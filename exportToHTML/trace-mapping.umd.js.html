<html>
<head>
<title>trace-mapping.umd.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #0033b3;}
.s2 { color: #067d17;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
trace-mapping.umd.js</font>
</center></td></tr></table>
<pre><span class="s0">(</span><span class="s1">function </span><span class="s0">(global, factory) {</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">exports === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">module !== </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">factory(module, require(</span><span class="s2">'@jridgewell/resolve-uri'</span><span class="s0">), require(</span><span class="s2">'@jridgewell/sourcemap-codec'</span><span class="s0">));</span>
    <span class="s0">module.exports = def(module);</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">define === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; define.amd) {</span>
    <span class="s0">define([</span><span class="s2">'module'</span><span class="s0">, </span><span class="s2">'@jridgewell/resolve-uri'</span><span class="s0">, </span><span class="s2">'@jridgewell/sourcemap-codec'</span><span class="s0">], </span><span class="s1">function</span><span class="s0">(mod) {</span>
      <span class="s0">factory.apply(</span><span class="s1">this</span><span class="s0">, arguments);</span>
      <span class="s0">mod.exports = def(mod);</span>
    <span class="s0">});</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s1">const </span><span class="s0">mod = { exports: {} };</span>
    <span class="s0">factory(mod, global.resolveURI, global.sourcemapCodec);</span>
    <span class="s0">global = </span><span class="s1">typeof </span><span class="s0">globalThis !== </span><span class="s2">'undefined' </span><span class="s0">? globalThis : global || self;</span>
    <span class="s0">global.traceMapping = def(mod);</span>
  <span class="s0">}</span>
  <span class="s1">function </span><span class="s0">def(m) { </span><span class="s1">return </span><span class="s2">'default' </span><span class="s1">in </span><span class="s0">m.exports ? m.exports.default : m.exports; }</span>
<span class="s0">})(</span><span class="s1">this</span><span class="s0">, (</span><span class="s1">function </span><span class="s0">(module, require_resolveURI, require_sourcemapCodec) {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">__create = Object.create;</span>
<span class="s1">var </span><span class="s0">__defProp = Object.defineProperty;</span>
<span class="s1">var </span><span class="s0">__getOwnPropDesc = Object.getOwnPropertyDescriptor;</span>
<span class="s1">var </span><span class="s0">__getOwnPropNames = Object.getOwnPropertyNames;</span>
<span class="s1">var </span><span class="s0">__getProtoOf = Object.getPrototypeOf;</span>
<span class="s1">var </span><span class="s0">__hasOwnProp = Object.prototype.hasOwnProperty;</span>
<span class="s1">var </span><span class="s0">__commonJS = (cb, mod) =&gt; </span><span class="s1">function </span><span class="s0">__require() {</span>
  <span class="s1">return </span><span class="s0">mod || (</span><span class="s3">0</span><span class="s0">, cb[__getOwnPropNames(cb)[</span><span class="s3">0</span><span class="s0">]])((mod = { exports: {} }).exports, mod), mod.exports;</span>
<span class="s0">};</span>
<span class="s1">var </span><span class="s0">__export = (target, all) =&gt; {</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)</span>
    <span class="s0">__defProp(target, name, { get: all[name], enumerable: </span><span class="s1">true </span><span class="s0">});</span>
<span class="s0">};</span>
<span class="s1">var </span><span class="s0">__copyProps = (to, from, except, desc) =&gt; {</span>
  <span class="s1">if </span><span class="s0">(from &amp;&amp; </span><span class="s1">typeof </span><span class="s0">from === </span><span class="s2">&quot;object&quot; </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">from === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">key of __getOwnPropNames(from))</span>
      <span class="s1">if </span><span class="s0">(!__hasOwnProp.call(to, key) &amp;&amp; key !== except)</span>
        <span class="s0">__defProp(to, key, { get: () =&gt; from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });</span>
  <span class="s0">}</span>
  <span class="s1">return </span><span class="s0">to;</span>
<span class="s0">};</span>
<span class="s1">var </span><span class="s0">__toESM = (mod, isNodeMode, target) =&gt; (target = mod != </span><span class="s1">null </span><span class="s0">? __create(__getProtoOf(mod)) : {}, __copyProps(</span>
  <span class="s4">// If the importer is in node compatibility mode or this is not an ESM</span>
  <span class="s4">// file that has been converted to a CommonJS file using a Babel-</span>
  <span class="s4">// compatible transform (i.e. &quot;__esModule&quot; has not been set), then set</span>
  <span class="s4">// &quot;default&quot; to the CommonJS &quot;module.exports&quot; for node compatibility.</span>
  <span class="s0">isNodeMode || !mod || !mod.__esModule ? __defProp(target, </span><span class="s2">&quot;default&quot;</span><span class="s0">, { value: mod, enumerable: </span><span class="s1">true </span><span class="s0">}) : target,</span>
  <span class="s0">mod</span>
<span class="s0">));</span>
<span class="s1">var </span><span class="s0">__toCommonJS = (mod) =&gt; __copyProps(__defProp({}, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, { value: </span><span class="s1">true </span><span class="s0">}), mod);</span>

<span class="s4">// umd:@jridgewell/sourcemap-codec</span>
<span class="s1">var </span><span class="s0">require_sourcemap_codec = __commonJS({</span>
  <span class="s2">&quot;umd:@jridgewell/sourcemap-codec&quot;</span><span class="s0">(exports, module2) {</span>
    <span class="s0">module2.exports = require_sourcemapCodec;</span>
  <span class="s0">}</span>
<span class="s0">});</span>

<span class="s4">// umd:@jridgewell/resolve-uri</span>
<span class="s1">var </span><span class="s0">require_resolve_uri = __commonJS({</span>
  <span class="s2">&quot;umd:@jridgewell/resolve-uri&quot;</span><span class="s0">(exports, module2) {</span>
    <span class="s0">module2.exports = require_resolveURI;</span>
  <span class="s0">}</span>
<span class="s0">});</span>

<span class="s4">// src/trace-mapping.ts</span>
<span class="s1">var </span><span class="s0">trace_mapping_exports = {};</span>
<span class="s0">__export(trace_mapping_exports, {</span>
  <span class="s0">AnyMap: () =&gt; FlattenMap,</span>
  <span class="s0">FlattenMap: () =&gt; FlattenMap,</span>
  <span class="s0">GREATEST_LOWER_BOUND: () =&gt; GREATEST_LOWER_BOUND,</span>
  <span class="s0">LEAST_UPPER_BOUND: () =&gt; LEAST_UPPER_BOUND,</span>
  <span class="s0">TraceMap: () =&gt; TraceMap,</span>
  <span class="s0">allGeneratedPositionsFor: () =&gt; allGeneratedPositionsFor,</span>
  <span class="s0">decodedMap: () =&gt; decodedMap,</span>
  <span class="s0">decodedMappings: () =&gt; decodedMappings,</span>
  <span class="s0">eachMapping: () =&gt; eachMapping,</span>
  <span class="s0">encodedMap: () =&gt; encodedMap,</span>
  <span class="s0">encodedMappings: () =&gt; encodedMappings,</span>
  <span class="s0">generatedPositionFor: () =&gt; generatedPositionFor,</span>
  <span class="s0">isIgnored: () =&gt; isIgnored,</span>
  <span class="s0">originalPositionFor: () =&gt; originalPositionFor,</span>
  <span class="s0">presortedDecodedMap: () =&gt; presortedDecodedMap,</span>
  <span class="s0">sourceContentFor: () =&gt; sourceContentFor,</span>
  <span class="s0">traceSegment: () =&gt; traceSegment</span>
<span class="s0">});</span>
<span class="s0">module.exports = __toCommonJS(trace_mapping_exports);</span>
<span class="s1">var </span><span class="s0">import_sourcemap_codec = __toESM(require_sourcemap_codec());</span>

<span class="s4">// src/resolve.ts</span>
<span class="s1">var </span><span class="s0">import_resolve_uri = __toESM(require_resolve_uri());</span>

<span class="s4">// src/strip-filename.ts</span>
<span class="s1">function </span><span class="s0">stripFilename(path) {</span>
  <span class="s1">if </span><span class="s0">(!path) </span><span class="s1">return </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
  <span class="s1">const </span><span class="s0">index = path.lastIndexOf(</span><span class="s2">&quot;/&quot;</span><span class="s0">);</span>
  <span class="s1">return </span><span class="s0">path.slice(</span><span class="s3">0</span><span class="s0">, index + </span><span class="s3">1</span><span class="s0">);</span>
<span class="s0">}</span>

<span class="s4">// src/resolve.ts</span>
<span class="s1">function </span><span class="s0">resolver(mapUrl, sourceRoot) {</span>
  <span class="s1">const </span><span class="s0">from = stripFilename(mapUrl);</span>
  <span class="s1">const </span><span class="s0">prefix = sourceRoot ? sourceRoot + </span><span class="s2">&quot;/&quot; </span><span class="s0">: </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
  <span class="s1">return </span><span class="s0">(source) =&gt; (</span><span class="s3">0</span><span class="s0">, import_resolve_uri.default)(prefix + (source || </span><span class="s2">&quot;&quot;</span><span class="s0">), from);</span>
<span class="s0">}</span>

<span class="s4">// src/sourcemap-segment.ts</span>
<span class="s1">var </span><span class="s0">COLUMN = </span><span class="s3">0</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">SOURCES_INDEX = </span><span class="s3">1</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">SOURCE_LINE = </span><span class="s3">2</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">SOURCE_COLUMN = </span><span class="s3">3</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">NAMES_INDEX = </span><span class="s3">4</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">REV_GENERATED_LINE = </span><span class="s3">1</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">REV_GENERATED_COLUMN = </span><span class="s3">2</span><span class="s0">;</span>

<span class="s4">// src/sort.ts</span>
<span class="s1">function </span><span class="s0">maybeSort(mappings, owned) {</span>
  <span class="s1">const </span><span class="s0">unsortedIndex = nextUnsortedSegmentLine(mappings, </span><span class="s3">0</span><span class="s0">);</span>
  <span class="s1">if </span><span class="s0">(unsortedIndex === mappings.length) </span><span class="s1">return </span><span class="s0">mappings;</span>
  <span class="s1">if </span><span class="s0">(!owned) mappings = mappings.slice();</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = unsortedIndex; i &lt; mappings.length; i = nextUnsortedSegmentLine(mappings, i + </span><span class="s3">1</span><span class="s0">)) {</span>
    <span class="s0">mappings[i] = sortSegments(mappings[i], owned);</span>
  <span class="s0">}</span>
  <span class="s1">return </span><span class="s0">mappings;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">nextUnsortedSegmentLine(mappings, start) {</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = start; i &lt; mappings.length; i++) {</span>
    <span class="s1">if </span><span class="s0">(!isSorted(mappings[i])) </span><span class="s1">return </span><span class="s0">i;</span>
  <span class="s0">}</span>
  <span class="s1">return </span><span class="s0">mappings.length;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">isSorted(line) {</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">j = </span><span class="s3">1</span><span class="s0">; j &lt; line.length; j++) {</span>
    <span class="s1">if </span><span class="s0">(line[j][COLUMN] &lt; line[j - </span><span class="s3">1</span><span class="s0">][COLUMN]) {</span>
      <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
  <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">sortSegments(line, owned) {</span>
  <span class="s1">if </span><span class="s0">(!owned) line = line.slice();</span>
  <span class="s1">return </span><span class="s0">line.sort(sortComparator);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">sortComparator(a, b) {</span>
  <span class="s1">return </span><span class="s0">a[COLUMN] - b[COLUMN];</span>
<span class="s0">}</span>

<span class="s4">// src/by-source.ts</span>
<span class="s1">function </span><span class="s0">buildBySources(decoded, memos) {</span>
  <span class="s1">const </span><span class="s0">sources = memos.map(() =&gt; []);</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; decoded.length; i++) {</span>
    <span class="s1">const </span><span class="s0">line = decoded[i];</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">j = </span><span class="s3">0</span><span class="s0">; j &lt; line.length; j++) {</span>
      <span class="s1">const </span><span class="s0">seg = line[j];</span>
      <span class="s1">if </span><span class="s0">(seg.length === </span><span class="s3">1</span><span class="s0">) </span><span class="s1">continue</span><span class="s0">;</span>
      <span class="s1">const </span><span class="s0">sourceIndex2 = seg[SOURCES_INDEX];</span>
      <span class="s1">const </span><span class="s0">sourceLine = seg[SOURCE_LINE];</span>
      <span class="s1">const </span><span class="s0">sourceColumn = seg[SOURCE_COLUMN];</span>
      <span class="s1">const </span><span class="s0">source = sources[sourceIndex2];</span>
      <span class="s1">const </span><span class="s0">segs = source[sourceLine] || (source[sourceLine] = []);</span>
      <span class="s0">segs.push([sourceColumn, i, seg[COLUMN]]);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; sources.length; i++) {</span>
    <span class="s1">const </span><span class="s0">source = sources[i];</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">j = </span><span class="s3">0</span><span class="s0">; j &lt; source.length; j++) {</span>
      <span class="s1">const </span><span class="s0">line = source[j];</span>
      <span class="s1">if </span><span class="s0">(line) line.sort(sortComparator);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
  <span class="s1">return </span><span class="s0">sources;</span>
<span class="s0">}</span>

<span class="s4">// src/binary-search.ts</span>
<span class="s1">var </span><span class="s0">found = </span><span class="s1">false</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">binarySearch(haystack, needle, low, high) {</span>
  <span class="s1">while </span><span class="s0">(low &lt;= high) {</span>
    <span class="s1">const </span><span class="s0">mid = low + (high - low &gt;&gt; </span><span class="s3">1</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">cmp = haystack[mid][COLUMN] - needle;</span>
    <span class="s1">if </span><span class="s0">(cmp === </span><span class="s3">0</span><span class="s0">) {</span>
      <span class="s0">found = </span><span class="s1">true</span><span class="s0">;</span>
      <span class="s1">return </span><span class="s0">mid;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(cmp &lt; </span><span class="s3">0</span><span class="s0">) {</span>
      <span class="s0">low = mid + </span><span class="s3">1</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">high = mid - </span><span class="s3">1</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
  <span class="s0">found = </span><span class="s1">false</span><span class="s0">;</span>
  <span class="s1">return </span><span class="s0">low - </span><span class="s3">1</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">upperBound(haystack, needle, index) {</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = index + </span><span class="s3">1</span><span class="s0">; i &lt; haystack.length; index = i++) {</span>
    <span class="s1">if </span><span class="s0">(haystack[i][COLUMN] !== needle) </span><span class="s1">break</span><span class="s0">;</span>
  <span class="s0">}</span>
  <span class="s1">return </span><span class="s0">index;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">lowerBound(haystack, needle, index) {</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = index - </span><span class="s3">1</span><span class="s0">; i &gt;= </span><span class="s3">0</span><span class="s0">; index = i--) {</span>
    <span class="s1">if </span><span class="s0">(haystack[i][COLUMN] !== needle) </span><span class="s1">break</span><span class="s0">;</span>
  <span class="s0">}</span>
  <span class="s1">return </span><span class="s0">index;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">memoizedState() {</span>
  <span class="s1">return </span><span class="s0">{</span>
    <span class="s0">lastKey: -</span><span class="s3">1</span><span class="s0">,</span>
    <span class="s0">lastNeedle: -</span><span class="s3">1</span><span class="s0">,</span>
    <span class="s0">lastIndex: -</span><span class="s3">1</span>
  <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">memoizedBinarySearch(haystack, needle, state, key) {</span>
  <span class="s1">const </span><span class="s0">{ lastKey, lastNeedle, lastIndex } = state;</span>
  <span class="s1">let </span><span class="s0">low = </span><span class="s3">0</span><span class="s0">;</span>
  <span class="s1">let </span><span class="s0">high = haystack.length - </span><span class="s3">1</span><span class="s0">;</span>
  <span class="s1">if </span><span class="s0">(key === lastKey) {</span>
    <span class="s1">if </span><span class="s0">(needle === lastNeedle) {</span>
      <span class="s0">found = lastIndex !== -</span><span class="s3">1 </span><span class="s0">&amp;&amp; haystack[lastIndex][COLUMN] === needle;</span>
      <span class="s1">return </span><span class="s0">lastIndex;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(needle &gt;= lastNeedle) {</span>
      <span class="s0">low = lastIndex === -</span><span class="s3">1 </span><span class="s0">? </span><span class="s3">0 </span><span class="s0">: lastIndex;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">high = lastIndex;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
  <span class="s0">state.lastKey = key;</span>
  <span class="s0">state.lastNeedle = needle;</span>
  <span class="s1">return </span><span class="s0">state.lastIndex = binarySearch(haystack, needle, low, high);</span>
<span class="s0">}</span>

<span class="s4">// src/types.ts</span>
<span class="s1">function </span><span class="s0">parse(map) {</span>
  <span class="s1">return typeof </span><span class="s0">map === </span><span class="s2">&quot;string&quot; </span><span class="s0">? JSON.parse(map) : map;</span>
<span class="s0">}</span>

<span class="s4">// src/flatten-map.ts</span>
<span class="s1">var </span><span class="s0">FlattenMap = </span><span class="s1">function</span><span class="s0">(map, mapUrl) {</span>
  <span class="s1">const </span><span class="s0">parsed = parse(map);</span>
  <span class="s1">if </span><span class="s0">(!(</span><span class="s2">&quot;sections&quot; </span><span class="s1">in </span><span class="s0">parsed)) {</span>
    <span class="s1">return new </span><span class="s0">TraceMap(parsed, mapUrl);</span>
  <span class="s0">}</span>
  <span class="s1">const </span><span class="s0">mappings = [];</span>
  <span class="s1">const </span><span class="s0">sources = [];</span>
  <span class="s1">const </span><span class="s0">sourcesContent = [];</span>
  <span class="s1">const </span><span class="s0">names = [];</span>
  <span class="s1">const </span><span class="s0">ignoreList = [];</span>
  <span class="s0">recurse(</span>
    <span class="s0">parsed,</span>
    <span class="s0">mapUrl,</span>
    <span class="s0">mappings,</span>
    <span class="s0">sources,</span>
    <span class="s0">sourcesContent,</span>
    <span class="s0">names,</span>
    <span class="s0">ignoreList,</span>
    <span class="s3">0</span><span class="s0">,</span>
    <span class="s3">0</span><span class="s0">,</span>
    <span class="s0">Infinity,</span>
    <span class="s0">Infinity</span>
  <span class="s0">);</span>
  <span class="s1">const </span><span class="s0">joined = {</span>
    <span class="s0">version: </span><span class="s3">3</span><span class="s0">,</span>
    <span class="s0">file: parsed.file,</span>
    <span class="s0">names,</span>
    <span class="s0">sources,</span>
    <span class="s0">sourcesContent,</span>
    <span class="s0">mappings,</span>
    <span class="s0">ignoreList</span>
  <span class="s0">};</span>
  <span class="s1">return </span><span class="s0">presortedDecodedMap(joined);</span>
<span class="s0">};</span>
<span class="s1">function </span><span class="s0">recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {</span>
  <span class="s1">const </span><span class="s0">{ sections } = input;</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; sections.length; i++) {</span>
    <span class="s1">const </span><span class="s0">{ map, offset } = sections[i];</span>
    <span class="s1">let </span><span class="s0">sl = stopLine;</span>
    <span class="s1">let </span><span class="s0">sc = stopColumn;</span>
    <span class="s1">if </span><span class="s0">(i + </span><span class="s3">1 </span><span class="s0">&lt; sections.length) {</span>
      <span class="s1">const </span><span class="s0">nextOffset = sections[i + </span><span class="s3">1</span><span class="s0">].offset;</span>
      <span class="s0">sl = Math.min(stopLine, lineOffset + nextOffset.line);</span>
      <span class="s1">if </span><span class="s0">(sl === stopLine) {</span>
        <span class="s0">sc = Math.min(stopColumn, columnOffset + nextOffset.column);</span>
      <span class="s0">} </span><span class="s1">else if </span><span class="s0">(sl &lt; stopLine) {</span>
        <span class="s0">sc = columnOffset + nextOffset.column;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">addSection(</span>
      <span class="s0">map,</span>
      <span class="s0">mapUrl,</span>
      <span class="s0">mappings,</span>
      <span class="s0">sources,</span>
      <span class="s0">sourcesContent,</span>
      <span class="s0">names,</span>
      <span class="s0">ignoreList,</span>
      <span class="s0">lineOffset + offset.line,</span>
      <span class="s0">columnOffset + offset.column,</span>
      <span class="s0">sl,</span>
      <span class="s0">sc</span>
    <span class="s0">);</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {</span>
  <span class="s1">const </span><span class="s0">parsed = parse(input);</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;sections&quot; </span><span class="s1">in </span><span class="s0">parsed) </span><span class="s1">return </span><span class="s0">recurse(...arguments);</span>
  <span class="s1">const </span><span class="s0">map = </span><span class="s1">new </span><span class="s0">TraceMap(parsed, mapUrl);</span>
  <span class="s1">const </span><span class="s0">sourcesOffset = sources.length;</span>
  <span class="s1">const </span><span class="s0">namesOffset = names.length;</span>
  <span class="s1">const </span><span class="s0">decoded = decodedMappings(map);</span>
  <span class="s1">const </span><span class="s0">{ resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;</span>
  <span class="s0">append(sources, resolvedSources);</span>
  <span class="s0">append(names, map.names);</span>
  <span class="s1">if </span><span class="s0">(contents) append(sourcesContent, contents);</span>
  <span class="s1">else for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; resolvedSources.length; i++) sourcesContent.push(</span><span class="s1">null</span><span class="s0">);</span>
  <span class="s1">if </span><span class="s0">(ignores) </span><span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; ignores.length; i++) ignoreList.push(ignores[i] + sourcesOffset);</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; decoded.length; i++) {</span>
    <span class="s1">const </span><span class="s0">lineI = lineOffset + i;</span>
    <span class="s1">if </span><span class="s0">(lineI &gt; stopLine) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">out = getLine(mappings, lineI);</span>
    <span class="s1">const </span><span class="s0">cOffset = i === </span><span class="s3">0 </span><span class="s0">? columnOffset : </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">line = decoded[i];</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">j = </span><span class="s3">0</span><span class="s0">; j &lt; line.length; j++) {</span>
      <span class="s1">const </span><span class="s0">seg = line[j];</span>
      <span class="s1">const </span><span class="s0">column = cOffset + seg[COLUMN];</span>
      <span class="s1">if </span><span class="s0">(lineI === stopLine &amp;&amp; column &gt;= stopColumn) </span><span class="s1">return</span><span class="s0">;</span>
      <span class="s1">if </span><span class="s0">(seg.length === </span><span class="s3">1</span><span class="s0">) {</span>
        <span class="s0">out.push([column]);</span>
        <span class="s1">continue</span><span class="s0">;</span>
      <span class="s0">}</span>
      <span class="s1">const </span><span class="s0">sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];</span>
      <span class="s1">const </span><span class="s0">sourceLine = seg[SOURCE_LINE];</span>
      <span class="s1">const </span><span class="s0">sourceColumn = seg[SOURCE_COLUMN];</span>
      <span class="s0">out.push(</span>
        <span class="s0">seg.length === </span><span class="s3">4 </span><span class="s0">? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]</span>
      <span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">append(arr, other) {</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; other.length; i++) arr.push(other[i]);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getLine(arr, index) {</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = arr.length; i &lt;= index; i++) arr[i] = [];</span>
  <span class="s1">return </span><span class="s0">arr[index];</span>
<span class="s0">}</span>

<span class="s4">// src/trace-mapping.ts</span>
<span class="s1">var </span><span class="s0">LINE_GTR_ZERO = </span><span class="s2">&quot;`line` must be greater than 0 (lines start at line 1)&quot;</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">COL_GTR_EQ_ZERO = </span><span class="s2">&quot;`column` must be greater than or equal to 0 (columns start at column 0)&quot;</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">LEAST_UPPER_BOUND = -</span><span class="s3">1</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">GREATEST_LOWER_BOUND = </span><span class="s3">1</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">TraceMap = </span><span class="s1">class </span><span class="s0">{</span>
  <span class="s0">constructor(map, mapUrl) {</span>
    <span class="s1">const </span><span class="s0">isString = </span><span class="s1">typeof </span><span class="s0">map === </span><span class="s2">&quot;string&quot;</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(!isString &amp;&amp; map._decodedMemo) </span><span class="s1">return </span><span class="s0">map;</span>
    <span class="s1">const </span><span class="s0">parsed = parse(map);</span>
    <span class="s1">const </span><span class="s0">{ version, file, names, sourceRoot, sources, sourcesContent } = parsed;</span>
    <span class="s1">this</span><span class="s0">.version = version;</span>
    <span class="s1">this</span><span class="s0">.file = file;</span>
    <span class="s1">this</span><span class="s0">.names = names || [];</span>
    <span class="s1">this</span><span class="s0">.sourceRoot = sourceRoot;</span>
    <span class="s1">this</span><span class="s0">.sources = sources;</span>
    <span class="s1">this</span><span class="s0">.sourcesContent = sourcesContent;</span>
    <span class="s1">this</span><span class="s0">.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || </span><span class="s1">void </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">resolve = resolver(mapUrl, sourceRoot);</span>
    <span class="s1">this</span><span class="s0">.resolvedSources = sources.map(resolve);</span>
    <span class="s1">const </span><span class="s0">{ mappings } = parsed;</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">mappings === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
      <span class="s1">this</span><span class="s0">._encoded = mappings;</span>
      <span class="s1">this</span><span class="s0">._decoded = </span><span class="s1">void </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(Array.isArray(mappings)) {</span>
      <span class="s1">this</span><span class="s0">._encoded = </span><span class="s1">void </span><span class="s3">0</span><span class="s0">;</span>
      <span class="s1">this</span><span class="s0">._decoded = maybeSort(mappings, isString);</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(parsed.sections) {</span>
      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">`TraceMap passed sectioned source map, please use FlattenMap export instead`</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">`invalid source map: </span><span class="s0">${JSON.stringify(parsed)}</span><span class="s2">`</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">this</span><span class="s0">._decodedMemo = memoizedState();</span>
    <span class="s1">this</span><span class="s0">._bySources = </span><span class="s1">void </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s1">this</span><span class="s0">._bySourceMemos = </span><span class="s1">void </span><span class="s3">0</span><span class="s0">;</span>
  <span class="s0">}</span>
<span class="s0">};</span>
<span class="s1">function </span><span class="s0">cast(map) {</span>
  <span class="s1">return </span><span class="s0">map;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">encodedMappings(map) {</span>
  <span class="s1">var </span><span class="s0">_a, _b;</span>
  <span class="s1">return </span><span class="s0">(_b = (_a = cast(map))._encoded) != </span><span class="s1">null </span><span class="s0">? _b : _a._encoded = (</span><span class="s3">0</span><span class="s0">, import_sourcemap_codec.encode)(cast(map)._decoded);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">decodedMappings(map) {</span>
  <span class="s1">var </span><span class="s0">_a;</span>
  <span class="s1">return </span><span class="s0">(_a = cast(map))._decoded || (_a._decoded = (</span><span class="s3">0</span><span class="s0">, import_sourcemap_codec.decode)(cast(map)._encoded));</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">traceSegment(map, line, column) {</span>
  <span class="s1">const </span><span class="s0">decoded = decodedMappings(map);</span>
  <span class="s1">if </span><span class="s0">(line &gt;= decoded.length) </span><span class="s1">return null</span><span class="s0">;</span>
  <span class="s1">const </span><span class="s0">segments = decoded[line];</span>
  <span class="s1">const </span><span class="s0">index = traceSegmentInternal(</span>
    <span class="s0">segments,</span>
    <span class="s0">cast(map)._decodedMemo,</span>
    <span class="s0">line,</span>
    <span class="s0">column,</span>
    <span class="s0">GREATEST_LOWER_BOUND</span>
  <span class="s0">);</span>
  <span class="s1">return </span><span class="s0">index === -</span><span class="s3">1 </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: segments[index];</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">originalPositionFor(map, needle) {</span>
  <span class="s1">let </span><span class="s0">{ line, column, bias } = needle;</span>
  <span class="s0">line--;</span>
  <span class="s1">if </span><span class="s0">(line &lt; </span><span class="s3">0</span><span class="s0">) </span><span class="s1">throw new </span><span class="s0">Error(LINE_GTR_ZERO);</span>
  <span class="s1">if </span><span class="s0">(column &lt; </span><span class="s3">0</span><span class="s0">) </span><span class="s1">throw new </span><span class="s0">Error(COL_GTR_EQ_ZERO);</span>
  <span class="s1">const </span><span class="s0">decoded = decodedMappings(map);</span>
  <span class="s1">if </span><span class="s0">(line &gt;= decoded.length) </span><span class="s1">return </span><span class="s0">OMapping(</span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
  <span class="s1">const </span><span class="s0">segments = decoded[line];</span>
  <span class="s1">const </span><span class="s0">index = traceSegmentInternal(</span>
    <span class="s0">segments,</span>
    <span class="s0">cast(map)._decodedMemo,</span>
    <span class="s0">line,</span>
    <span class="s0">column,</span>
    <span class="s0">bias || GREATEST_LOWER_BOUND</span>
  <span class="s0">);</span>
  <span class="s1">if </span><span class="s0">(index === -</span><span class="s3">1</span><span class="s0">) </span><span class="s1">return </span><span class="s0">OMapping(</span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
  <span class="s1">const </span><span class="s0">segment = segments[index];</span>
  <span class="s1">if </span><span class="s0">(segment.length === </span><span class="s3">1</span><span class="s0">) </span><span class="s1">return </span><span class="s0">OMapping(</span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
  <span class="s1">const </span><span class="s0">{ names, resolvedSources } = map;</span>
  <span class="s1">return </span><span class="s0">OMapping(</span>
    <span class="s0">resolvedSources[segment[SOURCES_INDEX]],</span>
    <span class="s0">segment[SOURCE_LINE] + </span><span class="s3">1</span><span class="s0">,</span>
    <span class="s0">segment[SOURCE_COLUMN],</span>
    <span class="s0">segment.length === </span><span class="s3">5 </span><span class="s0">? names[segment[NAMES_INDEX]] : </span><span class="s1">null</span>
  <span class="s0">);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">generatedPositionFor(map, needle) {</span>
  <span class="s1">const </span><span class="s0">{ source, line, column, bias } = needle;</span>
  <span class="s1">return </span><span class="s0">generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, </span><span class="s1">false</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">allGeneratedPositionsFor(map, needle) {</span>
  <span class="s1">const </span><span class="s0">{ source, line, column, bias } = needle;</span>
  <span class="s1">return </span><span class="s0">generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, </span><span class="s1">true</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">eachMapping(map, cb) {</span>
  <span class="s1">const </span><span class="s0">decoded = decodedMappings(map);</span>
  <span class="s1">const </span><span class="s0">{ names, resolvedSources } = map;</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; decoded.length; i++) {</span>
    <span class="s1">const </span><span class="s0">line = decoded[i];</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">j = </span><span class="s3">0</span><span class="s0">; j &lt; line.length; j++) {</span>
      <span class="s1">const </span><span class="s0">seg = line[j];</span>
      <span class="s1">const </span><span class="s0">generatedLine = i + </span><span class="s3">1</span><span class="s0">;</span>
      <span class="s1">const </span><span class="s0">generatedColumn = seg[</span><span class="s3">0</span><span class="s0">];</span>
      <span class="s1">let </span><span class="s0">source = </span><span class="s1">null</span><span class="s0">;</span>
      <span class="s1">let </span><span class="s0">originalLine = </span><span class="s1">null</span><span class="s0">;</span>
      <span class="s1">let </span><span class="s0">originalColumn = </span><span class="s1">null</span><span class="s0">;</span>
      <span class="s1">let </span><span class="s0">name = </span><span class="s1">null</span><span class="s0">;</span>
      <span class="s1">if </span><span class="s0">(seg.length !== </span><span class="s3">1</span><span class="s0">) {</span>
        <span class="s0">source = resolvedSources[seg[</span><span class="s3">1</span><span class="s0">]];</span>
        <span class="s0">originalLine = seg[</span><span class="s3">2</span><span class="s0">] + </span><span class="s3">1</span><span class="s0">;</span>
        <span class="s0">originalColumn = seg[</span><span class="s3">3</span><span class="s0">];</span>
      <span class="s0">}</span>
      <span class="s1">if </span><span class="s0">(seg.length === </span><span class="s3">5</span><span class="s0">) name = names[seg[</span><span class="s3">4</span><span class="s0">]];</span>
      <span class="s0">cb({</span>
        <span class="s0">generatedLine,</span>
        <span class="s0">generatedColumn,</span>
        <span class="s0">source,</span>
        <span class="s0">originalLine,</span>
        <span class="s0">originalColumn,</span>
        <span class="s0">name</span>
      <span class="s0">});</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">sourceIndex(map, source) {</span>
  <span class="s1">const </span><span class="s0">{ sources, resolvedSources } = map;</span>
  <span class="s1">let </span><span class="s0">index = sources.indexOf(source);</span>
  <span class="s1">if </span><span class="s0">(index === -</span><span class="s3">1</span><span class="s0">) index = resolvedSources.indexOf(source);</span>
  <span class="s1">return </span><span class="s0">index;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">sourceContentFor(map, source) {</span>
  <span class="s1">const </span><span class="s0">{ sourcesContent } = map;</span>
  <span class="s1">if </span><span class="s0">(sourcesContent == </span><span class="s1">null</span><span class="s0">) </span><span class="s1">return null</span><span class="s0">;</span>
  <span class="s1">const </span><span class="s0">index = sourceIndex(map, source);</span>
  <span class="s1">return </span><span class="s0">index === -</span><span class="s3">1 </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: sourcesContent[index];</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">isIgnored(map, source) {</span>
  <span class="s1">const </span><span class="s0">{ ignoreList } = map;</span>
  <span class="s1">if </span><span class="s0">(ignoreList == </span><span class="s1">null</span><span class="s0">) </span><span class="s1">return false</span><span class="s0">;</span>
  <span class="s1">const </span><span class="s0">index = sourceIndex(map, source);</span>
  <span class="s1">return </span><span class="s0">index === -</span><span class="s3">1 </span><span class="s0">? </span><span class="s1">false </span><span class="s0">: ignoreList.includes(index);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">presortedDecodedMap(map, mapUrl) {</span>
  <span class="s1">const </span><span class="s0">tracer = </span><span class="s1">new </span><span class="s0">TraceMap(clone(map, []), mapUrl);</span>
  <span class="s0">cast(tracer)._decoded = map.mappings;</span>
  <span class="s1">return </span><span class="s0">tracer;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">decodedMap(map) {</span>
  <span class="s1">return </span><span class="s0">clone(map, decodedMappings(map));</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">encodedMap(map) {</span>
  <span class="s1">return </span><span class="s0">clone(map, encodedMappings(map));</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">clone(map, mappings) {</span>
  <span class="s1">return </span><span class="s0">{</span>
    <span class="s0">version: map.version,</span>
    <span class="s0">file: map.file,</span>
    <span class="s0">names: map.names,</span>
    <span class="s0">sourceRoot: map.sourceRoot,</span>
    <span class="s0">sources: map.sources,</span>
    <span class="s0">sourcesContent: map.sourcesContent,</span>
    <span class="s0">mappings,</span>
    <span class="s0">ignoreList: map.ignoreList || map.x_google_ignoreList</span>
  <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">OMapping(source, line, column, name) {</span>
  <span class="s1">return </span><span class="s0">{ source, line, column, name };</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">GMapping(line, column) {</span>
  <span class="s1">return </span><span class="s0">{ line, column };</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">traceSegmentInternal(segments, memo, line, column, bias) {</span>
  <span class="s1">let </span><span class="s0">index = memoizedBinarySearch(segments, column, memo, line);</span>
  <span class="s1">if </span><span class="s0">(found) {</span>
    <span class="s0">index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(bias === LEAST_UPPER_BOUND) index++;</span>
  <span class="s1">if </span><span class="s0">(index === -</span><span class="s3">1 </span><span class="s0">|| index === segments.length) </span><span class="s1">return </span><span class="s0">-</span><span class="s3">1</span><span class="s0">;</span>
  <span class="s1">return </span><span class="s0">index;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">sliceGeneratedPositions(segments, memo, line, column, bias) {</span>
  <span class="s1">let </span><span class="s0">min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);</span>
  <span class="s1">if </span><span class="s0">(!found &amp;&amp; bias === LEAST_UPPER_BOUND) min++;</span>
  <span class="s1">if </span><span class="s0">(min === -</span><span class="s3">1 </span><span class="s0">|| min === segments.length) </span><span class="s1">return </span><span class="s0">[];</span>
  <span class="s1">const </span><span class="s0">matchedColumn = found ? column : segments[min][COLUMN];</span>
  <span class="s1">if </span><span class="s0">(!found) min = lowerBound(segments, matchedColumn, min);</span>
  <span class="s1">const </span><span class="s0">max = upperBound(segments, matchedColumn, min);</span>
  <span class="s1">const </span><span class="s0">result = [];</span>
  <span class="s1">for </span><span class="s0">(; min &lt;= max; min++) {</span>
    <span class="s1">const </span><span class="s0">segment = segments[min];</span>
    <span class="s0">result.push(GMapping(segment[REV_GENERATED_LINE] + </span><span class="s3">1</span><span class="s0">, segment[REV_GENERATED_COLUMN]));</span>
  <span class="s0">}</span>
  <span class="s1">return </span><span class="s0">result;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">generatedPosition(map, source, line, column, bias, all) {</span>
  <span class="s1">var </span><span class="s0">_a, _b;</span>
  <span class="s0">line--;</span>
  <span class="s1">if </span><span class="s0">(line &lt; </span><span class="s3">0</span><span class="s0">) </span><span class="s1">throw new </span><span class="s0">Error(LINE_GTR_ZERO);</span>
  <span class="s1">if </span><span class="s0">(column &lt; </span><span class="s3">0</span><span class="s0">) </span><span class="s1">throw new </span><span class="s0">Error(COL_GTR_EQ_ZERO);</span>
  <span class="s1">const </span><span class="s0">{ sources, resolvedSources } = map;</span>
  <span class="s1">let </span><span class="s0">sourceIndex2 = sources.indexOf(source);</span>
  <span class="s1">if </span><span class="s0">(sourceIndex2 === -</span><span class="s3">1</span><span class="s0">) sourceIndex2 = resolvedSources.indexOf(source);</span>
  <span class="s1">if </span><span class="s0">(sourceIndex2 === -</span><span class="s3">1</span><span class="s0">) </span><span class="s1">return </span><span class="s0">all ? [] : GMapping(</span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
  <span class="s1">const </span><span class="s0">bySourceMemos = (_a = cast(map))._bySourceMemos || (_a._bySourceMemos = sources.map(memoizedState));</span>
  <span class="s1">const </span><span class="s0">generated = (_b = cast(map))._bySources || (_b._bySources = buildBySources(decodedMappings(map), bySourceMemos));</span>
  <span class="s1">const </span><span class="s0">segments = generated[sourceIndex2][line];</span>
  <span class="s1">if </span><span class="s0">(segments == </span><span class="s1">null</span><span class="s0">) </span><span class="s1">return </span><span class="s0">all ? [] : GMapping(</span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
  <span class="s1">const </span><span class="s0">memo = bySourceMemos[sourceIndex2];</span>
  <span class="s1">if </span><span class="s0">(all) </span><span class="s1">return </span><span class="s0">sliceGeneratedPositions(segments, memo, line, column, bias);</span>
  <span class="s1">const </span><span class="s0">index = traceSegmentInternal(segments, memo, line, column, bias);</span>
  <span class="s1">if </span><span class="s0">(index === -</span><span class="s3">1</span><span class="s0">) </span><span class="s1">return </span><span class="s0">GMapping(</span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
  <span class="s1">const </span><span class="s0">segment = segments[index];</span>
  <span class="s1">return </span><span class="s0">GMapping(segment[REV_GENERATED_LINE] + </span><span class="s3">1</span><span class="s0">, segment[REV_GENERATED_COLUMN]);</span>
<span class="s0">}</span>
<span class="s0">}));</span>
<span class="s4">//# sourceMappingURL=trace-mapping.umd.js.map</span>
</pre>
</body>
</html>