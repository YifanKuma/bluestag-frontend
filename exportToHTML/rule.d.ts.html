<html>
<head>
<title>Rule.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Rule.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">type { JSONSchema4 } from </span><span class="s2">'../json-schema'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { ParserServices, TSESTree } from </span><span class="s2">'../ts-estree'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { AST } from </span><span class="s2">'./AST'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { FlatConfig } from </span><span class="s2">'./Config'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { Linter } from </span><span class="s2">'./Linter'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { Scope } from </span><span class="s2">'./Scope'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { SourceCode } from </span><span class="s2">'./SourceCode'</span><span class="s1">;</span>
<span class="s0">export </span><span class="s1">type RuleRecommendation = </span><span class="s2">'recommended' </span><span class="s1">| </span><span class="s2">'strict' </span><span class="s1">| </span><span class="s2">'stylistic'</span><span class="s1">;</span>
<span class="s0">export interface </span><span class="s1">RuleRecommendationAcrossConfigs&lt;Options </span><span class="s0">extends </span><span class="s1">readonly unknown[]&gt; {</span>
    <span class="s1">recommended?: </span><span class="s0">true</span><span class="s1">;</span>
    <span class="s1">strict: Partial&lt;Options&gt;;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">RuleMetaDataDocs {</span>
    <span class="s3">/**</span>
     <span class="s3">* Concise description of the rule.</span>
     <span class="s3">*/</span>
    <span class="s1">description: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* The URL of the rule's docs.</span>
     <span class="s3">*/</span>
    <span class="s1">url?: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* Mark this rule as feature-frozen.</span>
     <span class="s3">*/</span>
    <span class="s1">frozen?: boolean;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">ExternalSpecifier {</span>
    <span class="s3">/**</span>
     <span class="s3">* Name of the referenced plugin / rule.</span>
     <span class="s3">*/</span>
    <span class="s1">name?: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* URL pointing to documentation for the plugin / rule.</span>
     <span class="s3">*/</span>
    <span class="s1">url?: string;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">ReplacedByInfo {</span>
    <span class="s3">/**</span>
     <span class="s3">* General message presented to the user, e.g. how to replace the rule</span>
     <span class="s3">*/</span>
    <span class="s1">message?: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* URL to more information about this replacement in general</span>
     <span class="s3">*/</span>
    <span class="s1">url?: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* Name should be &quot;eslint&quot; if the replacement is an ESLint core rule. Omit</span>
     <span class="s3">* the property if the replacement is in the same plugin.</span>
     <span class="s3">*/</span>
    <span class="s1">plugin?: ExternalSpecifier;</span>
    <span class="s3">/**</span>
     <span class="s3">* Name and documentation of the replacement rule</span>
     <span class="s3">*/</span>
    <span class="s1">rule?: ExternalSpecifier;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">DeprecatedInfo {</span>
    <span class="s3">/**</span>
     <span class="s3">* General message presented to the user, e.g. for the key rule why the rule</span>
     <span class="s3">* is deprecated or for info how to replace the rule.</span>
     <span class="s3">*/</span>
    <span class="s1">message?: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* URL to more information about this deprecation in general.</span>
     <span class="s3">*/</span>
    <span class="s1">url?: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* An empty array explicitly states that there is no replacement.</span>
     <span class="s3">*/</span>
    <span class="s1">replacedBy?: ReplacedByInfo[];</span>
    <span class="s3">/**</span>
     <span class="s3">* The package version since when the rule is deprecated (should use full</span>
     <span class="s3">* semver without a leading &quot;v&quot;).</span>
     <span class="s3">*/</span>
    <span class="s1">deprecatedSince?: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* The estimated version when the rule is removed (probably the next major</span>
     <span class="s3">* version). null means the rule is &quot;frozen&quot; (will be available but will not</span>
     <span class="s3">* be changed).</span>
     <span class="s3">*/</span>
    <span class="s1">availableUntil?: string | </span><span class="s0">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">RuleMetaData&lt;MessageIds </span><span class="s0">extends </span><span class="s1">string, PluginDocs = unknown, Options </span><span class="s0">extends </span><span class="s1">readonly unknown[] = []&gt; {</span>
    <span class="s3">/**</span>
     <span class="s3">* True if the rule is deprecated, false otherwise</span>
     <span class="s3">*/</span>
    <span class="s1">deprecated?: boolean | DeprecatedInfo;</span>
    <span class="s3">/**</span>
     <span class="s3">* Documentation for the rule</span>
     <span class="s3">*/</span>
    <span class="s1">docs?: PluginDocs &amp; RuleMetaDataDocs;</span>
    <span class="s3">/**</span>
     <span class="s3">* The fixer category. Omit if there is no fixer</span>
     <span class="s3">*/</span>
    <span class="s1">fixable?: </span><span class="s2">'code' </span><span class="s1">| </span><span class="s2">'whitespace'</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Specifies whether rules can return suggestions. Omit if there is no suggestions</span>
     <span class="s3">*/</span>
    <span class="s1">hasSuggestions?: boolean;</span>
    <span class="s3">/**</span>
     <span class="s3">* A map of messages which the rule can report.</span>
     <span class="s3">* The key is the messageId, and the string is the parameterised error string.</span>
     <span class="s3">* See: https://eslint.org/docs/developer-guide/working-with-rules#messageids</span>
     <span class="s3">*/</span>
    <span class="s1">messages: Record&lt;MessageIds, string&gt;;</span>
    <span class="s3">/**</span>
     <span class="s3">* The name of the rule this rule was replaced by, if it was deprecated.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@deprecated </span><span class="s3">since eslint 9.21.0, in favor of `RuleMetaData#deprecated.replacedBy`</span>
     <span class="s3">*/</span>
    <span class="s1">replacedBy?: readonly string[];</span>
    <span class="s3">/**</span>
     <span class="s3">* The options schema. Supply an empty array if there are no options.</span>
     <span class="s3">*/</span>
    <span class="s1">schema: JSONSchema4 | readonly JSONSchema4[];</span>
    <span class="s3">/**</span>
     <span class="s3">* The type of rule.</span>
     <span class="s3">* - `&quot;problem&quot;` means the rule is identifying code that either will cause an error or may cause a confusing behavior. Developers should consider this a high priority to resolve.</span>
     <span class="s3">* - `&quot;suggestion&quot;` means the rule is identifying something that could be done in a better way but no errors will occur if the code isn’t changed.</span>
     <span class="s3">* - `&quot;layout&quot;` means the rule cares primarily about whitespace, semicolons, commas, and parentheses, all the parts of the program that determine how the code looks rather than how it executes. These rules work on parts of the code that aren’t specified in the AST.</span>
     <span class="s3">*/</span>
    <span class="s1">type: </span><span class="s2">'layout' </span><span class="s1">| </span><span class="s2">'problem' </span><span class="s1">| </span><span class="s2">'suggestion'</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Specifies default options for the rule. If present, any user-provided options in their config will be merged on top of them recursively.</span>
     <span class="s3">* This merging will be applied directly to `context.options`.</span>
     <span class="s3">* If you want backwards-compatible support for earlier ESLint version, consider using the top-level `defaultOptions` instead.</span>
     <span class="s3">*</span>
     <span class="s3">* since ESLint 9.15.0</span>
     <span class="s3">*/</span>
    <span class="s1">defaultOptions?: Options;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">RuleMetaDataWithDocs&lt;MessageIds </span><span class="s0">extends </span><span class="s1">string, PluginDocs = unknown, Options </span><span class="s0">extends </span><span class="s1">readonly unknown[] = []&gt; </span><span class="s0">extends </span><span class="s1">RuleMetaData&lt;MessageIds, PluginDocs, Options&gt; {</span>
    <span class="s3">/**</span>
     <span class="s3">* Documentation for the rule</span>
     <span class="s3">*/</span>
    <span class="s1">docs: PluginDocs &amp; RuleMetaDataDocs;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">RuleFix {</span>
    <span class="s1">range: Readonly&lt;AST.Range&gt;;</span>
    <span class="s1">text: string;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">RuleFixer {</span>
    <span class="s1">insertTextAfter(nodeOrToken: TSESTree.Node | TSESTree.Token, text: string): RuleFix;</span>
    <span class="s1">insertTextAfterRange(range: Readonly&lt;AST.Range&gt;, text: string): RuleFix;</span>
    <span class="s1">insertTextBefore(nodeOrToken: TSESTree.Node | TSESTree.Token, text: string): RuleFix;</span>
    <span class="s1">insertTextBeforeRange(range: Readonly&lt;AST.Range&gt;, text: string): RuleFix;</span>
    <span class="s1">remove(nodeOrToken: TSESTree.Node | TSESTree.Token): RuleFix;</span>
    <span class="s1">removeRange(range: Readonly&lt;AST.Range&gt;): RuleFix;</span>
    <span class="s1">replaceText(nodeOrToken: TSESTree.Node | TSESTree.Token, text: string): RuleFix;</span>
    <span class="s1">replaceTextRange(range: Readonly&lt;AST.Range&gt;, text: string): RuleFix;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">SuggestionReportDescriptor&lt;MessageIds </span><span class="s0">extends </span><span class="s1">string&gt; </span><span class="s0">extends </span><span class="s1">Omit&lt;ReportDescriptorBase&lt;MessageIds&gt;, </span><span class="s2">'fix'</span><span class="s1">&gt; {</span>
    <span class="s1">readonly fix: ReportFixFunction;</span>
<span class="s1">}</span>
<span class="s0">export </span><span class="s1">type ReportFixFunction = (fixer: RuleFixer) =&gt; IterableIterator&lt;RuleFix&gt; | readonly RuleFix[] | RuleFix | </span><span class="s0">null</span><span class="s1">;</span>
<span class="s0">export </span><span class="s1">type ReportSuggestionArray&lt;MessageIds </span><span class="s0">extends </span><span class="s1">string&gt; = SuggestionReportDescriptor&lt;MessageIds&gt;[];</span>
<span class="s0">export </span><span class="s1">type ReportDescriptorMessageData = Readonly&lt;Record&lt;string, unknown&gt;&gt;;</span>
<span class="s0">interface </span><span class="s1">ReportDescriptorBase&lt;MessageIds </span><span class="s0">extends </span><span class="s1">string&gt; {</span>
    <span class="s3">/**</span>
     <span class="s3">* The parameters for the message string associated with `messageId`.</span>
     <span class="s3">*/</span>
    <span class="s1">readonly data?: ReportDescriptorMessageData;</span>
    <span class="s3">/**</span>
     <span class="s3">* The fixer function.</span>
     <span class="s3">*/</span>
    <span class="s1">readonly fix?: ReportFixFunction | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* The messageId which is being reported.</span>
     <span class="s3">*/</span>
    <span class="s1">readonly messageId: MessageIds;</span>
<span class="s1">}</span>
<span class="s0">interface </span><span class="s1">ReportDescriptorWithSuggestion&lt;MessageIds </span><span class="s0">extends </span><span class="s1">string&gt; </span><span class="s0">extends </span><span class="s1">ReportDescriptorBase&lt;MessageIds&gt; {</span>
    <span class="s3">/**</span>
     <span class="s3">* 6.7's Suggestions API</span>
     <span class="s3">*/</span>
    <span class="s1">readonly suggest?: Readonly&lt;ReportSuggestionArray&lt;MessageIds&gt;&gt; | </span><span class="s0">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">interface </span><span class="s1">ReportDescriptorNodeOptionalLoc {</span>
    <span class="s3">/**</span>
     <span class="s3">* An override of the location of the report</span>
     <span class="s3">*/</span>
    <span class="s1">readonly loc?: Readonly&lt;TSESTree.Position&gt; | Readonly&lt;TSESTree.SourceLocation&gt;;</span>
    <span class="s3">/**</span>
     <span class="s3">* The Node or AST Token which the report is being attached to</span>
     <span class="s3">*/</span>
    <span class="s1">readonly node: TSESTree.Node | TSESTree.Token;</span>
<span class="s1">}</span>
<span class="s0">interface </span><span class="s1">ReportDescriptorLocOnly {</span>
    <span class="s3">/**</span>
     <span class="s3">* An override of the location of the report</span>
     <span class="s3">*/</span>
    <span class="s1">loc: Readonly&lt;TSESTree.Position&gt; | Readonly&lt;TSESTree.SourceLocation&gt;;</span>
<span class="s1">}</span>
<span class="s0">export </span><span class="s1">type ReportDescriptor&lt;MessageIds </span><span class="s0">extends </span><span class="s1">string&gt; = (ReportDescriptorLocOnly | ReportDescriptorNodeOptionalLoc) &amp; ReportDescriptorWithSuggestion&lt;MessageIds&gt;;</span>
<span class="s3">/**</span>
 <span class="s3">* Plugins can add their settings using declaration</span>
 <span class="s3">* merging against this interface.</span>
 <span class="s3">*/</span>
<span class="s0">export interface </span><span class="s1">SharedConfigurationSettings {</span>
    <span class="s1">[name: string]: unknown;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">RuleContext&lt;MessageIds </span><span class="s0">extends </span><span class="s1">string, Options </span><span class="s0">extends </span><span class="s1">readonly unknown[]&gt; {</span>
    <span class="s3">/**</span>
     <span class="s3">* The rule ID.</span>
     <span class="s3">*/</span>
    <span class="s1">id: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* The language options configured for this run</span>
     <span class="s3">*/</span>
    <span class="s1">languageOptions: FlatConfig.LanguageOptions;</span>
    <span class="s3">/**</span>
     <span class="s3">* An array of the configured options for this rule.</span>
     <span class="s3">* This array does not include the rule severity.</span>
     <span class="s3">*/</span>
    <span class="s1">options: Options;</span>
    <span class="s3">/**</span>
     <span class="s3">* The parser options configured for this run</span>
     <span class="s3">*/</span>
    <span class="s1">parserOptions: Linter.ParserOptions;</span>
    <span class="s3">/**</span>
     <span class="s3">* The name of the parser from configuration, if in eslintrc (legacy) config.</span>
     <span class="s3">*/</span>
    <span class="s1">parserPath: string | undefined;</span>
    <span class="s3">/**</span>
     <span class="s3">* An object containing parser-provided services for rules</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@deprecated </span><span class="s3">in favor of `SourceCode#parserServices`</span>
     <span class="s3">*/</span>
    <span class="s1">parserServices?: ParserServices;</span>
    <span class="s3">/**</span>
     <span class="s3">* The shared settings from configuration.</span>
     <span class="s3">* We do not have any shared settings in this plugin.</span>
     <span class="s3">*/</span>
    <span class="s1">settings: SharedConfigurationSettings;</span>
    <span class="s3">/**</span>
     <span class="s3">* Returns an array of the ancestors of the currently-traversed node, starting at</span>
     <span class="s3">* the root of the AST and continuing through the direct parent of the current node.</span>
     <span class="s3">* This array does not include the currently-traversed node itself.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@deprecated </span><span class="s3">in favor of `SourceCode#getAncestors`</span>
     <span class="s3">*/</span>
    <span class="s1">getAncestors(): TSESTree.Node[];</span>
    <span class="s3">/**</span>
     <span class="s3">* Returns a list of variables declared by the given node.</span>
     <span class="s3">* This information can be used to track references to variables.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@deprecated </span><span class="s3">in favor of `SourceCode#getDeclaredVariables`</span>
     <span class="s3">*/</span>
    <span class="s1">getDeclaredVariables(node: TSESTree.Node): readonly Scope.Variable[];</span>
    <span class="s3">/**</span>
     <span class="s3">* Returns the current working directory passed to Linter.</span>
     <span class="s3">* It is a path to a directory that should be considered as the current working directory.</span>
     <span class="s3">* </span><span class="s4">@deprecated </span><span class="s3">in favor of `RuleContext#cwd`</span>
     <span class="s3">*/</span>
    <span class="s1">getCwd(): string;</span>
    <span class="s3">/**</span>
     <span class="s3">* The current working directory passed to Linter.</span>
     <span class="s3">* It is a path to a directory that should be considered as the current working directory.</span>
     <span class="s3">*/</span>
    <span class="s1">cwd: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* Returns the filename associated with the source.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@deprecated </span><span class="s3">in favor of `RuleContext#filename`</span>
     <span class="s3">*/</span>
    <span class="s1">getFilename(): string;</span>
    <span class="s3">/**</span>
     <span class="s3">* The filename associated with the source.</span>
     <span class="s3">*/</span>
    <span class="s1">filename: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* Returns the full path of the file on disk without any code block information (unlike `getFilename()`).</span>
     <span class="s3">* </span><span class="s4">@deprecated </span><span class="s3">in favor of `RuleContext#physicalFilename`</span>
     <span class="s3">*/</span>
    <span class="s1">getPhysicalFilename(): string;</span>
    <span class="s3">/**</span>
     <span class="s3">* The full path of the file on disk without any code block information (unlike `filename`).</span>
     <span class="s3">*/</span>
    <span class="s1">physicalFilename: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* Returns the scope of the currently-traversed node.</span>
     <span class="s3">* This information can be used track references to variables.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@deprecated </span><span class="s3">in favor of `SourceCode#getScope`</span>
     <span class="s3">*/</span>
    <span class="s1">getScope(): Scope.Scope;</span>
    <span class="s3">/**</span>
     <span class="s3">* Returns a SourceCode object that you can use to work with the source that</span>
     <span class="s3">* was passed to ESLint.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@deprecated </span><span class="s3">in favor of `RuleContext#sourceCode`</span>
     <span class="s3">*/</span>
    <span class="s1">getSourceCode(): Readonly&lt;SourceCode&gt;;</span>
    <span class="s3">/**</span>
     <span class="s3">* A SourceCode object that you can use to work with the source that</span>
     <span class="s3">* was passed to ESLint.</span>
     <span class="s3">*/</span>
    <span class="s1">sourceCode: Readonly&lt;SourceCode&gt;;</span>
    <span class="s3">/**</span>
     <span class="s3">* Marks a variable with the given name in the current scope as used.</span>
     <span class="s3">* This affects the no-unused-vars rule.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@deprecated </span><span class="s3">in favor of `SourceCode#markVariableAsUsed`</span>
     <span class="s3">*/</span>
    <span class="s1">markVariableAsUsed(name: string): boolean;</span>
    <span class="s3">/**</span>
     <span class="s3">* Reports a problem in the code.</span>
     <span class="s3">*/</span>
    <span class="s1">report(descriptor: ReportDescriptor&lt;MessageIds&gt;): </span><span class="s0">void</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Part of the code path analysis feature of ESLint:</span>
 <span class="s3">* https://eslint.org/docs/latest/extend/code-path-analysis</span>
 <span class="s3">*</span>
 <span class="s3">* These are used in the `onCodePath*` methods. (Note that the `node` parameter</span>
 <span class="s3">* of these methods is intentionally omitted.)</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@see </span><span class="s3">https://github.com/typescript-eslint/typescript-eslint/issues/6993</span>
 <span class="s3">*/</span>
<span class="s0">export interface </span><span class="s1">CodePath {</span>
    <span class="s3">/** Code paths of functions this code path contains. */</span>
    <span class="s1">childCodePaths: CodePath[];</span>
    <span class="s3">/**</span>
     <span class="s3">* Segments of the current traversal position.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@deprecated</span>
     <span class="s3">*/</span>
    <span class="s1">currentSegments: CodePathSegment[];</span>
    <span class="s3">/** The final segments which includes both returned and thrown. */</span>
    <span class="s1">finalSegments: CodePathSegment[];</span>
    <span class="s3">/**</span>
     <span class="s3">* A unique string. Respective rules can use `id` to save additional</span>
     <span class="s3">* information for each code path.</span>
     <span class="s3">*/</span>
    <span class="s1">id: string;</span>
    <span class="s1">initialSegment: CodePathSegment;</span>
    <span class="s3">/** The final segments which includes only returned. */</span>
    <span class="s1">returnedSegments: CodePathSegment[];</span>
    <span class="s3">/** The final segments which includes only thrown. */</span>
    <span class="s1">thrownSegments: CodePathSegment[];</span>
    <span class="s3">/** The code path of the upper function/global scope. */</span>
    <span class="s1">upper: CodePath | </span><span class="s0">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Part of the code path analysis feature of ESLint:</span>
 <span class="s3">* https://eslint.org/docs/latest/extend/code-path-analysis</span>
 <span class="s3">*</span>
 <span class="s3">* These are used in the `onCodePath*` methods. (Note that the `node` parameter</span>
 <span class="s3">* of these methods is intentionally omitted.)</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@see </span><span class="s3">https://github.com/typescript-eslint/typescript-eslint/issues/6993</span>
 <span class="s3">*/</span>
<span class="s0">export interface </span><span class="s1">CodePathSegment {</span>
    <span class="s3">/**</span>
     <span class="s3">* A unique string. Respective rules can use `id` to save additional</span>
     <span class="s3">* information for each segment.</span>
     <span class="s3">*/</span>
    <span class="s1">id: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* The next segments. If forking, there are two or more. If final, there is</span>
     <span class="s3">* nothing.</span>
     <span class="s3">*/</span>
    <span class="s1">nextSegments: CodePathSegment[];</span>
    <span class="s3">/**</span>
     <span class="s3">* The previous segments. If merging, there are two or more. If initial, there</span>
     <span class="s3">* is nothing.</span>
     <span class="s3">*/</span>
    <span class="s1">prevSegments: CodePathSegment[];</span>
    <span class="s3">/**</span>
     <span class="s3">* A flag which shows whether it is reachable. This becomes `false` when</span>
     <span class="s3">* preceded by `return`, `throw`, `break`, or `continue`.</span>
     <span class="s3">*/</span>
    <span class="s1">reachable: boolean;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Part of the code path analysis feature of ESLint:</span>
 <span class="s3">* https://eslint.org/docs/latest/extend/code-path-analysis</span>
 <span class="s3">*</span>
 <span class="s3">* This type is unused in the `typescript-eslint` codebase since putting it on</span>
 <span class="s3">* the `nodeSelector` for `RuleListener` would break the existing definition.</span>
 <span class="s3">* However, it is exported here for the purposes of manual type-assertion.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@see </span><span class="s3">https://github.com/typescript-eslint/typescript-eslint/issues/6993</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">type CodePathFunction = ((codePath: CodePath, node: TSESTree.Node) =&gt; </span><span class="s0">void</span><span class="s1">) | ((fromSegment: CodePathSegment, toSegment: CodePathSegment, node: TSESTree.Node) =&gt; </span><span class="s0">void</span><span class="s1">) | ((segment: CodePathSegment, node: TSESTree.Node) =&gt; </span><span class="s0">void</span><span class="s1">);</span>
<span class="s0">export </span><span class="s1">type RuleFunction&lt;T </span><span class="s0">extends </span><span class="s1">TSESTree.NodeOrTokenData = never&gt; = (node: T) =&gt; </span><span class="s0">void</span><span class="s1">;</span>
<span class="s0">interface </span><span class="s1">RuleListenerBaseSelectors {</span>
    <span class="s1">AccessorProperty?: RuleFunction&lt;TSESTree.AccessorProperty&gt;;</span>
    <span class="s1">ArrayExpression?: RuleFunction&lt;TSESTree.ArrayExpression&gt;;</span>
    <span class="s1">ArrayPattern?: RuleFunction&lt;TSESTree.ArrayPattern&gt;;</span>
    <span class="s1">ArrowFunctionExpression?: RuleFunction&lt;TSESTree.ArrowFunctionExpression&gt;;</span>
    <span class="s1">AssignmentExpression?: RuleFunction&lt;TSESTree.AssignmentExpression&gt;;</span>
    <span class="s1">AssignmentPattern?: RuleFunction&lt;TSESTree.AssignmentPattern&gt;;</span>
    <span class="s1">AwaitExpression?: RuleFunction&lt;TSESTree.AwaitExpression&gt;;</span>
    <span class="s1">BinaryExpression?: RuleFunction&lt;TSESTree.BinaryExpression&gt;;</span>
    <span class="s1">BlockStatement?: RuleFunction&lt;TSESTree.BlockStatement&gt;;</span>
    <span class="s1">BreakStatement?: RuleFunction&lt;TSESTree.BreakStatement&gt;;</span>
    <span class="s1">CallExpression?: RuleFunction&lt;TSESTree.CallExpression&gt;;</span>
    <span class="s1">CatchClause?: RuleFunction&lt;TSESTree.CatchClause&gt;;</span>
    <span class="s1">ChainExpression?: RuleFunction&lt;TSESTree.ChainExpression&gt;;</span>
    <span class="s1">ClassBody?: RuleFunction&lt;TSESTree.ClassBody&gt;;</span>
    <span class="s1">ClassDeclaration?: RuleFunction&lt;TSESTree.ClassDeclaration&gt;;</span>
    <span class="s1">ClassExpression?: RuleFunction&lt;TSESTree.ClassExpression&gt;;</span>
    <span class="s1">ConditionalExpression?: RuleFunction&lt;TSESTree.ConditionalExpression&gt;;</span>
    <span class="s1">ContinueStatement?: RuleFunction&lt;TSESTree.ContinueStatement&gt;;</span>
    <span class="s1">DebuggerStatement?: RuleFunction&lt;TSESTree.DebuggerStatement&gt;;</span>
    <span class="s1">Decorator?: RuleFunction&lt;TSESTree.Decorator&gt;;</span>
    <span class="s1">DoWhileStatement?: RuleFunction&lt;TSESTree.DoWhileStatement&gt;;</span>
    <span class="s1">EmptyStatement?: RuleFunction&lt;TSESTree.EmptyStatement&gt;;</span>
    <span class="s1">ExportAllDeclaration?: RuleFunction&lt;TSESTree.ExportAllDeclaration&gt;;</span>
    <span class="s1">ExportDefaultDeclaration?: RuleFunction&lt;TSESTree.ExportDefaultDeclaration&gt;;</span>
    <span class="s1">ExportNamedDeclaration?: RuleFunction&lt;TSESTree.ExportNamedDeclaration&gt;;</span>
    <span class="s1">ExportSpecifier?: RuleFunction&lt;TSESTree.ExportSpecifier&gt;;</span>
    <span class="s1">ExpressionStatement?: RuleFunction&lt;TSESTree.ExpressionStatement&gt;;</span>
    <span class="s1">ForInStatement?: RuleFunction&lt;TSESTree.ForInStatement&gt;;</span>
    <span class="s1">ForOfStatement?: RuleFunction&lt;TSESTree.ForOfStatement&gt;;</span>
    <span class="s1">ForStatement?: RuleFunction&lt;TSESTree.ForStatement&gt;;</span>
    <span class="s1">FunctionDeclaration?: RuleFunction&lt;TSESTree.FunctionDeclaration&gt;;</span>
    <span class="s1">FunctionExpression?: RuleFunction&lt;TSESTree.FunctionExpression&gt;;</span>
    <span class="s1">Identifier?: RuleFunction&lt;TSESTree.Identifier&gt;;</span>
    <span class="s1">IfStatement?: RuleFunction&lt;TSESTree.IfStatement&gt;;</span>
    <span class="s1">ImportAttribute?: RuleFunction&lt;TSESTree.ImportAttribute&gt;;</span>
    <span class="s1">ImportDeclaration?: RuleFunction&lt;TSESTree.ImportDeclaration&gt;;</span>
    <span class="s1">ImportDefaultSpecifier?: RuleFunction&lt;TSESTree.ImportDefaultSpecifier&gt;;</span>
    <span class="s1">ImportExpression?: RuleFunction&lt;TSESTree.ImportExpression&gt;;</span>
    <span class="s1">ImportNamespaceSpecifier?: RuleFunction&lt;TSESTree.ImportNamespaceSpecifier&gt;;</span>
    <span class="s1">ImportSpecifier?: RuleFunction&lt;TSESTree.ImportSpecifier&gt;;</span>
    <span class="s1">JSXAttribute?: RuleFunction&lt;TSESTree.JSXAttribute&gt;;</span>
    <span class="s1">JSXClosingElement?: RuleFunction&lt;TSESTree.JSXClosingElement&gt;;</span>
    <span class="s1">JSXClosingFragment?: RuleFunction&lt;TSESTree.JSXClosingFragment&gt;;</span>
    <span class="s1">JSXElement?: RuleFunction&lt;TSESTree.JSXElement&gt;;</span>
    <span class="s1">JSXEmptyExpression?: RuleFunction&lt;TSESTree.JSXEmptyExpression&gt;;</span>
    <span class="s1">JSXExpressionContainer?: RuleFunction&lt;TSESTree.JSXExpressionContainer&gt;;</span>
    <span class="s1">JSXFragment?: RuleFunction&lt;TSESTree.JSXFragment&gt;;</span>
    <span class="s1">JSXIdentifier?: RuleFunction&lt;TSESTree.JSXIdentifier&gt;;</span>
    <span class="s1">JSXMemberExpression?: RuleFunction&lt;TSESTree.JSXMemberExpression&gt;;</span>
    <span class="s1">JSXNamespacedName?: RuleFunction&lt;TSESTree.JSXNamespacedName&gt;;</span>
    <span class="s1">JSXOpeningElement?: RuleFunction&lt;TSESTree.JSXOpeningElement&gt;;</span>
    <span class="s1">JSXOpeningFragment?: RuleFunction&lt;TSESTree.JSXOpeningFragment&gt;;</span>
    <span class="s1">JSXSpreadAttribute?: RuleFunction&lt;TSESTree.JSXSpreadAttribute&gt;;</span>
    <span class="s1">JSXSpreadChild?: RuleFunction&lt;TSESTree.JSXSpreadChild&gt;;</span>
    <span class="s1">JSXText?: RuleFunction&lt;TSESTree.JSXText&gt;;</span>
    <span class="s1">LabeledStatement?: RuleFunction&lt;TSESTree.LabeledStatement&gt;;</span>
    <span class="s1">Literal?: RuleFunction&lt;TSESTree.Literal&gt;;</span>
    <span class="s1">LogicalExpression?: RuleFunction&lt;TSESTree.LogicalExpression&gt;;</span>
    <span class="s1">MemberExpression?: RuleFunction&lt;TSESTree.MemberExpression&gt;;</span>
    <span class="s1">MetaProperty?: RuleFunction&lt;TSESTree.MetaProperty&gt;;</span>
    <span class="s1">MethodDefinition?: RuleFunction&lt;TSESTree.MethodDefinition&gt;;</span>
    <span class="s1">NewExpression?: RuleFunction&lt;TSESTree.NewExpression&gt;;</span>
    <span class="s1">ObjectExpression?: RuleFunction&lt;TSESTree.ObjectExpression&gt;;</span>
    <span class="s1">ObjectPattern?: RuleFunction&lt;TSESTree.ObjectPattern&gt;;</span>
    <span class="s1">PrivateIdentifier?: RuleFunction&lt;TSESTree.PrivateIdentifier&gt;;</span>
    <span class="s1">Program?: RuleFunction&lt;TSESTree.Program&gt;;</span>
    <span class="s1">Property?: RuleFunction&lt;TSESTree.Property&gt;;</span>
    <span class="s1">PropertyDefinition?: RuleFunction&lt;TSESTree.PropertyDefinition&gt;;</span>
    <span class="s1">RestElement?: RuleFunction&lt;TSESTree.RestElement&gt;;</span>
    <span class="s1">ReturnStatement?: RuleFunction&lt;TSESTree.ReturnStatement&gt;;</span>
    <span class="s1">SequenceExpression?: RuleFunction&lt;TSESTree.SequenceExpression&gt;;</span>
    <span class="s1">SpreadElement?: RuleFunction&lt;TSESTree.SpreadElement&gt;;</span>
    <span class="s1">StaticBlock?: RuleFunction&lt;TSESTree.StaticBlock&gt;;</span>
    <span class="s1">Super?: RuleFunction&lt;TSESTree.Super&gt;;</span>
    <span class="s1">SwitchCase?: RuleFunction&lt;TSESTree.SwitchCase&gt;;</span>
    <span class="s1">SwitchStatement?: RuleFunction&lt;TSESTree.SwitchStatement&gt;;</span>
    <span class="s1">TaggedTemplateExpression?: RuleFunction&lt;TSESTree.TaggedTemplateExpression&gt;;</span>
    <span class="s1">TemplateElement?: RuleFunction&lt;TSESTree.TemplateElement&gt;;</span>
    <span class="s1">TemplateLiteral?: RuleFunction&lt;TSESTree.TemplateLiteral&gt;;</span>
    <span class="s1">ThisExpression?: RuleFunction&lt;TSESTree.ThisExpression&gt;;</span>
    <span class="s1">ThrowStatement?: RuleFunction&lt;TSESTree.ThrowStatement&gt;;</span>
    <span class="s1">TryStatement?: RuleFunction&lt;TSESTree.TryStatement&gt;;</span>
    <span class="s1">TSAbstractAccessorProperty?: RuleFunction&lt;TSESTree.TSAbstractAccessorProperty&gt;;</span>
    <span class="s1">TSAbstractKeyword?: RuleFunction&lt;TSESTree.TSAbstractKeyword&gt;;</span>
    <span class="s1">TSAbstractMethodDefinition?: RuleFunction&lt;TSESTree.TSAbstractMethodDefinition&gt;;</span>
    <span class="s1">TSAbstractPropertyDefinition?: RuleFunction&lt;TSESTree.TSAbstractPropertyDefinition&gt;;</span>
    <span class="s1">TSAnyKeyword?: RuleFunction&lt;TSESTree.TSAnyKeyword&gt;;</span>
    <span class="s1">TSArrayType?: RuleFunction&lt;TSESTree.TSArrayType&gt;;</span>
    <span class="s1">TSAsExpression?: RuleFunction&lt;TSESTree.TSAsExpression&gt;;</span>
    <span class="s1">TSAsyncKeyword?: RuleFunction&lt;TSESTree.TSAsyncKeyword&gt;;</span>
    <span class="s1">TSBigIntKeyword?: RuleFunction&lt;TSESTree.TSBigIntKeyword&gt;;</span>
    <span class="s1">TSBooleanKeyword?: RuleFunction&lt;TSESTree.TSBooleanKeyword&gt;;</span>
    <span class="s1">TSCallSignatureDeclaration?: RuleFunction&lt;TSESTree.TSCallSignatureDeclaration&gt;;</span>
    <span class="s1">TSClassImplements?: RuleFunction&lt;TSESTree.TSClassImplements&gt;;</span>
    <span class="s1">TSConditionalType?: RuleFunction&lt;TSESTree.TSConditionalType&gt;;</span>
    <span class="s1">TSConstructorType?: RuleFunction&lt;TSESTree.TSConstructorType&gt;;</span>
    <span class="s1">TSConstructSignatureDeclaration?: RuleFunction&lt;TSESTree.TSConstructSignatureDeclaration&gt;;</span>
    <span class="s1">TSDeclareFunction?: RuleFunction&lt;TSESTree.TSDeclareFunction&gt;;</span>
    <span class="s1">TSDeclareKeyword?: RuleFunction&lt;TSESTree.TSDeclareKeyword&gt;;</span>
    <span class="s1">TSEmptyBodyFunctionExpression?: RuleFunction&lt;TSESTree.TSEmptyBodyFunctionExpression&gt;;</span>
    <span class="s1">TSEnumBody?: RuleFunction&lt;TSESTree.TSEnumBody&gt;;</span>
    <span class="s1">TSEnumDeclaration?: RuleFunction&lt;TSESTree.TSEnumDeclaration&gt;;</span>
    <span class="s1">TSEnumMember?: RuleFunction&lt;TSESTree.TSEnumMember&gt;;</span>
    <span class="s1">TSExportAssignment?: RuleFunction&lt;TSESTree.TSExportAssignment&gt;;</span>
    <span class="s1">TSExportKeyword?: RuleFunction&lt;TSESTree.TSExportKeyword&gt;;</span>
    <span class="s1">TSExternalModuleReference?: RuleFunction&lt;TSESTree.TSExternalModuleReference&gt;;</span>
    <span class="s1">TSFunctionType?: RuleFunction&lt;TSESTree.TSFunctionType&gt;;</span>
    <span class="s1">TSImportEqualsDeclaration?: RuleFunction&lt;TSESTree.TSImportEqualsDeclaration&gt;;</span>
    <span class="s1">TSImportType?: RuleFunction&lt;TSESTree.TSImportType&gt;;</span>
    <span class="s1">TSIndexedAccessType?: RuleFunction&lt;TSESTree.TSIndexedAccessType&gt;;</span>
    <span class="s1">TSIndexSignature?: RuleFunction&lt;TSESTree.TSIndexSignature&gt;;</span>
    <span class="s1">TSInferType?: RuleFunction&lt;TSESTree.TSInferType&gt;;</span>
    <span class="s1">TSInstantiationExpression?: RuleFunction&lt;TSESTree.TSInstantiationExpression&gt;;</span>
    <span class="s1">TSInterfaceBody?: RuleFunction&lt;TSESTree.TSInterfaceBody&gt;;</span>
    <span class="s1">TSInterfaceDeclaration?: RuleFunction&lt;TSESTree.TSInterfaceDeclaration&gt;;</span>
    <span class="s1">TSInterfaceHeritage?: RuleFunction&lt;TSESTree.TSInterfaceHeritage&gt;;</span>
    <span class="s1">TSIntersectionType?: RuleFunction&lt;TSESTree.TSIntersectionType&gt;;</span>
    <span class="s1">TSIntrinsicKeyword?: RuleFunction&lt;TSESTree.TSIntrinsicKeyword&gt;;</span>
    <span class="s1">TSLiteralType?: RuleFunction&lt;TSESTree.TSLiteralType&gt;;</span>
    <span class="s1">TSMappedType?: RuleFunction&lt;TSESTree.TSMappedType&gt;;</span>
    <span class="s1">TSMethodSignature?: RuleFunction&lt;TSESTree.TSMethodSignature&gt;;</span>
    <span class="s1">TSModuleBlock?: RuleFunction&lt;TSESTree.TSModuleBlock&gt;;</span>
    <span class="s1">TSModuleDeclaration?: RuleFunction&lt;TSESTree.TSModuleDeclaration&gt;;</span>
    <span class="s1">TSNamedTupleMember?: RuleFunction&lt;TSESTree.TSNamedTupleMember&gt;;</span>
    <span class="s1">TSNamespaceExportDeclaration?: RuleFunction&lt;TSESTree.TSNamespaceExportDeclaration&gt;;</span>
    <span class="s1">TSNeverKeyword?: RuleFunction&lt;TSESTree.TSNeverKeyword&gt;;</span>
    <span class="s1">TSNonNullExpression?: RuleFunction&lt;TSESTree.TSNonNullExpression&gt;;</span>
    <span class="s1">TSNullKeyword?: RuleFunction&lt;TSESTree.TSNullKeyword&gt;;</span>
    <span class="s1">TSNumberKeyword?: RuleFunction&lt;TSESTree.TSNumberKeyword&gt;;</span>
    <span class="s1">TSObjectKeyword?: RuleFunction&lt;TSESTree.TSObjectKeyword&gt;;</span>
    <span class="s1">TSOptionalType?: RuleFunction&lt;TSESTree.TSOptionalType&gt;;</span>
    <span class="s1">TSParameterProperty?: RuleFunction&lt;TSESTree.TSParameterProperty&gt;;</span>
    <span class="s1">TSPrivateKeyword?: RuleFunction&lt;TSESTree.TSPrivateKeyword&gt;;</span>
    <span class="s1">TSPropertySignature?: RuleFunction&lt;TSESTree.TSPropertySignature&gt;;</span>
    <span class="s1">TSProtectedKeyword?: RuleFunction&lt;TSESTree.TSProtectedKeyword&gt;;</span>
    <span class="s1">TSPublicKeyword?: RuleFunction&lt;TSESTree.TSPublicKeyword&gt;;</span>
    <span class="s1">TSQualifiedName?: RuleFunction&lt;TSESTree.TSQualifiedName&gt;;</span>
    <span class="s1">TSReadonlyKeyword?: RuleFunction&lt;TSESTree.TSReadonlyKeyword&gt;;</span>
    <span class="s1">TSRestType?: RuleFunction&lt;TSESTree.TSRestType&gt;;</span>
    <span class="s1">TSSatisfiesExpression?: RuleFunction&lt;TSESTree.TSSatisfiesExpression&gt;;</span>
    <span class="s1">TSStaticKeyword?: RuleFunction&lt;TSESTree.TSStaticKeyword&gt;;</span>
    <span class="s1">TSStringKeyword?: RuleFunction&lt;TSESTree.TSStringKeyword&gt;;</span>
    <span class="s1">TSSymbolKeyword?: RuleFunction&lt;TSESTree.TSSymbolKeyword&gt;;</span>
    <span class="s1">TSTemplateLiteralType?: RuleFunction&lt;TSESTree.TSTemplateLiteralType&gt;;</span>
    <span class="s1">TSThisType?: RuleFunction&lt;TSESTree.TSThisType&gt;;</span>
    <span class="s1">TSTupleType?: RuleFunction&lt;TSESTree.TSTupleType&gt;;</span>
    <span class="s1">TSTypeAliasDeclaration?: RuleFunction&lt;TSESTree.TSTypeAliasDeclaration&gt;;</span>
    <span class="s1">TSTypeAnnotation?: RuleFunction&lt;TSESTree.TSTypeAnnotation&gt;;</span>
    <span class="s1">TSTypeAssertion?: RuleFunction&lt;TSESTree.TSTypeAssertion&gt;;</span>
    <span class="s1">TSTypeLiteral?: RuleFunction&lt;TSESTree.TSTypeLiteral&gt;;</span>
    <span class="s1">TSTypeOperator?: RuleFunction&lt;TSESTree.TSTypeOperator&gt;;</span>
    <span class="s1">TSTypeParameter?: RuleFunction&lt;TSESTree.TSTypeParameter&gt;;</span>
    <span class="s1">TSTypeParameterDeclaration?: RuleFunction&lt;TSESTree.TSTypeParameterDeclaration&gt;;</span>
    <span class="s1">TSTypeParameterInstantiation?: RuleFunction&lt;TSESTree.TSTypeParameterInstantiation&gt;;</span>
    <span class="s1">TSTypePredicate?: RuleFunction&lt;TSESTree.TSTypePredicate&gt;;</span>
    <span class="s1">TSTypeQuery?: RuleFunction&lt;TSESTree.TSTypeQuery&gt;;</span>
    <span class="s1">TSTypeReference?: RuleFunction&lt;TSESTree.TSTypeReference&gt;;</span>
    <span class="s1">TSUndefinedKeyword?: RuleFunction&lt;TSESTree.TSUndefinedKeyword&gt;;</span>
    <span class="s1">TSUnionType?: RuleFunction&lt;TSESTree.TSUnionType&gt;;</span>
    <span class="s1">TSUnknownKeyword?: RuleFunction&lt;TSESTree.TSUnknownKeyword&gt;;</span>
    <span class="s1">TSVoidKeyword?: RuleFunction&lt;TSESTree.TSVoidKeyword&gt;;</span>
    <span class="s1">UnaryExpression?: RuleFunction&lt;TSESTree.UnaryExpression&gt;;</span>
    <span class="s1">UpdateExpression?: RuleFunction&lt;TSESTree.UpdateExpression&gt;;</span>
    <span class="s1">VariableDeclaration?: RuleFunction&lt;TSESTree.VariableDeclaration&gt;;</span>
    <span class="s1">VariableDeclarator?: RuleFunction&lt;TSESTree.VariableDeclarator&gt;;</span>
    <span class="s1">WhileStatement?: RuleFunction&lt;TSESTree.WhileStatement&gt;;</span>
    <span class="s1">WithStatement?: RuleFunction&lt;TSESTree.WithStatement&gt;;</span>
    <span class="s1">YieldExpression?: RuleFunction&lt;TSESTree.YieldExpression&gt;;</span>
<span class="s1">}</span>
<span class="s1">type RuleListenerExitSelectors = {</span>
    <span class="s1">[K </span><span class="s0">in </span><span class="s1">keyof RuleListenerBaseSelectors as </span><span class="s2">`</span><span class="s1">${K}</span><span class="s2">:exit`</span><span class="s1">]: RuleListenerBaseSelectors[K];</span>
<span class="s1">};</span>
<span class="s1">type RuleListenerCatchAllBaseCase = Record&lt;string, RuleFunction | undefined&gt;;</span>
<span class="s0">export interface </span><span class="s1">RuleListenerExtension {</span>
<span class="s1">}</span>
<span class="s0">export </span><span class="s1">type RuleListener = RuleListenerBaseSelectors &amp; RuleListenerCatchAllBaseCase &amp; RuleListenerExitSelectors;</span>
<span class="s0">export interface </span><span class="s1">RuleModule&lt;MessageIds </span><span class="s0">extends </span><span class="s1">string, Options </span><span class="s0">extends </span><span class="s1">readonly unknown[] = [], Docs = unknown, ExtendedRuleListener </span><span class="s0">extends </span><span class="s1">RuleListener = RuleListener&gt; {</span>
    <span class="s3">/**</span>
     <span class="s3">* Function which returns an object with methods that ESLint calls to “visit”</span>
     <span class="s3">* nodes while traversing the abstract syntax tree.</span>
     <span class="s3">*/</span>
    <span class="s1">create(context: Readonly&lt;RuleContext&lt;MessageIds, Options&gt;&gt;): ExtendedRuleListener;</span>
    <span class="s3">/**</span>
     <span class="s3">* Default options the rule will be run with</span>
     <span class="s3">*/</span>
    <span class="s1">defaultOptions: Options;</span>
    <span class="s3">/**</span>
     <span class="s3">* Metadata about the rule</span>
     <span class="s3">*/</span>
    <span class="s1">meta: RuleMetaData&lt;MessageIds, Docs, Options&gt;;</span>
    <span class="s3">/**</span>
     <span class="s3">* Rule name</span>
     <span class="s3">*/</span>
    <span class="s1">name: string;</span>
<span class="s1">}</span>
<span class="s0">export </span><span class="s1">type AnyRuleModule = RuleModule&lt;string, readonly unknown[]&gt;;</span>
<span class="s0">export interface </span><span class="s1">RuleModuleWithMetaDocs&lt;MessageIds </span><span class="s0">extends </span><span class="s1">string, Options </span><span class="s0">extends </span><span class="s1">readonly unknown[] = [], Docs = unknown, ExtendedRuleListener </span><span class="s0">extends </span><span class="s1">RuleListener = RuleListener&gt; </span><span class="s0">extends </span><span class="s1">RuleModule&lt;MessageIds, Options, Docs, ExtendedRuleListener&gt; {</span>
    <span class="s3">/**</span>
     <span class="s3">* Metadata about the rule</span>
     <span class="s3">*/</span>
    <span class="s1">meta: RuleMetaDataWithDocs&lt;MessageIds, Docs, Options&gt;;</span>
<span class="s1">}</span>
<span class="s0">export </span><span class="s1">type AnyRuleModuleWithMetaDocs = RuleModuleWithMetaDocs&lt;string, unknown[]&gt;;</span>
<span class="s3">/**</span>
 <span class="s3">* A loose definition of the RuleModule type for use with configs. This type is</span>
 <span class="s3">* intended to relax validation of types so that we can have basic validation</span>
 <span class="s3">* without being overly strict about nitty gritty details matching.</span>
 <span class="s3">*</span>
 <span class="s3">* For example the plugin might be declared using an old version of our types or</span>
 <span class="s3">* they might use the DefinitelyTyped eslint types. Ultimately we don't need</span>
 <span class="s3">* super strict validation in a config - a loose shape match is &quot;good enough&quot; to</span>
 <span class="s3">* help validate the config is correct.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@see </span><span class="s3">{</span><span class="s4">@link </span><span class="s3">LooseParserModule}, {</span><span class="s4">@link </span><span class="s3">LooseProcessorModule}</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">type LooseRuleDefinition = LooseRuleCreateFunction | {</span>
    <span class="s1">create: LooseRuleCreateFunction;</span>
    <span class="s1">meta?: object | undefined;</span>
<span class="s1">};</span>
<span class="s0">export </span><span class="s1">type LooseRuleCreateFunction = (context: any) =&gt; Record&lt;string, Function | undefined&gt;;</span>
<span class="s0">export </span><span class="s1">type RuleCreateFunction&lt;MessageIds </span><span class="s0">extends </span><span class="s1">string = never, Options </span><span class="s0">extends </span><span class="s1">readonly unknown[] = unknown[]&gt; = (context: Readonly&lt;RuleContext&lt;MessageIds, Options&gt;&gt;) =&gt; RuleListener;</span>
<span class="s0">export </span><span class="s1">type AnyRuleCreateFunction = RuleCreateFunction&lt;string, readonly unknown[]&gt;;</span>
<span class="s0">export </span><span class="s1">{};</span>
</pre>
</body>
</html>