<html>
<head>
<title>ScopeManager.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ScopeManager.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">type { SourceType, TSESTree } from </span><span class="s2">'@typescript-eslint/types'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { Scope } from </span><span class="s2">'./scope'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { Variable } from </span><span class="s2">'./variable'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ BlockScope, CatchScope, ClassScope, ConditionalTypeScope, ForScope, FunctionExpressionNameScope, FunctionScope, FunctionTypeScope, GlobalScope, MappedTypeScope, ModuleScope, SwitchScope, TSEnumScope, TSModuleScope, TypeScope, WithScope } from </span><span class="s2">'./scope'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ ClassFieldInitializerScope } from </span><span class="s2">'./scope/ClassFieldInitializerScope'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ ClassStaticBlockScope } from </span><span class="s2">'./scope/ClassStaticBlockScope'</span><span class="s1">;</span>
<span class="s0">interface </span><span class="s1">ScopeManagerOptions {</span>
    <span class="s1">globalReturn?: boolean;</span>
    <span class="s1">impliedStrict?: boolean;</span>
    <span class="s1">sourceType?: SourceType;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@see </span><span class="s3">https://eslint.org/docs/latest/developer-guide/scope-manager-interface#scopemanager-interface</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">class </span><span class="s1">ScopeManager {</span>
    <span class="s1">#private;</span>
    <span class="s1">currentScope: Scope | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">readonly declaredVariables: WeakMap&lt;TSESTree.Node, Variable[]&gt;;</span>
    <span class="s3">/**</span>
     <span class="s3">* The root scope</span>
     <span class="s3">*/</span>
    <span class="s1">globalScope: GlobalScope | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">readonly nodeToScope: WeakMap&lt;TSESTree.Node, Scope[]&gt;;</span>
    <span class="s3">/**</span>
     <span class="s3">* All scopes</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">readonly scopes: Scope[];</span>
    <span class="s1">constructor(options: ScopeManagerOptions);</span>
    <span class="s1">isES6(): boolean;</span>
    <span class="s1">isGlobalReturn(): boolean;</span>
    <span class="s1">isImpliedStrict(): boolean;</span>
    <span class="s1">isModule(): boolean;</span>
    <span class="s1">isStrictModeSupported(): boolean;</span>
    <span class="s1">get variables(): Variable[];</span>
    <span class="s3">/**</span>
     <span class="s3">* Get the variables that a given AST node defines. The gotten variables' `def[].node`/`def[].parent` property is the node.</span>
     <span class="s3">* If the node does not define any variable, this returns an empty array.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">node An AST node to get their variables.</span>
     <span class="s3">*/</span>
    <span class="s1">getDeclaredVariables(node: TSESTree.Node): Variable[];</span>
    <span class="s3">/**</span>
     <span class="s3">* Get the scope of a given AST node. The gotten scope's `block` property is the node.</span>
     <span class="s3">* This method never returns `function-expression-name` scope. If the node does not have their scope, this returns `null`.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">node An AST node to get their scope.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">inner If the node has multiple scopes, this returns the outermost scope normally.</span>
     <span class="s3">*                If `inner` is `true` then this returns the innermost scope.</span>
     <span class="s3">*/</span>
    <span class="s1">acquire(node: TSESTree.Node, inner?: boolean): Scope | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">nestBlockScope(node: BlockScope[</span><span class="s2">'block'</span><span class="s1">]): BlockScope;</span>
    <span class="s1">nestCatchScope(node: CatchScope[</span><span class="s2">'block'</span><span class="s1">]): CatchScope;</span>
    <span class="s1">nestClassFieldInitializerScope(node: ClassFieldInitializerScope[</span><span class="s2">'block'</span><span class="s1">]): ClassFieldInitializerScope;</span>
    <span class="s1">nestClassScope(node: ClassScope[</span><span class="s2">'block'</span><span class="s1">]): ClassScope;</span>
    <span class="s1">nestClassStaticBlockScope(node: ClassStaticBlockScope[</span><span class="s2">'block'</span><span class="s1">]): ClassStaticBlockScope;</span>
    <span class="s1">nestConditionalTypeScope(node: ConditionalTypeScope[</span><span class="s2">'block'</span><span class="s1">]): ConditionalTypeScope;</span>
    <span class="s1">nestForScope(node: ForScope[</span><span class="s2">'block'</span><span class="s1">]): ForScope;</span>
    <span class="s1">nestFunctionExpressionNameScope(node: FunctionExpressionNameScope[</span><span class="s2">'block'</span><span class="s1">]): FunctionExpressionNameScope;</span>
    <span class="s1">nestFunctionScope(node: FunctionScope[</span><span class="s2">'block'</span><span class="s1">], isMethodDefinition: boolean): FunctionScope;</span>
    <span class="s1">nestFunctionTypeScope(node: FunctionTypeScope[</span><span class="s2">'block'</span><span class="s1">]): FunctionTypeScope;</span>
    <span class="s1">nestGlobalScope(node: GlobalScope[</span><span class="s2">'block'</span><span class="s1">]): GlobalScope;</span>
    <span class="s1">nestMappedTypeScope(node: MappedTypeScope[</span><span class="s2">'block'</span><span class="s1">]): MappedTypeScope;</span>
    <span class="s1">nestModuleScope(node: ModuleScope[</span><span class="s2">'block'</span><span class="s1">]): ModuleScope;</span>
    <span class="s1">nestSwitchScope(node: SwitchScope[</span><span class="s2">'block'</span><span class="s1">]): SwitchScope;</span>
    <span class="s1">nestTSEnumScope(node: TSEnumScope[</span><span class="s2">'block'</span><span class="s1">]): TSEnumScope;</span>
    <span class="s1">nestTSModuleScope(node: TSModuleScope[</span><span class="s2">'block'</span><span class="s1">]): TSModuleScope;</span>
    <span class="s1">nestTypeScope(node: TypeScope[</span><span class="s2">'block'</span><span class="s1">]): TypeScope;</span>
    <span class="s1">nestWithScope(node: WithScope[</span><span class="s2">'block'</span><span class="s1">]): WithScope;</span>
    <span class="s0">protected </span><span class="s1">nestScope&lt;T </span><span class="s0">extends </span><span class="s1">Scope&gt;(scope: T): T;</span>
<span class="s1">}</span>
<span class="s0">export </span><span class="s1">{};</span>
</pre>
</body>
</html>