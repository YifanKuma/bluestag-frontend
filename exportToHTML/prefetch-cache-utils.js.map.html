<html>
<head>
<title>prefetch-cache-utils.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
prefetch-cache-utils.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/client/components/router-reducer/prefetch-cache-utils.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">fetchServerResponse,</span><span class="s3">\n  </span><span class="s1">type FetchServerResponseResult,</span><span class="s3">\n</span><span class="s1">} from './fetch-server-response'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">PrefetchCacheEntryStatus,</span><span class="s3">\n  </span><span class="s1">type PrefetchCacheEntry,</span><span class="s3">\n  </span><span class="s1">PrefetchKind,</span><span class="s3">\n  </span><span class="s1">type ReadonlyReducerState,</span><span class="s3">\n</span><span class="s1">} from './router-reducer-types'</span><span class="s3">\n</span><span class="s1">import { prefetchQueue } from './reducers/prefetch-reducer'</span><span class="s3">\n\n</span><span class="s1">const INTERCEPTION_CACHE_KEY_MARKER = '%'</span><span class="s3">\n\n</span><span class="s1">export type AliasedPrefetchCacheEntry = PrefetchCacheEntry &amp; {</span><span class="s3">\n  </span><span class="s1">/** This is a special property that indicates a prefetch entry associated with a different URL</span><span class="s3">\n   </span><span class="s1">* was returned rather than the requested URL. This signals to the router that it should only</span><span class="s3">\n   </span><span class="s1">* apply the part that doesn't depend on searchParams (specifically the loading state).</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">aliased?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a cache key for the router prefetch cache</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param url - The URL being navigated to</span><span class="s3">\n </span><span class="s1">* @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.</span><span class="s3">\n </span><span class="s1">* @return The generated prefetch cache key.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createPrefetchCacheKeyImpl(</span><span class="s3">\n  </span><span class="s1">url: URL,</span><span class="s3">\n  </span><span class="s1">includeSearchParams: boolean,</span><span class="s3">\n  </span><span class="s1">prefix?: string | null</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// Initially we only use the pathname as the cache key. We don't want to include</span><span class="s3">\n  </span><span class="s1">// search params so that multiple URLs with the same search parameter can re-use</span><span class="s3">\n  </span><span class="s1">// loading states.</span><span class="s3">\n  </span><span class="s1">let pathnameFromUrl = url.pathname</span><span class="s3">\n\n  </span><span class="s1">// RSC responses can differ based on search params, specifically in the case where we aren't</span><span class="s3">\n  </span><span class="s1">// returning a partial response (ie with `PrefetchKind.AUTO`).</span><span class="s3">\n  </span><span class="s1">// In the auto case, since loading.js &amp; layout.js won't have access to search params,</span><span class="s3">\n  </span><span class="s1">// we can safely re-use that cache entry. But for full prefetches, we should not</span><span class="s3">\n  </span><span class="s1">// re-use the cache entry as the response may differ.</span><span class="s3">\n  </span><span class="s1">if (includeSearchParams) {</span><span class="s3">\n    </span><span class="s1">// if we have a full prefetch, we can include the search param in the key,</span><span class="s3">\n    </span><span class="s1">// as we'll be getting back a full response. The server might have read the search</span><span class="s3">\n    </span><span class="s1">// params when generating the full response.</span><span class="s3">\n    </span><span class="s1">pathnameFromUrl += url.search</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (prefix) {</span><span class="s3">\n    </span><span class="s1">return `${prefix}${INTERCEPTION_CACHE_KEY_MARKER}${pathnameFromUrl}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return pathnameFromUrl</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createPrefetchCacheKey(</span><span class="s3">\n  </span><span class="s1">url: URL,</span><span class="s3">\n  </span><span class="s1">kind: PrefetchKind | undefined,</span><span class="s3">\n  </span><span class="s1">nextUrl?: string | null</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return createPrefetchCacheKeyImpl(url, kind === PrefetchKind.FULL, nextUrl)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getExistingCacheEntry(</span><span class="s3">\n  </span><span class="s1">url: URL,</span><span class="s3">\n  </span><span class="s1">kind: PrefetchKind = PrefetchKind.TEMPORARY,</span><span class="s3">\n  </span><span class="s1">nextUrl: string | null,</span><span class="s3">\n  </span><span class="s1">prefetchCache: Map&lt;string, PrefetchCacheEntry&gt;,</span><span class="s3">\n  </span><span class="s1">allowAliasing: boolean</span><span class="s3">\n</span><span class="s1">): AliasedPrefetchCacheEntry | undefined {</span><span class="s3">\n  </span><span class="s1">// We first check if there's a more specific interception route prefetch entry</span><span class="s3">\n  </span><span class="s1">// This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)</span><span class="s3">\n  </span><span class="s1">// to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.</span><span class="s3">\n  </span><span class="s1">for (const maybeNextUrl of [nextUrl, null]) {</span><span class="s3">\n    </span><span class="s1">const cacheKeyWithParams = createPrefetchCacheKeyImpl(</span><span class="s3">\n      </span><span class="s1">url,</span><span class="s3">\n      </span><span class="s1">true,</span><span class="s3">\n      </span><span class="s1">maybeNextUrl</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">const cacheKeyWithoutParams = createPrefetchCacheKeyImpl(</span><span class="s3">\n      </span><span class="s1">url,</span><span class="s3">\n      </span><span class="s1">false,</span><span class="s3">\n      </span><span class="s1">maybeNextUrl</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">// First, we check if we have a cache entry that exactly matches the URL</span><span class="s3">\n    </span><span class="s1">const cacheKeyToUse = url.search</span><span class="s3">\n      </span><span class="s1">? cacheKeyWithParams</span><span class="s3">\n      </span><span class="s1">: cacheKeyWithoutParams</span><span class="s3">\n\n    </span><span class="s1">const existingEntry = prefetchCache.get(cacheKeyToUse)</span><span class="s3">\n    </span><span class="s1">if (existingEntry &amp;&amp; allowAliasing) {</span><span class="s3">\n      </span><span class="s1">// We know we're returning an aliased entry when the pathname matches but the search params don't,</span><span class="s3">\n      </span><span class="s1">const isAliased =</span><span class="s3">\n        </span><span class="s1">existingEntry.url.pathname === url.pathname &amp;&amp;</span><span class="s3">\n        </span><span class="s1">existingEntry.url.search !== url.search</span><span class="s3">\n\n      </span><span class="s1">if (isAliased) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">...existingEntry,</span><span class="s3">\n          </span><span class="s1">aliased: true,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return existingEntry</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If the request contains search params, and we're not doing a full prefetch, we can return the</span><span class="s3">\n    </span><span class="s1">// param-less entry if it exists.</span><span class="s3">\n    </span><span class="s1">// This is technically covered by the check at the bottom of this function, which iterates over cache entries,</span><span class="s3">\n    </span><span class="s1">// but lets us arrive there quicker in the param-full case.</span><span class="s3">\n    </span><span class="s1">const entryWithoutParams = prefetchCache.get(cacheKeyWithoutParams)</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">process.env.NODE_ENV !== 'development' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">allowAliasing &amp;&amp;</span><span class="s3">\n      </span><span class="s1">url.search &amp;&amp;</span><span class="s3">\n      </span><span class="s1">kind !== PrefetchKind.FULL &amp;&amp;</span><span class="s3">\n      </span><span class="s1">entryWithoutParams &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// We shouldn't return the aliased entry if it was relocated to a new cache key.</span><span class="s3">\n      </span><span class="s1">// Since it's rewritten, it could respond with a completely different loading state.</span><span class="s3">\n      </span><span class="s1">!entryWithoutParams.key.includes(INTERCEPTION_CACHE_KEY_MARKER)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return { ...entryWithoutParams, aliased: true }</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If we've gotten to this point, we didn't find a specific cache entry that matched</span><span class="s3">\n  </span><span class="s1">// the request URL.</span><span class="s3">\n  </span><span class="s1">// We attempt a partial match by checking if there's a cache entry with the same pathname.</span><span class="s3">\n  </span><span class="s1">// Regardless of what we find, since it doesn't correspond with the requested URL, we'll mark it </span><span class="s3">\&quot;</span><span class="s1">aliased</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n  </span><span class="s1">// This will signal to the router that it should only apply the loading state on the prefetched data.</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">process.env.NODE_ENV !== 'development' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">kind !== PrefetchKind.FULL &amp;&amp;</span><span class="s3">\n    </span><span class="s1">allowAliasing</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">for (const cacheEntry of prefetchCache.values()) {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">cacheEntry.url.pathname === url.pathname &amp;&amp;</span><span class="s3">\n        </span><span class="s1">// We shouldn't return the aliased entry if it was relocated to a new cache key.</span><span class="s3">\n        </span><span class="s1">// Since it's rewritten, it could respond with a completely different loading state.</span><span class="s3">\n        </span><span class="s1">!cacheEntry.key.includes(INTERCEPTION_CACHE_KEY_MARKER)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return { ...cacheEntry, aliased: true }</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns a prefetch cache entry if one exists. Otherwise creates a new one and enqueues a fetch request</span><span class="s3">\n </span><span class="s1">* to retrieve the prefetch data from the server.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getOrCreatePrefetchCacheEntry({</span><span class="s3">\n  </span><span class="s1">url,</span><span class="s3">\n  </span><span class="s1">nextUrl,</span><span class="s3">\n  </span><span class="s1">tree,</span><span class="s3">\n  </span><span class="s1">prefetchCache,</span><span class="s3">\n  </span><span class="s1">kind,</span><span class="s3">\n  </span><span class="s1">allowAliasing = true,</span><span class="s3">\n</span><span class="s1">}: Pick&lt;ReadonlyReducerState, 'nextUrl' | 'prefetchCache' | 'tree'&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">url: URL</span><span class="s3">\n  </span><span class="s1">kind?: PrefetchKind</span><span class="s3">\n  </span><span class="s1">allowAliasing: boolean</span><span class="s3">\n</span><span class="s1">}): AliasedPrefetchCacheEntry {</span><span class="s3">\n  </span><span class="s1">const existingCacheEntry = getExistingCacheEntry(</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">kind,</span><span class="s3">\n    </span><span class="s1">nextUrl,</span><span class="s3">\n    </span><span class="s1">prefetchCache,</span><span class="s3">\n    </span><span class="s1">allowAliasing</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (existingCacheEntry) {</span><span class="s3">\n    </span><span class="s1">// Grab the latest status of the cache entry and update it</span><span class="s3">\n    </span><span class="s1">existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry)</span><span class="s3">\n\n    </span><span class="s1">// when `kind` is provided, an explicit prefetch was requested.</span><span class="s3">\n    </span><span class="s1">// if the requested prefetch is </span><span class="s3">\&quot;</span><span class="s1">full</span><span class="s3">\&quot; </span><span class="s1">and the current cache entry wasn't, we want to re-prefetch with the new intent</span><span class="s3">\n    </span><span class="s1">const switchedToFullPrefetch =</span><span class="s3">\n      </span><span class="s1">existingCacheEntry.kind !== PrefetchKind.FULL &amp;&amp;</span><span class="s3">\n      </span><span class="s1">kind === PrefetchKind.FULL</span><span class="s3">\n\n    </span><span class="s1">if (switchedToFullPrefetch) {</span><span class="s3">\n      </span><span class="s1">// If we switched to a full prefetch, validate that the existing cache entry contained partial data.</span><span class="s3">\n      </span><span class="s1">// It's possible that the cache entry was seeded with full data but has a cache type of </span><span class="s3">\&quot;</span><span class="s1">auto</span><span class="s3">\&quot; </span><span class="s1">(ie when cache entries</span><span class="s3">\n      </span><span class="s1">// are seeded but without a prefetch intent)</span><span class="s3">\n      </span><span class="s1">existingCacheEntry.data.then((prefetchResponse) =&gt; {</span><span class="s3">\n        </span><span class="s1">const isFullPrefetch =</span><span class="s3">\n          </span><span class="s1">Array.isArray(prefetchResponse.flightData) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">prefetchResponse.flightData.some((flightData) =&gt; {</span><span class="s3">\n            </span><span class="s1">// If we started rendering from the root and we returned RSC data (seedData), we already had a full prefetch.</span><span class="s3">\n            </span><span class="s1">return flightData.isRootRender &amp;&amp; flightData.seedData !== null</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">if (!isFullPrefetch) {</span><span class="s3">\n          </span><span class="s1">return createLazyPrefetchEntry({</span><span class="s3">\n            </span><span class="s1">tree,</span><span class="s3">\n            </span><span class="s1">url,</span><span class="s3">\n            </span><span class="s1">nextUrl,</span><span class="s3">\n            </span><span class="s1">prefetchCache,</span><span class="s3">\n            </span><span class="s1">// If we didn't get an explicit prefetch kind, we want to set a temporary kind</span><span class="s3">\n            </span><span class="s1">// rather than assuming the same intent as the previous entry, to be consistent with how we</span><span class="s3">\n            </span><span class="s1">// lazily create prefetch entries when intent is left unspecified.</span><span class="s3">\n            </span><span class="s1">kind: kind ?? PrefetchKind.TEMPORARY,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,</span><span class="s3">\n    </span><span class="s1">// where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.</span><span class="s3">\n    </span><span class="s1">if (kind &amp;&amp; existingCacheEntry.kind === PrefetchKind.TEMPORARY) {</span><span class="s3">\n      </span><span class="s1">existingCacheEntry.kind = kind</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// We've determined that the existing entry we found is still valid, so we return it.</span><span class="s3">\n    </span><span class="s1">return existingCacheEntry</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If we didn't return an entry, create a new one.</span><span class="s3">\n  </span><span class="s1">return createLazyPrefetchEntry({</span><span class="s3">\n    </span><span class="s1">tree,</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">nextUrl,</span><span class="s3">\n    </span><span class="s1">prefetchCache,</span><span class="s3">\n    </span><span class="s1">kind: kind || PrefetchKind.TEMPORARY,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Used to take an existing cache entry and prefix it with the nextUrl, if it exists.</span><span class="s3">\n </span><span class="s1">* This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function prefixExistingPrefetchCacheEntry({</span><span class="s3">\n  </span><span class="s1">url,</span><span class="s3">\n  </span><span class="s1">nextUrl,</span><span class="s3">\n  </span><span class="s1">prefetchCache,</span><span class="s3">\n  </span><span class="s1">existingCacheKey,</span><span class="s3">\n</span><span class="s1">}: Pick&lt;ReadonlyReducerState, 'nextUrl' | 'prefetchCache'&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">url: URL</span><span class="s3">\n  </span><span class="s1">existingCacheKey: string</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">const existingCacheEntry = prefetchCache.get(existingCacheKey)</span><span class="s3">\n  </span><span class="s1">if (!existingCacheEntry) {</span><span class="s3">\n    </span><span class="s1">// no-op -- there wasn't an entry to move</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const newCacheKey = createPrefetchCacheKey(</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">existingCacheEntry.kind,</span><span class="s3">\n    </span><span class="s1">nextUrl</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">prefetchCache.set(newCacheKey, { ...existingCacheEntry, key: newCacheKey })</span><span class="s3">\n  </span><span class="s1">prefetchCache.delete(existingCacheKey)</span><span class="s3">\n\n  </span><span class="s1">return newCacheKey</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Use to seed the prefetch cache with data that has already been fetched.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function createSeededPrefetchCacheEntry({</span><span class="s3">\n  </span><span class="s1">nextUrl,</span><span class="s3">\n  </span><span class="s1">tree,</span><span class="s3">\n  </span><span class="s1">prefetchCache,</span><span class="s3">\n  </span><span class="s1">url,</span><span class="s3">\n  </span><span class="s1">data,</span><span class="s3">\n  </span><span class="s1">kind,</span><span class="s3">\n</span><span class="s1">}: Pick&lt;ReadonlyReducerState, 'nextUrl' | 'tree' | 'prefetchCache'&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">url: URL</span><span class="s3">\n  </span><span class="s1">data: FetchServerResponseResult</span><span class="s3">\n  </span><span class="s1">kind: PrefetchKind</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">// The initial cache entry technically includes full data, but it isn't explicitly prefetched -- we just seed the</span><span class="s3">\n  </span><span class="s1">// prefetch cache so that we can skip an extra prefetch request later, since we already have the data.</span><span class="s3">\n  </span><span class="s1">// if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key</span><span class="s3">\n  </span><span class="s1">const prefetchCacheKey = data.couldBeIntercepted</span><span class="s3">\n    </span><span class="s1">? createPrefetchCacheKey(url, kind, nextUrl)</span><span class="s3">\n    </span><span class="s1">: createPrefetchCacheKey(url, kind)</span><span class="s3">\n\n  </span><span class="s1">const prefetchEntry = {</span><span class="s3">\n    </span><span class="s1">treeAtTimeOfPrefetch: tree,</span><span class="s3">\n    </span><span class="s1">data: Promise.resolve(data),</span><span class="s3">\n    </span><span class="s1">kind,</span><span class="s3">\n    </span><span class="s1">prefetchTime: Date.now(),</span><span class="s3">\n    </span><span class="s1">lastUsedTime: Date.now(),</span><span class="s3">\n    </span><span class="s1">staleTime: data.staleTime,</span><span class="s3">\n    </span><span class="s1">key: prefetchCacheKey,</span><span class="s3">\n    </span><span class="s1">status: PrefetchCacheEntryStatus.fresh,</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n  </span><span class="s1">} satisfies PrefetchCacheEntry</span><span class="s3">\n\n  </span><span class="s1">prefetchCache.set(prefetchCacheKey, prefetchEntry)</span><span class="s3">\n\n  </span><span class="s1">return prefetchEntry</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createLazyPrefetchEntry({</span><span class="s3">\n  </span><span class="s1">url,</span><span class="s3">\n  </span><span class="s1">kind,</span><span class="s3">\n  </span><span class="s1">tree,</span><span class="s3">\n  </span><span class="s1">nextUrl,</span><span class="s3">\n  </span><span class="s1">prefetchCache,</span><span class="s3">\n</span><span class="s1">}: Pick&lt;ReadonlyReducerState, 'nextUrl' | 'tree' | 'prefetchCache'&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">url: URL</span><span class="s3">\n  </span><span class="s1">kind: PrefetchKind</span><span class="s3">\n</span><span class="s1">}): PrefetchCacheEntry {</span><span class="s3">\n  </span><span class="s1">const prefetchCacheKey = createPrefetchCacheKey(url, kind)</span><span class="s3">\n\n  </span><span class="s1">// initiates the fetch request for the prefetch and attaches a listener</span><span class="s3">\n  </span><span class="s1">// to the promise to update the prefetch cache entry when the promise resolves (if necessary)</span><span class="s3">\n  </span><span class="s1">const data = prefetchQueue.enqueue(() =&gt;</span><span class="s3">\n    </span><span class="s1">fetchServerResponse(url, {</span><span class="s3">\n      </span><span class="s1">flightRouterState: tree,</span><span class="s3">\n      </span><span class="s1">nextUrl,</span><span class="s3">\n      </span><span class="s1">prefetchKind: kind,</span><span class="s3">\n    </span><span class="s1">}).then((prefetchResponse) =&gt; {</span><span class="s3">\n      </span><span class="s1">// TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations</span><span class="s3">\n      </span><span class="s1">// to avoid drift between this cache key prefixing logic</span><span class="s3">\n      </span><span class="s1">// (which is currently directly influenced by the server response)</span><span class="s3">\n      </span><span class="s1">let newCacheKey</span><span class="s3">\n\n      </span><span class="s1">if (prefetchResponse.couldBeIntercepted) {</span><span class="s3">\n        </span><span class="s1">// Determine if we need to prefix the cache key with the nextUrl</span><span class="s3">\n        </span><span class="s1">newCacheKey = prefixExistingPrefetchCacheEntry({</span><span class="s3">\n          </span><span class="s1">url,</span><span class="s3">\n          </span><span class="s1">existingCacheKey: prefetchCacheKey,</span><span class="s3">\n          </span><span class="s1">nextUrl,</span><span class="s3">\n          </span><span class="s1">prefetchCache,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// If the prefetch was a cache hit, we want to update the existing cache entry to reflect that it was a full prefetch.</span><span class="s3">\n      </span><span class="s1">// This is because we know that a static response will contain the full RSC payload, and can be updated to respect the `static`</span><span class="s3">\n      </span><span class="s1">// staleTime.</span><span class="s3">\n      </span><span class="s1">if (prefetchResponse.prerendered) {</span><span class="s3">\n        </span><span class="s1">const existingCacheEntry = prefetchCache.get(</span><span class="s3">\n          </span><span class="s1">// if we prefixed the cache key due to route interception, we want to use the new key. Otherwise we use the original key</span><span class="s3">\n          </span><span class="s1">newCacheKey ?? prefetchCacheKey</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">if (existingCacheEntry) {</span><span class="s3">\n          </span><span class="s1">existingCacheEntry.kind = PrefetchKind.FULL</span><span class="s3">\n          </span><span class="s1">if (prefetchResponse.staleTime !== -1) {</span><span class="s3">\n            </span><span class="s1">// This is the stale time that was collected by the server during</span><span class="s3">\n            </span><span class="s1">// static generation. Use this in place of the default stale time.</span><span class="s3">\n            </span><span class="s1">existingCacheEntry.staleTime = prefetchResponse.staleTime</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return prefetchResponse</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const prefetchEntry = {</span><span class="s3">\n    </span><span class="s1">treeAtTimeOfPrefetch: tree,</span><span class="s3">\n    </span><span class="s1">data,</span><span class="s3">\n    </span><span class="s1">kind,</span><span class="s3">\n    </span><span class="s1">prefetchTime: Date.now(),</span><span class="s3">\n    </span><span class="s1">lastUsedTime: null,</span><span class="s3">\n    </span><span class="s1">staleTime: -1,</span><span class="s3">\n    </span><span class="s1">key: prefetchCacheKey,</span><span class="s3">\n    </span><span class="s1">status: PrefetchCacheEntryStatus.fresh,</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">prefetchCache.set(prefetchCacheKey, prefetchEntry)</span><span class="s3">\n\n  </span><span class="s1">return prefetchEntry</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function prunePrefetchCache(</span><span class="s3">\n  </span><span class="s1">prefetchCache: ReadonlyReducerState['prefetchCache']</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">for (const [href, prefetchCacheEntry] of prefetchCache) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">getPrefetchEntryCacheStatus(prefetchCacheEntry) ===</span><span class="s3">\n      </span><span class="s1">PrefetchCacheEntryStatus.expired</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">prefetchCache.delete(href)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)</span><span class="s3">\n</span><span class="s1">// and default to 5 minutes (static) / 0 seconds (dynamic)</span><span class="s3">\n</span><span class="s1">export const DYNAMIC_STALETIME_MS =</span><span class="s3">\n  </span><span class="s1">Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000</span><span class="s3">\n\n</span><span class="s1">export const STATIC_STALETIME_MS =</span><span class="s3">\n  </span><span class="s1">Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME) * 1000</span><span class="s3">\n\n</span><span class="s1">function getPrefetchEntryCacheStatus({</span><span class="s3">\n  </span><span class="s1">kind,</span><span class="s3">\n  </span><span class="s1">prefetchTime,</span><span class="s3">\n  </span><span class="s1">lastUsedTime,</span><span class="s3">\n</span><span class="s1">}: PrefetchCacheEntry): PrefetchCacheEntryStatus {</span><span class="s3">\n  </span><span class="s1">// We will re-use the cache entry data for up to the `dynamic` staletime window.</span><span class="s3">\n  </span><span class="s1">if (Date.now() &lt; (lastUsedTime ?? prefetchTime) + DYNAMIC_STALETIME_MS) {</span><span class="s3">\n    </span><span class="s1">return lastUsedTime</span><span class="s3">\n      </span><span class="s1">? PrefetchCacheEntryStatus.reusable</span><span class="s3">\n      </span><span class="s1">: PrefetchCacheEntryStatus.fresh</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// For </span><span class="s3">\&quot;</span><span class="s1">auto</span><span class="s3">\&quot; </span><span class="s1">prefetching, we'll re-use only the loading boundary for up to `static` staletime window.</span><span class="s3">\n  </span><span class="s1">// A stale entry will only re-use the `loading` boundary, not the full data.</span><span class="s3">\n  </span><span class="s1">// This will trigger a </span><span class="s3">\&quot;</span><span class="s1">lazy fetch</span><span class="s3">\&quot; </span><span class="s1">for the full data.</span><span class="s3">\n  </span><span class="s1">if (kind === PrefetchKind.AUTO) {</span><span class="s3">\n    </span><span class="s1">if (Date.now() &lt; prefetchTime + STATIC_STALETIME_MS) {</span><span class="s3">\n      </span><span class="s1">return PrefetchCacheEntryStatus.stale</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// for </span><span class="s3">\&quot;</span><span class="s1">full</span><span class="s3">\&quot; </span><span class="s1">prefetching, we'll re-use the cache entry data for up to `static` staletime window.</span><span class="s3">\n  </span><span class="s1">if (kind === PrefetchKind.FULL) {</span><span class="s3">\n    </span><span class="s1">if (Date.now() &lt; prefetchTime + STATIC_STALETIME_MS) {</span><span class="s3">\n      </span><span class="s1">return PrefetchCacheEntryStatus.reusable</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return PrefetchCacheEntryStatus.expired</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;DYNAMIC_STALETIME_MS&quot;</span><span class="s0">,</span><span class="s1">&quot;STATIC_STALETIME_MS&quot;</span><span class="s0">,</span><span class="s1">&quot;createSeededPrefetchCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;getOrCreatePrefetchCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;prunePrefetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;INTERCEPTION_CACHE_KEY_MARKER&quot;</span><span class="s0">,</span><span class="s1">&quot;createPrefetchCacheKeyImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;includeSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">,</span><span class="s1">&quot;pathnameFromUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;createPrefetchCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchKind&quot;</span><span class="s0">,</span><span class="s1">&quot;FULL&quot;</span><span class="s0">,</span><span class="s1">&quot;getExistingCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;allowAliasing&quot;</span><span class="s0">,</span><span class="s1">&quot;TEMPORARY&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeNextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKeyWithParams&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKeyWithoutParams&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKeyToUse&quot;</span><span class="s0">,</span><span class="s1">&quot;existingEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;isAliased&quot;</span><span class="s0">,</span><span class="s1">&quot;aliased&quot;</span><span class="s0">,</span><span class="s1">&quot;entryWithoutParams&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;getPrefetchEntryCacheStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;switchedToFullPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;isFullPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootRender&quot;</span><span class="s0">,</span><span class="s1">&quot;seedData&quot;</span><span class="s0">,</span><span class="s1">&quot;createLazyPrefetchEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;prefixExistingPrefetchCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;newCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;couldBeIntercepted&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;treeAtTimeOfPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchTime&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;lastUsedTime&quot;</span><span class="s0">,</span><span class="s1">&quot;staleTime&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchCacheEntryStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;fresh&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;enqueue&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchServerResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchKind&quot;</span><span class="s0">,</span><span class="s1">&quot;prerendered&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;expired&quot;</span><span class="s0">,</span><span class="s1">&quot;Number&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CLIENT_ROUTER_STATIC_STALETIME&quot;</span><span class="s0">,</span><span class="s1">&quot;reusable&quot;</span><span class="s0">,</span><span class="s1">&quot;AUTO&quot;</span><span class="s0">,</span><span class="s1">&quot;stale&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>