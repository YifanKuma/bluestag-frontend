<html>
<head>
<title>memory-with-gc-cache-plugin.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
memory-with-gc-cache-plugin.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/build/webpack/plugins/memory-with-gc-cache-plugin.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/*</span><span class="s3">\n</span><span class="s1">This plugin is based on the internal one in webpack but heavily modified to use a different caching heuristic.</span><span class="s3">\n</span><span class="s1">https://github.com/webpack/webpack/blob/853bfda35a0080605c09e1bdeb0103bcb9367a10/lib/cache/MemoryWithGcCachePlugin.js#L15</span><span class="s3">\n\n</span><span class="s1">https://github.com/webpack/webpack/blob/main/LICENSE</span><span class="s3">\n</span><span class="s1">Copyright JS Foundation and other contributors</span><span class="s3">\n\n</span><span class="s1">Permission is hereby granted, free of charge, to any person obtaining</span><span class="s3">\n</span><span class="s1">a copy of this software and associated documentation files (the</span><span class="s3">\n</span><span class="s1">'Software'), to deal in the Software without restriction, including</span><span class="s3">\n</span><span class="s1">without limitation the rights to use, copy, modify, merge, publish,</span><span class="s3">\n</span><span class="s1">distribute, sublicense, and/or sell copies of the Software, and to</span><span class="s3">\n</span><span class="s1">permit persons to whom the Software is furnished to do so, subject to</span><span class="s3">\n</span><span class="s1">the following conditions:</span><span class="s3">\n\n</span><span class="s1">The above copyright notice and this permission notice shall be</span><span class="s3">\n</span><span class="s1">included in all copies or substantial portions of the Software.</span><span class="s3">\n\n</span><span class="s1">THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,</span><span class="s3">\n</span><span class="s1">EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span><span class="s3">\n</span><span class="s1">MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.</span><span class="s3">\n</span><span class="s1">IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY</span><span class="s3">\n</span><span class="s1">CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,</span><span class="s3">\n</span><span class="s1">TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE</span><span class="s3">\n</span><span class="s1">SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n</span><span class="s1">The change in this plugin compared to the built-in one in webpack is that this plugin always cleans up after 5 compilations.</span><span class="s3">\n</span><span class="s1">The built-in plugin only cleans up </span><span class="s3">\&quot;</span><span class="s1">total modules / max generations</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n</span><span class="s1">The default for max generations is 5, so 1/5th of the modules would be marked for deletion.</span><span class="s3">\n</span><span class="s1">This plugin instead always checks the cache and decreases the time to live of all entries. That way memory is cleaned up earlier.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import type { webpack } from 'next/dist/compiled/webpack/webpack'</span><span class="s3">\n</span><span class="s1">import type { Compiler } from 'next/dist/compiled/webpack/webpack'</span><span class="s3">\n\n</span><span class="s1">// Webpack doesn't expose Etag as a type so get it this way instead.</span><span class="s3">\n</span><span class="s1">type Etag = Parameters&lt;typeof webpack.Cache.prototype.get&gt;[1]</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Entry in the memory cache</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">interface CacheEntry {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Webpack provided etag</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">etag: Etag</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Webpack provided data</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">data: unknown | null</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Number of compilations left before the cache item is evicted.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">ttl: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Used to hook into the memory stage of the webpack caching</span><span class="s3">\n</span><span class="s1">const CACHE_STAGE_MEMORY = -10 // TODO: Somehow webpack.Cache.STAGE_MEMORY doesn't work.</span><span class="s3">\n\n</span><span class="s1">const PLUGIN_NAME = 'NextJsMemoryWithGcCachePlugin'</span><span class="s3">\n\n</span><span class="s1">export class MemoryWithGcCachePlugin {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Maximum number of compilations to keep the cache entry around for when it's not used.</span><span class="s3">\n   </span><span class="s1">* We keep the modules for a few more compilations so that if you comment out a package and bring it back it doesn't need a full compile again.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private maxGenerations: number</span><span class="s3">\n  </span><span class="s1">constructor({ maxGenerations }: { maxGenerations: number }) {</span><span class="s3">\n    </span><span class="s1">this.maxGenerations = maxGenerations</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">apply(compiler: Compiler) {</span><span class="s3">\n    </span><span class="s1">const maxGenerations = this.maxGenerations</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The memory cache</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const cache = new Map&lt;string, CacheEntry&gt;()</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Cache cleanup implementation</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function decreaseTTLAndEvict() {</span><span class="s3">\n      </span><span class="s1">for (const [identifier, entry] of cache) {</span><span class="s3">\n        </span><span class="s1">// Decrease item time to live</span><span class="s3">\n        </span><span class="s1">entry.ttl--</span><span class="s3">\n\n        </span><span class="s1">// if ttl is 0 or below, evict entry from the cache</span><span class="s3">\n        </span><span class="s1">if (entry.ttl &lt;= 0) {</span><span class="s3">\n          </span><span class="s1">cache.delete(identifier)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">compiler.hooks.afterDone.tap(PLUGIN_NAME, decreaseTTLAndEvict)</span><span class="s3">\n    </span><span class="s1">compiler.cache.hooks.store.tap(</span><span class="s3">\n      </span><span class="s1">{ name: PLUGIN_NAME, stage: CACHE_STAGE_MEMORY },</span><span class="s3">\n      </span><span class="s1">(identifier, etag, data) =&gt; {</span><span class="s3">\n        </span><span class="s1">cache.set(identifier, { etag, data, ttl: maxGenerations })</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">compiler.cache.hooks.get.tap(</span><span class="s3">\n      </span><span class="s1">{ name: PLUGIN_NAME, stage: CACHE_STAGE_MEMORY },</span><span class="s3">\n      </span><span class="s1">(identifier, etag, gotHandlers) =&gt; {</span><span class="s3">\n        </span><span class="s1">const cacheEntry = cache.get(identifier)</span><span class="s3">\n        </span><span class="s1">// Item found</span><span class="s3">\n        </span><span class="s1">if (cacheEntry !== undefined) {</span><span class="s3">\n          </span><span class="s1">// When cache entry is hit we reset the counter.</span><span class="s3">\n          </span><span class="s1">cacheEntry.ttl = maxGenerations</span><span class="s3">\n          </span><span class="s1">// Handles `null` separately as it doesn't have an etag.</span><span class="s3">\n          </span><span class="s1">if (cacheEntry.data === null) {</span><span class="s3">\n            </span><span class="s1">return null</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">return cacheEntry.etag === etag ? cacheEntry.data : null</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Handle case where other cache does have the identifier, puts it into the memory cache</span><span class="s3">\n        </span><span class="s1">gotHandlers.push((result, callback) =&gt; {</span><span class="s3">\n          </span><span class="s1">cache.set(identifier, {</span><span class="s3">\n            </span><span class="s1">// Handles `null` separately as it doesn't have an etag.</span><span class="s3">\n            </span><span class="s1">etag: result === null ? null : etag,</span><span class="s3">\n            </span><span class="s1">data: result,</span><span class="s3">\n            </span><span class="s1">ttl: maxGenerations,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">return callback()</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">// No item found</span><span class="s3">\n        </span><span class="s1">return undefined</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">compiler.cache.hooks.shutdown.tap(</span><span class="s3">\n      </span><span class="s1">{ name: PLUGIN_NAME, stage: CACHE_STAGE_MEMORY },</span><span class="s3">\n      </span><span class="s1">() =&gt; {</span><span class="s3">\n        </span><span class="s1">cache.clear()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;MemoryWithGcCachePlugin&quot;</span><span class="s0">,</span><span class="s1">&quot;CACHE_STAGE_MEMORY&quot;</span><span class="s0">,</span><span class="s1">&quot;PLUGIN_NAME&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;maxGenerations&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;compiler&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;decreaseTTLAndEvict&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;entry&quot;</span><span class="s0">,</span><span class="s1">&quot;ttl&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;hooks&quot;</span><span class="s0">,</span><span class="s1">&quot;afterDone&quot;</span><span class="s0">,</span><span class="s1">&quot;tap&quot;</span><span class="s0">,</span><span class="s1">&quot;store&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;stage&quot;</span><span class="s0">,</span><span class="s1">&quot;etag&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;gotHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;callback&quot;</span><span class="s0">,</span><span class="s1">&quot;shutdown&quot;</span><span class="s0">,</span><span class="s1">&quot;clear&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,GAEA;;;;;AAKA;;;;+BA+BaA;;;eAAAA;;;AALb,4DAA4D;AAC5D,MAAMC,qBAAqB,CAAC,GAAG,yDAAyD;;AAExF,MAAMC,cAAc;AAEb,MAAMF;IAMXG,YAAY,EAAEC,cAAc,EAA8B,CAAE;QAC1D,IAAI,CAACA,cAAc,GAAGA;IACxB;IACAC,MAAMC,QAAkB,EAAE;QACxB,MAAMF,iBAAiB,IAAI,CAACA,cAAc;QAE1C;;KAEC,GACD,MAAMG,QAAQ,IAAIC;QAElB;;KAEC,GACD,SAASC;YACP,KAAK,MAAM,CAACC,YAAYC,MAAM,IAAIJ,MAAO;gBACvC,6BAA6B;gBAC7BI,MAAMC,GAAG;gBAET,mDAAmD;gBACnD,IAAID,MAAMC,GAAG,IAAI,GAAG;oBAClBL,MAAMM,MAAM,CAACH;gBACf;YACF;QACF;QACAJ,SAASQ,KAAK,CAACC,SAAS,CAACC,GAAG,CAACd,aAAaO;QAC1CH,SAASC,KAAK,CAACO,KAAK,CAACG,KAAK,CAACD,GAAG,CAC5B;YAAEE,MAAMhB;YAAaiB,OAAOlB;QAAmB,GAC/C,CAACS,YAAYU,MAAMC;YACjBd,MAAMe,GAAG,CAACZ,YAAY;gBAAEU;gBAAMC;gBAAMT,KAAKR;YAAe;QAC1D;QAEFE,SAASC,KAAK,CAACO,KAAK,CAACS,GAAG,CAACP,GAAG,CAC1B;YAAEE,MAAMhB;YAAaiB,OAAOlB;QAAmB,GAC/C,CAACS,YAAYU,MAAMI;YACjB,MAAMC,aAAalB,MAAMgB,GAAG,CAACb;YAC7B,aAAa;YACb,IAAIe,eAAeC,WAAW;gBAC5B,gDAAgD;gBAChDD,WAAWb,GAAG,GAAGR;gBACjB,wDAAwD;gBACxD,IAAIqB,WAAWJ,IAAI,KAAK,MAAM;oBAC5B,OAAO;gBACT;gBAEA,OAAOI,WAAWL,IAAI,KAAKA,OAAOK,WAAWJ,IAAI,GAAG;YACtD;YAEA,wFAAwF;YACxFG,YAAYG,IAAI,CAAC,CAACC,QAAQC;gBACxBtB,MAAMe,GAAG,CAACZ,YAAY;oBACpB,wDAAwD;oBACxDU,MAAMQ,WAAW,OAAO,OAAOR;oBAC/BC,MAAMO;oBACNhB,KAAKR;gBACP;gBACA,OAAOyB;YACT;YAEA,gBAAgB;YAChB,OAAOH;QACT;QAEFpB,SAASC,KAAK,CAACO,KAAK,CAACgB,QAAQ,CAACd,GAAG,CAC/B;YAAEE,MAAMhB;YAAaiB,OAAOlB;QAAmB,GAC/C;YACEM,MAAMwB,KAAK;QACb;IAEJ;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>