<html>
<head>
<title>resolve.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #1750eb;}
.s6 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
resolve.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s1">exports.__esModule = </span><span class="s2">true</span><span class="s1">;</span>

<span class="s2">const </span><span class="s1">fs = require(</span><span class="s0">'fs'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">Module = require(</span><span class="s0">'module'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">path = require(</span><span class="s0">'path'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">{ getPhysicalFilename } = require(</span><span class="s0">'./contextCompat'</span><span class="s1">);</span>

<span class="s2">const </span><span class="s1">hashObject = require(</span><span class="s0">'./hash'</span><span class="s1">).hashObject;</span>
<span class="s2">const </span><span class="s1">ModuleCache = require(</span><span class="s0">'./ModuleCache'</span><span class="s1">).default;</span>
<span class="s2">const </span><span class="s1">pkgDir = require(</span><span class="s0">'./pkgDir'</span><span class="s1">).default;</span>

<span class="s2">const </span><span class="s1">CASE_SENSITIVE_FS = !fs.existsSync(path.join(__dirname.toUpperCase(), </span><span class="s0">'reSOLVE.js'</span><span class="s1">));</span>
<span class="s1">exports.CASE_SENSITIVE_FS = CASE_SENSITIVE_FS;</span>

<span class="s2">const </span><span class="s1">ERROR_NAME = </span><span class="s0">'EslintPluginImportResolveError'</span><span class="s1">;</span>

<span class="s2">const </span><span class="s1">fileExistsCache = </span><span class="s2">new </span><span class="s1">ModuleCache();</span>

<span class="s3">// Polyfill Node's `Module.createRequireFromPath` if not present (added in Node v10.12.0)</span>
<span class="s3">// Use `Module.createRequire` if available (added in Node v12.2.0)</span>
<span class="s2">const </span><span class="s1">createRequire = Module.createRequire</span>
  <span class="s3">// @ts-expect-error this only exists in older node</span>
  <span class="s1">|| Module.createRequireFromPath</span>
  <span class="s1">|| </span><span class="s3">/** </span><span class="s4">@type </span><span class="s3">{(filename: string) =&gt; unknown} */ </span><span class="s2">function </span><span class="s1">(filename) {</span>
    <span class="s2">const </span><span class="s1">mod = </span><span class="s2">new </span><span class="s1">Module(filename, </span><span class="s2">void null</span><span class="s1">);</span>
    <span class="s1">mod.filename = filename;</span>
    <span class="s3">// @ts-expect-error _nodeModulePaths is undocumented</span>
    <span class="s1">mod.paths = Module._nodeModulePaths(path.dirname(filename));</span>

    <span class="s3">// @ts-expect-error _compile is undocumented</span>
    <span class="s1">mod._compile(</span><span class="s0">`module.exports = require;`</span><span class="s1">, filename);</span>

    <span class="s2">return </span><span class="s1">mod.exports;</span>
  <span class="s1">};</span>

<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{(resolver: object) =&gt; resolver is import('./resolve').Resolver} */</span>
<span class="s2">function </span><span class="s1">isResolverValid(resolver) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s0">'interfaceVersion' </span><span class="s2">in </span><span class="s1">resolver &amp;&amp; resolver.interfaceVersion === </span><span class="s5">2</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s0">'resolve' </span><span class="s2">in </span><span class="s1">resolver &amp;&amp; !!resolver.resolve &amp;&amp; </span><span class="s2">typeof </span><span class="s1">resolver.resolve === </span><span class="s0">'function'</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s0">'resolveImport' </span><span class="s2">in </span><span class="s1">resolver &amp;&amp; !!resolver.resolveImport &amp;&amp; </span><span class="s2">typeof </span><span class="s1">resolver.resolveImport === </span><span class="s0">'function'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{&lt;T extends string&gt;(target: T, sourceFile?: string | null | undefined) =&gt; undefined | ReturnType&lt;typeof require&gt;} */</span>
<span class="s2">function </span><span class="s1">tryRequire(target, sourceFile) {</span>
  <span class="s2">let </span><span class="s1">resolved;</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s3">// Check if the target exists</span>
    <span class="s2">if </span><span class="s1">(sourceFile != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">resolved = createRequire(path.resolve(sourceFile)).resolve(target);</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
        <span class="s1">resolved = require.resolve(target);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">resolved = require.resolve(target);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
    <span class="s3">// If the target does not exist then just return undefined</span>
    <span class="s2">return </span><span class="s1">undefined;</span>
  <span class="s1">}</span>

  <span class="s3">// If the target exists then return the loaded module</span>
  <span class="s2">return </span><span class="s1">require(resolved);</span>
<span class="s1">}</span>

<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{&lt;T extends Map&lt;string, unknown&gt;&gt;(resolvers: string[] | string | { [k: string]: string }, map: T) =&gt; T} */</span>
<span class="s2">function </span><span class="s1">resolverReducer(resolvers, map) {</span>
  <span class="s2">if </span><span class="s1">(Array.isArray(resolvers)) {</span>
    <span class="s1">resolvers.forEach((r) =&gt; resolverReducer(r, map));</span>
    <span class="s2">return </span><span class="s1">map;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">resolvers === </span><span class="s0">'string'</span><span class="s1">) {</span>
    <span class="s1">map.set(resolvers, </span><span class="s2">null</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">map;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">resolvers === </span><span class="s0">'object'</span><span class="s1">) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">resolvers) {</span>
      <span class="s1">map.set(key, resolvers[key]);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">map;</span>
  <span class="s1">}</span>

  <span class="s2">const </span><span class="s1">err = </span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'invalid resolver config'</span><span class="s1">);</span>
  <span class="s1">err.name = ERROR_NAME;</span>
  <span class="s2">throw </span><span class="s1">err;</span>
<span class="s1">}</span>

<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{(sourceFile: string) =&gt; string} */</span>
<span class="s2">function </span><span class="s1">getBaseDir(sourceFile) {</span>
  <span class="s2">return </span><span class="s1">pkgDir(sourceFile) || process.cwd();</span>
<span class="s1">}</span>

<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{(name: string, sourceFile: string) =&gt; import('./resolve').Resolver} */</span>
<span class="s2">function </span><span class="s1">requireResolver(name, sourceFile) {</span>
  <span class="s3">// Try to resolve package with conventional name</span>
  <span class="s2">const </span><span class="s1">resolver = tryRequire(</span><span class="s0">`eslint-import-resolver-</span><span class="s1">${name}</span><span class="s0">`</span><span class="s1">, sourceFile)</span>
    <span class="s1">|| tryRequire(name, sourceFile)</span>
    <span class="s1">|| tryRequire(path.resolve(getBaseDir(sourceFile), name));</span>

  <span class="s2">if </span><span class="s1">(!resolver) {</span>
    <span class="s2">const </span><span class="s1">err = </span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`unable to load resolver &quot;</span><span class="s1">${name}</span><span class="s0">&quot;.`</span><span class="s1">);</span>
    <span class="s1">err.name = ERROR_NAME;</span>
    <span class="s2">throw </span><span class="s1">err;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!isResolverValid(resolver)) {</span>
    <span class="s2">const </span><span class="s1">err = </span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`</span><span class="s1">${name} </span><span class="s0">with invalid interface loaded as resolver`</span><span class="s1">);</span>
    <span class="s1">err.name = ERROR_NAME;</span>
    <span class="s2">throw </span><span class="s1">err;</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">resolver;</span>
<span class="s1">}</span>

<span class="s3">// https://stackoverflow.com/a/27382838</span>
<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{import('./resolve').fileExistsWithCaseSync} */</span>
<span class="s1">exports.fileExistsWithCaseSync = </span><span class="s2">function </span><span class="s1">fileExistsWithCaseSync(filepath, cacheSettings, strict) {</span>
  <span class="s3">// don't care if the FS is case-sensitive</span>
  <span class="s2">if </span><span class="s1">(CASE_SENSITIVE_FS) { </span><span class="s2">return true</span><span class="s1">; }</span>

  <span class="s3">// null means it resolved to a builtin</span>
  <span class="s2">if </span><span class="s1">(filepath === </span><span class="s2">null</span><span class="s1">) { </span><span class="s2">return true</span><span class="s1">; }</span>
  <span class="s2">if </span><span class="s1">(filepath.toLowerCase() === process.cwd().toLowerCase() &amp;&amp; !strict) { </span><span class="s2">return true</span><span class="s1">; }</span>
  <span class="s2">const </span><span class="s1">parsedPath = path.parse(filepath);</span>
  <span class="s2">const </span><span class="s1">dir = parsedPath.dir;</span>

  <span class="s2">let </span><span class="s1">result = fileExistsCache.get(filepath, cacheSettings);</span>
  <span class="s2">if </span><span class="s1">(result != </span><span class="s2">null</span><span class="s1">) { </span><span class="s2">return </span><span class="s1">result; }</span>

  <span class="s3">// base case</span>
  <span class="s2">if </span><span class="s1">(dir === </span><span class="s0">'' </span><span class="s1">|| parsedPath.root === filepath) {</span>
    <span class="s1">result = </span><span class="s2">true</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">const </span><span class="s1">filenames = fs.readdirSync(dir);</span>
    <span class="s2">if </span><span class="s1">(filenames.indexOf(parsedPath.base) === -</span><span class="s5">1</span><span class="s1">) {</span>
      <span class="s1">result = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">result = fileExistsWithCaseSync(dir, cacheSettings, strict);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">fileExistsCache.set(filepath, result);</span>
  <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">};</span>

<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{import('./types').ESLintSettings | null} */</span>
<span class="s2">let </span><span class="s1">prevSettings = </span><span class="s2">null</span><span class="s1">;</span>
<span class="s2">let </span><span class="s1">memoizedHash = </span><span class="s0">''</span><span class="s1">;</span>
<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{(modulePath: string, sourceFile: string, settings: import('./types').ESLintSettings) =&gt; import('./resolve').ResolvedResult} */</span>
<span class="s2">function </span><span class="s1">fullResolve(modulePath, sourceFile, settings) {</span>
  <span class="s3">// check if this is a bonus core module</span>
  <span class="s2">const </span><span class="s1">coreSet = </span><span class="s2">new </span><span class="s1">Set(settings[</span><span class="s0">'import/core-modules'</span><span class="s1">]);</span>
  <span class="s2">if </span><span class="s1">(coreSet.has(modulePath)) { </span><span class="s2">return </span><span class="s1">{ found: </span><span class="s2">true</span><span class="s1">, path: </span><span class="s2">null </span><span class="s1">}; }</span>

  <span class="s2">const </span><span class="s1">sourceDir = path.dirname(sourceFile);</span>

  <span class="s2">if </span><span class="s1">(prevSettings !== settings) {</span>
    <span class="s1">memoizedHash = hashObject(settings).digest(</span><span class="s0">'hex'</span><span class="s1">);</span>
    <span class="s1">prevSettings = settings;</span>
  <span class="s1">}</span>

  <span class="s2">const </span><span class="s1">cacheKey = sourceDir + memoizedHash + modulePath;</span>

  <span class="s2">const </span><span class="s1">cacheSettings = ModuleCache.getSettings(settings);</span>

  <span class="s2">const </span><span class="s1">cachedPath = fileExistsCache.get(cacheKey, cacheSettings);</span>
  <span class="s2">if </span><span class="s1">(cachedPath !== undefined) { </span><span class="s2">return </span><span class="s1">{ found: </span><span class="s2">true</span><span class="s1">, path: cachedPath }; }</span>

  <span class="s3">/** </span><span class="s4">@type </span><span class="s3">{(resolvedPath: string | null) =&gt; void} */</span>
  <span class="s2">function </span><span class="s1">cache(resolvedPath) {</span>
    <span class="s1">fileExistsCache.set(cacheKey, resolvedPath);</span>
  <span class="s1">}</span>

  <span class="s3">/** </span><span class="s4">@type </span><span class="s3">{(resolver: import('./resolve').Resolver, config: unknown) =&gt; import('./resolve').ResolvedResult} */</span>
  <span class="s2">function </span><span class="s1">withResolver(resolver, config) {</span>
    <span class="s2">if </span><span class="s1">(resolver.interfaceVersion === </span><span class="s5">2</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">resolver.resolve(modulePath, sourceFile, config);</span>
    <span class="s1">}</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">const </span><span class="s1">resolved = resolver.resolveImport(modulePath, sourceFile, config);</span>
      <span class="s2">if </span><span class="s1">(resolved === undefined) { </span><span class="s2">return </span><span class="s1">{ found: </span><span class="s2">false </span><span class="s1">}; }</span>
      <span class="s2">return </span><span class="s1">{ found: </span><span class="s2">true</span><span class="s1">, path: resolved };</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
      <span class="s2">return </span><span class="s1">{ found: </span><span class="s2">false </span><span class="s1">};</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">const </span><span class="s1">configResolvers = settings[</span><span class="s0">'import/resolver'</span><span class="s1">]</span>
    <span class="s1">|| { node: settings[</span><span class="s0">'import/resolve'</span><span class="s1">] }; </span><span class="s3">// backward compatibility</span>

  <span class="s2">const </span><span class="s1">resolvers = resolverReducer(configResolvers, </span><span class="s2">new </span><span class="s1">Map());</span>

  <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">pair of resolvers) {</span>
    <span class="s2">const </span><span class="s1">name = pair[</span><span class="s5">0</span><span class="s1">];</span>
    <span class="s2">const </span><span class="s1">config = pair[</span><span class="s5">1</span><span class="s1">];</span>
    <span class="s2">const </span><span class="s1">resolver = requireResolver(name, sourceFile);</span>
    <span class="s2">const </span><span class="s1">resolved = withResolver(resolver, config);</span>

    <span class="s2">if </span><span class="s1">(!resolved.found) { </span><span class="s2">continue</span><span class="s1">; }</span>

    <span class="s3">// else, counts</span>
    <span class="s1">cache(resolved.path);</span>
    <span class="s2">return </span><span class="s1">resolved;</span>
  <span class="s1">}</span>

  <span class="s3">// failed</span>
  <span class="s3">// cache(undefined)</span>
  <span class="s2">return </span><span class="s1">{ found: </span><span class="s2">false </span><span class="s1">};</span>
<span class="s1">}</span>

<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{import('./resolve').relative} */</span>
<span class="s2">function </span><span class="s1">relative(modulePath, sourceFile, settings) {</span>
  <span class="s2">return </span><span class="s1">fullResolve(modulePath, sourceFile, settings).path;</span>
<span class="s1">}</span>
<span class="s1">exports.relative = relative;</span>

<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{Set&lt;import('eslint').Rule.RuleContext&gt;} */</span>
<span class="s2">const </span><span class="s1">erroredContexts = </span><span class="s2">new </span><span class="s1">Set();</span>

<span class="s3">/**</span>
 <span class="s3">* Given</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">p - module path</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">context - ESLint context</span>
 <span class="s3">* </span><span class="s4">@return </span><span class="s3">- the full module filesystem path; null if package is core; undefined if not found</span>
 <span class="s3">* </span><span class="s4">@type </span><span class="s3">{import('./resolve').default}</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">resolve(p, context) {</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s2">return </span><span class="s1">relative(p, getPhysicalFilename(context), context.settings);</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
    <span class="s2">if </span><span class="s1">(!erroredContexts.has(context)) {</span>
      <span class="s3">// The `err.stack` string starts with `err.name` followed by colon and `err.message`.</span>
      <span class="s3">// We're filtering out the default `err.name` because it adds little value to the message.</span>
      <span class="s3">// @ts-expect-error this might be an Error</span>
      <span class="s2">let </span><span class="s1">errMessage = err.message;</span>
      <span class="s3">// @ts-expect-error this might be an Error</span>
      <span class="s2">if </span><span class="s1">(err.name !== ERROR_NAME &amp;&amp; err.stack) {</span>
        <span class="s3">// @ts-expect-error this might be an Error</span>
        <span class="s1">errMessage = err.stack.replace(</span><span class="s6">/^Error: /</span><span class="s1">, </span><span class="s0">''</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s1">context.report({</span>
        <span class="s1">message: </span><span class="s0">`Resolve error: </span><span class="s1">${errMessage}</span><span class="s0">`</span><span class="s1">,</span>
        <span class="s1">loc: { line: </span><span class="s5">1</span><span class="s1">, column: </span><span class="s5">0 </span><span class="s1">},</span>
      <span class="s1">});</span>
      <span class="s1">erroredContexts.add(context);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">resolve.relative = relative;</span>
<span class="s1">exports.default = resolve;</span>
</pre>
</body>
</html>