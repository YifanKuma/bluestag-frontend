<html>
<head>
<title>strict-boolean-expressions.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
strict-boolean-expressions.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">__createBinding = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__createBinding) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s2">var </span><span class="s1">desc = Object.getOwnPropertyDescriptor(m, k);</span>
    <span class="s2">if </span><span class="s1">(!desc || (</span><span class="s0">&quot;get&quot; </span><span class="s2">in </span><span class="s1">desc ? !m.__esModule : desc.writable || desc.configurable)) {</span>
      <span class="s1">desc = { enumerable: </span><span class="s2">true</span><span class="s1">, get: </span><span class="s2">function</span><span class="s1">() { </span><span class="s2">return </span><span class="s1">m[k]; } };</span>
    <span class="s1">}</span>
    <span class="s1">Object.defineProperty(o, k2, desc);</span>
<span class="s1">}) : (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s1">o[k2] = m[k];</span>
<span class="s1">}));</span>
<span class="s2">var </span><span class="s1">__setModuleDefault = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__setModuleDefault) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">Object.defineProperty(o, </span><span class="s0">&quot;default&quot;</span><span class="s1">, { enumerable: </span><span class="s2">true</span><span class="s1">, value: v });</span>
<span class="s1">}) : </span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">o[</span><span class="s0">&quot;default&quot;</span><span class="s1">] = v;</span>
<span class="s1">});</span>
<span class="s2">var </span><span class="s1">__importStar = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__importStar) || (</span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">var </span><span class="s1">ownKeys = </span><span class="s2">function</span><span class="s1">(o) {</span>
        <span class="s1">ownKeys = Object.getOwnPropertyNames || </span><span class="s2">function </span><span class="s1">(o) {</span>
            <span class="s2">var </span><span class="s1">ar = [];</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">k </span><span class="s2">in </span><span class="s1">o) </span><span class="s2">if </span><span class="s1">(Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;</span>
            <span class="s2">return </span><span class="s1">ar;</span>
        <span class="s1">};</span>
        <span class="s2">return </span><span class="s1">ownKeys(o);</span>
    <span class="s1">};</span>
    <span class="s2">return function </span><span class="s1">(mod) {</span>
        <span class="s2">if </span><span class="s1">(mod &amp;&amp; mod.__esModule) </span><span class="s2">return </span><span class="s1">mod;</span>
        <span class="s2">var </span><span class="s1">result = {};</span>
        <span class="s2">if </span><span class="s1">(mod != </span><span class="s2">null</span><span class="s1">) </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">k = ownKeys(mod), i = </span><span class="s3">0</span><span class="s1">; i &lt; k.length; i++) </span><span class="s2">if </span><span class="s1">(k[i] !== </span><span class="s0">&quot;default&quot;</span><span class="s1">) __createBinding(result, mod, k[i]);</span>
        <span class="s1">__setModuleDefault(result, mod);</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">};</span>
<span class="s1">})();</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s2">const </span><span class="s1">utils_1 = require(</span><span class="s0">&quot;@typescript-eslint/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">tsutils = __importStar(require(</span><span class="s0">&quot;ts-api-utils&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">ts = __importStar(require(</span><span class="s0">&quot;typescript&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">util_1 = require(</span><span class="s0">&quot;../util&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">assertionFunctionUtils_1 = require(</span><span class="s0">&quot;../util/assertionFunctionUtils&quot;</span><span class="s1">);</span>
<span class="s1">exports.default = (</span><span class="s3">0</span><span class="s1">, util_1.createRule)({</span>
    <span class="s1">name: </span><span class="s0">'strict-boolean-expressions'</span><span class="s1">,</span>
    <span class="s1">meta: {</span>
        <span class="s1">type: </span><span class="s0">'suggestion'</span><span class="s1">,</span>
        <span class="s1">docs: {</span>
            <span class="s1">description: </span><span class="s0">'Disallow certain types in boolean expressions'</span><span class="s1">,</span>
            <span class="s1">requiresTypeChecking: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">hasSuggestions: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">messages: {</span>
            <span class="s1">conditionErrorAny: </span><span class="s0">'Unexpected any value in {{context}}. ' </span><span class="s1">+</span>
                <span class="s0">'An explicit comparison or type conversion is required.'</span><span class="s1">,</span>
            <span class="s1">conditionErrorNullableBoolean: </span><span class="s0">'Unexpected nullable boolean value in {{context}}. ' </span><span class="s1">+</span>
                <span class="s0">'Please handle the nullish case explicitly.'</span><span class="s1">,</span>
            <span class="s1">conditionErrorNullableEnum: </span><span class="s0">'Unexpected nullable enum value in {{context}}. ' </span><span class="s1">+</span>
                <span class="s0">'Please handle the nullish/zero/NaN cases explicitly.'</span><span class="s1">,</span>
            <span class="s1">conditionErrorNullableNumber: </span><span class="s0">'Unexpected nullable number value in {{context}}. ' </span><span class="s1">+</span>
                <span class="s0">'Please handle the nullish/zero/NaN cases explicitly.'</span><span class="s1">,</span>
            <span class="s1">conditionErrorNullableObject: </span><span class="s0">'Unexpected nullable object value in {{context}}. ' </span><span class="s1">+</span>
                <span class="s0">'An explicit null check is required.'</span><span class="s1">,</span>
            <span class="s1">conditionErrorNullableString: </span><span class="s0">'Unexpected nullable string value in {{context}}. ' </span><span class="s1">+</span>
                <span class="s0">'Please handle the nullish/empty cases explicitly.'</span><span class="s1">,</span>
            <span class="s1">conditionErrorNullish: </span><span class="s0">'Unexpected nullish value in conditional. ' </span><span class="s1">+</span>
                <span class="s0">'The condition is always false.'</span><span class="s1">,</span>
            <span class="s1">conditionErrorNumber: </span><span class="s0">'Unexpected number value in {{context}}. ' </span><span class="s1">+</span>
                <span class="s0">'An explicit zero/NaN check is required.'</span><span class="s1">,</span>
            <span class="s1">conditionErrorObject: </span><span class="s0">'Unexpected object value in {{context}}. ' </span><span class="s1">+</span>
                <span class="s0">'The condition is always true.'</span><span class="s1">,</span>
            <span class="s1">conditionErrorOther: </span><span class="s0">'Unexpected value in conditional. ' </span><span class="s1">+</span>
                <span class="s0">'A boolean expression is required.'</span><span class="s1">,</span>
            <span class="s1">conditionErrorString: </span><span class="s0">'Unexpected string value in {{context}}. ' </span><span class="s1">+</span>
                <span class="s0">'An explicit empty string check is required.'</span><span class="s1">,</span>
            <span class="s1">conditionFixCastBoolean: </span><span class="s0">'Explicitly convert value to a boolean (`Boolean(value)`)'</span><span class="s1">,</span>
            <span class="s1">conditionFixCompareArrayLengthNonzero: </span><span class="s0">&quot;Change condition to check array's length (`value.length &gt; 0`)&quot;</span><span class="s1">,</span>
            <span class="s1">conditionFixCompareArrayLengthZero: </span><span class="s0">&quot;Change condition to check array's length (`value.length === 0`)&quot;</span><span class="s1">,</span>
            <span class="s1">conditionFixCompareEmptyString: </span><span class="s0">'Change condition to check for empty string (`value !== &quot;&quot;`)'</span><span class="s1">,</span>
            <span class="s1">conditionFixCompareFalse: </span><span class="s0">'Change condition to check if false (`value === false`)'</span><span class="s1">,</span>
            <span class="s1">conditionFixCompareNaN: </span><span class="s0">'Change condition to check for NaN (`!Number.isNaN(value)`)'</span><span class="s1">,</span>
            <span class="s1">conditionFixCompareNullish: </span><span class="s0">'Change condition to check for null/undefined (`value != null`)'</span><span class="s1">,</span>
            <span class="s1">conditionFixCompareStringLength: </span><span class="s0">&quot;Change condition to check string's length (`value.length !== 0`)&quot;</span><span class="s1">,</span>
            <span class="s1">conditionFixCompareTrue: </span><span class="s0">'Change condition to check if true (`value === true`)'</span><span class="s1">,</span>
            <span class="s1">conditionFixCompareZero: </span><span class="s0">'Change condition to check for 0 (`value !== 0`)'</span><span class="s1">,</span>
            <span class="s1">conditionFixDefaultEmptyString: </span><span class="s0">'Explicitly treat nullish value the same as an empty string (`value ?? &quot;&quot;`)'</span><span class="s1">,</span>
            <span class="s1">conditionFixDefaultFalse: </span><span class="s0">'Explicitly treat nullish value the same as false (`value ?? false`)'</span><span class="s1">,</span>
            <span class="s1">conditionFixDefaultZero: </span><span class="s0">'Explicitly treat nullish value the same as 0 (`value ?? 0`)'</span><span class="s1">,</span>
            <span class="s1">explicitBooleanReturnType: </span><span class="s0">'Add an explicit `boolean` return type annotation.'</span><span class="s1">,</span>
            <span class="s1">noStrictNullCheck: </span><span class="s0">'This rule requires the `strictNullChecks` compiler option to be turned on to function correctly.'</span><span class="s1">,</span>
            <span class="s1">predicateCannotBeAsync: </span><span class="s0">&quot;Predicate function should not be 'async'; expected a boolean return type.&quot;</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">schema: [</span>
            <span class="s1">{</span>
                <span class="s1">type: </span><span class="s0">'object'</span><span class="s1">,</span>
                <span class="s1">additionalProperties: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">properties: {</span>
                    <span class="s1">allowAny: {</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                        <span class="s1">description: </span><span class="s0">'Whether to allow `any`s in a boolean context.'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">allowNullableBoolean: {</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                        <span class="s1">description: </span><span class="s0">'Whether to allow nullable `boolean`s in a boolean context.'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">allowNullableEnum: {</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                        <span class="s1">description: </span><span class="s0">'Whether to allow nullable `enum`s in a boolean context.'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">allowNullableNumber: {</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                        <span class="s1">description: </span><span class="s0">'Whether to allow nullable `number`s in a boolean context.'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">allowNullableObject: {</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                        <span class="s1">description: </span><span class="s0">'Whether to allow nullable `object`s, `symbol`s, and functions in a boolean context.'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">allowNullableString: {</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                        <span class="s1">description: </span><span class="s0">'Whether to allow nullable `string`s in a boolean context.'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">allowNumber: {</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                        <span class="s1">description: </span><span class="s0">'Whether to allow `number`s in a boolean context.'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: {</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                        <span class="s1">description: </span><span class="s0">'Unless this is set to `true`, the rule will error on every file whose `tsconfig.json` does _not_ have the `strictNullChecks` compiler option (or `strict`) set to `true`.'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">allowString: {</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                        <span class="s1">description: </span><span class="s0">'Whether to allow `string`s in a boolean context.'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                <span class="s1">},</span>
            <span class="s1">},</span>
        <span class="s1">],</span>
    <span class="s1">},</span>
    <span class="s1">defaultOptions: [</span>
        <span class="s1">{</span>
            <span class="s1">allowAny: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">allowNullableBoolean: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">allowNullableEnum: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">allowNullableNumber: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">allowNullableObject: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">allowNullableString: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">allowNumber: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">allowString: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">},</span>
    <span class="s1">],</span>
    <span class="s1">create(context, [options]) {</span>
        <span class="s2">const </span><span class="s1">services = (</span><span class="s3">0</span><span class="s1">, util_1.getParserServices)(context);</span>
        <span class="s2">const </span><span class="s1">checker = services.program.getTypeChecker();</span>
        <span class="s2">const </span><span class="s1">compilerOptions = services.program.getCompilerOptions();</span>
        <span class="s2">const </span><span class="s1">isStrictNullChecks = tsutils.isStrictCompilerOptionEnabled(compilerOptions, </span><span class="s0">'strictNullChecks'</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(!isStrictNullChecks &amp;&amp;</span>
            <span class="s1">options.allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing !== </span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s1">context.report({</span>
                <span class="s1">loc: {</span>
                    <span class="s1">start: { column: </span><span class="s3">0</span><span class="s1">, line: </span><span class="s3">0 </span><span class="s1">},</span>
                    <span class="s1">end: { column: </span><span class="s3">0</span><span class="s1">, line: </span><span class="s3">0 </span><span class="s1">},</span>
                <span class="s1">},</span>
                <span class="s1">messageId: </span><span class="s0">'noStrictNullCheck'</span><span class="s1">,</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">traversedNodes = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">CallExpression: traverseCallExpression,</span>
            <span class="s1">ConditionalExpression: traverseTestExpression,</span>
            <span class="s1">DoWhileStatement: traverseTestExpression,</span>
            <span class="s1">ForStatement: traverseTestExpression,</span>
            <span class="s1">IfStatement: traverseTestExpression,</span>
            <span class="s0">'LogicalExpression[operator!=&quot;??&quot;]'</span><span class="s1">: traverseLogicalExpression,</span>
            <span class="s0">'UnaryExpression[operator=&quot;!&quot;]'</span><span class="s1">: traverseUnaryLogicalExpression,</span>
            <span class="s1">WhileStatement: traverseTestExpression,</span>
        <span class="s1">};</span>
        <span class="s4">/**</span>
         <span class="s4">* Inspects condition of a test expression. (`if`, `while`, `for`, etc.)</span>
         <span class="s4">*/</span>
        <span class="s2">function </span><span class="s1">traverseTestExpression(node) {</span>
            <span class="s2">if </span><span class="s1">(node.test == </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">traverseNode(node.test, </span><span class="s2">true</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* Inspects the argument of a unary logical expression (`!`).</span>
         <span class="s4">*/</span>
        <span class="s2">function </span><span class="s1">traverseUnaryLogicalExpression(node) {</span>
            <span class="s1">traverseNode(node.argument, </span><span class="s2">true</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* Inspects the arguments of a logical expression (`&amp;&amp;`, `||`).</span>
         <span class="s4">*</span>
         <span class="s4">* If the logical expression is a descendant of a test expression,</span>
         <span class="s4">* the `isCondition` flag should be set to true.</span>
         <span class="s4">* Otherwise, if the logical expression is there on it's own,</span>
         <span class="s4">* it's used for control flow and is not a condition itself.</span>
         <span class="s4">*/</span>
        <span class="s2">function </span><span class="s1">traverseLogicalExpression(node, isCondition = </span><span class="s2">false</span><span class="s1">) {</span>
            <span class="s4">// left argument is always treated as a condition</span>
            <span class="s1">traverseNode(node.left, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s4">// if the logical expression is used for control flow,</span>
            <span class="s4">// then its right argument is used for its side effects only</span>
            <span class="s1">traverseNode(node.right, isCondition);</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">traverseCallExpression(node) {</span>
            <span class="s2">const </span><span class="s1">assertedArgument = (</span><span class="s3">0</span><span class="s1">, assertionFunctionUtils_1.findTruthinessAssertedArgument)(services, node);</span>
            <span class="s2">if </span><span class="s1">(assertedArgument != </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s1">traverseNode(assertedArgument, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, util_1.isArrayMethodCallWithPredicate)(context, services, node)) {</span>
                <span class="s2">const </span><span class="s1">predicate = node.arguments.at(</span><span class="s3">0</span><span class="s1">);</span>
                <span class="s2">if </span><span class="s1">(predicate) {</span>
                    <span class="s1">checkArrayMethodCallPredicate(predicate);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* Dedicated function to check array method predicate calls. Reports predicate</span>
         <span class="s4">* arguments that don't return a boolean value.</span>
         <span class="s4">*/</span>
        <span class="s2">function </span><span class="s1">checkArrayMethodCallPredicate(predicateNode) {</span>
            <span class="s2">const </span><span class="s1">isFunctionExpression = utils_1.ASTUtils.isFunction(predicateNode);</span>
            <span class="s4">// custom message for accidental `async` function expressions</span>
            <span class="s2">if </span><span class="s1">(isFunctionExpression &amp;&amp; predicateNode.async) {</span>
                <span class="s2">return </span><span class="s1">context.report({</span>
                    <span class="s1">node: predicateNode,</span>
                    <span class="s1">messageId: </span><span class="s0">'predicateCannotBeAsync'</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">returnTypes = services</span>
                <span class="s1">.getTypeAtLocation(predicateNode)</span>
                <span class="s1">.getCallSignatures()</span>
                <span class="s1">.map(signature =&gt; {</span>
                <span class="s2">const </span><span class="s1">type = signature.getReturnType();</span>
                <span class="s2">if </span><span class="s1">(tsutils.isTypeParameter(type)) {</span>
                    <span class="s2">return </span><span class="s1">checker.getBaseConstraintOfType(type) ?? type;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">type;</span>
            <span class="s1">});</span>
            <span class="s2">const </span><span class="s1">flattenTypes = [</span>
                <span class="s1">...</span><span class="s2">new </span><span class="s1">Set(returnTypes.flatMap(type =&gt; tsutils.unionConstituents(type))),</span>
            <span class="s1">];</span>
            <span class="s2">const </span><span class="s1">types = inspectVariantTypes(flattenTypes);</span>
            <span class="s2">const </span><span class="s1">reportType = determineReportType(types);</span>
            <span class="s2">if </span><span class="s1">(reportType == </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">suggestions = [];</span>
            <span class="s2">if </span><span class="s1">(isFunctionExpression &amp;&amp;</span>
                <span class="s1">predicateNode.body.type !== utils_1.AST_NODE_TYPES.BlockStatement) {</span>
                <span class="s1">suggestions.push(...getSuggestionsForConditionError(predicateNode.body, reportType));</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(isFunctionExpression &amp;&amp; !predicateNode.returnType) {</span>
                <span class="s1">suggestions.push({</span>
                    <span class="s1">messageId: </span><span class="s0">'explicitBooleanReturnType'</span><span class="s1">,</span>
                    <span class="s1">fix: fixer =&gt; {</span>
                        <span class="s2">if </span><span class="s1">(predicateNode.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression &amp;&amp;</span>
                            <span class="s1">(</span><span class="s3">0</span><span class="s1">, util_1.isParenlessArrowFunction)(predicateNode, context.sourceCode)) {</span>
                            <span class="s2">return </span><span class="s1">[</span>
                                <span class="s1">fixer.insertTextBefore(predicateNode.params[</span><span class="s3">0</span><span class="s1">], </span><span class="s0">'('</span><span class="s1">),</span>
                                <span class="s1">fixer.insertTextAfter(predicateNode.params[</span><span class="s3">0</span><span class="s1">], </span><span class="s0">'): boolean'</span><span class="s1">),</span>
                            <span class="s1">];</span>
                        <span class="s1">}</span>
                        <span class="s2">if </span><span class="s1">(predicateNode.params.length === </span><span class="s3">0</span><span class="s1">) {</span>
                            <span class="s2">const </span><span class="s1">closingBracket = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(context.sourceCode.getFirstToken(predicateNode, token =&gt; token.value === </span><span class="s0">')'</span><span class="s1">), </span><span class="s0">'function expression has to have a closing parenthesis.'</span><span class="s1">);</span>
                            <span class="s2">return </span><span class="s1">fixer.insertTextAfter(closingBracket, </span><span class="s0">': boolean'</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s2">const </span><span class="s1">lastClosingParenthesis = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(context.sourceCode.getTokenAfter(predicateNode.params[predicateNode.params.length - </span><span class="s3">1</span><span class="s1">], token =&gt; token.value === </span><span class="s0">')'</span><span class="s1">), </span><span class="s0">'function expression has to have a closing parenthesis.'</span><span class="s1">);</span>
                        <span class="s2">return </span><span class="s1">fixer.insertTextAfter(lastClosingParenthesis, </span><span class="s0">': boolean'</span><span class="s1">);</span>
                    <span class="s1">},</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">context.report({</span>
                <span class="s1">node: predicateNode,</span>
                <span class="s1">messageId: reportType,</span>
                <span class="s1">data: {</span>
                    <span class="s1">context: </span><span class="s0">'array predicate return type'</span><span class="s1">,</span>
                <span class="s1">},</span>
                <span class="s1">suggest: suggestions,</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* Inspects any node.</span>
         <span class="s4">*</span>
         <span class="s4">* If it's a logical expression then it recursively traverses its arguments.</span>
         <span class="s4">* If it's any other kind of node then it's type is finally checked against the rule,</span>
         <span class="s4">* unless `isCondition` flag is set to false, in which case</span>
         <span class="s4">* it's assumed to be used for side effects only and is skipped.</span>
         <span class="s4">*/</span>
        <span class="s2">function </span><span class="s1">traverseNode(node, isCondition) {</span>
            <span class="s4">// prevent checking the same node multiple times</span>
            <span class="s2">if </span><span class="s1">(traversedNodes.has(node)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">traversedNodes.add(node);</span>
            <span class="s4">// for logical operator, we check its operands</span>
            <span class="s2">if </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.LogicalExpression &amp;&amp;</span>
                <span class="s1">node.operator !== </span><span class="s0">'??'</span><span class="s1">) {</span>
                <span class="s1">traverseLogicalExpression(node, isCondition);</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// skip if node is not a condition</span>
            <span class="s2">if </span><span class="s1">(!isCondition) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">checkNode(node);</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">determineReportType(types) {</span>
            <span class="s2">const </span><span class="s1">is = (...wantedTypes) =&gt; types.size === wantedTypes.length &amp;&amp;</span>
                <span class="s1">wantedTypes.every(type =&gt; types.has(type));</span>
            <span class="s4">// boolean</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'boolean'</span><span class="s1">) || is(</span><span class="s0">'truthy boolean'</span><span class="s1">)) {</span>
                <span class="s4">// boolean is always ok</span>
                <span class="s2">return </span><span class="s1">undefined;</span>
            <span class="s1">}</span>
            <span class="s4">// never</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'never'</span><span class="s1">)) {</span>
                <span class="s4">// never is always okay</span>
                <span class="s2">return </span><span class="s1">undefined;</span>
            <span class="s1">}</span>
            <span class="s4">// nullish</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'nullish'</span><span class="s1">)) {</span>
                <span class="s4">// condition is always false</span>
                <span class="s2">return </span><span class="s0">'conditionErrorNullish'</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// Known edge case: boolean `true` and nullish values are always valid boolean expressions</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'truthy boolean'</span><span class="s1">)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// nullable boolean</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'boolean'</span><span class="s1">)) {</span>
                <span class="s2">return </span><span class="s1">!options.allowNullableBoolean</span>
                    <span class="s1">? </span><span class="s0">'conditionErrorNullableBoolean'</span>
                    <span class="s1">: undefined;</span>
            <span class="s1">}</span>
            <span class="s4">// Known edge case: truthy primitives and nullish values are always valid boolean expressions</span>
            <span class="s2">if </span><span class="s1">((options.allowNumber &amp;&amp; is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'truthy number'</span><span class="s1">)) ||</span>
                <span class="s1">(options.allowString &amp;&amp; is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'truthy string'</span><span class="s1">))) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// string</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'string'</span><span class="s1">) || is(</span><span class="s0">'truthy string'</span><span class="s1">)) {</span>
                <span class="s2">return </span><span class="s1">!options.allowString ? </span><span class="s0">'conditionErrorString' </span><span class="s1">: undefined;</span>
            <span class="s1">}</span>
            <span class="s4">// nullable string</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'string'</span><span class="s1">)) {</span>
                <span class="s2">return </span><span class="s1">!options.allowNullableString</span>
                    <span class="s1">? </span><span class="s0">'conditionErrorNullableString'</span>
                    <span class="s1">: undefined;</span>
            <span class="s1">}</span>
            <span class="s4">// number</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'number'</span><span class="s1">) || is(</span><span class="s0">'truthy number'</span><span class="s1">)) {</span>
                <span class="s2">return </span><span class="s1">!options.allowNumber ? </span><span class="s0">'conditionErrorNumber' </span><span class="s1">: undefined;</span>
            <span class="s1">}</span>
            <span class="s4">// nullable number</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'number'</span><span class="s1">)) {</span>
                <span class="s2">return </span><span class="s1">!options.allowNullableNumber</span>
                    <span class="s1">? </span><span class="s0">'conditionErrorNullableNumber'</span>
                    <span class="s1">: undefined;</span>
            <span class="s1">}</span>
            <span class="s4">// object</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'object'</span><span class="s1">)) {</span>
                <span class="s2">return </span><span class="s0">'conditionErrorObject'</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// nullable object</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'object'</span><span class="s1">)) {</span>
                <span class="s2">return </span><span class="s1">!options.allowNullableObject</span>
                    <span class="s1">? </span><span class="s0">'conditionErrorNullableObject'</span>
                    <span class="s1">: undefined;</span>
            <span class="s1">}</span>
            <span class="s4">// nullable enum</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'number'</span><span class="s1">, </span><span class="s0">'enum'</span><span class="s1">) ||</span>
                <span class="s1">is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'string'</span><span class="s1">, </span><span class="s0">'enum'</span><span class="s1">) ||</span>
                <span class="s1">is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'truthy number'</span><span class="s1">, </span><span class="s0">'enum'</span><span class="s1">) ||</span>
                <span class="s1">is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'truthy string'</span><span class="s1">, </span><span class="s0">'enum'</span><span class="s1">) ||</span>
                <span class="s4">// mixed enums</span>
                <span class="s1">is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'truthy number'</span><span class="s1">, </span><span class="s0">'truthy string'</span><span class="s1">, </span><span class="s0">'enum'</span><span class="s1">) ||</span>
                <span class="s1">is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'truthy number'</span><span class="s1">, </span><span class="s0">'string'</span><span class="s1">, </span><span class="s0">'enum'</span><span class="s1">) ||</span>
                <span class="s1">is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'truthy string'</span><span class="s1">, </span><span class="s0">'number'</span><span class="s1">, </span><span class="s0">'enum'</span><span class="s1">) ||</span>
                <span class="s1">is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'number'</span><span class="s1">, </span><span class="s0">'string'</span><span class="s1">, </span><span class="s0">'enum'</span><span class="s1">)) {</span>
                <span class="s2">return </span><span class="s1">!options.allowNullableEnum</span>
                    <span class="s1">? </span><span class="s0">'conditionErrorNullableEnum'</span>
                    <span class="s1">: undefined;</span>
            <span class="s1">}</span>
            <span class="s4">// any</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'any'</span><span class="s1">)) {</span>
                <span class="s2">return </span><span class="s1">!options.allowAny ? </span><span class="s0">'conditionErrorAny' </span><span class="s1">: undefined;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s0">'conditionErrorOther'</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">getSuggestionsForConditionError(node, conditionError) {</span>
            <span class="s2">switch </span><span class="s1">(conditionError) {</span>
                <span class="s2">case </span><span class="s0">'conditionErrorAny'</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">[</span>
                        <span class="s1">{</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionFixCastBoolean'</span><span class="s1">,</span>
                            <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                <span class="s1">node,</span>
                                <span class="s1">sourceCode: context.sourceCode,</span>
                                <span class="s1">wrap: code =&gt; </span><span class="s0">`Boolean(</span><span class="s1">${code}</span><span class="s0">)`</span><span class="s1">,</span>
                            <span class="s1">}),</span>
                        <span class="s1">},</span>
                    <span class="s1">];</span>
                <span class="s2">case </span><span class="s0">'conditionErrorNullableBoolean'</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">(isLogicalNegationExpression(node.parent)) {</span>
                        <span class="s4">// if (!nullableBoolean)</span>
                        <span class="s2">return </span><span class="s1">[</span>
                            <span class="s1">{</span>
                                <span class="s1">messageId: </span><span class="s0">'conditionFixDefaultFalse'</span><span class="s1">,</span>
                                <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                    <span class="s1">node,</span>
                                    <span class="s1">sourceCode: context.sourceCode,</span>
                                    <span class="s1">wrap: code =&gt; </span><span class="s0">`</span><span class="s1">${code} </span><span class="s0">?? false`</span><span class="s1">,</span>
                                <span class="s1">}),</span>
                            <span class="s1">},</span>
                            <span class="s1">{</span>
                                <span class="s1">messageId: </span><span class="s0">'conditionFixCompareFalse'</span><span class="s1">,</span>
                                <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                    <span class="s1">node: node.parent,</span>
                                    <span class="s1">innerNode: node,</span>
                                    <span class="s1">sourceCode: context.sourceCode,</span>
                                    <span class="s1">wrap: code =&gt; </span><span class="s0">`</span><span class="s1">${code} </span><span class="s0">=== false`</span><span class="s1">,</span>
                                <span class="s1">}),</span>
                            <span class="s1">},</span>
                        <span class="s1">];</span>
                    <span class="s1">}</span>
                    <span class="s4">// if (nullableBoolean)</span>
                    <span class="s2">return </span><span class="s1">[</span>
                        <span class="s1">{</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionFixDefaultFalse'</span><span class="s1">,</span>
                            <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                <span class="s1">node,</span>
                                <span class="s1">sourceCode: context.sourceCode,</span>
                                <span class="s1">wrap: code =&gt; </span><span class="s0">`</span><span class="s1">${code} </span><span class="s0">?? false`</span><span class="s1">,</span>
                            <span class="s1">}),</span>
                        <span class="s1">},</span>
                        <span class="s1">{</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionFixCompareTrue'</span><span class="s1">,</span>
                            <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                <span class="s1">node,</span>
                                <span class="s1">sourceCode: context.sourceCode,</span>
                                <span class="s1">wrap: code =&gt; </span><span class="s0">`</span><span class="s1">${code} </span><span class="s0">=== true`</span><span class="s1">,</span>
                            <span class="s1">}),</span>
                        <span class="s1">},</span>
                    <span class="s1">];</span>
                <span class="s2">case </span><span class="s0">'conditionErrorNullableEnum'</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">(isLogicalNegationExpression(node.parent)) {</span>
                        <span class="s2">return </span><span class="s1">[</span>
                            <span class="s1">{</span>
                                <span class="s1">messageId: </span><span class="s0">'conditionFixCompareNullish'</span><span class="s1">,</span>
                                <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                    <span class="s1">node: node.parent,</span>
                                    <span class="s1">innerNode: node,</span>
                                    <span class="s1">sourceCode: context.sourceCode,</span>
                                    <span class="s1">wrap: code =&gt; </span><span class="s0">`</span><span class="s1">${code} </span><span class="s0">== null`</span><span class="s1">,</span>
                                <span class="s1">}),</span>
                            <span class="s1">},</span>
                        <span class="s1">];</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">[</span>
                        <span class="s1">{</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionFixCompareNullish'</span><span class="s1">,</span>
                            <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                <span class="s1">node,</span>
                                <span class="s1">sourceCode: context.sourceCode,</span>
                                <span class="s1">wrap: code =&gt; </span><span class="s0">`</span><span class="s1">${code} </span><span class="s0">!= null`</span><span class="s1">,</span>
                            <span class="s1">}),</span>
                        <span class="s1">},</span>
                    <span class="s1">];</span>
                <span class="s2">case </span><span class="s0">'conditionErrorNullableNumber'</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">(isLogicalNegationExpression(node.parent)) {</span>
                        <span class="s4">// if (!nullableNumber)</span>
                        <span class="s2">return </span><span class="s1">[</span>
                            <span class="s1">{</span>
                                <span class="s1">messageId: </span><span class="s0">'conditionFixCompareNullish'</span><span class="s1">,</span>
                                <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                    <span class="s1">node: node.parent,</span>
                                    <span class="s1">innerNode: node,</span>
                                    <span class="s1">sourceCode: context.sourceCode,</span>
                                    <span class="s1">wrap: code =&gt; </span><span class="s0">`</span><span class="s1">${code} </span><span class="s0">== null`</span><span class="s1">,</span>
                                <span class="s1">}),</span>
                            <span class="s1">},</span>
                            <span class="s1">{</span>
                                <span class="s1">messageId: </span><span class="s0">'conditionFixDefaultZero'</span><span class="s1">,</span>
                                <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                    <span class="s1">node,</span>
                                    <span class="s1">sourceCode: context.sourceCode,</span>
                                    <span class="s1">wrap: code =&gt; </span><span class="s0">`</span><span class="s1">${code} </span><span class="s0">?? 0`</span><span class="s1">,</span>
                                <span class="s1">}),</span>
                            <span class="s1">},</span>
                            <span class="s1">{</span>
                                <span class="s1">messageId: </span><span class="s0">'conditionFixCastBoolean'</span><span class="s1">,</span>
                                <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                    <span class="s1">node: node.parent,</span>
                                    <span class="s1">innerNode: node,</span>
                                    <span class="s1">sourceCode: context.sourceCode,</span>
                                    <span class="s1">wrap: code =&gt; </span><span class="s0">`!Boolean(</span><span class="s1">${code}</span><span class="s0">)`</span><span class="s1">,</span>
                                <span class="s1">}),</span>
                            <span class="s1">},</span>
                        <span class="s1">];</span>
                    <span class="s1">}</span>
                    <span class="s4">// if (nullableNumber)</span>
                    <span class="s2">return </span><span class="s1">[</span>
                        <span class="s1">{</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionFixCompareNullish'</span><span class="s1">,</span>
                            <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                <span class="s1">node,</span>
                                <span class="s1">sourceCode: context.sourceCode,</span>
                                <span class="s1">wrap: code =&gt; </span><span class="s0">`</span><span class="s1">${code} </span><span class="s0">!= null`</span><span class="s1">,</span>
                            <span class="s1">}),</span>
                        <span class="s1">},</span>
                        <span class="s1">{</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionFixDefaultZero'</span><span class="s1">,</span>
                            <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                <span class="s1">node,</span>
                                <span class="s1">sourceCode: context.sourceCode,</span>
                                <span class="s1">wrap: code =&gt; </span><span class="s0">`</span><span class="s1">${code} </span><span class="s0">?? 0`</span><span class="s1">,</span>
                            <span class="s1">}),</span>
                        <span class="s1">},</span>
                        <span class="s1">{</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionFixCastBoolean'</span><span class="s1">,</span>
                            <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                <span class="s1">node,</span>
                                <span class="s1">sourceCode: context.sourceCode,</span>
                                <span class="s1">wrap: code =&gt; </span><span class="s0">`Boolean(</span><span class="s1">${code}</span><span class="s0">)`</span><span class="s1">,</span>
                            <span class="s1">}),</span>
                        <span class="s1">},</span>
                    <span class="s1">];</span>
                <span class="s2">case </span><span class="s0">'conditionErrorNullableObject'</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">(isLogicalNegationExpression(node.parent)) {</span>
                        <span class="s4">// if (!nullableObject)</span>
                        <span class="s2">return </span><span class="s1">[</span>
                            <span class="s1">{</span>
                                <span class="s1">messageId: </span><span class="s0">'conditionFixCompareNullish'</span><span class="s1">,</span>
                                <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                    <span class="s1">node: node.parent,</span>
                                    <span class="s1">innerNode: node,</span>
                                    <span class="s1">sourceCode: context.sourceCode,</span>
                                    <span class="s1">wrap: code =&gt; </span><span class="s0">`</span><span class="s1">${code} </span><span class="s0">== null`</span><span class="s1">,</span>
                                <span class="s1">}),</span>
                            <span class="s1">},</span>
                        <span class="s1">];</span>
                    <span class="s1">}</span>
                    <span class="s4">// if (nullableObject)</span>
                    <span class="s2">return </span><span class="s1">[</span>
                        <span class="s1">{</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionFixCompareNullish'</span><span class="s1">,</span>
                            <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                <span class="s1">node,</span>
                                <span class="s1">sourceCode: context.sourceCode,</span>
                                <span class="s1">wrap: code =&gt; </span><span class="s0">`</span><span class="s1">${code} </span><span class="s0">!= null`</span><span class="s1">,</span>
                            <span class="s1">}),</span>
                        <span class="s1">},</span>
                    <span class="s1">];</span>
                <span class="s2">case </span><span class="s0">'conditionErrorNullableString'</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">(isLogicalNegationExpression(node.parent)) {</span>
                        <span class="s4">// if (!nullableString)</span>
                        <span class="s2">return </span><span class="s1">[</span>
                            <span class="s1">{</span>
                                <span class="s1">messageId: </span><span class="s0">'conditionFixCompareNullish'</span><span class="s1">,</span>
                                <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                    <span class="s1">node: node.parent,</span>
                                    <span class="s1">innerNode: node,</span>
                                    <span class="s1">sourceCode: context.sourceCode,</span>
                                    <span class="s1">wrap: code =&gt; </span><span class="s0">`</span><span class="s1">${code} </span><span class="s0">== null`</span><span class="s1">,</span>
                                <span class="s1">}),</span>
                            <span class="s1">},</span>
                            <span class="s1">{</span>
                                <span class="s1">messageId: </span><span class="s0">'conditionFixDefaultEmptyString'</span><span class="s1">,</span>
                                <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                    <span class="s1">node,</span>
                                    <span class="s1">sourceCode: context.sourceCode,</span>
                                    <span class="s1">wrap: code =&gt; </span><span class="s0">`</span><span class="s1">${code} </span><span class="s0">?? &quot;&quot;`</span><span class="s1">,</span>
                                <span class="s1">}),</span>
                            <span class="s1">},</span>
                            <span class="s1">{</span>
                                <span class="s1">messageId: </span><span class="s0">'conditionFixCastBoolean'</span><span class="s1">,</span>
                                <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                    <span class="s1">node: node.parent,</span>
                                    <span class="s1">innerNode: node,</span>
                                    <span class="s1">sourceCode: context.sourceCode,</span>
                                    <span class="s1">wrap: code =&gt; </span><span class="s0">`!Boolean(</span><span class="s1">${code}</span><span class="s0">)`</span><span class="s1">,</span>
                                <span class="s1">}),</span>
                            <span class="s1">},</span>
                        <span class="s1">];</span>
                    <span class="s1">}</span>
                    <span class="s4">// if (nullableString)</span>
                    <span class="s2">return </span><span class="s1">[</span>
                        <span class="s1">{</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionFixCompareNullish'</span><span class="s1">,</span>
                            <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                <span class="s1">node,</span>
                                <span class="s1">sourceCode: context.sourceCode,</span>
                                <span class="s1">wrap: code =&gt; </span><span class="s0">`</span><span class="s1">${code} </span><span class="s0">!= null`</span><span class="s1">,</span>
                            <span class="s1">}),</span>
                        <span class="s1">},</span>
                        <span class="s1">{</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionFixDefaultEmptyString'</span><span class="s1">,</span>
                            <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                <span class="s1">node,</span>
                                <span class="s1">sourceCode: context.sourceCode,</span>
                                <span class="s1">wrap: code =&gt; </span><span class="s0">`</span><span class="s1">${code} </span><span class="s0">?? &quot;&quot;`</span><span class="s1">,</span>
                            <span class="s1">}),</span>
                        <span class="s1">},</span>
                        <span class="s1">{</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionFixCastBoolean'</span><span class="s1">,</span>
                            <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                <span class="s1">node,</span>
                                <span class="s1">sourceCode: context.sourceCode,</span>
                                <span class="s1">wrap: code =&gt; </span><span class="s0">`Boolean(</span><span class="s1">${code}</span><span class="s0">)`</span><span class="s1">,</span>
                            <span class="s1">}),</span>
                        <span class="s1">},</span>
                    <span class="s1">];</span>
                <span class="s2">case </span><span class="s0">'conditionErrorNumber'</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">(isArrayLengthExpression(node, checker, services)) {</span>
                        <span class="s2">if </span><span class="s1">(isLogicalNegationExpression(node.parent)) {</span>
                            <span class="s4">// if (!array.length)</span>
                            <span class="s2">return </span><span class="s1">[</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixCompareArrayLengthZero'</span><span class="s1">,</span>
                                    <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                        <span class="s1">node: node.parent,</span>
                                        <span class="s1">innerNode: node,</span>
                                        <span class="s1">sourceCode: context.sourceCode,</span>
                                        <span class="s1">wrap: code =&gt; </span><span class="s0">`</span><span class="s1">${code} </span><span class="s0">=== 0`</span><span class="s1">,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                            <span class="s1">];</span>
                        <span class="s1">}</span>
                        <span class="s4">// if (array.length)</span>
                        <span class="s2">return </span><span class="s1">[</span>
                            <span class="s1">{</span>
                                <span class="s1">messageId: </span><span class="s0">'conditionFixCompareArrayLengthNonzero'</span><span class="s1">,</span>
                                <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                    <span class="s1">node,</span>
                                    <span class="s1">sourceCode: context.sourceCode,</span>
                                    <span class="s1">wrap: code =&gt; </span><span class="s0">`</span><span class="s1">${code} </span><span class="s0">&gt; 0`</span><span class="s1">,</span>
                                <span class="s1">}),</span>
                            <span class="s1">},</span>
                        <span class="s1">];</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(isLogicalNegationExpression(node.parent)) {</span>
                        <span class="s4">// if (!number)</span>
                        <span class="s2">return </span><span class="s1">[</span>
                            <span class="s1">{</span>
                                <span class="s1">messageId: </span><span class="s0">'conditionFixCompareZero'</span><span class="s1">,</span>
                                <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                    <span class="s1">node: node.parent,</span>
                                    <span class="s1">innerNode: node,</span>
                                    <span class="s1">sourceCode: context.sourceCode,</span>
                                    <span class="s4">// TODO: we have to compare to 0n if the type is bigint</span>
                                    <span class="s1">wrap: code =&gt; </span><span class="s0">`</span><span class="s1">${code} </span><span class="s0">=== 0`</span><span class="s1">,</span>
                                <span class="s1">}),</span>
                            <span class="s1">},</span>
                            <span class="s1">{</span>
                                <span class="s4">// TODO: don't suggest this for bigint because it can't be NaN</span>
                                <span class="s1">messageId: </span><span class="s0">'conditionFixCompareNaN'</span><span class="s1">,</span>
                                <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                    <span class="s1">node: node.parent,</span>
                                    <span class="s1">innerNode: node,</span>
                                    <span class="s1">sourceCode: context.sourceCode,</span>
                                    <span class="s1">wrap: code =&gt; </span><span class="s0">`Number.isNaN(</span><span class="s1">${code}</span><span class="s0">)`</span><span class="s1">,</span>
                                <span class="s1">}),</span>
                            <span class="s1">},</span>
                            <span class="s1">{</span>
                                <span class="s1">messageId: </span><span class="s0">'conditionFixCastBoolean'</span><span class="s1">,</span>
                                <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                    <span class="s1">node: node.parent,</span>
                                    <span class="s1">innerNode: node,</span>
                                    <span class="s1">sourceCode: context.sourceCode,</span>
                                    <span class="s1">wrap: code =&gt; </span><span class="s0">`!Boolean(</span><span class="s1">${code}</span><span class="s0">)`</span><span class="s1">,</span>
                                <span class="s1">}),</span>
                            <span class="s1">},</span>
                        <span class="s1">];</span>
                    <span class="s1">}</span>
                    <span class="s4">// if (number)</span>
                    <span class="s2">return </span><span class="s1">[</span>
                        <span class="s1">{</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionFixCompareZero'</span><span class="s1">,</span>
                            <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                <span class="s1">node,</span>
                                <span class="s1">sourceCode: context.sourceCode,</span>
                                <span class="s1">wrap: code =&gt; </span><span class="s0">`</span><span class="s1">${code} </span><span class="s0">!== 0`</span><span class="s1">,</span>
                            <span class="s1">}),</span>
                        <span class="s1">},</span>
                        <span class="s1">{</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionFixCompareNaN'</span><span class="s1">,</span>
                            <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                <span class="s1">node,</span>
                                <span class="s1">sourceCode: context.sourceCode,</span>
                                <span class="s1">wrap: code =&gt; </span><span class="s0">`!Number.isNaN(</span><span class="s1">${code}</span><span class="s0">)`</span><span class="s1">,</span>
                            <span class="s1">}),</span>
                        <span class="s1">},</span>
                        <span class="s1">{</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionFixCastBoolean'</span><span class="s1">,</span>
                            <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                <span class="s1">node,</span>
                                <span class="s1">sourceCode: context.sourceCode,</span>
                                <span class="s1">wrap: code =&gt; </span><span class="s0">`Boolean(</span><span class="s1">${code}</span><span class="s0">)`</span><span class="s1">,</span>
                            <span class="s1">}),</span>
                        <span class="s1">},</span>
                    <span class="s1">];</span>
                <span class="s2">case </span><span class="s0">'conditionErrorString'</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">(isLogicalNegationExpression(node.parent)) {</span>
                        <span class="s4">// if (!string)</span>
                        <span class="s2">return </span><span class="s1">[</span>
                            <span class="s1">{</span>
                                <span class="s1">messageId: </span><span class="s0">'conditionFixCompareStringLength'</span><span class="s1">,</span>
                                <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                    <span class="s1">node: node.parent,</span>
                                    <span class="s1">innerNode: node,</span>
                                    <span class="s1">sourceCode: context.sourceCode,</span>
                                    <span class="s1">wrap: code =&gt; </span><span class="s0">`</span><span class="s1">${code}</span><span class="s0">.length === 0`</span><span class="s1">,</span>
                                <span class="s1">}),</span>
                            <span class="s1">},</span>
                            <span class="s1">{</span>
                                <span class="s1">messageId: </span><span class="s0">'conditionFixCompareEmptyString'</span><span class="s1">,</span>
                                <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                    <span class="s1">node: node.parent,</span>
                                    <span class="s1">innerNode: node,</span>
                                    <span class="s1">sourceCode: context.sourceCode,</span>
                                    <span class="s1">wrap: code =&gt; </span><span class="s0">`</span><span class="s1">${code} </span><span class="s0">=== &quot;&quot;`</span><span class="s1">,</span>
                                <span class="s1">}),</span>
                            <span class="s1">},</span>
                            <span class="s1">{</span>
                                <span class="s1">messageId: </span><span class="s0">'conditionFixCastBoolean'</span><span class="s1">,</span>
                                <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                    <span class="s1">node: node.parent,</span>
                                    <span class="s1">innerNode: node,</span>
                                    <span class="s1">sourceCode: context.sourceCode,</span>
                                    <span class="s1">wrap: code =&gt; </span><span class="s0">`!Boolean(</span><span class="s1">${code}</span><span class="s0">)`</span><span class="s1">,</span>
                                <span class="s1">}),</span>
                            <span class="s1">},</span>
                        <span class="s1">];</span>
                    <span class="s1">}</span>
                    <span class="s4">// if (string)</span>
                    <span class="s2">return </span><span class="s1">[</span>
                        <span class="s1">{</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionFixCompareStringLength'</span><span class="s1">,</span>
                            <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                <span class="s1">node,</span>
                                <span class="s1">sourceCode: context.sourceCode,</span>
                                <span class="s1">wrap: code =&gt; </span><span class="s0">`</span><span class="s1">${code}</span><span class="s0">.length &gt; 0`</span><span class="s1">,</span>
                            <span class="s1">}),</span>
                        <span class="s1">},</span>
                        <span class="s1">{</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionFixCompareEmptyString'</span><span class="s1">,</span>
                            <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                <span class="s1">node,</span>
                                <span class="s1">sourceCode: context.sourceCode,</span>
                                <span class="s1">wrap: code =&gt; </span><span class="s0">`</span><span class="s1">${code} </span><span class="s0">!== &quot;&quot;`</span><span class="s1">,</span>
                            <span class="s1">}),</span>
                        <span class="s1">},</span>
                        <span class="s1">{</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionFixCastBoolean'</span><span class="s1">,</span>
                            <span class="s1">fix: (</span><span class="s3">0</span><span class="s1">, util_1.getWrappingFixer)({</span>
                                <span class="s1">node,</span>
                                <span class="s1">sourceCode: context.sourceCode,</span>
                                <span class="s1">wrap: code =&gt; </span><span class="s0">`Boolean(</span><span class="s1">${code}</span><span class="s0">)`</span><span class="s1">,</span>
                            <span class="s1">}),</span>
                        <span class="s1">},</span>
                    <span class="s1">];</span>
                <span class="s2">case </span><span class="s0">'conditionErrorObject'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'conditionErrorNullish'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'conditionErrorOther'</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">[];</span>
                <span class="s2">default</span><span class="s1">:</span>
                    <span class="s1">conditionError;</span>
                    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'Unreachable'</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* This function does the actual type check on a node.</span>
         <span class="s4">* It analyzes the type of a node and checks if it is allowed in a boolean context.</span>
         <span class="s4">*/</span>
        <span class="s2">function </span><span class="s1">checkNode(node) {</span>
            <span class="s2">const </span><span class="s1">type = (</span><span class="s3">0</span><span class="s1">, util_1.getConstrainedTypeAtLocation)(services, node);</span>
            <span class="s2">const </span><span class="s1">types = inspectVariantTypes(tsutils.unionConstituents(type));</span>
            <span class="s2">const </span><span class="s1">reportType = determineReportType(types);</span>
            <span class="s2">if </span><span class="s1">(reportType != </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node,</span>
                    <span class="s1">messageId: reportType,</span>
                    <span class="s1">data: {</span>
                        <span class="s1">context: </span><span class="s0">'conditional'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">suggest: getSuggestionsForConditionError(node, reportType),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* Check union variants for the types we care about</span>
         <span class="s4">*/</span>
        <span class="s2">function </span><span class="s1">inspectVariantTypes(types) {</span>
            <span class="s2">const </span><span class="s1">variantTypes = </span><span class="s2">new </span><span class="s1">Set();</span>
            <span class="s2">if </span><span class="s1">(types.some(type =&gt; tsutils.isTypeFlagSet(type, ts.TypeFlags.Null | ts.TypeFlags.Undefined | ts.TypeFlags.VoidLike))) {</span>
                <span class="s1">variantTypes.add(</span><span class="s0">'nullish'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">booleans = types.filter(type =&gt; tsutils.isTypeFlagSet(type, ts.TypeFlags.BooleanLike));</span>
            <span class="s4">// If incoming type is either &quot;true&quot; or &quot;false&quot;, there will be one type</span>
            <span class="s4">// object with intrinsicName set accordingly</span>
            <span class="s4">// If incoming type is boolean, there will be two type objects with</span>
            <span class="s4">// intrinsicName set &quot;true&quot; and &quot;false&quot; each because of ts-api-utils.unionConstituents()</span>
            <span class="s2">if </span><span class="s1">(booleans.length === </span><span class="s3">1</span><span class="s1">) {</span>
                <span class="s1">variantTypes.add(tsutils.isTrueLiteralType(booleans[</span><span class="s3">0</span><span class="s1">]) ? </span><span class="s0">'truthy boolean' </span><span class="s1">: </span><span class="s0">'boolean'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(booleans.length === </span><span class="s3">2</span><span class="s1">) {</span>
                <span class="s1">variantTypes.add(</span><span class="s0">'boolean'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">strings = types.filter(type =&gt; tsutils.isTypeFlagSet(type, ts.TypeFlags.StringLike));</span>
            <span class="s2">if </span><span class="s1">(strings.length) {</span>
                <span class="s2">if </span><span class="s1">(strings.every(type =&gt; type.isStringLiteral() &amp;&amp; type.value !== </span><span class="s0">''</span><span class="s1">)) {</span>
                    <span class="s1">variantTypes.add(</span><span class="s0">'truthy string'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">variantTypes.add(</span><span class="s0">'string'</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">numbers = types.filter(type =&gt; tsutils.isTypeFlagSet(type, ts.TypeFlags.NumberLike | ts.TypeFlags.BigIntLike));</span>
            <span class="s2">if </span><span class="s1">(numbers.length) {</span>
                <span class="s2">if </span><span class="s1">(numbers.every(type =&gt; type.isNumberLiteral() &amp;&amp; type.value !== </span><span class="s3">0</span><span class="s1">)) {</span>
                    <span class="s1">variantTypes.add(</span><span class="s0">'truthy number'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">variantTypes.add(</span><span class="s0">'number'</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(types.some(type =&gt; tsutils.isTypeFlagSet(type, ts.TypeFlags.EnumLike))) {</span>
                <span class="s1">variantTypes.add(</span><span class="s0">'enum'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(types.some(type =&gt; !tsutils.isTypeFlagSet(type, ts.TypeFlags.Null |</span>
                <span class="s1">ts.TypeFlags.Undefined |</span>
                <span class="s1">ts.TypeFlags.VoidLike |</span>
                <span class="s1">ts.TypeFlags.BooleanLike |</span>
                <span class="s1">ts.TypeFlags.StringLike |</span>
                <span class="s1">ts.TypeFlags.NumberLike |</span>
                <span class="s1">ts.TypeFlags.BigIntLike |</span>
                <span class="s1">ts.TypeFlags.TypeParameter |</span>
                <span class="s1">ts.TypeFlags.Any |</span>
                <span class="s1">ts.TypeFlags.Unknown |</span>
                <span class="s1">ts.TypeFlags.Never))) {</span>
                <span class="s1">variantTypes.add(types.some(isBrandedBoolean) ? </span><span class="s0">'boolean' </span><span class="s1">: </span><span class="s0">'object'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(types.some(type =&gt; tsutils.isTypeFlagSet(type, ts.TypeFlags.TypeParameter |</span>
                <span class="s1">ts.TypeFlags.Any |</span>
                <span class="s1">ts.TypeFlags.Unknown))) {</span>
                <span class="s1">variantTypes.add(</span><span class="s0">'any'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(types.some(type =&gt; tsutils.isTypeFlagSet(type, ts.TypeFlags.Never))) {</span>
                <span class="s1">variantTypes.add(</span><span class="s0">'never'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">variantTypes;</span>
        <span class="s1">}</span>
    <span class="s1">},</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">isLogicalNegationExpression(node) {</span>
    <span class="s2">return </span><span class="s1">node.type === utils_1.AST_NODE_TYPES.UnaryExpression &amp;&amp; node.operator === </span><span class="s0">'!'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isArrayLengthExpression(node, typeChecker, services) {</span>
    <span class="s2">if </span><span class="s1">(node.type !== utils_1.AST_NODE_TYPES.MemberExpression) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(node.computed) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(node.property.name !== </span><span class="s0">'length'</span><span class="s1">) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">objectType = (</span><span class="s3">0</span><span class="s1">, util_1.getConstrainedTypeAtLocation)(services, node.object);</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, util_1.isTypeArrayTypeOrUnionOfArrayTypes)(objectType, typeChecker);</span>
<span class="s1">}</span>
<span class="s4">/**</span>
 <span class="s4">* Verify is the type is a branded boolean (e.g. `type Foo = boolean &amp; { __brand: 'Foo' }`)</span>
 <span class="s4">*</span>
 <span class="s4">* </span><span class="s5">@param </span><span class="s4">type The type checked</span>
 <span class="s4">*/</span>
<span class="s2">function </span><span class="s1">isBrandedBoolean(type) {</span>
    <span class="s2">return </span><span class="s1">(type.isIntersection() &amp;&amp;</span>
        <span class="s1">type.types.some(childType =&gt; isBooleanType(childType)));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isBooleanType(expressionType) {</span>
    <span class="s2">return </span><span class="s1">tsutils.isTypeFlagSet(expressionType, ts.TypeFlags.Boolean | ts.TypeFlags.BooleanLiteral);</span>
<span class="s1">}</span>
</pre>
</body>
</html>