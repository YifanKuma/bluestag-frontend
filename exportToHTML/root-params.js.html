<html>
<head>
<title>root-params.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #0037a6;}
.s5 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
root-params.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">getRootParam: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">unstable_rootParams: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">getRootParam: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getRootParam;</span>
    <span class="s1">},</span>
    <span class="s1">unstable_rootParams: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">unstable_rootParams;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_invarianterror = require(</span><span class="s0">&quot;../../shared/lib/invariant-error&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_dynamicrendering = require(</span><span class="s0">&quot;../app-render/dynamic-rendering&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_workasyncstorageexternal = require(</span><span class="s0">&quot;../app-render/work-async-storage.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_workunitasyncstorageexternal = require(</span><span class="s0">&quot;../app-render/work-unit-async-storage.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_dynamicrenderingutils = require(</span><span class="s0">&quot;../dynamic-rendering-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_reflectutils = require(</span><span class="s0">&quot;../../shared/lib/utils/reflect-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_actionasyncstorageexternal = require(</span><span class="s0">&quot;../app-render/action-async-storage.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_log = require(</span><span class="s0">&quot;../../build/output/log&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">CachedParams = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">unstable_rootParams() {</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _log.warnOnce)(</span><span class="s0">'`unstable_rootParams()` is deprecated and will be removed in an upcoming major release. Import specific root params from `next/root-params` instead.'</span><span class="s1">);</span>
    <span class="s2">const </span><span class="s1">workStore = _workasyncstorageexternal.workAsyncStorage.getStore();</span>
    <span class="s2">if </span><span class="s1">(!workStore) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">'Missing workStore in unstable_rootParams'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E615&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
    <span class="s2">if </span><span class="s1">(!workUnitStore) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Route </span><span class="s1">${workStore.route} </span><span class="s0">used </span><span class="s4">\`</span><span class="s0">unstable_rootParams()</span><span class="s4">\` </span><span class="s0">in Pages Router. This API is only available within App Router.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E641&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
        <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Route </span><span class="s1">${workStore.route} </span><span class="s0">used </span><span class="s4">\`</span><span class="s0">unstable_rootParams()</span><span class="s4">\` </span><span class="s0">inside </span><span class="s4">\`</span><span class="s0">&quot;use cache&quot;</span><span class="s4">\` </span><span class="s0">or </span><span class="s4">\`</span><span class="s0">unstable_cache</span><span class="s4">\`</span><span class="s0">. Support for this API inside cache scopes is planned for a future version of Next.js.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E642&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">createPrerenderRootParams(workUnitStore.rootParams, workStore, workUnitStore);</span>
        <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">Promise.resolve(workUnitStore.rootParams);</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">workUnitStore;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createPrerenderRootParams(underlyingParams, workStore, prerenderStore) {</span>
    <span class="s2">switch</span><span class="s1">(prerenderStore.type){</span>
        <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s2">const </span><span class="s1">exportName = </span><span class="s0">'`unstable_rootParams`'</span><span class="s1">;</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">`</span><span class="s1">${exportName} </span><span class="s0">must not be used within a client component. Next.js should be preventing </span><span class="s1">${exportName} </span><span class="s0">from being included in client components statically, but did not in this case.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E693&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s2">const </span><span class="s1">fallbackParams = prerenderStore.fallbackRouteParams;</span>
                <span class="s2">if </span><span class="s1">(fallbackParams) {</span>
                    <span class="s2">for</span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">underlyingParams){</span>
                        <span class="s2">if </span><span class="s1">(fallbackParams.has(key)) {</span>
                            <span class="s2">const </span><span class="s1">cachedParams = CachedParams.get(underlyingParams);</span>
                            <span class="s2">if </span><span class="s1">(cachedParams) {</span>
                                <span class="s2">return </span><span class="s1">cachedParams;</span>
                            <span class="s1">}</span>
                            <span class="s2">const </span><span class="s1">promise = (</span><span class="s3">0</span><span class="s1">, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, workStore.route, </span><span class="s0">'`unstable_rootParams`'</span><span class="s1">);</span>
                            <span class="s1">CachedParams.set(underlyingParams, promise);</span>
                            <span class="s2">return </span><span class="s1">promise;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s2">const </span><span class="s1">fallbackParams = prerenderStore.fallbackRouteParams;</span>
                <span class="s2">if </span><span class="s1">(fallbackParams) {</span>
                    <span class="s2">for</span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">underlyingParams){</span>
                        <span class="s2">if </span><span class="s1">(fallbackParams.has(key)) {</span>
                            <span class="s5">// We have fallback params at this level so we need to make an erroring</span>
                            <span class="s5">// params object which will postpone if you access the fallback params</span>
                            <span class="s2">return </span><span class="s1">makeErroringRootParams(underlyingParams, fallbackParams, workStore, prerenderStore);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
            <span class="s2">break</span><span class="s1">;</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s1">prerenderStore;</span>
    <span class="s1">}</span>
    <span class="s5">// We don't have any fallback params so we have an entirely static safe params object</span>
    <span class="s2">return </span><span class="s1">Promise.resolve(underlyingParams);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">makeErroringRootParams(underlyingParams, fallbackParams, workStore, prerenderStore) {</span>
    <span class="s2">const </span><span class="s1">cachedParams = CachedParams.get(underlyingParams);</span>
    <span class="s2">if </span><span class="s1">(cachedParams) {</span>
        <span class="s2">return </span><span class="s1">cachedParams;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">augmentedUnderlying = {</span>
        <span class="s1">...underlyingParams</span>
    <span class="s1">};</span>
    <span class="s5">// We don't use makeResolvedReactPromise here because params</span>
    <span class="s5">// supports copying with spread and we don't want to unnecessarily</span>
    <span class="s5">// instrument the promise with spreadable properties of ReactPromise.</span>
    <span class="s2">const </span><span class="s1">promise = Promise.resolve(augmentedUnderlying);</span>
    <span class="s1">CachedParams.set(underlyingParams, promise);</span>
    <span class="s1">Object.keys(underlyingParams).forEach((prop)=&gt;{</span>
        <span class="s2">if </span><span class="s1">(_reflectutils.wellKnownProperties.has(prop)) {</span>
        <span class="s5">// These properties cannot be shadowed because they need to be the</span>
        <span class="s5">// true underlying value for Promises to work correctly at runtime</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(fallbackParams.has(prop)) {</span>
                <span class="s1">Object.defineProperty(augmentedUnderlying, prop, {</span>
                    <span class="s1">get () {</span>
                        <span class="s2">const </span><span class="s1">expression = (</span><span class="s3">0</span><span class="s1">, _reflectutils.describeStringPropertyAccess)(</span><span class="s0">'unstable_rootParams'</span><span class="s1">, prop);</span>
                        <span class="s5">// In most dynamic APIs we also throw if `dynamic = &quot;error&quot;` however</span>
                        <span class="s5">// for params is only dynamic when we're generating a fallback shell</span>
                        <span class="s5">// and even when `dynamic = &quot;error&quot;` we still support generating dynamic</span>
                        <span class="s5">// fallback shells</span>
                        <span class="s5">// TODO remove this comment when cacheComponents is the default since there</span>
                        <span class="s5">// will be no `dynamic = &quot;error&quot;`</span>
                        <span class="s2">if </span><span class="s1">(prerenderStore.type === </span><span class="s0">'prerender-ppr'</span><span class="s1">) {</span>
                            <span class="s5">// PPR Prerender (no cacheComponents)</span>
                            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);</span>
                        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                            <span class="s5">// Legacy Prerender</span>
                            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);</span>
                        <span class="s1">}</span>
                    <span class="s1">},</span>
                    <span class="s1">enumerable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">;</span>
                <span class="s1">promise[prop] = underlyingParams[prop];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">promise;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getRootParam(paramName) {</span>
    <span class="s2">const </span><span class="s1">apiName = </span><span class="s0">`</span><span class="s4">\`</span><span class="s0">import('next/root-params').</span><span class="s1">${paramName}</span><span class="s0">()</span><span class="s4">\`</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">workStore = _workasyncstorageexternal.workAsyncStorage.getStore();</span>
    <span class="s2">if </span><span class="s1">(!workStore) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">`Missing workStore in </span><span class="s1">${apiName}</span><span class="s0">`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E764&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
    <span class="s2">if </span><span class="s1">(!workUnitStore) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Route </span><span class="s1">${workStore.route} </span><span class="s0">used </span><span class="s1">${apiName} </span><span class="s0">outside of a Server Component. This is not allowed.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E774&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">actionStore = _actionasyncstorageexternal.actionAsyncStorage.getStore();</span>
    <span class="s2">if </span><span class="s1">(actionStore) {</span>
        <span class="s2">if </span><span class="s1">(actionStore.isAppRoute) {</span>
            <span class="s5">// TODO(root-params): add support for route handlers</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Route </span><span class="s1">${workStore.route} </span><span class="s0">used </span><span class="s1">${apiName} </span><span class="s0">inside a Route Handler. Support for this API in Route Handlers is planned for a future version of Next.js.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E765&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(actionStore.isAction &amp;&amp; workUnitStore.phase === </span><span class="s0">'action'</span><span class="s1">) {</span>
            <span class="s5">// Actions are not fundamentally tied to a route (even if they're always submitted from some page),</span>
            <span class="s5">// so root params would be inconsistent if an action is called from multiple roots.</span>
            <span class="s5">// Make sure we check if the phase is &quot;action&quot; - we should not error in the rerender</span>
            <span class="s5">// after an action revalidates or updates cookies (which will still have `actionStore.isAction === true`)</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`</span><span class="s1">${apiName} </span><span class="s0">was used inside a Server Action. This is not supported. Functions from 'next/root-params' can only be called in the context of a route.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E766&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
        <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Route </span><span class="s1">${workStore.route} </span><span class="s0">used </span><span class="s1">${apiName} </span><span class="s0">inside </span><span class="s4">\`</span><span class="s0">&quot;use cache&quot;</span><span class="s4">\` </span><span class="s0">or </span><span class="s4">\`</span><span class="s0">unstable_cache</span><span class="s4">\`</span><span class="s0">. Support for this API inside cache scopes is planned for a future version of Next.js.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E760&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s2">return </span><span class="s1">createPrerenderRootParamPromise(paramName, workStore, workUnitStore, apiName);</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s1">workUnitStore;</span>
            <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">Promise.resolve(workUnitStore.rootParams[paramName]);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createPrerenderRootParamPromise(paramName, workStore, prerenderStore, apiName) {</span>
    <span class="s2">switch</span><span class="s1">(prerenderStore.type){</span>
        <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">`</span><span class="s1">${apiName} </span><span class="s0">must not be used within a client component. Next.js should be preventing </span><span class="s1">${apiName} </span><span class="s0">from being included in client components statically, but did not in this case.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E693&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
        <span class="s2">default</span><span class="s1">:</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">underlyingParams = prerenderStore.rootParams;</span>
    <span class="s2">switch</span><span class="s1">(prerenderStore.type){</span>
        <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s5">// We are in a dynamicIO prerender.</span>
                <span class="s5">// The param is a fallback, so it should be treated as dynamic.</span>
                <span class="s2">if </span><span class="s1">(prerenderStore.fallbackRouteParams &amp;&amp; prerenderStore.fallbackRouteParams.has(paramName)) {</span>
                    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, workStore.route, apiName);</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s5">// We aren't in a dynamicIO prerender, but the param is a fallback,</span>
                <span class="s5">// so we need to make an erroring params object which will postpone/error if you access it</span>
                <span class="s2">if </span><span class="s1">(prerenderStore.fallbackRouteParams &amp;&amp; prerenderStore.fallbackRouteParams.has(paramName)) {</span>
                    <span class="s2">return </span><span class="s1">makeErroringRootParamPromise(paramName, workStore, prerenderStore, apiName);</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s1">prerenderStore;</span>
            <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s5">// If the param is not a fallback param, we just return the statically available value.</span>
    <span class="s2">return </span><span class="s1">Promise.resolve(underlyingParams[paramName]);</span>
<span class="s1">}</span>
<span class="s5">/** Deliberately async -- we want to create a rejected promise, not error synchronously. */ </span><span class="s1">async </span><span class="s2">function </span><span class="s1">makeErroringRootParamPromise(paramName, workStore, prerenderStore, apiName) {</span>
    <span class="s2">const </span><span class="s1">expression = (</span><span class="s3">0</span><span class="s1">, _reflectutils.describeStringPropertyAccess)(apiName, paramName);</span>
    <span class="s5">// In most dynamic APIs, we also throw if `dynamic = &quot;error&quot;`.</span>
    <span class="s5">// However, root params are only dynamic when we're generating a fallback shell,</span>
    <span class="s5">// and even with `dynamic = &quot;error&quot;` we still support generating dynamic fallback shells.</span>
    <span class="s5">// TODO: remove this comment when dynamicIO is the default since there will be no `dynamic = &quot;error&quot;`</span>
    <span class="s2">switch</span><span class="s1">(prerenderStore.type){</span>
        <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);</span>
            <span class="s1">}</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s1">prerenderStore;</span>
            <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">//# sourceMappingURL=root-params.js.map</span></pre>
</body>
</html>