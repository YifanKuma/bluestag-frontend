<html>
<head>
<title>mock-interceptor.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
mock-interceptor.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">{ IncomingHttpHeaders } from </span><span class="s2">'./header'</span>
<span class="s0">import </span><span class="s1">Dispatcher from </span><span class="s2">'./dispatcher'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ BodyInit, Headers } from </span><span class="s2">'./fetch'</span>

<span class="s0">export </span><span class="s1">{</span>
  <span class="s1">Interceptable,</span>
  <span class="s1">MockInterceptor,</span>
  <span class="s1">MockScope</span>
<span class="s1">}</span>

<span class="s3">/** The scope associated with a mock dispatch. */</span>
<span class="s1">declare </span><span class="s0">class </span><span class="s1">MockScope&lt;TData </span><span class="s0">extends </span><span class="s1">object = object&gt; {</span>
  <span class="s1">constructor(mockDispatch: MockInterceptor.MockDispatch&lt;TData&gt;);</span>
  <span class="s3">/** Delay a reply by a set amount of time in ms. */</span>
  <span class="s1">delay(waitInMs: number): MockScope&lt;TData&gt;;</span>
  <span class="s3">/** Persist the defined mock data for the associated reply. It will return the defined mock data indefinitely. */</span>
  <span class="s1">persist(): MockScope&lt;TData&gt;;</span>
  <span class="s3">/** Define a reply for a set amount of matching requests. */</span>
  <span class="s1">times(repeatTimes: number): MockScope&lt;TData&gt;;</span>
<span class="s1">}</span>

<span class="s3">/** The interceptor for a Mock. */</span>
<span class="s1">declare </span><span class="s0">class </span><span class="s1">MockInterceptor {</span>
  <span class="s1">constructor(options: MockInterceptor.Options, mockDispatches: MockInterceptor.MockDispatch[]);</span>
  <span class="s3">/** Mock an undici request with the defined reply. */</span>
  <span class="s1">reply&lt;TData </span><span class="s0">extends </span><span class="s1">object = object&gt;(replyOptionsCallback: MockInterceptor.MockReplyOptionsCallback&lt;TData&gt;): MockScope&lt;TData&gt;;</span>
  <span class="s1">reply&lt;TData </span><span class="s0">extends </span><span class="s1">object = object&gt;(</span>
    <span class="s1">statusCode: number,</span>
    <span class="s1">data?: TData | Buffer | string | MockInterceptor.MockResponseDataHandler&lt;TData&gt;,</span>
    <span class="s1">responseOptions?: MockInterceptor.MockResponseOptions</span>
  <span class="s1">): MockScope&lt;TData&gt;;</span>
  <span class="s3">/** Mock an undici request by throwing the defined reply error. */</span>
  <span class="s1">replyWithError&lt;TError </span><span class="s0">extends </span><span class="s1">Error = Error&gt;(error: TError): MockScope;</span>
  <span class="s3">/** Set default reply headers on the interceptor for subsequent mocked replies. */</span>
  <span class="s1">defaultReplyHeaders(headers: IncomingHttpHeaders): MockInterceptor;</span>
  <span class="s3">/** Set default reply trailers on the interceptor for subsequent mocked replies. */</span>
  <span class="s1">defaultReplyTrailers(trailers: Record&lt;string, string&gt;): MockInterceptor;</span>
  <span class="s3">/** Set automatically calculated content-length header on subsequent mocked replies. */</span>
  <span class="s1">replyContentLength(): MockInterceptor;</span>
<span class="s1">}</span>

<span class="s1">declare namespace MockInterceptor {</span>
  <span class="s3">/** MockInterceptor options. */</span>
  <span class="s0">export interface </span><span class="s1">Options {</span>
    <span class="s3">/** Path to intercept on. */</span>
    <span class="s1">path: string | RegExp | ((path: string) =&gt; boolean);</span>
    <span class="s3">/** Method to intercept on. Defaults to GET. */</span>
    <span class="s1">method?: string | RegExp | ((method: string) =&gt; boolean);</span>
    <span class="s3">/** Body to intercept on. */</span>
    <span class="s1">body?: string | RegExp | ((body: string) =&gt; boolean);</span>
    <span class="s3">/** Headers to intercept on. */</span>
    <span class="s1">headers?: Record&lt;string, string | RegExp | ((body: string) =&gt; boolean)&gt; | ((headers: Record&lt;string, string&gt;) =&gt; boolean);</span>
    <span class="s3">/** Query params to intercept on */</span>
    <span class="s1">query?: Record&lt;string, any&gt;;</span>
  <span class="s1">}</span>
  <span class="s0">export interface </span><span class="s1">MockDispatch&lt;TData </span><span class="s0">extends </span><span class="s1">object = object, TError </span><span class="s0">extends </span><span class="s1">Error = Error&gt; </span><span class="s0">extends </span><span class="s1">Options {</span>
    <span class="s1">times: number | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">persist: boolean;</span>
    <span class="s1">consumed: boolean;</span>
    <span class="s1">data: MockDispatchData&lt;TData, TError&gt;;</span>
  <span class="s1">}</span>
  <span class="s0">export interface </span><span class="s1">MockDispatchData&lt;TData </span><span class="s0">extends </span><span class="s1">object = object, TError </span><span class="s0">extends </span><span class="s1">Error = Error&gt; </span><span class="s0">extends </span><span class="s1">MockResponseOptions {</span>
    <span class="s1">error: TError | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">statusCode?: number;</span>
    <span class="s1">data?: TData | string;</span>
  <span class="s1">}</span>
  <span class="s0">export interface </span><span class="s1">MockResponseOptions {</span>
    <span class="s1">headers?: IncomingHttpHeaders;</span>
    <span class="s1">trailers?: Record&lt;string, string&gt;;</span>
  <span class="s1">}</span>

  <span class="s0">export interface </span><span class="s1">MockResponseCallbackOptions {</span>
    <span class="s1">path: string;</span>
    <span class="s1">method: string;</span>
    <span class="s1">headers?: Headers | Record&lt;string, string&gt;;</span>
    <span class="s1">origin?: string;</span>
    <span class="s1">body?: BodyInit | Dispatcher.DispatchOptions[</span><span class="s2">'body'</span><span class="s1">] | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">maxRedirections?: number;</span>
  <span class="s1">}</span>

  <span class="s0">export </span><span class="s1">type MockResponseDataHandler&lt;TData </span><span class="s0">extends </span><span class="s1">object = object&gt; = (</span>
    <span class="s1">opts: MockResponseCallbackOptions</span>
  <span class="s1">) =&gt; TData | Buffer | string;</span>

  <span class="s0">export </span><span class="s1">type MockReplyOptionsCallback&lt;TData </span><span class="s0">extends </span><span class="s1">object = object&gt; = (</span>
    <span class="s1">opts: MockResponseCallbackOptions</span>
  <span class="s1">) =&gt; { statusCode: number, data?: TData | Buffer | string, responseOptions?: MockResponseOptions }</span>
<span class="s1">}</span>

<span class="s0">interface </span><span class="s1">Interceptable </span><span class="s0">extends </span><span class="s1">Dispatcher {</span>
  <span class="s3">/** Intercepts any matching requests that use the same origin as this mock client. */</span>
  <span class="s1">intercept(options: MockInterceptor.Options): MockInterceptor;</span>
<span class="s1">}</span>
</pre>
</body>
</html>