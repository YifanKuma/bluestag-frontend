<html>
<head>
<title>bfcache.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
bfcache.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/client/components/bfcache.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { FlightRouterState } from '../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { useState } from 'react'</span><span class="s3">\n\n</span><span class="s1">// When the flag is disabled, only track the currently active tree</span><span class="s3">\n</span><span class="s1">const MAX_BF_CACHE_ENTRIES = process.env.__NEXT_ROUTER_BF_CACHE ? 3 : 1</span><span class="s3">\n\n</span><span class="s1">export type RouterBFCacheEntry = {</span><span class="s3">\n  </span><span class="s1">tree: FlightRouterState</span><span class="s3">\n  </span><span class="s1">stateKey: string</span><span class="s3">\n  </span><span class="s1">// The entries form a linked list, sorted in order of most recently active.</span><span class="s3">\n  </span><span class="s1">next: RouterBFCacheEntry | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Keeps track of the most recent N trees (FlightRouterStates) that were active</span><span class="s3">\n </span><span class="s1">* at a certain segment level. E.g. for a segment </span><span class="s3">\&quot;</span><span class="s1">/a/b/[param]</span><span class="s3">\&quot;</span><span class="s1">, this hook</span><span class="s3">\n </span><span class="s1">* tracks the last N param values that the router rendered for N.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The result of this hook precisely determines the number and order of</span><span class="s3">\n </span><span class="s1">* trees that are rendered in parallel at their segment level.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The purpose of this cache is to we can preserve the React and DOM state of</span><span class="s3">\n </span><span class="s1">* some number of inactive trees, by rendering them in an &lt;Activity&gt; boundary.</span><span class="s3">\n </span><span class="s1">* That means it would not make sense for the the lifetime of the cache to be</span><span class="s3">\n </span><span class="s1">* any longer than the lifetime of the React tree; e.g. if the hook were</span><span class="s3">\n </span><span class="s1">* unmounted, then the React tree would be, too. So, we use React state to</span><span class="s3">\n </span><span class="s1">* manage it.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Note that we don't store the RSC data for the cache entries in this hook —</span><span class="s3">\n </span><span class="s1">* the data for inactive segments is stored in the parent CacheNode, which</span><span class="s3">\n </span><span class="s1">* *does* have a longer lifetime than the React tree. This hook only determines</span><span class="s3">\n </span><span class="s1">* which of those trees should have their *state* preserved, by &lt;Activity&gt;.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function useRouterBFCache(</span><span class="s3">\n  </span><span class="s1">activeTree: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">activeStateKey: string</span><span class="s3">\n</span><span class="s1">): RouterBFCacheEntry {</span><span class="s3">\n  </span><span class="s1">// The currently active entry. The entries form a linked list, sorted in</span><span class="s3">\n  </span><span class="s1">// order of most recently active. This allows us to reuse parts of the list</span><span class="s3">\n  </span><span class="s1">// without cloning, unless there's a reordering or removal.</span><span class="s3">\n  </span><span class="s1">// TODO: Once we start tracking back/forward history at each route level,</span><span class="s3">\n  </span><span class="s1">// we should use the history order instead. In other words, when traversing</span><span class="s3">\n  </span><span class="s1">// to an existing entry as a result of a popstate event, we should maintain</span><span class="s3">\n  </span><span class="s1">// the existing order instead of moving it to the front of the list. I think</span><span class="s3">\n  </span><span class="s1">// an initial implementation of this could be to pass an incrementing id</span><span class="s3">\n  </span><span class="s1">// to history.pushState/replaceState, then use that here for ordering.</span><span class="s3">\n  </span><span class="s1">const [prevActiveEntry, setPrevActiveEntry] = useState&lt;RouterBFCacheEntry&gt;(</span><span class="s3">\n    </span><span class="s1">() =&gt; {</span><span class="s3">\n      </span><span class="s1">const initialEntry: RouterBFCacheEntry = {</span><span class="s3">\n        </span><span class="s1">tree: activeTree,</span><span class="s3">\n        </span><span class="s1">stateKey: activeStateKey,</span><span class="s3">\n        </span><span class="s1">next: null,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return initialEntry</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (prevActiveEntry.tree === activeTree) {</span><span class="s3">\n    </span><span class="s1">// Fast path. The active tree hasn't changed, so we can reuse the</span><span class="s3">\n    </span><span class="s1">// existing state.</span><span class="s3">\n    </span><span class="s1">return prevActiveEntry</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// The route tree changed. Note that this doesn't mean that the tree changed</span><span class="s3">\n  </span><span class="s1">// *at this level* — the change may be due to a child route. Either way, we</span><span class="s3">\n  </span><span class="s1">// need to either add or update the router tree in the bfcache.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// The rest of the code looks more complicated than it actually is because we</span><span class="s3">\n  </span><span class="s1">// can't mutate the state in place; we have to copy-on-write.</span><span class="s3">\n\n  </span><span class="s1">// Create a new entry for the active cache key. This is the head of the new</span><span class="s3">\n  </span><span class="s1">// linked list.</span><span class="s3">\n  </span><span class="s1">const newActiveEntry: RouterBFCacheEntry = {</span><span class="s3">\n    </span><span class="s1">tree: activeTree,</span><span class="s3">\n    </span><span class="s1">stateKey: activeStateKey,</span><span class="s3">\n    </span><span class="s1">next: null,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// We need to append the old list onto the new list. If the head of the new</span><span class="s3">\n  </span><span class="s1">// list was already present in the cache, then we'll need to clone everything</span><span class="s3">\n  </span><span class="s1">// that came before it. Then we can reuse the rest.</span><span class="s3">\n  </span><span class="s1">let n = 1</span><span class="s3">\n  </span><span class="s1">let oldEntry: RouterBFCacheEntry | null = prevActiveEntry</span><span class="s3">\n  </span><span class="s1">let clonedEntry: RouterBFCacheEntry = newActiveEntry</span><span class="s3">\n  </span><span class="s1">while (oldEntry !== null &amp;&amp; n &lt; MAX_BF_CACHE_ENTRIES) {</span><span class="s3">\n    </span><span class="s1">if (oldEntry.stateKey === activeStateKey) {</span><span class="s3">\n      </span><span class="s1">// Fast path. This entry in the old list that corresponds to the key that</span><span class="s3">\n      </span><span class="s1">// is now active. We've already placed a clone of this entry at the front</span><span class="s3">\n      </span><span class="s1">// of the new list. We can reuse the rest of the old list without cloning.</span><span class="s3">\n      </span><span class="s1">// NOTE: We don't need to worry about eviction in this case because we</span><span class="s3">\n      </span><span class="s1">// haven't increased the size of the cache, and we assume the max size</span><span class="s3">\n      </span><span class="s1">// is constant across renders. If we were to change it to a dynamic limit,</span><span class="s3">\n      </span><span class="s1">// then the implementation would need to account for that.</span><span class="s3">\n      </span><span class="s1">clonedEntry.next = oldEntry.next</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Clone the entry and append it to the list.</span><span class="s3">\n      </span><span class="s1">n++</span><span class="s3">\n      </span><span class="s1">const entry: RouterBFCacheEntry = {</span><span class="s3">\n        </span><span class="s1">tree: oldEntry.tree,</span><span class="s3">\n        </span><span class="s1">stateKey: oldEntry.stateKey,</span><span class="s3">\n        </span><span class="s1">next: null,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">clonedEntry.next = entry</span><span class="s3">\n      </span><span class="s1">clonedEntry = entry</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">oldEntry = oldEntry.next</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">setPrevActiveEntry(newActiveEntry)</span><span class="s3">\n  </span><span class="s1">return newActiveEntry</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;useRouterBFCache&quot;</span><span class="s0">,</span><span class="s1">&quot;MAX_BF_CACHE_ENTRIES&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_ROUTER_BF_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;activeTree&quot;</span><span class="s0">,</span><span class="s1">&quot;activeStateKey&quot;</span><span class="s0">,</span><span class="s1">&quot;prevActiveEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;setPrevActiveEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;useState&quot;</span><span class="s0">,</span><span class="s1">&quot;initialEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;stateKey&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;newActiveEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;n&quot;</span><span class="s0">,</span><span class="s1">&quot;oldEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;clonedEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;entry&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;+BAiCgBA;;;eAAAA;;;uBAhCS;AAEzB,kEAAkE;AAClE,MAAMC,uBAAuBC,QAAQC,GAAG,CAACC,sBAAsB,GAAG,IAAI;AA6B/D,SAASJ,iBACdK,UAA6B,EAC7BC,cAAsB;IAEtB,wEAAwE;IACxE,2EAA2E;IAC3E,2DAA2D;IAC3D,yEAAyE;IACzE,2EAA2E;IAC3E,2EAA2E;IAC3E,4EAA4E;IAC5E,wEAAwE;IACxE,sEAAsE;IACtE,MAAM,CAACC,iBAAiBC,mBAAmB,GAAGC,IAAAA,eAAQ,EACpD;QACE,MAAMC,eAAmC;YACvCC,MAAMN;YACNO,UAAUN;YACVO,MAAM;QACR;QACA,OAAOH;IACT;IAGF,IAAIH,gBAAgBI,IAAI,KAAKN,YAAY;QACvC,iEAAiE;QACjE,kBAAkB;QAClB,OAAOE;IACT;IAEA,4EAA4E;IAC5E,2EAA2E;IAC3E,+DAA+D;IAC/D,EAAE;IACF,6EAA6E;IAC7E,6DAA6D;IAE7D,2EAA2E;IAC3E,eAAe;IACf,MAAMO,iBAAqC;QACzCH,MAAMN;QACNO,UAAUN;QACVO,MAAM;IACR;IAEA,2EAA2E;IAC3E,6EAA6E;IAC7E,mDAAmD;IACnD,IAAIE,IAAI;IACR,IAAIC,WAAsCT;IAC1C,IAAIU,cAAkCH;IACtC,MAAOE,aAAa,QAAQD,IAAId,qBAAsB;QACpD,IAAIe,SAASJ,QAAQ,KAAKN,gBAAgB;YACxC,yEAAyE;YACzE,yEAAyE;YACzE,0EAA0E;YAC1E,sEAAsE;YACtE,sEAAsE;YACtE,0EAA0E;YAC1E,0DAA0D;YAC1DW,YAAYJ,IAAI,GAAGG,SAASH,IAAI;YAChC;QACF,OAAO;YACL,6CAA6C;YAC7CE;YACA,MAAMG,QAA4B;gBAChCP,MAAMK,SAASL,IAAI;gBACnBC,UAAUI,SAASJ,QAAQ;gBAC3BC,MAAM;YACR;YACAI,YAAYJ,IAAI,GAAGK;YACnBD,cAAcC;QAChB;QACAF,WAAWA,SAASH,IAAI;IAC1B;IAEAL,mBAAmBM;IACnB,OAAOA;AACT&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>