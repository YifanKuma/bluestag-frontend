<html>
<head>
<title>bigfraction.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #0033b3;}
.s4 { color: #067d17;}
.s5 { color: #1750eb;}
.s6 { color: #264eff;}
.s7 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
bigfraction.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@license </span><span class="s0">Fraction.js v4.2.1 20/08/2023</span>
 <span class="s0">* https://www.xarg.org/2014/03/rational-numbers-in-javascript/</span>
 <span class="s0">*</span>
 <span class="s0">* Copyright (c) 2023, Robert Eisele (robert@raw.org)</span>
 <span class="s0">* Dual licensed under the MIT or GPL Version 2 licenses.</span>
 <span class="s0">**/</span>


<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">* This class offers the possibility to calculate fractions.</span>
 <span class="s0">* You can pass a fraction in different formats. Either as array, as double, as string or as an integer.</span>
 <span class="s0">*</span>
 <span class="s0">* Array/Object form</span>
 <span class="s0">* [ 0 =&gt; &lt;numerator&gt;, 1 =&gt; &lt;denominator&gt; ]</span>
 <span class="s0">* [ n =&gt; &lt;numerator&gt;, d =&gt; &lt;denominator&gt; ]</span>
 <span class="s0">*</span>
 <span class="s0">* Integer form</span>
 <span class="s0">* - Single integer value</span>
 <span class="s0">*</span>
 <span class="s0">* Double form</span>
 <span class="s0">* - Single double value</span>
 <span class="s0">*</span>
 <span class="s0">* String form</span>
 <span class="s0">* 123.456 - a simple double</span>
 <span class="s0">* 123/456 - a string fraction</span>
 <span class="s0">* 123.'456' - a double with repeating decimal places</span>
 <span class="s0">* 123.(456) - synonym</span>
 <span class="s0">* 123.45'6' - a double with repeating last place</span>
 <span class="s0">* 123.45(6) - synonym</span>
 <span class="s0">*</span>
 <span class="s0">* Example:</span>
 <span class="s0">*</span>
 <span class="s0">* let f = new Fraction(&quot;9.4'31'&quot;);</span>
 <span class="s0">* f.mul([-4, 3]).div(4.9);</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s2">(</span><span class="s3">function</span><span class="s2">(root) {</span>

  <span class="s4">&quot;use strict&quot;</span><span class="s2">;</span>

  <span class="s0">// Set Identity function to downgrade BigInt to Number if needed</span>
  <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">BigInt === </span><span class="s4">'undefined'</span><span class="s2">) BigInt = </span><span class="s3">function</span><span class="s2">(n) { </span><span class="s3">if </span><span class="s2">(isNaN(n)) </span><span class="s3">throw new </span><span class="s2">Error(</span><span class="s4">&quot;&quot;</span><span class="s2">); </span><span class="s3">return </span><span class="s2">n; };</span>

  <span class="s3">const </span><span class="s2">C_ONE = BigInt(</span><span class="s5">1</span><span class="s2">);</span>
  <span class="s3">const </span><span class="s2">C_ZERO = BigInt(</span><span class="s5">0</span><span class="s2">);</span>
  <span class="s3">const </span><span class="s2">C_TEN = BigInt(</span><span class="s5">10</span><span class="s2">);</span>
  <span class="s3">const </span><span class="s2">C_TWO = BigInt(</span><span class="s5">2</span><span class="s2">);</span>
  <span class="s3">const </span><span class="s2">C_FIVE = BigInt(</span><span class="s5">5</span><span class="s2">);</span>

  <span class="s0">// Maximum search depth for cyclic rational numbers. 2000 should be more than enough.</span>
  <span class="s0">// Example: 1/7 = 0.(142857) has 6 repeating decimal places.</span>
  <span class="s0">// If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits</span>
  <span class="s3">const </span><span class="s2">MAX_CYCLE_LEN = </span><span class="s5">2000</span><span class="s2">;</span>

  <span class="s0">// Parsed data to avoid calling &quot;new&quot; all the time</span>
  <span class="s3">const </span><span class="s2">P = {</span>
    <span class="s4">&quot;s&quot;</span><span class="s2">: C_ONE,</span>
    <span class="s4">&quot;n&quot;</span><span class="s2">: C_ZERO,</span>
    <span class="s4">&quot;d&quot;</span><span class="s2">: C_ONE</span>
  <span class="s2">};</span>

  <span class="s3">function </span><span class="s2">assign(n, s) {</span>

    <span class="s3">try </span><span class="s2">{</span>
      <span class="s2">n = BigInt(n);</span>
    <span class="s2">} </span><span class="s3">catch </span><span class="s2">(e) {</span>
      <span class="s3">throw </span><span class="s2">InvalidParameter();</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s2">n * s;</span>
  <span class="s2">}</span>

  <span class="s0">// Creates a new Fraction internally without the need of the bulky constructor</span>
  <span class="s3">function </span><span class="s2">newFraction(n, d) {</span>

    <span class="s3">if </span><span class="s2">(d === C_ZERO) {</span>
      <span class="s3">throw </span><span class="s2">DivisionByZero();</span>
    <span class="s2">}</span>

    <span class="s3">const </span><span class="s2">f = Object.create(Fraction.prototype);</span>
    <span class="s2">f[</span><span class="s4">&quot;s&quot;</span><span class="s2">] = n &lt; C_ZERO ? -C_ONE : C_ONE;</span>

    <span class="s2">n = n &lt; C_ZERO ? -n : n;</span>

    <span class="s3">const </span><span class="s2">a = gcd(n, d);</span>

    <span class="s2">f[</span><span class="s4">&quot;n&quot;</span><span class="s2">] = n / a;</span>
    <span class="s2">f[</span><span class="s4">&quot;d&quot;</span><span class="s2">] = d / a;</span>
    <span class="s3">return </span><span class="s2">f;</span>
  <span class="s2">}</span>

  <span class="s3">function </span><span class="s2">factorize(num) {</span>

    <span class="s3">const </span><span class="s2">factors = {};</span>

    <span class="s3">let </span><span class="s2">n = num;</span>
    <span class="s3">let </span><span class="s2">i = C_TWO;</span>
    <span class="s3">let </span><span class="s2">s = C_FIVE - C_ONE;</span>

    <span class="s3">while </span><span class="s2">(s &lt;= n) {</span>

      <span class="s3">while </span><span class="s2">(n % i === C_ZERO) {</span>
        <span class="s2">n/= i;</span>
        <span class="s2">factors[i] = (factors[i] || C_ZERO) + C_ONE;</span>
      <span class="s2">}</span>
      <span class="s2">s+= C_ONE + C_TWO * i++;</span>
    <span class="s2">}</span>

    <span class="s3">if </span><span class="s2">(n !== num) {</span>
      <span class="s3">if </span><span class="s2">(n &gt; </span><span class="s5">1</span><span class="s2">)</span>
        <span class="s2">factors[n] = (factors[n] || C_ZERO) + C_ONE;</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s2">factors[num] = (factors[num] || C_ZERO) + C_ONE;</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s2">factors;</span>
  <span class="s2">}</span>

  <span class="s3">const </span><span class="s2">parse = </span><span class="s3">function</span><span class="s2">(p1, p2) {</span>

    <span class="s3">let </span><span class="s2">n = C_ZERO, d = C_ONE, s = C_ONE;</span>

    <span class="s3">if </span><span class="s2">(p1 === undefined || p1 === </span><span class="s3">null</span><span class="s2">) {</span>
      <span class="s0">/* void */</span>
    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(p2 !== undefined) {</span>
      <span class="s2">n = BigInt(p1);</span>
      <span class="s2">d = BigInt(p2);</span>
      <span class="s2">s = n * d;</span>

      <span class="s3">if </span><span class="s2">(n % C_ONE !== C_ZERO || d % C_ONE !== C_ZERO) {</span>
        <span class="s3">throw </span><span class="s2">NonIntegerParameter();</span>
      <span class="s2">}</span>

    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">p1 === </span><span class="s4">&quot;object&quot;</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s4">&quot;d&quot; </span><span class="s3">in </span><span class="s2">p1 &amp;&amp; </span><span class="s4">&quot;n&quot; </span><span class="s3">in </span><span class="s2">p1) {</span>
        <span class="s2">n = BigInt(p1[</span><span class="s4">&quot;n&quot;</span><span class="s2">]);</span>
        <span class="s2">d = BigInt(p1[</span><span class="s4">&quot;d&quot;</span><span class="s2">]);</span>
        <span class="s3">if </span><span class="s2">(</span><span class="s4">&quot;s&quot; </span><span class="s3">in </span><span class="s2">p1)</span>
          <span class="s2">n*= BigInt(p1[</span><span class="s4">&quot;s&quot;</span><span class="s2">]);</span>
      <span class="s2">} </span><span class="s3">else if </span><span class="s2">(</span><span class="s5">0 </span><span class="s3">in </span><span class="s2">p1) {</span>
        <span class="s2">n = BigInt(p1[</span><span class="s5">0</span><span class="s2">]);</span>
        <span class="s3">if </span><span class="s2">(</span><span class="s5">1 </span><span class="s3">in </span><span class="s2">p1)</span>
          <span class="s2">d = BigInt(p1[</span><span class="s5">1</span><span class="s2">]);</span>
      <span class="s2">} </span><span class="s3">else if </span><span class="s2">(p1 </span><span class="s3">instanceof </span><span class="s2">BigInt) {</span>
        <span class="s2">n = BigInt(p1);</span>
      <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
        <span class="s3">throw </span><span class="s2">InvalidParameter();</span>
      <span class="s2">}</span>
      <span class="s2">s = n * d;</span>
    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">p1 === </span><span class="s4">&quot;bigint&quot;</span><span class="s2">) {</span>
      <span class="s2">n = p1;</span>
      <span class="s2">s = p1;</span>
      <span class="s2">d = C_ONE;</span>
    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">p1 === </span><span class="s4">&quot;number&quot;</span><span class="s2">) {</span>

      <span class="s3">if </span><span class="s2">(isNaN(p1)) {</span>
        <span class="s3">throw </span><span class="s2">InvalidParameter();</span>
      <span class="s2">}</span>

      <span class="s3">if </span><span class="s2">(p1 &lt; </span><span class="s5">0</span><span class="s2">) {</span>
        <span class="s2">s = -C_ONE;</span>
        <span class="s2">p1 = -p1;</span>
      <span class="s2">}</span>

      <span class="s3">if </span><span class="s2">(p1 % </span><span class="s5">1 </span><span class="s2">=== </span><span class="s5">0</span><span class="s2">) {</span>
        <span class="s2">n = BigInt(p1);</span>
      <span class="s2">} </span><span class="s3">else if </span><span class="s2">(p1 &gt; </span><span class="s5">0</span><span class="s2">) { </span><span class="s0">// check for != 0, scale would become NaN (log(0)), which converges really slow</span>

        <span class="s3">let </span><span class="s2">z = </span><span class="s5">1</span><span class="s2">;</span>

        <span class="s3">let </span><span class="s2">A = </span><span class="s5">0</span><span class="s2">, B = </span><span class="s5">1</span><span class="s2">;</span>
        <span class="s3">let </span><span class="s2">C = </span><span class="s5">1</span><span class="s2">, D = </span><span class="s5">1</span><span class="s2">;</span>

        <span class="s3">let </span><span class="s2">N = </span><span class="s5">10000000</span><span class="s2">;</span>

        <span class="s3">if </span><span class="s2">(p1 &gt;= </span><span class="s5">1</span><span class="s2">) {</span>
          <span class="s2">z = </span><span class="s5">10 </span><span class="s2">** Math.floor(</span><span class="s5">1 </span><span class="s2">+ Math.log10(p1));</span>
          <span class="s2">p1/= z;</span>
        <span class="s2">}</span>

        <span class="s0">// Using Farey Sequences</span>

        <span class="s3">while </span><span class="s2">(B &lt;= N &amp;&amp; D &lt;= N) {</span>
          <span class="s3">let </span><span class="s2">M = (A + C) / (B + D);</span>

          <span class="s3">if </span><span class="s2">(p1 === M) {</span>
            <span class="s3">if </span><span class="s2">(B + D &lt;= N) {</span>
              <span class="s2">n = A + C;</span>
              <span class="s2">d = B + D;</span>
            <span class="s2">} </span><span class="s3">else if </span><span class="s2">(D &gt; B) {</span>
              <span class="s2">n = C;</span>
              <span class="s2">d = D;</span>
            <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
              <span class="s2">n = A;</span>
              <span class="s2">d = B;</span>
            <span class="s2">}</span>
            <span class="s3">break</span><span class="s2">;</span>

          <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>

            <span class="s3">if </span><span class="s2">(p1 &gt; M) {</span>
              <span class="s2">A+= C;</span>
              <span class="s2">B+= D;</span>
            <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
              <span class="s2">C+= A;</span>
              <span class="s2">D+= B;</span>
            <span class="s2">}</span>

            <span class="s3">if </span><span class="s2">(B &gt; N) {</span>
              <span class="s2">n = C;</span>
              <span class="s2">d = D;</span>
            <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
              <span class="s2">n = A;</span>
              <span class="s2">d = B;</span>
            <span class="s2">}</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s2">n = BigInt(n) * BigInt(z);</span>
        <span class="s2">d = BigInt(d);</span>

      <span class="s2">}</span>

    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">p1 === </span><span class="s4">&quot;string&quot;</span><span class="s2">) {</span>

      <span class="s3">let </span><span class="s2">ndx = </span><span class="s5">0</span><span class="s2">;</span>

      <span class="s3">let </span><span class="s2">v = C_ZERO, w = C_ZERO, x = C_ZERO, y = C_ONE, z = C_ONE;</span>

      <span class="s3">let </span><span class="s2">match = p1.match(</span><span class="s6">/\d+|./g</span><span class="s2">);</span>

      <span class="s3">if </span><span class="s2">(match === </span><span class="s3">null</span><span class="s2">)</span>
        <span class="s3">throw </span><span class="s2">InvalidParameter();</span>

      <span class="s3">if </span><span class="s2">(match[ndx] === </span><span class="s4">'-'</span><span class="s2">) {</span><span class="s0">// Check for minus sign at the beginning</span>
        <span class="s2">s = -C_ONE;</span>
        <span class="s2">ndx++;</span>
      <span class="s2">} </span><span class="s3">else if </span><span class="s2">(match[ndx] === </span><span class="s4">'+'</span><span class="s2">) {</span><span class="s0">// Check for plus sign at the beginning</span>
        <span class="s2">ndx++;</span>
      <span class="s2">}</span>

      <span class="s3">if </span><span class="s2">(match.length === ndx + </span><span class="s5">1</span><span class="s2">) { </span><span class="s0">// Check if it's just a simple number &quot;1234&quot;</span>
        <span class="s2">w = assign(match[ndx++], s);</span>
      <span class="s2">} </span><span class="s3">else if </span><span class="s2">(match[ndx + </span><span class="s5">1</span><span class="s2">] === </span><span class="s4">'.' </span><span class="s2">|| match[ndx] === </span><span class="s4">'.'</span><span class="s2">) { </span><span class="s0">// Check if it's a decimal number</span>

        <span class="s3">if </span><span class="s2">(match[ndx] !== </span><span class="s4">'.'</span><span class="s2">) { </span><span class="s0">// Handle 0.5 and .5</span>
          <span class="s2">v = assign(match[ndx++], s);</span>
        <span class="s2">}</span>
        <span class="s2">ndx++;</span>

        <span class="s0">// Check for decimal places</span>
        <span class="s3">if </span><span class="s2">(ndx + </span><span class="s5">1 </span><span class="s2">=== match.length || match[ndx + </span><span class="s5">1</span><span class="s2">] === </span><span class="s4">'(' </span><span class="s2">&amp;&amp; match[ndx + </span><span class="s5">3</span><span class="s2">] === </span><span class="s4">')' </span><span class="s2">|| match[ndx + </span><span class="s5">1</span><span class="s2">] === </span><span class="s4">&quot;'&quot; </span><span class="s2">&amp;&amp; match[ndx + </span><span class="s5">3</span><span class="s2">] === </span><span class="s4">&quot;'&quot;</span><span class="s2">) {</span>
          <span class="s2">w = assign(match[ndx], s);</span>
          <span class="s2">y = C_TEN ** BigInt(match[ndx].length);</span>
          <span class="s2">ndx++;</span>
        <span class="s2">}</span>

        <span class="s0">// Check for repeating places</span>
        <span class="s3">if </span><span class="s2">(match[ndx] === </span><span class="s4">'(' </span><span class="s2">&amp;&amp; match[ndx + </span><span class="s5">2</span><span class="s2">] === </span><span class="s4">')' </span><span class="s2">|| match[ndx] === </span><span class="s4">&quot;'&quot; </span><span class="s2">&amp;&amp; match[ndx + </span><span class="s5">2</span><span class="s2">] === </span><span class="s4">&quot;'&quot;</span><span class="s2">) {</span>
          <span class="s2">x = assign(match[ndx + </span><span class="s5">1</span><span class="s2">], s);</span>
          <span class="s2">z = C_TEN ** BigInt(match[ndx + </span><span class="s5">1</span><span class="s2">].length) - C_ONE;</span>
          <span class="s2">ndx+= </span><span class="s5">3</span><span class="s2">;</span>
        <span class="s2">}</span>

      <span class="s2">} </span><span class="s3">else if </span><span class="s2">(match[ndx + </span><span class="s5">1</span><span class="s2">] === </span><span class="s4">'/' </span><span class="s2">|| match[ndx + </span><span class="s5">1</span><span class="s2">] === </span><span class="s4">':'</span><span class="s2">) { </span><span class="s0">// Check for a simple fraction &quot;123/456&quot; or &quot;123:456&quot;</span>
        <span class="s2">w = assign(match[ndx], s);</span>
        <span class="s2">y = assign(match[ndx + </span><span class="s5">2</span><span class="s2">], C_ONE);</span>
        <span class="s2">ndx+= </span><span class="s5">3</span><span class="s2">;</span>
      <span class="s2">} </span><span class="s3">else if </span><span class="s2">(match[ndx + </span><span class="s5">3</span><span class="s2">] === </span><span class="s4">'/' </span><span class="s2">&amp;&amp; match[ndx + </span><span class="s5">1</span><span class="s2">] === </span><span class="s4">' '</span><span class="s2">) { </span><span class="s0">// Check for a complex fraction &quot;123 1/2&quot;</span>
        <span class="s2">v = assign(match[ndx], s);</span>
        <span class="s2">w = assign(match[ndx + </span><span class="s5">2</span><span class="s2">], s);</span>
        <span class="s2">y = assign(match[ndx + </span><span class="s5">4</span><span class="s2">], C_ONE);</span>
        <span class="s2">ndx+= </span><span class="s5">5</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s3">if </span><span class="s2">(match.length &lt;= ndx) { </span><span class="s0">// Check for more tokens on the stack</span>
        <span class="s2">d = y * z;</span>
        <span class="s2">s = </span><span class="s0">/* void */</span>
        <span class="s2">n = x + d * v + z * w;</span>
      <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
        <span class="s3">throw </span><span class="s2">InvalidParameter();</span>
      <span class="s2">}</span>

    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">throw </span><span class="s2">InvalidParameter();</span>
    <span class="s2">}</span>

    <span class="s3">if </span><span class="s2">(d === C_ZERO) {</span>
      <span class="s3">throw </span><span class="s2">DivisionByZero();</span>
    <span class="s2">}</span>

    <span class="s2">P[</span><span class="s4">&quot;s&quot;</span><span class="s2">] = s &lt; C_ZERO ? -C_ONE : C_ONE;</span>
    <span class="s2">P[</span><span class="s4">&quot;n&quot;</span><span class="s2">] = n &lt; C_ZERO ? -n : n;</span>
    <span class="s2">P[</span><span class="s4">&quot;d&quot;</span><span class="s2">] = d &lt; C_ZERO ? -d : d;</span>
  <span class="s2">};</span>

  <span class="s3">function </span><span class="s2">modpow(b, e, m) {</span>

    <span class="s3">let </span><span class="s2">r = C_ONE;</span>
    <span class="s3">for </span><span class="s2">(; e &gt; C_ZERO; b = (b * b) % m, e &gt;&gt;= C_ONE) {</span>

      <span class="s3">if </span><span class="s2">(e &amp; C_ONE) {</span>
        <span class="s2">r = (r * b) % m;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s2">r;</span>
  <span class="s2">}</span>

  <span class="s3">function </span><span class="s2">cycleLen(n, d) {</span>

    <span class="s3">for </span><span class="s2">(; d % C_TWO === C_ZERO;</span>
      <span class="s2">d/= C_TWO) {</span>
    <span class="s2">}</span>

    <span class="s3">for </span><span class="s2">(; d % C_FIVE === C_ZERO;</span>
      <span class="s2">d/= C_FIVE) {</span>
    <span class="s2">}</span>

    <span class="s3">if </span><span class="s2">(d === C_ONE) </span><span class="s0">// Catch non-cyclic numbers</span>
      <span class="s3">return </span><span class="s2">C_ZERO;</span>

    <span class="s0">// If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:</span>
    <span class="s0">// 10^(d-1) % d == 1</span>
    <span class="s0">// However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,</span>
    <span class="s0">// as we want to translate the numbers to strings.</span>

    <span class="s3">let </span><span class="s2">rem = C_TEN % d;</span>
    <span class="s3">let </span><span class="s2">t = </span><span class="s5">1</span><span class="s2">;</span>

    <span class="s3">for </span><span class="s2">(; rem !== C_ONE; t++) {</span>
      <span class="s2">rem = rem * C_TEN % d;</span>

      <span class="s3">if </span><span class="s2">(t &gt; MAX_CYCLE_LEN)</span>
        <span class="s3">return </span><span class="s2">C_ZERO; </span><span class="s0">// Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s2">BigInt(t);</span>
  <span class="s2">}</span>

  <span class="s3">function </span><span class="s2">cycleStart(n, d, len) {</span>

    <span class="s3">let </span><span class="s2">rem1 = C_ONE;</span>
    <span class="s3">let </span><span class="s2">rem2 = modpow(C_TEN, len, d);</span>

    <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">t = </span><span class="s5">0</span><span class="s2">; t &lt; </span><span class="s5">300</span><span class="s2">; t++) { </span><span class="s0">// s &lt; ~log10(Number.MAX_VALUE)</span>
      <span class="s0">// Solve 10^s == 10^(s+t) (mod d)</span>

      <span class="s3">if </span><span class="s2">(rem1 === rem2)</span>
        <span class="s3">return </span><span class="s2">BigInt(t);</span>

      <span class="s2">rem1 = rem1 * C_TEN % d;</span>
      <span class="s2">rem2 = rem2 * C_TEN % d;</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">}</span>

  <span class="s3">function </span><span class="s2">gcd(a, b) {</span>

    <span class="s3">if </span><span class="s2">(!a)</span>
      <span class="s3">return </span><span class="s2">b;</span>
    <span class="s3">if </span><span class="s2">(!b)</span>
      <span class="s3">return </span><span class="s2">a;</span>

    <span class="s3">while </span><span class="s2">(</span><span class="s5">1</span><span class="s2">) {</span>
      <span class="s2">a%= b;</span>
      <span class="s3">if </span><span class="s2">(!a)</span>
        <span class="s3">return </span><span class="s2">b;</span>
      <span class="s2">b%= a;</span>
      <span class="s3">if </span><span class="s2">(!b)</span>
        <span class="s3">return </span><span class="s2">a;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s0">/**</span>
   <span class="s0">* Module constructor</span>
   <span class="s0">*</span>
   <span class="s0">* </span><span class="s1">@constructor</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number|Fraction=} a</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number=} b</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s2">Fraction(a, b) {</span>

    <span class="s2">parse(a, b);</span>

    <span class="s3">if </span><span class="s2">(</span><span class="s3">this instanceof </span><span class="s2">Fraction) {</span>
      <span class="s2">a = gcd(P[</span><span class="s4">&quot;d&quot;</span><span class="s2">], P[</span><span class="s4">&quot;n&quot;</span><span class="s2">]); </span><span class="s0">// Abuse a</span>
      <span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;s&quot;</span><span class="s2">] = P[</span><span class="s4">&quot;s&quot;</span><span class="s2">];</span>
      <span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">] = P[</span><span class="s4">&quot;n&quot;</span><span class="s2">] / a;</span>
      <span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">] = P[</span><span class="s4">&quot;d&quot;</span><span class="s2">] / a;</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">return </span><span class="s2">newFraction(P[</span><span class="s4">'s'</span><span class="s2">] * P[</span><span class="s4">'n'</span><span class="s2">], P[</span><span class="s4">'d'</span><span class="s2">]);</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s3">var </span><span class="s2">DivisionByZero = </span><span class="s3">function</span><span class="s2">() {</span><span class="s3">return new </span><span class="s2">Error(</span><span class="s4">&quot;Division by Zero&quot;</span><span class="s2">);};</span>
  <span class="s3">var </span><span class="s2">InvalidParameter = </span><span class="s3">function</span><span class="s2">() {</span><span class="s3">return new </span><span class="s2">Error(</span><span class="s4">&quot;Invalid argument&quot;</span><span class="s2">);};</span>
  <span class="s3">var </span><span class="s2">NonIntegerParameter = </span><span class="s3">function</span><span class="s2">() {</span><span class="s3">return new </span><span class="s2">Error(</span><span class="s4">&quot;Parameters must be integer&quot;</span><span class="s2">);};</span>

  <span class="s2">Fraction.prototype = {</span>

    <span class="s4">&quot;s&quot;</span><span class="s2">: C_ONE,</span>
    <span class="s4">&quot;n&quot;</span><span class="s2">: C_ZERO,</span>
    <span class="s4">&quot;d&quot;</span><span class="s2">: C_ONE,</span>

    <span class="s0">/**</span>
     <span class="s0">* Calculates the absolute value</span>
     <span class="s0">*</span>
     <span class="s0">* Ex: new Fraction(-4).abs() =&gt; 4</span>
     <span class="s0">**/</span>
    <span class="s4">&quot;abs&quot;</span><span class="s2">: </span><span class="s3">function</span><span class="s2">() {</span>

      <span class="s3">return </span><span class="s2">newFraction(</span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">], </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">]);</span>
    <span class="s2">},</span>

    <span class="s0">/**</span>
     <span class="s0">* Inverts the sign of the current fraction</span>
     <span class="s0">*</span>
     <span class="s0">* Ex: new Fraction(-4).neg() =&gt; 4</span>
     <span class="s0">**/</span>
    <span class="s4">&quot;neg&quot;</span><span class="s2">: </span><span class="s3">function</span><span class="s2">() {</span>

      <span class="s3">return </span><span class="s2">newFraction(-</span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;s&quot;</span><span class="s2">] * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">], </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">]);</span>
    <span class="s2">},</span>

    <span class="s0">/**</span>
     <span class="s0">* Adds two rational numbers</span>
     <span class="s0">*</span>
     <span class="s0">* Ex: new Fraction({n: 2, d: 3}).add(&quot;14.9&quot;) =&gt; 467 / 30</span>
     <span class="s0">**/</span>
    <span class="s4">&quot;add&quot;</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(a, b) {</span>

      <span class="s2">parse(a, b);</span>
      <span class="s3">return </span><span class="s2">newFraction(</span>
        <span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;s&quot;</span><span class="s2">] * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">] * P[</span><span class="s4">&quot;d&quot;</span><span class="s2">] + P[</span><span class="s4">&quot;s&quot;</span><span class="s2">] * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">] * P[</span><span class="s4">&quot;n&quot;</span><span class="s2">],</span>
        <span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">] * P[</span><span class="s4">&quot;d&quot;</span><span class="s2">]</span>
      <span class="s2">);</span>
    <span class="s2">},</span>

    <span class="s0">/**</span>
     <span class="s0">* Subtracts two rational numbers</span>
     <span class="s0">*</span>
     <span class="s0">* Ex: new Fraction({n: 2, d: 3}).add(&quot;14.9&quot;) =&gt; -427 / 30</span>
     <span class="s0">**/</span>
    <span class="s4">&quot;sub&quot;</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(a, b) {</span>

      <span class="s2">parse(a, b);</span>
      <span class="s3">return </span><span class="s2">newFraction(</span>
        <span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;s&quot;</span><span class="s2">] * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">] * P[</span><span class="s4">&quot;d&quot;</span><span class="s2">] - P[</span><span class="s4">&quot;s&quot;</span><span class="s2">] * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">] * P[</span><span class="s4">&quot;n&quot;</span><span class="s2">],</span>
        <span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">] * P[</span><span class="s4">&quot;d&quot;</span><span class="s2">]</span>
      <span class="s2">);</span>
    <span class="s2">},</span>

    <span class="s0">/**</span>
     <span class="s0">* Multiplies two rational numbers</span>
     <span class="s0">*</span>
     <span class="s0">* Ex: new Fraction(&quot;-17.(345)&quot;).mul(3) =&gt; 5776 / 111</span>
     <span class="s0">**/</span>
    <span class="s4">&quot;mul&quot;</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(a, b) {</span>

      <span class="s2">parse(a, b);</span>
      <span class="s3">return </span><span class="s2">newFraction(</span>
        <span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;s&quot;</span><span class="s2">] * P[</span><span class="s4">&quot;s&quot;</span><span class="s2">] * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">] * P[</span><span class="s4">&quot;n&quot;</span><span class="s2">],</span>
        <span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">] * P[</span><span class="s4">&quot;d&quot;</span><span class="s2">]</span>
      <span class="s2">);</span>
    <span class="s2">},</span>

    <span class="s0">/**</span>
     <span class="s0">* Divides two rational numbers</span>
     <span class="s0">*</span>
     <span class="s0">* Ex: new Fraction(&quot;-17.(345)&quot;).inverse().div(3)</span>
     <span class="s0">**/</span>
    <span class="s4">&quot;div&quot;</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(a, b) {</span>

      <span class="s2">parse(a, b);</span>
      <span class="s3">return </span><span class="s2">newFraction(</span>
        <span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;s&quot;</span><span class="s2">] * P[</span><span class="s4">&quot;s&quot;</span><span class="s2">] * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">] * P[</span><span class="s4">&quot;d&quot;</span><span class="s2">],</span>
        <span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">] * P[</span><span class="s4">&quot;n&quot;</span><span class="s2">]</span>
      <span class="s2">);</span>
    <span class="s2">},</span>

    <span class="s0">/**</span>
     <span class="s0">* Clones the actual object</span>
     <span class="s0">*</span>
     <span class="s0">* Ex: new Fraction(&quot;-17.(345)&quot;).clone()</span>
     <span class="s0">**/</span>
    <span class="s4">&quot;clone&quot;</span><span class="s2">: </span><span class="s3">function</span><span class="s2">() {</span>
      <span class="s3">return </span><span class="s2">newFraction(</span><span class="s3">this</span><span class="s2">[</span><span class="s4">'s'</span><span class="s2">] * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">'n'</span><span class="s2">], </span><span class="s3">this</span><span class="s2">[</span><span class="s4">'d'</span><span class="s2">]);</span>
    <span class="s2">},</span>

    <span class="s0">/**</span>
     <span class="s0">* Calculates the modulo of two rational numbers - a more precise fmod</span>
     <span class="s0">*</span>
     <span class="s0">* Ex: new Fraction('4.(3)').mod([7, 8]) =&gt; (13/3) % (7/8) = (5/6)</span>
     <span class="s0">**/</span>
    <span class="s4">&quot;mod&quot;</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(a, b) {</span>

      <span class="s3">if </span><span class="s2">(a === undefined) {</span>
        <span class="s3">return </span><span class="s2">newFraction(</span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;s&quot;</span><span class="s2">] * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">] % </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">], C_ONE);</span>
      <span class="s2">}</span>

      <span class="s2">parse(a, b);</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== P[</span><span class="s4">&quot;n&quot;</span><span class="s2">] &amp;&amp; </span><span class="s5">0 </span><span class="s2">=== </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">]) {</span>
        <span class="s3">throw </span><span class="s2">DivisionByZero();</span>
      <span class="s2">}</span>

      <span class="s0">/* 
       * First silly attempt, kinda slow 
       * 
       return that[&quot;sub&quot;]({ 
       &quot;n&quot;: num[&quot;n&quot;] * Math.floor((this.n / this.d) / (num.n / num.d)), 
       &quot;d&quot;: num[&quot;d&quot;], 
       &quot;s&quot;: this[&quot;s&quot;] 
       });*/</span>

      <span class="s0">/* 
       * New attempt: a1 / b1 = a2 / b2 * q + r 
       * =&gt; b2 * a1 = a2 * b1 * q + b1 * b2 * r 
       * =&gt; (b2 * a1 % a2 * b1) / (b1 * b2) 
       */</span>
      <span class="s3">return </span><span class="s2">newFraction(</span>
        <span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;s&quot;</span><span class="s2">] * (P[</span><span class="s4">&quot;d&quot;</span><span class="s2">] * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">]) % (P[</span><span class="s4">&quot;n&quot;</span><span class="s2">] * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">]),</span>
        <span class="s2">P[</span><span class="s4">&quot;d&quot;</span><span class="s2">] * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">]</span>
      <span class="s2">);</span>
    <span class="s2">},</span>

    <span class="s0">/**</span>
     <span class="s0">* Calculates the fractional gcd of two rational numbers</span>
     <span class="s0">*</span>
     <span class="s0">* Ex: new Fraction(5,8).gcd(3,7) =&gt; 1/56</span>
     <span class="s0">*/</span>
    <span class="s4">&quot;gcd&quot;</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(a, b) {</span>

      <span class="s2">parse(a, b);</span>

      <span class="s0">// gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)</span>

      <span class="s3">return </span><span class="s2">newFraction(gcd(P[</span><span class="s4">&quot;n&quot;</span><span class="s2">], </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">]) * gcd(P[</span><span class="s4">&quot;d&quot;</span><span class="s2">], </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">]), P[</span><span class="s4">&quot;d&quot;</span><span class="s2">] * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">]);</span>
    <span class="s2">},</span>

    <span class="s0">/**</span>
     <span class="s0">* Calculates the fractional lcm of two rational numbers</span>
     <span class="s0">*</span>
     <span class="s0">* Ex: new Fraction(5,8).lcm(3,7) =&gt; 15</span>
     <span class="s0">*/</span>
    <span class="s4">&quot;lcm&quot;</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(a, b) {</span>

      <span class="s2">parse(a, b);</span>

      <span class="s0">// lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)</span>

      <span class="s3">if </span><span class="s2">(P[</span><span class="s4">&quot;n&quot;</span><span class="s2">] === C_ZERO &amp;&amp; </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">] === C_ZERO) {</span>
        <span class="s3">return </span><span class="s2">newFraction(C_ZERO, C_ONE);</span>
      <span class="s2">}</span>
      <span class="s3">return </span><span class="s2">newFraction(P[</span><span class="s4">&quot;n&quot;</span><span class="s2">] * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">], gcd(P[</span><span class="s4">&quot;n&quot;</span><span class="s2">], </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">]) * gcd(P[</span><span class="s4">&quot;d&quot;</span><span class="s2">], </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">]));</span>
    <span class="s2">},</span>

    <span class="s0">/**</span>
     <span class="s0">* Gets the inverse of the fraction, means numerator and denominator are exchanged</span>
     <span class="s0">*</span>
     <span class="s0">* Ex: new Fraction([-3, 4]).inverse() =&gt; -4 / 3</span>
     <span class="s0">**/</span>
    <span class="s4">&quot;inverse&quot;</span><span class="s2">: </span><span class="s3">function</span><span class="s2">() {</span>
      <span class="s3">return </span><span class="s2">newFraction(</span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;s&quot;</span><span class="s2">] * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">], </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">]);</span>
    <span class="s2">},</span>

    <span class="s0">/**</span>
     <span class="s0">* Calculates the fraction to some integer exponent</span>
     <span class="s0">*</span>
     <span class="s0">* Ex: new Fraction(-1,2).pow(-3) =&gt; -8</span>
     <span class="s0">*/</span>
    <span class="s4">&quot;pow&quot;</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(a, b) {</span>

      <span class="s2">parse(a, b);</span>

      <span class="s0">// Trivial case when exp is an integer</span>

      <span class="s3">if </span><span class="s2">(P[</span><span class="s4">'d'</span><span class="s2">] === C_ONE) {</span>

        <span class="s3">if </span><span class="s2">(P[</span><span class="s4">'s'</span><span class="s2">] &lt; C_ZERO) {</span>
          <span class="s3">return </span><span class="s2">newFraction((</span><span class="s3">this</span><span class="s2">[</span><span class="s4">'s'</span><span class="s2">] * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">]) ** P[</span><span class="s4">'n'</span><span class="s2">], </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">] ** P[</span><span class="s4">'n'</span><span class="s2">]);</span>
        <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
          <span class="s3">return </span><span class="s2">newFraction((</span><span class="s3">this</span><span class="s2">[</span><span class="s4">'s'</span><span class="s2">] * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">]) ** P[</span><span class="s4">'n'</span><span class="s2">], </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">] ** P[</span><span class="s4">'n'</span><span class="s2">]);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>

      <span class="s0">// Negative roots become complex</span>
      <span class="s0">//     (-a/b)^(c/d) = x</span>
      <span class="s0">// &lt;=&gt; (-1)^(c/d) * (a/b)^(c/d) = x</span>
      <span class="s0">// &lt;=&gt; (cos(pi) + i*sin(pi))^(c/d) * (a/b)^(c/d) = x</span>
      <span class="s0">// &lt;=&gt; (cos(c*pi/d) + i*sin(c*pi/d)) * (a/b)^(c/d) = x       # DeMoivre's formula</span>
      <span class="s0">// From which follows that only for c=0 the root is non-complex</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">this</span><span class="s2">[</span><span class="s4">'s'</span><span class="s2">] &lt; C_ZERO) </span><span class="s3">return null</span><span class="s2">;</span>

      <span class="s0">// Now prime factor n and d</span>
      <span class="s3">let </span><span class="s2">N = factorize(</span><span class="s3">this</span><span class="s2">[</span><span class="s4">'n'</span><span class="s2">]);</span>
      <span class="s3">let </span><span class="s2">D = factorize(</span><span class="s3">this</span><span class="s2">[</span><span class="s4">'d'</span><span class="s2">]);</span>

      <span class="s0">// Exponentiate and take root for n and d individually</span>
      <span class="s3">let </span><span class="s2">n = C_ONE;</span>
      <span class="s3">let </span><span class="s2">d = C_ONE;</span>
      <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">k </span><span class="s3">in </span><span class="s2">N) {</span>
        <span class="s3">if </span><span class="s2">(k === </span><span class="s4">'1'</span><span class="s2">) </span><span class="s3">continue</span><span class="s2">;</span>
        <span class="s3">if </span><span class="s2">(k === </span><span class="s4">'0'</span><span class="s2">) {</span>
          <span class="s2">n = C_ZERO;</span>
          <span class="s3">break</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s2">N[k]*= P[</span><span class="s4">'n'</span><span class="s2">];</span>

        <span class="s3">if </span><span class="s2">(N[k] % P[</span><span class="s4">'d'</span><span class="s2">] === C_ZERO) {</span>
          <span class="s2">N[k]/= P[</span><span class="s4">'d'</span><span class="s2">];</span>
        <span class="s2">} </span><span class="s3">else return null</span><span class="s2">;</span>
        <span class="s2">n*= BigInt(k) ** N[k];</span>
      <span class="s2">}</span>

      <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">k </span><span class="s3">in </span><span class="s2">D) {</span>
        <span class="s3">if </span><span class="s2">(k === </span><span class="s4">'1'</span><span class="s2">) </span><span class="s3">continue</span><span class="s2">;</span>
        <span class="s2">D[k]*= P[</span><span class="s4">'n'</span><span class="s2">];</span>

        <span class="s3">if </span><span class="s2">(D[k] % P[</span><span class="s4">'d'</span><span class="s2">] === C_ZERO) {</span>
          <span class="s2">D[k]/= P[</span><span class="s4">'d'</span><span class="s2">];</span>
        <span class="s2">} </span><span class="s3">else return null</span><span class="s2">;</span>
        <span class="s2">d*= BigInt(k) ** D[k];</span>
      <span class="s2">}</span>

      <span class="s3">if </span><span class="s2">(P[</span><span class="s4">'s'</span><span class="s2">] &lt; C_ZERO) {</span>
        <span class="s3">return </span><span class="s2">newFraction(d, n);</span>
      <span class="s2">}</span>
      <span class="s3">return </span><span class="s2">newFraction(n, d);</span>
    <span class="s2">},</span>

    <span class="s0">/**</span>
     <span class="s0">* Check if two rational numbers are the same</span>
     <span class="s0">*</span>
     <span class="s0">* Ex: new Fraction(19.6).equals([98, 5]);</span>
     <span class="s0">**/</span>
    <span class="s4">&quot;equals&quot;</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(a, b) {</span>

      <span class="s2">parse(a, b);</span>
      <span class="s3">return this</span><span class="s2">[</span><span class="s4">&quot;s&quot;</span><span class="s2">] * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">] * P[</span><span class="s4">&quot;d&quot;</span><span class="s2">] === P[</span><span class="s4">&quot;s&quot;</span><span class="s2">] * P[</span><span class="s4">&quot;n&quot;</span><span class="s2">] * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">]; </span><span class="s0">// Same as compare() === 0</span>
    <span class="s2">},</span>

    <span class="s0">/**</span>
     <span class="s0">* Check if two rational numbers are the same</span>
     <span class="s0">*</span>
     <span class="s0">* Ex: new Fraction(19.6).equals([98, 5]);</span>
     <span class="s0">**/</span>
    <span class="s4">&quot;compare&quot;</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(a, b) {</span>

      <span class="s2">parse(a, b);</span>
      <span class="s3">let </span><span class="s2">t = (</span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;s&quot;</span><span class="s2">] * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">] * P[</span><span class="s4">&quot;d&quot;</span><span class="s2">] - P[</span><span class="s4">&quot;s&quot;</span><span class="s2">] * P[</span><span class="s4">&quot;n&quot;</span><span class="s2">] * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">]);</span>

      <span class="s3">return </span><span class="s2">(C_ZERO &lt; t) - (t &lt; C_ZERO);</span>
    <span class="s2">},</span>

    <span class="s0">/**</span>
     <span class="s0">* Calculates the ceil of a rational number</span>
     <span class="s0">*</span>
     <span class="s0">* Ex: new Fraction('4.(3)').ceil() =&gt; (5 / 1)</span>
     <span class="s0">**/</span>
    <span class="s4">&quot;ceil&quot;</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(places) {</span>

      <span class="s2">places = C_TEN ** BigInt(places || </span><span class="s5">0</span><span class="s2">);</span>

      <span class="s3">return </span><span class="s2">newFraction(</span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;s&quot;</span><span class="s2">] * places * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">] / </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">] +</span>
        <span class="s2">(places * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">] % </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">] &gt; C_ZERO &amp;&amp; </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;s&quot;</span><span class="s2">] &gt;= C_ZERO ? C_ONE : C_ZERO),</span>
        <span class="s2">places);</span>
    <span class="s2">},</span>

    <span class="s0">/**</span>
     <span class="s0">* Calculates the floor of a rational number</span>
     <span class="s0">*</span>
     <span class="s0">* Ex: new Fraction('4.(3)').floor() =&gt; (4 / 1)</span>
     <span class="s0">**/</span>
    <span class="s4">&quot;floor&quot;</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(places) {</span>

      <span class="s2">places = C_TEN ** BigInt(places || </span><span class="s5">0</span><span class="s2">);</span>

      <span class="s3">return </span><span class="s2">newFraction(</span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;s&quot;</span><span class="s2">] * places * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">] / </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">] -</span>
        <span class="s2">(places * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">] % </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">] &gt; C_ZERO &amp;&amp; </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;s&quot;</span><span class="s2">] &lt; C_ZERO ? C_ONE : C_ZERO),</span>
        <span class="s2">places);</span>
    <span class="s2">},</span>

    <span class="s0">/**</span>
     <span class="s0">* Rounds a rational numbers</span>
     <span class="s0">*</span>
     <span class="s0">* Ex: new Fraction('4.(3)').round() =&gt; (4 / 1)</span>
     <span class="s0">**/</span>
    <span class="s4">&quot;round&quot;</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(places) {</span>

      <span class="s2">places = C_TEN ** BigInt(places || </span><span class="s5">0</span><span class="s2">);</span>

      <span class="s0">/* Derivation: 
 
      s &gt;= 0: 
        round(n / d) = trunc(n / d) + (n % d) / d &gt;= 0.5 ? 1 : 0 
                     = trunc(n / d) + 2(n % d) &gt;= d ? 1 : 0 
      s &lt; 0: 
        round(n / d) =-trunc(n / d) - (n % d) / d &gt; 0.5 ? 1 : 0 
                     =-trunc(n / d) - 2(n % d) &gt; d ? 1 : 0 
 
      =&gt;: 
 
      round(s * n / d) = s * trunc(n / d) + s * (C + 2(n % d) &gt; d ? 1 : 0) 
          where C = s &gt;= 0 ? 1 : 0, to fix the &gt;= for the positve case. 
      */</span>

      <span class="s3">return </span><span class="s2">newFraction(</span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;s&quot;</span><span class="s2">] * places * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">] / </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">] +</span>
        <span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;s&quot;</span><span class="s2">] * ((</span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;s&quot;</span><span class="s2">] &gt;= C_ZERO ? C_ONE : C_ZERO) + C_TWO * (places * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">] % </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">]) &gt; </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">] ? C_ONE : C_ZERO),</span>
        <span class="s2">places);</span>
    <span class="s2">},</span>

    <span class="s0">/**</span>
     <span class="s0">* Check if two rational numbers are divisible</span>
     <span class="s0">*</span>
     <span class="s0">* Ex: new Fraction(19.6).divisible(1.5);</span>
     <span class="s0">*/</span>
    <span class="s4">&quot;divisible&quot;</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(a, b) {</span>

      <span class="s2">parse(a, b);</span>
      <span class="s3">return </span><span class="s2">!(!(P[</span><span class="s4">&quot;n&quot;</span><span class="s2">] * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">]) || ((</span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">] * P[</span><span class="s4">&quot;d&quot;</span><span class="s2">]) % (P[</span><span class="s4">&quot;n&quot;</span><span class="s2">] * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">])));</span>
    <span class="s2">},</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns a decimal representation of the fraction</span>
     <span class="s0">*</span>
     <span class="s0">* Ex: new Fraction(&quot;100.'91823'&quot;).valueOf() =&gt; 100.91823918239183</span>
     <span class="s0">**/</span>
    <span class="s4">'valueOf'</span><span class="s2">: </span><span class="s3">function</span><span class="s2">() {</span>
      <span class="s0">// Best we can do so far</span>
      <span class="s3">return </span><span class="s2">Number(</span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;s&quot;</span><span class="s2">] * </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">]) / Number(</span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">]);</span>
    <span class="s2">},</span>

    <span class="s0">/**</span>
     <span class="s0">* Creates a string representation of a fraction with all digits</span>
     <span class="s0">*</span>
     <span class="s0">* Ex: new Fraction(&quot;100.'91823'&quot;).toString() =&gt; &quot;100.(91823)&quot;</span>
     <span class="s0">**/</span>
    <span class="s4">'toString'</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(dec) {</span>

      <span class="s3">let </span><span class="s2">N = </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">];</span>
      <span class="s3">let </span><span class="s2">D = </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">];</span>

      <span class="s3">function </span><span class="s2">trunc(x) {</span>
          <span class="s3">return typeof </span><span class="s2">x === </span><span class="s4">'bigint' </span><span class="s2">? x : Math.floor(x);</span>
      <span class="s2">}</span>

      <span class="s2">dec = dec || </span><span class="s5">15</span><span class="s2">; </span><span class="s0">// 15 = decimal places when no repetition</span>

      <span class="s3">let </span><span class="s2">cycLen = cycleLen(N, D); </span><span class="s0">// Cycle length</span>
      <span class="s3">let </span><span class="s2">cycOff = cycleStart(N, D, cycLen); </span><span class="s0">// Cycle start</span>

      <span class="s3">let </span><span class="s2">str = </span><span class="s3">this</span><span class="s2">[</span><span class="s4">'s'</span><span class="s2">] &lt; C_ZERO ? </span><span class="s4">&quot;-&quot; </span><span class="s2">: </span><span class="s4">&quot;&quot;</span><span class="s2">;</span>

      <span class="s0">// Append integer part</span>
      <span class="s2">str+= trunc(N / D);</span>

      <span class="s2">N%= D;</span>
      <span class="s2">N*= C_TEN;</span>

      <span class="s3">if </span><span class="s2">(N)</span>
        <span class="s2">str+= </span><span class="s4">&quot;.&quot;</span><span class="s2">;</span>

      <span class="s3">if </span><span class="s2">(cycLen) {</span>

        <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = cycOff; i--;) {</span>
          <span class="s2">str+= trunc(N / D);</span>
          <span class="s2">N%= D;</span>
          <span class="s2">N*= C_TEN;</span>
        <span class="s2">}</span>
        <span class="s2">str+= </span><span class="s4">&quot;(&quot;</span><span class="s2">;</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = cycLen; i--;) {</span>
          <span class="s2">str+= trunc(N / D);</span>
          <span class="s2">N%= D;</span>
          <span class="s2">N*= C_TEN;</span>
        <span class="s2">}</span>
        <span class="s2">str+= </span><span class="s4">&quot;)&quot;</span><span class="s2">;</span>
      <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = dec; N &amp;&amp; i--;) {</span>
          <span class="s2">str+= trunc(N / D);</span>
          <span class="s2">N%= D;</span>
          <span class="s2">N*= C_TEN;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s3">return </span><span class="s2">str;</span>
    <span class="s2">},</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns a string-fraction representation of a Fraction object</span>
     <span class="s0">*</span>
     <span class="s0">* Ex: new Fraction(&quot;1.'3'&quot;).toFraction() =&gt; &quot;4 1/3&quot;</span>
     <span class="s0">**/</span>
    <span class="s4">'toFraction'</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(excludeWhole) {</span>

      <span class="s3">let </span><span class="s2">n = </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">];</span>
      <span class="s3">let </span><span class="s2">d = </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">];</span>
      <span class="s3">let </span><span class="s2">str = </span><span class="s3">this</span><span class="s2">[</span><span class="s4">'s'</span><span class="s2">] &lt; C_ZERO ? </span><span class="s4">&quot;-&quot; </span><span class="s2">: </span><span class="s4">&quot;&quot;</span><span class="s2">;</span>

      <span class="s3">if </span><span class="s2">(d === C_ONE) {</span>
        <span class="s2">str+= n;</span>
      <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
        <span class="s3">let </span><span class="s2">whole = n / d;</span>
        <span class="s3">if </span><span class="s2">(excludeWhole &amp;&amp; whole &gt; C_ZERO) {</span>
          <span class="s2">str+= whole;</span>
          <span class="s2">str+= </span><span class="s4">&quot; &quot;</span><span class="s2">;</span>
          <span class="s2">n%= d;</span>
        <span class="s2">}</span>

        <span class="s2">str+= n;</span>
        <span class="s2">str+= </span><span class="s4">'/'</span><span class="s2">;</span>
        <span class="s2">str+= d;</span>
      <span class="s2">}</span>
      <span class="s3">return </span><span class="s2">str;</span>
    <span class="s2">},</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns a latex representation of a Fraction object</span>
     <span class="s0">*</span>
     <span class="s0">* Ex: new Fraction(&quot;1.'3'&quot;).toLatex() =&gt; &quot;\frac{4}{3}&quot;</span>
     <span class="s0">**/</span>
    <span class="s4">'toLatex'</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(excludeWhole) {</span>

      <span class="s3">let </span><span class="s2">n = </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;n&quot;</span><span class="s2">];</span>
      <span class="s3">let </span><span class="s2">d = </span><span class="s3">this</span><span class="s2">[</span><span class="s4">&quot;d&quot;</span><span class="s2">];</span>
      <span class="s3">let </span><span class="s2">str = </span><span class="s3">this</span><span class="s2">[</span><span class="s4">'s'</span><span class="s2">] &lt; C_ZERO ? </span><span class="s4">&quot;-&quot; </span><span class="s2">: </span><span class="s4">&quot;&quot;</span><span class="s2">;</span>

      <span class="s3">if </span><span class="s2">(d === C_ONE) {</span>
        <span class="s2">str+= n;</span>
      <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
        <span class="s3">let </span><span class="s2">whole = n / d;</span>
        <span class="s3">if </span><span class="s2">(excludeWhole &amp;&amp; whole &gt; C_ZERO) {</span>
          <span class="s2">str+= whole;</span>
          <span class="s2">n%= d;</span>
        <span class="s2">}</span>

        <span class="s2">str+= </span><span class="s4">&quot;</span><span class="s7">\\</span><span class="s4">frac{&quot;</span><span class="s2">;</span>
        <span class="s2">str+= n;</span>
        <span class="s2">str+= </span><span class="s4">'}{'</span><span class="s2">;</span>
        <span class="s2">str+= d;</span>
        <span class="s2">str+= </span><span class="s4">'}'</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s3">return </span><span class="s2">str;</span>
    <span class="s2">},</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns an array of continued fraction elements</span>
     <span class="s0">*</span>
     <span class="s0">* Ex: new Fraction(&quot;7/8&quot;).toContinued() =&gt; [0,1,7]</span>
     <span class="s0">*/</span>
    <span class="s4">'toContinued'</span><span class="s2">: </span><span class="s3">function</span><span class="s2">() {</span>

      <span class="s3">let </span><span class="s2">a = </span><span class="s3">this</span><span class="s2">[</span><span class="s4">'n'</span><span class="s2">];</span>
      <span class="s3">let </span><span class="s2">b = </span><span class="s3">this</span><span class="s2">[</span><span class="s4">'d'</span><span class="s2">];</span>
      <span class="s3">let </span><span class="s2">res = [];</span>

      <span class="s3">do </span><span class="s2">{</span>
        <span class="s2">res.push(a / b);</span>
        <span class="s3">let </span><span class="s2">t = a % b;</span>
        <span class="s2">a = b;</span>
        <span class="s2">b = t;</span>
      <span class="s2">} </span><span class="s3">while </span><span class="s2">(a !== C_ONE);</span>

      <span class="s3">return </span><span class="s2">res;</span>
    <span class="s2">},</span>

    <span class="s4">&quot;simplify&quot;</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(eps) {</span>

      <span class="s2">eps = eps || </span><span class="s5">0.001</span><span class="s2">;</span>

      <span class="s3">const </span><span class="s2">thisABS = </span><span class="s3">this</span><span class="s2">[</span><span class="s4">'abs'</span><span class="s2">]();</span>
      <span class="s3">const </span><span class="s2">cont = thisABS[</span><span class="s4">'toContinued'</span><span class="s2">]();</span>

      <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = </span><span class="s5">1</span><span class="s2">; i &lt; cont.length; i++) {</span>

        <span class="s3">let </span><span class="s2">s = newFraction(cont[i - </span><span class="s5">1</span><span class="s2">], C_ONE);</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">k = i - </span><span class="s5">2</span><span class="s2">; k &gt;= </span><span class="s5">0</span><span class="s2">; k--) {</span>
          <span class="s2">s = s[</span><span class="s4">'inverse'</span><span class="s2">]()[</span><span class="s4">'add'</span><span class="s2">](cont[k]);</span>
        <span class="s2">}</span>

        <span class="s3">if </span><span class="s2">(Math.abs(s[</span><span class="s4">'sub'</span><span class="s2">](thisABS).valueOf()) &lt; eps) {</span>
          <span class="s3">return </span><span class="s2">s[</span><span class="s4">'mul'</span><span class="s2">](</span><span class="s3">this</span><span class="s2">[</span><span class="s4">'s'</span><span class="s2">]);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s3">return this</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s2">};</span>

  <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">define === </span><span class="s4">&quot;function&quot; </span><span class="s2">&amp;&amp; define[</span><span class="s4">&quot;amd&quot;</span><span class="s2">]) {</span>
    <span class="s2">define([], </span><span class="s3">function</span><span class="s2">() {</span>
      <span class="s3">return </span><span class="s2">Fraction;</span>
    <span class="s2">});</span>
  <span class="s2">} </span><span class="s3">else if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">exports === </span><span class="s4">&quot;object&quot;</span><span class="s2">) {</span>
    <span class="s2">Object.defineProperty(exports, </span><span class="s4">&quot;__esModule&quot;</span><span class="s2">, { </span><span class="s4">'value'</span><span class="s2">: </span><span class="s3">true </span><span class="s2">});</span>
    <span class="s2">Fraction[</span><span class="s4">'default'</span><span class="s2">] = Fraction;</span>
    <span class="s2">Fraction[</span><span class="s4">'Fraction'</span><span class="s2">] = Fraction;</span>
    <span class="s2">module[</span><span class="s4">'exports'</span><span class="s2">] = Fraction;</span>
  <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
    <span class="s2">root[</span><span class="s4">'Fraction'</span><span class="s2">] = Fraction;</span>
  <span class="s2">}</span>

<span class="s2">})(</span><span class="s3">this</span><span class="s2">);</span>
</pre>
</body>
</html>