<html>
<head>
<title>action-handler.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #264eff;}
.s6 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
action-handler.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">handleAction: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">parseHostHeader: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">handleAction: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">handleAction;</span>
    <span class="s1">},</span>
    <span class="s1">parseHostHeader: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">parseHostHeader;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_approuterheaders = require(</span><span class="s0">&quot;../../client/components/app-router-headers&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_httpaccessfallback = require(</span><span class="s0">&quot;../../client/components/http-access-fallback/http-access-fallback&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_redirect = require(</span><span class="s0">&quot;../../client/components/redirect&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_redirecterror = require(</span><span class="s0">&quot;../../client/components/redirect-error&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_renderresult = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;../render-result&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_flightrenderresult = require(</span><span class="s0">&quot;./flight-render-result&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils = require(</span><span class="s0">&quot;../lib/server-ipc/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_requestcookies = require(</span><span class="s0">&quot;../web/spec-extension/adapters/request-cookies&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants = require(</span><span class="s0">&quot;../../lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_serveractionrequestmeta = require(</span><span class="s0">&quot;../lib/server-action-request-meta&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_csrfprotection = require(</span><span class="s0">&quot;./csrf-protection&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_log = require(</span><span class="s0">&quot;../../build/output/log&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_cookies = require(</span><span class="s0">&quot;../web/spec-extension/cookies&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_headers = require(</span><span class="s0">&quot;../web/spec-extension/adapters/headers&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils1 = require(</span><span class="s0">&quot;../web/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_actionutils = require(</span><span class="s0">&quot;./action-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_helpers = require(</span><span class="s0">&quot;../base-http/helpers&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_redirectstatuscode = require(</span><span class="s0">&quot;../../client/components/redirect-status-code&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_requeststore = require(</span><span class="s0">&quot;../async-storage/request-store&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_workunitasyncstorageexternal = require(</span><span class="s0">&quot;../app-render/work-unit-async-storage.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_invarianterror = require(</span><span class="s0">&quot;../../shared/lib/invariant-error&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_revalidationutils = require(</span><span class="s0">&quot;../revalidation-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_requestmeta = require(</span><span class="s0">&quot;../request-meta&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_setcachebustingsearchparam = require(</span><span class="s0">&quot;../../client/components/router-reducer/set-cache-busting-search-param&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">formDataFromSearchQueryString(query) {</span>
    <span class="s2">const </span><span class="s1">searchParams = </span><span class="s2">new </span><span class="s1">URLSearchParams(query);</span>
    <span class="s2">const </span><span class="s1">formData = </span><span class="s2">new </span><span class="s1">FormData();</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[key, value] of searchParams){</span>
        <span class="s1">formData.append(key, value);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">formData;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">nodeHeadersToRecord(headers) {</span>
    <span class="s2">const </span><span class="s1">record = {};</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[key, value] of Object.entries(headers)){</span>
        <span class="s2">if </span><span class="s1">(value !== undefined) {</span>
            <span class="s1">record[key] = Array.isArray(value) ? value.join(</span><span class="s0">', '</span><span class="s1">) : </span><span class="s0">`</span><span class="s1">${value}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">record;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getForwardedHeaders(req, res) {</span>
    <span class="s4">// Get request headers and cookies</span>
    <span class="s2">const </span><span class="s1">requestHeaders = req.headers;</span>
    <span class="s2">const </span><span class="s1">requestCookies = </span><span class="s2">new </span><span class="s1">_cookies.RequestCookies(_headers.HeadersAdapter.from(requestHeaders));</span>
    <span class="s4">// Get response headers and cookies</span>
    <span class="s2">const </span><span class="s1">responseHeaders = res.getHeaders();</span>
    <span class="s2">const </span><span class="s1">responseCookies = </span><span class="s2">new </span><span class="s1">_cookies.ResponseCookies((</span><span class="s3">0</span><span class="s1">, _utils1.fromNodeOutgoingHttpHeaders)(responseHeaders));</span>
    <span class="s4">// Merge request and response headers</span>
    <span class="s2">const </span><span class="s1">mergedHeaders = (</span><span class="s3">0</span><span class="s1">, _utils.filterReqHeaders)({</span>
        <span class="s1">...nodeHeadersToRecord(requestHeaders),</span>
        <span class="s1">...nodeHeadersToRecord(responseHeaders)</span>
    <span class="s1">}, _utils.actionsForbiddenHeaders);</span>
    <span class="s4">// Merge cookies into requestCookies, so responseCookies always take precedence</span>
    <span class="s4">// and overwrite/delete those from requestCookies.</span>
    <span class="s1">responseCookies.getAll().forEach((cookie)=&gt;{</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">cookie.value === </span><span class="s0">'undefined'</span><span class="s1">) {</span>
            <span class="s1">requestCookies.delete(cookie.name);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">requestCookies.set(cookie);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s4">// Update the 'cookie' header with the merged cookies</span>
    <span class="s1">mergedHeaders[</span><span class="s0">'cookie'</span><span class="s1">] = requestCookies.toString();</span>
    <span class="s4">// Remove headers that should not be forwarded</span>
    <span class="s2">delete </span><span class="s1">mergedHeaders[</span><span class="s0">'transfer-encoding'</span><span class="s1">];</span>
    <span class="s2">return new </span><span class="s1">Headers(mergedHeaders);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">addRevalidationHeader(res, { workStore, requestStore }) {</span>
    <span class="s2">var </span><span class="s1">_workStore_pendingRevalidatedTags;</span>
    <span class="s4">// If a tag was revalidated, the client router needs to invalidate all the</span>
    <span class="s4">// client router cache as they may be stale. And if a path was revalidated, the</span>
    <span class="s4">// client needs to invalidate all subtrees below that path.</span>
    <span class="s4">// To keep the header size small, we use a tuple of</span>
    <span class="s4">// [[revalidatedPaths], isTagRevalidated ? 1 : 0, isCookieRevalidated ? 1 : 0]</span>
    <span class="s4">// instead of a JSON object.</span>
    <span class="s4">// TODO-APP: Currently the prefetch cache doesn't have subtree information,</span>
    <span class="s4">// so we need to invalidate the entire cache if a path was revalidated.</span>
    <span class="s4">// TODO-APP: Currently paths are treated as tags, so the second element of the tuple</span>
    <span class="s4">// is always empty.</span>
    <span class="s2">const </span><span class="s1">isTagRevalidated = ((_workStore_pendingRevalidatedTags = workStore.pendingRevalidatedTags) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _workStore_pendingRevalidatedTags.length) ? </span><span class="s3">1 </span><span class="s1">: </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">isCookieRevalidated = (</span><span class="s3">0</span><span class="s1">, _requestcookies.getModifiedCookieValues)(requestStore.mutableCookies).length ? </span><span class="s3">1 </span><span class="s1">: </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">res.setHeader(</span><span class="s0">'x-action-revalidated'</span><span class="s1">, JSON.stringify([</span>
        <span class="s1">[],</span>
        <span class="s1">isTagRevalidated,</span>
        <span class="s1">isCookieRevalidated</span>
    <span class="s1">]));</span>
<span class="s1">}</span>
<span class="s4">/**</span>
 <span class="s4">* Forwards a server action request to a separate worker. Used when the requested action is not available in the current worker.</span>
 <span class="s4">*/ </span><span class="s1">async </span><span class="s2">function </span><span class="s1">createForwardedActionResponse(req, res, host, workerPathname, basePath) {</span>
    <span class="s2">var </span><span class="s1">_getRequestMeta;</span>
    <span class="s2">if </span><span class="s1">(!host) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Invariant: Missing `host` header from a forwarded Server Actions request.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E226&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">forwardedHeaders = getForwardedHeaders(req, res);</span>
    <span class="s4">// indicate that this action request was forwarded from another worker</span>
    <span class="s4">// we use this to skip rendering the flight tree so that we don't update the UI</span>
    <span class="s4">// with the response from the forwarded worker</span>
    <span class="s1">forwardedHeaders.set(</span><span class="s0">'x-action-forwarded'</span><span class="s1">, </span><span class="s0">'1'</span><span class="s1">);</span>
    <span class="s2">const </span><span class="s1">proto = ((_getRequestMeta = (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'initProtocol'</span><span class="s1">)) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _getRequestMeta.replace(</span><span class="s5">/:+$/</span><span class="s1">, </span><span class="s0">''</span><span class="s1">)) || </span><span class="s0">'https'</span><span class="s1">;</span>
    <span class="s4">// For standalone or the serverful mode, use the internal origin directly</span>
    <span class="s4">// other than the host headers from the request.</span>
    <span class="s2">const </span><span class="s1">origin = process.env.__NEXT_PRIVATE_ORIGIN || </span><span class="s0">`</span><span class="s1">${proto}</span><span class="s0">://</span><span class="s1">${host.value}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">fetchUrl = </span><span class="s2">new </span><span class="s1">URL(</span><span class="s0">`</span><span class="s1">${origin}${basePath}${workerPathname}</span><span class="s0">`</span><span class="s1">);</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">_response_headers_get;</span>
        <span class="s2">let </span><span class="s1">body;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s4">// The type check here ensures that `req` is correctly typed, and the</span>
        <span class="s4">// environment variable check provides dead code elimination.</span>
        <span class="s1">process.env.NEXT_RUNTIME === </span><span class="s0">'edge' </span><span class="s1">&amp;&amp; (</span><span class="s3">0</span><span class="s1">, _helpers.isWebNextRequest)(req)) {</span>
            <span class="s2">if </span><span class="s1">(!req.body) {</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Invariant: missing request body.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E333&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s1">body = req.body;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s4">// The type check here ensures that `req` is correctly typed, and the</span>
        <span class="s4">// environment variable check provides dead code elimination.</span>
        <span class="s1">process.env.NEXT_RUNTIME !== </span><span class="s0">'edge' </span><span class="s1">&amp;&amp; (</span><span class="s3">0</span><span class="s1">, _helpers.isNodeNextRequest)(req)) {</span>
            <span class="s1">body = req.stream();</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Invariant: Unknown request type.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E114&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s4">// Forward the request to the new worker</span>
        <span class="s2">const </span><span class="s1">response = </span><span class="s2">await </span><span class="s1">fetch(fetchUrl, {</span>
            <span class="s1">method: </span><span class="s0">'POST'</span><span class="s1">,</span>
            <span class="s1">body,</span>
            <span class="s1">duplex: </span><span class="s0">'half'</span><span class="s1">,</span>
            <span class="s1">headers: forwardedHeaders,</span>
            <span class="s1">redirect: </span><span class="s0">'manual'</span><span class="s1">,</span>
            <span class="s1">next: {</span>
                <span class="s4">// @ts-ignore</span>
                <span class="s1">internal: </span><span class="s3">1</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s2">if </span><span class="s1">((_response_headers_get = response.headers.get(</span><span class="s0">'content-type'</span><span class="s1">)) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _response_headers_get.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER)) {</span>
            <span class="s4">// copy the headers from the redirect response to the response we're sending</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[key, value] of response.headers){</span>
                <span class="s2">if </span><span class="s1">(!_utils.actionsForbiddenHeaders.includes(key)) {</span>
                    <span class="s1">res.setHeader(key, value);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return new </span><span class="s1">_flightrenderresult.FlightRenderResult(response.body);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">var </span><span class="s4">// Since we aren't consuming the response body, we cancel it to avoid memory leaks</span>
            <span class="s1">_response_body;</span>
            <span class="s1">(_response_body = response.body) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _response_body.cancel();</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
        <span class="s4">// we couldn't stream the forwarded response, so we'll just return an empty response</span>
        <span class="s1">console.error(</span><span class="s0">`failed to forward action response`</span><span class="s1">, err);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">_renderresult.default.fromStatic(</span><span class="s0">'{}'</span><span class="s1">, _constants.JSON_CONTENT_TYPE_HEADER);</span>
<span class="s1">}</span>
<span class="s4">/**</span>
 <span class="s4">* Returns the parsed redirect URL if we deem that it is hosted by us.</span>
 <span class="s4">*</span>
 <span class="s4">* We handle both relative and absolute redirect URLs.</span>
 <span class="s4">*</span>
 <span class="s4">* In case the redirect URL is not relative to the application we return `null`.</span>
 <span class="s4">*/ </span><span class="s2">function </span><span class="s1">getAppRelativeRedirectUrl(basePath, host, redirectUrl) {</span>
    <span class="s2">if </span><span class="s1">(redirectUrl.startsWith(</span><span class="s0">'/'</span><span class="s1">) || redirectUrl.startsWith(</span><span class="s0">'.'</span><span class="s1">)) {</span>
        <span class="s4">// Make sure we are appending the basePath to relative URLS</span>
        <span class="s2">return new </span><span class="s1">URL(</span><span class="s0">`</span><span class="s1">${basePath}${redirectUrl}</span><span class="s0">`</span><span class="s1">, </span><span class="s0">'http://n'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">parsedRedirectUrl = </span><span class="s2">new </span><span class="s1">URL(redirectUrl);</span>
    <span class="s2">if </span><span class="s1">((host == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: host.value) !== parsedRedirectUrl.host) {</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">// At this point the hosts are the same, just confirm we</span>
    <span class="s4">// are routing to a path underneath the `basePath`</span>
    <span class="s2">return </span><span class="s1">parsedRedirectUrl.pathname.startsWith(basePath) ? parsedRedirectUrl : </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">createRedirectRenderResult(req, res, originalHost, redirectUrl, redirectType, basePath, workStore) {</span>
    <span class="s1">res.setHeader(</span><span class="s0">'x-action-redirect'</span><span class="s1">, </span><span class="s0">`</span><span class="s1">${redirectUrl}</span><span class="s0">;</span><span class="s1">${redirectType}</span><span class="s0">`</span><span class="s1">);</span>
    <span class="s4">// If we're redirecting to another route of this Next.js application, we'll</span>
    <span class="s4">// try to stream the response from the other worker path. When that works,</span>
    <span class="s4">// we can save an extra roundtrip and avoid a full page reload.</span>
    <span class="s4">// When the redirect URL starts with a `/` or is to the same host, under the</span>
    <span class="s4">// `basePath` we treat it as an app-relative redirect;</span>
    <span class="s2">const </span><span class="s1">appRelativeRedirectUrl = getAppRelativeRedirectUrl(basePath, originalHost, redirectUrl);</span>
    <span class="s2">if </span><span class="s1">(appRelativeRedirectUrl) {</span>
        <span class="s2">var </span><span class="s1">_getRequestMeta;</span>
        <span class="s2">if </span><span class="s1">(!originalHost) {</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Invariant: Missing `host` header from a forwarded Server Actions request.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E226&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">forwardedHeaders = getForwardedHeaders(req, res);</span>
        <span class="s1">forwardedHeaders.set(_approuterheaders.RSC_HEADER, </span><span class="s0">'1'</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">proto = ((_getRequestMeta = (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'initProtocol'</span><span class="s1">)) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _getRequestMeta.replace(</span><span class="s5">/:+$/</span><span class="s1">, </span><span class="s0">''</span><span class="s1">)) || </span><span class="s0">'https'</span><span class="s1">;</span>
        <span class="s4">// For standalone or the serverful mode, use the internal origin directly</span>
        <span class="s4">// other than the host headers from the request.</span>
        <span class="s2">const </span><span class="s1">origin = process.env.__NEXT_PRIVATE_ORIGIN || </span><span class="s0">`</span><span class="s1">${proto}</span><span class="s0">://</span><span class="s1">${originalHost.value}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">fetchUrl = </span><span class="s2">new </span><span class="s1">URL(</span><span class="s0">`</span><span class="s1">${origin}${appRelativeRedirectUrl.pathname}${appRelativeRedirectUrl.search}</span><span class="s0">`</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(workStore.pendingRevalidatedTags) {</span>
            <span class="s2">var </span><span class="s1">_workStore_incrementalCache_prerenderManifest_preview, _workStore_incrementalCache_prerenderManifest, _workStore_incrementalCache;</span>
            <span class="s1">forwardedHeaders.set(_constants.NEXT_CACHE_REVALIDATED_TAGS_HEADER, workStore.pendingRevalidatedTags.join(</span><span class="s0">','</span><span class="s1">));</span>
            <span class="s1">forwardedHeaders.set(_constants.NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER, ((_workStore_incrementalCache = workStore.incrementalCache) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_workStore_incrementalCache_prerenderManifest = _workStore_incrementalCache.prerenderManifest) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_workStore_incrementalCache_prerenderManifest_preview = _workStore_incrementalCache_prerenderManifest.preview) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _workStore_incrementalCache_prerenderManifest_preview.previewModeId) || </span><span class="s0">''</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s4">// Ensures that when the path was revalidated we don't return a partial response on redirects</span>
        <span class="s1">forwardedHeaders.delete(_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER);</span>
        <span class="s4">// When an action follows a redirect, it's no longer handling an action: it's just a normal RSC request</span>
        <span class="s4">// to the requested URL. We should remove the `next-action` header so that it's not treated as an action</span>
        <span class="s1">forwardedHeaders.delete(_approuterheaders.ACTION_HEADER);</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">var </span><span class="s1">_response_headers_get;</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _setcachebustingsearchparam.setCacheBustingSearchParam)(fetchUrl, {</span>
                <span class="s1">[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER]: forwardedHeaders.get(_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER) ? </span><span class="s0">'1' </span><span class="s1">: undefined,</span>
                <span class="s1">[_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: forwardedHeaders.get(_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER) ?? undefined,</span>
                <span class="s1">[_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: forwardedHeaders.get(_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER) ?? undefined,</span>
                <span class="s1">[_approuterheaders.NEXT_URL]: forwardedHeaders.get(_approuterheaders.NEXT_URL) ?? undefined</span>
            <span class="s1">});</span>
            <span class="s2">const </span><span class="s1">response = </span><span class="s2">await </span><span class="s1">fetch(fetchUrl, {</span>
                <span class="s1">method: </span><span class="s0">'GET'</span><span class="s1">,</span>
                <span class="s1">headers: forwardedHeaders,</span>
                <span class="s1">next: {</span>
                    <span class="s4">// @ts-ignore</span>
                    <span class="s1">internal: </span><span class="s3">1</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s2">if </span><span class="s1">((_response_headers_get = response.headers.get(</span><span class="s0">'content-type'</span><span class="s1">)) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _response_headers_get.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER)) {</span>
                <span class="s4">// copy the headers from the redirect response to the response we're sending</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[key, value] of response.headers){</span>
                    <span class="s2">if </span><span class="s1">(!_utils.actionsForbiddenHeaders.includes(key)) {</span>
                        <span class="s1">res.setHeader(key, value);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">return new </span><span class="s1">_flightrenderresult.FlightRenderResult(response.body);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">var </span><span class="s4">// Since we aren't consuming the response body, we cancel it to avoid memory leaks</span>
                <span class="s1">_response_body;</span>
                <span class="s1">(_response_body = response.body) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _response_body.cancel();</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
            <span class="s4">// we couldn't stream the redirect response, so we'll just do a normal redirect</span>
            <span class="s1">console.error(</span><span class="s0">`failed to get redirect response`</span><span class="s1">, err);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">_renderresult.default.EMPTY;</span>
<span class="s1">}</span>
<span class="s4">/**</span>
 <span class="s4">* Ensures the value of the header can't create long logs.</span>
 <span class="s4">*/ </span><span class="s2">function </span><span class="s1">limitUntrustedHeaderValueForLogs(value) {</span>
    <span class="s2">return </span><span class="s1">value.length &gt; </span><span class="s3">100 </span><span class="s1">? value.slice(</span><span class="s3">0</span><span class="s1">, </span><span class="s3">100</span><span class="s1">) + </span><span class="s0">'...' </span><span class="s1">: value;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">parseHostHeader(headers, originDomain) {</span>
    <span class="s2">var </span><span class="s1">_forwardedHostHeader_split_, _forwardedHostHeader_split;</span>
    <span class="s2">const </span><span class="s1">forwardedHostHeader = headers[</span><span class="s0">'x-forwarded-host'</span><span class="s1">];</span>
    <span class="s2">const </span><span class="s1">forwardedHostHeaderValue = forwardedHostHeader &amp;&amp; Array.isArray(forwardedHostHeader) ? forwardedHostHeader[</span><span class="s3">0</span><span class="s1">] : forwardedHostHeader == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_forwardedHostHeader_split = forwardedHostHeader.split(</span><span class="s0">','</span><span class="s1">)) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_forwardedHostHeader_split_ = _forwardedHostHeader_split[</span><span class="s3">0</span><span class="s1">]) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _forwardedHostHeader_split_.trim();</span>
    <span class="s2">const </span><span class="s1">hostHeader = headers[</span><span class="s0">'host'</span><span class="s1">];</span>
    <span class="s2">if </span><span class="s1">(originDomain) {</span>
        <span class="s2">return </span><span class="s1">forwardedHostHeaderValue === originDomain ? {</span>
            <span class="s1">type: </span><span class="s0">&quot;x-forwarded-host&quot;</span><span class="s1">,</span>
            <span class="s1">value: forwardedHostHeaderValue</span>
        <span class="s1">} : hostHeader === originDomain ? {</span>
            <span class="s1">type: </span><span class="s0">&quot;host&quot;</span><span class="s1">,</span>
            <span class="s1">value: hostHeader</span>
        <span class="s1">} : undefined;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">forwardedHostHeaderValue ? {</span>
        <span class="s1">type: </span><span class="s0">&quot;x-forwarded-host&quot;</span><span class="s1">,</span>
        <span class="s1">value: forwardedHostHeaderValue</span>
    <span class="s1">} : hostHeader ? {</span>
        <span class="s1">type: </span><span class="s0">&quot;host&quot;</span><span class="s1">,</span>
        <span class="s1">value: hostHeader</span>
    <span class="s1">} : undefined;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">handleAction({ req, res, ComponentMod, serverModuleMap, generateFlight, workStore, requestStore, serverActions, ctx, metadata }) {</span>
    <span class="s2">const </span><span class="s1">contentType = req.headers[</span><span class="s0">'content-type'</span><span class="s1">];</span>
    <span class="s2">const </span><span class="s1">{ serverActionsManifest, page } = ctx.renderOpts;</span>
    <span class="s2">const </span><span class="s1">{ actionId, isURLEncodedAction, isMultipartAction, isFetchAction, isPossibleServerAction } = (</span><span class="s3">0</span><span class="s1">, _serveractionrequestmeta.getServerActionRequestMetadata)(req);</span>
    <span class="s4">// If it can't be a Server Action, skip handling.</span>
    <span class="s4">// Note that this can be a false positive -- any multipart/urlencoded POST can get us here,</span>
    <span class="s4">// But won't know if it's an MPA action or not until we call `decodeAction` below.</span>
    <span class="s2">if </span><span class="s1">(!isPossibleServerAction) {</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(workStore.isStaticGeneration) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">&quot;Invariant: server actions can't be handled during static rendering&quot;</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E359&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">temporaryReferences;</span>
    <span class="s4">// When running actions the default is no-store, you can still `cache: 'force-cache'`</span>
    <span class="s1">workStore.fetchCache = </span><span class="s0">'default-no-store'</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">originDomain = </span><span class="s2">typeof </span><span class="s1">req.headers[</span><span class="s0">'origin'</span><span class="s1">] === </span><span class="s0">'string' </span><span class="s1">? </span><span class="s2">new </span><span class="s1">URL(req.headers[</span><span class="s0">'origin'</span><span class="s1">]).host : undefined;</span>
    <span class="s2">const </span><span class="s1">host = parseHostHeader(req.headers);</span>
    <span class="s2">let </span><span class="s1">warning = undefined;</span>
    <span class="s2">function </span><span class="s1">warnBadServerActionRequest() {</span>
        <span class="s2">if </span><span class="s1">(warning) {</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _log.warn)(warning);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">// This is to prevent CSRF attacks. If `x-forwarded-host` is set, we need to</span>
    <span class="s4">// ensure that the request is coming from the same host.</span>
    <span class="s2">if </span><span class="s1">(!originDomain) {</span>
        <span class="s4">// This might be an old browser that doesn't send `host` header. We ignore</span>
        <span class="s4">// this case.</span>
        <span class="s1">warning = </span><span class="s0">'Missing `origin` header from a forwarded Server Actions request.'</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!host || originDomain !== host.value) {</span>
        <span class="s4">// If the customer sets a list of allowed origins, we'll allow the request.</span>
        <span class="s4">// These are considered safe but might be different from forwarded host set</span>
        <span class="s4">// by the infra (i.e. reverse proxies).</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _csrfprotection.isCsrfOriginAllowed)(originDomain, serverActions == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: serverActions.allowedOrigins)) {</span>
        <span class="s4">// Ignore it</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(host) {</span>
                <span class="s4">// This seems to be an CSRF attack. We should not proceed the action.</span>
                <span class="s1">console.error(</span><span class="s0">`</span><span class="s6">\`</span><span class="s1">${host.type}</span><span class="s6">\` </span><span class="s0">header with value </span><span class="s6">\`</span><span class="s1">${limitUntrustedHeaderValueForLogs(host.value)}</span><span class="s6">\` </span><span class="s0">does not match </span><span class="s6">\`</span><span class="s0">origin</span><span class="s6">\` </span><span class="s0">header with value </span><span class="s6">\`</span><span class="s1">${limitUntrustedHeaderValueForLogs(originDomain)}</span><span class="s6">\` </span><span class="s0">from a forwarded Server Actions request. Aborting the action.`</span><span class="s1">);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s4">// This is an attack. We should not proceed the action.</span>
                <span class="s1">console.error(</span><span class="s0">`</span><span class="s6">\`</span><span class="s0">x-forwarded-host</span><span class="s6">\` </span><span class="s0">or </span><span class="s6">\`</span><span class="s0">host</span><span class="s6">\` </span><span class="s0">headers are not provided. One of these is needed to compare the </span><span class="s6">\`</span><span class="s0">origin</span><span class="s6">\` </span><span class="s0">header from a forwarded Server Actions request. Aborting the action.`</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">error = Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Invalid Server Actions request.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E80&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
            <span class="s2">if </span><span class="s1">(isFetchAction) {</span>
                <span class="s1">res.statusCode = </span><span class="s3">500</span><span class="s1">;</span>
                <span class="s1">metadata.statusCode = </span><span class="s3">500</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">promise = Promise.reject(error);</span>
                <span class="s2">try </span><span class="s1">{</span>
                    <span class="s4">// we need to await the promise to trigger the rejection early</span>
                    <span class="s4">// so that it's already handled by the time we call</span>
                    <span class="s4">// the RSC runtime. Otherwise, it will throw an unhandled</span>
                    <span class="s4">// promise rejection error in the renderer.</span>
                    <span class="s2">await </span><span class="s1">promise;</span>
                <span class="s1">} </span><span class="s2">catch  </span><span class="s1">{</span>
                <span class="s4">// swallow error, it's gonna be handled on the client</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">type: </span><span class="s0">'done'</span><span class="s1">,</span>
                    <span class="s1">result: </span><span class="s2">await </span><span class="s1">generateFlight(req, ctx, requestStore, {</span>
                        <span class="s1">actionResult: promise,</span>
                        <span class="s4">// We didn't execute an action, so no revalidations could have occurred. We can skip rendering the page.</span>
                        <span class="s1">skipFlight: </span><span class="s2">true</span><span class="s1">,</span>
                        <span class="s1">temporaryReferences</span>
                    <span class="s1">})</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s2">throw </span><span class="s1">error;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">// ensure we avoid caching server actions unexpectedly</span>
    <span class="s1">res.setHeader(</span><span class="s0">'Cache-Control'</span><span class="s1">, </span><span class="s0">'no-cache, no-store, max-age=0, must-revalidate'</span><span class="s1">);</span>
    <span class="s2">const </span><span class="s1">{ actionAsyncStorage } = ComponentMod;</span>
    <span class="s2">const </span><span class="s1">actionWasForwarded = Boolean(req.headers[</span><span class="s0">'x-action-forwarded'</span><span class="s1">]);</span>
    <span class="s2">if </span><span class="s1">(actionId) {</span>
        <span class="s2">const </span><span class="s1">forwardedWorker = (</span><span class="s3">0</span><span class="s1">, _actionutils.selectWorkerForForwarding)(actionId, page, serverActionsManifest);</span>
        <span class="s4">// If forwardedWorker is truthy, it means there isn't a worker for the action</span>
        <span class="s4">// in the current handler, so we forward the request to a worker that has the action.</span>
        <span class="s2">if </span><span class="s1">(forwardedWorker) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">type: </span><span class="s0">'done'</span><span class="s1">,</span>
                <span class="s1">result: </span><span class="s2">await </span><span class="s1">createForwardedActionResponse(req, res, host, forwardedWorker, ctx.renderOpts.basePath)</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">handleUnrecognizedFetchAction = (err)=&gt;{</span>
        <span class="s4">// If the deployment doesn't have skew protection, this is expected to occasionally happen,</span>
        <span class="s4">// so we use a warning instead of an error.</span>
        <span class="s1">console.warn(err);</span>
        <span class="s4">// Return an empty response with a header that the client router will interpret.</span>
        <span class="s4">// We don't need to waste time encoding a flight response, and using a blank body + header</span>
        <span class="s4">// means that unrecognized actions can also be handled at the infra level</span>
        <span class="s4">// (i.e. without needing to invoke a lambda)</span>
        <span class="s1">res.setHeader(_approuterheaders.NEXT_ACTION_NOT_FOUND_HEADER, </span><span class="s0">'1'</span><span class="s1">);</span>
        <span class="s1">res.setHeader(</span><span class="s0">'content-type'</span><span class="s1">, </span><span class="s0">'text/plain'</span><span class="s1">);</span>
        <span class="s1">res.statusCode = </span><span class="s3">404</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">type: </span><span class="s0">'done'</span><span class="s1">,</span>
            <span class="s1">result: _renderresult.default.fromStatic(</span><span class="s0">'Server action not found.'</span><span class="s1">, </span><span class="s0">'text/plain'</span><span class="s1">)</span>
        <span class="s1">};</span>
    <span class="s1">};</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">return await </span><span class="s1">actionAsyncStorage.run({</span>
            <span class="s1">isAction: </span><span class="s2">true</span>
        <span class="s1">}, async ()=&gt;{</span>
            <span class="s4">// We only use these for fetch actions -- MPA actions handle them inside `decodeAction`.</span>
            <span class="s2">let </span><span class="s1">actionModId;</span>
            <span class="s2">let </span><span class="s1">boundActionArguments = [];</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s4">// The type check here ensures that `req` is correctly typed, and the</span>
            <span class="s4">// environment variable check provides dead code elimination.</span>
            <span class="s1">process.env.NEXT_RUNTIME === </span><span class="s0">'edge' </span><span class="s1">&amp;&amp; (</span><span class="s3">0</span><span class="s1">, _helpers.isWebNextRequest)(req)) {</span>
                <span class="s2">if </span><span class="s1">(!req.body) {</span>
                    <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'invariant: Missing request body.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E364&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s4">// TODO: add body limit</span>
                <span class="s4">// Use react-server-dom-webpack/server</span>
                <span class="s2">const </span><span class="s1">{ createTemporaryReferenceSet, decodeReply, decodeAction, decodeFormState } = ComponentMod;</span>
                <span class="s1">temporaryReferences = createTemporaryReferenceSet();</span>
                <span class="s2">if </span><span class="s1">(isMultipartAction) {</span>
                    <span class="s4">// TODO-APP: Add streaming support</span>
                    <span class="s2">const </span><span class="s1">formData = </span><span class="s2">await </span><span class="s1">req.request.formData();</span>
                    <span class="s2">if </span><span class="s1">(isFetchAction) {</span>
                        <span class="s4">// A fetch action with a multipart body.</span>
                        <span class="s1">boundActionArguments = </span><span class="s2">await </span><span class="s1">decodeReply(formData, serverModuleMap, {</span>
                            <span class="s1">temporaryReferences</span>
                        <span class="s1">});</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s4">// Multipart POST, but not a fetch action.</span>
                        <span class="s4">// Potentially an MPA action, we have to try decoding it to check.</span>
                        <span class="s2">const </span><span class="s1">action = </span><span class="s2">await </span><span class="s1">decodeAction(formData, serverModuleMap);</span>
                        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">action === </span><span class="s0">'function'</span><span class="s1">) {</span>
                            <span class="s4">// an MPA action.</span>
                            <span class="s4">// Only warn if it's a server action, otherwise skip for other post requests</span>
                            <span class="s1">warnBadServerActionRequest();</span>
                            <span class="s2">const </span><span class="s1">actionReturnedState = </span><span class="s2">await </span><span class="s1">executeActionAndPrepareForRender(action, [], workStore, requestStore);</span>
                            <span class="s2">const </span><span class="s1">formState = </span><span class="s2">await </span><span class="s1">decodeFormState(actionReturnedState, formData, serverModuleMap);</span>
                            <span class="s4">// Skip the fetch path.</span>
                            <span class="s4">// We need to render a full HTML version of the page for the response, we'll handle that in app-render.</span>
                            <span class="s2">return </span><span class="s1">{</span>
                                <span class="s1">type: </span><span class="s0">'done'</span><span class="s1">,</span>
                                <span class="s1">result: undefined,</span>
                                <span class="s1">formState</span>
                            <span class="s1">};</span>
                        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                            <span class="s4">// We couldn't decode an action, so this POST request turned out not to be a server action request.</span>
                            <span class="s2">return null</span><span class="s1">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s4">// POST with non-multipart body.</span>
                    <span class="s4">// If it's not multipart AND not a fetch action,</span>
                    <span class="s4">// then it can't be an action request.</span>
                    <span class="s2">if </span><span class="s1">(!isFetchAction) {</span>
                        <span class="s2">return null</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">try </span><span class="s1">{</span>
                        <span class="s1">actionModId = getActionModIdOrError(actionId, serverModuleMap);</span>
                    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
                        <span class="s2">return </span><span class="s1">handleUnrecognizedFetchAction(err);</span>
                    <span class="s1">}</span>
                    <span class="s4">// A fetch action with a non-multipart body.</span>
                    <span class="s4">// In practice, this happens if `encodeReply` returned a string instead of FormData,</span>
                    <span class="s4">// which can happen for very simple JSON-like values that don't need multiple flight rows.</span>
                    <span class="s2">const </span><span class="s1">chunks = [];</span>
                    <span class="s2">const </span><span class="s1">reader = req.body.getReader();</span>
                    <span class="s2">while</span><span class="s1">(</span><span class="s2">true</span><span class="s1">){</span>
                        <span class="s2">const </span><span class="s1">{ done, value } = </span><span class="s2">await </span><span class="s1">reader.read();</span>
                        <span class="s2">if </span><span class="s1">(done) {</span>
                            <span class="s2">break</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s1">chunks.push(value);</span>
                    <span class="s1">}</span>
                    <span class="s2">const </span><span class="s1">actionData = Buffer.concat(chunks).toString(</span><span class="s0">'utf-8'</span><span class="s1">);</span>
                    <span class="s2">if </span><span class="s1">(isURLEncodedAction) {</span>
                        <span class="s2">const </span><span class="s1">formData = formDataFromSearchQueryString(actionData);</span>
                        <span class="s1">boundActionArguments = </span><span class="s2">await </span><span class="s1">decodeReply(formData, serverModuleMap, {</span>
                            <span class="s1">temporaryReferences</span>
                        <span class="s1">});</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">boundActionArguments = </span><span class="s2">await </span><span class="s1">decodeReply(actionData, serverModuleMap, {</span>
                            <span class="s1">temporaryReferences</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s4">// The type check here ensures that `req` is correctly typed, and the</span>
            <span class="s4">// environment variable check provides dead code elimination.</span>
            <span class="s1">process.env.NEXT_RUNTIME !== </span><span class="s0">'edge' </span><span class="s1">&amp;&amp; (</span><span class="s3">0</span><span class="s1">, _helpers.isNodeNextRequest)(req)) {</span>
                <span class="s4">// Use react-server-dom-webpack/server.node which supports streaming</span>
                <span class="s2">const </span><span class="s1">{ createTemporaryReferenceSet, decodeReply, decodeReplyFromBusboy, decodeAction, decodeFormState } = require(</span><span class="s0">`./react-server.node`</span><span class="s1">);</span>
                <span class="s1">temporaryReferences = createTemporaryReferenceSet();</span>
                <span class="s2">const </span><span class="s1">{ Transform, pipeline } = require(</span><span class="s0">'node:stream'</span><span class="s1">);</span>
                <span class="s2">const </span><span class="s1">defaultBodySizeLimit = </span><span class="s0">'1 MB'</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">bodySizeLimit = (serverActions == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: serverActions.bodySizeLimit) ?? defaultBodySizeLimit;</span>
                <span class="s2">const </span><span class="s1">bodySizeLimitBytes = bodySizeLimit !== defaultBodySizeLimit ? require(</span><span class="s0">'next/dist/compiled/bytes'</span><span class="s1">).parse(bodySizeLimit) : </span><span class="s3">1024 </span><span class="s1">* </span><span class="s3">1024 </span><span class="s4">// 1 MB</span>
                <span class="s1">;</span>
                <span class="s2">let </span><span class="s1">size = </span><span class="s3">0</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">sizeLimitTransform = </span><span class="s2">new </span><span class="s1">Transform({</span>
                    <span class="s1">transform (chunk, encoding, callback) {</span>
                        <span class="s1">size += Buffer.byteLength(chunk, encoding);</span>
                        <span class="s2">if </span><span class="s1">(size &gt; bodySizeLimitBytes) {</span>
                            <span class="s2">const </span><span class="s1">{ ApiError } = require(</span><span class="s0">'../api-utils'</span><span class="s1">);</span>
                            <span class="s1">callback(Object.defineProperty(</span><span class="s2">new </span><span class="s1">ApiError(</span><span class="s3">413</span><span class="s1">, </span><span class="s0">`Body exceeded </span><span class="s1">${bodySizeLimit} </span><span class="s0">limit.</span><span class="s6">\n</span><span class="s0">` </span><span class="s1">+ </span><span class="s0">`To configure the body size limit for Server Actions, see: https://nextjs.org/docs/app/api-reference/next-config-js/serverActions#bodysizelimit`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                                <span class="s1">value: </span><span class="s0">&quot;E394&quot;</span><span class="s1">,</span>
                                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                                <span class="s1">configurable: </span><span class="s2">true</span>
                            <span class="s1">}));</span>
                            <span class="s2">return</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s1">callback(</span><span class="s2">null</span><span class="s1">, chunk);</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
                <span class="s2">const </span><span class="s1">sizeLimitedBody = pipeline(req.body, sizeLimitTransform, </span><span class="s4">// Avoid unhandled errors from `pipeline()` by passing an empty completion callback.</span>
                <span class="s4">// We'll propagate the errors properly when consuming the stream.</span>
                <span class="s1">()=&gt;{});</span>
                <span class="s2">if </span><span class="s1">(isMultipartAction) {</span>
                    <span class="s2">if </span><span class="s1">(isFetchAction) {</span>
                        <span class="s4">// A fetch action with a multipart body.</span>
                        <span class="s2">const </span><span class="s1">busboy = require(</span><span class="s0">'next/dist/compiled/busboy'</span><span class="s1">)({</span>
                            <span class="s1">defParamCharset: </span><span class="s0">'utf8'</span><span class="s1">,</span>
                            <span class="s1">headers: req.headers,</span>
                            <span class="s1">limits: {</span>
                                <span class="s1">fieldSize: bodySizeLimitBytes</span>
                            <span class="s1">}</span>
                        <span class="s1">});</span>
                        <span class="s4">// We need to use `pipeline(one, two)` instead of `one.pipe(two)` to propagate size limit errors correctly.</span>
                        <span class="s1">pipeline(sizeLimitedBody, busboy, </span><span class="s4">// Avoid unhandled errors from `pipeline()` by passing an empty completion callback.</span>
                        <span class="s4">// We'll propagate the errors properly when consuming the stream.</span>
                        <span class="s1">()=&gt;{});</span>
                        <span class="s1">boundActionArguments = </span><span class="s2">await </span><span class="s1">decodeReplyFromBusboy(busboy, serverModuleMap, {</span>
                            <span class="s1">temporaryReferences</span>
                        <span class="s1">});</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s4">// Multipart POST, but not a fetch action.</span>
                        <span class="s4">// Potentially an MPA action, we have to try decoding it to check.</span>
                        <span class="s4">// React doesn't yet publish a busboy version of decodeAction</span>
                        <span class="s4">// so we polyfill the parsing of FormData.</span>
                        <span class="s2">const </span><span class="s1">fakeRequest = </span><span class="s2">new </span><span class="s1">Request(</span><span class="s0">'http://localhost'</span><span class="s1">, {</span>
                            <span class="s1">method: </span><span class="s0">'POST'</span><span class="s1">,</span>
                            <span class="s4">// @ts-expect-error</span>
                            <span class="s1">headers: {</span>
                                <span class="s0">'Content-Type'</span><span class="s1">: contentType</span>
                            <span class="s1">},</span>
                            <span class="s1">body: </span><span class="s2">new </span><span class="s1">ReadableStream({</span>
                                <span class="s1">start: (controller)=&gt;{</span>
                                    <span class="s1">sizeLimitedBody.on(</span><span class="s0">'data'</span><span class="s1">, (chunk)=&gt;{</span>
                                        <span class="s1">controller.enqueue(</span><span class="s2">new </span><span class="s1">Uint8Array(chunk));</span>
                                    <span class="s1">});</span>
                                    <span class="s1">sizeLimitedBody.on(</span><span class="s0">'end'</span><span class="s1">, ()=&gt;{</span>
                                        <span class="s1">controller.close();</span>
                                    <span class="s1">});</span>
                                    <span class="s1">sizeLimitedBody.on(</span><span class="s0">'error'</span><span class="s1">, (err)=&gt;{</span>
                                        <span class="s1">controller.error(err);</span>
                                    <span class="s1">});</span>
                                <span class="s1">}</span>
                            <span class="s1">}),</span>
                            <span class="s1">duplex: </span><span class="s0">'half'</span>
                        <span class="s1">});</span>
                        <span class="s2">const </span><span class="s1">formData = </span><span class="s2">await </span><span class="s1">fakeRequest.formData();</span>
                        <span class="s2">const </span><span class="s1">action = </span><span class="s2">await </span><span class="s1">decodeAction(formData, serverModuleMap);</span>
                        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">action === </span><span class="s0">'function'</span><span class="s1">) {</span>
                            <span class="s4">// an MPA action.</span>
                            <span class="s4">// Only warn if it's a server action, otherwise skip for other post requests</span>
                            <span class="s1">warnBadServerActionRequest();</span>
                            <span class="s2">const </span><span class="s1">actionReturnedState = </span><span class="s2">await </span><span class="s1">executeActionAndPrepareForRender(action, [], workStore, requestStore);</span>
                            <span class="s2">const </span><span class="s1">formState = </span><span class="s2">await </span><span class="s1">decodeFormState(actionReturnedState, formData, serverModuleMap);</span>
                            <span class="s4">// Skip the fetch path.</span>
                            <span class="s4">// We need to render a full HTML version of the page for the response, we'll handle that in app-render.</span>
                            <span class="s2">return </span><span class="s1">{</span>
                                <span class="s1">type: </span><span class="s0">'done'</span><span class="s1">,</span>
                                <span class="s1">result: undefined,</span>
                                <span class="s1">formState</span>
                            <span class="s1">};</span>
                        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                            <span class="s4">// We couldn't decode an action, so this POST request turned out not to be a server action request.</span>
                            <span class="s2">return null</span><span class="s1">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s4">// POST with non-multipart body.</span>
                    <span class="s4">// If it's not multipart AND not a fetch action,</span>
                    <span class="s4">// then it can't be an action request.</span>
                    <span class="s2">if </span><span class="s1">(!isFetchAction) {</span>
                        <span class="s2">return null</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">try </span><span class="s1">{</span>
                        <span class="s1">actionModId = getActionModIdOrError(actionId, serverModuleMap);</span>
                    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
                        <span class="s2">return </span><span class="s1">handleUnrecognizedFetchAction(err);</span>
                    <span class="s1">}</span>
                    <span class="s4">// A fetch action with a non-multipart body.</span>
                    <span class="s4">// In practice, this happens if `encodeReply` returned a string instead of FormData,</span>
                    <span class="s4">// which can happen for very simple JSON-like values that don't need multiple flight rows.</span>
                    <span class="s2">const </span><span class="s1">chunks = [];</span>
                    <span class="s2">for await </span><span class="s1">(</span><span class="s2">const </span><span class="s1">chunk of sizeLimitedBody){</span>
                        <span class="s1">chunks.push(Buffer.from(chunk));</span>
                    <span class="s1">}</span>
                    <span class="s2">const </span><span class="s1">actionData = Buffer.concat(chunks).toString(</span><span class="s0">'utf-8'</span><span class="s1">);</span>
                    <span class="s2">if </span><span class="s1">(isURLEncodedAction) {</span>
                        <span class="s2">const </span><span class="s1">formData = formDataFromSearchQueryString(actionData);</span>
                        <span class="s1">boundActionArguments = </span><span class="s2">await </span><span class="s1">decodeReply(formData, serverModuleMap, {</span>
                            <span class="s1">temporaryReferences</span>
                        <span class="s1">});</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">boundActionArguments = </span><span class="s2">await </span><span class="s1">decodeReply(actionData, serverModuleMap, {</span>
                            <span class="s1">temporaryReferences</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Invariant: Unknown request type.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E114&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s4">// actions.js</span>
            <span class="s4">// app/page.js</span>
            <span class="s4">//   action worker1</span>
            <span class="s4">//     appRender1</span>
            <span class="s4">// app/foo/page.js</span>
            <span class="s4">//   action worker2</span>
            <span class="s4">//     appRender</span>
            <span class="s4">// / -&gt; fire action -&gt; POST / -&gt; appRender1 -&gt; modId for the action file</span>
            <span class="s4">// /foo -&gt; fire action -&gt; POST /foo -&gt; appRender2 -&gt; modId for the action file</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s1">actionModId = actionModId ?? getActionModIdOrError(actionId, serverModuleMap);</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
                <span class="s2">return </span><span class="s1">handleUnrecognizedFetchAction(err);</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">actionMod = </span><span class="s2">await </span><span class="s1">ComponentMod.__next_app__.require(actionModId);</span>
            <span class="s2">const </span><span class="s1">actionHandler = actionMod[</span><span class="s4">// `actionId` must exist if we got here, as otherwise we would have thrown an error above</span>
            <span class="s1">actionId];</span>
            <span class="s2">const </span><span class="s1">returnVal = </span><span class="s2">await </span><span class="s1">executeActionAndPrepareForRender(actionHandler, boundActionArguments, workStore, requestStore).finally(()=&gt;{</span>
                <span class="s1">addRevalidationHeader(res, {</span>
                    <span class="s1">workStore,</span>
                    <span class="s1">requestStore</span>
                <span class="s1">});</span>
            <span class="s1">});</span>
            <span class="s4">// For form actions, we need to continue rendering the page.</span>
            <span class="s2">if </span><span class="s1">(isFetchAction) {</span>
                <span class="s2">const </span><span class="s1">actionResult = </span><span class="s2">await </span><span class="s1">generateFlight(req, ctx, requestStore, {</span>
                    <span class="s1">actionResult: Promise.resolve(returnVal),</span>
                    <span class="s4">// if the page was not revalidated, or if the action was forwarded from another worker, we can skip the rendering the flight tree</span>
                    <span class="s1">skipFlight: !workStore.pathWasRevalidated || actionWasForwarded,</span>
                    <span class="s1">temporaryReferences</span>
                <span class="s1">});</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">type: </span><span class="s0">'done'</span><span class="s1">,</span>
                    <span class="s1">result: actionResult</span>
                <span class="s1">};</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s4">// TODO: this shouldn't be reachable, because all non-fetch codepaths return early.</span>
                <span class="s4">// this will be handled in a follow-up refactor PR.</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _redirecterror.isRedirectError)(err)) {</span>
            <span class="s2">const </span><span class="s1">redirectUrl = (</span><span class="s3">0</span><span class="s1">, _redirect.getURLFromRedirectError)(err);</span>
            <span class="s2">const </span><span class="s1">redirectType = (</span><span class="s3">0</span><span class="s1">, _redirect.getRedirectTypeFromError)(err);</span>
            <span class="s4">// if it's a fetch action, we'll set the status code for logging/debugging purposes</span>
            <span class="s4">// but we won't set a Location header, as the redirect will be handled by the client router</span>
            <span class="s1">res.statusCode = _redirectstatuscode.RedirectStatusCode.SeeOther;</span>
            <span class="s1">metadata.statusCode = _redirectstatuscode.RedirectStatusCode.SeeOther;</span>
            <span class="s2">if </span><span class="s1">(isFetchAction) {</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">type: </span><span class="s0">'done'</span><span class="s1">,</span>
                    <span class="s1">result: </span><span class="s2">await </span><span class="s1">createRedirectRenderResult(req, res, host, redirectUrl, redirectType, ctx.renderOpts.basePath, workStore)</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s4">// For an MPA action, the redirect doesn't need a body, just a Location header.</span>
            <span class="s1">res.setHeader(</span><span class="s0">'Location'</span><span class="s1">, redirectUrl);</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">type: </span><span class="s0">'done'</span><span class="s1">,</span>
                <span class="s1">result: _renderresult.default.EMPTY</span>
            <span class="s1">};</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _httpaccessfallback.isHTTPAccessFallbackError)(err)) {</span>
            <span class="s1">res.statusCode = (</span><span class="s3">0</span><span class="s1">, _httpaccessfallback.getAccessFallbackHTTPStatus)(err);</span>
            <span class="s1">metadata.statusCode = res.statusCode;</span>
            <span class="s2">if </span><span class="s1">(isFetchAction) {</span>
                <span class="s2">const </span><span class="s1">promise = Promise.reject(err);</span>
                <span class="s2">try </span><span class="s1">{</span>
                    <span class="s4">// we need to await the promise to trigger the rejection early</span>
                    <span class="s4">// so that it's already handled by the time we call</span>
                    <span class="s4">// the RSC runtime. Otherwise, it will throw an unhandled</span>
                    <span class="s4">// promise rejection error in the renderer.</span>
                    <span class="s2">await </span><span class="s1">promise;</span>
                <span class="s1">} </span><span class="s2">catch  </span><span class="s1">{</span>
                <span class="s4">// swallow error, it's gonna be handled on the client</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">type: </span><span class="s0">'done'</span><span class="s1">,</span>
                    <span class="s1">result: </span><span class="s2">await </span><span class="s1">generateFlight(req, ctx, requestStore, {</span>
                        <span class="s1">skipFlight: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">actionResult: promise,</span>
                        <span class="s1">temporaryReferences</span>
                    <span class="s1">})</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s4">// For an MPA action, we need to render a HTML response. We'll handle that in app-render.</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">type: </span><span class="s0">'not-found'</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s4">// An error that didn't come from `redirect()` or `notFound()`, likely thrown from user code</span>
        <span class="s4">// (but it could also be a bug in our code!)</span>
        <span class="s2">if </span><span class="s1">(isFetchAction) {</span>
            <span class="s4">// TODO: consider checking if the error is an `ApiError` and change status code</span>
            <span class="s4">// so that we can respond with a 413 to requests that break the body size limit</span>
            <span class="s4">// (but if we do that, we also need to make sure that whatever handles the non-fetch error path below does the same)</span>
            <span class="s1">res.statusCode = </span><span class="s3">500</span><span class="s1">;</span>
            <span class="s1">metadata.statusCode = </span><span class="s3">500</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">promise = Promise.reject(err);</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s4">// we need to await the promise to trigger the rejection early</span>
                <span class="s4">// so that it's already handled by the time we call</span>
                <span class="s4">// the RSC runtime. Otherwise, it will throw an unhandled</span>
                <span class="s4">// promise rejection error in the renderer.</span>
                <span class="s2">await </span><span class="s1">promise;</span>
            <span class="s1">} </span><span class="s2">catch  </span><span class="s1">{</span>
            <span class="s4">// swallow error, it's gonna be handled on the client</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">type: </span><span class="s0">'done'</span><span class="s1">,</span>
                <span class="s1">result: </span><span class="s2">await </span><span class="s1">generateFlight(req, ctx, requestStore, {</span>
                    <span class="s1">actionResult: promise,</span>
                    <span class="s4">// if the page was not revalidated, or if the action was forwarded from another worker, we can skip the rendering the flight tree</span>
                    <span class="s1">skipFlight: !workStore.pathWasRevalidated || actionWasForwarded,</span>
                    <span class="s1">temporaryReferences</span>
                <span class="s1">})</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s4">// For an MPA action, we need to render a HTML response. We'll rethrow the error and let it be handled above.</span>
        <span class="s2">throw </span><span class="s1">err;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">executeActionAndPrepareForRender(action, args, workStore, requestStore) {</span>
    <span class="s1">requestStore.phase = </span><span class="s0">'action'</span><span class="s1">;</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">return await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(requestStore, ()=&gt;action.apply(</span><span class="s2">null</span><span class="s1">, args));</span>
    <span class="s1">} </span><span class="s2">finally</span><span class="s1">{</span>
        <span class="s1">requestStore.phase = </span><span class="s0">'render'</span><span class="s1">;</span>
        <span class="s4">// When we switch to the render phase, cookies() will return</span>
        <span class="s4">// `workUnitStore.cookies` instead of `workUnitStore.userspaceMutableCookies`.</span>
        <span class="s4">// We want the render to see any cookie writes that we performed during the action,</span>
        <span class="s4">// so we need to update the immutable cookies to reflect the changes.</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requeststore.synchronizeMutableCookies)(requestStore);</span>
        <span class="s4">// The server action might have toggled draft mode, so we need to reflect</span>
        <span class="s4">// that in the work store to be up-to-date for subsequent rendering.</span>
        <span class="s1">workStore.isDraftMode = requestStore.draftMode.isEnabled;</span>
        <span class="s4">// If the action called revalidateTag/revalidatePath, then that might affect data used by the subsequent render,</span>
        <span class="s4">// so we need to make sure all revalidations are applied before that</span>
        <span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _revalidationutils.executeRevalidates)(workStore);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s4">/**</span>
 <span class="s4">* Attempts to find the module ID for the action from the module map. When this fails, it could be a deployment skew where</span>
 <span class="s4">* the action came from a different deployment. It could also simply be an invalid POST request that is not a server action.</span>
 <span class="s4">* In either case, we'll throw an error to be handled by the caller.</span>
 <span class="s4">*/ </span><span class="s2">function </span><span class="s1">getActionModIdOrError(actionId, serverModuleMap) {</span>
    <span class="s2">var </span><span class="s1">_serverModuleMap_actionId;</span>
    <span class="s4">// if we're missing the action ID header, we can't do any further processing</span>
    <span class="s2">if </span><span class="s1">(!actionId) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">&quot;Missing 'next-action' header.&quot;</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E664&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">actionModId = (_serverModuleMap_actionId = serverModuleMap[actionId]) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _serverModuleMap_actionId.id;</span>
    <span class="s2">if </span><span class="s1">(!actionModId) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Failed to find Server Action &quot;</span><span class="s1">${actionId}</span><span class="s0">&quot;. This request might be from an older or newer deployment.</span><span class="s6">\n</span><span class="s0">Read more: https://nextjs.org/docs/messages/failed-to-find-server-action`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E665&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">actionModId;</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=action-handler.js.map</span></pre>
</body>
</html>