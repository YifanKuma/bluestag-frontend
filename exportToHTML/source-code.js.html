<html>
<head>
<title>source-code.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #1750eb;}
.s6 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
source-code.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">Abstraction of JavaScript source code.</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Nicholas C. Zakas</span>
 <span class="s0">*/</span>
<span class="s3">&quot;use strict&quot;</span><span class="s2">;</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Requirements</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s4">const </span><span class="s2">{ isCommentToken } = require(</span><span class="s3">&quot;@eslint-community/eslint-utils&quot;</span><span class="s2">),</span>
	<span class="s2">TokenStore = require(</span><span class="s3">&quot;./token-store&quot;</span><span class="s2">),</span>
	<span class="s2">astUtils = require(</span><span class="s3">&quot;../../../shared/ast-utils&quot;</span><span class="s2">),</span>
	<span class="s2">Traverser = require(</span><span class="s3">&quot;../../../shared/traverser&quot;</span><span class="s2">),</span>
	<span class="s2">globals = require(</span><span class="s3">&quot;../../../../conf/globals&quot;</span><span class="s2">),</span>
	<span class="s2">{ directivesPattern } = require(</span><span class="s3">&quot;../../../shared/directives&quot;</span><span class="s2">),</span>
	<span class="s2">CodePathAnalyzer = require(</span><span class="s3">&quot;../../../linter/code-path-analysis/code-path-analyzer&quot;</span><span class="s2">),</span>
	<span class="s2">{</span>
		<span class="s2">ConfigCommentParser,</span>
		<span class="s2">VisitNodeStep,</span>
		<span class="s2">CallMethodStep,</span>
		<span class="s2">Directive,</span>
	<span class="s2">} = require(</span><span class="s3">&quot;@eslint/plugin-kit&quot;</span><span class="s2">),</span>
	<span class="s2">eslintScope = require(</span><span class="s3">&quot;eslint-scope&quot;</span><span class="s2">);</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Type Definitions</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;eslint-scope&quot;).Variable} Variable */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;eslint-scope&quot;).Scope} Scope */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;@eslint/core&quot;).SourceCode} ISourceCode */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;@eslint/core&quot;).Directive} IDirective */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;@eslint/core&quot;).TraversalStep} ITraversalStep */</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Private</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s4">const </span><span class="s2">commentParser = </span><span class="s4">new </span><span class="s2">ConfigCommentParser();</span>

<span class="s0">/**</span>
 <span class="s0">* Validates that the given AST has the required information.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} ast The Program node of the AST to check.</span>
 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the AST doesn't contain the correct information.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">validate(ast) {</span>
	<span class="s4">if </span><span class="s2">(!ast) {</span>
		<span class="s4">throw new </span><span class="s2">TypeError(</span><span class="s3">`Unexpected empty AST. (</span><span class="s2">${ast}</span><span class="s3">)`</span><span class="s2">);</span>
	<span class="s2">}</span>

	<span class="s4">if </span><span class="s2">(!ast.tokens) {</span>
		<span class="s4">throw new </span><span class="s2">TypeError(</span><span class="s3">&quot;AST is missing the tokens array.&quot;</span><span class="s2">);</span>
	<span class="s2">}</span>

	<span class="s4">if </span><span class="s2">(!ast.comments) {</span>
		<span class="s4">throw new </span><span class="s2">TypeError(</span><span class="s3">&quot;AST is missing the comments array.&quot;</span><span class="s2">);</span>
	<span class="s2">}</span>

	<span class="s4">if </span><span class="s2">(!ast.loc) {</span>
		<span class="s4">throw new </span><span class="s2">TypeError(</span><span class="s3">&quot;AST is missing location information.&quot;</span><span class="s2">);</span>
	<span class="s2">}</span>

	<span class="s4">if </span><span class="s2">(!ast.range) {</span>
		<span class="s4">throw new </span><span class="s2">TypeError(</span><span class="s3">&quot;AST is missing range information&quot;</span><span class="s2">);</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Retrieves globals for the given ecmaVersion.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} ecmaVersion The version to retrieve globals for.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Object} The globals for the given ecmaVersion.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">getGlobalsForEcmaVersion(ecmaVersion) {</span>
	<span class="s4">switch </span><span class="s2">(ecmaVersion) {</span>
		<span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
			<span class="s4">return </span><span class="s2">globals.es3;</span>

		<span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
			<span class="s4">return </span><span class="s2">globals.es5;</span>

		<span class="s4">default</span><span class="s2">:</span>
			<span class="s4">if </span><span class="s2">(ecmaVersion &lt; </span><span class="s5">2015</span><span class="s2">) {</span>
				<span class="s4">return </span><span class="s2">globals[</span><span class="s3">`es</span><span class="s2">${ecmaVersion + </span><span class="s5">2009</span><span class="s2">}</span><span class="s3">`</span><span class="s2">];</span>
			<span class="s2">}</span>

			<span class="s4">return </span><span class="s2">globals[</span><span class="s3">`es</span><span class="s2">${ecmaVersion}</span><span class="s3">`</span><span class="s2">];</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Check to see if its a ES6 export declaration.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} astNode An AST node.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} whether the given node represents an export declaration.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">looksLikeExport(astNode) {</span>
	<span class="s4">return </span><span class="s2">(</span>
		<span class="s2">astNode.type === </span><span class="s3">&quot;ExportDefaultDeclaration&quot; </span><span class="s2">||</span>
		<span class="s2">astNode.type === </span><span class="s3">&quot;ExportNamedDeclaration&quot; </span><span class="s2">||</span>
		<span class="s2">astNode.type === </span><span class="s3">&quot;ExportAllDeclaration&quot; </span><span class="s2">||</span>
		<span class="s2">astNode.type === </span><span class="s3">&quot;ExportSpecifier&quot;</span>
	<span class="s2">);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Merges two sorted lists into a larger sorted list in O(n) time.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token[]} tokens The list of tokens.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token[]} comments The list of comments.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Token[]} A sorted list of tokens and comments.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">sortedMerge(tokens, comments) {</span>
	<span class="s4">const </span><span class="s2">result = [];</span>
	<span class="s4">let </span><span class="s2">tokenIndex = </span><span class="s5">0</span><span class="s2">;</span>
	<span class="s4">let </span><span class="s2">commentIndex = </span><span class="s5">0</span><span class="s2">;</span>

	<span class="s4">while </span><span class="s2">(tokenIndex &lt; tokens.length || commentIndex &lt; comments.length) {</span>
		<span class="s4">if </span><span class="s2">(</span>
			<span class="s2">commentIndex &gt;= comments.length ||</span>
			<span class="s2">(tokenIndex &lt; tokens.length &amp;&amp;</span>
				<span class="s2">tokens[tokenIndex].range[</span><span class="s5">0</span><span class="s2">] &lt; comments[commentIndex].range[</span><span class="s5">0</span><span class="s2">])</span>
		<span class="s2">) {</span>
			<span class="s2">result.push(tokens[tokenIndex++]);</span>
		<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
			<span class="s2">result.push(comments[commentIndex++]);</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s4">return </span><span class="s2">result;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Normalizes a value for a global in a config</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{(boolean|string|null)} configuredValue The value given for a global in configuration or in</span>
 <span class="s0">* a global directive comment</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{(&quot;readonly&quot;|&quot;writable&quot;|&quot;off&quot;)} The value normalized as a string</span>
 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} if global value is invalid</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">normalizeConfigGlobal(configuredValue) {</span>
	<span class="s4">switch </span><span class="s2">(configuredValue) {</span>
		<span class="s4">case </span><span class="s3">&quot;off&quot;</span><span class="s2">:</span>
			<span class="s4">return </span><span class="s3">&quot;off&quot;</span><span class="s2">;</span>

		<span class="s4">case true</span><span class="s2">:</span>
		<span class="s4">case </span><span class="s3">&quot;true&quot;</span><span class="s2">:</span>
		<span class="s4">case </span><span class="s3">&quot;writeable&quot;</span><span class="s2">:</span>
		<span class="s4">case </span><span class="s3">&quot;writable&quot;</span><span class="s2">:</span>
			<span class="s4">return </span><span class="s3">&quot;writable&quot;</span><span class="s2">;</span>

		<span class="s4">case null</span><span class="s2">:</span>
		<span class="s4">case false</span><span class="s2">:</span>
		<span class="s4">case </span><span class="s3">&quot;false&quot;</span><span class="s2">:</span>
		<span class="s4">case </span><span class="s3">&quot;readable&quot;</span><span class="s2">:</span>
		<span class="s4">case </span><span class="s3">&quot;readonly&quot;</span><span class="s2">:</span>
			<span class="s4">return </span><span class="s3">&quot;readonly&quot;</span><span class="s2">;</span>

		<span class="s4">default</span><span class="s2">:</span>
			<span class="s4">throw new </span><span class="s2">Error(</span>
				<span class="s3">`'</span><span class="s2">${configuredValue}</span><span class="s3">' is not a valid configuration for a global (use 'readonly', 'writable', or 'off')`</span><span class="s2">,</span>
			<span class="s2">);</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Determines if two nodes or tokens overlap.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode|Token} first The first node or token to check.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode|Token} second The second node or token to check.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the two nodes or tokens overlap.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">nodesOrTokensOverlap(first, second) {</span>
	<span class="s4">return </span><span class="s2">(</span>
		<span class="s2">(first.range[</span><span class="s5">0</span><span class="s2">] &lt;= second.range[</span><span class="s5">0</span><span class="s2">] &amp;&amp;</span>
			<span class="s2">first.range[</span><span class="s5">1</span><span class="s2">] &gt;= second.range[</span><span class="s5">0</span><span class="s2">]) ||</span>
		<span class="s2">(second.range[</span><span class="s5">0</span><span class="s2">] &lt;= first.range[</span><span class="s5">0</span><span class="s2">] &amp;&amp; second.range[</span><span class="s5">1</span><span class="s2">] &gt;= first.range[</span><span class="s5">0</span><span class="s2">])</span>
	<span class="s2">);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Determines if two nodes or tokens have at least one whitespace character</span>
 <span class="s0">* between them. Order does not matter. Returns false if the given nodes or</span>
 <span class="s0">* tokens overlap.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{SourceCode} sourceCode The source code object.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode|Token} first The first node or token to check between.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode|Token} second The second node or token to check between.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} checkInsideOfJSXText If `true` is present, check inside of JSXText tokens for backward compatibility.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if there is a whitespace character between</span>
 <span class="s0">* any of the tokens found between the two given nodes or tokens.</span>
 <span class="s0">* </span><span class="s1">@public</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isSpaceBetween(sourceCode, first, second, checkInsideOfJSXText) {</span>
	<span class="s4">if </span><span class="s2">(nodesOrTokensOverlap(first, second)) {</span>
		<span class="s4">return false</span><span class="s2">;</span>
	<span class="s2">}</span>

	<span class="s4">const </span><span class="s2">[startingNodeOrToken, endingNodeOrToken] =</span>
		<span class="s2">first.range[</span><span class="s5">1</span><span class="s2">] &lt;= second.range[</span><span class="s5">0</span><span class="s2">] ? [first, second] : [second, first];</span>
	<span class="s4">const </span><span class="s2">firstToken =</span>
		<span class="s2">sourceCode.getLastToken(startingNodeOrToken) || startingNodeOrToken;</span>
	<span class="s4">const </span><span class="s2">finalToken =</span>
		<span class="s2">sourceCode.getFirstToken(endingNodeOrToken) || endingNodeOrToken;</span>
	<span class="s4">let </span><span class="s2">currentToken = firstToken;</span>

	<span class="s4">while </span><span class="s2">(currentToken !== finalToken) {</span>
		<span class="s4">const </span><span class="s2">nextToken = sourceCode.getTokenAfter(currentToken, {</span>
			<span class="s2">includeComments: </span><span class="s4">true</span><span class="s2">,</span>
		<span class="s2">});</span>

		<span class="s4">if </span><span class="s2">(</span>
			<span class="s2">currentToken.range[</span><span class="s5">1</span><span class="s2">] !== nextToken.range[</span><span class="s5">0</span><span class="s2">] ||</span>
			<span class="s0">/* 
             * For backward compatibility, check spaces in JSXText. 
             * https://github.com/eslint/eslint/issues/12614 
             */</span>
			<span class="s2">(checkInsideOfJSXText &amp;&amp;</span>
				<span class="s2">nextToken !== finalToken &amp;&amp;</span>
				<span class="s2">nextToken.type === </span><span class="s3">&quot;JSXText&quot; </span><span class="s2">&amp;&amp;</span>
				<span class="s6">/\s/u</span><span class="s2">.test(nextToken.value))</span>
		<span class="s2">) {</span>
			<span class="s4">return true</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s2">currentToken = nextToken;</span>
	<span class="s2">}</span>

	<span class="s4">return false</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Performs binary search to find the line number containing a given character index.</span>
 <span class="s0">* Returns the lower bound - the index of the first element greater than the target.</span>
 <span class="s0">* **Please note that the `lineStartIndices` should be sorted in ascending order**.</span>
 <span class="s0">* - Time Complexity: O(log n) - Significantly faster than linear search for large files.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number[]} lineStartIndices Sorted array of line start indices.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} target The character index to find the line number for.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{number} The 1-based line number for the target index.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">findLineNumberBinarySearch(lineStartIndices, target) {</span>
	<span class="s4">let </span><span class="s2">low = </span><span class="s5">0</span><span class="s2">;</span>
	<span class="s4">let </span><span class="s2">high = lineStartIndices.length;</span>

	<span class="s4">while </span><span class="s2">(low &lt; high) {</span>
		<span class="s4">const </span><span class="s2">mid = ((low + high) / </span><span class="s5">2</span><span class="s2">) | </span><span class="s5">0</span><span class="s2">; </span><span class="s0">// Use bitwise OR to floor the division</span>

		<span class="s4">if </span><span class="s2">(target &lt; lineStartIndices[mid]) {</span>
			<span class="s2">high = mid;</span>
		<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
			<span class="s2">low = mid + </span><span class="s5">1</span><span class="s2">;</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s4">return </span><span class="s2">low;</span>
<span class="s2">}</span>

<span class="s0">//-----------------------------------------------------------------------------</span>
<span class="s0">// Directive Comments</span>
<span class="s0">//-----------------------------------------------------------------------------</span>

<span class="s0">/**</span>
 <span class="s0">* Ensures that variables representing built-in properties of the Global Object,</span>
 <span class="s0">* and any globals declared by special block comments, are present in the global</span>
 <span class="s0">* scope.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Scope} globalScope The global scope.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object|undefined} configGlobals The globals declared in configuration</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object|undefined} inlineGlobals The globals declared in the source code</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">addDeclaredGlobals(</span>
	<span class="s2">globalScope,</span>
	<span class="s2">configGlobals = {},</span>
	<span class="s2">inlineGlobals = {},</span>
<span class="s2">) {</span>
	<span class="s0">// Define configured global variables.</span>
	<span class="s4">for </span><span class="s2">(</span><span class="s4">const </span><span class="s2">id of </span><span class="s4">new </span><span class="s2">Set([</span>
		<span class="s2">...Object.keys(configGlobals),</span>
		<span class="s2">...Object.keys(inlineGlobals),</span>
	<span class="s2">])) {</span>
		<span class="s0">/* 
         * `normalizeConfigGlobal` will throw an error if a configured global value is invalid. However, these errors would 
         * typically be caught when validating a config anyway (validity for inline global comments is checked separately). 
         */</span>
		<span class="s4">const </span><span class="s2">configValue =</span>
			<span class="s2">configGlobals[id] === </span><span class="s4">void </span><span class="s5">0</span>
				<span class="s2">? </span><span class="s4">void </span><span class="s5">0</span>
				<span class="s2">: normalizeConfigGlobal(configGlobals[id]);</span>
		<span class="s4">const </span><span class="s2">commentValue = inlineGlobals[id] &amp;&amp; inlineGlobals[id].value;</span>
		<span class="s4">const </span><span class="s2">value = commentValue || configValue;</span>
		<span class="s4">const </span><span class="s2">sourceComments = inlineGlobals[id] &amp;&amp; inlineGlobals[id].comments;</span>

		<span class="s4">if </span><span class="s2">(value === </span><span class="s3">&quot;off&quot;</span><span class="s2">) {</span>
			<span class="s4">continue</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s4">let </span><span class="s2">variable = globalScope.set.get(id);</span>

		<span class="s4">if </span><span class="s2">(!variable) {</span>
			<span class="s2">variable = </span><span class="s4">new </span><span class="s2">eslintScope.Variable(id, globalScope);</span>

			<span class="s2">globalScope.variables.push(variable);</span>
			<span class="s2">globalScope.set.set(id, variable);</span>
		<span class="s2">}</span>

		<span class="s2">variable.eslintImplicitGlobalSetting = configValue;</span>
		<span class="s2">variable.eslintExplicitGlobal = sourceComments !== </span><span class="s4">void </span><span class="s5">0</span><span class="s2">;</span>
		<span class="s2">variable.eslintExplicitGlobalComments = sourceComments;</span>
		<span class="s2">variable.writeable = value === </span><span class="s3">&quot;writable&quot;</span><span class="s2">;</span>
	<span class="s2">}</span>

	<span class="s0">/* 
     * &quot;through&quot; contains all references which definitions cannot be found. 
     * Since we augment the global scope using configuration, we need to update 
     * references and remove the ones that were added by configuration. 
     */</span>
	<span class="s2">globalScope.through = globalScope.through.filter(reference =&gt; {</span>
		<span class="s4">const </span><span class="s2">name = reference.identifier.name;</span>
		<span class="s4">const </span><span class="s2">variable = globalScope.set.get(name);</span>

		<span class="s4">if </span><span class="s2">(variable) {</span>
			<span class="s0">/* 
             * Links the variable and the reference. 
             * And this reference is removed from `Scope#through`. 
             */</span>
			<span class="s2">reference.resolved = variable;</span>
			<span class="s2">variable.references.push(reference);</span>

			<span class="s4">return false</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s4">return true</span><span class="s2">;</span>
	<span class="s2">});</span>

	<span class="s0">/* 
     * &quot;implicit&quot; contains information about implicit global variables (those created 
     * implicitly by assigning values to undeclared variables in non-strict code). 
     * Since we augment the global scope using configuration, we need to remove 
     * the ones that were added by configuration, as they are either built-in 
     * or declared elsewhere, therefore not implicit. 
     * Since the &quot;implicit&quot; property was not documented, first we'll check if it exists 
     * because it's possible that not all custom scope managers create this property. 
     * If it exists, we assume it has properties `variables` and `set`. Property 
     * `left` is considered optional (for example, typescript-eslint's scope manage 
     * has this property named `leftToBeResolved`). 
     */</span>
	<span class="s4">const </span><span class="s2">{ implicit } = globalScope;</span>
	<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">implicit === </span><span class="s3">&quot;object&quot; </span><span class="s2">&amp;&amp; implicit !== </span><span class="s4">null</span><span class="s2">) {</span>
		<span class="s2">implicit.variables = implicit.variables.filter(variable =&gt; {</span>
			<span class="s4">const </span><span class="s2">name = variable.name;</span>
			<span class="s4">if </span><span class="s2">(globalScope.set.has(name)) {</span>
				<span class="s2">implicit.set.delete(name);</span>
				<span class="s4">return false</span><span class="s2">;</span>
			<span class="s2">}</span>
			<span class="s4">return true</span><span class="s2">;</span>
		<span class="s2">});</span>

		<span class="s4">if </span><span class="s2">(implicit.left) {</span>
			<span class="s2">implicit.left = implicit.left.filter(</span>
				<span class="s2">reference =&gt; !globalScope.set.has(reference.identifier.name),</span>
			<span class="s2">);</span>
		<span class="s2">}</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the given variable names as exported so they won't be triggered by</span>
 <span class="s0">* the `no-unused-vars` rule.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{eslint.Scope} globalScope The global scope to define exports in.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Record&lt;string,string&gt;} variables An object whose keys are the variable</span>
 <span class="s0">*      names to export.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">markExportedVariables(globalScope, variables) {</span>
	<span class="s2">Object.keys(variables).forEach(name =&gt; {</span>
		<span class="s4">const </span><span class="s2">variable = globalScope.set.get(name);</span>

		<span class="s4">if </span><span class="s2">(variable) {</span>
			<span class="s2">variable.eslintUsed = </span><span class="s4">true</span><span class="s2">;</span>
			<span class="s2">variable.eslintExported = </span><span class="s4">true</span><span class="s2">;</span>
		<span class="s2">}</span>
	<span class="s2">});</span>
<span class="s2">}</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Public Interface</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s4">const </span><span class="s2">caches = Symbol(</span><span class="s3">&quot;caches&quot;</span><span class="s2">);</span>

<span class="s0">/**</span>
 <span class="s0">* Represents parsed source code.</span>
 <span class="s0">* </span><span class="s1">@implements </span><span class="s0">{ISourceCode}</span>
 <span class="s0">*/</span>
<span class="s4">class </span><span class="s2">SourceCode </span><span class="s4">extends </span><span class="s2">TokenStore {</span>
	<span class="s0">/**</span>
	 <span class="s0">* The cache of steps that were taken while traversing the source code.</span>
	 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;ITraversalStep&gt;}</span>
	 <span class="s0">*/</span>
	<span class="s2">#steps;</span>

	<span class="s0">/**</span>
	 <span class="s0">* Creates a new instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|Object} textOrConfig The source code text or config object.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} textOrConfig.text The source code text.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} textOrConfig.ast The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} textOrConfig.hasBOM Indicates if the text has a Unicode BOM.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object|null} textOrConfig.parserServices The parser services.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ScopeManager|null} textOrConfig.scopeManager The scope of this source code.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object|null} textOrConfig.visitorKeys The visitor keys to traverse AST.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} [astIfNoConfig] The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor(textOrConfig, astIfNoConfig) {</span>
		<span class="s4">let </span><span class="s2">text, hasBOM, ast, parserServices, scopeManager, visitorKeys;</span>

		<span class="s0">// Process overloading of arguments</span>
		<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">textOrConfig === </span><span class="s3">&quot;string&quot;</span><span class="s2">) {</span>
			<span class="s2">text = textOrConfig;</span>
			<span class="s2">ast = astIfNoConfig;</span>
			<span class="s2">hasBOM = </span><span class="s4">false</span><span class="s2">;</span>
		<span class="s2">} </span><span class="s4">else if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">textOrConfig === </span><span class="s3">&quot;object&quot; </span><span class="s2">&amp;&amp; textOrConfig !== </span><span class="s4">null</span><span class="s2">) {</span>
			<span class="s2">text = textOrConfig.text;</span>
			<span class="s2">ast = textOrConfig.ast;</span>
			<span class="s2">hasBOM = textOrConfig.hasBOM;</span>
			<span class="s2">parserServices = textOrConfig.parserServices;</span>
			<span class="s2">scopeManager = textOrConfig.scopeManager;</span>
			<span class="s2">visitorKeys = textOrConfig.visitorKeys;</span>
		<span class="s2">}</span>

		<span class="s2">validate(ast);</span>
		<span class="s4">super</span><span class="s2">(ast.tokens, ast.comments);</span>

		<span class="s0">/**</span>
		 <span class="s0">* General purpose caching for the class.</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">[caches] = </span><span class="s4">new </span><span class="s2">Map([</span>
			<span class="s2">[</span><span class="s3">&quot;scopes&quot;</span><span class="s2">, </span><span class="s4">new </span><span class="s2">WeakMap()],</span>
			<span class="s2">[</span><span class="s3">&quot;vars&quot;</span><span class="s2">, </span><span class="s4">new </span><span class="s2">Map()],</span>
			<span class="s2">[</span><span class="s3">&quot;configNodes&quot;</span><span class="s2">, </span><span class="s4">void </span><span class="s5">0</span><span class="s2">],</span>
			<span class="s2">[</span><span class="s3">&quot;isGlobalReference&quot;</span><span class="s2">, </span><span class="s4">new </span><span class="s2">WeakMap()],</span>
		<span class="s2">]);</span>

		<span class="s0">/**</span>
		 <span class="s0">* Indicates if the AST is ESTree compatible.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.isESTree = ast.type === </span><span class="s3">&quot;Program&quot;</span><span class="s2">;</span>

		<span class="s0">/* 
         * Backwards compatibility for BOM handling. 
         * 
         * The `hasBOM` property has been available on the `SourceCode` object 
         * for a long time and is used to indicate if the source contains a BOM. 
         * The linter strips the BOM and just passes the `hasBOM` property to the 
         * `SourceCode` constructor to make it easier for languages to not deal with 
         * the BOM. 
         * 
         * However, the text passed in to the `SourceCode` constructor might still 
         * have a BOM if the constructor is called outside of the linter, so we still 
         * need to check for the BOM in the text. 
         */</span>
		<span class="s4">const </span><span class="s2">textHasBOM = text.charCodeAt(</span><span class="s5">0</span><span class="s2">) === </span><span class="s5">0xfeff</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The flag to indicate that the source code has Unicode BOM.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.hasBOM = textHasBOM || !!hasBOM;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The original text source code.</span>
		 <span class="s0">* BOM was stripped from this text.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{string}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.text = textHasBOM ? text.slice(</span><span class="s5">1</span><span class="s2">) : text;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The parsed AST for the source code.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ASTNode}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.ast = ast;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The parser services of this source code.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Object}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.parserServices = parserServices || {};</span>

		<span class="s0">/**</span>
		 <span class="s0">* The scope of this source code.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ScopeManager|null}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.scopeManager = scopeManager || </span><span class="s4">null</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The visitor keys to traverse AST.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Object}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.visitorKeys = visitorKeys || Traverser.DEFAULT_VISITOR_KEYS;</span>

		<span class="s0">// Check the source text for the presence of a shebang since it is parsed as a standard line comment.</span>
		<span class="s4">const </span><span class="s2">shebangMatched = </span><span class="s4">this</span><span class="s2">.text.match(astUtils.shebangPattern);</span>
		<span class="s4">const </span><span class="s2">hasShebang =</span>
			<span class="s2">shebangMatched &amp;&amp;</span>
			<span class="s2">ast.comments.length &amp;&amp;</span>
			<span class="s2">ast.comments[</span><span class="s5">0</span><span class="s2">].value === shebangMatched[</span><span class="s5">1</span><span class="s2">];</span>

		<span class="s4">if </span><span class="s2">(hasShebang) {</span>
			<span class="s2">ast.comments[</span><span class="s5">0</span><span class="s2">].type = </span><span class="s3">&quot;Shebang&quot;</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s4">this</span><span class="s2">.tokensAndComments = sortedMerge(ast.tokens, ast.comments);</span>

		<span class="s0">/**</span>
		 <span class="s0">* The source code split into lines according to ECMA-262 specification.</span>
		 <span class="s0">* This is done to avoid each rule needing to do so separately.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{string[]}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.lines = [];</span>

		<span class="s0">/**</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{number[]}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.lineStartIndices = [</span><span class="s5">0</span><span class="s2">];</span>

		<span class="s4">const </span><span class="s2">lineEndingPattern = astUtils.createGlobalLinebreakMatcher();</span>
		<span class="s4">let </span><span class="s2">match;</span>

		<span class="s0">/* 
         * Previously, this was implemented using a regex that 
         * matched a sequence of non-linebreak characters followed by a 
         * linebreak, then adding the lengths of the matches. However, 
         * this caused a catastrophic backtracking issue when the end 
         * of a file contained a large number of non-newline characters. 
         * To avoid this, the current implementation just matches newlines 
         * and uses match.index to get the correct line start indices. 
         */</span>
		<span class="s4">while </span><span class="s2">((match = lineEndingPattern.exec(</span><span class="s4">this</span><span class="s2">.text))) {</span>
			<span class="s4">this</span><span class="s2">.lines.push(</span>
				<span class="s4">this</span><span class="s2">.text.slice(</span><span class="s4">this</span><span class="s2">.lineStartIndices.at(-</span><span class="s5">1</span><span class="s2">), match.index),</span>
			<span class="s2">);</span>
			<span class="s4">this</span><span class="s2">.lineStartIndices.push(match.index + match[</span><span class="s5">0</span><span class="s2">].length);</span>
		<span class="s2">}</span>
		<span class="s4">this</span><span class="s2">.lines.push(</span><span class="s4">this</span><span class="s2">.text.slice(</span><span class="s4">this</span><span class="s2">.lineStartIndices.at(-</span><span class="s5">1</span><span class="s2">)));</span>

		<span class="s0">// don't allow further modification of this object</span>
		<span class="s2">Object.freeze(</span><span class="s4">this</span><span class="s2">);</span>
		<span class="s2">Object.freeze(</span><span class="s4">this</span><span class="s2">.lines);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Split the source code into multiple lines based on the line delimiters.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} text Source code as a string.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string[]} Array of source code lines.</span>
	 <span class="s0">* </span><span class="s1">@public</span>
	 <span class="s0">*/</span>
	<span class="s4">static </span><span class="s2">splitLines(text) {</span>
		<span class="s4">return </span><span class="s2">text.split(astUtils.createGlobalLinebreakMatcher());</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Gets the source code for the given node.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} [node] The AST node to get the text for.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} [beforeCount] The number of characters before the node to retrieve.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} [afterCount] The number of characters after the node to retrieve.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string} The text representing the AST node.</span>
	 <span class="s0">* </span><span class="s1">@public</span>
	 <span class="s0">*/</span>
	<span class="s2">getText(node, beforeCount, afterCount) {</span>
		<span class="s4">if </span><span class="s2">(node) {</span>
			<span class="s4">return this</span><span class="s2">.text.slice(</span>
				<span class="s2">Math.max(node.range[</span><span class="s5">0</span><span class="s2">] - (beforeCount || </span><span class="s5">0</span><span class="s2">), </span><span class="s5">0</span><span class="s2">),</span>
				<span class="s2">node.range[</span><span class="s5">1</span><span class="s2">] + (afterCount || </span><span class="s5">0</span><span class="s2">),</span>
			<span class="s2">);</span>
		<span class="s2">}</span>
		<span class="s4">return this</span><span class="s2">.text;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Gets the entire source text split into an array of lines.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string[]} The source text as an array of lines.</span>
	 <span class="s0">* </span><span class="s1">@public</span>
	 <span class="s0">*/</span>
	<span class="s2">getLines() {</span>
		<span class="s4">return this</span><span class="s2">.lines;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Retrieves an array containing all comments in the source code.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ASTNode[]} An array of comment nodes.</span>
	 <span class="s0">* </span><span class="s1">@public</span>
	 <span class="s0">*/</span>
	<span class="s2">getAllComments() {</span>
		<span class="s4">return this</span><span class="s2">.ast.comments;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Retrieves the JSDoc comment for a given node.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node to get the comment for.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Token|null} The Block comment token containing the JSDoc comment</span>
	 <span class="s0">*      for the given node or null if not found.</span>
	 <span class="s0">* </span><span class="s1">@public</span>
	 <span class="s0">* </span><span class="s1">@deprecated</span>
	 <span class="s0">*/</span>
	<span class="s2">getJSDocComment(node) {</span>
		<span class="s0">/**</span>
		 <span class="s0">* Checks for the presence of a JSDoc comment for the given node and returns it.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} astNode The AST node to get the comment for.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Token|null} The Block comment token containing the JSDoc comment</span>
		 <span class="s0">*      for the given node or null if not found.</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">const </span><span class="s2">findJSDocComment = astNode =&gt; {</span>
			<span class="s4">const </span><span class="s2">tokenBefore = </span><span class="s4">this</span><span class="s2">.getTokenBefore(astNode, {</span>
				<span class="s2">includeComments: </span><span class="s4">true</span><span class="s2">,</span>
			<span class="s2">});</span>

			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">tokenBefore &amp;&amp;</span>
				<span class="s2">isCommentToken(tokenBefore) &amp;&amp;</span>
				<span class="s2">tokenBefore.type === </span><span class="s3">&quot;Block&quot; </span><span class="s2">&amp;&amp;</span>
				<span class="s2">tokenBefore.value.charAt(</span><span class="s5">0</span><span class="s2">) === </span><span class="s3">&quot;*&quot; </span><span class="s2">&amp;&amp;</span>
				<span class="s2">astNode.loc.start.line - tokenBefore.loc.end.line &lt;= </span><span class="s5">1</span>
			<span class="s2">) {</span>
				<span class="s4">return </span><span class="s2">tokenBefore;</span>
			<span class="s2">}</span>

			<span class="s4">return null</span><span class="s2">;</span>
		<span class="s2">};</span>
		<span class="s4">let </span><span class="s2">parent = node.parent;</span>

		<span class="s4">switch </span><span class="s2">(node.type) {</span>
			<span class="s4">case </span><span class="s3">&quot;ClassDeclaration&quot;</span><span class="s2">:</span>
			<span class="s4">case </span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s2">:</span>
				<span class="s4">return </span><span class="s2">findJSDocComment(</span>
					<span class="s2">looksLikeExport(parent) ? parent : node,</span>
				<span class="s2">);</span>

			<span class="s4">case </span><span class="s3">&quot;ClassExpression&quot;</span><span class="s2">:</span>
				<span class="s4">return </span><span class="s2">findJSDocComment(parent.parent);</span>

			<span class="s4">case </span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s2">:</span>
			<span class="s4">case </span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s2">:</span>
				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">parent.type !== </span><span class="s3">&quot;CallExpression&quot; </span><span class="s2">&amp;&amp;</span>
					<span class="s2">parent.type !== </span><span class="s3">&quot;NewExpression&quot;</span>
				<span class="s2">) {</span>
					<span class="s4">while </span><span class="s2">(</span>
						<span class="s2">!</span><span class="s4">this</span><span class="s2">.getCommentsBefore(parent).length &amp;&amp;</span>
						<span class="s2">!</span><span class="s6">/Function/u</span><span class="s2">.test(parent.type) &amp;&amp;</span>
						<span class="s2">parent.type !== </span><span class="s3">&quot;MethodDefinition&quot; </span><span class="s2">&amp;&amp;</span>
						<span class="s2">parent.type !== </span><span class="s3">&quot;Property&quot;</span>
					<span class="s2">) {</span>
						<span class="s2">parent = parent.parent;</span>

						<span class="s4">if </span><span class="s2">(!parent) {</span>
							<span class="s4">break</span><span class="s2">;</span>
						<span class="s2">}</span>
					<span class="s2">}</span>

					<span class="s4">if </span><span class="s2">(</span>
						<span class="s2">parent &amp;&amp;</span>
						<span class="s2">parent.type !== </span><span class="s3">&quot;FunctionDeclaration&quot; </span><span class="s2">&amp;&amp;</span>
						<span class="s2">parent.type !== </span><span class="s3">&quot;Program&quot;</span>
					<span class="s2">) {</span>
						<span class="s4">return </span><span class="s2">findJSDocComment(parent);</span>
					<span class="s2">}</span>
				<span class="s2">}</span>

				<span class="s4">return </span><span class="s2">findJSDocComment(node);</span>

			<span class="s0">// falls through</span>
			<span class="s4">default</span><span class="s2">:</span>
				<span class="s4">return null</span><span class="s2">;</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Gets the deepest node containing a range index.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} index Range index of the desired node.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ASTNode} The node if found or null if not found.</span>
	 <span class="s0">* </span><span class="s1">@public</span>
	 <span class="s0">*/</span>
	<span class="s2">getNodeByRangeIndex(index) {</span>
		<span class="s4">let </span><span class="s2">result = </span><span class="s4">null</span><span class="s2">;</span>

		<span class="s2">Traverser.traverse(</span><span class="s4">this</span><span class="s2">.ast, {</span>
			<span class="s2">visitorKeys: </span><span class="s4">this</span><span class="s2">.visitorKeys,</span>
			<span class="s2">enter(node) {</span>
				<span class="s4">if </span><span class="s2">(node.range[</span><span class="s5">0</span><span class="s2">] &lt;= index &amp;&amp; index &lt; node.range[</span><span class="s5">1</span><span class="s2">]) {</span>
					<span class="s2">result = node;</span>
				<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
					<span class="s4">this</span><span class="s2">.skip();</span>
				<span class="s2">}</span>
			<span class="s2">},</span>
			<span class="s2">leave(node) {</span>
				<span class="s4">if </span><span class="s2">(node === result) {</span>
					<span class="s4">this</span><span class="s2">.break();</span>
				<span class="s2">}</span>
			<span class="s2">},</span>
		<span class="s2">});</span>

		<span class="s4">return </span><span class="s2">result;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Determines if two nodes or tokens have at least one whitespace character</span>
	 <span class="s0">* between them. Order does not matter. Returns false if the given nodes or</span>
	 <span class="s0">* tokens overlap.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode|Token} first The first node or token to check between.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode|Token} second The second node or token to check between.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if there is a whitespace character between</span>
	 <span class="s0">* any of the tokens found between the two given nodes or tokens.</span>
	 <span class="s0">* </span><span class="s1">@public</span>
	 <span class="s0">*/</span>
	<span class="s2">isSpaceBetween(first, second) {</span>
		<span class="s4">return </span><span class="s2">isSpaceBetween(</span><span class="s4">this</span><span class="s2">, first, second, </span><span class="s4">false</span><span class="s2">);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Determines if two nodes or tokens have at least one whitespace character</span>
	 <span class="s0">* between them. Order does not matter. Returns false if the given nodes or</span>
	 <span class="s0">* tokens overlap.</span>
	 <span class="s0">* For backward compatibility, this method returns true if there are</span>
	 <span class="s0">* `JSXText` tokens that contain whitespaces between the two.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode|Token} first The first node or token to check between.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode|Token} second The second node or token to check between.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if there is a whitespace character between</span>
	 <span class="s0">* any of the tokens found between the two given nodes or tokens.</span>
	 <span class="s0">* </span><span class="s1">@deprecated </span><span class="s0">in favor of isSpaceBetween().</span>
	 <span class="s0">* </span><span class="s1">@public</span>
	 <span class="s0">*/</span>
	<span class="s2">isSpaceBetweenTokens(first, second) {</span>
		<span class="s4">return </span><span class="s2">isSpaceBetween(</span><span class="s4">this</span><span class="s2">, first, second, </span><span class="s4">true</span><span class="s2">);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Converts a source text index into a (line, column) pair.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} index The index of a character in a file.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError|RangeError} If non-numeric index or index out of range.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{{line: number, column: number}} A {line, column} location object with 1-indexed line and 0-indexed column.</span>
	 <span class="s0">* </span><span class="s1">@public</span>
	 <span class="s0">*/</span>
	<span class="s2">getLocFromIndex(index) {</span>
		<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">index !== </span><span class="s3">&quot;number&quot;</span><span class="s2">) {</span>
			<span class="s4">throw new </span><span class="s2">TypeError(</span><span class="s3">&quot;Expected `index` to be a number.&quot;</span><span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s4">if </span><span class="s2">(index &lt; </span><span class="s5">0 </span><span class="s2">|| index &gt; </span><span class="s4">this</span><span class="s2">.text.length) {</span>
			<span class="s4">throw new </span><span class="s2">RangeError(</span>
				<span class="s3">`Index out of range (requested index </span><span class="s2">${index}</span><span class="s3">, but source text has length </span><span class="s2">${</span><span class="s4">this</span><span class="s2">.text.length}</span><span class="s3">).`</span><span class="s2">,</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">/* 
         * For an argument of this.text.length, return the location one &quot;spot&quot; past the last character 
         * of the file. If the last character is a linebreak, the location will be column 0 of the next 
         * line; otherwise, the location will be in the next column on the same line. 
         * 
         * See getIndexFromLoc for the motivation for this special case. 
         */</span>
		<span class="s4">if </span><span class="s2">(index === </span><span class="s4">this</span><span class="s2">.text.length) {</span>
			<span class="s4">return </span><span class="s2">{</span>
				<span class="s2">line: </span><span class="s4">this</span><span class="s2">.lines.length,</span>
				<span class="s2">column: </span><span class="s4">this</span><span class="s2">.lines.at(-</span><span class="s5">1</span><span class="s2">).length,</span>
			<span class="s2">};</span>
		<span class="s2">}</span>

		<span class="s0">/* 
         * To figure out which line index is on, determine the last place at which index could 
         * be inserted into lineStartIndices to keep the list sorted. 
         */</span>
		<span class="s4">const </span><span class="s2">lineNumber =</span>
			<span class="s2">index &gt;= </span><span class="s4">this</span><span class="s2">.lineStartIndices.at(-</span><span class="s5">1</span><span class="s2">)</span>
				<span class="s2">? </span><span class="s4">this</span><span class="s2">.lineStartIndices.length</span>
				<span class="s2">: findLineNumberBinarySearch(</span><span class="s4">this</span><span class="s2">.lineStartIndices, index);</span>

		<span class="s4">return </span><span class="s2">{</span>
			<span class="s2">line: lineNumber,</span>
			<span class="s2">column: index - </span><span class="s4">this</span><span class="s2">.lineStartIndices[lineNumber - </span><span class="s5">1</span><span class="s2">],</span>
		<span class="s2">};</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Converts a (line, column) pair into a range index.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} loc A line/column location</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} loc.line The line number of the location (1-indexed)</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} loc.column The column number of the location (0-indexed)</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError|RangeError} If `loc` is not an object with a numeric</span>
	 <span class="s0">*   `line` and `column`, if the `line` is less than or equal to zero or</span>
	 <span class="s0">*   the line or column is out of the expected range.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{number} The range index of the location in the file.</span>
	 <span class="s0">* </span><span class="s1">@public</span>
	 <span class="s0">*/</span>
	<span class="s2">getIndexFromLoc(loc) {</span>
		<span class="s4">if </span><span class="s2">(</span>
			<span class="s2">loc === </span><span class="s4">null </span><span class="s2">||</span>
			<span class="s4">typeof </span><span class="s2">loc !== </span><span class="s3">&quot;object&quot; </span><span class="s2">||</span>
			<span class="s4">typeof </span><span class="s2">loc.line !== </span><span class="s3">&quot;number&quot; </span><span class="s2">||</span>
			<span class="s4">typeof </span><span class="s2">loc.column !== </span><span class="s3">&quot;number&quot;</span>
		<span class="s2">) {</span>
			<span class="s4">throw new </span><span class="s2">TypeError(</span>
				<span class="s3">&quot;Expected `loc` to be an object with numeric `line` and `column` properties.&quot;</span><span class="s2">,</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s4">if </span><span class="s2">(loc.line &lt;= </span><span class="s5">0</span><span class="s2">) {</span>
			<span class="s4">throw new </span><span class="s2">RangeError(</span>
				<span class="s3">`Line number out of range (line </span><span class="s2">${loc.line} </span><span class="s3">requested). Line numbers should be 1-based.`</span><span class="s2">,</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s4">if </span><span class="s2">(loc.line &gt; </span><span class="s4">this</span><span class="s2">.lineStartIndices.length) {</span>
			<span class="s4">throw new </span><span class="s2">RangeError(</span>
				<span class="s3">`Line number out of range (line </span><span class="s2">${loc.line} </span><span class="s3">requested, but only </span><span class="s2">${</span><span class="s4">this</span><span class="s2">.lineStartIndices.length} </span><span class="s3">lines present).`</span><span class="s2">,</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s4">if </span><span class="s2">(loc.column &lt; </span><span class="s5">0</span><span class="s2">) {</span>
			<span class="s4">throw new </span><span class="s2">RangeError(</span>
				<span class="s3">`Invalid column number (column </span><span class="s2">${loc.column} </span><span class="s3">requested).`</span><span class="s2">,</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s4">const </span><span class="s2">lineStartIndex = </span><span class="s4">this</span><span class="s2">.lineStartIndices[loc.line - </span><span class="s5">1</span><span class="s2">];</span>
		<span class="s4">const </span><span class="s2">lineEndIndex =</span>
			<span class="s2">loc.line === </span><span class="s4">this</span><span class="s2">.lineStartIndices.length</span>
				<span class="s2">? </span><span class="s4">this</span><span class="s2">.text.length</span>
				<span class="s2">: </span><span class="s4">this</span><span class="s2">.lineStartIndices[loc.line];</span>
		<span class="s4">const </span><span class="s2">positionIndex = lineStartIndex + loc.column;</span>

		<span class="s0">/* 
         * By design, getIndexFromLoc({ line: lineNum, column: 0 }) should return the start index of 
         * the given line, provided that the line number is valid element of this.lines. Since the 
         * last element of this.lines is an empty string for files with trailing newlines, add a 
         * special case where getting the index for the first location after the end of the file 
         * will return the length of the file, rather than throwing an error. This allows rules to 
         * use getIndexFromLoc consistently without worrying about edge cases at the end of a file. 
         */</span>
		<span class="s4">if </span><span class="s2">(</span>
			<span class="s2">(loc.line === </span><span class="s4">this</span><span class="s2">.lineStartIndices.length &amp;&amp;</span>
				<span class="s2">positionIndex &gt; lineEndIndex) ||</span>
			<span class="s2">(loc.line &lt; </span><span class="s4">this</span><span class="s2">.lineStartIndices.length &amp;&amp;</span>
				<span class="s2">positionIndex &gt;= lineEndIndex)</span>
		<span class="s2">) {</span>
			<span class="s4">throw new </span><span class="s2">RangeError(</span>
				<span class="s3">`Column number out of range (column </span><span class="s2">${loc.column} </span><span class="s3">requested, but the length of line </span><span class="s2">${loc.line} </span><span class="s3">is </span><span class="s2">${lineEndIndex - lineStartIndex}</span><span class="s3">).`</span><span class="s2">,</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s4">return </span><span class="s2">positionIndex;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Gets the scope for the given node</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} currentNode The node to get the scope of</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Scope} The scope information for this node</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the `currentNode` argument is missing.</span>
	 <span class="s0">*/</span>
	<span class="s2">getScope(currentNode) {</span>
		<span class="s4">if </span><span class="s2">(!currentNode) {</span>
			<span class="s4">throw new </span><span class="s2">TypeError(</span><span class="s3">&quot;Missing required argument: node.&quot;</span><span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">// check cache first</span>
		<span class="s4">const </span><span class="s2">cache = </span><span class="s4">this</span><span class="s2">[caches].get(</span><span class="s3">&quot;scopes&quot;</span><span class="s2">);</span>
		<span class="s4">const </span><span class="s2">cachedScope = cache.get(currentNode);</span>

		<span class="s4">if </span><span class="s2">(cachedScope) {</span>
			<span class="s4">return </span><span class="s2">cachedScope;</span>
		<span class="s2">}</span>

		<span class="s0">// On Program node, get the outermost scope to avoid return Node.js special function scope or ES modules scope.</span>
		<span class="s4">const </span><span class="s2">inner = currentNode.type !== </span><span class="s3">&quot;Program&quot;</span><span class="s2">;</span>

		<span class="s4">for </span><span class="s2">(</span><span class="s4">let </span><span class="s2">node = currentNode; node; node = node.parent) {</span>
			<span class="s4">const </span><span class="s2">scope = </span><span class="s4">this</span><span class="s2">.scopeManager.acquire(node, inner);</span>

			<span class="s4">if </span><span class="s2">(scope) {</span>
				<span class="s4">if </span><span class="s2">(scope.type === </span><span class="s3">&quot;function-expression-name&quot;</span><span class="s2">) {</span>
					<span class="s2">cache.set(currentNode, scope.childScopes[</span><span class="s5">0</span><span class="s2">]);</span>
					<span class="s4">return </span><span class="s2">scope.childScopes[</span><span class="s5">0</span><span class="s2">];</span>
				<span class="s2">}</span>

				<span class="s2">cache.set(currentNode, scope);</span>
				<span class="s4">return </span><span class="s2">scope;</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s2">cache.set(currentNode, </span><span class="s4">this</span><span class="s2">.scopeManager.scopes[</span><span class="s5">0</span><span class="s2">]);</span>
		<span class="s4">return this</span><span class="s2">.scopeManager.scopes[</span><span class="s5">0</span><span class="s2">];</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Get the variables that `node` defines.</span>
	 <span class="s0">* This is a convenience method that passes through</span>
	 <span class="s0">* to the same method on the `scopeManager`.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node for which the variables are obtained.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Array&lt;Variable&gt;} An array of variable nodes representing</span>
	 <span class="s0">*      the variables that `node` defines.</span>
	 <span class="s0">*/</span>
	<span class="s2">getDeclaredVariables(node) {</span>
		<span class="s4">return this</span><span class="s2">.scopeManager.getDeclaredVariables(node);</span>
	<span class="s2">}</span>

	<span class="s0">/* eslint-disable class-methods-use-this -- node is owned by SourceCode */</span>
	<span class="s0">/**</span>
	 <span class="s0">* Gets all the ancestors of a given node</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Array&lt;ASTNode&gt;} All the ancestor nodes in the AST, not including the provided node, starting</span>
	 <span class="s0">* from the root node at index 0 and going inwards to the parent node.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When `node` is missing.</span>
	 <span class="s0">*/</span>
	<span class="s2">getAncestors(node) {</span>
		<span class="s4">if </span><span class="s2">(!node) {</span>
			<span class="s4">throw new </span><span class="s2">TypeError(</span><span class="s3">&quot;Missing required argument: node.&quot;</span><span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s4">const </span><span class="s2">ancestorsStartingAtParent = [];</span>

		<span class="s4">for </span><span class="s2">(</span><span class="s4">let </span><span class="s2">ancestor = node.parent; ancestor; ancestor = ancestor.parent) {</span>
			<span class="s2">ancestorsStartingAtParent.push(ancestor);</span>
		<span class="s2">}</span>

		<span class="s4">return </span><span class="s2">ancestorsStartingAtParent.reverse();</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Determines whether the given identifier node is a reference to a global variable.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node `Identifier` node to check.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the identifier is a reference to a global variable.</span>
	 <span class="s0">*/</span>
	<span class="s2">isGlobalReference(node) {</span>
		<span class="s4">if </span><span class="s2">(!node) {</span>
			<span class="s4">throw new </span><span class="s2">TypeError(</span><span class="s3">&quot;Missing required argument: node.&quot;</span><span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s4">const </span><span class="s2">cache = </span><span class="s4">this</span><span class="s2">[caches].get(</span><span class="s3">&quot;isGlobalReference&quot;</span><span class="s2">);</span>

		<span class="s4">if </span><span class="s2">(cache.has(node)) {</span>
			<span class="s4">return </span><span class="s2">cache.get(node);</span>
		<span class="s2">}</span>

		<span class="s4">if </span><span class="s2">(node.type !== </span><span class="s3">&quot;Identifier&quot;</span><span class="s2">) {</span>
			<span class="s2">cache.set(node, </span><span class="s4">false</span><span class="s2">);</span>
			<span class="s4">return false</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s4">const </span><span class="s2">variable = </span><span class="s4">this</span><span class="s2">.scopeManager.scopes[</span><span class="s5">0</span><span class="s2">].set.get(node.name);</span>

		<span class="s4">if </span><span class="s2">(!variable || variable.defs.length &gt; </span><span class="s5">0</span><span class="s2">) {</span>
			<span class="s2">cache.set(node, </span><span class="s4">false</span><span class="s2">);</span>
			<span class="s4">return false</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s4">const </span><span class="s2">result = variable.references.some(</span>
			<span class="s2">({ identifier }) =&gt; identifier === node,</span>
		<span class="s2">);</span>
		<span class="s2">cache.set(node, result);</span>
		<span class="s4">return </span><span class="s2">result;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Returns the location of the given node or token.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode|Token} nodeOrToken The node or token to get the location of.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{SourceLocation} The location of the node or token.</span>
	 <span class="s0">*/</span>
	<span class="s2">getLoc(nodeOrToken) {</span>
		<span class="s4">return </span><span class="s2">nodeOrToken.loc;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Returns the range of the given node or token.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode|Token} nodeOrToken The node or token to get the range of.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{[number, number]} The range of the node or token.</span>
	 <span class="s0">*/</span>
	<span class="s2">getRange(nodeOrToken) {</span>
		<span class="s4">return </span><span class="s2">nodeOrToken.range;</span>
	<span class="s2">}</span>

	<span class="s0">/* eslint-enable class-methods-use-this -- node is owned by SourceCode */</span>

	<span class="s0">/**</span>
	 <span class="s0">* Marks a variable as used in the current scope</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} name The name of the variable to mark as used.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} [refNode] The closest node to the variable reference.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the variable was found and marked as used, false if not.</span>
	 <span class="s0">*/</span>
	<span class="s2">markVariableAsUsed(name, refNode = </span><span class="s4">this</span><span class="s2">.ast) {</span>
		<span class="s4">const </span><span class="s2">currentScope = </span><span class="s4">this</span><span class="s2">.getScope(refNode);</span>
		<span class="s4">let </span><span class="s2">initialScope = currentScope;</span>

		<span class="s0">/* 
         * When we are in an ESM or CommonJS module, we need to start searching 
         * from the top-level scope, not the global scope. For ESM the top-level 
         * scope is the module scope; for CommonJS the top-level scope is the 
         * outer function scope. 
         * 
         * Without this check, we might miss a variable declared with `var` at 
         * the top-level because it won't exist in the global scope. 
         */</span>
		<span class="s4">if </span><span class="s2">(</span>
			<span class="s2">currentScope.type === </span><span class="s3">&quot;global&quot; </span><span class="s2">&amp;&amp;</span>
			<span class="s2">currentScope.childScopes.length &gt; </span><span class="s5">0 </span><span class="s2">&amp;&amp;</span>
			<span class="s0">// top-level scopes refer to a `Program` node</span>
			<span class="s2">currentScope.childScopes[</span><span class="s5">0</span><span class="s2">].block === </span><span class="s4">this</span><span class="s2">.ast</span>
		<span class="s2">) {</span>
			<span class="s2">initialScope = currentScope.childScopes[</span><span class="s5">0</span><span class="s2">];</span>
		<span class="s2">}</span>

		<span class="s4">for </span><span class="s2">(</span><span class="s4">let </span><span class="s2">scope = initialScope; scope; scope = scope.upper) {</span>
			<span class="s4">const </span><span class="s2">variable = scope.variables.find(</span>
				<span class="s2">scopeVar =&gt; scopeVar.name === name,</span>
			<span class="s2">);</span>

			<span class="s4">if </span><span class="s2">(variable) {</span>
				<span class="s2">variable.eslintUsed = </span><span class="s4">true</span><span class="s2">;</span>
				<span class="s4">return true</span><span class="s2">;</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s4">return false</span><span class="s2">;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Returns an array of all inline configuration nodes found in the</span>
	 <span class="s0">* source code.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Array&lt;Token&gt;} An array of all inline configuration nodes.</span>
	 <span class="s0">*/</span>
	<span class="s2">getInlineConfigNodes() {</span>
		<span class="s0">// check the cache first</span>
		<span class="s4">let </span><span class="s2">configNodes = </span><span class="s4">this</span><span class="s2">[caches].get(</span><span class="s3">&quot;configNodes&quot;</span><span class="s2">);</span>

		<span class="s4">if </span><span class="s2">(configNodes) {</span>
			<span class="s4">return </span><span class="s2">configNodes;</span>
		<span class="s2">}</span>

		<span class="s0">// calculate fresh config nodes</span>
		<span class="s2">configNodes = </span><span class="s4">this</span><span class="s2">.ast.comments.filter(comment =&gt; {</span>
			<span class="s0">// shebang comments are never directives</span>
			<span class="s4">if </span><span class="s2">(comment.type === </span><span class="s3">&quot;Shebang&quot;</span><span class="s2">) {</span>
				<span class="s4">return false</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s4">const </span><span class="s2">directive = commentParser.parseDirective(comment.value);</span>

			<span class="s4">if </span><span class="s2">(!directive) {</span>
				<span class="s4">return false</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(!directivesPattern.test(directive.label)) {</span>
				<span class="s4">return false</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s0">// only certain comment types are supported as line comments</span>
			<span class="s4">return </span><span class="s2">(</span>
				<span class="s2">comment.type !== </span><span class="s3">&quot;Line&quot; </span><span class="s2">||</span>
				<span class="s2">!!</span><span class="s6">/^eslint-disable-(?:next-)?line$/u</span><span class="s2">.test(directive.label)</span>
			<span class="s2">);</span>
		<span class="s2">});</span>

		<span class="s4">this</span><span class="s2">[caches].set(</span><span class="s3">&quot;configNodes&quot;</span><span class="s2">, configNodes);</span>

		<span class="s4">return </span><span class="s2">configNodes;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Returns an all directive nodes that enable or disable rules along with any problems</span>
	 <span class="s0">* encountered while parsing the directives.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{{problems:Array&lt;Problem&gt;,directives:Array&lt;Directive&gt;}} Information</span>
	 <span class="s0">*      that ESLint needs to further process the directives.</span>
	 <span class="s0">*/</span>
	<span class="s2">getDisableDirectives() {</span>
		<span class="s0">// check the cache first</span>
		<span class="s4">const </span><span class="s2">cachedDirectives = </span><span class="s4">this</span><span class="s2">[caches].get(</span><span class="s3">&quot;disableDirectives&quot;</span><span class="s2">);</span>

		<span class="s4">if </span><span class="s2">(cachedDirectives) {</span>
			<span class="s4">return </span><span class="s2">cachedDirectives;</span>
		<span class="s2">}</span>

		<span class="s4">const </span><span class="s2">problems = [];</span>
		<span class="s4">const </span><span class="s2">directives = [];</span>

		<span class="s4">this</span><span class="s2">.getInlineConfigNodes().forEach(comment =&gt; {</span>
			<span class="s0">// Step 1: Parse the directive</span>
			<span class="s4">const </span><span class="s2">{</span>
				<span class="s2">label,</span>
				<span class="s2">value,</span>
				<span class="s2">justification: justificationPart,</span>
			<span class="s2">} = commentParser.parseDirective(comment.value);</span>

			<span class="s0">// Step 2: Extract the directive value</span>
			<span class="s4">const </span><span class="s2">lineCommentSupported =</span>
				<span class="s6">/^eslint-disable-(?:next-)?line$/u</span><span class="s2">.test(label);</span>

			<span class="s4">if </span><span class="s2">(comment.type === </span><span class="s3">&quot;Line&quot; </span><span class="s2">&amp;&amp; !lineCommentSupported) {</span>
				<span class="s4">return</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s0">// Step 3: Validate the directive does not span multiple lines</span>
			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">label === </span><span class="s3">&quot;eslint-disable-line&quot; </span><span class="s2">&amp;&amp;</span>
				<span class="s2">comment.loc.start.line !== comment.loc.end.line</span>
			<span class="s2">) {</span>
				<span class="s4">const </span><span class="s2">message = </span><span class="s3">`</span><span class="s2">${label} </span><span class="s3">comment should not span multiple lines.`</span><span class="s2">;</span>

				<span class="s2">problems.push({</span>
					<span class="s2">ruleId: </span><span class="s4">null</span><span class="s2">,</span>
					<span class="s2">message,</span>
					<span class="s2">loc: comment.loc,</span>
				<span class="s2">});</span>
				<span class="s4">return</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s0">// Step 4: Extract the directive value and create the Directive object</span>
			<span class="s4">switch </span><span class="s2">(label) {</span>
				<span class="s4">case </span><span class="s3">&quot;eslint-disable&quot;</span><span class="s2">:</span>
				<span class="s4">case </span><span class="s3">&quot;eslint-enable&quot;</span><span class="s2">:</span>
				<span class="s4">case </span><span class="s3">&quot;eslint-disable-next-line&quot;</span><span class="s2">:</span>
				<span class="s4">case </span><span class="s3">&quot;eslint-disable-line&quot;</span><span class="s2">: {</span>
					<span class="s4">const </span><span class="s2">directiveType = label.slice(</span><span class="s3">&quot;eslint-&quot;</span><span class="s2">.length);</span>

					<span class="s2">directives.push(</span>
						<span class="s4">new </span><span class="s2">Directive({</span>
							<span class="s2">type: directiveType,</span>
							<span class="s2">node: comment,</span>
							<span class="s2">value,</span>
							<span class="s2">justification: justificationPart,</span>
						<span class="s2">}),</span>
					<span class="s2">);</span>
				<span class="s2">}</span>

				<span class="s0">// no default</span>
			<span class="s2">}</span>
		<span class="s2">});</span>

		<span class="s4">const </span><span class="s2">result = { problems, directives };</span>

		<span class="s4">this</span><span class="s2">[caches].set(</span><span class="s3">&quot;disableDirectives&quot;</span><span class="s2">, result);</span>

		<span class="s4">return </span><span class="s2">result;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Applies language options sent in from the core.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} languageOptions The language options for this run.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">applyLanguageOptions(languageOptions) {</span>
		<span class="s0">/* 
         * Add configured globals and language globals 
         * 
         * Using Object.assign instead of object spread for performance reasons 
         * https://github.com/eslint/eslint/issues/16302 
         */</span>
		<span class="s4">const </span><span class="s2">configGlobals = Object.assign(</span>
			<span class="s2">Object.create(</span><span class="s4">null</span><span class="s2">), </span><span class="s0">// https://github.com/eslint/eslint/issues/18363</span>
			<span class="s2">getGlobalsForEcmaVersion(languageOptions.ecmaVersion),</span>
			<span class="s2">languageOptions.sourceType === </span><span class="s3">&quot;commonjs&quot;</span>
				<span class="s2">? globals.commonjs</span>
				<span class="s2">: </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
			<span class="s2">languageOptions.globals,</span>
		<span class="s2">);</span>
		<span class="s4">const </span><span class="s2">varsCache = </span><span class="s4">this</span><span class="s2">[caches].get(</span><span class="s3">&quot;vars&quot;</span><span class="s2">);</span>

		<span class="s2">varsCache.set(</span><span class="s3">&quot;configGlobals&quot;</span><span class="s2">, configGlobals);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Applies configuration found inside of the source code. This method is only</span>
	 <span class="s0">* called when ESLint is running with inline configuration allowed.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{{problems:Array&lt;Problem&gt;,configs:{config:FlatConfigArray,loc:Location}}} Information</span>
	 <span class="s0">*      that ESLint needs to further process the inline configuration.</span>
	 <span class="s0">*/</span>
	<span class="s2">applyInlineConfig() {</span>
		<span class="s4">const </span><span class="s2">problems = [];</span>
		<span class="s4">const </span><span class="s2">configs = [];</span>
		<span class="s4">const </span><span class="s2">exportedVariables = {};</span>
		<span class="s4">const </span><span class="s2">inlineGlobals = Object.create(</span><span class="s4">null</span><span class="s2">);</span>

		<span class="s4">this</span><span class="s2">.getInlineConfigNodes().forEach(comment =&gt; {</span>
			<span class="s4">const </span><span class="s2">{ label, value } = commentParser.parseDirective(</span>
				<span class="s2">comment.value,</span>
			<span class="s2">);</span>

			<span class="s4">switch </span><span class="s2">(label) {</span>
				<span class="s4">case </span><span class="s3">&quot;exported&quot;</span><span class="s2">:</span>
					<span class="s2">Object.assign(</span>
						<span class="s2">exportedVariables,</span>
						<span class="s2">commentParser.parseListConfig(value),</span>
					<span class="s2">);</span>
					<span class="s4">break</span><span class="s2">;</span>

				<span class="s4">case </span><span class="s3">&quot;globals&quot;</span><span class="s2">:</span>
				<span class="s4">case </span><span class="s3">&quot;global&quot;</span><span class="s2">:</span>
					<span class="s4">for </span><span class="s2">(</span><span class="s4">const </span><span class="s2">[id, idSetting] of Object.entries(</span>
						<span class="s2">commentParser.parseStringConfig(value),</span>
					<span class="s2">)) {</span>
						<span class="s4">let </span><span class="s2">normalizedValue;</span>

						<span class="s4">try </span><span class="s2">{</span>
							<span class="s2">normalizedValue = normalizeConfigGlobal(idSetting);</span>
						<span class="s2">} </span><span class="s4">catch </span><span class="s2">(err) {</span>
							<span class="s2">problems.push({</span>
								<span class="s2">ruleId: </span><span class="s4">null</span><span class="s2">,</span>
								<span class="s2">loc: comment.loc,</span>
								<span class="s2">message: err.message,</span>
							<span class="s2">});</span>
							<span class="s4">continue</span><span class="s2">;</span>
						<span class="s2">}</span>

						<span class="s4">if </span><span class="s2">(inlineGlobals[id]) {</span>
							<span class="s2">inlineGlobals[id].comments.push(comment);</span>
							<span class="s2">inlineGlobals[id].value = normalizedValue;</span>
						<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
							<span class="s2">inlineGlobals[id] = {</span>
								<span class="s2">comments: [comment],</span>
								<span class="s2">value: normalizedValue,</span>
							<span class="s2">};</span>
						<span class="s2">}</span>
					<span class="s2">}</span>
					<span class="s4">break</span><span class="s2">;</span>

				<span class="s4">case </span><span class="s3">&quot;eslint&quot;</span><span class="s2">: {</span>
					<span class="s4">const </span><span class="s2">parseResult =</span>
						<span class="s2">commentParser.parseJSONLikeConfig(value);</span>

					<span class="s4">if </span><span class="s2">(parseResult.ok) {</span>
						<span class="s2">configs.push({</span>
							<span class="s2">config: {</span>
								<span class="s2">rules: parseResult.config,</span>
							<span class="s2">},</span>
							<span class="s2">loc: comment.loc,</span>
						<span class="s2">});</span>
					<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
						<span class="s2">problems.push({</span>
							<span class="s2">ruleId: </span><span class="s4">null</span><span class="s2">,</span>
							<span class="s2">loc: comment.loc,</span>
							<span class="s2">message: parseResult.error.message,</span>
						<span class="s2">});</span>
					<span class="s2">}</span>

					<span class="s4">break</span><span class="s2">;</span>
				<span class="s2">}</span>

				<span class="s0">// no default</span>
			<span class="s2">}</span>
		<span class="s2">});</span>

		<span class="s0">// save all the new variables for later</span>
		<span class="s4">const </span><span class="s2">varsCache = </span><span class="s4">this</span><span class="s2">[caches].get(</span><span class="s3">&quot;vars&quot;</span><span class="s2">);</span>

		<span class="s2">varsCache.set(</span><span class="s3">&quot;inlineGlobals&quot;</span><span class="s2">, inlineGlobals);</span>
		<span class="s2">varsCache.set(</span><span class="s3">&quot;exportedVariables&quot;</span><span class="s2">, exportedVariables);</span>

		<span class="s4">return </span><span class="s2">{</span>
			<span class="s2">configs,</span>
			<span class="s2">problems,</span>
		<span class="s2">};</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Called by ESLint core to indicate that it has finished providing</span>
	 <span class="s0">* information. We now add in all the missing variables and ensure that</span>
	 <span class="s0">* state-changing methods cannot be called by rules.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">finalize() {</span>
		<span class="s4">const </span><span class="s2">varsCache = </span><span class="s4">this</span><span class="s2">[caches].get(</span><span class="s3">&quot;vars&quot;</span><span class="s2">);</span>
		<span class="s4">const </span><span class="s2">configGlobals = varsCache.get(</span><span class="s3">&quot;configGlobals&quot;</span><span class="s2">);</span>
		<span class="s4">const </span><span class="s2">inlineGlobals = varsCache.get(</span><span class="s3">&quot;inlineGlobals&quot;</span><span class="s2">);</span>
		<span class="s4">const </span><span class="s2">exportedVariables = varsCache.get(</span><span class="s3">&quot;exportedVariables&quot;</span><span class="s2">);</span>
		<span class="s4">const </span><span class="s2">globalScope = </span><span class="s4">this</span><span class="s2">.scopeManager.scopes[</span><span class="s5">0</span><span class="s2">];</span>

		<span class="s2">addDeclaredGlobals(globalScope, configGlobals, inlineGlobals);</span>

		<span class="s4">if </span><span class="s2">(exportedVariables) {</span>
			<span class="s2">markExportedVariables(globalScope, exportedVariables);</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Traverse the source code and return the steps that were taken.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Array&lt;TraversalStep&gt;} The steps that were taken while traversing the source code.</span>
	 <span class="s0">*/</span>
	<span class="s2">traverse() {</span>
		<span class="s0">// Because the AST doesn't mutate, we can cache the steps</span>
		<span class="s4">if </span><span class="s2">(</span><span class="s4">this</span><span class="s2">.#steps) {</span>
			<span class="s4">return this</span><span class="s2">.#steps;</span>
		<span class="s2">}</span>

		<span class="s4">const </span><span class="s2">steps = (</span><span class="s4">this</span><span class="s2">.#steps = []);</span>

		<span class="s0">/* 
         * This logic works for any AST, not just ESTree. Because ESLint has allowed 
         * custom parsers to return any AST, we need to ensure that the traversal 
         * logic works for any AST. 
         */</span>
		<span class="s4">let </span><span class="s2">analyzer = {</span>
			<span class="s2">enterNode(node) {</span>
				<span class="s2">steps.push(</span>
					<span class="s4">new </span><span class="s2">VisitNodeStep({</span>
						<span class="s2">target: node,</span>
						<span class="s2">phase: </span><span class="s5">1</span><span class="s2">,</span>
						<span class="s2">args: [node, node.parent],</span>
					<span class="s2">}),</span>
				<span class="s2">);</span>
			<span class="s2">},</span>
			<span class="s2">leaveNode(node) {</span>
				<span class="s2">steps.push(</span>
					<span class="s4">new </span><span class="s2">VisitNodeStep({</span>
						<span class="s2">target: node,</span>
						<span class="s2">phase: </span><span class="s5">2</span><span class="s2">,</span>
						<span class="s2">args: [node, node.parent],</span>
					<span class="s2">}),</span>
				<span class="s2">);</span>
			<span class="s2">},</span>
			<span class="s2">emit(eventName, args) {</span>
				<span class="s2">steps.push(</span>
					<span class="s4">new </span><span class="s2">CallMethodStep({</span>
						<span class="s2">target: eventName,</span>
						<span class="s2">args,</span>
					<span class="s2">}),</span>
				<span class="s2">);</span>
			<span class="s2">},</span>
		<span class="s2">};</span>

		<span class="s0">/* 
         * We do code path analysis for ESTree only. Code path analysis is not 
         * necessary for other ASTs, and it's also not possible to do for other 
         * ASTs because the necessary information is not available. 
         * 
         * Generally speaking, we can tell that the AST is an ESTree if it has a 
         * Program node at the top level. This is not a perfect heuristic, but it 
         * is good enough for now. 
         */</span>
		<span class="s4">if </span><span class="s2">(</span><span class="s4">this</span><span class="s2">.isESTree) {</span>
			<span class="s2">analyzer = </span><span class="s4">new </span><span class="s2">CodePathAnalyzer(analyzer);</span>
		<span class="s2">}</span>

		<span class="s0">/* 
         * The actual AST traversal is done by the `Traverser` class. This class 
         * is responsible for walking the AST and calling the appropriate methods 
         * on the `analyzer` object, which is appropriate for the given AST. 
         */</span>
		<span class="s2">Traverser.traverse(</span><span class="s4">this</span><span class="s2">.ast, {</span>
			<span class="s2">enter(node, parent) {</span>
				<span class="s0">// save the parent node on a property for backwards compatibility</span>
				<span class="s2">node.parent = parent;</span>

				<span class="s2">analyzer.enterNode(node);</span>
			<span class="s2">},</span>
			<span class="s2">leave(node) {</span>
				<span class="s2">analyzer.leaveNode(node);</span>
			<span class="s2">},</span>
			<span class="s2">visitorKeys: </span><span class="s4">this</span><span class="s2">.visitorKeys,</span>
		<span class="s2">});</span>

		<span class="s4">return </span><span class="s2">steps;</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s2">module.exports = SourceCode;</span>
</pre>
</body>
</html>