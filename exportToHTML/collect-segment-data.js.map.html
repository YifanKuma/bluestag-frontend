<html>
<head>
<title>collect-segment-data.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
collect-segment-data.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/app-render/collect-segment-data.tsx&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">CacheNodeSeedData,</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">InitialRSCPayload,</span><span class="s3">\n  </span><span class="s1">DynamicParamTypesShort,</span><span class="s3">\n</span><span class="s1">} from './types'</span><span class="s3">\n</span><span class="s1">import type { ManifestNode } from '../../build/webpack/plugins/flight-manifest-plugin'</span><span class="s3">\n\n</span><span class="s1">// eslint-disable-next-line import/no-extraneous-dependencies</span><span class="s3">\n</span><span class="s1">import { createFromReadableStream } from 'react-server-dom-webpack/client'</span><span class="s3">\n</span><span class="s1">// eslint-disable-next-line import/no-extraneous-dependencies</span><span class="s3">\n</span><span class="s1">import { unstable_prerender as prerender } from 'react-server-dom-webpack/static'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">streamFromBuffer,</span><span class="s3">\n  </span><span class="s1">streamToBuffer,</span><span class="s3">\n</span><span class="s1">} from '../stream-utils/node-web-streams-helper'</span><span class="s3">\n</span><span class="s1">import { waitAtLeastOneReactRenderTask } from '../../lib/scheduler'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">HeadData,</span><span class="s3">\n  </span><span class="s1">LoadingModuleData,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">type SegmentRequestKey,</span><span class="s3">\n  </span><span class="s1">createSegmentRequestKeyPart,</span><span class="s3">\n  </span><span class="s1">appendSegmentRequestKeyPart,</span><span class="s3">\n  </span><span class="s1">ROOT_SEGMENT_REQUEST_KEY,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/segment-cache/segment-value-encoding'</span><span class="s3">\n</span><span class="s1">import { getDigestForWellKnownError } from './create-error-handler'</span><span class="s3">\n\n</span><span class="s1">// Contains metadata about the route tree. The client must fetch this before</span><span class="s3">\n</span><span class="s1">// it can fetch any actual segment data.</span><span class="s3">\n</span><span class="s1">export type RootTreePrefetch = {</span><span class="s3">\n  </span><span class="s1">buildId: string</span><span class="s3">\n  </span><span class="s1">tree: TreePrefetch</span><span class="s3">\n  </span><span class="s1">head: HeadData</span><span class="s3">\n  </span><span class="s1">isHeadPartial: boolean</span><span class="s3">\n  </span><span class="s1">staleTime: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type TreePrefetch = {</span><span class="s3">\n  </span><span class="s1">name: string</span><span class="s3">\n  </span><span class="s1">paramType: DynamicParamTypesShort | null</span><span class="s3">\n  </span><span class="s1">// TODO: When clientParamParsing is enabled, this field is always null.</span><span class="s3">\n  </span><span class="s1">// Instead we parse the param on the client, allowing us to omit it from</span><span class="s3">\n  </span><span class="s1">// the prefetch response and increase its cacheability. Remove this field</span><span class="s3">\n  </span><span class="s1">// once clientParamParsing is enabled everywhere.</span><span class="s3">\n  </span><span class="s1">paramKey: string | null</span><span class="s3">\n\n  </span><span class="s1">// Child segments.</span><span class="s3">\n  </span><span class="s1">slots: null | {</span><span class="s3">\n    </span><span class="s1">[parallelRouteKey: string]: TreePrefetch</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Extra fields that only exist so we can reconstruct a FlightRouterState on</span><span class="s3">\n  </span><span class="s1">// the client. We may be able to unify TreePrefetch and FlightRouterState</span><span class="s3">\n  </span><span class="s1">// after some refactoring, but in the meantime it would be wasteful to add a</span><span class="s3">\n  </span><span class="s1">// bunch of new prefetch-only fields to FlightRouterState. So think of</span><span class="s3">\n  </span><span class="s1">// TreePrefetch as a superset of FlightRouterState.</span><span class="s3">\n  </span><span class="s1">isRootLayout: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type SegmentPrefetch = {</span><span class="s3">\n  </span><span class="s1">buildId: string</span><span class="s3">\n  </span><span class="s1">rsc: React.ReactNode | null</span><span class="s3">\n  </span><span class="s1">loading: LoadingModuleData | Promise&lt;LoadingModuleData&gt;</span><span class="s3">\n  </span><span class="s1">isPartial: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const filterStackFrame =</span><span class="s3">\n  </span><span class="s1">process.env.NODE_ENV !== 'production'</span><span class="s3">\n    </span><span class="s1">? (require('../lib/source-maps') as typeof import('../lib/source-maps'))</span><span class="s3">\n        </span><span class="s1">.filterStackFrameDEV</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n</span><span class="s1">const findSourceMapURL =</span><span class="s3">\n  </span><span class="s1">process.env.NODE_ENV !== 'production'</span><span class="s3">\n    </span><span class="s1">? (require('../lib/source-maps') as typeof import('../lib/source-maps'))</span><span class="s3">\n        </span><span class="s1">.findSourceMapURLDEV</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n\n</span><span class="s1">function onSegmentPrerenderError(error: unknown) {</span><span class="s3">\n  </span><span class="s1">const digest = getDigestForWellKnownError(error)</span><span class="s3">\n  </span><span class="s1">if (digest) {</span><span class="s3">\n    </span><span class="s1">return digest</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// We don't need to log the errors because we would have already done that</span><span class="s3">\n  </span><span class="s1">// when generating the original Flight stream for the whole page.</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function collectSegmentData(</span><span class="s3">\n  </span><span class="s1">isClientParamParsingEnabled: boolean,</span><span class="s3">\n  </span><span class="s1">fullPageDataBuffer: Buffer,</span><span class="s3">\n  </span><span class="s1">staleTime: number,</span><span class="s3">\n  </span><span class="s1">clientModules: ManifestNode,</span><span class="s3">\n  </span><span class="s1">serverConsumerManifest: any</span><span class="s3">\n</span><span class="s1">): Promise&lt;Map&lt;SegmentRequestKey, Buffer&gt;&gt; {</span><span class="s3">\n  </span><span class="s1">// Traverse the router tree and generate a prefetch response for each segment.</span><span class="s3">\n\n  </span><span class="s1">// A mutable map to collect the results as we traverse the route tree.</span><span class="s3">\n  </span><span class="s1">const resultMap = new Map&lt;SegmentRequestKey, Buffer&gt;()</span><span class="s3">\n\n  </span><span class="s1">// Before we start, warm up the module cache by decoding the page data once.</span><span class="s3">\n  </span><span class="s1">// Then we can assume that any remaining async tasks that occur the next time</span><span class="s3">\n  </span><span class="s1">// are due to hanging promises caused by dynamic data access. Note we only</span><span class="s3">\n  </span><span class="s1">// have to do this once per page, not per individual segment.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">await createFromReadableStream(streamFromBuffer(fullPageDataBuffer), {</span><span class="s3">\n      </span><span class="s1">findSourceMapURL,</span><span class="s3">\n      </span><span class="s1">serverConsumerManifest,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">await waitAtLeastOneReactRenderTask()</span><span class="s3">\n  </span><span class="s1">} catch {}</span><span class="s3">\n\n  </span><span class="s1">// Create an abort controller that we'll use to stop the stream.</span><span class="s3">\n  </span><span class="s1">const abortController = new AbortController()</span><span class="s3">\n  </span><span class="s1">const onCompletedProcessingRouteTree = async () =&gt; {</span><span class="s3">\n    </span><span class="s1">// Since all we're doing is decoding and re-encoding a cached prerender, if</span><span class="s3">\n    </span><span class="s1">// serializing the stream takes longer than a microtask, it must because of</span><span class="s3">\n    </span><span class="s1">// hanging promises caused by dynamic data.</span><span class="s3">\n    </span><span class="s1">await waitAtLeastOneReactRenderTask()</span><span class="s3">\n    </span><span class="s1">abortController.abort()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Generate a stream for the route tree prefetch. While we're walking the</span><span class="s3">\n  </span><span class="s1">// tree, we'll also spawn additional tasks to generate the segment prefetches.</span><span class="s3">\n  </span><span class="s1">// The promises for these tasks are pushed to a mutable array that we will</span><span class="s3">\n  </span><span class="s1">// await once the route tree is fully rendered.</span><span class="s3">\n  </span><span class="s1">const segmentTasks: Array&lt;Promise&lt;[SegmentRequestKey, Buffer]&gt;&gt; = []</span><span class="s3">\n  </span><span class="s1">const { prelude: treeStream } = await prerender(</span><span class="s3">\n    </span><span class="s1">// RootTreePrefetch is not a valid return type for a React component, but</span><span class="s3">\n    </span><span class="s1">// we need to use a component so that when we decode the original stream</span><span class="s3">\n    </span><span class="s1">// inside of it, the side effects are transferred to the new stream.</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error</span><span class="s3">\n    </span><span class="s1">&lt;PrefetchTreeData</span><span class="s3">\n      </span><span class="s1">isClientParamParsingEnabled={isClientParamParsingEnabled}</span><span class="s3">\n      </span><span class="s1">fullPageDataBuffer={fullPageDataBuffer}</span><span class="s3">\n      </span><span class="s1">serverConsumerManifest={serverConsumerManifest}</span><span class="s3">\n      </span><span class="s1">clientModules={clientModules}</span><span class="s3">\n      </span><span class="s1">staleTime={staleTime}</span><span class="s3">\n      </span><span class="s1">segmentTasks={segmentTasks}</span><span class="s3">\n      </span><span class="s1">onCompletedProcessingRouteTree={onCompletedProcessingRouteTree}</span><span class="s3">\n    </span><span class="s1">/&gt;,</span><span class="s3">\n    </span><span class="s1">clientModules,</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">filterStackFrame,</span><span class="s3">\n      </span><span class="s1">signal: abortController.signal,</span><span class="s3">\n      </span><span class="s1">onError: onSegmentPrerenderError,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// Write the route tree to a special `/_tree` segment.</span><span class="s3">\n  </span><span class="s1">const treeBuffer = await streamToBuffer(treeStream)</span><span class="s3">\n  </span><span class="s1">resultMap.set('/_tree' as SegmentRequestKey, treeBuffer)</span><span class="s3">\n\n  </span><span class="s1">// Now that we've finished rendering the route tree, all the segment tasks</span><span class="s3">\n  </span><span class="s1">// should have been spawned. Await them in parallel and write the segment</span><span class="s3">\n  </span><span class="s1">// prefetches to the result map.</span><span class="s3">\n  </span><span class="s1">for (const [segmentPath, buffer] of await Promise.all(segmentTasks)) {</span><span class="s3">\n    </span><span class="s1">resultMap.set(segmentPath, buffer)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return resultMap</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function PrefetchTreeData({</span><span class="s3">\n  </span><span class="s1">isClientParamParsingEnabled,</span><span class="s3">\n  </span><span class="s1">fullPageDataBuffer,</span><span class="s3">\n  </span><span class="s1">serverConsumerManifest,</span><span class="s3">\n  </span><span class="s1">clientModules,</span><span class="s3">\n  </span><span class="s1">staleTime,</span><span class="s3">\n  </span><span class="s1">segmentTasks,</span><span class="s3">\n  </span><span class="s1">onCompletedProcessingRouteTree,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">isClientParamParsingEnabled: boolean</span><span class="s3">\n  </span><span class="s1">fullPageDataBuffer: Buffer</span><span class="s3">\n  </span><span class="s1">serverConsumerManifest: any</span><span class="s3">\n  </span><span class="s1">clientModules: ManifestNode</span><span class="s3">\n  </span><span class="s1">staleTime: number</span><span class="s3">\n  </span><span class="s1">segmentTasks: Array&lt;Promise&lt;[SegmentRequestKey, Buffer]&gt;&gt;</span><span class="s3">\n  </span><span class="s1">onCompletedProcessingRouteTree: () =&gt; void</span><span class="s3">\n</span><span class="s1">}): Promise&lt;RootTreePrefetch | null&gt; {</span><span class="s3">\n  </span><span class="s1">// We're currently rendering a Flight response for the route tree prefetch.</span><span class="s3">\n  </span><span class="s1">// Inside this component, decode the Flight stream for the whole page. This is</span><span class="s3">\n  </span><span class="s1">// a hack to transfer the side effects from the original Flight stream (e.g.</span><span class="s3">\n  </span><span class="s1">// Float preloads) onto the Flight stream for the tree prefetch.</span><span class="s3">\n  </span><span class="s1">// TODO: React needs a better way to do this. Needed for Server Actions, too.</span><span class="s3">\n  </span><span class="s1">const initialRSCPayload: InitialRSCPayload = await createFromReadableStream(</span><span class="s3">\n    </span><span class="s1">createUnclosingPrefetchStream(streamFromBuffer(fullPageDataBuffer)),</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">findSourceMapURL,</span><span class="s3">\n      </span><span class="s1">serverConsumerManifest,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const buildId = initialRSCPayload.b</span><span class="s3">\n\n  </span><span class="s1">// FlightDataPath is an unsound type, hence the additional checks.</span><span class="s3">\n  </span><span class="s1">const flightDataPaths = initialRSCPayload.f</span><span class="s3">\n  </span><span class="s1">if (flightDataPaths.length !== 1 &amp;&amp; flightDataPaths[0].length !== 3) {</span><span class="s3">\n    </span><span class="s1">console.error(</span><span class="s3">\n      </span><span class="s1">'Internal Next.js error: InitialRSCPayload does not match the expected ' +</span><span class="s3">\n        </span><span class="s1">'shape for a prerendered page during segment prefetch generation.'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const flightRouterState: FlightRouterState = flightDataPaths[0][0]</span><span class="s3">\n  </span><span class="s1">const seedData: CacheNodeSeedData = flightDataPaths[0][1]</span><span class="s3">\n  </span><span class="s1">const head: HeadData = flightDataPaths[0][2]</span><span class="s3">\n\n  </span><span class="s1">// Compute the route metadata tree by traversing the FlightRouterState. As we</span><span class="s3">\n  </span><span class="s1">// walk the tree, we will also spawn a task to produce a prefetch response for</span><span class="s3">\n  </span><span class="s1">// each segment.</span><span class="s3">\n  </span><span class="s1">const tree = collectSegmentDataImpl(</span><span class="s3">\n    </span><span class="s1">isClientParamParsingEnabled,</span><span class="s3">\n    </span><span class="s1">flightRouterState,</span><span class="s3">\n    </span><span class="s1">buildId,</span><span class="s3">\n    </span><span class="s1">seedData,</span><span class="s3">\n    </span><span class="s1">clientModules,</span><span class="s3">\n    </span><span class="s1">ROOT_SEGMENT_REQUEST_KEY,</span><span class="s3">\n    </span><span class="s1">segmentTasks</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const isHeadPartial = await isPartialRSCData(head, clientModules)</span><span class="s3">\n\n  </span><span class="s1">// Notify the abort controller that we're done processing the route tree.</span><span class="s3">\n  </span><span class="s1">// Anything async that happens after this point must be due to hanging</span><span class="s3">\n  </span><span class="s1">// promises in the original stream.</span><span class="s3">\n  </span><span class="s1">onCompletedProcessingRouteTree()</span><span class="s3">\n\n  </span><span class="s1">// Render the route tree to a special `/_tree` segment.</span><span class="s3">\n  </span><span class="s1">const treePrefetch: RootTreePrefetch = {</span><span class="s3">\n    </span><span class="s1">buildId,</span><span class="s3">\n    </span><span class="s1">tree,</span><span class="s3">\n    </span><span class="s1">head,</span><span class="s3">\n    </span><span class="s1">isHeadPartial,</span><span class="s3">\n    </span><span class="s1">staleTime,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return treePrefetch</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function collectSegmentDataImpl(</span><span class="s3">\n  </span><span class="s1">isClientParamParsingEnabled: boolean,</span><span class="s3">\n  </span><span class="s1">route: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">buildId: string,</span><span class="s3">\n  </span><span class="s1">seedData: CacheNodeSeedData | null,</span><span class="s3">\n  </span><span class="s1">clientModules: ManifestNode,</span><span class="s3">\n  </span><span class="s1">requestKey: SegmentRequestKey,</span><span class="s3">\n  </span><span class="s1">segmentTasks: Array&lt;Promise&lt;[string, Buffer]&gt;&gt;</span><span class="s3">\n</span><span class="s1">): TreePrefetch {</span><span class="s3">\n  </span><span class="s1">// Metadata about the segment. Sent as part of the tree prefetch. Null if</span><span class="s3">\n  </span><span class="s1">// there are no children.</span><span class="s3">\n  </span><span class="s1">let slotMetadata: { [parallelRouteKey: string]: TreePrefetch } | null = null</span><span class="s3">\n\n  </span><span class="s1">const children = route[1]</span><span class="s3">\n  </span><span class="s1">const seedDataChildren = seedData !== null ? seedData[2] : null</span><span class="s3">\n  </span><span class="s1">for (const parallelRouteKey in children) {</span><span class="s3">\n    </span><span class="s1">const childRoute = children[parallelRouteKey]</span><span class="s3">\n    </span><span class="s1">const childSegment = childRoute[0]</span><span class="s3">\n    </span><span class="s1">const childSeedData =</span><span class="s3">\n      </span><span class="s1">seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null</span><span class="s3">\n\n    </span><span class="s1">const childRequestKey = appendSegmentRequestKeyPart(</span><span class="s3">\n      </span><span class="s1">requestKey,</span><span class="s3">\n      </span><span class="s1">parallelRouteKey,</span><span class="s3">\n      </span><span class="s1">createSegmentRequestKeyPart(childSegment)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">const childTree = collectSegmentDataImpl(</span><span class="s3">\n      </span><span class="s1">isClientParamParsingEnabled,</span><span class="s3">\n      </span><span class="s1">childRoute,</span><span class="s3">\n      </span><span class="s1">buildId,</span><span class="s3">\n      </span><span class="s1">childSeedData,</span><span class="s3">\n      </span><span class="s1">clientModules,</span><span class="s3">\n      </span><span class="s1">childRequestKey,</span><span class="s3">\n      </span><span class="s1">segmentTasks</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">if (slotMetadata === null) {</span><span class="s3">\n      </span><span class="s1">slotMetadata = {}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">slotMetadata[parallelRouteKey] = childTree</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (seedData !== null) {</span><span class="s3">\n    </span><span class="s1">// Spawn a task to write the segment data to a new Flight stream.</span><span class="s3">\n    </span><span class="s1">segmentTasks.push(</span><span class="s3">\n      </span><span class="s1">// Since we're already in the middle of a render, wait until after the</span><span class="s3">\n      </span><span class="s1">// current task to escape the current rendering context.</span><span class="s3">\n      </span><span class="s1">waitAtLeastOneReactRenderTask().then(() =&gt;</span><span class="s3">\n        </span><span class="s1">renderSegmentPrefetch(buildId, seedData, requestKey, clientModules)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// This segment does not have any seed data. Skip generating a prefetch</span><span class="s3">\n    </span><span class="s1">// response for it. We'll still include it in the route tree, though.</span><span class="s3">\n    </span><span class="s1">// TODO: We should encode in the route tree whether a segment is missing</span><span class="s3">\n    </span><span class="s1">// so we don't attempt to fetch it for no reason. As of now this shouldn't</span><span class="s3">\n    </span><span class="s1">// ever happen in practice, though.</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const segment = route[0]</span><span class="s3">\n  </span><span class="s1">let name</span><span class="s3">\n  </span><span class="s1">let paramType: DynamicParamTypesShort | null = null</span><span class="s3">\n  </span><span class="s1">let paramKey: string | null = null</span><span class="s3">\n  </span><span class="s1">if (typeof segment === 'string') {</span><span class="s3">\n    </span><span class="s1">name = segment</span><span class="s3">\n    </span><span class="s1">paramKey = segment</span><span class="s3">\n    </span><span class="s1">paramType = null</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">name = segment[0]</span><span class="s3">\n    </span><span class="s1">paramKey = segment[1]</span><span class="s3">\n    </span><span class="s1">paramType = segment[2] as DynamicParamTypesShort</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Metadata about the segment. Sent to the client as part of the</span><span class="s3">\n  </span><span class="s1">// tree prefetch.</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">name,</span><span class="s3">\n    </span><span class="s1">paramType,</span><span class="s3">\n    </span><span class="s1">// This value is ommitted from the prefetch response when clientParamParsing</span><span class="s3">\n    </span><span class="s1">// is enabled. The flag only exists while we're testing the feature, in</span><span class="s3">\n    </span><span class="s1">// case there's a bug and we need to revert.</span><span class="s3">\n    </span><span class="s1">// TODO: Remove once clientParamParsing is enabled everywhere.</span><span class="s3">\n    </span><span class="s1">paramKey: isClientParamParsingEnabled ? null : paramKey,</span><span class="s3">\n    </span><span class="s1">slots: slotMetadata,</span><span class="s3">\n    </span><span class="s1">isRootLayout: route[4] === true,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function renderSegmentPrefetch(</span><span class="s3">\n  </span><span class="s1">buildId: string,</span><span class="s3">\n  </span><span class="s1">seedData: CacheNodeSeedData,</span><span class="s3">\n  </span><span class="s1">requestKey: SegmentRequestKey,</span><span class="s3">\n  </span><span class="s1">clientModules: ManifestNode</span><span class="s3">\n</span><span class="s1">): Promise&lt;[SegmentRequestKey, Buffer]&gt; {</span><span class="s3">\n  </span><span class="s1">// Render the segment data to a stream.</span><span class="s3">\n  </span><span class="s1">// In the future, this is where we can include additional metadata, like the</span><span class="s3">\n  </span><span class="s1">// stale time and cache tags.</span><span class="s3">\n  </span><span class="s1">const rsc = seedData[1]</span><span class="s3">\n  </span><span class="s1">const loading = seedData[3]</span><span class="s3">\n  </span><span class="s1">const segmentPrefetch: SegmentPrefetch = {</span><span class="s3">\n    </span><span class="s1">buildId,</span><span class="s3">\n    </span><span class="s1">rsc,</span><span class="s3">\n    </span><span class="s1">loading,</span><span class="s3">\n    </span><span class="s1">isPartial: await isPartialRSCData(rsc, clientModules),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Since all we're doing is decoding and re-encoding a cached prerender, if</span><span class="s3">\n  </span><span class="s1">// it takes longer than a microtask, it must because of hanging promises</span><span class="s3">\n  </span><span class="s1">// caused by dynamic data. Abort the stream at the end of the current task.</span><span class="s3">\n  </span><span class="s1">const abortController = new AbortController()</span><span class="s3">\n  </span><span class="s1">waitAtLeastOneReactRenderTask().then(() =&gt; abortController.abort())</span><span class="s3">\n  </span><span class="s1">const { prelude: segmentStream } = await prerender(</span><span class="s3">\n    </span><span class="s1">segmentPrefetch,</span><span class="s3">\n    </span><span class="s1">clientModules,</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">filterStackFrame,</span><span class="s3">\n      </span><span class="s1">signal: abortController.signal,</span><span class="s3">\n      </span><span class="s1">onError: onSegmentPrerenderError,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const segmentBuffer = await streamToBuffer(segmentStream)</span><span class="s3">\n  </span><span class="s1">if (requestKey === ROOT_SEGMENT_REQUEST_KEY) {</span><span class="s3">\n    </span><span class="s1">return ['/_index' as SegmentRequestKey, segmentBuffer]</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return [requestKey, segmentBuffer]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function isPartialRSCData(</span><span class="s3">\n  </span><span class="s1">rsc: React.ReactNode,</span><span class="s3">\n  </span><span class="s1">clientModules: ManifestNode</span><span class="s3">\n</span><span class="s1">): Promise&lt;boolean&gt; {</span><span class="s3">\n  </span><span class="s1">// We can determine if a segment contains only partial data if it takes longer</span><span class="s3">\n  </span><span class="s1">// than a task to encode, because dynamic data is encoded as an infinite</span><span class="s3">\n  </span><span class="s1">// promise. We must do this in a separate Flight prerender from the one that</span><span class="s3">\n  </span><span class="s1">// actually generates the prefetch stream because we need to include</span><span class="s3">\n  </span><span class="s1">// `isPartial` in the stream itself.</span><span class="s3">\n  </span><span class="s1">let isPartial = false</span><span class="s3">\n  </span><span class="s1">const abortController = new AbortController()</span><span class="s3">\n  </span><span class="s1">waitAtLeastOneReactRenderTask().then(() =&gt; {</span><span class="s3">\n    </span><span class="s1">// If we haven't yet finished the outer task, then it must be because we</span><span class="s3">\n    </span><span class="s1">// accessed dynamic data.</span><span class="s3">\n    </span><span class="s1">isPartial = true</span><span class="s3">\n    </span><span class="s1">abortController.abort()</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">await prerender(rsc, clientModules, {</span><span class="s3">\n    </span><span class="s1">filterStackFrame,</span><span class="s3">\n    </span><span class="s1">signal: abortController.signal,</span><span class="s3">\n    </span><span class="s1">onError() {},</span><span class="s3">\n    </span><span class="s1">onPostpone() {</span><span class="s3">\n      </span><span class="s1">// If something postponed, i.e. when Cache Components is not enabled, we can</span><span class="s3">\n      </span><span class="s1">// infer that the RSC data is partial.</span><span class="s3">\n      </span><span class="s1">isPartial = true</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">return isPartial</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createUnclosingPrefetchStream(</span><span class="s3">\n  </span><span class="s1">originalFlightStream: ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n</span><span class="s1">): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">// When PPR is enabled, prefetch streams may contain references that never</span><span class="s3">\n  </span><span class="s1">// resolve, because that's how we encode dynamic data access. In the decoded</span><span class="s3">\n  </span><span class="s1">// object returned by the Flight client, these are reified into hanging</span><span class="s3">\n  </span><span class="s1">// promises that suspend during render, which is effectively what we want.</span><span class="s3">\n  </span><span class="s1">// The UI resolves when it switches to the dynamic data stream</span><span class="s3">\n  </span><span class="s1">// (via useDeferredValue(dynamic, static)).</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// However, the Flight implementation currently errors if the server closes</span><span class="s3">\n  </span><span class="s1">// the response before all the references are resolved. As a cheat to work</span><span class="s3">\n  </span><span class="s1">// around this, we wrap the original stream in a new stream that never closes,</span><span class="s3">\n  </span><span class="s1">// and therefore doesn't error.</span><span class="s3">\n  </span><span class="s1">const reader = originalFlightStream.getReader()</span><span class="s3">\n  </span><span class="s1">return new ReadableStream({</span><span class="s3">\n    </span><span class="s1">async pull(controller) {</span><span class="s3">\n      </span><span class="s1">while (true) {</span><span class="s3">\n        </span><span class="s1">const { done, value } = await reader.read()</span><span class="s3">\n        </span><span class="s1">if (!done) {</span><span class="s3">\n          </span><span class="s1">// Pass to the target stream and keep consuming the Flight response</span><span class="s3">\n          </span><span class="s1">// from the server.</span><span class="s3">\n          </span><span class="s1">controller.enqueue(value)</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// The server stream has closed. Exit, but intentionally do not close</span><span class="s3">\n        </span><span class="s1">// the target stream.</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;collectSegmentData&quot;</span><span class="s0">,</span><span class="s1">&quot;filterStackFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;filterStackFrameDEV&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;findSourceMapURL&quot;</span><span class="s0">,</span><span class="s1">&quot;findSourceMapURLDEV&quot;</span><span class="s0">,</span><span class="s1">&quot;onSegmentPrerenderError&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;digest&quot;</span><span class="s0">,</span><span class="s1">&quot;getDigestForWellKnownError&quot;</span><span class="s0">,</span><span class="s1">&quot;isClientParamParsingEnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;fullPageDataBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;staleTime&quot;</span><span class="s0">,</span><span class="s1">&quot;clientModules&quot;</span><span class="s0">,</span><span class="s1">&quot;serverConsumerManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;resultMap&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;createFromReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;streamFromBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;waitAtLeastOneReactRenderTask&quot;</span><span class="s0">,</span><span class="s1">&quot;abortController&quot;</span><span class="s0">,</span><span class="s1">&quot;AbortController&quot;</span><span class="s0">,</span><span class="s1">&quot;onCompletedProcessingRouteTree&quot;</span><span class="s0">,</span><span class="s1">&quot;abort&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentTasks&quot;</span><span class="s0">,</span><span class="s1">&quot;prelude&quot;</span><span class="s0">,</span><span class="s1">&quot;treeStream&quot;</span><span class="s0">,</span><span class="s1">&quot;prerender&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchTreeData&quot;</span><span class="s0">,</span><span class="s1">&quot;signal&quot;</span><span class="s0">,</span><span class="s1">&quot;onError&quot;</span><span class="s0">,</span><span class="s1">&quot;treeBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;streamToBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;all&quot;</span><span class="s0">,</span><span class="s1">&quot;initialRSCPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;createUnclosingPrefetchStream&quot;</span><span class="s0">,</span><span class="s1">&quot;buildId&quot;</span><span class="s0">,</span><span class="s1">&quot;b&quot;</span><span class="s0">,</span><span class="s1">&quot;flightDataPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;f&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;seedData&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;collectSegmentDataImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;ROOT_SEGMENT_REQUEST_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;isHeadPartial&quot;</span><span class="s0">,</span><span class="s1">&quot;isPartialRSCData&quot;</span><span class="s0">,</span><span class="s1">&quot;treePrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;requestKey&quot;</span><span class="s0">,</span><span class="s1">&quot;slotMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;seedDataChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;childRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;childSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;childSeedData&quot;</span><span class="s0">,</span><span class="s1">&quot;childRequestKey&quot;</span><span class="s0">,</span><span class="s1">&quot;appendSegmentRequestKeyPart&quot;</span><span class="s0">,</span><span class="s1">&quot;createSegmentRequestKeyPart&quot;</span><span class="s0">,</span><span class="s1">&quot;childTree&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;renderSegmentPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;paramType&quot;</span><span class="s0">,</span><span class="s1">&quot;paramKey&quot;</span><span class="s0">,</span><span class="s1">&quot;slots&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;rsc&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;isPartial&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentStream&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;onPostpone&quot;</span><span class="s0">,</span><span class="s1">&quot;originalFlightStream&quot;</span><span class="s0">,</span><span class="s1">&quot;reader&quot;</span><span class="s0">,</span><span class="s1">&quot;getReader&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;pull&quot;</span><span class="s0">,</span><span class="s1">&quot;controller&quot;</span><span class="s0">,</span><span class="s1">&quot;done&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;read&quot;</span><span class="s0">,</span><span class="s1">&quot;enqueue&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>