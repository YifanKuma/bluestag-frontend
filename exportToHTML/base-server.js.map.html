<html>
<head>
<title>base-server.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
base-server.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/server/base-server.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { __ApiPreviewProps } from './api-utils'</span><span class="s3">\n</span><span class="s1">import type { LoadComponentsReturnType } from './load-components'</span><span class="s3">\n</span><span class="s1">import type { MiddlewareRouteMatch } from '../shared/lib/router/utils/middleware-route-matcher'</span><span class="s3">\n</span><span class="s1">import type { Params } from './request/params'</span><span class="s3">\n</span><span class="s1">import type { NextConfig, NextConfigComplete } from './config-shared'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">NextParsedUrlQuery,</span><span class="s3">\n  </span><span class="s1">NextUrlWithParsedQuery,</span><span class="s3">\n  </span><span class="s1">RequestMeta,</span><span class="s3">\n</span><span class="s1">} from './request-meta'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import type { RenderOptsPartial as PagesRenderOptsPartial } from './render'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">RenderOptsPartial as AppRenderOptsPartial,</span><span class="s3">\n  </span><span class="s1">ServerOnInstrumentationRequestError,</span><span class="s3">\n</span><span class="s1">} from './app-render/types'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">ServerComponentsHmrCache,</span><span class="s3">\n  </span><span class="s1">ResponseCacheBase,</span><span class="s3">\n</span><span class="s1">} from './response-cache'</span><span class="s3">\n</span><span class="s1">import type { UrlWithParsedQuery } from 'url'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NormalizeError,</span><span class="s3">\n  </span><span class="s1">DecodeError,</span><span class="s3">\n  </span><span class="s1">normalizeRepeatedSlashes,</span><span class="s3">\n  </span><span class="s1">MissingStaticPage,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import type { PagesManifest } from '../build/webpack/plugins/pages-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest, BaseNextResponse } from './base-http'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">ManifestRewriteRoute,</span><span class="s3">\n  </span><span class="s1">ManifestRoute,</span><span class="s3">\n  </span><span class="s1">PrerenderManifest,</span><span class="s3">\n</span><span class="s1">} from '../build'</span><span class="s3">\n</span><span class="s1">import type { ClientReferenceManifest } from '../build/webpack/plugins/flight-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import type { NextFontManifest } from '../build/webpack/plugins/next-font-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import type { PagesAPIRouteMatch } from './route-matches/pages-api-route-match'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">Server as HTTPServer,</span><span class="s3">\n  </span><span class="s1">IncomingMessage,</span><span class="s3">\n  </span><span class="s1">ServerResponse as HTTPServerResponse,</span><span class="s3">\n</span><span class="s1">} from 'http'</span><span class="s3">\n</span><span class="s1">import type { MiddlewareMatcher } from '../build/analysis/get-page-static-info'</span><span class="s3">\n</span><span class="s1">import type { TLSSocket } from 'tls'</span><span class="s3">\n</span><span class="s1">import type { PathnameNormalizer } from './normalizers/request/pathname-normalizer'</span><span class="s3">\n</span><span class="s1">import type { InstrumentationModule } from './instrumentation/types'</span><span class="s3">\n\n</span><span class="s1">import { format as formatUrl, parse as parseUrl } from 'url'</span><span class="s3">\n</span><span class="s1">import { formatHostname } from './lib/format-hostname'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">APP_PATHS_MANIFEST,</span><span class="s3">\n  </span><span class="s1">NEXT_BUILTIN_DOCUMENT,</span><span class="s3">\n  </span><span class="s1">PAGES_MANIFEST,</span><span class="s3">\n  </span><span class="s1">STATIC_STATUS_PAGES,</span><span class="s3">\n  </span><span class="s1">UNDERSCORE_NOT_FOUND_ROUTE,</span><span class="s3">\n  </span><span class="s1">UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/constants'</span><span class="s3">\n</span><span class="s1">import { isDynamicRoute } from '../shared/lib/router/utils'</span><span class="s3">\n</span><span class="s1">import { setConfig } from '../shared/lib/runtime-config.external'</span><span class="s3">\n</span><span class="s1">import { execOnce } from '../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import { isBlockedPage } from './utils'</span><span class="s3">\n</span><span class="s1">import { getBotType, isBot } from '../shared/lib/router/utils/is-bot'</span><span class="s3">\n</span><span class="s1">import RenderResult from './render-result'</span><span class="s3">\n</span><span class="s1">import { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'</span><span class="s3">\n</span><span class="s1">import { denormalizePagePath } from '../shared/lib/page-path/denormalize-page-path'</span><span class="s3">\n</span><span class="s1">import * as Log from '../build/output/log'</span><span class="s3">\n</span><span class="s1">import { getPreviouslyRevalidatedTags, getServerUtils } from './server-utils'</span><span class="s3">\n</span><span class="s1">import isError, { getProperError } from '../lib/is-error'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">addRequestMeta,</span><span class="s3">\n  </span><span class="s1">getRequestMeta,</span><span class="s3">\n  </span><span class="s1">removeRequestMeta,</span><span class="s3">\n  </span><span class="s1">setRequestMeta,</span><span class="s3">\n</span><span class="s1">} from './request-meta'</span><span class="s3">\n</span><span class="s1">import { removePathPrefix } from '../shared/lib/router/utils/remove-path-prefix'</span><span class="s3">\n</span><span class="s1">import { normalizeAppPath } from '../shared/lib/router/utils/app-paths'</span><span class="s3">\n</span><span class="s1">import { getHostname } from '../shared/lib/get-hostname'</span><span class="s3">\n</span><span class="s1">import { parseUrl as parseUrlUtil } from '../shared/lib/router/utils/parse-url'</span><span class="s3">\n</span><span class="s1">import { getNextPathnameInfo } from '../shared/lib/router/utils/get-next-pathname-info'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">RSC_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_RSC_UNION_QUERY,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_PREFETCH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_URL,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_STATE_TREE_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">MatchOptions,</span><span class="s3">\n  </span><span class="s1">RouteMatcherManager,</span><span class="s3">\n</span><span class="s1">} from './route-matcher-managers/route-matcher-manager'</span><span class="s3">\n</span><span class="s1">import { LocaleRouteNormalizer } from './normalizers/locale-route-normalizer'</span><span class="s3">\n</span><span class="s1">import { DefaultRouteMatcherManager } from './route-matcher-managers/default-route-matcher-manager'</span><span class="s3">\n</span><span class="s1">import { AppPageRouteMatcherProvider } from './route-matcher-providers/app-page-route-matcher-provider'</span><span class="s3">\n</span><span class="s1">import { AppRouteRouteMatcherProvider } from './route-matcher-providers/app-route-route-matcher-provider'</span><span class="s3">\n</span><span class="s1">import { PagesAPIRouteMatcherProvider } from './route-matcher-providers/pages-api-route-matcher-provider'</span><span class="s3">\n</span><span class="s1">import { PagesRouteMatcherProvider } from './route-matcher-providers/pages-route-matcher-provider'</span><span class="s3">\n</span><span class="s1">import { ServerManifestLoader } from './route-matcher-providers/helpers/manifest-loaders/server-manifest-loader'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getTracer,</span><span class="s3">\n  </span><span class="s1">isBubbledError,</span><span class="s3">\n  </span><span class="s1">SpanKind,</span><span class="s3">\n  </span><span class="s1">SpanStatusCode,</span><span class="s3">\n</span><span class="s1">} from './lib/trace/tracer'</span><span class="s3">\n</span><span class="s1">import { BaseServerSpan } from './lib/trace/constants'</span><span class="s3">\n</span><span class="s1">import { I18NProvider } from './lib/i18n-provider'</span><span class="s3">\n</span><span class="s1">import { sendResponse } from './send-response'</span><span class="s3">\n</span><span class="s1">import { normalizeNextQueryParam } from './web/utils'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">HTML_CONTENT_TYPE_HEADER,</span><span class="s3">\n  </span><span class="s1">JSON_CONTENT_TYPE_HEADER,</span><span class="s3">\n  </span><span class="s1">MATCHED_PATH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_RESUME_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../lib/constants'</span><span class="s3">\n</span><span class="s1">import { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path'</span><span class="s3">\n</span><span class="s1">import { matchNextDataPathname } from './lib/match-next-data-pathname'</span><span class="s3">\n</span><span class="s1">import getRouteFromAssetPath from '../shared/lib/router/utils/get-route-from-asset-path'</span><span class="s3">\n</span><span class="s1">import { RSCPathnameNormalizer } from './normalizers/request/rsc'</span><span class="s3">\n</span><span class="s1">import { stripFlightHeaders } from './app-render/strip-flight-headers'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">isAppPageRouteModule,</span><span class="s3">\n  </span><span class="s1">isAppRouteRouteModule,</span><span class="s3">\n</span><span class="s1">} from './route-modules/checks'</span><span class="s3">\n</span><span class="s1">import { PrefetchRSCPathnameNormalizer } from './normalizers/request/prefetch-rsc'</span><span class="s3">\n</span><span class="s1">import { NextDataPathnameNormalizer } from './normalizers/request/next-data'</span><span class="s3">\n</span><span class="s1">import { getIsPossibleServerAction } from './lib/server-action-request-meta'</span><span class="s3">\n</span><span class="s1">import { isInterceptionRouteAppPath } from '../shared/lib/router/utils/interception-routes'</span><span class="s3">\n</span><span class="s1">import { toRoute } from './lib/to-route'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../shared/lib/deep-readonly'</span><span class="s3">\n</span><span class="s1">import { isNodeNextRequest, isNodeNextResponse } from './base-http/helpers'</span><span class="s3">\n</span><span class="s1">import { patchSetHeaderWithCookieSupport } from './lib/patch-set-header'</span><span class="s3">\n</span><span class="s1">import { checkIsAppPPREnabled } from './lib/experimental/ppr'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getBuiltinRequestContext,</span><span class="s3">\n  </span><span class="s1">type WaitUntil,</span><span class="s3">\n</span><span class="s1">} from './after/builtin-request-context'</span><span class="s3">\n</span><span class="s1">import { NextRequestHint } from './web/adapter'</span><span class="s3">\n</span><span class="s1">import type { RouteModule } from './route-modules/route-module'</span><span class="s3">\n</span><span class="s1">import { type FallbackMode, parseFallbackField } from '../lib/fallback'</span><span class="s3">\n</span><span class="s1">import { SegmentPrefixRSCPathnameNormalizer } from './normalizers/request/segment-prefix-rsc'</span><span class="s3">\n</span><span class="s1">import { shouldServeStreamingMetadata } from './lib/streaming-metadata'</span><span class="s3">\n</span><span class="s1">import { decodeQueryPathParameter } from './lib/decode-query-path-parameter'</span><span class="s3">\n</span><span class="s1">import { NoFallbackError } from '../shared/lib/no-fallback-error.external'</span><span class="s3">\n</span><span class="s1">import { getCacheHandlers } from './use-cache/handlers'</span><span class="s3">\n</span><span class="s1">import { fixMojibake } from './lib/fix-mojibake'</span><span class="s3">\n</span><span class="s1">import { computeCacheBustingSearchParam } from '../shared/lib/router/utils/cache-busting-search-param'</span><span class="s3">\n</span><span class="s1">import { setCacheBustingSearchParamWithHash } from '../client/components/router-reducer/set-cache-busting-search-param'</span><span class="s3">\n</span><span class="s1">import type { CacheControl } from './lib/cache-control'</span><span class="s3">\n</span><span class="s1">import type { PrerenderedRoute } from '../build/static-paths/types'</span><span class="s3">\n\n</span><span class="s1">export type FindComponentsResult = {</span><span class="s3">\n  </span><span class="s1">components: LoadComponentsReturnType</span><span class="s3">\n  </span><span class="s1">query: NextParsedUrlQuery</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface MiddlewareRoutingItem {</span><span class="s3">\n  </span><span class="s1">page: string</span><span class="s3">\n  </span><span class="s1">match: MiddlewareRouteMatch</span><span class="s3">\n  </span><span class="s1">matchers?: MiddlewareMatcher[]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RouteHandler&lt;</span><span class="s3">\n  </span><span class="s1">ServerRequest extends BaseNextRequest = BaseNextRequest,</span><span class="s3">\n  </span><span class="s1">ServerResponse extends BaseNextResponse = BaseNextResponse,</span><span class="s3">\n</span><span class="s1">&gt; = (</span><span class="s3">\n  </span><span class="s1">req: ServerRequest,</span><span class="s3">\n  </span><span class="s1">res: ServerResponse,</span><span class="s3">\n  </span><span class="s1">parsedUrl: NextUrlWithParsedQuery</span><span class="s3">\n</span><span class="s1">) =&gt; PromiseLike&lt;boolean&gt; | boolean</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The normalized route manifest is the same as the route manifest, but with</span><span class="s3">\n </span><span class="s1">* the rewrites normalized to the object shape that the router expects.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type NormalizedRouteManifest = {</span><span class="s3">\n  </span><span class="s1">readonly dynamicRoutes: ReadonlyArray&lt;ManifestRoute&gt;</span><span class="s3">\n  </span><span class="s1">readonly rewrites: {</span><span class="s3">\n    </span><span class="s1">readonly beforeFiles: ReadonlyArray&lt;ManifestRewriteRoute&gt;</span><span class="s3">\n    </span><span class="s1">readonly afterFiles: ReadonlyArray&lt;ManifestRewriteRoute&gt;</span><span class="s3">\n    </span><span class="s1">readonly fallback: ReadonlyArray&lt;ManifestRewriteRoute&gt;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface Options {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Object containing the configuration next.config.js</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">conf: NextConfig</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Set to false when the server was created by Next.js</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">customServer?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Tells if Next.js is running in dev mode</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">dev?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Enables the experimental testing mode.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">experimentalTestProxy?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether or not the dev server is running in experimental HTTPS mode</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">experimentalHttpsServer?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Where the Next project is located</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">dir?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Tells if Next.js is at the platform-level</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">minimalMode?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Hide error messages containing server information</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">quiet?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The hostname the server is running behind</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">hostname?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The port the server is running behind</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">port?: number</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The HTTP Server that Next.js is running behind</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">httpServer?: HTTPServer</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RenderOpts = PagesRenderOptsPartial &amp; AppRenderOptsPartial</span><span class="s3">\n\n</span><span class="s1">export type LoadedRenderOpts = RenderOpts &amp;</span><span class="s3">\n  </span><span class="s1">LoadComponentsReturnType &amp;</span><span class="s3">\n  </span><span class="s1">RequestLifecycleOpts</span><span class="s3">\n\n</span><span class="s1">export type RequestLifecycleOpts = {</span><span class="s3">\n  </span><span class="s1">waitUntil: ((promise: Promise&lt;any&gt;) =&gt; void) | undefined</span><span class="s3">\n  </span><span class="s1">onClose: (callback: () =&gt; void) =&gt; void</span><span class="s3">\n  </span><span class="s1">onAfterTaskError: ((error: unknown) =&gt; void) | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type BaseRenderOpts = RenderOpts &amp; {</span><span class="s3">\n  </span><span class="s1">poweredByHeader: boolean</span><span class="s3">\n  </span><span class="s1">generateEtags: boolean</span><span class="s3">\n  </span><span class="s1">previewProps: __ApiPreviewProps</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The public interface for rendering with the server programmatically. This</span><span class="s3">\n </span><span class="s1">* would typically only allow the base request or response to extend it, but</span><span class="s3">\n </span><span class="s1">* because this can be programmatically accessed, we assume that it could also</span><span class="s3">\n </span><span class="s1">* be the base Node.js request and response types.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface BaseRequestHandler&lt;</span><span class="s3">\n  </span><span class="s1">ServerRequest extends BaseNextRequest | IncomingMessage = BaseNextRequest,</span><span class="s3">\n  </span><span class="s1">ServerResponse extends</span><span class="s3">\n    </span><span class="s1">| BaseNextResponse</span><span class="s3">\n    </span><span class="s1">| HTTPServerResponse = BaseNextResponse,</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">parsedUrl?: NextUrlWithParsedQuery | undefined</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; | void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RequestContext&lt;</span><span class="s3">\n  </span><span class="s1">ServerRequest extends BaseNextRequest = BaseNextRequest,</span><span class="s3">\n  </span><span class="s1">ServerResponse extends BaseNextResponse = BaseNextResponse,</span><span class="s3">\n</span><span class="s1">&gt; = {</span><span class="s3">\n  </span><span class="s1">req: ServerRequest</span><span class="s3">\n  </span><span class="s1">res: ServerResponse</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n  </span><span class="s1">query: NextParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">renderOpts: RenderOpts</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Internal wrapper around build errors at development</span><span class="s3">\n</span><span class="s1">// time, to prevent us from propagating or logging them</span><span class="s3">\n</span><span class="s1">export class WrappedBuildError extends Error {</span><span class="s3">\n  </span><span class="s1">innerError: Error</span><span class="s3">\n\n  </span><span class="s1">constructor(innerError: Error) {</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n    </span><span class="s1">this.innerError = innerError</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ResponsePayload = {</span><span class="s3">\n  </span><span class="s1">body: RenderResult</span><span class="s3">\n  </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type NextEnabledDirectories = {</span><span class="s3">\n  </span><span class="s1">readonly pages: boolean</span><span class="s3">\n  </span><span class="s1">readonly app: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default abstract class Server&lt;</span><span class="s3">\n  </span><span class="s1">ServerOptions extends Options = Options,</span><span class="s3">\n  </span><span class="s1">ServerRequest extends BaseNextRequest = BaseNextRequest,</span><span class="s3">\n  </span><span class="s1">ServerResponse extends BaseNextResponse = BaseNextResponse,</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">public readonly hostname?: string</span><span class="s3">\n  </span><span class="s1">public readonly fetchHostname?: string</span><span class="s3">\n  </span><span class="s1">public readonly port?: number</span><span class="s3">\n  </span><span class="s1">protected readonly dir: string</span><span class="s3">\n  </span><span class="s1">protected readonly quiet: boolean</span><span class="s3">\n  </span><span class="s1">protected readonly nextConfig: NextConfigComplete</span><span class="s3">\n  </span><span class="s1">protected readonly distDir: string</span><span class="s3">\n  </span><span class="s1">protected readonly publicDir: string</span><span class="s3">\n  </span><span class="s1">protected readonly hasStaticDir: boolean</span><span class="s3">\n  </span><span class="s1">protected readonly pagesManifest?: PagesManifest</span><span class="s3">\n  </span><span class="s1">protected readonly appPathsManifest?: PagesManifest</span><span class="s3">\n  </span><span class="s1">protected readonly buildId: string</span><span class="s3">\n  </span><span class="s1">protected readonly minimalMode: boolean</span><span class="s3">\n  </span><span class="s1">protected readonly renderOpts: BaseRenderOpts</span><span class="s3">\n  </span><span class="s1">protected readonly serverOptions: Readonly&lt;ServerOptions&gt;</span><span class="s3">\n  </span><span class="s1">protected readonly appPathRoutes?: Record&lt;string, string[]&gt;</span><span class="s3">\n  </span><span class="s1">protected readonly clientReferenceManifest?: DeepReadonly&lt;ClientReferenceManifest&gt;</span><span class="s3">\n  </span><span class="s1">protected interceptionRoutePatterns: RegExp[]</span><span class="s3">\n  </span><span class="s1">protected nextFontManifest?: DeepReadonly&lt;NextFontManifest&gt;</span><span class="s3">\n  </span><span class="s1">protected instrumentation: InstrumentationModule | undefined</span><span class="s3">\n  </span><span class="s1">private readonly responseCache: ResponseCacheBase</span><span class="s3">\n\n  </span><span class="s1">protected abstract getPublicDir(): string</span><span class="s3">\n  </span><span class="s1">protected abstract getHasStaticDir(): boolean</span><span class="s3">\n  </span><span class="s1">protected abstract getPagesManifest(): PagesManifest | undefined</span><span class="s3">\n  </span><span class="s1">protected abstract getAppPathsManifest(): PagesManifest | undefined</span><span class="s3">\n  </span><span class="s1">protected abstract getBuildId(): string</span><span class="s3">\n  </span><span class="s1">protected abstract getinterceptionRoutePatterns(): RegExp[]</span><span class="s3">\n\n  </span><span class="s1">protected readonly enabledDirectories: NextEnabledDirectories</span><span class="s3">\n  </span><span class="s1">protected abstract getEnabledDirectories(dev: boolean): NextEnabledDirectories</span><span class="s3">\n\n  </span><span class="s1">protected readonly experimentalTestProxy?: boolean</span><span class="s3">\n\n  </span><span class="s1">protected abstract findPageComponents(params: {</span><span class="s3">\n    </span><span class="s1">locale: string | undefined</span><span class="s3">\n    </span><span class="s1">page: string</span><span class="s3">\n    </span><span class="s1">query: NextParsedUrlQuery</span><span class="s3">\n    </span><span class="s1">params: Params</span><span class="s3">\n    </span><span class="s1">isAppPath: boolean</span><span class="s3">\n    </span><span class="s1">// The following parameters are used in the development server's</span><span class="s3">\n    </span><span class="s1">// implementation.</span><span class="s3">\n    </span><span class="s1">sriEnabled?: boolean</span><span class="s3">\n    </span><span class="s1">appPaths?: ReadonlyArray&lt;string&gt; | null</span><span class="s3">\n    </span><span class="s1">shouldEnsure?: boolean</span><span class="s3">\n    </span><span class="s1">url?: string</span><span class="s3">\n  </span><span class="s1">}): Promise&lt;FindComponentsResult | null&gt;</span><span class="s3">\n  </span><span class="s1">protected abstract getPrerenderManifest(): DeepReadonly&lt;PrerenderManifest&gt;</span><span class="s3">\n  </span><span class="s1">protected abstract getNextFontManifest():</span><span class="s3">\n    </span><span class="s1">| DeepReadonly&lt;NextFontManifest&gt;</span><span class="s3">\n    </span><span class="s1">| undefined</span><span class="s3">\n  </span><span class="s1">protected abstract attachRequestMeta(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">parsedUrl: NextUrlWithParsedQuery</span><span class="s3">\n  </span><span class="s1">): void</span><span class="s3">\n  </span><span class="s1">protected abstract hasPage(pathname: string): Promise&lt;boolean&gt;</span><span class="s3">\n\n  </span><span class="s1">protected abstract sendRenderResult(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">options: {</span><span class="s3">\n      </span><span class="s1">result: RenderResult</span><span class="s3">\n      </span><span class="s1">generateEtags: boolean</span><span class="s3">\n      </span><span class="s1">poweredByHeader: boolean</span><span class="s3">\n      </span><span class="s1">cacheControl: CacheControl | undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt;</span><span class="s3">\n\n  </span><span class="s1">protected abstract runApi(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">query: ParsedUrlQuery,</span><span class="s3">\n    </span><span class="s1">match: PagesAPIRouteMatch</span><span class="s3">\n  </span><span class="s1">): Promise&lt;boolean&gt;</span><span class="s3">\n\n  </span><span class="s1">protected abstract renderHTML(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">query: NextParsedUrlQuery,</span><span class="s3">\n    </span><span class="s1">renderOpts: LoadedRenderOpts</span><span class="s3">\n  </span><span class="s1">): Promise&lt;RenderResult&gt;</span><span class="s3">\n\n  </span><span class="s1">protected abstract getIncrementalCache(options: {</span><span class="s3">\n    </span><span class="s1">requestHeaders: Record&lt;string, undefined | string | string[]&gt;</span><span class="s3">\n  </span><span class="s1">}): Promise&lt;import('./lib/incremental-cache').IncrementalCache&gt;</span><span class="s3">\n\n  </span><span class="s1">protected abstract getResponseCache(options: {</span><span class="s3">\n    </span><span class="s1">dev: boolean</span><span class="s3">\n  </span><span class="s1">}): ResponseCacheBase</span><span class="s3">\n\n  </span><span class="s1">protected getServerComponentsHmrCache():</span><span class="s3">\n    </span><span class="s1">| ServerComponentsHmrCache</span><span class="s3">\n    </span><span class="s1">| undefined {</span><span class="s3">\n    </span><span class="s1">return this.nextConfig.experimental.serverComponentsHmrCache</span><span class="s3">\n      </span><span class="s1">? (globalThis as any).__serverComponentsHmrCache</span><span class="s3">\n      </span><span class="s1">: undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected abstract loadEnvConfig(params: {</span><span class="s3">\n    </span><span class="s1">dev: boolean</span><span class="s3">\n    </span><span class="s1">forceReload?: boolean</span><span class="s3">\n  </span><span class="s1">}): void</span><span class="s3">\n\n  </span><span class="s1">// TODO-APP: (wyattjoh): Make protected again. Used for turbopack in route-resolver.ts right now.</span><span class="s3">\n  </span><span class="s1">public readonly matchers: RouteMatcherManager</span><span class="s3">\n  </span><span class="s1">protected readonly i18nProvider?: I18NProvider</span><span class="s3">\n  </span><span class="s1">protected readonly localeNormalizer?: LocaleRouteNormalizer</span><span class="s3">\n\n  </span><span class="s1">protected readonly normalizers: {</span><span class="s3">\n    </span><span class="s1">readonly rsc: RSCPathnameNormalizer | undefined</span><span class="s3">\n    </span><span class="s1">readonly prefetchRSC: PrefetchRSCPathnameNormalizer | undefined</span><span class="s3">\n    </span><span class="s1">readonly segmentPrefetchRSC: SegmentPrefixRSCPathnameNormalizer | undefined</span><span class="s3">\n    </span><span class="s1">readonly data: NextDataPathnameNormalizer | undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private readonly isAppPPREnabled: boolean</span><span class="s3">\n  </span><span class="s1">private readonly isAppSegmentPrefetchEnabled: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This is used to persist cache scopes across</span><span class="s3">\n   </span><span class="s1">* prefetch -&gt; full route requests for cache components</span><span class="s3">\n   </span><span class="s1">* it's only fully used in dev</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">public constructor(options: ServerOptions) {</span><span class="s3">\n    </span><span class="s1">const {</span><span class="s3">\n      </span><span class="s1">dir = '.',</span><span class="s3">\n      </span><span class="s1">quiet = false,</span><span class="s3">\n      </span><span class="s1">conf,</span><span class="s3">\n      </span><span class="s1">dev = false,</span><span class="s3">\n      </span><span class="s1">minimalMode = false,</span><span class="s3">\n      </span><span class="s1">hostname,</span><span class="s3">\n      </span><span class="s1">port,</span><span class="s3">\n      </span><span class="s1">experimentalTestProxy,</span><span class="s3">\n    </span><span class="s1">} = options</span><span class="s3">\n\n    </span><span class="s1">this.experimentalTestProxy = experimentalTestProxy</span><span class="s3">\n    </span><span class="s1">this.serverOptions = options</span><span class="s3">\n\n    </span><span class="s1">this.dir = (require('path') as typeof import('path')).resolve(dir)</span><span class="s3">\n\n    </span><span class="s1">this.quiet = quiet</span><span class="s3">\n    </span><span class="s1">this.loadEnvConfig({ dev })</span><span class="s3">\n\n    </span><span class="s1">// TODO: should conf be normalized to prevent missing</span><span class="s3">\n    </span><span class="s1">// values from causing issues as this can be user provided</span><span class="s3">\n    </span><span class="s1">this.nextConfig = conf as NextConfigComplete</span><span class="s3">\n    </span><span class="s1">this.hostname = hostname</span><span class="s3">\n    </span><span class="s1">if (this.hostname) {</span><span class="s3">\n      </span><span class="s1">// we format the hostname so that it can be fetched</span><span class="s3">\n      </span><span class="s1">this.fetchHostname = formatHostname(this.hostname)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.port = port</span><span class="s3">\n    </span><span class="s1">this.distDir = (require('path') as typeof import('path')).join(</span><span class="s3">\n      </span><span class="s1">this.dir,</span><span class="s3">\n      </span><span class="s1">this.nextConfig.distDir</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">this.publicDir = this.getPublicDir()</span><span class="s3">\n    </span><span class="s1">this.hasStaticDir = !minimalMode &amp;&amp; this.getHasStaticDir()</span><span class="s3">\n\n    </span><span class="s1">this.i18nProvider = this.nextConfig.i18n?.locales</span><span class="s3">\n      </span><span class="s1">? new I18NProvider(this.nextConfig.i18n)</span><span class="s3">\n      </span><span class="s1">: undefined</span><span class="s3">\n\n    </span><span class="s1">// Configure the locale normalizer, it's used for routes inside `pages/`.</span><span class="s3">\n    </span><span class="s1">this.localeNormalizer = this.i18nProvider</span><span class="s3">\n      </span><span class="s1">? new LocaleRouteNormalizer(this.i18nProvider)</span><span class="s3">\n      </span><span class="s1">: undefined</span><span class="s3">\n\n    </span><span class="s1">// Only serverRuntimeConfig needs the default</span><span class="s3">\n    </span><span class="s1">// publicRuntimeConfig gets it's default in client/index.js</span><span class="s3">\n    </span><span class="s1">const {</span><span class="s3">\n      </span><span class="s1">serverRuntimeConfig = {},</span><span class="s3">\n      </span><span class="s1">publicRuntimeConfig,</span><span class="s3">\n      </span><span class="s1">assetPrefix,</span><span class="s3">\n      </span><span class="s1">generateEtags,</span><span class="s3">\n    </span><span class="s1">} = this.nextConfig</span><span class="s3">\n\n    </span><span class="s1">this.buildId = this.getBuildId()</span><span class="s3">\n    </span><span class="s1">// this is a hack to avoid Webpack knowing this is equal to this.minimalMode</span><span class="s3">\n    </span><span class="s1">// because we replace this.minimalMode to true in production bundles.</span><span class="s3">\n    </span><span class="s1">const minimalModeKey = 'minimalMode'</span><span class="s3">\n    </span><span class="s1">this[minimalModeKey] =</span><span class="s3">\n      </span><span class="s1">minimalMode || !!process.env.NEXT_PRIVATE_MINIMAL_MODE</span><span class="s3">\n\n    </span><span class="s1">this.enabledDirectories = this.getEnabledDirectories(dev)</span><span class="s3">\n\n    </span><span class="s1">this.isAppPPREnabled =</span><span class="s3">\n      </span><span class="s1">this.enabledDirectories.app &amp;&amp;</span><span class="s3">\n      </span><span class="s1">checkIsAppPPREnabled(this.nextConfig.experimental.ppr)</span><span class="s3">\n\n    </span><span class="s1">this.isAppSegmentPrefetchEnabled =</span><span class="s3">\n      </span><span class="s1">this.enabledDirectories.app &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.nextConfig.experimental.clientSegmentCache === true</span><span class="s3">\n\n    </span><span class="s1">this.normalizers = {</span><span class="s3">\n      </span><span class="s1">// We should normalize the pathname from the RSC prefix only in minimal</span><span class="s3">\n      </span><span class="s1">// mode as otherwise that route is not exposed external to the server as</span><span class="s3">\n      </span><span class="s1">// we instead only rely on the headers.</span><span class="s3">\n      </span><span class="s1">rsc:</span><span class="s3">\n        </span><span class="s1">this.enabledDirectories.app &amp;&amp; this.minimalMode</span><span class="s3">\n          </span><span class="s1">? new RSCPathnameNormalizer()</span><span class="s3">\n          </span><span class="s1">: undefined,</span><span class="s3">\n      </span><span class="s1">prefetchRSC:</span><span class="s3">\n        </span><span class="s1">this.isAppPPREnabled &amp;&amp; this.minimalMode</span><span class="s3">\n          </span><span class="s1">? new PrefetchRSCPathnameNormalizer()</span><span class="s3">\n          </span><span class="s1">: undefined,</span><span class="s3">\n      </span><span class="s1">segmentPrefetchRSC:</span><span class="s3">\n        </span><span class="s1">this.isAppSegmentPrefetchEnabled &amp;&amp; this.minimalMode</span><span class="s3">\n          </span><span class="s1">? new SegmentPrefixRSCPathnameNormalizer()</span><span class="s3">\n          </span><span class="s1">: undefined,</span><span class="s3">\n      </span><span class="s1">data: this.enabledDirectories.pages</span><span class="s3">\n        </span><span class="s1">? new NextDataPathnameNormalizer(this.buildId)</span><span class="s3">\n        </span><span class="s1">: undefined,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.nextFontManifest = this.getNextFontManifest()</span><span class="s3">\n    </span><span class="s1">process.env.NEXT_DEPLOYMENT_ID = this.nextConfig.deploymentId || ''</span><span class="s3">\n\n    </span><span class="s1">this.renderOpts = {</span><span class="s3">\n      </span><span class="s1">dir: this.dir,</span><span class="s3">\n      </span><span class="s1">supportsDynamicResponse: true,</span><span class="s3">\n      </span><span class="s1">trailingSlash: this.nextConfig.trailingSlash,</span><span class="s3">\n      </span><span class="s1">deploymentId: this.nextConfig.deploymentId,</span><span class="s3">\n      </span><span class="s1">poweredByHeader: this.nextConfig.poweredByHeader,</span><span class="s3">\n      </span><span class="s1">canonicalBase: this.nextConfig.amp.canonicalBase || '',</span><span class="s3">\n      </span><span class="s1">generateEtags,</span><span class="s3">\n      </span><span class="s1">previewProps: this.getPrerenderManifest().preview,</span><span class="s3">\n      </span><span class="s1">ampOptimizerConfig: this.nextConfig.experimental.amp?.optimizer,</span><span class="s3">\n      </span><span class="s1">basePath: this.nextConfig.basePath,</span><span class="s3">\n      </span><span class="s1">images: this.nextConfig.images,</span><span class="s3">\n      </span><span class="s1">optimizeCss: this.nextConfig.experimental.optimizeCss,</span><span class="s3">\n      </span><span class="s1">nextConfigOutput: this.nextConfig.output,</span><span class="s3">\n      </span><span class="s1">nextScriptWorkers: this.nextConfig.experimental.nextScriptWorkers,</span><span class="s3">\n      </span><span class="s1">disableOptimizedLoading:</span><span class="s3">\n        </span><span class="s1">this.nextConfig.experimental.disableOptimizedLoading,</span><span class="s3">\n      </span><span class="s1">domainLocales: this.nextConfig.i18n?.domains,</span><span class="s3">\n      </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n      </span><span class="s1">serverComponents: this.enabledDirectories.app,</span><span class="s3">\n      </span><span class="s1">cacheLifeProfiles: this.nextConfig.experimental.cacheLife,</span><span class="s3">\n      </span><span class="s1">enableTainting: this.nextConfig.experimental.taint,</span><span class="s3">\n      </span><span class="s1">crossOrigin: this.nextConfig.crossOrigin</span><span class="s3">\n        </span><span class="s1">? this.nextConfig.crossOrigin</span><span class="s3">\n        </span><span class="s1">: undefined,</span><span class="s3">\n      </span><span class="s1">largePageDataBytes: this.nextConfig.experimental.largePageDataBytes,</span><span class="s3">\n      </span><span class="s1">// Only the `publicRuntimeConfig` key is exposed to the client side</span><span class="s3">\n      </span><span class="s1">// It'll be rendered as part of __NEXT_DATA__ on the client side</span><span class="s3">\n      </span><span class="s1">runtimeConfig:</span><span class="s3">\n        </span><span class="s1">Object.keys(publicRuntimeConfig).length &gt; 0</span><span class="s3">\n          </span><span class="s1">? publicRuntimeConfig</span><span class="s3">\n          </span><span class="s1">: undefined,</span><span class="s3">\n\n      </span><span class="s1">isExperimentalCompile: this.nextConfig.experimental.isExperimentalCompile,</span><span class="s3">\n      </span><span class="s1">// `htmlLimitedBots` is passed to server as serialized config in string format</span><span class="s3">\n      </span><span class="s1">htmlLimitedBots: this.nextConfig.htmlLimitedBots,</span><span class="s3">\n      </span><span class="s1">experimental: {</span><span class="s3">\n        </span><span class="s1">expireTime: this.nextConfig.expireTime,</span><span class="s3">\n        </span><span class="s1">staleTimes: this.nextConfig.experimental.staleTimes,</span><span class="s3">\n        </span><span class="s1">clientTraceMetadata: this.nextConfig.experimental.clientTraceMetadata,</span><span class="s3">\n        </span><span class="s1">cacheComponents: this.nextConfig.experimental.cacheComponents ?? false,</span><span class="s3">\n        </span><span class="s1">clientSegmentCache:</span><span class="s3">\n          </span><span class="s1">this.nextConfig.experimental.clientSegmentCache === 'client-only'</span><span class="s3">\n            </span><span class="s1">? 'client-only'</span><span class="s3">\n            </span><span class="s1">: Boolean(this.nextConfig.experimental.clientSegmentCache),</span><span class="s3">\n        </span><span class="s1">clientParamParsing:</span><span class="s3">\n          </span><span class="s1">this.nextConfig.experimental.clientParamParsing ?? false,</span><span class="s3">\n        </span><span class="s1">dynamicOnHover: this.nextConfig.experimental.dynamicOnHover ?? false,</span><span class="s3">\n        </span><span class="s1">inlineCss: this.nextConfig.experimental.inlineCss ?? false,</span><span class="s3">\n        </span><span class="s1">authInterrupts: !!this.nextConfig.experimental.authInterrupts,</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">onInstrumentationRequestError:</span><span class="s3">\n        </span><span class="s1">this.instrumentationOnRequestError.bind(this),</span><span class="s3">\n      </span><span class="s1">reactMaxHeadersLength: this.nextConfig.reactMaxHeadersLength,</span><span class="s3">\n      </span><span class="s1">devtoolSegmentExplorer:</span><span class="s3">\n        </span><span class="s1">this.nextConfig.experimental.devtoolSegmentExplorer,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Initialize next/config with the environment configuration</span><span class="s3">\n    </span><span class="s1">setConfig({</span><span class="s3">\n      </span><span class="s1">serverRuntimeConfig,</span><span class="s3">\n      </span><span class="s1">publicRuntimeConfig,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">this.pagesManifest = this.getPagesManifest()</span><span class="s3">\n    </span><span class="s1">this.appPathsManifest = this.getAppPathsManifest()</span><span class="s3">\n    </span><span class="s1">this.appPathRoutes = this.getAppPathRoutes()</span><span class="s3">\n    </span><span class="s1">this.interceptionRoutePatterns = this.getinterceptionRoutePatterns()</span><span class="s3">\n\n    </span><span class="s1">// Configure the routes.</span><span class="s3">\n    </span><span class="s1">this.matchers = this.getRouteMatchers()</span><span class="s3">\n\n    </span><span class="s1">// Start route compilation. We don't wait for the routes to finish loading</span><span class="s3">\n    </span><span class="s1">// because we use the `waitTillReady` promise below in `handleRequest` to</span><span class="s3">\n    </span><span class="s1">// wait. Also we can't `await` in the constructor.</span><span class="s3">\n    </span><span class="s1">void this.matchers.reload()</span><span class="s3">\n\n    </span><span class="s1">this.setAssetPrefix(assetPrefix)</span><span class="s3">\n    </span><span class="s1">this.responseCache = this.getResponseCache({ dev })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private handleRSCRequest: RouteHandler&lt;ServerRequest, ServerResponse&gt; = (</span><span class="s3">\n    </span><span class="s1">req,</span><span class="s3">\n    </span><span class="s1">_res,</span><span class="s3">\n    </span><span class="s1">parsedUrl</span><span class="s3">\n  </span><span class="s1">) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (!parsedUrl.pathname) return false</span><span class="s3">\n\n    </span><span class="s1">if (this.normalizers.segmentPrefetchRSC?.match(parsedUrl.pathname)) {</span><span class="s3">\n      </span><span class="s1">const result = this.normalizers.segmentPrefetchRSC.extract(</span><span class="s3">\n        </span><span class="s1">parsedUrl.pathname</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">if (!result) return false</span><span class="s3">\n\n      </span><span class="s1">const { originalPathname, segmentPath } = result</span><span class="s3">\n      </span><span class="s1">parsedUrl.pathname = originalPathname</span><span class="s3">\n\n      </span><span class="s1">// Mark the request as a router prefetch request.</span><span class="s3">\n      </span><span class="s1">req.headers[RSC_HEADER] = '1'</span><span class="s3">\n      </span><span class="s1">req.headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'</span><span class="s3">\n      </span><span class="s1">req.headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] = segmentPath</span><span class="s3">\n\n      </span><span class="s1">addRequestMeta(req, 'isRSCRequest', true)</span><span class="s3">\n      </span><span class="s1">addRequestMeta(req, 'isPrefetchRSCRequest', true)</span><span class="s3">\n      </span><span class="s1">addRequestMeta(req, 'segmentPrefetchRSCRequest', segmentPath)</span><span class="s3">\n    </span><span class="s1">} else if (this.normalizers.prefetchRSC?.match(parsedUrl.pathname)) {</span><span class="s3">\n      </span><span class="s1">parsedUrl.pathname = this.normalizers.prefetchRSC.normalize(</span><span class="s3">\n        </span><span class="s1">parsedUrl.pathname,</span><span class="s3">\n        </span><span class="s1">true</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">// Mark the request as a router prefetch request.</span><span class="s3">\n      </span><span class="s1">req.headers[RSC_HEADER] = '1'</span><span class="s3">\n      </span><span class="s1">req.headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'</span><span class="s3">\n      </span><span class="s1">addRequestMeta(req, 'isRSCRequest', true)</span><span class="s3">\n      </span><span class="s1">addRequestMeta(req, 'isPrefetchRSCRequest', true)</span><span class="s3">\n    </span><span class="s1">} else if (this.normalizers.rsc?.match(parsedUrl.pathname)) {</span><span class="s3">\n      </span><span class="s1">parsedUrl.pathname = this.normalizers.rsc.normalize(</span><span class="s3">\n        </span><span class="s1">parsedUrl.pathname,</span><span class="s3">\n        </span><span class="s1">true</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">// Mark the request as a RSC request.</span><span class="s3">\n      </span><span class="s1">req.headers[RSC_HEADER] = '1'</span><span class="s3">\n      </span><span class="s1">addRequestMeta(req, 'isRSCRequest', true)</span><span class="s3">\n    </span><span class="s1">} else if (req.headers['x-now-route-matches']) {</span><span class="s3">\n      </span><span class="s1">// If we didn't match, return with the flight headers stripped. If in</span><span class="s3">\n      </span><span class="s1">// minimal mode we didn't match based on the path, this can't be a RSC</span><span class="s3">\n      </span><span class="s1">// request. This is because Vercel only sends this header during</span><span class="s3">\n      </span><span class="s1">// revalidation requests and we want the cache to instead depend on the</span><span class="s3">\n      </span><span class="s1">// request path for flight information.</span><span class="s3">\n      </span><span class="s1">stripFlightHeaders(req.headers)</span><span class="s3">\n\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">} else if (req.headers[RSC_HEADER] === '1') {</span><span class="s3">\n      </span><span class="s1">addRequestMeta(req, 'isRSCRequest', true)</span><span class="s3">\n\n      </span><span class="s1">if (req.headers[NEXT_ROUTER_PREFETCH_HEADER] === '1') {</span><span class="s3">\n        </span><span class="s1">addRequestMeta(req, 'isPrefetchRSCRequest', true)</span><span class="s3">\n\n        </span><span class="s1">const segmentPrefetchRSCRequest =</span><span class="s3">\n          </span><span class="s1">req.headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]</span><span class="s3">\n        </span><span class="s1">if (typeof segmentPrefetchRSCRequest === 'string') {</span><span class="s3">\n          </span><span class="s1">addRequestMeta(</span><span class="s3">\n            </span><span class="s1">req,</span><span class="s3">\n            </span><span class="s1">'segmentPrefetchRSCRequest',</span><span class="s3">\n            </span><span class="s1">segmentPrefetchRSCRequest</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Otherwise just return without doing anything.</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (req.url) {</span><span class="s3">\n      </span><span class="s1">const parsed = parseUrl(req.url)</span><span class="s3">\n      </span><span class="s1">parsed.pathname = parsedUrl.pathname</span><span class="s3">\n      </span><span class="s1">req.url = formatUrl(parsed)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private handleNextDataRequest: RouteHandler&lt;ServerRequest, ServerResponse&gt; =</span><span class="s3">\n    </span><span class="s1">async (req, res, parsedUrl) =&gt; {</span><span class="s3">\n      </span><span class="s1">const middleware = await this.getMiddleware()</span><span class="s3">\n      </span><span class="s1">const params = matchNextDataPathname(parsedUrl.pathname)</span><span class="s3">\n\n      </span><span class="s1">// ignore for non-next data URLs</span><span class="s3">\n      </span><span class="s1">if (!params || !params.path) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (params.path[0] !== this.buildId) {</span><span class="s3">\n        </span><span class="s1">// Ignore if its a middleware request when we aren't on edge.</span><span class="s3">\n        </span><span class="s1">if (getRequestMeta(req, 'middlewareInvoke')) {</span><span class="s3">\n          </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Make sure to 404 if the buildId isn't correct</span><span class="s3">\n        </span><span class="s1">await this.render404(req, res, parsedUrl)</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// remove buildId from URL</span><span class="s3">\n      </span><span class="s1">params.path.shift()</span><span class="s3">\n\n      </span><span class="s1">const lastParam = params.path[params.path.length - 1]</span><span class="s3">\n\n      </span><span class="s1">// show 404 if it doesn't end with .json</span><span class="s3">\n      </span><span class="s1">if (typeof lastParam !== 'string' || !lastParam.endsWith('.json')) {</span><span class="s3">\n        </span><span class="s1">await this.render404(req, res, parsedUrl)</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// re-create page's pathname</span><span class="s3">\n      </span><span class="s1">let pathname = `/${params.path.join('/')}`</span><span class="s3">\n      </span><span class="s1">pathname = getRouteFromAssetPath(pathname, '.json')</span><span class="s3">\n\n      </span><span class="s1">// ensure trailing slash is normalized per config</span><span class="s3">\n      </span><span class="s1">if (middleware) {</span><span class="s3">\n        </span><span class="s1">if (this.nextConfig.trailingSlash &amp;&amp; !pathname.endsWith('/')) {</span><span class="s3">\n          </span><span class="s1">pathname += '/'</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">!this.nextConfig.trailingSlash &amp;&amp;</span><span class="s3">\n          </span><span class="s1">pathname.length &gt; 1 &amp;&amp;</span><span class="s3">\n          </span><span class="s1">pathname.endsWith('/')</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">pathname = pathname.substring(0, pathname.length - 1)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (this.i18nProvider) {</span><span class="s3">\n        </span><span class="s1">// Remove the port from the hostname if present.</span><span class="s3">\n        </span><span class="s1">const hostname = req?.headers.host?.split(':', 1)[0].toLowerCase()</span><span class="s3">\n\n        </span><span class="s1">const domainLocale = this.i18nProvider.detectDomainLocale(hostname)</span><span class="s3">\n        </span><span class="s1">const defaultLocale =</span><span class="s3">\n          </span><span class="s1">domainLocale?.defaultLocale ?? this.i18nProvider.config.defaultLocale</span><span class="s3">\n\n        </span><span class="s1">const localePathResult = this.i18nProvider.analyze(pathname)</span><span class="s3">\n\n        </span><span class="s1">// If the locale is detected from the path, we need to remove it</span><span class="s3">\n        </span><span class="s1">// from the pathname.</span><span class="s3">\n        </span><span class="s1">if (localePathResult.detectedLocale) {</span><span class="s3">\n          </span><span class="s1">pathname = localePathResult.pathname</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Update the query with the detected locale and default locale.</span><span class="s3">\n        </span><span class="s1">addRequestMeta(req, 'locale', localePathResult.detectedLocale)</span><span class="s3">\n        </span><span class="s1">addRequestMeta(req, 'defaultLocale', defaultLocale)</span><span class="s3">\n\n        </span><span class="s1">// If the locale is not detected from the path, we need to mark that</span><span class="s3">\n        </span><span class="s1">// it was not inferred from default.</span><span class="s3">\n        </span><span class="s1">if (!localePathResult.detectedLocale) {</span><span class="s3">\n          </span><span class="s1">removeRequestMeta(req, 'localeInferredFromDefault')</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// If no locale was detected and we don't have middleware, we need</span><span class="s3">\n        </span><span class="s1">// to render a 404 page.</span><span class="s3">\n        </span><span class="s1">if (!localePathResult.detectedLocale &amp;&amp; !middleware) {</span><span class="s3">\n          </span><span class="s1">addRequestMeta(req, 'locale', defaultLocale)</span><span class="s3">\n          </span><span class="s1">await this.render404(req, res, parsedUrl)</span><span class="s3">\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">parsedUrl.pathname = pathname</span><span class="s3">\n      </span><span class="s1">addRequestMeta(req, 'isNextDataReq', true)</span><span class="s3">\n\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected handleNextImageRequest: RouteHandler&lt;</span><span class="s3">\n    </span><span class="s1">ServerRequest,</span><span class="s3">\n    </span><span class="s1">ServerResponse</span><span class="s3">\n  </span><span class="s1">&gt; = () =&gt; false</span><span class="s3">\n\n  </span><span class="s1">protected handleCatchallRenderRequest: RouteHandler&lt;</span><span class="s3">\n    </span><span class="s1">ServerRequest,</span><span class="s3">\n    </span><span class="s1">ServerResponse</span><span class="s3">\n  </span><span class="s1">&gt; = () =&gt; false</span><span class="s3">\n\n  </span><span class="s1">protected handleCatchallMiddlewareRequest: RouteHandler&lt;</span><span class="s3">\n    </span><span class="s1">ServerRequest,</span><span class="s3">\n    </span><span class="s1">ServerResponse</span><span class="s3">\n  </span><span class="s1">&gt; = () =&gt; false</span><span class="s3">\n\n  </span><span class="s1">protected getRouteMatchers(): RouteMatcherManager {</span><span class="s3">\n    </span><span class="s1">// Create a new manifest loader that get's the manifests from the server.</span><span class="s3">\n    </span><span class="s1">const manifestLoader = new ServerManifestLoader((name) =&gt; {</span><span class="s3">\n      </span><span class="s1">switch (name) {</span><span class="s3">\n        </span><span class="s1">case PAGES_MANIFEST:</span><span class="s3">\n          </span><span class="s1">return this.getPagesManifest() ?? null</span><span class="s3">\n        </span><span class="s1">case APP_PATHS_MANIFEST:</span><span class="s3">\n          </span><span class="s1">return this.getAppPathsManifest() ?? null</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n          </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">// Configure the matchers and handlers.</span><span class="s3">\n    </span><span class="s1">const matchers: RouteMatcherManager = new DefaultRouteMatcherManager()</span><span class="s3">\n\n    </span><span class="s1">// Match pages under `pages/`.</span><span class="s3">\n    </span><span class="s1">matchers.push(</span><span class="s3">\n      </span><span class="s1">new PagesRouteMatcherProvider(</span><span class="s3">\n        </span><span class="s1">this.distDir,</span><span class="s3">\n        </span><span class="s1">manifestLoader,</span><span class="s3">\n        </span><span class="s1">this.i18nProvider</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">// Match api routes under `pages/api/`.</span><span class="s3">\n    </span><span class="s1">matchers.push(</span><span class="s3">\n      </span><span class="s1">new PagesAPIRouteMatcherProvider(</span><span class="s3">\n        </span><span class="s1">this.distDir,</span><span class="s3">\n        </span><span class="s1">manifestLoader,</span><span class="s3">\n        </span><span class="s1">this.i18nProvider</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">// If the app directory is enabled, then add the app matchers and handlers.</span><span class="s3">\n    </span><span class="s1">if (this.enabledDirectories.app) {</span><span class="s3">\n      </span><span class="s1">// Match app pages under `app/`.</span><span class="s3">\n      </span><span class="s1">matchers.push(</span><span class="s3">\n        </span><span class="s1">new AppPageRouteMatcherProvider(this.distDir, manifestLoader)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">matchers.push(</span><span class="s3">\n        </span><span class="s1">new AppRouteRouteMatcherProvider(this.distDir, manifestLoader)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return matchers</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async instrumentationOnRequestError(</span><span class="s3">\n    </span><span class="s1">...args: Parameters&lt;ServerOnInstrumentationRequestError&gt;</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const [err, req, ctx] = args</span><span class="s3">\n\n    </span><span class="s1">if (this.instrumentation) {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">await this.instrumentation.onRequestError?.(</span><span class="s3">\n          </span><span class="s1">err,</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">path: req.url || '',</span><span class="s3">\n            </span><span class="s1">method: req.method || 'GET',</span><span class="s3">\n            </span><span class="s1">// Normalize middleware headers and other server request headers</span><span class="s3">\n            </span><span class="s1">headers:</span><span class="s3">\n              </span><span class="s1">req instanceof NextRequestHint</span><span class="s3">\n                </span><span class="s1">? Object.fromEntries(req.headers.entries())</span><span class="s3">\n                </span><span class="s1">: req.headers,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">ctx</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} catch (handlerErr) {</span><span class="s3">\n        </span><span class="s1">// Log the soft error and continue, since errors can thrown from react stream handler</span><span class="s3">\n        </span><span class="s1">console.error('Error in instrumentation.onRequestError:', handlerErr)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public logError(err: Error): void {</span><span class="s3">\n    </span><span class="s1">if (this.quiet) return</span><span class="s3">\n    </span><span class="s1">Log.error(err)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async handleRequest(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">parsedUrl?: NextUrlWithParsedQuery</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">await this.prepare()</span><span class="s3">\n    </span><span class="s1">const method = req.method.toUpperCase()</span><span class="s3">\n\n    </span><span class="s1">const tracer = getTracer()</span><span class="s3">\n    </span><span class="s1">return tracer.withPropagatedContext(req.headers, () =&gt; {</span><span class="s3">\n      </span><span class="s1">return tracer.trace(</span><span class="s3">\n        </span><span class="s1">BaseServerSpan.handleRequest,</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">spanName: `${method} ${req.url}`,</span><span class="s3">\n          </span><span class="s1">kind: SpanKind.SERVER,</span><span class="s3">\n          </span><span class="s1">attributes: {</span><span class="s3">\n            </span><span class="s1">'http.method': method,</span><span class="s3">\n            </span><span class="s1">'http.target': req.url,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">async (span) =&gt;</span><span class="s3">\n          </span><span class="s1">this.handleRequestImpl(req, res, parsedUrl).finally(() =&gt; {</span><span class="s3">\n            </span><span class="s1">if (!span) return</span><span class="s3">\n\n            </span><span class="s1">const isRSCRequest = getRequestMeta(req, 'isRSCRequest') ?? false</span><span class="s3">\n            </span><span class="s1">span.setAttributes({</span><span class="s3">\n              </span><span class="s1">'http.status_code': res.statusCode,</span><span class="s3">\n              </span><span class="s1">'next.rsc': isRSCRequest,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n\n            </span><span class="s1">if (res.statusCode &amp;&amp; res.statusCode &gt;= 500) {</span><span class="s3">\n              </span><span class="s1">// For 5xx status codes: SHOULD be set to 'Error' span status.</span><span class="s3">\n              </span><span class="s1">// x-ref: https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status</span><span class="s3">\n              </span><span class="s1">span.setStatus({</span><span class="s3">\n                </span><span class="s1">code: SpanStatusCode.ERROR,</span><span class="s3">\n              </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">// For span status 'Error', SHOULD set 'error.type' attribute.</span><span class="s3">\n              </span><span class="s1">span.setAttribute('error.type', res.statusCode.toString())</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const rootSpanAttributes = tracer.getRootSpanAttributes()</span><span class="s3">\n            </span><span class="s1">// We were unable to get attributes, probably OTEL is not enabled</span><span class="s3">\n            </span><span class="s1">if (!rootSpanAttributes) return</span><span class="s3">\n\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">rootSpanAttributes.get('next.span_type') !==</span><span class="s3">\n              </span><span class="s1">BaseServerSpan.handleRequest</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">console.warn(</span><span class="s3">\n                </span><span class="s1">`Unexpected root span type '${rootSpanAttributes.get(</span><span class="s3">\n                  </span><span class="s1">'next.span_type'</span><span class="s3">\n                </span><span class="s1">)}'. Please report this Next.js issue https://github.com/vercel/next.js`</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">return</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const route = rootSpanAttributes.get('next.route')</span><span class="s3">\n            </span><span class="s1">if (route) {</span><span class="s3">\n              </span><span class="s1">const name = isRSCRequest</span><span class="s3">\n                </span><span class="s1">? `RSC ${method} ${route}`</span><span class="s3">\n                </span><span class="s1">: `${method} ${route}`</span><span class="s3">\n\n              </span><span class="s1">span.setAttributes({</span><span class="s3">\n                </span><span class="s1">'next.route': route,</span><span class="s3">\n                </span><span class="s1">'http.route': route,</span><span class="s3">\n                </span><span class="s1">'next.span_name': name,</span><span class="s3">\n              </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">span.updateName(name)</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">span.updateName(</span><span class="s3">\n                </span><span class="s1">isRSCRequest</span><span class="s3">\n                  </span><span class="s1">? `RSC ${method} ${req.url}`</span><span class="s3">\n                  </span><span class="s1">: `${method} ${req.url}`</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async handleRequestImpl(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">parsedUrl?: NextUrlWithParsedQuery</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">// Wait for the matchers to be ready.</span><span class="s3">\n      </span><span class="s1">await this.matchers.waitTillReady()</span><span class="s3">\n\n      </span><span class="s1">// ensure cookies set in middleware are merged and</span><span class="s3">\n      </span><span class="s1">// not overridden by API routes/getServerSideProps</span><span class="s3">\n      </span><span class="s1">patchSetHeaderWithCookieSupport(</span><span class="s3">\n        </span><span class="s1">req,</span><span class="s3">\n        </span><span class="s1">isNodeNextResponse(res) ? res.originalResponse : res</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">const urlParts = (req.url || '').split('?', 1)</span><span class="s3">\n      </span><span class="s1">const urlNoQuery = urlParts[0]</span><span class="s3">\n\n      </span><span class="s1">// this normalizes repeated slashes in the path e.g. hello//world -&gt;</span><span class="s3">\n      </span><span class="s1">// hello/world or backslashes to forward slashes, this does not</span><span class="s3">\n      </span><span class="s1">// handle trailing slash as that is handled the same as a next.config.js</span><span class="s3">\n      </span><span class="s1">// redirect</span><span class="s3">\n      </span><span class="s1">if (urlNoQuery?.match(/(</span><span class="s3">\\\\</span><span class="s1">|</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/)/)) {</span><span class="s3">\n        </span><span class="s1">const cleanUrl = normalizeRepeatedSlashes(req.url!)</span><span class="s3">\n        </span><span class="s1">res.redirect(cleanUrl, 308).body(cleanUrl).send()</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Parse url if parsedUrl not provided</span><span class="s3">\n      </span><span class="s1">if (!parsedUrl || typeof parsedUrl !== 'object') {</span><span class="s3">\n        </span><span class="s1">if (!req.url) {</span><span class="s3">\n          </span><span class="s1">throw new Error('Invariant: url can not be undefined')</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">parsedUrl = parseUrl(req.url!, true)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (!parsedUrl.pathname) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Invariant: pathname can't be empty</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Parse the querystring ourselves if the user doesn't handle querystring parsing</span><span class="s3">\n      </span><span class="s1">if (typeof parsedUrl.query === 'string') {</span><span class="s3">\n        </span><span class="s1">parsedUrl.query = Object.fromEntries(</span><span class="s3">\n          </span><span class="s1">new URLSearchParams(parsedUrl.query)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Update the `x-forwarded-*` headers.</span><span class="s3">\n      </span><span class="s1">const { originalRequest = null } = isNodeNextRequest(req) ? req : {}</span><span class="s3">\n      </span><span class="s1">const xForwardedProto = originalRequest?.headers['x-forwarded-proto']</span><span class="s3">\n      </span><span class="s1">const isHttps = xForwardedProto</span><span class="s3">\n        </span><span class="s1">? xForwardedProto === 'https'</span><span class="s3">\n        </span><span class="s1">: !!(originalRequest?.socket as TLSSocket)?.encrypted</span><span class="s3">\n\n      </span><span class="s1">req.headers['x-forwarded-host'] ??= req.headers['host'] ?? this.hostname</span><span class="s3">\n      </span><span class="s1">req.headers['x-forwarded-port'] ??= this.port</span><span class="s3">\n        </span><span class="s1">? this.port.toString()</span><span class="s3">\n        </span><span class="s1">: isHttps</span><span class="s3">\n          </span><span class="s1">? '443'</span><span class="s3">\n          </span><span class="s1">: '80'</span><span class="s3">\n      </span><span class="s1">req.headers['x-forwarded-proto'] ??= isHttps ? 'https' : 'http'</span><span class="s3">\n      </span><span class="s1">req.headers['x-forwarded-for'] ??= originalRequest?.socket?.remoteAddress</span><span class="s3">\n\n      </span><span class="s1">// This should be done before any normalization of the pathname happens as</span><span class="s3">\n      </span><span class="s1">// it captures the initial URL.</span><span class="s3">\n      </span><span class="s1">this.attachRequestMeta(req, parsedUrl)</span><span class="s3">\n\n      </span><span class="s1">let finished = await this.handleRSCRequest(req, res, parsedUrl)</span><span class="s3">\n      </span><span class="s1">if (finished) return</span><span class="s3">\n\n      </span><span class="s1">const domainLocale = this.i18nProvider?.detectDomainLocale(</span><span class="s3">\n        </span><span class="s1">getHostname(parsedUrl, req.headers)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">const defaultLocale =</span><span class="s3">\n        </span><span class="s1">domainLocale?.defaultLocale || this.nextConfig.i18n?.defaultLocale</span><span class="s3">\n      </span><span class="s1">addRequestMeta(req, 'defaultLocale', defaultLocale)</span><span class="s3">\n\n      </span><span class="s1">const url = parseUrlUtil(req.url.replace(/^</span><span class="s3">\\</span><span class="s1">/+/, '/'))</span><span class="s3">\n      </span><span class="s1">const pathnameInfo = getNextPathnameInfo(url.pathname, {</span><span class="s3">\n        </span><span class="s1">nextConfig: this.nextConfig,</span><span class="s3">\n        </span><span class="s1">i18nProvider: this.i18nProvider,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">url.pathname = pathnameInfo.pathname</span><span class="s3">\n\n      </span><span class="s1">if (pathnameInfo.basePath) {</span><span class="s3">\n        </span><span class="s1">req.url = removePathPrefix(req.url!, this.nextConfig.basePath)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const useMatchedPathHeader =</span><span class="s3">\n        </span><span class="s1">this.minimalMode &amp;&amp; typeof req.headers[MATCHED_PATH_HEADER] === 'string'</span><span class="s3">\n\n      </span><span class="s1">// TODO: merge handling with invokePath</span><span class="s3">\n      </span><span class="s1">if (useMatchedPathHeader) {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">if (this.enabledDirectories.app) {</span><span class="s3">\n            </span><span class="s1">// ensure /index path is normalized for prerender</span><span class="s3">\n            </span><span class="s1">// in minimal mode</span><span class="s3">\n            </span><span class="s1">if (req.url.match(/^</span><span class="s3">\\</span><span class="s1">/index($|</span><span class="s3">\\</span><span class="s1">?)/)) {</span><span class="s3">\n              </span><span class="s1">req.url = req.url.replace(/^</span><span class="s3">\\</span><span class="s1">/index/, '/')</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">parsedUrl.pathname =</span><span class="s3">\n              </span><span class="s1">parsedUrl.pathname === '/index' ? '/' : parsedUrl.pathname</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// x-matched-path is the source of truth, it tells what page</span><span class="s3">\n          </span><span class="s1">// should be rendered because we don't process rewrites in minimalMode</span><span class="s3">\n          </span><span class="s1">let { pathname: matchedPath } = new URL(</span><span class="s3">\n            </span><span class="s1">fixMojibake(req.headers[MATCHED_PATH_HEADER] as string),</span><span class="s3">\n            </span><span class="s1">'http://localhost'</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">let { pathname: urlPathname } = new URL(req.url, 'http://localhost')</span><span class="s3">\n\n          </span><span class="s1">// For ISR the URL is normalized to the prerenderPath so if</span><span class="s3">\n          </span><span class="s1">// it's a data request the URL path will be the data URL,</span><span class="s3">\n          </span><span class="s1">// basePath is already stripped by this point</span><span class="s3">\n          </span><span class="s1">if (this.normalizers.data?.match(urlPathname)) {</span><span class="s3">\n            </span><span class="s1">addRequestMeta(req, 'isNextDataReq', true)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">// In minimal mode, if PPR is enabled, then we should check to see if</span><span class="s3">\n          </span><span class="s1">// the request should be a resume request.</span><span class="s3">\n          </span><span class="s1">else if (</span><span class="s3">\n            </span><span class="s1">this.isAppPPREnabled &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.minimalMode &amp;&amp;</span><span class="s3">\n            </span><span class="s1">req.headers[NEXT_RESUME_HEADER] === '1' &amp;&amp;</span><span class="s3">\n            </span><span class="s1">req.method === 'POST'</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">// Decode the postponed state from the request body, it will come as</span><span class="s3">\n            </span><span class="s1">// an array of buffers, so collect them and then concat them to form</span><span class="s3">\n            </span><span class="s1">// the string.</span><span class="s3">\n            </span><span class="s1">const body: Array&lt;Buffer&gt; = []</span><span class="s3">\n            </span><span class="s1">for await (const chunk of req.body) {</span><span class="s3">\n              </span><span class="s1">body.push(chunk)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const postponed = Buffer.concat(body).toString('utf8')</span><span class="s3">\n\n            </span><span class="s1">addRequestMeta(req, 'postponed', postponed)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">matchedPath = this.normalize(matchedPath)</span><span class="s3">\n          </span><span class="s1">const normalizedUrlPath = this.stripNextDataPath(urlPathname)</span><span class="s3">\n\n          </span><span class="s1">matchedPath = denormalizePagePath(matchedPath)</span><span class="s3">\n\n          </span><span class="s1">// Perform locale detection and normalization.</span><span class="s3">\n          </span><span class="s1">const localeAnalysisResult = this.i18nProvider?.analyze(matchedPath, {</span><span class="s3">\n            </span><span class="s1">defaultLocale,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n\n          </span><span class="s1">// The locale result will be defined even if the locale was not</span><span class="s3">\n          </span><span class="s1">// detected for the request because it will be inferred from the</span><span class="s3">\n          </span><span class="s1">// default locale.</span><span class="s3">\n          </span><span class="s1">if (localeAnalysisResult) {</span><span class="s3">\n            </span><span class="s1">addRequestMeta(req, 'locale', localeAnalysisResult.detectedLocale)</span><span class="s3">\n\n            </span><span class="s1">// If the detected locale was inferred from the default locale, we</span><span class="s3">\n            </span><span class="s1">// need to modify the metadata on the request to indicate that.</span><span class="s3">\n            </span><span class="s1">if (localeAnalysisResult.inferredFromDefault) {</span><span class="s3">\n              </span><span class="s1">addRequestMeta(req, 'localeInferredFromDefault', true)</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">removeRequestMeta(req, 'localeInferredFromDefault')</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">let srcPathname = matchedPath</span><span class="s3">\n          </span><span class="s1">let pageIsDynamic = isDynamicRoute(srcPathname)</span><span class="s3">\n          </span><span class="s1">let paramsResult: {</span><span class="s3">\n            </span><span class="s1">params: ParsedUrlQuery | false</span><span class="s3">\n            </span><span class="s1">hasValidParams: boolean</span><span class="s3">\n          </span><span class="s1">} = {</span><span class="s3">\n            </span><span class="s1">params: false,</span><span class="s3">\n            </span><span class="s1">hasValidParams: false,</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (!pageIsDynamic) {</span><span class="s3">\n            </span><span class="s1">const match = await this.matchers.match(srcPathname, {</span><span class="s3">\n              </span><span class="s1">i18n: localeAnalysisResult,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n\n            </span><span class="s1">// Update the source pathname to the matched page's pathname.</span><span class="s3">\n            </span><span class="s1">if (match) {</span><span class="s3">\n              </span><span class="s1">srcPathname = match.definition.pathname</span><span class="s3">\n\n              </span><span class="s1">// The page is dynamic if the params are defined. We know at this</span><span class="s3">\n              </span><span class="s1">// stage that the matched path is not a static page if the params</span><span class="s3">\n              </span><span class="s1">// were parsed from the matched path header.</span><span class="s3">\n              </span><span class="s1">if (typeof match.params !== 'undefined') {</span><span class="s3">\n                </span><span class="s1">pageIsDynamic = true</span><span class="s3">\n                </span><span class="s1">paramsResult.params = match.params</span><span class="s3">\n                </span><span class="s1">paramsResult.hasValidParams = true</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// The rest of this function can't handle i18n properly, so ensure we</span><span class="s3">\n          </span><span class="s1">// restore the pathname with the locale information stripped from it</span><span class="s3">\n          </span><span class="s1">// now that we're done matching if we're using i18n.</span><span class="s3">\n          </span><span class="s1">if (localeAnalysisResult) {</span><span class="s3">\n            </span><span class="s1">matchedPath = localeAnalysisResult.pathname</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">const utils = getServerUtils({</span><span class="s3">\n            </span><span class="s1">pageIsDynamic,</span><span class="s3">\n            </span><span class="s1">page: srcPathname,</span><span class="s3">\n            </span><span class="s1">i18n: this.nextConfig.i18n,</span><span class="s3">\n            </span><span class="s1">basePath: this.nextConfig.basePath,</span><span class="s3">\n            </span><span class="s1">rewrites: this.getRoutesManifest()?.rewrites || {</span><span class="s3">\n              </span><span class="s1">beforeFiles: [],</span><span class="s3">\n              </span><span class="s1">afterFiles: [],</span><span class="s3">\n              </span><span class="s1">fallback: [],</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">caseSensitive: !!this.nextConfig.experimental.caseSensitiveRoutes,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n\n          </span><span class="s1">// Ensure parsedUrl.pathname includes locale before processing</span><span class="s3">\n          </span><span class="s1">// rewrites or they won't match correctly.</span><span class="s3">\n          </span><span class="s1">if (defaultLocale &amp;&amp; !pathnameInfo.locale) {</span><span class="s3">\n            </span><span class="s1">parsedUrl.pathname = `/${defaultLocale}${parsedUrl.pathname}`</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// Store a copy of `parsedUrl.query` before calling handleRewrites.</span><span class="s3">\n          </span><span class="s1">// Since `handleRewrites` might add new queries to `parsedUrl.query`.</span><span class="s3">\n          </span><span class="s1">const originQueryParams = { ...parsedUrl.query }</span><span class="s3">\n\n          </span><span class="s1">const pathnameBeforeRewrite = parsedUrl.pathname</span><span class="s3">\n          </span><span class="s1">const rewriteParamKeys = Object.keys(</span><span class="s3">\n            </span><span class="s1">utils.handleRewrites(req, parsedUrl)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">// Create a copy of the query params to avoid mutating the original</span><span class="s3">\n          </span><span class="s1">// object. This prevents any overlapping query params that have the</span><span class="s3">\n          </span><span class="s1">// same normalized key from causing issues.</span><span class="s3">\n          </span><span class="s1">const queryParams = { ...parsedUrl.query }</span><span class="s3">\n          </span><span class="s1">const didRewrite = pathnameBeforeRewrite !== parsedUrl.pathname</span><span class="s3">\n\n          </span><span class="s1">if (didRewrite &amp;&amp; parsedUrl.pathname) {</span><span class="s3">\n            </span><span class="s1">addRequestMeta(req, 'rewroteURL', parsedUrl.pathname)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">const routeParamKeys = new Set&lt;string&gt;()</span><span class="s3">\n          </span><span class="s1">for (const [key, value] of Object.entries(parsedUrl.query)) {</span><span class="s3">\n            </span><span class="s1">const normalizedKey = normalizeNextQueryParam(key)</span><span class="s3">\n            </span><span class="s1">if (!normalizedKey) continue</span><span class="s3">\n\n            </span><span class="s1">// Remove the prefixed key from the query params because we want</span><span class="s3">\n            </span><span class="s1">// to consume it for the dynamic route matcher.</span><span class="s3">\n            </span><span class="s1">delete parsedUrl.query[key]</span><span class="s3">\n            </span><span class="s1">routeParamKeys.add(normalizedKey)</span><span class="s3">\n\n            </span><span class="s1">if (typeof value === 'undefined') continue</span><span class="s3">\n\n            </span><span class="s1">queryParams[normalizedKey] = Array.isArray(value)</span><span class="s3">\n              </span><span class="s1">? value.map((v) =&gt; decodeQueryPathParameter(v))</span><span class="s3">\n              </span><span class="s1">: decodeQueryPathParameter(value)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// interpolate dynamic params and normalize URL if needed</span><span class="s3">\n          </span><span class="s1">if (pageIsDynamic) {</span><span class="s3">\n            </span><span class="s1">let params: ParsedUrlQuery | false = {}</span><span class="s3">\n\n            </span><span class="s1">// If we don't already have valid params, try to parse them from</span><span class="s3">\n            </span><span class="s1">// the query params.</span><span class="s3">\n            </span><span class="s1">if (!paramsResult.hasValidParams) {</span><span class="s3">\n              </span><span class="s1">paramsResult = utils.normalizeDynamicRouteParams(</span><span class="s3">\n                </span><span class="s1">queryParams,</span><span class="s3">\n                </span><span class="s1">false</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// for prerendered ISR paths we attempt parsing the route</span><span class="s3">\n            </span><span class="s1">// params from the URL directly as route-matches may not</span><span class="s3">\n            </span><span class="s1">// contain the correct values due to the filesystem path</span><span class="s3">\n            </span><span class="s1">// matching before the dynamic route has been matched</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">!paramsResult.hasValidParams &amp;&amp;</span><span class="s3">\n              </span><span class="s1">!isDynamicRoute(normalizedUrlPath)</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">let matcherParams = utils.dynamicRouteMatcher?.(normalizedUrlPath)</span><span class="s3">\n\n              </span><span class="s1">if (matcherParams) {</span><span class="s3">\n                </span><span class="s1">utils.normalizeDynamicRouteParams(matcherParams, false)</span><span class="s3">\n                </span><span class="s1">Object.assign(paramsResult.params, matcherParams)</span><span class="s3">\n                </span><span class="s1">paramsResult.hasValidParams = true</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// if an action request is bypassing a prerender and we</span><span class="s3">\n            </span><span class="s1">// don't have the params in the URL since it was prerendered</span><span class="s3">\n            </span><span class="s1">// and matched during handle: 'filesystem' rather than dynamic route</span><span class="s3">\n            </span><span class="s1">// resolving we need to parse the params from the matched-path.</span><span class="s3">\n            </span><span class="s1">// Note: this is similar to above case but from match-path instead</span><span class="s3">\n            </span><span class="s1">// of from the request URL since a rewrite could cause that to not</span><span class="s3">\n            </span><span class="s1">// match the src pathname</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">// we can have a collision with /index and a top-level /[slug]</span><span class="s3">\n              </span><span class="s1">matchedPath !== '/index' &amp;&amp;</span><span class="s3">\n              </span><span class="s1">!paramsResult.hasValidParams &amp;&amp;</span><span class="s3">\n              </span><span class="s1">!isDynamicRoute(matchedPath)</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">let matcherParams = utils.dynamicRouteMatcher?.(matchedPath)</span><span class="s3">\n\n              </span><span class="s1">if (matcherParams) {</span><span class="s3">\n                </span><span class="s1">const curParamsResult = utils.normalizeDynamicRouteParams(</span><span class="s3">\n                  </span><span class="s1">matcherParams,</span><span class="s3">\n                  </span><span class="s1">false</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n\n                </span><span class="s1">if (curParamsResult.hasValidParams) {</span><span class="s3">\n                  </span><span class="s1">Object.assign(params, matcherParams)</span><span class="s3">\n                  </span><span class="s1">paramsResult = curParamsResult</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (paramsResult.hasValidParams) {</span><span class="s3">\n              </span><span class="s1">params = paramsResult.params</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const routeMatchesHeader = req.headers['x-now-route-matches']</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">typeof routeMatchesHeader === 'string' &amp;&amp;</span><span class="s3">\n              </span><span class="s1">routeMatchesHeader &amp;&amp;</span><span class="s3">\n              </span><span class="s1">isDynamicRoute(matchedPath) &amp;&amp;</span><span class="s3">\n              </span><span class="s1">!paramsResult.hasValidParams</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">const routeMatches =</span><span class="s3">\n                </span><span class="s1">utils.getParamsFromRouteMatches(routeMatchesHeader)</span><span class="s3">\n\n              </span><span class="s1">if (routeMatches) {</span><span class="s3">\n                </span><span class="s1">paramsResult = utils.normalizeDynamicRouteParams(</span><span class="s3">\n                  </span><span class="s1">routeMatches,</span><span class="s3">\n                  </span><span class="s1">true</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n\n                </span><span class="s1">if (paramsResult.hasValidParams) {</span><span class="s3">\n                  </span><span class="s1">params = paramsResult.params</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// Try to parse the params from the query if we couldn't parse them</span><span class="s3">\n            </span><span class="s1">// from the route matches but ignore missing optional params.</span><span class="s3">\n            </span><span class="s1">if (!paramsResult.hasValidParams) {</span><span class="s3">\n              </span><span class="s1">paramsResult = utils.normalizeDynamicRouteParams(</span><span class="s3">\n                </span><span class="s1">queryParams,</span><span class="s3">\n                </span><span class="s1">true</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n\n              </span><span class="s1">if (paramsResult.hasValidParams) {</span><span class="s3">\n                </span><span class="s1">params = paramsResult.params</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// If the pathname being requested is the same as the source</span><span class="s3">\n            </span><span class="s1">// pathname, and we don't have valid params, we want to use the</span><span class="s3">\n            </span><span class="s1">// default route matches.</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">utils.defaultRouteMatches &amp;&amp;</span><span class="s3">\n              </span><span class="s1">normalizedUrlPath === srcPathname &amp;&amp;</span><span class="s3">\n              </span><span class="s1">!paramsResult.hasValidParams</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">params = utils.defaultRouteMatches</span><span class="s3">\n\n              </span><span class="s1">// If the route matches header is an empty string, we want to</span><span class="s3">\n              </span><span class="s1">// render a fallback shell. This is because we know this came from</span><span class="s3">\n              </span><span class="s1">// a prerender (it has the header) but it's values were filtered</span><span class="s3">\n              </span><span class="s1">// out (because the allowQuery was empty). If it was undefined</span><span class="s3">\n              </span><span class="s1">// then we know that the request is hitting the lambda directly.</span><span class="s3">\n              </span><span class="s1">if (routeMatchesHeader === '') {</span><span class="s3">\n                </span><span class="s1">addRequestMeta(req, 'renderFallbackShell', true)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (params) {</span><span class="s3">\n              </span><span class="s1">matchedPath = utils.interpolateDynamicPath(srcPathname, params)</span><span class="s3">\n              </span><span class="s1">req.url = utils.interpolateDynamicPath(req.url!, params)</span><span class="s3">\n\n              </span><span class="s1">// If the request is for a segment prefetch, we need to update the</span><span class="s3">\n              </span><span class="s1">// segment prefetch request path to include the interpolated</span><span class="s3">\n              </span><span class="s1">// params.</span><span class="s3">\n              </span><span class="s1">let segmentPrefetchRSCRequest = getRequestMeta(</span><span class="s3">\n                </span><span class="s1">req,</span><span class="s3">\n                </span><span class="s1">'segmentPrefetchRSCRequest'</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">if (</span><span class="s3">\n                </span><span class="s1">segmentPrefetchRSCRequest &amp;&amp;</span><span class="s3">\n                </span><span class="s1">isDynamicRoute(segmentPrefetchRSCRequest, false)</span><span class="s3">\n              </span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">segmentPrefetchRSCRequest = utils.interpolateDynamicPath(</span><span class="s3">\n                  </span><span class="s1">segmentPrefetchRSCRequest,</span><span class="s3">\n                  </span><span class="s1">params</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n\n                </span><span class="s1">req.headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] =</span><span class="s3">\n                  </span><span class="s1">segmentPrefetchRSCRequest</span><span class="s3">\n                </span><span class="s1">addRequestMeta(</span><span class="s3">\n                  </span><span class="s1">req,</span><span class="s3">\n                  </span><span class="s1">'segmentPrefetchRSCRequest',</span><span class="s3">\n                  </span><span class="s1">segmentPrefetchRSCRequest</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (pageIsDynamic || didRewrite) {</span><span class="s3">\n            </span><span class="s1">utils.normalizeCdnUrl(req, [</span><span class="s3">\n              </span><span class="s1">...rewriteParamKeys,</span><span class="s3">\n              </span><span class="s1">...Object.keys(utils.defaultRouteRegex?.groups || {}),</span><span class="s3">\n            </span><span class="s1">])</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">// Remove the route `params` keys from `parsedUrl.query` if they are</span><span class="s3">\n          </span><span class="s1">// not in the original query params.</span><span class="s3">\n          </span><span class="s1">// If it's used in both route `params` and query `searchParams`, it should be kept.</span><span class="s3">\n          </span><span class="s1">for (const key of routeParamKeys) {</span><span class="s3">\n            </span><span class="s1">if (!(key in originQueryParams)) {</span><span class="s3">\n              </span><span class="s1">delete parsedUrl.query[key]</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">parsedUrl.pathname = matchedPath</span><span class="s3">\n          </span><span class="s1">url.pathname = parsedUrl.pathname</span><span class="s3">\n          </span><span class="s1">finished = await this.normalizeAndAttachMetadata(req, res, parsedUrl)</span><span class="s3">\n          </span><span class="s1">if (finished) return</span><span class="s3">\n        </span><span class="s1">} catch (err) {</span><span class="s3">\n          </span><span class="s1">if (err instanceof DecodeError || err instanceof NormalizeError) {</span><span class="s3">\n            </span><span class="s1">res.statusCode = 400</span><span class="s3">\n            </span><span class="s1">return this.renderError(null, req, res, '/_error', {})</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">throw err</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">addRequestMeta(req, 'isLocaleDomain', Boolean(domainLocale))</span><span class="s3">\n\n      </span><span class="s1">if (pathnameInfo.locale) {</span><span class="s3">\n        </span><span class="s1">req.url = formatUrl(url)</span><span class="s3">\n        </span><span class="s1">addRequestMeta(req, 'didStripLocale', true)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// If we aren't in minimal mode or there is no locale in the query</span><span class="s3">\n      </span><span class="s1">// string, add the locale to the query string.</span><span class="s3">\n      </span><span class="s1">if (!this.minimalMode || !getRequestMeta(req, 'locale')) {</span><span class="s3">\n        </span><span class="s1">// If the locale is in the pathname, add it to the query string.</span><span class="s3">\n        </span><span class="s1">if (pathnameInfo.locale) {</span><span class="s3">\n          </span><span class="s1">addRequestMeta(req, 'locale', pathnameInfo.locale)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// If the default locale is available, add it to the query string and</span><span class="s3">\n        </span><span class="s1">// mark it as inferred rather than implicit.</span><span class="s3">\n        </span><span class="s1">else if (defaultLocale) {</span><span class="s3">\n          </span><span class="s1">addRequestMeta(req, 'locale', defaultLocale)</span><span class="s3">\n          </span><span class="s1">addRequestMeta(req, 'localeInferredFromDefault', true)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// set incremental cache to request meta so it can</span><span class="s3">\n      </span><span class="s1">// be passed down for edge functions and the fetch disk</span><span class="s3">\n      </span><span class="s1">// cache can be leveraged locally</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!(this.serverOptions as any).webServerConfig &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!getRequestMeta(req, 'incrementalCache')</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">const incrementalCache = await this.getIncrementalCache({</span><span class="s3">\n          </span><span class="s1">requestHeaders: Object.assign({}, req.headers),</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">incrementalCache.resetRequestCache()</span><span class="s3">\n        </span><span class="s1">addRequestMeta(req, 'incrementalCache', incrementalCache)</span><span class="s3">\n        </span><span class="s1">// This is needed for pages router to leverage unstable_cache</span><span class="s3">\n        </span><span class="s1">// TODO: re-work this handling to not use global and use a AsyncStore</span><span class="s3">\n        </span><span class="s1">;(globalThis as any).__incrementalCache = incrementalCache</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const cacheHandlers = getCacheHandlers()</span><span class="s3">\n\n      </span><span class="s1">if (cacheHandlers) {</span><span class="s3">\n        </span><span class="s1">await Promise.all(</span><span class="s3">\n          </span><span class="s1">[...cacheHandlers].map(async (cacheHandler) =&gt; {</span><span class="s3">\n            </span><span class="s1">if ('refreshTags' in cacheHandler) {</span><span class="s3">\n              </span><span class="s1">// Note: cacheHandler.refreshTags() is called lazily before the</span><span class="s3">\n              </span><span class="s1">// first cache entry is retrieved. It allows us to skip the</span><span class="s3">\n              </span><span class="s1">// refresh request if no caches are read at all.</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">const previouslyRevalidatedTags = getPreviouslyRevalidatedTags(</span><span class="s3">\n                </span><span class="s1">req.headers,</span><span class="s3">\n                </span><span class="s1">this.getPrerenderManifest().preview.previewModeId</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n\n              </span><span class="s1">await cacheHandler.receiveExpiredTags(</span><span class="s3">\n                </span><span class="s1">...previouslyRevalidatedTags</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// set server components HMR cache to request meta so it can be passed</span><span class="s3">\n      </span><span class="s1">// down for edge functions</span><span class="s3">\n      </span><span class="s1">if (!getRequestMeta(req, 'serverComponentsHmrCache')) {</span><span class="s3">\n        </span><span class="s1">addRequestMeta(</span><span class="s3">\n          </span><span class="s1">req,</span><span class="s3">\n          </span><span class="s1">'serverComponentsHmrCache',</span><span class="s3">\n          </span><span class="s1">this.getServerComponentsHmrCache()</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// when invokePath is specified we can short short circuit resolving</span><span class="s3">\n      </span><span class="s1">// we only honor this header if we are inside of a render worker to</span><span class="s3">\n      </span><span class="s1">// prevent external users coercing the routing path</span><span class="s3">\n      </span><span class="s1">const invokePath = getRequestMeta(req, 'invokePath')</span><span class="s3">\n      </span><span class="s1">const useInvokePath = !useMatchedPathHeader &amp;&amp; invokePath</span><span class="s3">\n\n      </span><span class="s1">if (useInvokePath) {</span><span class="s3">\n        </span><span class="s1">const invokeStatus = getRequestMeta(req, 'invokeStatus')</span><span class="s3">\n        </span><span class="s1">if (invokeStatus) {</span><span class="s3">\n          </span><span class="s1">const invokeQuery = getRequestMeta(req, 'invokeQuery')</span><span class="s3">\n\n          </span><span class="s1">if (invokeQuery) {</span><span class="s3">\n            </span><span class="s1">Object.assign(parsedUrl.query, invokeQuery)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">res.statusCode = invokeStatus</span><span class="s3">\n          </span><span class="s1">let err: Error | null = getRequestMeta(req, 'invokeError') || null</span><span class="s3">\n\n          </span><span class="s1">return this.renderError(err, req, res, '/_error', parsedUrl.query)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const parsedMatchedPath = new URL(invokePath || '/', 'http://n')</span><span class="s3">\n        </span><span class="s1">const invokePathnameInfo = getNextPathnameInfo(</span><span class="s3">\n          </span><span class="s1">parsedMatchedPath.pathname,</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">nextConfig: this.nextConfig,</span><span class="s3">\n            </span><span class="s1">parseData: false,</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">if (invokePathnameInfo.locale) {</span><span class="s3">\n          </span><span class="s1">addRequestMeta(req, 'locale', invokePathnameInfo.locale)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (parsedUrl.pathname !== parsedMatchedPath.pathname) {</span><span class="s3">\n          </span><span class="s1">parsedUrl.pathname = parsedMatchedPath.pathname</span><span class="s3">\n          </span><span class="s1">addRequestMeta(req, 'rewroteURL', invokePathnameInfo.pathname)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const normalizeResult = normalizeLocalePath(</span><span class="s3">\n          </span><span class="s1">removePathPrefix(parsedUrl.pathname, this.nextConfig.basePath || ''),</span><span class="s3">\n          </span><span class="s1">this.nextConfig.i18n?.locales</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">if (normalizeResult.detectedLocale) {</span><span class="s3">\n          </span><span class="s1">addRequestMeta(req, 'locale', normalizeResult.detectedLocale)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">parsedUrl.pathname = normalizeResult.pathname</span><span class="s3">\n\n        </span><span class="s1">for (const key of Object.keys(parsedUrl.query)) {</span><span class="s3">\n          </span><span class="s1">delete parsedUrl.query[key]</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const invokeQuery = getRequestMeta(req, 'invokeQuery')</span><span class="s3">\n\n        </span><span class="s1">if (invokeQuery) {</span><span class="s3">\n          </span><span class="s1">Object.assign(parsedUrl.query, invokeQuery)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">finished = await this.normalizeAndAttachMetadata(req, res, parsedUrl)</span><span class="s3">\n        </span><span class="s1">if (finished) return</span><span class="s3">\n\n        </span><span class="s1">await this.handleCatchallRenderRequest(req, res, parsedUrl)</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (getRequestMeta(req, 'middlewareInvoke')) {</span><span class="s3">\n        </span><span class="s1">finished = await this.normalizeAndAttachMetadata(req, res, parsedUrl)</span><span class="s3">\n        </span><span class="s1">if (finished) return</span><span class="s3">\n\n        </span><span class="s1">finished = await this.handleCatchallMiddlewareRequest(</span><span class="s3">\n          </span><span class="s1">req,</span><span class="s3">\n          </span><span class="s1">res,</span><span class="s3">\n          </span><span class="s1">parsedUrl</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">if (finished) return</span><span class="s3">\n\n        </span><span class="s1">const err = new Error()</span><span class="s3">\n        </span><span class="s1">;(err as any).result = {</span><span class="s3">\n          </span><span class="s1">response: new Response(null, {</span><span class="s3">\n            </span><span class="s1">headers: {</span><span class="s3">\n              </span><span class="s1">'x-middleware-next': '1',</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">;(err as any).bubble = true</span><span class="s3">\n        </span><span class="s1">throw err</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// This wasn't a request via the matched path or the invoke path, so</span><span class="s3">\n      </span><span class="s1">// prepare for a legacy run by removing the base path.</span><span class="s3">\n\n      </span><span class="s1">// ensure we strip the basePath when not using an invoke header</span><span class="s3">\n      </span><span class="s1">if (!useMatchedPathHeader &amp;&amp; pathnameInfo.basePath) {</span><span class="s3">\n        </span><span class="s1">parsedUrl.pathname = removePathPrefix(</span><span class="s3">\n          </span><span class="s1">parsedUrl.pathname,</span><span class="s3">\n          </span><span class="s1">pathnameInfo.basePath</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">res.statusCode = 200</span><span class="s3">\n      </span><span class="s1">return await this.run(req, res, parsedUrl)</span><span class="s3">\n    </span><span class="s1">} catch (err: any) {</span><span class="s3">\n      </span><span class="s1">if (err instanceof NoFallbackError) {</span><span class="s3">\n        </span><span class="s1">throw err</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">(err &amp;&amp; typeof err === 'object' &amp;&amp; err.code === 'ERR_INVALID_URL') ||</span><span class="s3">\n        </span><span class="s1">err instanceof DecodeError ||</span><span class="s3">\n        </span><span class="s1">err instanceof NormalizeError</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">res.statusCode = 400</span><span class="s3">\n        </span><span class="s1">return this.renderError(null, req, res, '/_error', {})</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">this.minimalMode ||</span><span class="s3">\n        </span><span class="s1">this.renderOpts.dev ||</span><span class="s3">\n        </span><span class="s1">(isBubbledError(err) &amp;&amp; err.bubble)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">throw err</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.logError(getProperError(err))</span><span class="s3">\n      </span><span class="s1">res.statusCode = 500</span><span class="s3">\n      </span><span class="s1">res.body('Internal Server Error').send()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Normalizes a pathname without attaching any metadata from any matched</span><span class="s3">\n   </span><span class="s1">* normalizer.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param pathname the pathname to normalize</span><span class="s3">\n   </span><span class="s1">* @returns the normalized pathname</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private normalize = (pathname: string) =&gt; {</span><span class="s3">\n    </span><span class="s1">const normalizers: Array&lt;PathnameNormalizer&gt; = []</span><span class="s3">\n\n    </span><span class="s1">if (this.normalizers.data) {</span><span class="s3">\n      </span><span class="s1">normalizers.push(this.normalizers.data)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// We have to put the segment prefetch normalizer before the RSC normalizer</span><span class="s3">\n    </span><span class="s1">// because the RSC normalizer will match the prefetch RSC routes too.</span><span class="s3">\n    </span><span class="s1">if (this.normalizers.segmentPrefetchRSC) {</span><span class="s3">\n      </span><span class="s1">normalizers.push(this.normalizers.segmentPrefetchRSC)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// We have to put the prefetch normalizer before the RSC normalizer</span><span class="s3">\n    </span><span class="s1">// because the RSC normalizer will match the prefetch RSC routes too.</span><span class="s3">\n    </span><span class="s1">if (this.normalizers.prefetchRSC) {</span><span class="s3">\n      </span><span class="s1">normalizers.push(this.normalizers.prefetchRSC)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.normalizers.rsc) {</span><span class="s3">\n      </span><span class="s1">normalizers.push(this.normalizers.rsc)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const normalizer of normalizers) {</span><span class="s3">\n      </span><span class="s1">if (!normalizer.match(pathname)) continue</span><span class="s3">\n\n      </span><span class="s1">return normalizer.normalize(pathname, true)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return pathname</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private normalizeAndAttachMetadata: RouteHandler&lt;</span><span class="s3">\n    </span><span class="s1">ServerRequest,</span><span class="s3">\n    </span><span class="s1">ServerResponse</span><span class="s3">\n  </span><span class="s1">&gt; = async (req, res, url) =&gt; {</span><span class="s3">\n    </span><span class="s1">let finished = await this.handleNextImageRequest(req, res, url)</span><span class="s3">\n    </span><span class="s1">if (finished) return true</span><span class="s3">\n\n    </span><span class="s1">if (this.enabledDirectories.pages) {</span><span class="s3">\n      </span><span class="s1">finished = await this.handleNextDataRequest(req, res, url)</span><span class="s3">\n      </span><span class="s1">if (finished) return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @internal - this method is internal to Next.js and should not be used directly by end-users</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public getRequestHandlerWithMetadata(</span><span class="s3">\n    </span><span class="s1">meta: RequestMeta</span><span class="s3">\n  </span><span class="s1">): BaseRequestHandler&lt;ServerRequest, ServerResponse&gt; {</span><span class="s3">\n    </span><span class="s1">const handler = this.getRequestHandler()</span><span class="s3">\n    </span><span class="s1">return (req, res, parsedUrl) =&gt; {</span><span class="s3">\n      </span><span class="s1">setRequestMeta(req, meta)</span><span class="s3">\n      </span><span class="s1">return handler(req, res, parsedUrl)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public getRequestHandler(): BaseRequestHandler&lt;</span><span class="s3">\n    </span><span class="s1">ServerRequest,</span><span class="s3">\n    </span><span class="s1">ServerResponse</span><span class="s3">\n  </span><span class="s1">&gt; {</span><span class="s3">\n    </span><span class="s1">return this.handleRequest.bind(this)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected abstract handleUpgrade(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">socket: any,</span><span class="s3">\n    </span><span class="s1">head?: any</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt;</span><span class="s3">\n\n  </span><span class="s1">public setAssetPrefix(prefix?: string): void {</span><span class="s3">\n    </span><span class="s1">this.nextConfig.assetPrefix = prefix ? prefix.replace(/</span><span class="s3">\\</span><span class="s1">/$/, '') : ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected prepared: boolean = false</span><span class="s3">\n  </span><span class="s1">protected preparedPromise: Promise&lt;void&gt; | null = null</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Runs async initialization of server.</span><span class="s3">\n   </span><span class="s1">* It is idempotent, won't fire underlying initialization more than once.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public async prepare(): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">if (this.prepared) return</span><span class="s3">\n\n    </span><span class="s1">// Get instrumentation module</span><span class="s3">\n    </span><span class="s1">if (!this.instrumentation) {</span><span class="s3">\n      </span><span class="s1">this.instrumentation = await this.loadInstrumentationModule()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.preparedPromise === null) {</span><span class="s3">\n      </span><span class="s1">this.preparedPromise = this.prepareImpl().then(() =&gt; {</span><span class="s3">\n        </span><span class="s1">this.prepared = true</span><span class="s3">\n        </span><span class="s1">this.preparedPromise = null</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.preparedPromise</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">protected async prepareImpl(): Promise&lt;void&gt; {}</span><span class="s3">\n  </span><span class="s1">protected async loadInstrumentationModule(): Promise&lt;any&gt; {}</span><span class="s3">\n\n  </span><span class="s1">public async close(): Promise&lt;void&gt; {}</span><span class="s3">\n\n  </span><span class="s1">protected getAppPathRoutes(): Record&lt;string, string[]&gt; {</span><span class="s3">\n    </span><span class="s1">const appPathRoutes: Record&lt;string, string[]&gt; = {}</span><span class="s3">\n\n    </span><span class="s1">Object.keys(this.appPathsManifest || {}).forEach((entry) =&gt; {</span><span class="s3">\n      </span><span class="s1">const normalizedPath = normalizeAppPath(entry)</span><span class="s3">\n      </span><span class="s1">if (!appPathRoutes[normalizedPath]) {</span><span class="s3">\n        </span><span class="s1">appPathRoutes[normalizedPath] = []</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">appPathRoutes[normalizedPath].push(entry)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">return appPathRoutes</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async run(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">parsedUrl: UrlWithParsedQuery</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">return getTracer().trace(BaseServerSpan.run, async () =&gt;</span><span class="s3">\n      </span><span class="s1">this.runImpl(req, res, parsedUrl)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async runImpl(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">parsedUrl: UrlWithParsedQuery</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">await this.handleCatchallRenderRequest(req, res, parsedUrl)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async pipe(</span><span class="s3">\n    </span><span class="s1">fn: (</span><span class="s3">\n      </span><span class="s1">ctx: RequestContext&lt;ServerRequest, ServerResponse&gt;</span><span class="s3">\n    </span><span class="s1">) =&gt; Promise&lt;ResponsePayload | null&gt;,</span><span class="s3">\n    </span><span class="s1">partialContext: Omit&lt;</span><span class="s3">\n      </span><span class="s1">RequestContext&lt;ServerRequest, ServerResponse&gt;,</span><span class="s3">\n      </span><span class="s1">'renderOpts'</span><span class="s3">\n    </span><span class="s1">&gt;</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">return getTracer().trace(BaseServerSpan.pipe, async () =&gt;</span><span class="s3">\n      </span><span class="s1">this.pipeImpl(fn, partialContext)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async pipeImpl(</span><span class="s3">\n    </span><span class="s1">fn: (</span><span class="s3">\n      </span><span class="s1">ctx: RequestContext&lt;ServerRequest, ServerResponse&gt;</span><span class="s3">\n    </span><span class="s1">) =&gt; Promise&lt;ResponsePayload | null&gt;,</span><span class="s3">\n    </span><span class="s1">partialContext: Omit&lt;</span><span class="s3">\n      </span><span class="s1">RequestContext&lt;ServerRequest, ServerResponse&gt;,</span><span class="s3">\n      </span><span class="s1">'renderOpts'</span><span class="s3">\n    </span><span class="s1">&gt;</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">const ua = partialContext.req.headers['user-agent'] || ''</span><span class="s3">\n\n    </span><span class="s1">const ctx: RequestContext&lt;ServerRequest, ServerResponse&gt; = {</span><span class="s3">\n      </span><span class="s1">...partialContext,</span><span class="s3">\n      </span><span class="s1">renderOpts: {</span><span class="s3">\n        </span><span class="s1">...this.renderOpts,</span><span class="s3">\n        </span><span class="s1">// `renderOpts.botType` is accumulated in `this.renderImpl()`</span><span class="s3">\n        </span><span class="s1">supportsDynamicResponse: !this.renderOpts.botType,</span><span class="s3">\n        </span><span class="s1">serveStreamingMetadata: shouldServeStreamingMetadata(</span><span class="s3">\n          </span><span class="s1">ua,</span><span class="s3">\n          </span><span class="s1">this.nextConfig.htmlLimitedBots</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const payload = await fn(ctx)</span><span class="s3">\n    </span><span class="s1">if (payload === null) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const { req, res } = ctx</span><span class="s3">\n    </span><span class="s1">const originalStatus = res.statusCode</span><span class="s3">\n    </span><span class="s1">const { body } = payload</span><span class="s3">\n    </span><span class="s1">let { cacheControl } = payload</span><span class="s3">\n    </span><span class="s1">if (!res.sent) {</span><span class="s3">\n      </span><span class="s1">const { generateEtags, poweredByHeader, dev } = this.renderOpts</span><span class="s3">\n\n      </span><span class="s1">// In dev, we should not cache pages for any reason.</span><span class="s3">\n      </span><span class="s1">if (dev) {</span><span class="s3">\n        </span><span class="s1">res.setHeader('Cache-Control', 'no-store, must-revalidate')</span><span class="s3">\n        </span><span class="s1">cacheControl = undefined</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (cacheControl &amp;&amp; cacheControl.expire === undefined) {</span><span class="s3">\n        </span><span class="s1">cacheControl.expire = this.nextConfig.expireTime</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">await this.sendRenderResult(req, res, {</span><span class="s3">\n        </span><span class="s1">result: body,</span><span class="s3">\n        </span><span class="s1">generateEtags,</span><span class="s3">\n        </span><span class="s1">poweredByHeader,</span><span class="s3">\n        </span><span class="s1">cacheControl,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">res.statusCode = originalStatus</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async getStaticHTML(</span><span class="s3">\n    </span><span class="s1">fn: (</span><span class="s3">\n      </span><span class="s1">ctx: RequestContext&lt;ServerRequest, ServerResponse&gt;</span><span class="s3">\n    </span><span class="s1">) =&gt; Promise&lt;ResponsePayload | null&gt;,</span><span class="s3">\n    </span><span class="s1">partialContext: Omit&lt;</span><span class="s3">\n      </span><span class="s1">RequestContext&lt;ServerRequest, ServerResponse&gt;,</span><span class="s3">\n      </span><span class="s1">'renderOpts'</span><span class="s3">\n    </span><span class="s1">&gt;</span><span class="s3">\n  </span><span class="s1">): Promise&lt;string | null&gt; {</span><span class="s3">\n    </span><span class="s1">const ctx: RequestContext&lt;ServerRequest, ServerResponse&gt; = {</span><span class="s3">\n      </span><span class="s1">...partialContext,</span><span class="s3">\n      </span><span class="s1">renderOpts: {</span><span class="s3">\n        </span><span class="s1">...this.renderOpts,</span><span class="s3">\n        </span><span class="s1">supportsDynamicResponse: false,</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const payload = await fn(ctx)</span><span class="s3">\n    </span><span class="s1">if (payload === null) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return payload.body.toUnchunkedString()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async render(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">query: NextParsedUrlQuery = {},</span><span class="s3">\n    </span><span class="s1">parsedUrl?: NextUrlWithParsedQuery,</span><span class="s3">\n    </span><span class="s1">internalRender = false</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">return getTracer().trace(BaseServerSpan.render, async () =&gt;</span><span class="s3">\n      </span><span class="s1">this.renderImpl(req, res, pathname, query, parsedUrl, internalRender)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected getWaitUntil(): WaitUntil | undefined {</span><span class="s3">\n    </span><span class="s1">const builtinRequestContext = getBuiltinRequestContext()</span><span class="s3">\n    </span><span class="s1">if (builtinRequestContext) {</span><span class="s3">\n      </span><span class="s1">// the platform provided a request context.</span><span class="s3">\n      </span><span class="s1">// use the `waitUntil` from there, whether actually present or not --</span><span class="s3">\n      </span><span class="s1">// if not present, `after` will error.</span><span class="s3">\n\n      </span><span class="s1">// NOTE: if we're in an edge runtime sandbox, this context will be used to forward the outer waitUntil.</span><span class="s3">\n      </span><span class="s1">return builtinRequestContext.waitUntil</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.minimalMode) {</span><span class="s3">\n      </span><span class="s1">// we're built for a serverless environment, and `waitUntil` is not available,</span><span class="s3">\n      </span><span class="s1">// but using a noop would likely lead to incorrect behavior,</span><span class="s3">\n      </span><span class="s1">// because we have no way of keeping the invocation alive.</span><span class="s3">\n      </span><span class="s1">// return nothing, and `after` will error if used.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// NOTE: for edge functions, `NextWebServer` always runs in minimal mode.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// NOTE: if we're in an edge runtime sandbox, waitUntil will be passed in using </span><span class="s3">\&quot;</span><span class="s1">@next/request-context</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">// so we won't get here.</span><span class="s3">\n      </span><span class="s1">return undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.getInternalWaitUntil()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected getInternalWaitUntil(): WaitUntil | undefined {</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async renderImpl(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">query: NextParsedUrlQuery = {},</span><span class="s3">\n    </span><span class="s1">parsedUrl?: NextUrlWithParsedQuery,</span><span class="s3">\n    </span><span class="s1">internalRender = false</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">if (!pathname.startsWith('/')) {</span><span class="s3">\n      </span><span class="s1">console.warn(</span><span class="s3">\n        </span><span class="s1">`Cannot render page with path </span><span class="s3">\&quot;</span><span class="s1">${pathname}</span><span class="s3">\&quot;</span><span class="s1">, did you mean </span><span class="s3">\&quot;</span><span class="s1">/${pathname}</span><span class="s3">\&quot;</span><span class="s1">?. See more info here: https://nextjs.org/docs/messages/render-no-starting-slash`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">this.serverOptions.customServer &amp;&amp;</span><span class="s3">\n      </span><span class="s1">pathname === '/index' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!(await this.hasPage('/index'))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// maintain backwards compatibility for custom server</span><span class="s3">\n      </span><span class="s1">// (see custom-server integration tests)</span><span class="s3">\n      </span><span class="s1">pathname = '/'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const ua = req.headers['user-agent'] || ''</span><span class="s3">\n    </span><span class="s1">this.renderOpts.botType = getBotType(ua)</span><span class="s3">\n\n    </span><span class="s1">// we allow custom servers to call render for all URLs</span><span class="s3">\n    </span><span class="s1">// so check if we need to serve a static _next file or not.</span><span class="s3">\n    </span><span class="s1">// we don't modify the URL for _next/data request but still</span><span class="s3">\n    </span><span class="s1">// call render so we special case this to prevent an infinite loop</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!internalRender &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!this.minimalMode &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!getRequestMeta(req, 'isNextDataReq') &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(req.url?.match(/^</span><span class="s3">\\</span><span class="s1">/_next</span><span class="s3">\\</span><span class="s1">//) ||</span><span class="s3">\n        </span><span class="s1">(this.hasStaticDir &amp;&amp; req.url!.match(/^</span><span class="s3">\\</span><span class="s1">/static</span><span class="s3">\\</span><span class="s1">//)))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return this.handleRequest(req, res, parsedUrl)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isBlockedPage(pathname)) {</span><span class="s3">\n      </span><span class="s1">return this.render404(req, res, parsedUrl)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.pipe((ctx) =&gt; this.renderToResponse(ctx), {</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">res,</span><span class="s3">\n      </span><span class="s1">pathname,</span><span class="s3">\n      </span><span class="s1">query,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async getStaticPaths({</span><span class="s3">\n    </span><span class="s1">pathname,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">pathname: string</span><span class="s3">\n    </span><span class="s1">urlPathname: string</span><span class="s3">\n    </span><span class="s1">requestHeaders: import('./lib/incremental-cache').IncrementalCache['requestHeaders']</span><span class="s3">\n    </span><span class="s1">page: string</span><span class="s3">\n    </span><span class="s1">isAppPath: boolean</span><span class="s3">\n  </span><span class="s1">}): Promise&lt;{</span><span class="s3">\n    </span><span class="s1">staticPaths?: string[]</span><span class="s3">\n    </span><span class="s1">prerenderedRoutes?: PrerenderedRoute[]</span><span class="s3">\n    </span><span class="s1">fallbackMode?: FallbackMode</span><span class="s3">\n  </span><span class="s1">}&gt; {</span><span class="s3">\n    </span><span class="s1">// Read whether or not fallback should exist from the manifest.</span><span class="s3">\n    </span><span class="s1">const fallbackField =</span><span class="s3">\n      </span><span class="s1">this.getPrerenderManifest().dynamicRoutes[pathname]?.fallback</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">// `staticPaths` is intentionally set to `undefined` as it should've</span><span class="s3">\n      </span><span class="s1">// been caught when checking disk data.</span><span class="s3">\n      </span><span class="s1">staticPaths: undefined,</span><span class="s3">\n      </span><span class="s1">fallbackMode: parseFallbackField(fallbackField),</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async renderToResponseWithComponents(</span><span class="s3">\n    </span><span class="s1">requestContext: RequestContext&lt;ServerRequest, ServerResponse&gt;,</span><span class="s3">\n    </span><span class="s1">findComponentsResult: FindComponentsResult</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ResponsePayload | null&gt; {</span><span class="s3">\n    </span><span class="s1">return getTracer().trace(</span><span class="s3">\n      </span><span class="s1">BaseServerSpan.renderToResponseWithComponents,</span><span class="s3">\n      </span><span class="s1">async () =&gt;</span><span class="s3">\n        </span><span class="s1">this.renderToResponseWithComponentsImpl(</span><span class="s3">\n          </span><span class="s1">requestContext,</span><span class="s3">\n          </span><span class="s1">findComponentsResult</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected pathCouldBeIntercepted(resolvedPathname: string): boolean {</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">isInterceptionRouteAppPath(resolvedPathname) ||</span><span class="s3">\n      </span><span class="s1">this.interceptionRoutePatterns.some((regexp) =&gt; {</span><span class="s3">\n        </span><span class="s1">return regexp.test(resolvedPathname)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected setVaryHeader(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">isAppPath: boolean,</span><span class="s3">\n    </span><span class="s1">resolvedPathname: string</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">const baseVaryHeader = `${RSC_HEADER}, ${NEXT_ROUTER_STATE_TREE_HEADER}, ${NEXT_ROUTER_PREFETCH_HEADER}, ${NEXT_ROUTER_SEGMENT_PREFETCH_HEADER}`</span><span class="s3">\n    </span><span class="s1">const isRSCRequest = getRequestMeta(req, 'isRSCRequest') ?? false</span><span class="s3">\n\n    </span><span class="s1">let addedNextUrlToVary = false</span><span class="s3">\n\n    </span><span class="s1">if (isAppPath &amp;&amp; this.pathCouldBeIntercepted(resolvedPathname)) {</span><span class="s3">\n      </span><span class="s1">// Interception route responses can vary based on the `Next-URL` header.</span><span class="s3">\n      </span><span class="s1">// We use the Vary header to signal this behavior to the client to properly cache the response.</span><span class="s3">\n      </span><span class="s1">res.appendHeader('vary', `${baseVaryHeader}, ${NEXT_URL}`)</span><span class="s3">\n      </span><span class="s1">addedNextUrlToVary = true</span><span class="s3">\n    </span><span class="s1">} else if (isAppPath || isRSCRequest) {</span><span class="s3">\n      </span><span class="s1">// We don't need to include `Next-URL` in the Vary header for non-interception routes since it won't affect the response.</span><span class="s3">\n      </span><span class="s1">// We also set this header for pages to avoid caching issues when navigating between pages and app.</span><span class="s3">\n      </span><span class="s1">res.appendHeader('vary', baseVaryHeader)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!addedNextUrlToVary) {</span><span class="s3">\n      </span><span class="s1">// Remove `Next-URL` from the request headers we determined it wasn't necessary to include in the Vary header.</span><span class="s3">\n      </span><span class="s1">// This is to avoid any dependency on the `Next-URL` header being present when preparing the response.</span><span class="s3">\n      </span><span class="s1">delete req.headers[NEXT_URL]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async renderToResponseWithComponentsImpl(</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">res,</span><span class="s3">\n      </span><span class="s1">pathname,</span><span class="s3">\n      </span><span class="s1">renderOpts: opts,</span><span class="s3">\n    </span><span class="s1">}: RequestContext&lt;ServerRequest, ServerResponse&gt;,</span><span class="s3">\n    </span><span class="s1">{ components, query }: FindComponentsResult</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ResponsePayload | null&gt; {</span><span class="s3">\n    </span><span class="s1">if (pathname === UNDERSCORE_NOT_FOUND_ROUTE) {</span><span class="s3">\n      </span><span class="s1">pathname = '/404'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const isErrorPathname = pathname === '/_error'</span><span class="s3">\n    </span><span class="s1">const is404Page =</span><span class="s3">\n      </span><span class="s1">pathname === '/404' || (isErrorPathname &amp;&amp; res.statusCode === 404)</span><span class="s3">\n    </span><span class="s1">const is500Page =</span><span class="s3">\n      </span><span class="s1">pathname === '/500' || (isErrorPathname &amp;&amp; res.statusCode === 500)</span><span class="s3">\n    </span><span class="s1">const isAppPath = components.isAppPath === true</span><span class="s3">\n\n    </span><span class="s1">const hasServerProps = !!components.getServerSideProps</span><span class="s3">\n    </span><span class="s1">const isPossibleServerAction = getIsPossibleServerAction(req)</span><span class="s3">\n    </span><span class="s1">let isSSG = !!components.getStaticProps</span><span class="s3">\n    </span><span class="s1">// NOTE: Don't delete headers[RSC] yet, it still needs to be used in renderToHTML later</span><span class="s3">\n    </span><span class="s1">const isRSCRequest = getRequestMeta(req, 'isRSCRequest') ?? false</span><span class="s3">\n\n    </span><span class="s1">// Not all CDNs respect the Vary header when caching. We must assume that</span><span class="s3">\n    </span><span class="s1">// only the URL is used to vary the responses. The Next client computes a</span><span class="s3">\n    </span><span class="s1">// hash of the header values and sends it as a search param. Before</span><span class="s3">\n    </span><span class="s1">// responding to a request, we must verify that the hash matches the</span><span class="s3">\n    </span><span class="s1">// expected value. Neglecting to do this properly can lead to cache</span><span class="s3">\n    </span><span class="s1">// poisoning attacks on certain CDNs.</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!this.minimalMode &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.nextConfig.experimental.validateRSCRequestHeaders &amp;&amp;</span><span class="s3">\n      </span><span class="s1">isRSCRequest</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const headers = req.headers</span><span class="s3">\n\n      </span><span class="s1">const prefetchHeaderValue = headers[NEXT_ROUTER_PREFETCH_HEADER]</span><span class="s3">\n      </span><span class="s1">const routerPrefetch =</span><span class="s3">\n        </span><span class="s1">prefetchHeaderValue !== undefined</span><span class="s3">\n          </span><span class="s1">? // We only recognize '1' and '2'. Strip all other values here.</span><span class="s3">\n            </span><span class="s1">prefetchHeaderValue === '1' || prefetchHeaderValue === '2'</span><span class="s3">\n            </span><span class="s1">? prefetchHeaderValue</span><span class="s3">\n            </span><span class="s1">: undefined</span><span class="s3">\n          </span><span class="s1">: // For runtime prefetches, we always perform a dynamic request,</span><span class="s3">\n            </span><span class="s1">// so we don't expect the header to be stripped by an intermediate layer.</span><span class="s3">\n            </span><span class="s1">// This should only happen for static prefetches, so we only handle those here.</span><span class="s3">\n            </span><span class="s1">getRequestMeta(req, 'isPrefetchRSCRequest')</span><span class="s3">\n            </span><span class="s1">? '1'</span><span class="s3">\n            </span><span class="s1">: undefined</span><span class="s3">\n\n      </span><span class="s1">const segmentPrefetchRSCRequest =</span><span class="s3">\n        </span><span class="s1">headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] ||</span><span class="s3">\n        </span><span class="s1">getRequestMeta(req, 'segmentPrefetchRSCRequest')</span><span class="s3">\n\n      </span><span class="s1">const expectedHash = computeCacheBustingSearchParam(</span><span class="s3">\n        </span><span class="s1">routerPrefetch,</span><span class="s3">\n        </span><span class="s1">segmentPrefetchRSCRequest,</span><span class="s3">\n        </span><span class="s1">headers[NEXT_ROUTER_STATE_TREE_HEADER],</span><span class="s3">\n        </span><span class="s1">headers[NEXT_URL]</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">const actualHash =</span><span class="s3">\n        </span><span class="s1">getRequestMeta(req, 'cacheBustingSearchParam') ??</span><span class="s3">\n        </span><span class="s1">new URL(req.url || '', 'http://localhost').searchParams.get(</span><span class="s3">\n          </span><span class="s1">NEXT_RSC_UNION_QUERY</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">if (expectedHash !== actualHash) {</span><span class="s3">\n        </span><span class="s1">// The hash sent by the client does not match the expected value.</span><span class="s3">\n        </span><span class="s1">// Redirect to the URL with the correct cache-busting search param.</span><span class="s3">\n        </span><span class="s1">// This prevents cache poisoning attacks on CDNs that don't respect Vary headers.</span><span class="s3">\n        </span><span class="s1">// Note: When no headers are present, expectedHash is empty string and client</span><span class="s3">\n        </span><span class="s1">// must send `_rsc` param, otherwise actualHash is null and hash check fails.</span><span class="s3">\n        </span><span class="s1">const url = new URL(req.url || '', 'http://localhost')</span><span class="s3">\n        </span><span class="s1">setCacheBustingSearchParamWithHash(url, expectedHash)</span><span class="s3">\n        </span><span class="s1">res.statusCode = 307</span><span class="s3">\n        </span><span class="s1">res.setHeader('location', `${url.pathname}${url.search}`)</span><span class="s3">\n        </span><span class="s1">res.body('').send()</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Compute the iSSG cache key. We use the rewroteUrl since</span><span class="s3">\n    </span><span class="s1">// pages with fallback: false are allowed to be rewritten to</span><span class="s3">\n    </span><span class="s1">// and we need to look up the path by the rewritten path</span><span class="s3">\n    </span><span class="s1">let urlPathname = parseUrl(req.url || '').pathname || '/'</span><span class="s3">\n\n    </span><span class="s1">let resolvedUrlPathname = getRequestMeta(req, 'rewroteURL') || urlPathname</span><span class="s3">\n\n    </span><span class="s1">this.setVaryHeader(req, res, isAppPath, resolvedUrlPathname)</span><span class="s3">\n\n    </span><span class="s1">let staticPaths: string[] | undefined</span><span class="s3">\n    </span><span class="s1">let hasFallback = false</span><span class="s3">\n\n    </span><span class="s1">const prerenderManifest = this.getPrerenderManifest()</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">hasFallback ||</span><span class="s3">\n      </span><span class="s1">staticPaths?.includes(resolvedUrlPathname) ||</span><span class="s3">\n      </span><span class="s1">// this signals revalidation in deploy environments</span><span class="s3">\n      </span><span class="s1">// TODO: make this more generic</span><span class="s3">\n      </span><span class="s1">req.headers['x-now-route-matches']</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">isSSG = true</span><span class="s3">\n    </span><span class="s1">} else if (!this.renderOpts.dev) {</span><span class="s3">\n      </span><span class="s1">isSSG ||= !!prerenderManifest.routes[toRoute(pathname)]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Toggle whether or not this is a Data request</span><span class="s3">\n    </span><span class="s1">const isNextDataRequest =</span><span class="s3">\n      </span><span class="s1">!!(</span><span class="s3">\n        </span><span class="s1">getRequestMeta(req, 'isNextDataReq') ||</span><span class="s3">\n        </span><span class="s1">(req.headers['x-nextjs-data'] &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(this.serverOptions as any).webServerConfig)</span><span class="s3">\n      </span><span class="s1">) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(isSSG || hasServerProps)</span><span class="s3">\n\n    </span><span class="s1">// when we are handling a middleware prefetch and it doesn't</span><span class="s3">\n    </span><span class="s1">// resolve to a static data route we bail early to avoid</span><span class="s3">\n    </span><span class="s1">// unexpected SSR invocations</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!isSSG &amp;&amp;</span><span class="s3">\n      </span><span class="s1">req.headers['x-middleware-prefetch'] &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!(is404Page || pathname === '/_error')</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">res.setHeader(MATCHED_PATH_HEADER, pathname)</span><span class="s3">\n      </span><span class="s1">res.setHeader('x-middleware-skip', '1')</span><span class="s3">\n      </span><span class="s1">res.setHeader(</span><span class="s3">\n        </span><span class="s1">'cache-control',</span><span class="s3">\n        </span><span class="s1">'private, no-cache, no-store, max-age=0, must-revalidate'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">res.body('{}').send()</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// normalize req.url for SSG paths as it is not exposed</span><span class="s3">\n    </span><span class="s1">// to getStaticProps and the asPath should not expose /_next/data</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">isSSG &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.minimalMode &amp;&amp;</span><span class="s3">\n      </span><span class="s1">req.headers[MATCHED_PATH_HEADER] &amp;&amp;</span><span class="s3">\n      </span><span class="s1">req.url.startsWith('/_next/data')</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">req.url = this.stripNextDataPath(req.url)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const locale = getRequestMeta(req, 'locale')</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!!req.headers['x-nextjs-data'] &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(!res.statusCode || res.statusCode === 200)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">res.setHeader(</span><span class="s3">\n        </span><span class="s1">'x-nextjs-matched-path',</span><span class="s3">\n        </span><span class="s1">`${locale ? `/${locale}` : ''}${pathname}`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let routeModule: RouteModule | undefined</span><span class="s3">\n    </span><span class="s1">if (components.routeModule) {</span><span class="s3">\n      </span><span class="s1">routeModule = components.routeModule</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If the route being rendered is an app page, and the ppr feature has been</span><span class="s3">\n     </span><span class="s1">* enabled, then the given route _could_ support PPR.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const couldSupportPPR: boolean =</span><span class="s3">\n      </span><span class="s1">this.isAppPPREnabled &amp;&amp;</span><span class="s3">\n      </span><span class="s1">typeof routeModule !== 'undefined' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">isAppPageRouteModule(routeModule)</span><span class="s3">\n\n    </span><span class="s1">// When enabled, this will allow the use of the `?__nextppronly` query to</span><span class="s3">\n    </span><span class="s1">// enable debugging of the static shell.</span><span class="s3">\n    </span><span class="s1">const hasDebugStaticShellQuery =</span><span class="s3">\n      </span><span class="s1">process.env.__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING === '1' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">typeof query.__nextppronly !== 'undefined' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">couldSupportPPR</span><span class="s3">\n\n    </span><span class="s1">// This page supports PPR if it is marked as being `PARTIALLY_STATIC` in the</span><span class="s3">\n    </span><span class="s1">// prerender manifest and this is an app page.</span><span class="s3">\n    </span><span class="s1">const isRoutePPREnabled: boolean =</span><span class="s3">\n      </span><span class="s1">couldSupportPPR &amp;&amp;</span><span class="s3">\n      </span><span class="s1">((</span><span class="s3">\n        </span><span class="s1">prerenderManifest.routes[pathname] ??</span><span class="s3">\n        </span><span class="s1">prerenderManifest.dynamicRoutes[pathname]</span><span class="s3">\n      </span><span class="s1">)?.renderingMode === 'PARTIALLY_STATIC' ||</span><span class="s3">\n        </span><span class="s1">// Ideally we'd want to check the appConfig to see if this page has PPR</span><span class="s3">\n        </span><span class="s1">// enabled or not, but that would require plumbing the appConfig through</span><span class="s3">\n        </span><span class="s1">// to the server during development. We assume that the page supports it</span><span class="s3">\n        </span><span class="s1">// but only during development.</span><span class="s3">\n        </span><span class="s1">(hasDebugStaticShellQuery &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(this.renderOpts.dev === true ||</span><span class="s3">\n            </span><span class="s1">this.experimentalTestProxy === true)))</span><span class="s3">\n\n    </span><span class="s1">// If we're in minimal mode, then try to get the postponed information from</span><span class="s3">\n    </span><span class="s1">// the request metadata. If available, use it for resuming the postponed</span><span class="s3">\n    </span><span class="s1">// render.</span><span class="s3">\n    </span><span class="s1">const minimalPostponed = isRoutePPREnabled</span><span class="s3">\n      </span><span class="s1">? getRequestMeta(req, 'postponed')</span><span class="s3">\n      </span><span class="s1">: undefined</span><span class="s3">\n\n    </span><span class="s1">// we need to ensure the status code if /404 is visited directly</span><span class="s3">\n    </span><span class="s1">if (is404Page &amp;&amp; !isNextDataRequest &amp;&amp; !isRSCRequest) {</span><span class="s3">\n      </span><span class="s1">res.statusCode = 404</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// ensure correct status is set when visiting a status page</span><span class="s3">\n    </span><span class="s1">// directly e.g. /500</span><span class="s3">\n    </span><span class="s1">if (STATIC_STATUS_PAGES.includes(pathname)) {</span><span class="s3">\n      </span><span class="s1">res.statusCode = parseInt(pathname.slice(1), 10)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">// Server actions can use non-GET/HEAD methods.</span><span class="s3">\n      </span><span class="s1">!isPossibleServerAction &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Resume can use non-GET/HEAD methods.</span><span class="s3">\n      </span><span class="s1">!minimalPostponed &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!is404Page &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!is500Page &amp;&amp;</span><span class="s3">\n      </span><span class="s1">pathname !== '/_error' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">req.method !== 'HEAD' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">req.method !== 'GET' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(typeof components.Component === 'string' || isSSG)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">res.statusCode = 405</span><span class="s3">\n      </span><span class="s1">res.setHeader('Allow', ['GET', 'HEAD'])</span><span class="s3">\n      </span><span class="s1">res.body('Method Not Allowed').send()</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// handle static page</span><span class="s3">\n    </span><span class="s1">if (typeof components.Component === 'string') {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">body: RenderResult.fromStatic(</span><span class="s3">\n          </span><span class="s1">components.Component,</span><span class="s3">\n          </span><span class="s1">HTML_CONTENT_TYPE_HEADER</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Ensure that if the `amp` query parameter is falsy that we remove it from</span><span class="s3">\n    </span><span class="s1">// the query object. This ensures it won't be found by the `in` operator.</span><span class="s3">\n    </span><span class="s1">if ('amp' in query &amp;&amp; !query.amp) delete query.amp</span><span class="s3">\n\n    </span><span class="s1">if (opts.supportsDynamicResponse === true) {</span><span class="s3">\n      </span><span class="s1">const ua = req.headers['user-agent'] || ''</span><span class="s3">\n      </span><span class="s1">const isBotRequest = isBot(ua)</span><span class="s3">\n      </span><span class="s1">const isSupportedDocument =</span><span class="s3">\n        </span><span class="s1">typeof components.Document?.getInitialProps !== 'function' ||</span><span class="s3">\n        </span><span class="s1">// The built-in `Document` component also supports dynamic HTML for concurrent mode.</span><span class="s3">\n        </span><span class="s1">NEXT_BUILTIN_DOCUMENT in components.Document</span><span class="s3">\n\n      </span><span class="s1">// Disable dynamic HTML in cases that we know it won't be generated,</span><span class="s3">\n      </span><span class="s1">// so that we can continue generating a cache key when possible.</span><span class="s3">\n      </span><span class="s1">// TODO-APP: should the first render for a dynamic app path</span><span class="s3">\n      </span><span class="s1">// be static so we can collect revalidate and populate the</span><span class="s3">\n      </span><span class="s1">// cache if there are no dynamic data requirements</span><span class="s3">\n      </span><span class="s1">opts.supportsDynamicResponse =</span><span class="s3">\n        </span><span class="s1">!isSSG &amp;&amp; !isBotRequest &amp;&amp; !query.amp &amp;&amp; isSupportedDocument</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// In development, we always want to generate dynamic HTML.</span><span class="s3">\n    </span><span class="s1">if (!isNextDataRequest &amp;&amp; isAppPath &amp;&amp; opts.dev) {</span><span class="s3">\n      </span><span class="s1">opts.supportsDynamicResponse = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isSSG &amp;&amp; this.minimalMode &amp;&amp; req.headers[MATCHED_PATH_HEADER]) {</span><span class="s3">\n      </span><span class="s1">// the url value is already correct when the matched-path header is set</span><span class="s3">\n      </span><span class="s1">resolvedUrlPathname = urlPathname</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">urlPathname = removeTrailingSlash(urlPathname)</span><span class="s3">\n    </span><span class="s1">resolvedUrlPathname = removeTrailingSlash(resolvedUrlPathname)</span><span class="s3">\n    </span><span class="s1">if (this.localeNormalizer) {</span><span class="s3">\n      </span><span class="s1">resolvedUrlPathname = this.localeNormalizer.normalize(resolvedUrlPathname)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// remove /_next/data prefix from urlPathname so it matches</span><span class="s3">\n    </span><span class="s1">// for direct page visit and /_next/data visit</span><span class="s3">\n    </span><span class="s1">if (isNextDataRequest) {</span><span class="s3">\n      </span><span class="s1">resolvedUrlPathname = this.stripNextDataPath(resolvedUrlPathname)</span><span class="s3">\n      </span><span class="s1">urlPathname = this.stripNextDataPath(urlPathname)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// use existing incrementalCache instance if available</span><span class="s3">\n    </span><span class="s1">const incrementalCache: import('./lib/incremental-cache').IncrementalCache =</span><span class="s3">\n      </span><span class="s1">await this.getIncrementalCache({</span><span class="s3">\n        </span><span class="s1">requestHeaders: Object.assign({}, req.headers),</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">// TODO: investigate, this is not safe across multiple concurrent requests</span><span class="s3">\n    </span><span class="s1">incrementalCache.resetRequestCache()</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">routeModule?.isDev &amp;&amp;</span><span class="s3">\n      </span><span class="s1">isDynamicRoute(pathname) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(components.getStaticPaths || isAppPath)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const pathsResults = await this.getStaticPaths({</span><span class="s3">\n        </span><span class="s1">pathname,</span><span class="s3">\n        </span><span class="s1">urlPathname,</span><span class="s3">\n        </span><span class="s1">requestHeaders: req.headers,</span><span class="s3">\n        </span><span class="s1">page: components.page,</span><span class="s3">\n        </span><span class="s1">isAppPath,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">if (isAppPath &amp;&amp; this.nextConfig.experimental.cacheComponents) {</span><span class="s3">\n        </span><span class="s1">if (pathsResults.prerenderedRoutes?.length) {</span><span class="s3">\n          </span><span class="s1">let smallestFallbackRouteParams = null</span><span class="s3">\n          </span><span class="s1">for (const route of pathsResults.prerenderedRoutes) {</span><span class="s3">\n            </span><span class="s1">const fallbackRouteParams = route.fallbackRouteParams</span><span class="s3">\n            </span><span class="s1">if (!fallbackRouteParams || fallbackRouteParams.length === 0) {</span><span class="s3">\n              </span><span class="s1">// There are no fallback route params so we don't need to continue</span><span class="s3">\n              </span><span class="s1">smallestFallbackRouteParams = null</span><span class="s3">\n              </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">smallestFallbackRouteParams === null ||</span><span class="s3">\n              </span><span class="s1">fallbackRouteParams.length &lt; smallestFallbackRouteParams.length</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">smallestFallbackRouteParams = fallbackRouteParams</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (smallestFallbackRouteParams) {</span><span class="s3">\n            </span><span class="s1">const devValidatingFallbackParams = new Map&lt;string, string&gt;(</span><span class="s3">\n              </span><span class="s1">smallestFallbackRouteParams.map((v) =&gt; [v, ''])</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">addRequestMeta(</span><span class="s3">\n              </span><span class="s1">req,</span><span class="s3">\n              </span><span class="s1">'devValidatingFallbackParams',</span><span class="s3">\n              </span><span class="s1">devValidatingFallbackParams</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// An OPTIONS request to a page handler is invalid.</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">req.method === 'OPTIONS' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!is404Page &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(!routeModule || !isAppRouteRouteModule(routeModule))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">await sendResponse(req, res, new Response(null, { status: 400 }))</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const request = isNodeNextRequest(req) ? req.originalRequest : req</span><span class="s3">\n    </span><span class="s1">const response = isNodeNextResponse(res) ? res.originalResponse : res</span><span class="s3">\n\n    </span><span class="s1">const parsedInitUrl = parseUrl(getRequestMeta(req, 'initURL') || req.url)</span><span class="s3">\n    </span><span class="s1">let initPathname = parsedInitUrl.pathname || '/'</span><span class="s3">\n\n    </span><span class="s1">for (const normalizer of [</span><span class="s3">\n      </span><span class="s1">this.normalizers.segmentPrefetchRSC,</span><span class="s3">\n      </span><span class="s1">this.normalizers.prefetchRSC,</span><span class="s3">\n      </span><span class="s1">this.normalizers.rsc,</span><span class="s3">\n    </span><span class="s1">]) {</span><span class="s3">\n      </span><span class="s1">if (normalizer?.match(initPathname)) {</span><span class="s3">\n        </span><span class="s1">initPathname = normalizer.normalize(initPathname)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// On minimal mode, the request url of dynamic route can be a</span><span class="s3">\n    </span><span class="s1">// literal dynamic route ('/[slug]') instead of actual URL, so overwriting to initPathname</span><span class="s3">\n    </span><span class="s1">// will transform back the resolved url to the dynamic route pathname.</span><span class="s3">\n    </span><span class="s1">if (!(this.minimalMode &amp;&amp; isErrorPathname)) {</span><span class="s3">\n      </span><span class="s1">request.url = `${initPathname}${parsedInitUrl.search || ''}`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// propagate the request context for dev</span><span class="s3">\n    </span><span class="s1">setRequestMeta(request, getRequestMeta(req))</span><span class="s3">\n    </span><span class="s1">addRequestMeta(request, 'distDir', this.distDir)</span><span class="s3">\n    </span><span class="s1">addRequestMeta(request, 'query', query)</span><span class="s3">\n    </span><span class="s1">addRequestMeta(request, 'params', opts.params)</span><span class="s3">\n    </span><span class="s1">addRequestMeta(request, 'ampValidator', this.renderOpts.ampValidator)</span><span class="s3">\n    </span><span class="s1">addRequestMeta(request, 'minimalMode', this.minimalMode)</span><span class="s3">\n\n    </span><span class="s1">if (opts.err) {</span><span class="s3">\n      </span><span class="s1">addRequestMeta(request, 'invokeError', opts.err)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const handler: (</span><span class="s3">\n      </span><span class="s1">req: ServerRequest | IncomingMessage,</span><span class="s3">\n      </span><span class="s1">res: ServerResponse | HTTPServerResponse,</span><span class="s3">\n      </span><span class="s1">ctx: {</span><span class="s3">\n        </span><span class="s1">waitUntil: ReturnType&lt;Server['getWaitUntil']&gt;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">) =&gt; Promise&lt;void&gt; = components.ComponentMod.handler</span><span class="s3">\n\n    </span><span class="s1">const maybeDevRequest =</span><span class="s3">\n      </span><span class="s1">// we need to capture fetch metrics when they are set</span><span class="s3">\n      </span><span class="s1">// and can't wait for handler to resolve as the fetch</span><span class="s3">\n      </span><span class="s1">// metrics are logged on response close which happens</span><span class="s3">\n      </span><span class="s1">// before handler resolves</span><span class="s3">\n      </span><span class="s1">process.env.NODE_ENV === 'development'</span><span class="s3">\n        </span><span class="s1">? new Proxy(request, {</span><span class="s3">\n            </span><span class="s1">get(target: any, prop) {</span><span class="s3">\n              </span><span class="s1">if (typeof target[prop] === 'function') {</span><span class="s3">\n                </span><span class="s1">return target[prop].bind(target)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">return target[prop]</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">set(target: any, prop, value) {</span><span class="s3">\n              </span><span class="s1">if (prop === 'fetchMetrics') {</span><span class="s3">\n                </span><span class="s1">;(req as any).fetchMetrics = value</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">target[prop] = value</span><span class="s3">\n              </span><span class="s1">return true</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">: request</span><span class="s3">\n\n    </span><span class="s1">await handler(maybeDevRequest, response, {</span><span class="s3">\n      </span><span class="s1">waitUntil: this.getWaitUntil(),</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">// response is handled fully in handler</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private stripNextDataPath(path: string, stripLocale = true) {</span><span class="s3">\n    </span><span class="s1">if (path.includes(this.buildId)) {</span><span class="s3">\n      </span><span class="s1">const splitPath = path.substring(</span><span class="s3">\n        </span><span class="s1">path.indexOf(this.buildId) + this.buildId.length</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">path = denormalizePagePath(splitPath.replace(/</span><span class="s3">\\</span><span class="s1">.json$/, ''))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.localeNormalizer &amp;&amp; stripLocale) {</span><span class="s3">\n      </span><span class="s1">return this.localeNormalizer.normalize(path)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return path</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// map the route to the actual bundle name</span><span class="s3">\n  </span><span class="s1">protected getOriginalAppPaths(route: string) {</span><span class="s3">\n    </span><span class="s1">if (this.enabledDirectories.app) {</span><span class="s3">\n      </span><span class="s1">const originalAppPath = this.appPathRoutes?.[route]</span><span class="s3">\n\n      </span><span class="s1">if (!originalAppPath) {</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return originalAppPath</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async renderPageComponent(</span><span class="s3">\n    </span><span class="s1">ctx: RequestContext&lt;ServerRequest, ServerResponse&gt;,</span><span class="s3">\n    </span><span class="s1">bubbleNoFallback: boolean</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const { query, pathname } = ctx</span><span class="s3">\n\n    </span><span class="s1">const appPaths = this.getOriginalAppPaths(pathname)</span><span class="s3">\n    </span><span class="s1">const isAppPath = Array.isArray(appPaths)</span><span class="s3">\n\n    </span><span class="s1">let page = pathname</span><span class="s3">\n    </span><span class="s1">if (isAppPath) {</span><span class="s3">\n      </span><span class="s1">// the last item in the array is the root page, if there are parallel routes</span><span class="s3">\n      </span><span class="s1">page = appPaths[appPaths.length - 1]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const result = await this.findPageComponents({</span><span class="s3">\n      </span><span class="s1">locale: getRequestMeta(ctx.req, 'locale'),</span><span class="s3">\n      </span><span class="s1">page,</span><span class="s3">\n      </span><span class="s1">query,</span><span class="s3">\n      </span><span class="s1">params: ctx.renderOpts.params || {},</span><span class="s3">\n      </span><span class="s1">isAppPath,</span><span class="s3">\n      </span><span class="s1">sriEnabled: !!this.nextConfig.experimental.sri?.algorithm,</span><span class="s3">\n      </span><span class="s1">appPaths,</span><span class="s3">\n      </span><span class="s1">// Ensuring for loading page component routes is done via the matcher.</span><span class="s3">\n      </span><span class="s1">shouldEnsure: false,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">if (result) {</span><span class="s3">\n      </span><span class="s1">getTracer().setRootSpanAttribute('next.route', pathname)</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">return await this.renderToResponseWithComponents(ctx, result)</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">const isNoFallbackError = err instanceof NoFallbackError</span><span class="s3">\n\n        </span><span class="s1">if (!isNoFallbackError || (isNoFallbackError &amp;&amp; bubbleNoFallback)) {</span><span class="s3">\n          </span><span class="s1">throw err</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async renderToResponse(</span><span class="s3">\n    </span><span class="s1">ctx: RequestContext&lt;ServerRequest, ServerResponse&gt;</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ResponsePayload | null&gt; {</span><span class="s3">\n    </span><span class="s1">return getTracer().trace(</span><span class="s3">\n      </span><span class="s1">BaseServerSpan.renderToResponse,</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">spanName: `rendering page`,</span><span class="s3">\n        </span><span class="s1">attributes: {</span><span class="s3">\n          </span><span class="s1">'next.route': ctx.pathname,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">async () =&gt; {</span><span class="s3">\n        </span><span class="s1">return this.renderToResponseImpl(ctx)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected abstract getMiddleware(): Promise&lt;MiddlewareRoutingItem | undefined&gt;</span><span class="s3">\n  </span><span class="s1">protected abstract getFallbackErrorComponents(</span><span class="s3">\n    </span><span class="s1">url?: string</span><span class="s3">\n  </span><span class="s1">): Promise&lt;LoadComponentsReturnType | null&gt;</span><span class="s3">\n  </span><span class="s1">protected abstract getRoutesManifest(): NormalizedRouteManifest | undefined</span><span class="s3">\n\n  </span><span class="s1">private async renderToResponseImpl(</span><span class="s3">\n    </span><span class="s1">ctx: RequestContext&lt;ServerRequest, ServerResponse&gt;</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ResponsePayload | null&gt; {</span><span class="s3">\n    </span><span class="s1">const { req, res, query, pathname } = ctx</span><span class="s3">\n    </span><span class="s1">let page = pathname</span><span class="s3">\n    </span><span class="s1">const bubbleNoFallback =</span><span class="s3">\n      </span><span class="s1">getRequestMeta(ctx.req, 'bubbleNoFallback') ?? false</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!this.minimalMode &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.nextConfig.experimental.validateRSCRequestHeaders</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">addRequestMeta(</span><span class="s3">\n        </span><span class="s1">ctx.req,</span><span class="s3">\n        </span><span class="s1">'cacheBustingSearchParam',</span><span class="s3">\n        </span><span class="s1">query[NEXT_RSC_UNION_QUERY]</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">delete query[NEXT_RSC_UNION_QUERY]</span><span class="s3">\n\n    </span><span class="s1">const options: MatchOptions = {</span><span class="s3">\n      </span><span class="s1">i18n: this.i18nProvider?.fromRequest(req, pathname),</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">for await (const match of this.matchers.matchAll(pathname, options)) {</span><span class="s3">\n        </span><span class="s1">// when a specific invoke-output is meant to be matched</span><span class="s3">\n        </span><span class="s1">// ensure a prior dynamic route/page doesn't take priority</span><span class="s3">\n        </span><span class="s1">const invokeOutput = getRequestMeta(ctx.req, 'invokeOutput')</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">!this.minimalMode &amp;&amp;</span><span class="s3">\n          </span><span class="s1">typeof invokeOutput === 'string' &amp;&amp;</span><span class="s3">\n          </span><span class="s1">isDynamicRoute(invokeOutput || '') &amp;&amp;</span><span class="s3">\n          </span><span class="s1">invokeOutput !== match.definition.pathname</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const result = await this.renderPageComponent(</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">...ctx,</span><span class="s3">\n            </span><span class="s1">pathname: match.definition.pathname,</span><span class="s3">\n            </span><span class="s1">renderOpts: {</span><span class="s3">\n              </span><span class="s1">...ctx.renderOpts,</span><span class="s3">\n              </span><span class="s1">params: match.params,</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">bubbleNoFallback</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">if (result !== false) return result</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// currently edge functions aren't receiving the x-matched-path</span><span class="s3">\n      </span><span class="s1">// header so we need to fallback to matching the current page</span><span class="s3">\n      </span><span class="s1">// when we weren't able to match via dynamic route to handle</span><span class="s3">\n      </span><span class="s1">// the rewrite case</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error extended in child class web-server</span><span class="s3">\n      </span><span class="s1">if (this.serverOptions.webServerConfig) {</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error extended in child class web-server</span><span class="s3">\n        </span><span class="s1">ctx.pathname = this.serverOptions.webServerConfig.page</span><span class="s3">\n        </span><span class="s1">const result = await this.renderPageComponent(ctx, bubbleNoFallback)</span><span class="s3">\n        </span><span class="s1">if (result !== false) return result</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (error) {</span><span class="s3">\n      </span><span class="s1">const err = getProperError(error)</span><span class="s3">\n\n      </span><span class="s1">if (error instanceof MissingStaticPage) {</span><span class="s3">\n        </span><span class="s1">console.error(</span><span class="s3">\n          </span><span class="s1">'Invariant: failed to load static page',</span><span class="s3">\n          </span><span class="s1">JSON.stringify(</span><span class="s3">\n            </span><span class="s1">{</span><span class="s3">\n              </span><span class="s1">page,</span><span class="s3">\n              </span><span class="s1">url: ctx.req.url,</span><span class="s3">\n              </span><span class="s1">matchedPath: ctx.req.headers[MATCHED_PATH_HEADER],</span><span class="s3">\n              </span><span class="s1">initUrl: getRequestMeta(ctx.req, 'initURL'),</span><span class="s3">\n              </span><span class="s1">didRewrite: !!getRequestMeta(ctx.req, 'rewroteURL'),</span><span class="s3">\n              </span><span class="s1">rewroteUrl: getRequestMeta(ctx.req, 'rewroteURL'),</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">null,</span><span class="s3">\n            </span><span class="s1">2</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">throw err</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (err instanceof NoFallbackError &amp;&amp; bubbleNoFallback) {</span><span class="s3">\n        </span><span class="s1">throw err</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (err instanceof DecodeError || err instanceof NormalizeError) {</span><span class="s3">\n        </span><span class="s1">res.statusCode = 400</span><span class="s3">\n        </span><span class="s1">return await this.renderErrorToResponse(ctx, err)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">res.statusCode = 500</span><span class="s3">\n\n      </span><span class="s1">// if pages/500 is present we still need to trigger</span><span class="s3">\n      </span><span class="s1">// /_error `getInitialProps` to allow reporting error</span><span class="s3">\n      </span><span class="s1">if (await this.hasPage('/500')) {</span><span class="s3">\n        </span><span class="s1">addRequestMeta(ctx.req, 'customErrorRender', true)</span><span class="s3">\n        </span><span class="s1">await this.renderErrorToResponse(ctx, err)</span><span class="s3">\n        </span><span class="s1">removeRequestMeta(ctx.req, 'customErrorRender')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const isWrappedError = err instanceof WrappedBuildError</span><span class="s3">\n\n      </span><span class="s1">if (!isWrappedError) {</span><span class="s3">\n        </span><span class="s1">if (this.minimalMode || this.renderOpts.dev) {</span><span class="s3">\n          </span><span class="s1">if (isError(err)) err.page = page</span><span class="s3">\n          </span><span class="s1">throw err</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.logError(getProperError(err))</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const response = await this.renderErrorToResponse(</span><span class="s3">\n        </span><span class="s1">ctx,</span><span class="s3">\n        </span><span class="s1">isWrappedError ? (err as WrappedBuildError).innerError : err</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">return response</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const middleware = await this.getMiddleware()</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">middleware &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!!ctx.req.headers['x-nextjs-data'] &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(!res.statusCode || res.statusCode === 200 || res.statusCode === 404)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const locale = getRequestMeta(req, 'locale')</span><span class="s3">\n\n      </span><span class="s1">res.setHeader(</span><span class="s3">\n        </span><span class="s1">'x-nextjs-matched-path',</span><span class="s3">\n        </span><span class="s1">`${locale ? `/${locale}` : ''}${pathname}`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">res.statusCode = 200</span><span class="s3">\n      </span><span class="s1">res.setHeader('Content-Type', JSON_CONTENT_TYPE_HEADER)</span><span class="s3">\n      </span><span class="s1">res.body('{}')</span><span class="s3">\n      </span><span class="s1">res.send()</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">res.statusCode = 404</span><span class="s3">\n    </span><span class="s1">return this.renderErrorToResponse(ctx, null)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async renderToHTML(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">query: ParsedUrlQuery = {}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;string | null&gt; {</span><span class="s3">\n    </span><span class="s1">return getTracer().trace(BaseServerSpan.renderToHTML, async () =&gt; {</span><span class="s3">\n      </span><span class="s1">return this.renderToHTMLImpl(req, res, pathname, query)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async renderToHTMLImpl(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">query: ParsedUrlQuery = {}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;string | null&gt; {</span><span class="s3">\n    </span><span class="s1">return this.getStaticHTML((ctx) =&gt; this.renderToResponse(ctx), {</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">res,</span><span class="s3">\n      </span><span class="s1">pathname,</span><span class="s3">\n      </span><span class="s1">query,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async renderError(</span><span class="s3">\n    </span><span class="s1">err: Error | null,</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">query: NextParsedUrlQuery = {},</span><span class="s3">\n    </span><span class="s1">setHeaders = true</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">return getTracer().trace(BaseServerSpan.renderError, async () =&gt; {</span><span class="s3">\n      </span><span class="s1">return this.renderErrorImpl(err, req, res, pathname, query, setHeaders)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async renderErrorImpl(</span><span class="s3">\n    </span><span class="s1">err: Error | null,</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">query: NextParsedUrlQuery = {},</span><span class="s3">\n    </span><span class="s1">setHeaders = true</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">if (setHeaders) {</span><span class="s3">\n      </span><span class="s1">res.setHeader(</span><span class="s3">\n        </span><span class="s1">'Cache-Control',</span><span class="s3">\n        </span><span class="s1">'private, no-cache, no-store, max-age=0, must-revalidate'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.pipe(</span><span class="s3">\n      </span><span class="s1">async (ctx) =&gt; {</span><span class="s3">\n        </span><span class="s1">const response = await this.renderErrorToResponse(ctx, err)</span><span class="s3">\n        </span><span class="s1">if (this.minimalMode &amp;&amp; res.statusCode === 500) {</span><span class="s3">\n          </span><span class="s1">throw err</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return response</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">{ req, res, pathname, query }</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private customErrorNo404Warn = execOnce(() =&gt; {</span><span class="s3">\n    </span><span class="s1">Log.warn(</span><span class="s3">\n      </span><span class="s1">`You have added a custom /_error page without a custom /404 page. This prevents the 404 page from being auto statically optimized.</span><span class="s3">\\</span><span class="s1">nSee here for info: https://nextjs.org/docs/messages/custom-error-no-custom-404`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">private async renderErrorToResponse(</span><span class="s3">\n    </span><span class="s1">ctx: RequestContext&lt;ServerRequest, ServerResponse&gt;,</span><span class="s3">\n    </span><span class="s1">err: Error | null</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ResponsePayload | null&gt; {</span><span class="s3">\n    </span><span class="s1">return getTracer().trace(BaseServerSpan.renderErrorToResponse, async () =&gt; {</span><span class="s3">\n      </span><span class="s1">return this.renderErrorToResponseImpl(ctx, err)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async renderErrorToResponseImpl(</span><span class="s3">\n    </span><span class="s1">ctx: RequestContext&lt;ServerRequest, ServerResponse&gt;,</span><span class="s3">\n    </span><span class="s1">err: Error | null</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ResponsePayload | null&gt; {</span><span class="s3">\n    </span><span class="s1">// Short-circuit favicon.ico in development to avoid compiling 404 page when the app has no favicon.ico.</span><span class="s3">\n    </span><span class="s1">// Since favicon.ico is automatically requested by the browser.</span><span class="s3">\n    </span><span class="s1">if (this.renderOpts.dev &amp;&amp; ctx.pathname === '/favicon.ico') {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">body: RenderResult.EMPTY,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const { res, query } = ctx</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">let result: null | FindComponentsResult = null</span><span class="s3">\n\n      </span><span class="s1">const is404 = res.statusCode === 404</span><span class="s3">\n      </span><span class="s1">let using404Page = false</span><span class="s3">\n\n      </span><span class="s1">if (is404) {</span><span class="s3">\n        </span><span class="s1">if (this.enabledDirectories.app) {</span><span class="s3">\n          </span><span class="s1">// Use the not-found entry in app directory</span><span class="s3">\n          </span><span class="s1">result = await this.findPageComponents({</span><span class="s3">\n            </span><span class="s1">locale: getRequestMeta(ctx.req, 'locale'),</span><span class="s3">\n            </span><span class="s1">page: UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,</span><span class="s3">\n            </span><span class="s1">query,</span><span class="s3">\n            </span><span class="s1">params: {},</span><span class="s3">\n            </span><span class="s1">isAppPath: true,</span><span class="s3">\n            </span><span class="s1">shouldEnsure: true,</span><span class="s3">\n            </span><span class="s1">url: ctx.req.url,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">using404Page = result !== null</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (!result &amp;&amp; (await this.hasPage('/404'))) {</span><span class="s3">\n          </span><span class="s1">result = await this.findPageComponents({</span><span class="s3">\n            </span><span class="s1">locale: getRequestMeta(ctx.req, 'locale'),</span><span class="s3">\n            </span><span class="s1">page: '/404',</span><span class="s3">\n            </span><span class="s1">query,</span><span class="s3">\n            </span><span class="s1">params: {},</span><span class="s3">\n            </span><span class="s1">isAppPath: false,</span><span class="s3">\n            </span><span class="s1">// Ensuring can't be done here because you never </span><span class="s3">\&quot;</span><span class="s1">match</span><span class="s3">\&quot; </span><span class="s1">a 404 route.</span><span class="s3">\n            </span><span class="s1">shouldEnsure: true,</span><span class="s3">\n            </span><span class="s1">url: ctx.req.url,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">using404Page = result !== null</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">let statusPage = `/${res.statusCode}`</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!getRequestMeta(ctx.req, 'customErrorRender') &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!result &amp;&amp;</span><span class="s3">\n        </span><span class="s1">STATIC_STATUS_PAGES.includes(statusPage)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// skip ensuring /500 in dev mode as it isn't used and the</span><span class="s3">\n        </span><span class="s1">// dev overlay is used instead</span><span class="s3">\n        </span><span class="s1">if (statusPage !== '/500' || !this.renderOpts.dev) {</span><span class="s3">\n          </span><span class="s1">result = await this.findPageComponents({</span><span class="s3">\n            </span><span class="s1">locale: getRequestMeta(ctx.req, 'locale'),</span><span class="s3">\n            </span><span class="s1">page: statusPage,</span><span class="s3">\n            </span><span class="s1">query,</span><span class="s3">\n            </span><span class="s1">params: {},</span><span class="s3">\n            </span><span class="s1">isAppPath: false,</span><span class="s3">\n            </span><span class="s1">// Ensuring can't be done here because you never </span><span class="s3">\&quot;</span><span class="s1">match</span><span class="s3">\&quot; </span><span class="s1">a 500</span><span class="s3">\n            </span><span class="s1">// route.</span><span class="s3">\n            </span><span class="s1">shouldEnsure: true,</span><span class="s3">\n            </span><span class="s1">url: ctx.req.url,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (!result) {</span><span class="s3">\n        </span><span class="s1">result = await this.findPageComponents({</span><span class="s3">\n          </span><span class="s1">locale: getRequestMeta(ctx.req, 'locale'),</span><span class="s3">\n          </span><span class="s1">page: '/_error',</span><span class="s3">\n          </span><span class="s1">query,</span><span class="s3">\n          </span><span class="s1">params: {},</span><span class="s3">\n          </span><span class="s1">isAppPath: false,</span><span class="s3">\n          </span><span class="s1">// Ensuring can't be done here because you never </span><span class="s3">\&quot;</span><span class="s1">match</span><span class="s3">\&quot; </span><span class="s1">an error</span><span class="s3">\n          </span><span class="s1">// route.</span><span class="s3">\n          </span><span class="s1">shouldEnsure: true,</span><span class="s3">\n          </span><span class="s1">url: ctx.req.url,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">statusPage = '/_error'</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!using404Page &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(await this.hasPage('/_error')) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!(await this.hasPage('/404'))</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">this.customErrorNo404Warn()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (!result) {</span><span class="s3">\n        </span><span class="s1">// this can occur when a project directory has been moved/deleted</span><span class="s3">\n        </span><span class="s1">// which is handled in the parent process in development</span><span class="s3">\n        </span><span class="s1">if (this.renderOpts.dev) {</span><span class="s3">\n          </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">// wait for dev-server to restart before refreshing</span><span class="s3">\n            </span><span class="s1">body: RenderResult.fromStatic(</span><span class="s3">\n              </span><span class="s1">`</span><span class="s3">\n              </span><span class="s1">&lt;pre&gt;missing required error components, refreshing...&lt;/pre&gt;</span><span class="s3">\n              </span><span class="s1">&lt;script&gt;</span><span class="s3">\n                </span><span class="s1">async function check() {</span><span class="s3">\n                  </span><span class="s1">const res = await fetch(location.href).catch(() =&gt; ({}))</span><span class="s3">\n\n                  </span><span class="s1">if (res.status === 200) {</span><span class="s3">\n                    </span><span class="s1">location.reload()</span><span class="s3">\n                  </span><span class="s1">} else {</span><span class="s3">\n                    </span><span class="s1">setTimeout(check, 1000)</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">check()</span><span class="s3">\n              </span><span class="s1">&lt;/script&gt;`,</span><span class="s3">\n              </span><span class="s1">HTML_CONTENT_TYPE_HEADER</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">throw new WrappedBuildError(</span><span class="s3">\n          </span><span class="s1">new Error('missing required error components')</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// If the page has a route module, use it for the new match. If it doesn't</span><span class="s3">\n      </span><span class="s1">// have a route module, remove the match.</span><span class="s3">\n      </span><span class="s1">if (result.components.routeModule) {</span><span class="s3">\n        </span><span class="s1">addRequestMeta(ctx.req, 'match', {</span><span class="s3">\n          </span><span class="s1">definition: result.components.routeModule.definition,</span><span class="s3">\n          </span><span class="s1">params: undefined,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">removeRequestMeta(ctx.req, 'match')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">return await this.renderToResponseWithComponents(</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">...ctx,</span><span class="s3">\n            </span><span class="s1">pathname: statusPage,</span><span class="s3">\n            </span><span class="s1">renderOpts: {</span><span class="s3">\n              </span><span class="s1">...ctx.renderOpts,</span><span class="s3">\n              </span><span class="s1">err,</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">result</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} catch (maybeFallbackError) {</span><span class="s3">\n        </span><span class="s1">if (maybeFallbackError instanceof NoFallbackError) {</span><span class="s3">\n          </span><span class="s1">throw new Error('invariant: failed to render error page')</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">throw maybeFallbackError</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (error) {</span><span class="s3">\n      </span><span class="s1">const renderToHtmlError = getProperError(error)</span><span class="s3">\n      </span><span class="s1">const isWrappedError = renderToHtmlError instanceof WrappedBuildError</span><span class="s3">\n      </span><span class="s1">if (!isWrappedError) {</span><span class="s3">\n        </span><span class="s1">this.logError(renderToHtmlError)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">res.statusCode = 500</span><span class="s3">\n      </span><span class="s1">const fallbackComponents = await this.getFallbackErrorComponents(</span><span class="s3">\n        </span><span class="s1">ctx.req.url</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">if (fallbackComponents) {</span><span class="s3">\n        </span><span class="s1">// There was an error, so use it's definition from the route module</span><span class="s3">\n        </span><span class="s1">// to add the match to the request.</span><span class="s3">\n        </span><span class="s1">addRequestMeta(ctx.req, 'match', {</span><span class="s3">\n          </span><span class="s1">definition: fallbackComponents.routeModule!.definition,</span><span class="s3">\n          </span><span class="s1">params: undefined,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">return this.renderToResponseWithComponents(</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">...ctx,</span><span class="s3">\n            </span><span class="s1">pathname: '/_error',</span><span class="s3">\n            </span><span class="s1">renderOpts: {</span><span class="s3">\n              </span><span class="s1">...ctx.renderOpts,</span><span class="s3">\n              </span><span class="s1">// We render `renderToHtmlError` here because `err` is</span><span class="s3">\n              </span><span class="s1">// already captured in the stacktrace.</span><span class="s3">\n              </span><span class="s1">err: isWrappedError</span><span class="s3">\n                </span><span class="s1">? renderToHtmlError.innerError</span><span class="s3">\n                </span><span class="s1">: renderToHtmlError,</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">query,</span><span class="s3">\n            </span><span class="s1">components: fallbackComponents,</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">body: RenderResult.fromStatic('Internal Server Error', 'text/plain'),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async renderErrorToHTML(</span><span class="s3">\n    </span><span class="s1">err: Error | null,</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">query: ParsedUrlQuery = {}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;string | null&gt; {</span><span class="s3">\n    </span><span class="s1">return this.getStaticHTML((ctx) =&gt; this.renderErrorToResponse(ctx, err), {</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">res,</span><span class="s3">\n      </span><span class="s1">pathname,</span><span class="s3">\n      </span><span class="s1">query,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async render404(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">parsedUrl?: Pick&lt;NextUrlWithParsedQuery, 'pathname' | 'query'&gt;,</span><span class="s3">\n    </span><span class="s1">setHeaders = true</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">const { pathname, query } = parsedUrl ? parsedUrl : parseUrl(req.url!, true)</span><span class="s3">\n\n    </span><span class="s1">// Ensure the locales are provided on the request meta.</span><span class="s3">\n    </span><span class="s1">if (this.nextConfig.i18n) {</span><span class="s3">\n      </span><span class="s1">if (!getRequestMeta(req, 'locale')) {</span><span class="s3">\n        </span><span class="s1">addRequestMeta(req, 'locale', this.nextConfig.i18n.defaultLocale)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">addRequestMeta(req, 'defaultLocale', this.nextConfig.i18n.defaultLocale)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">res.statusCode = 404</span><span class="s3">\n    </span><span class="s1">return this.renderError(null, req, res, pathname!, query, setHeaders)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;WrappedBuildError&quot;</span><span class="s0">,</span><span class="s1">&quot;Server&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;innerError&quot;</span><span class="s0">,</span><span class="s1">&quot;getServerComponentsHmrCache&quot;</span><span class="s0">,</span><span class="s1">&quot;nextConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;experimental&quot;</span><span class="s0">,</span><span class="s1">&quot;serverComponentsHmrCache&quot;</span><span class="s0">,</span><span class="s1">&quot;globalThis&quot;</span><span class="s0">,</span><span class="s1">&quot;__serverComponentsHmrCache&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;handleRSCRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;req&quot;</span><span class="s0">,</span><span class="s1">&quot;_res&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizers&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPrefetchRSC&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;extract&quot;</span><span class="s0">,</span><span class="s1">&quot;originalPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_PREFETCH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_SEGMENT_PREFETCH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;addRequestMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRSC&quot;</span><span class="s0">,</span><span class="s1">&quot;normalize&quot;</span><span class="s0">,</span><span class="s1">&quot;rsc&quot;</span><span class="s0">,</span><span class="s1">&quot;stripFlightHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPrefetchRSCRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;parsed&quot;</span><span class="s0">,</span><span class="s1">&quot;parseUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;formatUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;handleNextDataRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;middleware&quot;</span><span class="s0">,</span><span class="s1">&quot;getMiddleware&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;matchNextDataPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;buildId&quot;</span><span class="s0">,</span><span class="s1">&quot;getRequestMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;render404&quot;</span><span class="s0">,</span><span class="s1">&quot;shift&quot;</span><span class="s0">,</span><span class="s1">&quot;lastParam&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteFromAssetPath&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;substring&quot;</span><span class="s0">,</span><span class="s1">&quot;i18nProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;hostname&quot;</span><span class="s0">,</span><span class="s1">&quot;host&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;toLowerCase&quot;</span><span class="s0">,</span><span class="s1">&quot;domainLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;detectDomainLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;config&quot;</span><span class="s0">,</span><span class="s1">&quot;localePathResult&quot;</span><span class="s0">,</span><span class="s1">&quot;analyze&quot;</span><span class="s0">,</span><span class="s1">&quot;detectedLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;removeRequestMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;handleNextImageRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;handleCatchallRenderRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;handleCatchallMiddlewareRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeAndAttachMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;finished&quot;</span><span class="s0">,</span><span class="s1">&quot;enabledDirectories&quot;</span><span class="s0">,</span><span class="s1">&quot;pages&quot;</span><span class="s0">,</span><span class="s1">&quot;prepared&quot;</span><span class="s0">,</span><span class="s1">&quot;preparedPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;customErrorNo404Warn&quot;</span><span class="s0">,</span><span class="s1">&quot;execOnce&quot;</span><span class="s0">,</span><span class="s1">&quot;Log&quot;</span><span class="s0">,</span><span class="s1">&quot;warn&quot;</span><span class="s0">,</span><span class="s1">&quot;dir&quot;</span><span class="s0">,</span><span class="s1">&quot;quiet&quot;</span><span class="s0">,</span><span class="s1">&quot;conf&quot;</span><span class="s0">,</span><span class="s1">&quot;dev&quot;</span><span class="s0">,</span><span class="s1">&quot;minimalMode&quot;</span><span class="s0">,</span><span class="s1">&quot;port&quot;</span><span class="s0">,</span><span class="s1">&quot;experimentalTestProxy&quot;</span><span class="s0">,</span><span class="s1">&quot;serverOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;loadEnvConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchHostname&quot;</span><span class="s0">,</span><span class="s1">&quot;formatHostname&quot;</span><span class="s0">,</span><span class="s1">&quot;distDir&quot;</span><span class="s0">,</span><span class="s1">&quot;publicDir&quot;</span><span class="s0">,</span><span class="s1">&quot;getPublicDir&quot;</span><span class="s0">,</span><span class="s1">&quot;hasStaticDir&quot;</span><span class="s0">,</span><span class="s1">&quot;getHasStaticDir&quot;</span><span class="s0">,</span><span class="s1">&quot;i18n&quot;</span><span class="s0">,</span><span class="s1">&quot;locales&quot;</span><span class="s0">,</span><span class="s1">&quot;I18NProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;localeNormalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;LocaleRouteNormalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;serverRuntimeConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;publicRuntimeConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;assetPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;generateEtags&quot;</span><span class="s0">,</span><span class="s1">&quot;getBuildId&quot;</span><span class="s0">,</span><span class="s1">&quot;minimalModeKey&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_PRIVATE_MINIMAL_MODE&quot;</span><span class="s0">,</span><span class="s1">&quot;getEnabledDirectories&quot;</span><span class="s0">,</span><span class="s1">&quot;isAppPPREnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;app&quot;</span><span class="s0">,</span><span class="s1">&quot;checkIsAppPPREnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;ppr&quot;</span><span class="s0">,</span><span class="s1">&quot;isAppSegmentPrefetchEnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;clientSegmentCache&quot;</span><span class="s0">,</span><span class="s1">&quot;RSCPathnameNormalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchRSCPathnameNormalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;SegmentPrefixRSCPathnameNormalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;NextDataPathnameNormalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;nextFontManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;getNextFontManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_DEPLOYMENT_ID&quot;</span><span class="s0">,</span><span class="s1">&quot;deploymentId&quot;</span><span class="s0">,</span><span class="s1">&quot;renderOpts&quot;</span><span class="s0">,</span><span class="s1">&quot;supportsDynamicResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;poweredByHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalBase&quot;</span><span class="s0">,</span><span class="s1">&quot;amp&quot;</span><span class="s0">,</span><span class="s1">&quot;previewProps&quot;</span><span class="s0">,</span><span class="s1">&quot;getPrerenderManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;preview&quot;</span><span class="s0">,</span><span class="s1">&quot;ampOptimizerConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;optimizer&quot;</span><span class="s0">,</span><span class="s1">&quot;basePath&quot;</span><span class="s0">,</span><span class="s1">&quot;images&quot;</span><span class="s0">,</span><span class="s1">&quot;optimizeCss&quot;</span><span class="s0">,</span><span class="s1">&quot;nextConfigOutput&quot;</span><span class="s0">,</span><span class="s1">&quot;output&quot;</span><span class="s0">,</span><span class="s1">&quot;nextScriptWorkers&quot;</span><span class="s0">,</span><span class="s1">&quot;disableOptimizedLoading&quot;</span><span class="s0">,</span><span class="s1">&quot;domainLocales&quot;</span><span class="s0">,</span><span class="s1">&quot;domains&quot;</span><span class="s0">,</span><span class="s1">&quot;serverComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheLifeProfiles&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheLife&quot;</span><span class="s0">,</span><span class="s1">&quot;enableTainting&quot;</span><span class="s0">,</span><span class="s1">&quot;taint&quot;</span><span class="s0">,</span><span class="s1">&quot;crossOrigin&quot;</span><span class="s0">,</span><span class="s1">&quot;largePageDataBytes&quot;</span><span class="s0">,</span><span class="s1">&quot;runtimeConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;isExperimentalCompile&quot;</span><span class="s0">,</span><span class="s1">&quot;htmlLimitedBots&quot;</span><span class="s0">,</span><span class="s1">&quot;expireTime&quot;</span><span class="s0">,</span><span class="s1">&quot;staleTimes&quot;</span><span class="s0">,</span><span class="s1">&quot;clientTraceMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">,</span><span class="s1">&quot;clientParamParsing&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicOnHover&quot;</span><span class="s0">,</span><span class="s1">&quot;inlineCss&quot;</span><span class="s0">,</span><span class="s1">&quot;authInterrupts&quot;</span><span class="s0">,</span><span class="s1">&quot;onInstrumentationRequestError&quot;</span><span class="s0">,</span><span class="s1">&quot;instrumentationOnRequestError&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;reactMaxHeadersLength&quot;</span><span class="s0">,</span><span class="s1">&quot;devtoolSegmentExplorer&quot;</span><span class="s0">,</span><span class="s1">&quot;setConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;pagesManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;getPagesManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;appPathsManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;getAppPathsManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;appPathRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;getAppPathRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptionRoutePatterns&quot;</span><span class="s0">,</span><span class="s1">&quot;getinterceptionRoutePatterns&quot;</span><span class="s0">,</span><span class="s1">&quot;matchers&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteMatchers&quot;</span><span class="s0">,</span><span class="s1">&quot;reload&quot;</span><span class="s0">,</span><span class="s1">&quot;setAssetPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;responseCache&quot;</span><span class="s0">,</span><span class="s1">&quot;getResponseCache&quot;</span><span class="s0">,</span><span class="s1">&quot;manifestLoader&quot;</span><span class="s0">,</span><span class="s1">&quot;ServerManifestLoader&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;PAGES_MANIFEST&quot;</span><span class="s0">,</span><span class="s1">&quot;APP_PATHS_MANIFEST&quot;</span><span class="s0">,</span><span class="s1">&quot;DefaultRouteMatcherManager&quot;</span><span class="s0">,</span><span class="s1">&quot;PagesRouteMatcherProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;PagesAPIRouteMatcherProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;AppPageRouteMatcherProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;AppRouteRouteMatcherProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;ctx&quot;</span><span class="s0">,</span><span class="s1">&quot;instrumentation&quot;</span><span class="s0">,</span><span class="s1">&quot;onRequestError&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;NextRequestHint&quot;</span><span class="s0">,</span><span class="s1">&quot;fromEntries&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;handlerErr&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;logError&quot;</span><span class="s0">,</span><span class="s1">&quot;handleRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;prepare&quot;</span><span class="s0">,</span><span class="s1">&quot;toUpperCase&quot;</span><span class="s0">,</span><span class="s1">&quot;tracer&quot;</span><span class="s0">,</span><span class="s1">&quot;getTracer&quot;</span><span class="s0">,</span><span class="s1">&quot;withPropagatedContext&quot;</span><span class="s0">,</span><span class="s1">&quot;trace&quot;</span><span class="s0">,</span><span class="s1">&quot;BaseServerSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;spanName&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;SpanKind&quot;</span><span class="s0">,</span><span class="s1">&quot;SERVER&quot;</span><span class="s0">,</span><span class="s1">&quot;attributes&quot;</span><span class="s0">,</span><span class="s1">&quot;span&quot;</span><span class="s0">,</span><span class="s1">&quot;handleRequestImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;finally&quot;</span><span class="s0">,</span><span class="s1">&quot;isRSCRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;setAttributes&quot;</span><span class="s0">,</span><span class="s1">&quot;statusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;setStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;SpanStatusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;ERROR&quot;</span><span class="s0">,</span><span class="s1">&quot;setAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;rootSpanAttributes&quot;</span><span class="s0">,</span><span class="s1">&quot;getRootSpanAttributes&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;updateName&quot;</span><span class="s0">,</span><span class="s1">&quot;originalRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;waitTillReady&quot;</span><span class="s0">,</span><span class="s1">&quot;patchSetHeaderWithCookieSupport&quot;</span><span class="s0">,</span><span class="s1">&quot;isNodeNextResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;originalResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;urlParts&quot;</span><span class="s0">,</span><span class="s1">&quot;urlNoQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeRepeatedSlashes&quot;</span><span class="s0">,</span><span class="s1">&quot;redirect&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;send&quot;</span><span class="s0">,</span><span class="s1">&quot;query&quot;</span><span class="s0">,</span><span class="s1">&quot;URLSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;isNodeNextRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;xForwardedProto&quot;</span><span class="s0">,</span><span class="s1">&quot;isHttps&quot;</span><span class="s0">,</span><span class="s1">&quot;socket&quot;</span><span class="s0">,</span><span class="s1">&quot;encrypted&quot;</span><span class="s0">,</span><span class="s1">&quot;remoteAddress&quot;</span><span class="s0">,</span><span class="s1">&quot;attachRequestMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;getHostname&quot;</span><span class="s0">,</span><span class="s1">&quot;parseUrlUtil&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;pathnameInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;getNextPathnameInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;removePathPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;useMatchedPathHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;MATCHED_PATH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;matchedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;fixMojibake&quot;</span><span class="s0">,</span><span class="s1">&quot;urlPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_RESUME_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;chunk&quot;</span><span class="s0">,</span><span class="s1">&quot;postponed&quot;</span><span class="s0">,</span><span class="s1">&quot;Buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedUrlPath&quot;</span><span class="s0">,</span><span class="s1">&quot;stripNextDataPath&quot;</span><span class="s0">,</span><span class="s1">&quot;denormalizePagePath&quot;</span><span class="s0">,</span><span class="s1">&quot;localeAnalysisResult&quot;</span><span class="s0">,</span><span class="s1">&quot;inferredFromDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;srcPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;pageIsDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;paramsResult&quot;</span><span class="s0">,</span><span class="s1">&quot;hasValidParams&quot;</span><span class="s0">,</span><span class="s1">&quot;definition&quot;</span><span class="s0">,</span><span class="s1">&quot;utils&quot;</span><span class="s0">,</span><span class="s1">&quot;getServerUtils&quot;</span><span class="s0">,</span><span class="s1">&quot;page&quot;</span><span class="s0">,</span><span class="s1">&quot;rewrites&quot;</span><span class="s0">,</span><span class="s1">&quot;getRoutesManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;beforeFiles&quot;</span><span class="s0">,</span><span class="s1">&quot;afterFiles&quot;</span><span class="s0">,</span><span class="s1">&quot;fallback&quot;</span><span class="s0">,</span><span class="s1">&quot;caseSensitive&quot;</span><span class="s0">,</span><span class="s1">&quot;caseSensitiveRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;locale&quot;</span><span class="s0">,</span><span class="s1">&quot;originQueryParams&quot;</span><span class="s0">,</span><span class="s1">&quot;pathnameBeforeRewrite&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;handleRewrites&quot;</span><span class="s0">,</span><span class="s1">&quot;queryParams&quot;</span><span class="s0">,</span><span class="s1">&quot;didRewrite&quot;</span><span class="s0">,</span><span class="s1">&quot;routeParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeNextQueryParam&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;v&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeQueryPathParameter&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeDynamicRouteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;matcherParams&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;curParamsResult&quot;</span><span class="s0">,</span><span class="s1">&quot;routeMatchesHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;routeMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;getParamsFromRouteMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultRouteMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;interpolateDynamicPath&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeCdnUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultRouteRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;groups&quot;</span><span class="s0">,</span><span class="s1">&quot;DecodeError&quot;</span><span class="s0">,</span><span class="s1">&quot;NormalizeError&quot;</span><span class="s0">,</span><span class="s1">&quot;renderError&quot;</span><span class="s0">,</span><span class="s1">&quot;webServerConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;incrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;getIncrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;requestHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;resetRequestCache&quot;</span><span class="s0">,</span><span class="s1">&quot;__incrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;getCacheHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;all&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;previouslyRevalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;getPreviouslyRevalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;previewModeId&quot;</span><span class="s0">,</span><span class="s1">&quot;receiveExpiredTags&quot;</span><span class="s0">,</span><span class="s1">&quot;invokePath&quot;</span><span class="s0">,</span><span class="s1">&quot;useInvokePath&quot;</span><span class="s0">,</span><span class="s1">&quot;invokeStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;invokeQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedMatchedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;invokePathnameInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;parseData&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeResult&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeLocalePath&quot;</span><span class="s0">,</span><span class="s1">&quot;response&quot;</span><span class="s0">,</span><span class="s1">&quot;Response&quot;</span><span class="s0">,</span><span class="s1">&quot;bubble&quot;</span><span class="s0">,</span><span class="s1">&quot;run&quot;</span><span class="s0">,</span><span class="s1">&quot;NoFallbackError&quot;</span><span class="s0">,</span><span class="s1">&quot;isBubbledError&quot;</span><span class="s0">,</span><span class="s1">&quot;getProperError&quot;</span><span class="s0">,</span><span class="s1">&quot;getRequestHandlerWithMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;meta&quot;</span><span class="s0">,</span><span class="s1">&quot;handler&quot;</span><span class="s0">,</span><span class="s1">&quot;getRequestHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;setRequestMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">,</span><span class="s1">&quot;loadInstrumentationModule&quot;</span><span class="s0">,</span><span class="s1">&quot;prepareImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;close&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;entry&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;runImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;pipe&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;partialContext&quot;</span><span class="s0">,</span><span class="s1">&quot;pipeImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;ua&quot;</span><span class="s0">,</span><span class="s1">&quot;botType&quot;</span><span class="s0">,</span><span class="s1">&quot;serveStreamingMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldServeStreamingMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;payload&quot;</span><span class="s0">,</span><span class="s1">&quot;originalStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheControl&quot;</span><span class="s0">,</span><span class="s1">&quot;sent&quot;</span><span class="s0">,</span><span class="s1">&quot;setHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;expire&quot;</span><span class="s0">,</span><span class="s1">&quot;sendRenderResult&quot;</span><span class="s0">,</span><span class="s1">&quot;getStaticHTML&quot;</span><span class="s0">,</span><span class="s1">&quot;toUnchunkedString&quot;</span><span class="s0">,</span><span class="s1">&quot;render&quot;</span><span class="s0">,</span><span class="s1">&quot;internalRender&quot;</span><span class="s0">,</span><span class="s1">&quot;renderImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;getWaitUntil&quot;</span><span class="s0">,</span><span class="s1">&quot;builtinRequestContext&quot;</span><span class="s0">,</span><span class="s1">&quot;getBuiltinRequestContext&quot;</span><span class="s0">,</span><span class="s1">&quot;waitUntil&quot;</span><span class="s0">,</span><span class="s1">&quot;getInternalWaitUntil&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;customServer&quot;</span><span class="s0">,</span><span class="s1">&quot;hasPage&quot;</span><span class="s0">,</span><span class="s1">&quot;getBotType&quot;</span><span class="s0">,</span><span class="s1">&quot;isBlockedPage&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;getStaticPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackField&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;staticPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackMode&quot;</span><span class="s0">,</span><span class="s1">&quot;parseFallbackField&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToResponseWithComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;requestContext&quot;</span><span class="s0">,</span><span class="s1">&quot;findComponentsResult&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToResponseWithComponentsImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;pathCouldBeIntercepted&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;isInterceptionRouteAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;regexp&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;setVaryHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;isAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;baseVaryHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_STATE_TREE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;addedNextUrlToVary&quot;</span><span class="s0">,</span><span class="s1">&quot;appendHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_URL&quot;</span><span class="s0">,</span><span class="s1">&quot;opts&quot;</span><span class="s0">,</span><span class="s1">&quot;components&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;UNDERSCORE_NOT_FOUND_ROUTE&quot;</span><span class="s0">,</span><span class="s1">&quot;isErrorPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;is404Page&quot;</span><span class="s0">,</span><span class="s1">&quot;is500Page&quot;</span><span class="s0">,</span><span class="s1">&quot;hasServerProps&quot;</span><span class="s0">,</span><span class="s1">&quot;getServerSideProps&quot;</span><span class="s0">,</span><span class="s1">&quot;isPossibleServerAction&quot;</span><span class="s0">,</span><span class="s1">&quot;getIsPossibleServerAction&quot;</span><span class="s0">,</span><span class="s1">&quot;isSSG&quot;</span><span class="s0">,</span><span class="s1">&quot;getStaticProps&quot;</span><span class="s0">,</span><span class="s1">&quot;validateRSCRequestHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchHeaderValue&quot;</span><span class="s0">,</span><span class="s1">&quot;routerPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;expectedHash&quot;</span><span class="s0">,</span><span class="s1">&quot;computeCacheBustingSearchParam&quot;</span><span class="s0">,</span><span class="s1">&quot;actualHash&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_RSC_UNION_QUERY&quot;</span><span class="s0">,</span><span class="s1">&quot;setCacheBustingSearchParamWithHash&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedUrlPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;hasFallback&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;routes&quot;</span><span class="s0">,</span><span class="s1">&quot;toRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;isNextDataRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;routeModule&quot;</span><span class="s0">,</span><span class="s1">&quot;couldSupportPPR&quot;</span><span class="s0">,</span><span class="s1">&quot;isAppPageRouteModule&quot;</span><span class="s0">,</span><span class="s1">&quot;hasDebugStaticShellQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING&quot;</span><span class="s0">,</span><span class="s1">&quot;__nextppronly&quot;</span><span class="s0">,</span><span class="s1">&quot;isRoutePPREnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;renderingMode&quot;</span><span class="s0">,</span><span class="s1">&quot;minimalPostponed&quot;</span><span class="s0">,</span><span class="s1">&quot;STATIC_STATUS_PAGES&quot;</span><span class="s0">,</span><span class="s1">&quot;parseInt&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;Component&quot;</span><span class="s0">,</span><span class="s1">&quot;RenderResult&quot;</span><span class="s0">,</span><span class="s1">&quot;fromStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;HTML_CONTENT_TYPE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;isBotRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;isBot&quot;</span><span class="s0">,</span><span class="s1">&quot;isSupportedDocument&quot;</span><span class="s0">,</span><span class="s1">&quot;Document&quot;</span><span class="s0">,</span><span class="s1">&quot;getInitialProps&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_BUILTIN_DOCUMENT&quot;</span><span class="s0">,</span><span class="s1">&quot;removeTrailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;isDev&quot;</span><span class="s0">,</span><span class="s1">&quot;pathsResults&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderedRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;smallestFallbackRouteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackRouteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;devValidatingFallbackParams&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;isAppRouteRouteModule&quot;</span><span class="s0">,</span><span class="s1">&quot;sendResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;request&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedInitUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;initPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;ampValidator&quot;</span><span class="s0">,</span><span class="s1">&quot;ComponentMod&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeDevRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;Proxy&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchMetrics&quot;</span><span class="s0">,</span><span class="s1">&quot;stripLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;splitPath&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;getOriginalAppPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;originalAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;renderPageComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;bubbleNoFallback&quot;</span><span class="s0">,</span><span class="s1">&quot;appPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;findPageComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;sriEnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;sri&quot;</span><span class="s0">,</span><span class="s1">&quot;algorithm&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldEnsure&quot;</span><span class="s0">,</span><span class="s1">&quot;setRootSpanAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;isNoFallbackError&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToResponseImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;fromRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;matchAll&quot;</span><span class="s0">,</span><span class="s1">&quot;invokeOutput&quot;</span><span class="s0">,</span><span class="s1">&quot;MissingStaticPage&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;initUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;rewroteUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;renderErrorToResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;isWrappedError&quot;</span><span class="s0">,</span><span class="s1">&quot;isError&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON_CONTENT_TYPE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToHTML&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToHTMLImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;setHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;renderErrorImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;renderErrorToResponseImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;EMPTY&quot;</span><span class="s0">,</span><span class="s1">&quot;is404&quot;</span><span class="s0">,</span><span class="s1">&quot;using404Page&quot;</span><span class="s0">,</span><span class="s1">&quot;UNDERSCORE_NOT_FOUND_ROUTE_ENTRY&quot;</span><span class="s0">,</span><span class="s1">&quot;statusPage&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeFallbackError&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToHtmlError&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;getFallbackErrorComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;renderErrorToHTML&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>