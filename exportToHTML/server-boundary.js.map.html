<html>
<head>
<title>server-boundary.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
server-boundary.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/server/typescript/rules/server-boundary.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// This module provides intellisense for all exports from `</span><span class="s3">\&quot;</span><span class="s1">use server</span><span class="s3">\&quot;</span><span class="s1">` directive.</span><span class="s3">\n\n</span><span class="s1">import { NEXT_TS_ERRORS } from '../constant'</span><span class="s3">\n</span><span class="s1">import { getTs, getTypeChecker } from '../utils'</span><span class="s3">\n</span><span class="s1">import type tsModule from 'typescript/lib/tsserverlibrary'</span><span class="s3">\n\n</span><span class="s1">// Check if the type is `Promise&lt;T&gt;`.</span><span class="s3">\n</span><span class="s1">function isPromiseType(type: tsModule.Type, typeChecker: tsModule.TypeChecker) {</span><span class="s3">\n  </span><span class="s1">const typeReferenceType = type as tsModule.TypeReference</span><span class="s3">\n  </span><span class="s1">if (!typeReferenceType.target) return false</span><span class="s3">\n\n  </span><span class="s1">// target should be Promise or Promise&lt;...&gt;</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">!/^Promise(&lt;.+&gt;)?$/.test(typeChecker.typeToString(typeReferenceType.target))</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isFunctionReturningPromise(</span><span class="s3">\n  </span><span class="s1">node: tsModule.Node,</span><span class="s3">\n  </span><span class="s1">typeChecker: tsModule.TypeChecker,</span><span class="s3">\n  </span><span class="s1">ts: typeof tsModule</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const type = typeChecker.getTypeAtLocation(node)</span><span class="s3">\n  </span><span class="s1">const signatures = typeChecker.getSignaturesOfType(</span><span class="s3">\n    </span><span class="s1">type,</span><span class="s3">\n    </span><span class="s1">ts.SignatureKind.Call</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">let isPromise = true</span><span class="s3">\n  </span><span class="s1">if (signatures.length) {</span><span class="s3">\n    </span><span class="s1">for (const signature of signatures) {</span><span class="s3">\n      </span><span class="s1">const returnType = signature.getReturnType()</span><span class="s3">\n      </span><span class="s1">if (returnType.isUnion()) {</span><span class="s3">\n        </span><span class="s1">for (const t of returnType.types) {</span><span class="s3">\n          </span><span class="s1">if (!isPromiseType(t, typeChecker)) {</span><span class="s3">\n            </span><span class="s1">isPromise = false</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">isPromise = isPromiseType(returnType, typeChecker)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">isPromise = false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return isPromise</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const serverBoundary = {</span><span class="s3">\n  </span><span class="s1">getSemanticDiagnosticsForExportDeclaration(</span><span class="s3">\n    </span><span class="s1">source: tsModule.SourceFile,</span><span class="s3">\n    </span><span class="s1">node: tsModule.ExportDeclaration</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const ts = getTs()</span><span class="s3">\n    </span><span class="s1">const typeChecker = getTypeChecker()</span><span class="s3">\n    </span><span class="s1">if (!typeChecker) return []</span><span class="s3">\n\n    </span><span class="s1">const diagnostics: tsModule.Diagnostic[] = []</span><span class="s3">\n\n    </span><span class="s1">const exportClause = node.exportClause</span><span class="s3">\n    </span><span class="s1">if (!node.isTypeOnly &amp;&amp; exportClause &amp;&amp; ts.isNamedExports(exportClause)) {</span><span class="s3">\n      </span><span class="s1">for (const e of exportClause.elements) {</span><span class="s3">\n        </span><span class="s1">if (e.isTypeOnly) {</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!isFunctionReturningPromise(e, typeChecker, ts)) {</span><span class="s3">\n          </span><span class="s1">diagnostics.push({</span><span class="s3">\n            </span><span class="s1">file: source,</span><span class="s3">\n            </span><span class="s1">category: ts.DiagnosticCategory.Error,</span><span class="s3">\n            </span><span class="s1">code: NEXT_TS_ERRORS.INVALID_SERVER_ENTRY_RETURN,</span><span class="s3">\n            </span><span class="s1">messageText: `The </span><span class="s3">\&quot;</span><span class="s1">use server</span><span class="s3">\&quot; </span><span class="s1">file can only export async functions.`,</span><span class="s3">\n            </span><span class="s1">start: e.getStart(),</span><span class="s3">\n            </span><span class="s1">length: e.getWidth(),</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return diagnostics</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">getSemanticDiagnosticsForExportVariableStatement(</span><span class="s3">\n    </span><span class="s1">source: tsModule.SourceFile,</span><span class="s3">\n    </span><span class="s1">node: tsModule.VariableStatement</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const ts = getTs()</span><span class="s3">\n\n    </span><span class="s1">const diagnostics: tsModule.Diagnostic[] = []</span><span class="s3">\n\n    </span><span class="s1">if (ts.isVariableDeclarationList(node.declarationList)) {</span><span class="s3">\n      </span><span class="s1">for (const declaration of node.declarationList.declarations) {</span><span class="s3">\n        </span><span class="s1">const initializer = declaration.initializer</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">initializer &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(ts.isArrowFunction(initializer) ||</span><span class="s3">\n            </span><span class="s1">ts.isFunctionDeclaration(initializer) ||</span><span class="s3">\n            </span><span class="s1">ts.isFunctionExpression(initializer) ||</span><span class="s3">\n            </span><span class="s1">ts.isCallExpression(initializer) ||</span><span class="s3">\n            </span><span class="s1">ts.isIdentifier(initializer))</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">diagnostics.push(</span><span class="s3">\n            </span><span class="s1">...serverBoundary.getSemanticDiagnosticsForFunctionExport(</span><span class="s3">\n              </span><span class="s1">source,</span><span class="s3">\n              </span><span class="s1">initializer</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">diagnostics.push({</span><span class="s3">\n            </span><span class="s1">file: source,</span><span class="s3">\n            </span><span class="s1">category: ts.DiagnosticCategory.Error,</span><span class="s3">\n            </span><span class="s1">code: NEXT_TS_ERRORS.INVALID_SERVER_ENTRY_RETURN,</span><span class="s3">\n            </span><span class="s1">messageText: `The </span><span class="s3">\&quot;</span><span class="s1">use server</span><span class="s3">\&quot; </span><span class="s1">file can only export async functions.`,</span><span class="s3">\n            </span><span class="s1">start: declaration.getStart(),</span><span class="s3">\n            </span><span class="s1">length: declaration.getWidth(),</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return diagnostics</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">getSemanticDiagnosticsForFunctionExport(</span><span class="s3">\n    </span><span class="s1">source: tsModule.SourceFile,</span><span class="s3">\n    </span><span class="s1">node:</span><span class="s3">\n      </span><span class="s1">| tsModule.FunctionDeclaration</span><span class="s3">\n      </span><span class="s1">| tsModule.ArrowFunction</span><span class="s3">\n      </span><span class="s1">| tsModule.FunctionExpression</span><span class="s3">\n      </span><span class="s1">| tsModule.CallExpression</span><span class="s3">\n      </span><span class="s1">| tsModule.Identifier</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const ts = getTs()</span><span class="s3">\n    </span><span class="s1">const typeChecker = getTypeChecker()</span><span class="s3">\n    </span><span class="s1">if (!typeChecker) return []</span><span class="s3">\n\n    </span><span class="s1">const diagnostics: tsModule.Diagnostic[] = []</span><span class="s3">\n\n    </span><span class="s1">if (!isFunctionReturningPromise(node, typeChecker, ts)) {</span><span class="s3">\n      </span><span class="s1">diagnostics.push({</span><span class="s3">\n        </span><span class="s1">file: source,</span><span class="s3">\n        </span><span class="s1">category: ts.DiagnosticCategory.Error,</span><span class="s3">\n        </span><span class="s1">code: NEXT_TS_ERRORS.INVALID_SERVER_ENTRY_RETURN,</span><span class="s3">\n        </span><span class="s1">messageText: `The </span><span class="s3">\&quot;</span><span class="s1">use server</span><span class="s3">\&quot; </span><span class="s1">file can only export async functions. Add </span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot; </span><span class="s1">to the function declaration or return a Promise.`,</span><span class="s3">\n        </span><span class="s1">start: node.getStart(),</span><span class="s3">\n        </span><span class="s1">length: node.getWidth(),</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return diagnostics</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default serverBoundary</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;isPromiseType&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;typeChecker&quot;</span><span class="s0">,</span><span class="s1">&quot;typeReferenceType&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;typeToString&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunctionReturningPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;ts&quot;</span><span class="s0">,</span><span class="s1">&quot;getTypeAtLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;signatures&quot;</span><span class="s0">,</span><span class="s1">&quot;getSignaturesOfType&quot;</span><span class="s0">,</span><span class="s1">&quot;SignatureKind&quot;</span><span class="s0">,</span><span class="s1">&quot;Call&quot;</span><span class="s0">,</span><span class="s1">&quot;isPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;signature&quot;</span><span class="s0">,</span><span class="s1">&quot;returnType&quot;</span><span class="s0">,</span><span class="s1">&quot;getReturnType&quot;</span><span class="s0">,</span><span class="s1">&quot;isUnion&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;types&quot;</span><span class="s0">,</span><span class="s1">&quot;serverBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;getSemanticDiagnosticsForExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;getTs&quot;</span><span class="s0">,</span><span class="s1">&quot;getTypeChecker&quot;</span><span class="s0">,</span><span class="s1">&quot;diagnostics&quot;</span><span class="s0">,</span><span class="s1">&quot;exportClause&quot;</span><span class="s0">,</span><span class="s1">&quot;isTypeOnly&quot;</span><span class="s0">,</span><span class="s1">&quot;isNamedExports&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;elements&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;category&quot;</span><span class="s0">,</span><span class="s1">&quot;DiagnosticCategory&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_TS_ERRORS&quot;</span><span class="s0">,</span><span class="s1">&quot;INVALID_SERVER_ENTRY_RETURN&quot;</span><span class="s0">,</span><span class="s1">&quot;messageText&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;getStart&quot;</span><span class="s0">,</span><span class="s1">&quot;getWidth&quot;</span><span class="s0">,</span><span class="s1">&quot;getSemanticDiagnosticsForExportVariableStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isVariableDeclarationList&quot;</span><span class="s0">,</span><span class="s1">&quot;declarationList&quot;</span><span class="s0">,</span><span class="s1">&quot;declaration&quot;</span><span class="s0">,</span><span class="s1">&quot;declarations&quot;</span><span class="s0">,</span><span class="s1">&quot;initializer&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrowFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunctionDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;getSemanticDiagnosticsForFunctionExport&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>