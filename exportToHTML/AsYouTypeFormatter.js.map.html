<html>
<head>
<title>AsYouTypeFormatter.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
AsYouTypeFormatter.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;AsYouTypeFormatter.js&quot;</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_AsYouTypeFormatterUtil&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_AsYouTypeFormatterComplete&quot;</span><span class="s0">,</span><span class="s1">&quot;_interopRequireWildcard&quot;</span><span class="s0">,</span><span class="s1">&quot;_AsYouTypeFormatterPatternMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;_interopRequireDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;_parseDigits&quot;</span><span class="s0">,</span><span class="s1">&quot;_formatNationalNumberUsingFormat&quot;</span><span class="s0">,</span><span class="s1">&quot;_constants&quot;</span><span class="s0">,</span><span class="s1">&quot;_applyInternationalSeparatorStyle&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;__esModule&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakMap&quot;</span><span class="s0">,</span><span class="s1">&quot;r&quot;</span><span class="s0">,</span><span class="s1">&quot;n&quot;</span><span class="s0">,</span><span class="s1">&quot;o&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;f&quot;</span><span class="s0">,</span><span class="s1">&quot;__proto__&quot;</span><span class="s0">,</span><span class="s1">&quot;_typeof&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;getOwnPropertyDescriptor&quot;</span><span class="s0">,</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;iterator&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;_createForOfIteratorHelperLoose&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;_unsupportedIterableToArray&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;done&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeError&quot;</span><span class="s0">,</span><span class="s1">&quot;a&quot;</span><span class="s0">,</span><span class="s1">&quot;_arrayLikeToArray&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;_classCallCheck&quot;</span><span class="s0">,</span><span class="s1">&quot;_defineProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;enumerable&quot;</span><span class="s0">,</span><span class="s1">&quot;configurable&quot;</span><span class="s0">,</span><span class="s1">&quot;writable&quot;</span><span class="s0">,</span><span class="s1">&quot;_toPropertyKey&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;_createClass&quot;</span><span class="s0">,</span><span class="s1">&quot;_toPrimitive&quot;</span><span class="s0">,</span><span class="s1">&quot;toPrimitive&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;Number&quot;</span><span class="s0">,</span><span class="s1">&quot;DUMMY_DIGIT&quot;</span><span class="s0">,</span><span class="s1">&quot;LONGEST_NATIONAL_PHONE_NUMBER_LENGTH&quot;</span><span class="s0">,</span><span class="s1">&quot;LONGEST_DUMMY_PHONE_NUMBER&quot;</span><span class="s0">,</span><span class="s1">&quot;repeat&quot;</span><span class="s0">,</span><span class="s1">&quot;NATIONAL_PREFIX_SEPARATORS_PATTERN&quot;</span><span class="s0">,</span><span class="s1">&quot;SUPPORT_LEGACY_FORMATTING_PATTERNS&quot;</span><span class="s0">,</span><span class="s1">&quot;CREATE_CHARACTER_CLASS_PATTERN&quot;</span><span class="s0">,</span><span class="s1">&quot;CREATE_STANDALONE_DIGIT_PATTERN&quot;</span><span class="s0">,</span><span class="s1">&quot;NON_ALTERING_FORMAT_REG_EXP&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;VALID_PUNCTUATION&quot;</span><span class="s0">,</span><span class="s1">&quot;MIN_LEADING_DIGITS_LENGTH&quot;</span><span class="s0">,</span><span class="s1">&quot;AsYouTypeFormatter&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;_ref&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;metadata&quot;</span><span class="s0">,</span><span class="s1">&quot;resetFormat&quot;</span><span class="s0">,</span><span class="s1">&quot;chosenFormat&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalNumberTemplate&quot;</span><span class="s0">,</span><span class="s1">&quot;populatedNationalNumberTemplate&quot;</span><span class="s0">,</span><span class="s1">&quot;populatedNationalNumberTemplatePosition&quot;</span><span class="s0">,</span><span class="s1">&quot;reset&quot;</span><span class="s0">,</span><span class="s1">&quot;numberingPlan&quot;</span><span class="s0">,</span><span class="s1">&quot;isNANP&quot;</span><span class="s0">,</span><span class="s1">&quot;callingCode&quot;</span><span class="s0">,</span><span class="s1">&quot;matchingFormats&quot;</span><span class="s0">,</span><span class="s1">&quot;formats&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalSignificantNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;narrowDownMatchingFormats&quot;</span><span class="s0">,</span><span class="s1">&quot;format&quot;</span><span class="s0">,</span><span class="s1">&quot;nextDigits&quot;</span><span class="s0">,</span><span class="s1">&quot;_this&quot;</span><span class="s0">,</span><span class="s1">&quot;canFormatCompleteNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;country&quot;</span><span class="s0">,</span><span class="s1">&quot;_iterator&quot;</span><span class="s0">,</span><span class="s1">&quot;_step&quot;</span><span class="s0">,</span><span class="s1">&quot;formattedCompleteNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;formatCompleteNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldTryNationalPrefixFormattingRule&quot;</span><span class="s0">,</span><span class="s1">&quot;international&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;getSeparatorAfterNationalPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;setNationalNumberTemplate&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;DIGIT_PLACEHOLDER&quot;</span><span class="s0">,</span><span class="s1">&quot;lastIndexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;formatNationalNumberWithNextDigits&quot;</span><span class="s0">,</span><span class="s1">&quot;previouslyChosenFormat&quot;</span><span class="s0">,</span><span class="s1">&quot;newlyChosenFormat&quot;</span><span class="s0">,</span><span class="s1">&quot;chooseFormat&quot;</span><span class="s0">,</span><span class="s1">&quot;formatNextNationalNumberDigits&quot;</span><span class="s0">,</span><span class="s1">&quot;getNationalDigits&quot;</span><span class="s0">,</span><span class="s1">&quot;_ref2&quot;</span><span class="s0">,</span><span class="s1">&quot;_this2&quot;</span><span class="s0">,</span><span class="s1">&quot;leadingDigits&quot;</span><span class="s0">,</span><span class="s1">&quot;leadingDigitsPatternIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;formatSuits&quot;</span><span class="s0">,</span><span class="s1">&quot;formatMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;usesNationalPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalPrefixIsOptionalWhenFormattingInNationalFormat&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalPrefixIsMandatoryWhenFormattingInNationalFormat&quot;</span><span class="s0">,</span><span class="s1">&quot;leadingDigitsPatternsCount&quot;</span><span class="s0">,</span><span class="s1">&quot;leadingDigitsPatterns&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;min&quot;</span><span class="s0">,</span><span class="s1">&quot;leadingDigitsPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;PatternMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;allowOverflow&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;getFormatFormat&quot;</span><span class="s0">,</span><span class="s1">&quot;internationalFormat&quot;</span><span class="s0">,</span><span class="s1">&quot;_this3&quot;</span><span class="s0">,</span><span class="s1">&quot;_loop&quot;</span><span class="s0">,</span><span class="s1">&quot;_step2&quot;</span><span class="s0">,</span><span class="s1">&quot;createTemplateForFormat&quot;</span><span class="s0">,</span><span class="s1">&quot;_&quot;</span><span class="s0">,</span><span class="s1">&quot;_ret&quot;</span><span class="s0">,</span><span class="s1">&quot;_iterator2&quot;</span><span class="s0">,</span><span class="s1">&quot;pattern&quot;</span><span class="s0">,</span><span class="s1">&quot;getTemplateForFormat&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalPrefixFormattingRule&quot;</span><span class="s0">,</span><span class="s1">&quot;getInternationalPrefixBeforeCountryCallingCode&quot;</span><span class="s0">,</span><span class="s1">&quot;_ref3&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;IDDPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;missingPlus&quot;</span><span class="s0">,</span><span class="s1">&quot;spacing&quot;</span><span class="s0">,</span><span class="s1">&quot;getTemplate&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;internationalPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;getDigitsWithoutInternationalPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;cutAndStripNonPairedParens&quot;</span><span class="s0">,</span><span class="s1">&quot;_ref4&quot;</span><span class="s0">,</span><span class="s1">&quot;prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;digits&quot;</span><span class="s0">,</span><span class="s1">&quot;strictPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalNumberDummyDigits&quot;</span><span class="s0">,</span><span class="s1">&quot;numberFormat&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalPrefixIncludedInTemplate&quot;</span><span class="s0">,</span><span class="s1">&quot;numberFormatWithNationalPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;FIRST_GROUP_PATTERN&quot;</span><span class="s0">,</span><span class="s1">&quot;parseDigits&quot;</span><span class="s0">,</span><span class="s1">&quot;applyInternationalSeparatorStyle&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;populateTemplateWithDigits&quot;</span><span class="s0">,</span><span class="s1">&quot;_ref5&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../source/AsYouTypeFormatter.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import {</span><span class="s3">\r\n\t</span><span class="s1">DIGIT_PLACEHOLDER,</span><span class="s3">\r\n\t</span><span class="s1">countOccurences,</span><span class="s3">\r\n\t</span><span class="s1">repeat,</span><span class="s3">\r\n\t</span><span class="s1">cutAndStripNonPairedParens,</span><span class="s3">\r\n\t</span><span class="s1">closeNonPairedParens,</span><span class="s3">\r\n\t</span><span class="s1">stripNonPairedParens,</span><span class="s3">\r\n\t</span><span class="s1">populateTemplateWithDigits</span><span class="s3">\r\n</span><span class="s1">} from './AsYouTypeFormatter.util.js'</span><span class="s3">\r\n\r\n</span><span class="s1">import formatCompleteNumber, {</span><span class="s3">\r\n\t</span><span class="s1">canFormatCompleteNumber</span><span class="s3">\r\n</span><span class="s1">} from './AsYouTypeFormatter.complete.js'</span><span class="s3">\r\n\r\n</span><span class="s1">import PatternMatcher from './AsYouTypeFormatter.PatternMatcher.js'</span><span class="s3">\r\n\r\n</span><span class="s1">import parseDigits from './helpers/parseDigits.js'</span><span class="s3">\r\n</span><span class="s1">export { DIGIT_PLACEHOLDER } from './AsYouTypeFormatter.util.js'</span><span class="s3">\r\n</span><span class="s1">import { FIRST_GROUP_PATTERN } from './helpers/formatNationalNumberUsingFormat.js'</span><span class="s3">\r\n</span><span class="s1">import { VALID_PUNCTUATION } from './constants.js'</span><span class="s3">\r\n</span><span class="s1">import applyInternationalSeparatorStyle from './helpers/applyInternationalSeparatorStyle.js'</span><span class="s3">\r\n\r\n</span><span class="s1">// Used in phone number format template creation.</span><span class="s3">\r\n</span><span class="s1">// Could be any digit, I guess.</span><span class="s3">\r\n</span><span class="s1">const DUMMY_DIGIT = '9'</span><span class="s3">\r\n</span><span class="s1">// I don't know why is it exactly `15`</span><span class="s3">\r\n</span><span class="s1">const LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15</span><span class="s3">\r\n</span><span class="s1">// Create a phone number consisting only of the digit 9 that matches the</span><span class="s3">\r\n</span><span class="s1">// `number_pattern` by applying the pattern to the </span><span class="s3">\&quot;</span><span class="s1">longest phone number</span><span class="s3">\&quot; </span><span class="s1">string.</span><span class="s3">\r\n</span><span class="s1">const LONGEST_DUMMY_PHONE_NUMBER = repeat(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH)</span><span class="s3">\r\n\r\n</span><span class="s1">// A set of characters that, if found in a national prefix formatting rules, are an indicator to</span><span class="s3">\r\n</span><span class="s1">// us that we should separate the national prefix from the number when formatting.</span><span class="s3">\r\n</span><span class="s1">const NATIONAL_PREFIX_SEPARATORS_PATTERN = /[- ]/</span><span class="s3">\r\n\r\n</span><span class="s1">// Deprecated: Google has removed some formatting pattern related code from their repo.</span><span class="s3">\r\n</span><span class="s1">// https://github.com/googlei18n/libphonenumber/commit/a395b4fef3caf57c4bc5f082e1152a4d2bd0ba4c</span><span class="s3">\r\n</span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">We no longer have numbers in formatting matching patterns, only </span><span class="s3">\\</span><span class="s1">d.</span><span class="s3">\&quot;\r\n</span><span class="s1">// Because this library supports generating custom metadata</span><span class="s3">\r\n</span><span class="s1">// some users may still be using old metadata so the relevant</span><span class="s3">\r\n</span><span class="s1">// code seems to stay until some next major version update.</span><span class="s3">\r\n</span><span class="s1">const SUPPORT_LEGACY_FORMATTING_PATTERNS = true</span><span class="s3">\r\n\r\n</span><span class="s1">// A pattern that is used to match character classes in regular expressions.</span><span class="s3">\r\n</span><span class="s1">// An example of a character class is </span><span class="s3">\&quot;</span><span class="s1">[1-4]</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\r\n</span><span class="s1">const CREATE_CHARACTER_CLASS_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS &amp;&amp; (() =&gt; /</span><span class="s3">\\</span><span class="s1">[([^</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">]])*</span><span class="s3">\\</span><span class="s1">]/g)</span><span class="s3">\r\n\r\n</span><span class="s1">// Any digit in a regular expression that actually denotes a digit. For</span><span class="s3">\r\n</span><span class="s1">// example, in the regular expression </span><span class="s3">\&quot;</span><span class="s1">80[0-2]</span><span class="s3">\\</span><span class="s1">d{6,10}</span><span class="s3">\&quot;</span><span class="s1">, the first 2 digits</span><span class="s3">\r\n</span><span class="s1">// (8 and 0) are standalone digits, but the rest are not.</span><span class="s3">\r\n</span><span class="s1">// Two look-aheads are needed because the number following </span><span class="s3">\\\\</span><span class="s1">d could be a</span><span class="s3">\r\n</span><span class="s1">// two-digit number, since the phone number can be as long as 15 digits.</span><span class="s3">\r\n</span><span class="s1">const CREATE_STANDALONE_DIGIT_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS &amp;&amp; (() =&gt; /</span><span class="s3">\\</span><span class="s1">d(?=[^,}][^,}])/g)</span><span class="s3">\r\n\r\n</span><span class="s1">// A regular expression that is used to determine if a `format` is</span><span class="s3">\r\n</span><span class="s1">// suitable to be used in the </span><span class="s3">\&quot;</span><span class="s1">as you type formatter</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\r\n</span><span class="s1">// A `format` is suitable when the resulting formatted number has</span><span class="s3">\r\n</span><span class="s1">// the same digits as the user has entered.</span><span class="s3">\r\n</span><span class="s1">//</span><span class="s3">\r\n</span><span class="s1">// In the simplest case, that would mean that the format</span><span class="s3">\r\n</span><span class="s1">// doesn't add any additional digits when formatting a number.</span><span class="s3">\r\n</span><span class="s1">// Google says that it also shouldn't add </span><span class="s3">\&quot;</span><span class="s1">star</span><span class="s3">\&quot; </span><span class="s1">(`*`) characters,</span><span class="s3">\r\n</span><span class="s1">// like it does in some Israeli formats.</span><span class="s3">\r\n</span><span class="s1">// Such basic format would only contain </span><span class="s3">\&quot;</span><span class="s1">valid punctuation</span><span class="s3">\&quot;\r\n</span><span class="s1">// and </span><span class="s3">\&quot;</span><span class="s1">captured group</span><span class="s3">\&quot; </span><span class="s1">identifiers ($1, $2, etc).</span><span class="s3">\r\n</span><span class="s1">//</span><span class="s3">\r\n</span><span class="s1">// An example of a format that adds additional digits:</span><span class="s3">\r\n</span><span class="s1">//</span><span class="s3">\r\n</span><span class="s1">// Country: `AR` (Argentina).</span><span class="s3">\r\n</span><span class="s1">// Format:</span><span class="s3">\r\n</span><span class="s1">// {</span><span class="s3">\r\n</span><span class="s1">//    </span><span class="s3">\&quot;</span><span class="s1">pattern</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\\\\</span><span class="s1">d)(</span><span class="s3">\\\\</span><span class="s1">d{2})(</span><span class="s3">\\\\</span><span class="s1">d{4})(</span><span class="s3">\\\\</span><span class="s1">d{4})</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\r\n</span><span class="s1">//    </span><span class="s3">\&quot;</span><span class="s1">leading_digits_patterns</span><span class="s3">\&quot;</span><span class="s1">: [</span><span class="s3">\&quot;</span><span class="s1">91</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\r\n</span><span class="s1">//    </span><span class="s3">\&quot;</span><span class="s1">national_prefix_formatting_rule</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">0$1</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\r\n</span><span class="s1">//    </span><span class="s3">\&quot;</span><span class="s1">format</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">$2 15-$3-$4</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\r\n</span><span class="s1">//    </span><span class="s3">\&quot;</span><span class="s1">international_format</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">$1 $2 $3-$4</span><span class="s3">\&quot;\r\n</span><span class="s1">// }</span><span class="s3">\r\n</span><span class="s1">//</span><span class="s3">\r\n</span><span class="s1">// In the format above, the `format` adds `15` to the digits when formatting a number.</span><span class="s3">\r\n</span><span class="s1">// A sidenote: this format actually is suitable because `national_prefix_for_parsing`</span><span class="s3">\r\n</span><span class="s1">// has previously removed `15` from a national number, so re-adding `15` in `format`</span><span class="s3">\r\n</span><span class="s1">// doesn't actually result in any extra digits added to user's input.</span><span class="s3">\r\n</span><span class="s1">// But verifying that would be a complex procedure, so the code chooses a simpler path:</span><span class="s3">\r\n</span><span class="s1">// it simply filters out all `format`s that contain anything but </span><span class="s3">\&quot;</span><span class="s1">captured group</span><span class="s3">\&quot; </span><span class="s1">ids.</span><span class="s3">\r\n</span><span class="s1">//</span><span class="s3">\r\n</span><span class="s1">// This regular expression is called `ELIGIBLE_FORMAT_PATTERN` in Google's</span><span class="s3">\r\n</span><span class="s1">// `libphonenumber` code.</span><span class="s3">\r\n</span><span class="s1">//</span><span class="s3">\r\n</span><span class="s1">const NON_ALTERING_FORMAT_REG_EXP = new RegExp(</span><span class="s3">\r\n\t</span><span class="s1">'[' + VALID_PUNCTUATION + ']*' +</span><span class="s3">\r\n\t</span><span class="s1">// Google developers say:</span><span class="s3">\r\n\t</span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">We require that the first matching group is present in the</span><span class="s3">\r\n\t</span><span class="s1">//  output pattern to ensure no data is lost while formatting.</span><span class="s3">\&quot;\r\n\t</span><span class="s1">'</span><span class="s3">\\\\</span><span class="s1">$1' +</span><span class="s3">\r\n\t</span><span class="s1">'[' + VALID_PUNCTUATION + ']*' +</span><span class="s3">\r\n\t</span><span class="s1">'(</span><span class="s3">\\\\</span><span class="s1">$</span><span class="s3">\\\\</span><span class="s1">d[' + VALID_PUNCTUATION + ']*)*' +</span><span class="s3">\r\n\t</span><span class="s1">'$'</span><span class="s3">\r\n</span><span class="s1">)</span><span class="s3">\r\n\r\n</span><span class="s1">// This is the minimum length of the leading digits of a phone number</span><span class="s3">\r\n</span><span class="s1">// to guarantee the first </span><span class="s3">\&quot;</span><span class="s1">leading digits pattern</span><span class="s3">\&quot; </span><span class="s1">for a phone number format</span><span class="s3">\r\n</span><span class="s1">// to be preemptive.</span><span class="s3">\r\n</span><span class="s1">const MIN_LEADING_DIGITS_LENGTH = 3</span><span class="s3">\r\n\r\n</span><span class="s1">export default class AsYouTypeFormatter {</span><span class="s3">\r\n\t</span><span class="s1">constructor({</span><span class="s3">\r\n\t\t</span><span class="s1">state,</span><span class="s3">\r\n\t\t</span><span class="s1">metadata</span><span class="s3">\r\n\t</span><span class="s1">}) {</span><span class="s3">\r\n\t\t</span><span class="s1">this.metadata = metadata</span><span class="s3">\r\n\t\t</span><span class="s1">this.resetFormat()</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">resetFormat() {</span><span class="s3">\r\n\t\t</span><span class="s1">this.chosenFormat = undefined</span><span class="s3">\r\n\t\t</span><span class="s1">this.template = undefined</span><span class="s3">\r\n\t\t</span><span class="s1">this.nationalNumberTemplate = undefined</span><span class="s3">\r\n\t\t</span><span class="s1">this.populatedNationalNumberTemplate = undefined</span><span class="s3">\r\n\t\t</span><span class="s1">this.populatedNationalNumberTemplatePosition = -1</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">reset(numberingPlan, state) {</span><span class="s3">\r\n\t\t</span><span class="s1">this.resetFormat()</span><span class="s3">\r\n\t\t</span><span class="s1">if (numberingPlan) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.isNANP = numberingPlan.callingCode() === '1'</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.matchingFormats = numberingPlan.formats()</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (state.nationalSignificantNumber) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">this.narrowDownMatchingFormats(state)</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">} else {</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.isNANP = undefined</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.matchingFormats = []</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">/**</span><span class="s3">\r\n\t </span><span class="s1">* Formats an updated phone number.</span><span class="s3">\r\n\t </span><span class="s1">* @param  {string} nextDigits — Additional phone number digits.</span><span class="s3">\r\n\t </span><span class="s1">* @param  {object} state — `AsYouType` state.</span><span class="s3">\r\n\t </span><span class="s1">* @return {[string]} Returns undefined if the updated phone number can't be formatted using any of the available formats.</span><span class="s3">\r\n\t </span><span class="s1">*/</span><span class="s3">\r\n\t</span><span class="s1">format(nextDigits, state) {</span><span class="s3">\r\n\t\t</span><span class="s1">// See if the phone number digits can be formatted as a complete phone number.</span><span class="s3">\r\n\t\t</span><span class="s1">// If not, use the results from `formatNationalNumberWithNextDigits()`,</span><span class="s3">\r\n\t\t</span><span class="s1">// which formats based on the chosen formatting pattern.</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">// Attempting to format complete phone number first is how it's done</span><span class="s3">\r\n\t\t</span><span class="s1">// in Google's `libphonenumber`, so this library just follows it.</span><span class="s3">\r\n\t\t</span><span class="s1">// Google's `libphonenumber` code doesn't explain in detail why does it</span><span class="s3">\r\n\t\t</span><span class="s1">// attempt to format digits as a complete phone number</span><span class="s3">\r\n\t\t</span><span class="s1">// instead of just going with a previoulsy (or newly) chosen `format`:</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">Checks to see if there is an exact pattern match for these digits.</span><span class="s3">\r\n\t\t</span><span class="s1">//  If so, we should use this instead of any other formatting template</span><span class="s3">\r\n\t\t</span><span class="s1">//  whose leadingDigitsPattern also matches the input.</span><span class="s3">\&quot;\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">if (canFormatCompleteNumber(state.nationalSignificantNumber, state.country, this.metadata)) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">for (const format of this.matchingFormats) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">const formattedCompleteNumber = formatCompleteNumber(</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">state,</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">format,</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">{</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">metadata: this.metadata,</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">shouldTryNationalPrefixFormattingRule: (format) =&gt; this.shouldTryNationalPrefixFormattingRule(format, {</span><span class="s3">\r\n\t\t\t\t\t\t\t</span><span class="s1">international: state.international,</span><span class="s3">\r\n\t\t\t\t\t\t\t</span><span class="s1">nationalPrefix: state.nationalPrefix</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">}),</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">getSeparatorAfterNationalPrefix: (format) =&gt; this.getSeparatorAfterNationalPrefix(format)</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">)</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">if (formattedCompleteNumber) {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">this.resetFormat()</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">this.chosenFormat = format</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">this.setNationalNumberTemplate(formattedCompleteNumber.replace(/</span><span class="s3">\\</span><span class="s1">d/g, DIGIT_PLACEHOLDER), state)</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">this.populatedNationalNumberTemplate = formattedCompleteNumber</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">// With a new formatting template, the matched position</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">// using the old template needs to be reset.</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">this.populatedNationalNumberTemplatePosition = this.template.lastIndexOf(DIGIT_PLACEHOLDER)</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">return formattedCompleteNumber</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">// Format the digits as a partial (incomplete) phone number</span><span class="s3">\r\n\t\t</span><span class="s1">// using the previously chosen formatting pattern (or a newly chosen one).</span><span class="s3">\r\n\t\t</span><span class="s1">return this.formatNationalNumberWithNextDigits(nextDigits, state)</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">// Formats the next phone number digits.</span><span class="s3">\r\n\t</span><span class="s1">formatNationalNumberWithNextDigits(nextDigits, state) {</span><span class="s3">\r\n\t\t</span><span class="s1">const previouslyChosenFormat = this.chosenFormat</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// Choose a format from the list of matching ones.</span><span class="s3">\r\n\t\t</span><span class="s1">const newlyChosenFormat = this.chooseFormat(state)</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">if (newlyChosenFormat) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (newlyChosenFormat === previouslyChosenFormat) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// If it can format the next (current) digits</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// using the previously chosen phone number format</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// then return the updated formatted number.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">return this.formatNextNationalNumberDigits(nextDigits)</span><span class="s3">\r\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// If a more appropriate phone number format</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// has been chosen for these </span><span class="s3">\&quot;</span><span class="s1">leading digits</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// then re-format the national phone number part</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// using the newly selected format.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">return this.formatNextNationalNumberDigits(state.getNationalDigits())</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">narrowDownMatchingFormats({</span><span class="s3">\r\n\t\t</span><span class="s1">nationalSignificantNumber,</span><span class="s3">\r\n\t\t</span><span class="s1">nationalPrefix,</span><span class="s3">\r\n\t\t</span><span class="s1">international</span><span class="s3">\r\n\t</span><span class="s1">}) {</span><span class="s3">\r\n\t\t</span><span class="s1">const leadingDigits = nationalSignificantNumber</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">leading digits</span><span class="s3">\&quot; </span><span class="s1">pattern list starts with a</span><span class="s3">\r\n\t\t</span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">leading digits</span><span class="s3">\&quot; </span><span class="s1">pattern fitting a maximum of 3 leading digits.</span><span class="s3">\r\n\t\t</span><span class="s1">// So, after a user inputs 3 digits of a national (significant) phone number</span><span class="s3">\r\n\t\t</span><span class="s1">// this national (significant) number can already be formatted.</span><span class="s3">\r\n\t\t</span><span class="s1">// The next </span><span class="s3">\&quot;</span><span class="s1">leading digits</span><span class="s3">\&quot; </span><span class="s1">pattern is for 4 leading digits max,</span><span class="s3">\r\n\t\t</span><span class="s1">// and the </span><span class="s3">\&quot;</span><span class="s1">leading digits</span><span class="s3">\&quot; </span><span class="s1">pattern after it is for 5 leading digits max, etc.</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// This implementation is different from Google's</span><span class="s3">\r\n\t\t</span><span class="s1">// in that it searches for a fitting format</span><span class="s3">\r\n\t\t</span><span class="s1">// even if the user has entered less than</span><span class="s3">\r\n\t\t</span><span class="s1">// `MIN_LEADING_DIGITS_LENGTH` digits of a national number.</span><span class="s3">\r\n\t\t</span><span class="s1">// Because some leading digit patterns already match for a single first digit.</span><span class="s3">\r\n\t\t</span><span class="s1">let leadingDigitsPatternIndex = leadingDigits.length - MIN_LEADING_DIGITS_LENGTH</span><span class="s3">\r\n\t\t</span><span class="s1">if (leadingDigitsPatternIndex &lt; 0) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">leadingDigitsPatternIndex = 0</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">this.matchingFormats = this.matchingFormats.filter(</span><span class="s3">\r\n\t\t\t</span><span class="s1">format =&gt; this.formatSuits(format, international, nationalPrefix)</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">&amp;&amp; this.formatMatches(format, leadingDigits, leadingDigitsPatternIndex)</span><span class="s3">\r\n\t\t</span><span class="s1">)</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// If there was a phone number format chosen</span><span class="s3">\r\n\t\t</span><span class="s1">// and it no longer holds given the new leading digits then reset it.</span><span class="s3">\r\n\t\t</span><span class="s1">// The test for this `if` condition is marked as:</span><span class="s3">\r\n\t\t</span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">Reset a chosen format when it no longer holds given the new leading digits</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\r\n\t\t</span><span class="s1">// To construct a valid test case for this one can find a country</span><span class="s3">\r\n\t\t</span><span class="s1">// in `PhoneNumberMetadata.xml` yielding one format for 3 `&lt;leadingDigits&gt;`</span><span class="s3">\r\n\t\t</span><span class="s1">// and yielding another format for 4 `&lt;leadingDigits&gt;` (Australia in this case).</span><span class="s3">\r\n\t\t</span><span class="s1">if (this.chosenFormat &amp;&amp; this.matchingFormats.indexOf(this.chosenFormat) === -1) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.resetFormat()</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">formatSuits(format, international, nationalPrefix) {</span><span class="s3">\r\n\t\t</span><span class="s1">// When a prefix before a national (significant) number is</span><span class="s3">\r\n\t\t</span><span class="s1">// simply a national prefix, then it's parsed as `this.nationalPrefix`.</span><span class="s3">\r\n\t\t</span><span class="s1">// In more complex cases, a prefix before national (significant) number</span><span class="s3">\r\n\t\t</span><span class="s1">// could include a national prefix as well as some </span><span class="s3">\&quot;</span><span class="s1">capturing groups</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\r\n\t\t</span><span class="s1">// and in that case there's no info whether a national prefix has been parsed.</span><span class="s3">\r\n\t\t</span><span class="s1">// If national prefix is not used when formatting a phone number</span><span class="s3">\r\n\t\t</span><span class="s1">// using this format, but a national prefix has been entered by the user,</span><span class="s3">\r\n\t\t</span><span class="s1">// and was extracted, then discard such phone number format.</span><span class="s3">\r\n\t\t</span><span class="s1">// In Google's </span><span class="s3">\&quot;</span><span class="s1">AsYouType</span><span class="s3">\&quot; </span><span class="s1">formatter code, the equivalent would be this part:</span><span class="s3">\r\n\t\t</span><span class="s1">// https://github.com/google/libphonenumber/blob/0a45cfd96e71cad8edb0e162a70fcc8bd9728933/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L175-L184</span><span class="s3">\r\n\t\t</span><span class="s1">if (nationalPrefix &amp;&amp;</span><span class="s3">\r\n\t\t\t</span><span class="s1">!format.usesNationalPrefix() &amp;&amp;</span><span class="s3">\r\n\t\t\t</span><span class="s1">// !format.domesticCarrierCodeFormattingRule() &amp;&amp;</span><span class="s3">\r\n\t\t\t</span><span class="s1">!format.nationalPrefixIsOptionalWhenFormattingInNationalFormat()) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">return false</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">// If national prefix is mandatory for this phone number format</span><span class="s3">\r\n\t\t</span><span class="s1">// and there're no guarantees that a national prefix is present in user input</span><span class="s3">\r\n\t\t</span><span class="s1">// then discard this phone number format as not suitable.</span><span class="s3">\r\n\t\t</span><span class="s1">// In Google's </span><span class="s3">\&quot;</span><span class="s1">AsYouType</span><span class="s3">\&quot; </span><span class="s1">formatter code, the equivalent would be this part:</span><span class="s3">\r\n\t\t</span><span class="s1">// https://github.com/google/libphonenumber/blob/0a45cfd96e71cad8edb0e162a70fcc8bd9728933/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L185-L193</span><span class="s3">\r\n\t\t</span><span class="s1">if (!international &amp;&amp;</span><span class="s3">\r\n\t\t\t</span><span class="s1">!nationalPrefix &amp;&amp;</span><span class="s3">\r\n\t\t\t</span><span class="s1">format.nationalPrefixIsMandatoryWhenFormattingInNationalFormat()) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">return false</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">return true</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">formatMatches(format, leadingDigits, leadingDigitsPatternIndex) {</span><span class="s3">\r\n\t\t</span><span class="s1">const leadingDigitsPatternsCount = format.leadingDigitsPatterns().length</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// If this format is not restricted to a certain</span><span class="s3">\r\n\t\t</span><span class="s1">// leading digits pattern then it fits.</span><span class="s3">\r\n\t\t</span><span class="s1">// The test case could be found by searching for </span><span class="s3">\&quot;</span><span class="s1">leadingDigitsPatternsCount === 0</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\r\n\t\t</span><span class="s1">if (leadingDigitsPatternsCount === 0) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">return true</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// Start narrowing down the list of possible formats based on the leading digits.</span><span class="s3">\r\n\t\t</span><span class="s1">// (only previously matched formats take part in the narrowing down process)</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// `leading_digits_patterns` start with 3 digits min</span><span class="s3">\r\n\t\t</span><span class="s1">// and then go up from there one digit at a time.</span><span class="s3">\r\n\t\t</span><span class="s1">leadingDigitsPatternIndex = Math.min(leadingDigitsPatternIndex, leadingDigitsPatternsCount - 1)</span><span class="s3">\r\n\t\t</span><span class="s1">const leadingDigitsPattern = format.leadingDigitsPatterns()[leadingDigitsPatternIndex]</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// Google imposes a requirement on the leading digits</span><span class="s3">\r\n\t\t</span><span class="s1">// to be minimum 3 digits long in order to be eligible</span><span class="s3">\r\n\t\t</span><span class="s1">// for checking those with a leading digits pattern.</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">// Since `leading_digits_patterns` start with 3 digits min,</span><span class="s3">\r\n\t\t</span><span class="s1">// Google's original `libphonenumber` library only starts</span><span class="s3">\r\n\t\t</span><span class="s1">// excluding any non-matching formats only when the</span><span class="s3">\r\n\t\t</span><span class="s1">// national number entered so far is at least 3 digits long,</span><span class="s3">\r\n\t\t</span><span class="s1">// otherwise format matching would give false negatives.</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">// For example, when the digits entered so far are `2`</span><span class="s3">\r\n\t\t</span><span class="s1">// and the leading digits pattern is `21` –</span><span class="s3">\r\n\t\t</span><span class="s1">// it's quite obvious in this case that the format could be the one</span><span class="s3">\r\n\t\t</span><span class="s1">// but due to the absence of further digits it would give false negative.</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">// Also, `leading_digits_patterns` doesn't always correspond to a single</span><span class="s3">\r\n\t\t</span><span class="s1">// digits count. For example, `60|8` pattern would already match `8`</span><span class="s3">\r\n\t\t</span><span class="s1">// but the `60` part would require having at least two leading digits,</span><span class="s3">\r\n\t\t</span><span class="s1">// so the whole pattern would require inputting two digits first in order to</span><span class="s3">\r\n\t\t</span><span class="s1">// decide on whether it matches the input, even when the input is </span><span class="s3">\&quot;</span><span class="s1">80</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">// This library — `libphonenumber-js` — allows filtering by `leading_digits_patterns`</span><span class="s3">\r\n\t\t</span><span class="s1">// even when there's only 1 or 2 digits of the national (significant) number.</span><span class="s3">\r\n\t\t</span><span class="s1">// To do that, it uses a non-strict pattern matcher written specifically for that.</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">if (leadingDigits.length &lt; MIN_LEADING_DIGITS_LENGTH) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">// Before leading digits &lt; 3 matching was implemented:</span><span class="s3">\r\n\t\t\t</span><span class="s1">// return true</span><span class="s3">\r\n\t\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t\t</span><span class="s1">// After leading digits &lt; 3 matching was implemented:</span><span class="s3">\r\n\t\t\t</span><span class="s1">try {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">return new PatternMatcher(leadingDigitsPattern).match(leadingDigits, { allowOverflow: true }) !== undefined</span><span class="s3">\r\n\t\t\t</span><span class="s1">} catch (error) /* istanbul ignore next */ {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// There's a slight possibility that there could be some undiscovered bug</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// in the pattern matcher code. Since the </span><span class="s3">\&quot;</span><span class="s1">leading digits &lt; 3 matching</span><span class="s3">\&quot;\r\n\t\t\t\t</span><span class="s1">// feature is not </span><span class="s3">\&quot;</span><span class="s1">essential</span><span class="s3">\&quot; </span><span class="s1">for operation, it can fall back to the old way</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// in case of any issues rather than halting the application's execution.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">console.error(error)</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">return true</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// If at least `MIN_LEADING_DIGITS_LENGTH` digits of a national number are</span><span class="s3">\r\n\t\t</span><span class="s1">// available then use the usual regular expression matching.</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">// The whole pattern is wrapped in round brackets (`()`) because</span><span class="s3">\r\n\t\t</span><span class="s1">// the pattern can use </span><span class="s3">\&quot;</span><span class="s1">or</span><span class="s3">\&quot; </span><span class="s1">operator (`|`) at the top level of the pattern.</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">return new RegExp(`^(${leadingDigitsPattern})`).test(leadingDigits)</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">getFormatFormat(format, international) {</span><span class="s3">\r\n\t\t</span><span class="s1">return international ? format.internationalFormat() : format.format()</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">chooseFormat(state) {</span><span class="s3">\r\n\t\t</span><span class="s1">// When there are multiple available formats, the formatter uses the first</span><span class="s3">\r\n\t\t</span><span class="s1">// format where a formatting template could be created.</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">// For some weird reason, `istanbul` says </span><span class="s3">\&quot;</span><span class="s1">else path not taken</span><span class="s3">\&quot;\r\n\t\t</span><span class="s1">// for the `for of` line below. Supposedly that means that</span><span class="s3">\r\n\t\t</span><span class="s1">// the loop doesn't ever go over the last element in the list.</span><span class="s3">\r\n\t\t</span><span class="s1">// That's true because there always is `this.chosenFormat`</span><span class="s3">\r\n\t\t</span><span class="s1">// when `this.matchingFormats` is non-empty.</span><span class="s3">\r\n\t\t</span><span class="s1">// And, for some weird reason, it doesn't think that the case</span><span class="s3">\r\n\t\t</span><span class="s1">// with empty `this.matchingFormats` qualifies for a valid </span><span class="s3">\&quot;</span><span class="s1">else</span><span class="s3">\&quot; </span><span class="s1">path.</span><span class="s3">\r\n\t\t</span><span class="s1">// So simply muting this `istanbul` warning.</span><span class="s3">\r\n\t\t</span><span class="s1">// It doesn't skip the contents of the `for of` loop,</span><span class="s3">\r\n\t\t</span><span class="s1">// it just skips the `for of` line.</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">/* istanbul ignore next */</span><span class="s3">\r\n\t\t</span><span class="s1">for (const format of this.matchingFormats.slice()) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">// If this format is currently being used</span><span class="s3">\r\n\t\t\t</span><span class="s1">// and is still suitable, then stick to it.</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (this.chosenFormat === format) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">break</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">// Sometimes, a formatting rule inserts additional digits in a phone number,</span><span class="s3">\r\n\t\t\t</span><span class="s1">// and </span><span class="s3">\&quot;</span><span class="s1">as you type</span><span class="s3">\&quot; </span><span class="s1">formatter can't do that: it should only use the digits</span><span class="s3">\r\n\t\t\t</span><span class="s1">// that the user has input.</span><span class="s3">\r\n\t\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t\t</span><span class="s1">// For example, in Argentina, there's a format for mobile phone numbers:</span><span class="s3">\r\n\t\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t\t</span><span class="s1">// {</span><span class="s3">\r\n\t\t\t</span><span class="s1">//    </span><span class="s3">\&quot;</span><span class="s1">pattern</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\\\\</span><span class="s1">d)(</span><span class="s3">\\\\</span><span class="s1">d{2})(</span><span class="s3">\\\\</span><span class="s1">d{4})(</span><span class="s3">\\\\</span><span class="s1">d{4})</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\r\n\t\t\t</span><span class="s1">//    </span><span class="s3">\&quot;</span><span class="s1">leading_digits_patterns</span><span class="s3">\&quot;</span><span class="s1">: [</span><span class="s3">\&quot;</span><span class="s1">91</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\r\n\t\t\t</span><span class="s1">//    </span><span class="s3">\&quot;</span><span class="s1">national_prefix_formatting_rule</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">0$1</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\r\n\t\t\t</span><span class="s1">//    </span><span class="s3">\&quot;</span><span class="s1">format</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">$2 15-$3-$4</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\r\n\t\t\t</span><span class="s1">//    </span><span class="s3">\&quot;</span><span class="s1">international_format</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">$1 $2 $3-$4</span><span class="s3">\&quot;\r\n\t\t\t</span><span class="s1">// }</span><span class="s3">\r\n\t\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t\t</span><span class="s1">// In that format, `international_format` is used instead of `format`</span><span class="s3">\r\n\t\t\t</span><span class="s1">// because `format` inserts `15` in the formatted number,</span><span class="s3">\r\n\t\t\t</span><span class="s1">// and `AsYouType` formatter should only use the digits</span><span class="s3">\r\n\t\t\t</span><span class="s1">// the user has actually input, without adding any extra digits.</span><span class="s3">\r\n\t\t\t</span><span class="s1">// In this case, it wouldn't make a difference, because the `15`</span><span class="s3">\r\n\t\t\t</span><span class="s1">// is first stripped when applying `national_prefix_for_parsing`</span><span class="s3">\r\n\t\t\t</span><span class="s1">// and then re-added when using `format`, so in reality it doesn't</span><span class="s3">\r\n\t\t\t</span><span class="s1">// add any new digits to the number, but to detect that, the code</span><span class="s3">\r\n\t\t\t</span><span class="s1">// would have to be more complex: it would have to try formatting</span><span class="s3">\r\n\t\t\t</span><span class="s1">// the digits using the format and then see if any digits have</span><span class="s3">\r\n\t\t\t</span><span class="s1">// actually been added or removed, and then, every time a new digit</span><span class="s3">\r\n\t\t\t</span><span class="s1">// is input, it should re-check whether the chosen format doesn't</span><span class="s3">\r\n\t\t\t</span><span class="s1">// alter the digits.</span><span class="s3">\r\n\t\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t\t</span><span class="s1">// Google's code doesn't go that far, and so does this library:</span><span class="s3">\r\n\t\t\t</span><span class="s1">// it simply requires that a `format` doesn't add any additonal</span><span class="s3">\r\n\t\t\t</span><span class="s1">// digits to user's input.</span><span class="s3">\r\n\t\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t\t</span><span class="s1">// Also, people in general should move from inputting phone numbers</span><span class="s3">\r\n\t\t\t</span><span class="s1">// in national format (possibly with national prefixes)</span><span class="s3">\r\n\t\t\t</span><span class="s1">// and use international phone number format instead:</span><span class="s3">\r\n\t\t\t</span><span class="s1">// it's a logical thing in the modern age of mobile phones,</span><span class="s3">\r\n\t\t\t</span><span class="s1">// globalization and the internet.</span><span class="s3">\r\n\t\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t\t</span><span class="s1">/* istanbul ignore if */</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (!NON_ALTERING_FORMAT_REG_EXP.test(this.getFormatFormat(format, state.international))) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">continue</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (!this.createTemplateForFormat(format, state)) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// Remove the format if it can't generate a template.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">this.matchingFormats = this.matchingFormats.filter(_ =&gt; _ !== format)</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">continue</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.chosenFormat = format</span><span class="s3">\r\n\t\t\t</span><span class="s1">break</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">if (!this.chosenFormat) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">// No format matches the national (significant) phone number.</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.resetFormat()</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">return this.chosenFormat</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">createTemplateForFormat(format, state) {</span><span class="s3">\r\n\t\t</span><span class="s1">// The formatter doesn't format numbers when numberPattern contains '|', e.g.</span><span class="s3">\r\n\t\t</span><span class="s1">// (20|3)</span><span class="s3">\\</span><span class="s1">d{4}. In those cases we quickly return.</span><span class="s3">\r\n\t\t</span><span class="s1">// (Though there's no such format in current metadata)</span><span class="s3">\r\n\t\t</span><span class="s1">/* istanbul ignore if */</span><span class="s3">\r\n\t\t</span><span class="s1">if (SUPPORT_LEGACY_FORMATTING_PATTERNS &amp;&amp; format.pattern().indexOf('|') &gt;= 0) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">return</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">// Get formatting template for this phone number format</span><span class="s3">\r\n\t\t</span><span class="s1">const template = this.getTemplateForFormat(format, state)</span><span class="s3">\r\n\t\t</span><span class="s1">// If the national number entered is too long</span><span class="s3">\r\n\t\t</span><span class="s1">// for any phone number format, then abort.</span><span class="s3">\r\n\t\t</span><span class="s1">if (template) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.setNationalNumberTemplate(template, state)</span><span class="s3">\r\n\t\t\t</span><span class="s1">return true</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">getSeparatorAfterNationalPrefix(format) {</span><span class="s3">\r\n\t\t</span><span class="s1">// `US` metadata doesn't have a `national_prefix_formatting_rule`,</span><span class="s3">\r\n\t\t</span><span class="s1">// so the `if` condition below doesn't apply to `US`,</span><span class="s3">\r\n\t\t</span><span class="s1">// but in reality there shoudl be a separator</span><span class="s3">\r\n\t\t</span><span class="s1">// between a national prefix and a national (significant) number.</span><span class="s3">\r\n\t\t</span><span class="s1">// So `US` national prefix separator is a </span><span class="s3">\&quot;</span><span class="s1">special</span><span class="s3">\&quot; \&quot;</span><span class="s1">hardcoded</span><span class="s3">\&quot; </span><span class="s1">case.</span><span class="s3">\r\n\t\t</span><span class="s1">if (this.isNANP) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">return ' '</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">// If a `format` has a `national_prefix_formatting_rule`</span><span class="s3">\r\n\t\t</span><span class="s1">// and that rule has a separator after a national prefix,</span><span class="s3">\r\n\t\t</span><span class="s1">// then it means that there should be a separator</span><span class="s3">\r\n\t\t</span><span class="s1">// between a national prefix and a national (significant) number.</span><span class="s3">\r\n\t\t</span><span class="s1">if (format &amp;&amp;</span><span class="s3">\r\n\t\t\t</span><span class="s1">format.nationalPrefixFormattingRule() &amp;&amp;</span><span class="s3">\r\n\t\t\t</span><span class="s1">NATIONAL_PREFIX_SEPARATORS_PATTERN.test(format.nationalPrefixFormattingRule())) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">return ' '</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">// At this point, there seems to be no clear evidence that</span><span class="s3">\r\n\t\t</span><span class="s1">// there should be a separator between a national prefix</span><span class="s3">\r\n\t\t</span><span class="s1">// and a national (significant) number. So don't insert one.</span><span class="s3">\r\n\t\t</span><span class="s1">return ''</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">getInternationalPrefixBeforeCountryCallingCode({ IDDPrefix, missingPlus }, options) {</span><span class="s3">\r\n\t\t</span><span class="s1">if (IDDPrefix) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">return options &amp;&amp; options.spacing === false ? IDDPrefix : IDDPrefix + ' '</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">if (missingPlus) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">return ''</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">return '+'</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">getTemplate(state) {</span><span class="s3">\r\n\t\t</span><span class="s1">if (!this.template) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">return</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">// `this.template` holds the template for a </span><span class="s3">\&quot;</span><span class="s1">complete</span><span class="s3">\&quot; </span><span class="s1">phone number.</span><span class="s3">\r\n\t\t</span><span class="s1">// The currently entered phone number is most likely not </span><span class="s3">\&quot;</span><span class="s1">complete</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\r\n\t\t</span><span class="s1">// so trim all non-populated digits.</span><span class="s3">\r\n\t\t</span><span class="s1">let index = -1</span><span class="s3">\r\n\t\t</span><span class="s1">let i = 0</span><span class="s3">\r\n\t\t</span><span class="s1">const internationalPrefix = state.international ? this.getInternationalPrefixBeforeCountryCallingCode(state, { spacing: false }) : ''</span><span class="s3">\r\n\t\t</span><span class="s1">while (i &lt; internationalPrefix.length + state.getDigitsWithoutInternationalPrefix().length) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">index = this.template.indexOf(DIGIT_PLACEHOLDER, index + 1)</span><span class="s3">\r\n\t\t\t</span><span class="s1">i++</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">return cutAndStripNonPairedParens(this.template, index + 1)</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">setNationalNumberTemplate(template, state) {</span><span class="s3">\r\n\t\t</span><span class="s1">this.nationalNumberTemplate = template</span><span class="s3">\r\n\t\t</span><span class="s1">this.populatedNationalNumberTemplate = template</span><span class="s3">\r\n\t\t</span><span class="s1">// With a new formatting template, the matched position</span><span class="s3">\r\n\t\t</span><span class="s1">// using the old template needs to be reset.</span><span class="s3">\r\n\t\t</span><span class="s1">this.populatedNationalNumberTemplatePosition = -1</span><span class="s3">\r\n\t\t</span><span class="s1">// For convenience, the public `.template` property</span><span class="s3">\r\n\t\t</span><span class="s1">// contains the whole international number</span><span class="s3">\r\n\t\t</span><span class="s1">// if the phone number being input is international:</span><span class="s3">\r\n\t\t</span><span class="s1">// 'x' for the '+' sign, 'x'es for the country phone code,</span><span class="s3">\r\n\t\t</span><span class="s1">// a spacebar and then the template for the formatted national number.</span><span class="s3">\r\n\t\t</span><span class="s1">if (state.international) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.template =</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">this.getInternationalPrefixBeforeCountryCallingCode(state).replace(/[</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">+]/g, DIGIT_PLACEHOLDER) +</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">repeat(DIGIT_PLACEHOLDER, state.callingCode.length) +</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">' ' +</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">template</span><span class="s3">\r\n\t\t</span><span class="s1">} else {</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.template = template</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">/**</span><span class="s3">\r\n\t </span><span class="s1">* Generates formatting template for a national phone number,</span><span class="s3">\r\n\t </span><span class="s1">* optionally containing a national prefix, for a format.</span><span class="s3">\r\n\t </span><span class="s1">* @param  {Format} format</span><span class="s3">\r\n\t </span><span class="s1">* @param  {string} nationalPrefix</span><span class="s3">\r\n\t </span><span class="s1">* @return {string}</span><span class="s3">\r\n\t </span><span class="s1">*/</span><span class="s3">\r\n\t</span><span class="s1">getTemplateForFormat(format, {</span><span class="s3">\r\n\t\t</span><span class="s1">nationalSignificantNumber,</span><span class="s3">\r\n\t\t</span><span class="s1">international,</span><span class="s3">\r\n\t\t</span><span class="s1">nationalPrefix,</span><span class="s3">\r\n\t\t</span><span class="s1">prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix</span><span class="s3">\r\n\t</span><span class="s1">}) {</span><span class="s3">\r\n\t\t</span><span class="s1">let pattern = format.pattern()</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">/* istanbul ignore else */</span><span class="s3">\r\n\t\t</span><span class="s1">if (SUPPORT_LEGACY_FORMATTING_PATTERNS) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">pattern = pattern</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// Replace anything in the form of [..] with </span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">.replace(CREATE_CHARACTER_CLASS_PATTERN(), '</span><span class="s3">\\\\</span><span class="s1">d')</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// Replace any standalone digit (not the one in `{}`) with </span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">.replace(CREATE_STANDALONE_DIGIT_PATTERN(), '</span><span class="s3">\\\\</span><span class="s1">d')</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// Generate a dummy national number (consisting of `9`s)</span><span class="s3">\r\n\t\t</span><span class="s1">// that fits this format's `pattern`.</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">// This match will always succeed,</span><span class="s3">\r\n\t\t</span><span class="s1">// because the </span><span class="s3">\&quot;</span><span class="s1">longest dummy phone number</span><span class="s3">\&quot;\r\n\t\t</span><span class="s1">// has enough length to accomodate any possible</span><span class="s3">\r\n\t\t</span><span class="s1">// national phone number format pattern.</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">let digits = LONGEST_DUMMY_PHONE_NUMBER.match(pattern)[0]</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// If the national number entered is too long</span><span class="s3">\r\n\t\t</span><span class="s1">// for any phone number format, then abort.</span><span class="s3">\r\n\t\t</span><span class="s1">if (nationalSignificantNumber.length &gt; digits.length) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">return</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// Get a formatting template which can be used to efficiently format</span><span class="s3">\r\n\t\t</span><span class="s1">// a partial number where digits are added one by one.</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// Below `strictPattern` is used for the</span><span class="s3">\r\n\t\t</span><span class="s1">// regular expression (with `^` and `$`).</span><span class="s3">\r\n\t\t</span><span class="s1">// This wasn't originally in Google's `libphonenumber`</span><span class="s3">\r\n\t\t</span><span class="s1">// and I guess they don't really need it</span><span class="s3">\r\n\t\t</span><span class="s1">// because they're not using </span><span class="s3">\&quot;</span><span class="s1">templates</span><span class="s3">\&quot; </span><span class="s1">to format phone numbers</span><span class="s3">\r\n\t\t</span><span class="s1">// but I added `strictPattern` after encountering</span><span class="s3">\r\n\t\t</span><span class="s1">// South Korean phone number formatting bug.</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">// Non-strict regular expression bug demonstration:</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">// this.nationalSignificantNumber : `111111111` (9 digits)</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">// pattern : (</span><span class="s3">\\</span><span class="s1">d{2})(</span><span class="s3">\\</span><span class="s1">d{3,4})(</span><span class="s3">\\</span><span class="s1">d{4})</span><span class="s3">\r\n\t\t</span><span class="s1">// format : `$1 $2 $3`</span><span class="s3">\r\n\t\t</span><span class="s1">// digits : `9999999999` (10 digits)</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">// '9999999999'.replace(new RegExp(/(</span><span class="s3">\\</span><span class="s1">d{2})(</span><span class="s3">\\</span><span class="s1">d{3,4})(</span><span class="s3">\\</span><span class="s1">d{4})/g), '$1 $2 $3') = </span><span class="s3">\&quot;</span><span class="s1">99 9999 9999</span><span class="s3">\&quot;\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">// template : xx xxxx xxxx</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">// But the correct template in this case is `xx xxx xxxx`.</span><span class="s3">\r\n\t\t</span><span class="s1">// The template was generated incorrectly because of the</span><span class="s3">\r\n\t\t</span><span class="s1">// `{3,4}` variability in the `pattern`.</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">// The fix is, if `this.nationalSignificantNumber` has already sufficient length</span><span class="s3">\r\n\t\t</span><span class="s1">// to satisfy the `pattern` completely then `this.nationalSignificantNumber`</span><span class="s3">\r\n\t\t</span><span class="s1">// is used instead of `digits`.</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">const strictPattern = new RegExp('^' + pattern + '$')</span><span class="s3">\r\n\t\t</span><span class="s1">const nationalNumberDummyDigits = nationalSignificantNumber.replace(/</span><span class="s3">\\</span><span class="s1">d/g, DUMMY_DIGIT)</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// If `this.nationalSignificantNumber` has already sufficient length</span><span class="s3">\r\n\t\t</span><span class="s1">// to satisfy the `pattern` completely then use it</span><span class="s3">\r\n\t\t</span><span class="s1">// instead of `digits`.</span><span class="s3">\r\n\t\t</span><span class="s1">if (strictPattern.test(nationalNumberDummyDigits)) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">digits = nationalNumberDummyDigits</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">let numberFormat = this.getFormatFormat(format, international)</span><span class="s3">\r\n\t\t</span><span class="s1">let nationalPrefixIncludedInTemplate</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// If a user did input a national prefix (and that's guaranteed),</span><span class="s3">\r\n\t\t</span><span class="s1">// and if a `format` does have a national prefix formatting rule,</span><span class="s3">\r\n\t\t</span><span class="s1">// then see if that national prefix formatting rule</span><span class="s3">\r\n\t\t</span><span class="s1">// prepends exactly the same national prefix the user has input.</span><span class="s3">\r\n\t\t</span><span class="s1">// If that's the case, then use the `format` with the national prefix formatting rule.</span><span class="s3">\r\n\t\t</span><span class="s1">// Otherwise, use  the `format` without the national prefix formatting rule,</span><span class="s3">\r\n\t\t</span><span class="s1">// and prepend a national prefix manually to it.</span><span class="s3">\r\n\t\t</span><span class="s1">if (this.shouldTryNationalPrefixFormattingRule(format, { international, nationalPrefix })) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">const numberFormatWithNationalPrefix = numberFormat.replace(</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">FIRST_GROUP_PATTERN,</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">format.nationalPrefixFormattingRule()</span><span class="s3">\r\n\t\t\t</span><span class="s1">)</span><span class="s3">\r\n\t\t\t</span><span class="s1">// If `national_prefix_formatting_rule` of a `format` simply prepends</span><span class="s3">\r\n\t\t\t</span><span class="s1">// national prefix at the start of a national (significant) number,</span><span class="s3">\r\n\t\t\t</span><span class="s1">// then such formatting can be used with `AsYouType` formatter.</span><span class="s3">\r\n\t\t\t</span><span class="s1">// There seems to be no `else` case: everywhere in metadata,</span><span class="s3">\r\n\t\t\t</span><span class="s1">// national prefix formatting rule is national prefix + $1,</span><span class="s3">\r\n\t\t\t</span><span class="s1">// or `($1)`, in which case such format isn't even considered</span><span class="s3">\r\n\t\t\t</span><span class="s1">// when the user has input a national prefix.</span><span class="s3">\r\n\t\t\t</span><span class="s1">/* istanbul ignore else */</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (parseDigits(format.nationalPrefixFormattingRule()) === (nationalPrefix || '') + parseDigits('$1')) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">numberFormat = numberFormatWithNationalPrefix</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">nationalPrefixIncludedInTemplate = true</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// Replace all digits of the national prefix in the formatting template</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// with `DIGIT_PLACEHOLDER`s.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">if (nationalPrefix) {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">let i = nationalPrefix.length</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">while (i &gt; 0) {</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">numberFormat = numberFormat.replace(/</span><span class="s3">\\</span><span class="s1">d/, DIGIT_PLACEHOLDER)</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">i--</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// Generate formatting template for this phone number format.</span><span class="s3">\r\n\t\t</span><span class="s1">let template = digits</span><span class="s3">\r\n\t\t\t</span><span class="s1">// Format the dummy phone number according to the format.</span><span class="s3">\r\n\t\t\t</span><span class="s1">.replace(new RegExp(pattern), numberFormat)</span><span class="s3">\r\n\t\t\t</span><span class="s1">// Replace each dummy digit with a DIGIT_PLACEHOLDER.</span><span class="s3">\r\n\t\t\t</span><span class="s1">.replace(new RegExp(DUMMY_DIGIT, 'g'), DIGIT_PLACEHOLDER)</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// If a prefix of a national (significant) number is not as simple</span><span class="s3">\r\n\t\t</span><span class="s1">// as just a basic national prefix, then just prepend such prefix</span><span class="s3">\r\n\t\t</span><span class="s1">// before the national (significant) number, optionally spacing</span><span class="s3">\r\n\t\t</span><span class="s1">// the two with a whitespace.</span><span class="s3">\r\n\t\t</span><span class="s1">if (!nationalPrefixIncludedInTemplate) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// Prepend the prefix to the template manually.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">template = repeat(DIGIT_PLACEHOLDER, prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix.length) +</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">' ' +</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">template</span><span class="s3">\r\n\t\t\t</span><span class="s1">} else if (nationalPrefix) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// Prepend national prefix to the template manually.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">template = repeat(DIGIT_PLACEHOLDER, nationalPrefix.length) +</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">this.getSeparatorAfterNationalPrefix(format) +</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">template</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">if (international) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">template = applyInternationalSeparatorStyle(template)</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">return template</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">formatNextNationalNumberDigits(digits) {</span><span class="s3">\r\n\t\t</span><span class="s1">const result = populateTemplateWithDigits(</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.populatedNationalNumberTemplate,</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.populatedNationalNumberTemplatePosition,</span><span class="s3">\r\n\t\t\t</span><span class="s1">digits</span><span class="s3">\r\n\t\t</span><span class="s1">)</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">if (!result) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">// Reset the format.</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.resetFormat()</span><span class="s3">\r\n\t\t\t</span><span class="s1">return</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">this.populatedNationalNumberTemplate = result[0]</span><span class="s3">\r\n\t\t</span><span class="s1">this.populatedNationalNumberTemplatePosition = result[1]</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// Return the formatted phone number so far.</span><span class="s3">\r\n\t\t</span><span class="s1">return cutAndStripNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// The old way which was good for `input-format` but is not so good</span><span class="s3">\r\n\t\t</span><span class="s1">// for `react-phone-number-input`'s default input (`InputBasic`).</span><span class="s3">\r\n\t\t</span><span class="s1">// return closeNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)</span><span class="s3">\r\n\t\t</span><span class="s1">// </span><span class="s3">\t</span><span class="s1">.replace(new RegExp(DIGIT_PLACEHOLDER, 'g'), ' ')</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">shouldTryNationalPrefixFormattingRule(format, { international, nationalPrefix }) {</span><span class="s3">\r\n\t\t</span><span class="s1">if (format.nationalPrefixFormattingRule()) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">// In some countries, `national_prefix_formatting_rule` is `($1)`,</span><span class="s3">\r\n\t\t\t</span><span class="s1">// so it applies even if the user hasn't input a national prefix.</span><span class="s3">\r\n\t\t\t</span><span class="s1">// `format.usesNationalPrefix()` detects such cases.</span><span class="s3">\r\n\t\t\t</span><span class="s1">const usesNationalPrefix = format.usesNationalPrefix()</span><span class="s3">\r\n\t\t\t</span><span class="s1">if ((usesNationalPrefix &amp;&amp; nationalPrefix) ||</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">(!usesNationalPrefix &amp;&amp; !international)) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">return true</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n</span><span class="s1">}&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>