<html>
<head>
<title>no-unstable-nested-components.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #264eff;}
.s6 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
no-unstable-nested-components.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">Prevent creating unstable components inside components</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Ari Perkkiö</span>
 <span class="s0">*/</span>

<span class="s3">'use strict'</span><span class="s2">;</span>

<span class="s4">const </span><span class="s2">minimatch = require(</span><span class="s3">'minimatch'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">Components = require(</span><span class="s3">'../util/Components'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">docsUrl = require(</span><span class="s3">'../util/docsUrl'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">astUtil = require(</span><span class="s3">'../util/ast'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">isCreateElement = require(</span><span class="s3">'../util/isCreateElement'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">report = require(</span><span class="s3">'../util/report'</span><span class="s2">);</span>

<span class="s0">// ------------------------------------------------------------------------------</span>
<span class="s0">// Constants</span>
<span class="s0">// ------------------------------------------------------------------------------</span>

<span class="s4">const </span><span class="s2">COMPONENT_AS_PROPS_INFO = </span><span class="s3">' If you want to allow component creation in props, set allowAsProps option to true.'</span><span class="s2">;</span>
<span class="s4">const </span><span class="s2">HOOK_REGEXP = </span><span class="s5">/^use[A-Z0-9].*$/</span><span class="s2">;</span>

<span class="s0">// ------------------------------------------------------------------------------</span>
<span class="s0">// Helpers</span>
<span class="s0">// ------------------------------------------------------------------------------</span>

<span class="s0">/**</span>
 <span class="s0">* Generate error message with given parent component name</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} parentName Name of the parent component, if known</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string} Error message with parent component name</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">generateErrorMessageWithParentName(parentName) {</span>
  <span class="s4">return </span><span class="s3">`Do not define components during render. React will see a new component type on every render and destroy the entire subtree’s DOM nodes and state (https://reactjs.org/docs/reconciliation.html#elements-of-different-types). Instead, move this component definition out of the parent component</span><span class="s2">${parentName ? </span><span class="s3">` “</span><span class="s2">${parentName}</span><span class="s3">” ` </span><span class="s2">: </span><span class="s3">' '</span><span class="s2">}</span><span class="s3">and pass data as props.`</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Check whether given text matches the pattern passed in.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} text Text to validate</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} pattern Pattern to match against</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean}</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">propMatchesRenderPropPattern(text, pattern) {</span>
  <span class="s4">return typeof </span><span class="s2">text === </span><span class="s3">'string' </span><span class="s2">&amp;&amp; minimatch(text, pattern);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Get closest parent matching given matcher</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Context} context eslint context</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} matcher Method used to match the parent</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ASTNode} The matching parent node, if any</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">getClosestMatchingParent(node, context, matcher) {</span>
  <span class="s4">if </span><span class="s2">(!node || !node.parent || node.parent.type === </span><span class="s3">'Program'</span><span class="s2">) {</span>
    <span class="s4">return</span><span class="s2">;</span>
  <span class="s2">}</span>

  <span class="s4">if </span><span class="s2">(matcher(node.parent, context)) {</span>
    <span class="s4">return </span><span class="s2">node.parent;</span>
  <span class="s2">}</span>

  <span class="s4">return </span><span class="s2">getClosestMatchingParent(node.parent, context, matcher);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Matcher used to check whether given node is a `createElement` call</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Context} context eslint context</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if node is a `createElement` call, false if not</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isCreateElementMatcher(node, context) {</span>
  <span class="s4">return </span><span class="s2">(</span>
    <span class="s2">astUtil.isCallExpression(node)</span>
    <span class="s2">&amp;&amp; isCreateElement(context, node)</span>
  <span class="s2">);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Matcher used to check whether given node is a `ObjectExpression`</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if node is a `ObjectExpression`, false if not</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isObjectExpressionMatcher(node) {</span>
  <span class="s4">return </span><span class="s2">node &amp;&amp; node.type === </span><span class="s3">'ObjectExpression'</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Matcher used to check whether given node is a `JSXExpressionContainer`</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if node is a `JSXExpressionContainer`, false if not</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isJSXExpressionContainerMatcher(node) {</span>
  <span class="s4">return </span><span class="s2">node &amp;&amp; node.type === </span><span class="s3">'JSXExpressionContainer'</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Matcher used to check whether given node is a `JSXAttribute` of `JSXExpressionContainer`</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if node is a `JSXAttribute` of `JSXExpressionContainer`, false if not</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isJSXAttributeOfExpressionContainerMatcher(node) {</span>
  <span class="s4">return </span><span class="s2">(</span>
    <span class="s2">node</span>
    <span class="s2">&amp;&amp; node.type === </span><span class="s3">'JSXAttribute'</span>
    <span class="s2">&amp;&amp; node.value</span>
    <span class="s2">&amp;&amp; node.value.type === </span><span class="s3">'JSXExpressionContainer'</span>
  <span class="s2">);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Matcher used to check whether given node is an object `Property`</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if node is a `Property`, false if not</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isPropertyOfObjectExpressionMatcher(node) {</span>
  <span class="s4">return </span><span class="s2">(</span>
    <span class="s2">node</span>
    <span class="s2">&amp;&amp; node.parent</span>
    <span class="s2">&amp;&amp; node.parent.type === </span><span class="s3">'Property'</span>
  <span class="s2">);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Check whether given node or its parent is directly inside `map` call</span>
 <span class="s0">* ```jsx</span>
 <span class="s0">* {items.map(item =&gt; &lt;li /&gt;)}</span>
 <span class="s0">* ```</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if node is directly inside `map` call, false if not</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isMapCall(node) {</span>
  <span class="s4">return </span><span class="s2">(</span>
    <span class="s2">node</span>
    <span class="s2">&amp;&amp; node.callee</span>
    <span class="s2">&amp;&amp; node.callee.property</span>
    <span class="s2">&amp;&amp; node.callee.property.name === </span><span class="s3">'map'</span>
  <span class="s2">);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Check whether given node is `ReturnStatement` of a React hook</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Context} context eslint context</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if node is a `ReturnStatement` of a React hook, false if not</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isReturnStatementOfHook(node, context) {</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s2">!node</span>
    <span class="s2">|| !node.parent</span>
    <span class="s2">|| node.parent.type !== </span><span class="s3">'ReturnStatement'</span>
  <span class="s2">) {</span>
    <span class="s4">return false</span><span class="s2">;</span>
  <span class="s2">}</span>

  <span class="s4">const </span><span class="s2">callExpression = getClosestMatchingParent(node, context, astUtil.isCallExpression);</span>
  <span class="s4">return </span><span class="s2">(</span>
    <span class="s2">callExpression</span>
    <span class="s2">&amp;&amp; callExpression.callee</span>
    <span class="s2">&amp;&amp; HOOK_REGEXP.test(callExpression.callee.name)</span>
  <span class="s2">);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Check whether given node is declared inside a render prop</span>
 <span class="s0">* ```jsx</span>
 <span class="s0">* &lt;Component renderFooter={() =&gt; &lt;div /&gt;} /&gt;</span>
 <span class="s0">* &lt;Component&gt;{() =&gt; &lt;div /&gt;}&lt;/Component&gt;</span>
 <span class="s0">* ```</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Context} context eslint context</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} propNamePattern a pattern to match render props against</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if component is declared inside a render prop, false if not</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isComponentInRenderProp(node, context, propNamePattern) {</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s2">node</span>
    <span class="s2">&amp;&amp; node.parent</span>
    <span class="s2">&amp;&amp; node.parent.type === </span><span class="s3">'Property'</span>
    <span class="s2">&amp;&amp; node.parent.key</span>
    <span class="s2">&amp;&amp; propMatchesRenderPropPattern(node.parent.key.name, propNamePattern)</span>
  <span class="s2">) {</span>
    <span class="s4">return true</span><span class="s2">;</span>
  <span class="s2">}</span>

  <span class="s0">// Check whether component is a render prop used as direct children, e.g. &lt;Component&gt;{() =&gt; &lt;div /&gt;}&lt;/Component&gt;</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s2">node</span>
    <span class="s2">&amp;&amp; node.parent</span>
    <span class="s2">&amp;&amp; node.parent.type === </span><span class="s3">'JSXExpressionContainer'</span>
    <span class="s2">&amp;&amp; node.parent.parent</span>
    <span class="s2">&amp;&amp; node.parent.parent.type === </span><span class="s3">'JSXElement'</span>
  <span class="s2">) {</span>
    <span class="s4">return true</span><span class="s2">;</span>
  <span class="s2">}</span>

  <span class="s4">const </span><span class="s2">jsxExpressionContainer = getClosestMatchingParent(node, context, isJSXExpressionContainerMatcher);</span>

  <span class="s0">// Check whether prop name indicates accepted patterns</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s2">jsxExpressionContainer</span>
    <span class="s2">&amp;&amp; jsxExpressionContainer.parent</span>
    <span class="s2">&amp;&amp; jsxExpressionContainer.parent.type === </span><span class="s3">'JSXAttribute'</span>
    <span class="s2">&amp;&amp; jsxExpressionContainer.parent.name</span>
    <span class="s2">&amp;&amp; jsxExpressionContainer.parent.name.type === </span><span class="s3">'JSXIdentifier'</span>
  <span class="s2">) {</span>
    <span class="s4">const </span><span class="s2">propName = jsxExpressionContainer.parent.name.name;</span>

    <span class="s0">// Starts with render, e.g. &lt;Component renderFooter={() =&gt; &lt;div /&gt;} /&gt;</span>
    <span class="s4">if </span><span class="s2">(propMatchesRenderPropPattern(propName, propNamePattern)) {</span>
      <span class="s4">return true</span><span class="s2">;</span>
    <span class="s2">}</span>

    <span class="s0">// Uses children prop explicitly, e.g. &lt;Component children={() =&gt; &lt;div /&gt;} /&gt;</span>
    <span class="s4">if </span><span class="s2">(propName === </span><span class="s3">'children'</span><span class="s2">) {</span>
      <span class="s4">return true</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s4">return false</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Check whether given node is declared directly inside a render property</span>
 <span class="s0">* ```jsx</span>
 <span class="s0">* const rows = { render: () =&gt; &lt;div /&gt; }</span>
 <span class="s0">* &lt;Component rows={ [{ render: () =&gt; &lt;div /&gt; }] } /&gt;</span>
 <span class="s0">*  ```</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} propNamePattern The pattern to match render props against</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if component is declared inside a render property, false if not</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isDirectValueOfRenderProperty(node, propNamePattern) {</span>
  <span class="s4">return </span><span class="s2">(</span>
    <span class="s2">node</span>
    <span class="s2">&amp;&amp; node.parent</span>
    <span class="s2">&amp;&amp; node.parent.type === </span><span class="s3">'Property'</span>
    <span class="s2">&amp;&amp; node.parent.key</span>
    <span class="s2">&amp;&amp; node.parent.key.type === </span><span class="s3">'Identifier'</span>
    <span class="s2">&amp;&amp; propMatchesRenderPropPattern(node.parent.key.name, propNamePattern)</span>
  <span class="s2">);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Resolve the component name of given node</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node of the component</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string} Name of the component, if any</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">resolveComponentName(node) {</span>
  <span class="s4">const </span><span class="s2">parentName = node.id &amp;&amp; node.id.name;</span>
  <span class="s4">if </span><span class="s2">(parentName) </span><span class="s4">return </span><span class="s2">parentName;</span>

  <span class="s4">return </span><span class="s2">(</span>
    <span class="s2">node.type === </span><span class="s3">'ArrowFunctionExpression'</span>
    <span class="s2">&amp;&amp; node.parent</span>
    <span class="s2">&amp;&amp; node.parent.id</span>
    <span class="s2">&amp;&amp; node.parent.id.name</span>
  <span class="s2">);</span>
<span class="s2">}</span>

<span class="s0">// ------------------------------------------------------------------------------</span>
<span class="s0">// Rule Definition</span>
<span class="s0">// ------------------------------------------------------------------------------</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{import('eslint').Rule.RuleModule} */</span>
<span class="s2">module.exports = {</span>
  <span class="s2">meta: {</span>
    <span class="s2">docs: {</span>
      <span class="s2">description: </span><span class="s3">'Disallow creating unstable components inside components'</span><span class="s2">,</span>
      <span class="s2">category: </span><span class="s3">'Possible Errors'</span><span class="s2">,</span>
      <span class="s2">recommended: </span><span class="s4">false</span><span class="s2">,</span>
      <span class="s2">url: docsUrl(</span><span class="s3">'no-unstable-nested-components'</span><span class="s2">),</span>
    <span class="s2">},</span>
    <span class="s2">schema: [{</span>
      <span class="s2">type: </span><span class="s3">'object'</span><span class="s2">,</span>
      <span class="s2">properties: {</span>
        <span class="s2">customValidators: {</span>
          <span class="s2">type: </span><span class="s3">'array'</span><span class="s2">,</span>
          <span class="s2">items: {</span>
            <span class="s2">type: </span><span class="s3">'string'</span><span class="s2">,</span>
          <span class="s2">},</span>
        <span class="s2">},</span>
        <span class="s2">allowAsProps: {</span>
          <span class="s2">type: </span><span class="s3">'boolean'</span><span class="s2">,</span>
        <span class="s2">},</span>
        <span class="s2">propNamePattern: {</span>
          <span class="s2">type: </span><span class="s3">'string'</span><span class="s2">,</span>
        <span class="s2">},</span>
      <span class="s2">},</span>
      <span class="s2">additionalProperties: </span><span class="s4">false</span><span class="s2">,</span>
    <span class="s2">}],</span>
  <span class="s2">},</span>

  <span class="s2">create: Components.detect((context, components, utils) =&gt; {</span>
    <span class="s4">const </span><span class="s2">allowAsProps = context.options.some((option) =&gt; option &amp;&amp; option.allowAsProps);</span>
    <span class="s4">const </span><span class="s2">propNamePattern = (context.options[</span><span class="s6">0</span><span class="s2">] || {}).propNamePattern || </span><span class="s3">'render*'</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Check whether given node is declared inside class component's render block</span>
     <span class="s0">* ```jsx</span>
     <span class="s0">* class Component extends React.Component {</span>
     <span class="s0">*   render() {</span>
     <span class="s0">*     class NestedClassComponent extends React.Component {</span>
     <span class="s0">* ...</span>
     <span class="s0">* ```</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node being checked</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if node is inside class component's render block, false if not</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">isInsideRenderMethod(node) {</span>
      <span class="s4">const </span><span class="s2">parentComponent = utils.getParentComponent(node);</span>

      <span class="s4">if </span><span class="s2">(!parentComponent || parentComponent.type !== </span><span class="s3">'ClassDeclaration'</span><span class="s2">) {</span>
        <span class="s4">return false</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">node</span>
        <span class="s2">&amp;&amp; node.parent</span>
        <span class="s2">&amp;&amp; node.parent.type === </span><span class="s3">'MethodDefinition'</span>
        <span class="s2">&amp;&amp; node.parent.key</span>
        <span class="s2">&amp;&amp; node.parent.key.name === </span><span class="s3">'render'</span>
      <span class="s2">);</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Check whether given node is a function component declared inside class component.</span>
     <span class="s0">* Util's component detection fails to detect function components inside class components.</span>
     <span class="s0">* ```jsx</span>
     <span class="s0">* class Component extends React.Component {</span>
     <span class="s0">*  render() {</span>
     <span class="s0">*    const NestedComponent = () =&gt; &lt;div /&gt;;</span>
     <span class="s0">* ...</span>
     <span class="s0">* ```</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node being checked</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if given node a function component declared inside class component, false if not</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">isFunctionComponentInsideClassComponent(node) {</span>
      <span class="s4">const </span><span class="s2">parentComponent = utils.getParentComponent(node);</span>
      <span class="s4">const </span><span class="s2">parentStatelessComponent = utils.getParentStatelessComponent(node);</span>

      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">parentComponent</span>
        <span class="s2">&amp;&amp; parentStatelessComponent</span>
        <span class="s2">&amp;&amp; parentComponent.type === </span><span class="s3">'ClassDeclaration'</span>
        <span class="s2">&amp;&amp; utils.getStatelessComponent(parentStatelessComponent)</span>
        <span class="s2">&amp;&amp; utils.isReturningJSX(node)</span>
      <span class="s2">);</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Check whether given node is declared inside `createElement` call's props</span>
     <span class="s0">* ```js</span>
     <span class="s0">* React.createElement(Component, {</span>
     <span class="s0">*   footer: () =&gt; React.createElement(&quot;div&quot;, null)</span>
     <span class="s0">* })</span>
     <span class="s0">* ```</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if node is declare inside `createElement` call's props, false if not</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">isComponentInsideCreateElementsProp(node) {</span>
      <span class="s4">if </span><span class="s2">(!components.get(node)) {</span>
        <span class="s4">return false</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s4">const </span><span class="s2">createElementParent = getClosestMatchingParent(node, context, isCreateElementMatcher);</span>

      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">createElementParent</span>
        <span class="s2">&amp;&amp; createElementParent.arguments</span>
        <span class="s2">&amp;&amp; createElementParent.arguments[</span><span class="s6">1</span><span class="s2">] === getClosestMatchingParent(node, context, isObjectExpressionMatcher)</span>
      <span class="s2">);</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Check whether given node is declared inside a component/object prop.</span>
     <span class="s0">* ```jsx</span>
     <span class="s0">* &lt;Component footer={() =&gt; &lt;div /&gt;} /&gt;</span>
     <span class="s0">* { footer: () =&gt; &lt;div /&gt; }</span>
     <span class="s0">* ```</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node being checked</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if node is a component declared inside prop, false if not</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">isComponentInProp(node) {</span>
      <span class="s4">if </span><span class="s2">(isPropertyOfObjectExpressionMatcher(node)) {</span>
        <span class="s4">return </span><span class="s2">utils.isReturningJSX(node);</span>
      <span class="s2">}</span>

      <span class="s4">const </span><span class="s2">jsxAttribute = getClosestMatchingParent(node, context, isJSXAttributeOfExpressionContainerMatcher);</span>

      <span class="s4">if </span><span class="s2">(!jsxAttribute) {</span>
        <span class="s4">return </span><span class="s2">isComponentInsideCreateElementsProp(node);</span>
      <span class="s2">}</span>

      <span class="s4">return </span><span class="s2">utils.isReturningJSX(node);</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Check whether given node is a stateless component returning non-JSX</span>
     <span class="s0">* ```jsx</span>
     <span class="s0">* {{ a: () =&gt; null }}</span>
     <span class="s0">* ```</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node being checked</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if node is a stateless component returning non-JSX, false if not</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">isStatelessComponentReturningNull(node) {</span>
      <span class="s4">const </span><span class="s2">component = utils.getStatelessComponent(node);</span>

      <span class="s4">return </span><span class="s2">component &amp;&amp; !utils.isReturningJSX(component);</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Check whether given node is a unstable nested component</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node being checked</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">validate(node) {</span>
      <span class="s4">if </span><span class="s2">(!node || !node.parent) {</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s4">const </span><span class="s2">isDeclaredInsideProps = isComponentInProp(node);</span>

      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">!components.get(node)</span>
        <span class="s2">&amp;&amp; !isFunctionComponentInsideClassComponent(node)</span>
        <span class="s2">&amp;&amp; !isDeclaredInsideProps) {</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s4">if </span><span class="s2">(</span>
        <span class="s0">// Support allowAsProps option</span>
        <span class="s2">(isDeclaredInsideProps &amp;&amp; (allowAsProps || isComponentInRenderProp(node, context, propNamePattern)))</span>

        <span class="s0">// Prevent reporting components created inside Array.map calls</span>
        <span class="s2">|| isMapCall(node)</span>
        <span class="s2">|| isMapCall(node.parent)</span>

        <span class="s0">// Do not mark components declared inside hooks (or falsy '() =&gt; null' clean-up methods)</span>
        <span class="s2">|| isReturnStatementOfHook(node, context)</span>

        <span class="s0">// Do not mark objects containing render methods</span>
        <span class="s2">|| isDirectValueOfRenderProperty(node, propNamePattern)</span>

        <span class="s0">// Prevent reporting nested class components twice</span>
        <span class="s2">|| isInsideRenderMethod(node)</span>

        <span class="s0">// Prevent falsely reporting detected &quot;components&quot; which do not return JSX</span>
        <span class="s2">|| isStatelessComponentReturningNull(node)</span>
      <span class="s2">) {</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s0">// Get the closest parent component</span>
      <span class="s4">const </span><span class="s2">parentComponent = getClosestMatchingParent(</span>
        <span class="s2">node,</span>
        <span class="s2">context,</span>
        <span class="s2">(nodeToMatch) =&gt; components.get(nodeToMatch)</span>
      <span class="s2">);</span>

      <span class="s4">if </span><span class="s2">(parentComponent) {</span>
        <span class="s4">const </span><span class="s2">parentName = resolveComponentName(parentComponent);</span>

        <span class="s0">// Exclude lowercase parents, e.g. function createTestComponent()</span>
        <span class="s0">// React-dom prevents creating lowercase components</span>
        <span class="s4">if </span><span class="s2">(parentName &amp;&amp; parentName[</span><span class="s6">0</span><span class="s2">] === parentName[</span><span class="s6">0</span><span class="s2">].toLowerCase()) {</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s2">}</span>

        <span class="s4">let </span><span class="s2">message = generateErrorMessageWithParentName(parentName);</span>

        <span class="s0">// Add information about allowAsProps option when component is declared inside prop</span>
        <span class="s4">if </span><span class="s2">(isDeclaredInsideProps &amp;&amp; !allowAsProps) {</span>
          <span class="s2">message += COMPONENT_AS_PROPS_INFO;</span>
        <span class="s2">}</span>

        <span class="s2">report(context, message, </span><span class="s4">null</span><span class="s2">, {</span>
          <span class="s2">node,</span>
        <span class="s2">});</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s0">// --------------------------------------------------------------------------</span>
    <span class="s0">// Public</span>
    <span class="s0">// --------------------------------------------------------------------------</span>

    <span class="s4">return </span><span class="s2">{</span>
      <span class="s2">FunctionDeclaration(node) { validate(node); },</span>
      <span class="s2">ArrowFunctionExpression(node) { validate(node); },</span>
      <span class="s2">FunctionExpression(node) { validate(node); },</span>
      <span class="s2">ClassDeclaration(node) { validate(node); },</span>
      <span class="s2">CallExpression(node) { validate(node); },</span>
    <span class="s2">};</span>
  <span class="s2">}),</span>
<span class="s2">};</span>
</pre>
</body>
</html>