<html>
<head>
<title>keyword-spacing.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #264eff;}
.s6 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
keyword-spacing.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">Rule to enforce spacing before and after keywords.</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Toru Nagashima</span>
 <span class="s0">* </span><span class="s1">@deprecated </span><span class="s0">in ESLint v8.53.0</span>
 <span class="s0">*/</span>

<span class="s3">&quot;use strict&quot;</span><span class="s2">;</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Requirements</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s4">const </span><span class="s2">astUtils = require(</span><span class="s3">&quot;./utils/ast-utils&quot;</span><span class="s2">),</span>
	<span class="s2">keywords = require(</span><span class="s3">&quot;./utils/keywords&quot;</span><span class="s2">);</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Constants</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s4">const </span><span class="s2">PREV_TOKEN = </span><span class="s5">/^[)\]}&gt;]$/u</span><span class="s2">;</span>
<span class="s4">const </span><span class="s2">NEXT_TOKEN = </span><span class="s5">/^(?:[([{&lt;~!]|\+\+?|--?)$/u</span><span class="s2">;</span>
<span class="s4">const </span><span class="s2">PREV_TOKEN_M = </span><span class="s5">/^[)\]}&gt;*]$/u</span><span class="s2">;</span>
<span class="s4">const </span><span class="s2">NEXT_TOKEN_M = </span><span class="s5">/^[{*]$/u</span><span class="s2">;</span>
<span class="s4">const </span><span class="s2">TEMPLATE_OPEN_PAREN = </span><span class="s5">/\$\{$/u</span><span class="s2">;</span>
<span class="s4">const </span><span class="s2">TEMPLATE_CLOSE_PAREN = </span><span class="s5">/^\}/u</span><span class="s2">;</span>
<span class="s4">const </span><span class="s2">CHECK_TYPE =</span>
	<span class="s5">/^(?:JSXElement|RegularExpression|String|Template|PrivateIdentifier)$/u</span><span class="s2">;</span>
<span class="s4">const </span><span class="s2">KEYS = keywords.concat([</span>
	<span class="s3">&quot;as&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;async&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;await&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;from&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;get&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;let&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;of&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;set&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;yield&quot;</span><span class="s2">,</span>
<span class="s2">]);</span>

<span class="s0">// check duplications.</span>
<span class="s2">(</span><span class="s4">function </span><span class="s2">() {</span>
	<span class="s2">KEYS.sort();</span>
	<span class="s4">for </span><span class="s2">(</span><span class="s4">let </span><span class="s2">i = </span><span class="s6">1</span><span class="s2">; i &lt; KEYS.length; ++i) {</span>
		<span class="s4">if </span><span class="s2">(KEYS[i] === KEYS[i - </span><span class="s6">1</span><span class="s2">]) {</span>
			<span class="s4">throw new </span><span class="s2">Error(</span>
				<span class="s3">`Duplication was found in the keyword list: </span><span class="s2">${KEYS[i]}</span><span class="s3">`</span><span class="s2">,</span>
			<span class="s2">);</span>
		<span class="s2">}</span>
	<span class="s2">}</span>
<span class="s2">})();</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Helpers</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s0">/**</span>
 <span class="s0">* Checks whether or not a given token is a &quot;Template&quot; token ends with &quot;${&quot;.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} token A token to check.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the token is a &quot;Template&quot; token ends with &quot;${&quot;.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isOpenParenOfTemplate(token) {</span>
	<span class="s4">return </span><span class="s2">token.type === </span><span class="s3">&quot;Template&quot; </span><span class="s2">&amp;&amp; TEMPLATE_OPEN_PAREN.test(token.value);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Checks whether or not a given token is a &quot;Template&quot; token starts with &quot;}&quot;.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} token A token to check.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the token is a &quot;Template&quot; token starts with &quot;}&quot;.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isCloseParenOfTemplate(token) {</span>
	<span class="s4">return </span><span class="s2">token.type === </span><span class="s3">&quot;Template&quot; </span><span class="s2">&amp;&amp; TEMPLATE_CLOSE_PAREN.test(token.value);</span>
<span class="s2">}</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Rule Definition</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{import('../types').Rule.RuleModule} */</span>
<span class="s2">module.exports = {</span>
	<span class="s2">meta: {</span>
		<span class="s2">deprecated: {</span>
			<span class="s2">message: </span><span class="s3">&quot;Formatting rules are being moved out of ESLint core.&quot;</span><span class="s2">,</span>
			<span class="s2">url: </span><span class="s3">&quot;https://eslint.org/blog/2023/10/deprecating-formatting-rules/&quot;</span><span class="s2">,</span>
			<span class="s2">deprecatedSince: </span><span class="s3">&quot;8.53.0&quot;</span><span class="s2">,</span>
			<span class="s2">availableUntil: </span><span class="s3">&quot;10.0.0&quot;</span><span class="s2">,</span>
			<span class="s2">replacedBy: [</span>
				<span class="s2">{</span>
					<span class="s2">message:</span>
						<span class="s3">&quot;ESLint Stylistic now maintains deprecated stylistic core rules.&quot;</span><span class="s2">,</span>
					<span class="s2">url: </span><span class="s3">&quot;https://eslint.style/guide/migration&quot;</span><span class="s2">,</span>
					<span class="s2">plugin: {</span>
						<span class="s2">name: </span><span class="s3">&quot;@stylistic/eslint-plugin&quot;</span><span class="s2">,</span>
						<span class="s2">url: </span><span class="s3">&quot;https://eslint.style&quot;</span><span class="s2">,</span>
					<span class="s2">},</span>
					<span class="s2">rule: {</span>
						<span class="s2">name: </span><span class="s3">&quot;keyword-spacing&quot;</span><span class="s2">,</span>
						<span class="s2">url: </span><span class="s3">&quot;https://eslint.style/rules/keyword-spacing&quot;</span><span class="s2">,</span>
					<span class="s2">},</span>
				<span class="s2">},</span>
			<span class="s2">],</span>
		<span class="s2">},</span>
		<span class="s2">type: </span><span class="s3">&quot;layout&quot;</span><span class="s2">,</span>

		<span class="s2">docs: {</span>
			<span class="s2">description: </span><span class="s3">&quot;Enforce consistent spacing before and after keywords&quot;</span><span class="s2">,</span>
			<span class="s2">recommended: </span><span class="s4">false</span><span class="s2">,</span>
			<span class="s2">url: </span><span class="s3">&quot;https://eslint.org/docs/latest/rules/keyword-spacing&quot;</span><span class="s2">,</span>
		<span class="s2">},</span>

		<span class="s2">fixable: </span><span class="s3">&quot;whitespace&quot;</span><span class="s2">,</span>

		<span class="s2">schema: [</span>
			<span class="s2">{</span>
				<span class="s2">type: </span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
				<span class="s2">properties: {</span>
					<span class="s2">before: { type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">, </span><span class="s4">default</span><span class="s2">: </span><span class="s4">true </span><span class="s2">},</span>
					<span class="s2">after: { type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">, </span><span class="s4">default</span><span class="s2">: </span><span class="s4">true </span><span class="s2">},</span>
					<span class="s2">overrides: {</span>
						<span class="s2">type: </span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
						<span class="s2">properties: KEYS.reduce((retv, key) =&gt; {</span>
							<span class="s2">retv[key] = {</span>
								<span class="s2">type: </span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
								<span class="s2">properties: {</span>
									<span class="s2">before: { type: </span><span class="s3">&quot;boolean&quot; </span><span class="s2">},</span>
									<span class="s2">after: { type: </span><span class="s3">&quot;boolean&quot; </span><span class="s2">},</span>
								<span class="s2">},</span>
								<span class="s2">additionalProperties: </span><span class="s4">false</span><span class="s2">,</span>
							<span class="s2">};</span>
							<span class="s4">return </span><span class="s2">retv;</span>
						<span class="s2">}, {}),</span>
						<span class="s2">additionalProperties: </span><span class="s4">false</span><span class="s2">,</span>
					<span class="s2">},</span>
				<span class="s2">},</span>
				<span class="s2">additionalProperties: </span><span class="s4">false</span><span class="s2">,</span>
			<span class="s2">},</span>
		<span class="s2">],</span>
		<span class="s2">messages: {</span>
			<span class="s2">expectedBefore: </span><span class="s3">'Expected space(s) before &quot;{{value}}&quot;.'</span><span class="s2">,</span>
			<span class="s2">expectedAfter: </span><span class="s3">'Expected space(s) after &quot;{{value}}&quot;.'</span><span class="s2">,</span>
			<span class="s2">unexpectedBefore: </span><span class="s3">'Unexpected space(s) before &quot;{{value}}&quot;.'</span><span class="s2">,</span>
			<span class="s2">unexpectedAfter: </span><span class="s3">'Unexpected space(s) after &quot;{{value}}&quot;.'</span><span class="s2">,</span>
		<span class="s2">},</span>
	<span class="s2">},</span>

	<span class="s2">create(context) {</span>
		<span class="s4">const </span><span class="s2">sourceCode = context.sourceCode;</span>

		<span class="s4">const </span><span class="s2">tokensToIgnore = </span><span class="s4">new </span><span class="s2">WeakSet();</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports a given token if there are not space(s) before the token.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} token A token to report.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{RegExp} pattern A pattern of the previous token to check.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">expectSpaceBefore(token, pattern) {</span>
			<span class="s4">const </span><span class="s2">prevToken = sourceCode.getTokenBefore(token);</span>

			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">prevToken &amp;&amp;</span>
				<span class="s2">(CHECK_TYPE.test(prevToken.type) ||</span>
					<span class="s2">pattern.test(prevToken.value)) &amp;&amp;</span>
				<span class="s2">!isOpenParenOfTemplate(prevToken) &amp;&amp;</span>
				<span class="s2">!tokensToIgnore.has(prevToken) &amp;&amp;</span>
				<span class="s2">astUtils.isTokenOnSameLine(prevToken, token) &amp;&amp;</span>
				<span class="s2">!sourceCode.isSpaceBetweenTokens(prevToken, token)</span>
			<span class="s2">) {</span>
				<span class="s2">context.report({</span>
					<span class="s2">loc: token.loc,</span>
					<span class="s2">messageId: </span><span class="s3">&quot;expectedBefore&quot;</span><span class="s2">,</span>
					<span class="s2">data: token,</span>
					<span class="s2">fix(fixer) {</span>
						<span class="s4">return </span><span class="s2">fixer.insertTextBefore(token, </span><span class="s3">&quot; &quot;</span><span class="s2">);</span>
					<span class="s2">},</span>
				<span class="s2">});</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports a given token if there are space(s) before the token.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} token A token to report.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{RegExp} pattern A pattern of the previous token to check.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">unexpectSpaceBefore(token, pattern) {</span>
			<span class="s4">const </span><span class="s2">prevToken = sourceCode.getTokenBefore(token);</span>

			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">prevToken &amp;&amp;</span>
				<span class="s2">(CHECK_TYPE.test(prevToken.type) ||</span>
					<span class="s2">pattern.test(prevToken.value)) &amp;&amp;</span>
				<span class="s2">!isOpenParenOfTemplate(prevToken) &amp;&amp;</span>
				<span class="s2">!tokensToIgnore.has(prevToken) &amp;&amp;</span>
				<span class="s2">astUtils.isTokenOnSameLine(prevToken, token) &amp;&amp;</span>
				<span class="s2">sourceCode.isSpaceBetweenTokens(prevToken, token)</span>
			<span class="s2">) {</span>
				<span class="s2">context.report({</span>
					<span class="s2">loc: { start: prevToken.loc.end, end: token.loc.start },</span>
					<span class="s2">messageId: </span><span class="s3">&quot;unexpectedBefore&quot;</span><span class="s2">,</span>
					<span class="s2">data: token,</span>
					<span class="s2">fix(fixer) {</span>
						<span class="s4">return </span><span class="s2">fixer.removeRange([</span>
							<span class="s2">prevToken.range[</span><span class="s6">1</span><span class="s2">],</span>
							<span class="s2">token.range[</span><span class="s6">0</span><span class="s2">],</span>
						<span class="s2">]);</span>
					<span class="s2">},</span>
				<span class="s2">});</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports a given token if there are not space(s) after the token.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} token A token to report.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{RegExp} pattern A pattern of the next token to check.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">expectSpaceAfter(token, pattern) {</span>
			<span class="s4">const </span><span class="s2">nextToken = sourceCode.getTokenAfter(token);</span>

			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">nextToken &amp;&amp;</span>
				<span class="s2">(CHECK_TYPE.test(nextToken.type) ||</span>
					<span class="s2">pattern.test(nextToken.value)) &amp;&amp;</span>
				<span class="s2">!isCloseParenOfTemplate(nextToken) &amp;&amp;</span>
				<span class="s2">!tokensToIgnore.has(nextToken) &amp;&amp;</span>
				<span class="s2">astUtils.isTokenOnSameLine(token, nextToken) &amp;&amp;</span>
				<span class="s2">!sourceCode.isSpaceBetweenTokens(token, nextToken)</span>
			<span class="s2">) {</span>
				<span class="s2">context.report({</span>
					<span class="s2">loc: token.loc,</span>
					<span class="s2">messageId: </span><span class="s3">&quot;expectedAfter&quot;</span><span class="s2">,</span>
					<span class="s2">data: token,</span>
					<span class="s2">fix(fixer) {</span>
						<span class="s4">return </span><span class="s2">fixer.insertTextAfter(token, </span><span class="s3">&quot; &quot;</span><span class="s2">);</span>
					<span class="s2">},</span>
				<span class="s2">});</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports a given token if there are space(s) after the token.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} token A token to report.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{RegExp} pattern A pattern of the next token to check.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">unexpectSpaceAfter(token, pattern) {</span>
			<span class="s4">const </span><span class="s2">nextToken = sourceCode.getTokenAfter(token);</span>

			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">nextToken &amp;&amp;</span>
				<span class="s2">(CHECK_TYPE.test(nextToken.type) ||</span>
					<span class="s2">pattern.test(nextToken.value)) &amp;&amp;</span>
				<span class="s2">!isCloseParenOfTemplate(nextToken) &amp;&amp;</span>
				<span class="s2">!tokensToIgnore.has(nextToken) &amp;&amp;</span>
				<span class="s2">astUtils.isTokenOnSameLine(token, nextToken) &amp;&amp;</span>
				<span class="s2">sourceCode.isSpaceBetweenTokens(token, nextToken)</span>
			<span class="s2">) {</span>
				<span class="s2">context.report({</span>
					<span class="s2">loc: { start: token.loc.end, end: nextToken.loc.start },</span>
					<span class="s2">messageId: </span><span class="s3">&quot;unexpectedAfter&quot;</span><span class="s2">,</span>
					<span class="s2">data: token,</span>
					<span class="s2">fix(fixer) {</span>
						<span class="s4">return </span><span class="s2">fixer.removeRange([</span>
							<span class="s2">token.range[</span><span class="s6">1</span><span class="s2">],</span>
							<span class="s2">nextToken.range[</span><span class="s6">0</span><span class="s2">],</span>
						<span class="s2">]);</span>
					<span class="s2">},</span>
				<span class="s2">});</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Parses the option object and determines check methods for each keyword.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object|undefined} options The option object to parse.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Object} - Normalized option object.</span>
		 <span class="s0">*      Keys are keywords (there are for every keyword).</span>
		 <span class="s0">*      Values are instances of `{&quot;before&quot;: function, &quot;after&quot;: function}`.</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">parseOptions(options = {}) {</span>
			<span class="s4">const </span><span class="s2">before = options.before !== </span><span class="s4">false</span><span class="s2">;</span>
			<span class="s4">const </span><span class="s2">after = options.after !== </span><span class="s4">false</span><span class="s2">;</span>
			<span class="s4">const </span><span class="s2">defaultValue = {</span>
				<span class="s2">before: before ? expectSpaceBefore : unexpectSpaceBefore,</span>
				<span class="s2">after: after ? expectSpaceAfter : unexpectSpaceAfter,</span>
			<span class="s2">};</span>
			<span class="s4">const </span><span class="s2">overrides = (options &amp;&amp; options.overrides) || {};</span>
			<span class="s4">const </span><span class="s2">retv = Object.create(</span><span class="s4">null</span><span class="s2">);</span>

			<span class="s4">for </span><span class="s2">(</span><span class="s4">let </span><span class="s2">i = </span><span class="s6">0</span><span class="s2">; i &lt; KEYS.length; ++i) {</span>
				<span class="s4">const </span><span class="s2">key = KEYS[i];</span>
				<span class="s4">const </span><span class="s2">override = overrides[key];</span>

				<span class="s4">if </span><span class="s2">(override) {</span>
					<span class="s4">const </span><span class="s2">thisBefore =</span>
						<span class="s3">&quot;before&quot; </span><span class="s4">in </span><span class="s2">override ? override.before : before;</span>
					<span class="s4">const </span><span class="s2">thisAfter =</span>
						<span class="s3">&quot;after&quot; </span><span class="s4">in </span><span class="s2">override ? override.after : after;</span>

					<span class="s2">retv[key] = {</span>
						<span class="s2">before: thisBefore</span>
							<span class="s2">? expectSpaceBefore</span>
							<span class="s2">: unexpectSpaceBefore,</span>
						<span class="s2">after: thisAfter</span>
							<span class="s2">? expectSpaceAfter</span>
							<span class="s2">: unexpectSpaceAfter,</span>
					<span class="s2">};</span>
				<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
					<span class="s2">retv[key] = defaultValue;</span>
				<span class="s2">}</span>
			<span class="s2">}</span>

			<span class="s4">return </span><span class="s2">retv;</span>
		<span class="s2">}</span>

		<span class="s4">const </span><span class="s2">checkMethodMap = parseOptions(context.options[</span><span class="s6">0</span><span class="s2">]);</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports a given token if usage of spacing followed by the token is</span>
		 <span class="s0">* invalid.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} token A token to report.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{RegExp} [pattern] Optional. A pattern of the previous</span>
		 <span class="s0">*      token to check.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkSpacingBefore(token, pattern) {</span>
			<span class="s2">checkMethodMap[token.value].before(token, pattern || PREV_TOKEN);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports a given token if usage of spacing preceded by the token is</span>
		 <span class="s0">* invalid.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} token A token to report.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{RegExp} [pattern] Optional. A pattern of the next</span>
		 <span class="s0">*      token to check.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkSpacingAfter(token, pattern) {</span>
			<span class="s2">checkMethodMap[token.value].after(token, pattern || NEXT_TOKEN);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports a given token if usage of spacing around the token is invalid.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} token A token to report.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkSpacingAround(token) {</span>
			<span class="s2">checkSpacingBefore(token);</span>
			<span class="s2">checkSpacingAfter(token);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports the first token of a given node if the first token is a keyword</span>
		 <span class="s0">* and usage of spacing around the token is invalid.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode|null} node A node to report.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkSpacingAroundFirstToken(node) {</span>
			<span class="s4">const </span><span class="s2">firstToken = node &amp;&amp; sourceCode.getFirstToken(node);</span>

			<span class="s4">if </span><span class="s2">(firstToken &amp;&amp; firstToken.type === </span><span class="s3">&quot;Keyword&quot;</span><span class="s2">) {</span>
				<span class="s2">checkSpacingAround(firstToken);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports the first token of a given node if the first token is a keyword</span>
		 <span class="s0">* and usage of spacing followed by the token is invalid.</span>
		 <span class="s0">*</span>
		 <span class="s0">* This is used for unary operators (e.g. `typeof`), `function`, and `super`.</span>
		 <span class="s0">* Other rules are handling usage of spacing preceded by those keywords.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode|null} node A node to report.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkSpacingBeforeFirstToken(node) {</span>
			<span class="s4">const </span><span class="s2">firstToken = node &amp;&amp; sourceCode.getFirstToken(node);</span>

			<span class="s4">if </span><span class="s2">(firstToken &amp;&amp; firstToken.type === </span><span class="s3">&quot;Keyword&quot;</span><span class="s2">) {</span>
				<span class="s2">checkSpacingBefore(firstToken);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports the previous token of a given node if the token is a keyword and</span>
		 <span class="s0">* usage of spacing around the token is invalid.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode|null} node A node to report.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkSpacingAroundTokenBefore(node) {</span>
			<span class="s4">if </span><span class="s2">(node) {</span>
				<span class="s4">const </span><span class="s2">token = sourceCode.getTokenBefore(</span>
					<span class="s2">node,</span>
					<span class="s2">astUtils.isKeywordToken,</span>
				<span class="s2">);</span>

				<span class="s2">checkSpacingAround(token);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports `async` or `function` keywords of a given node if usage of</span>
		 <span class="s0">* spacing around those keywords is invalid.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node A node to report.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkSpacingForFunction(node) {</span>
			<span class="s4">const </span><span class="s2">firstToken = node &amp;&amp; sourceCode.getFirstToken(node);</span>

			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">firstToken &amp;&amp;</span>
				<span class="s2">((firstToken.type === </span><span class="s3">&quot;Keyword&quot; </span><span class="s2">&amp;&amp;</span>
					<span class="s2">firstToken.value === </span><span class="s3">&quot;function&quot;</span><span class="s2">) ||</span>
					<span class="s2">firstToken.value === </span><span class="s3">&quot;async&quot;</span><span class="s2">)</span>
			<span class="s2">) {</span>
				<span class="s2">checkSpacingBefore(firstToken);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports `class` and `extends` keywords of a given node if usage of</span>
		 <span class="s0">* spacing around those keywords is invalid.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node A node to report.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkSpacingForClass(node) {</span>
			<span class="s2">checkSpacingAroundFirstToken(node);</span>
			<span class="s2">checkSpacingAroundTokenBefore(node.superClass);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports `if` and `else` keywords of a given node if usage of spacing</span>
		 <span class="s0">* around those keywords is invalid.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node A node to report.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkSpacingForIfStatement(node) {</span>
			<span class="s2">checkSpacingAroundFirstToken(node);</span>
			<span class="s2">checkSpacingAroundTokenBefore(node.alternate);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports `try`, `catch`, and `finally` keywords of a given node if usage</span>
		 <span class="s0">* of spacing around those keywords is invalid.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node A node to report.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkSpacingForTryStatement(node) {</span>
			<span class="s2">checkSpacingAroundFirstToken(node);</span>
			<span class="s2">checkSpacingAroundFirstToken(node.handler);</span>
			<span class="s2">checkSpacingAroundTokenBefore(node.finalizer);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports `do` and `while` keywords of a given node if usage of spacing</span>
		 <span class="s0">* around those keywords is invalid.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node A node to report.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkSpacingForDoWhileStatement(node) {</span>
			<span class="s2">checkSpacingAroundFirstToken(node);</span>
			<span class="s2">checkSpacingAroundTokenBefore(node.test);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports `for` and `in` keywords of a given node if usage of spacing</span>
		 <span class="s0">* around those keywords is invalid.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node A node to report.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkSpacingForForInStatement(node) {</span>
			<span class="s2">checkSpacingAroundFirstToken(node);</span>

			<span class="s4">const </span><span class="s2">inToken = sourceCode.getTokenBefore(</span>
				<span class="s2">node.right,</span>
				<span class="s2">astUtils.isNotOpeningParenToken,</span>
			<span class="s2">);</span>
			<span class="s4">const </span><span class="s2">previousToken = sourceCode.getTokenBefore(inToken);</span>

			<span class="s4">if </span><span class="s2">(previousToken.type !== </span><span class="s3">&quot;PrivateIdentifier&quot;</span><span class="s2">) {</span>
				<span class="s2">checkSpacingBefore(inToken);</span>
			<span class="s2">}</span>

			<span class="s2">checkSpacingAfter(inToken);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports `for` and `of` keywords of a given node if usage of spacing</span>
		 <span class="s0">* around those keywords is invalid.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node A node to report.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkSpacingForForOfStatement(node) {</span>
			<span class="s4">if </span><span class="s2">(node.await) {</span>
				<span class="s2">checkSpacingBefore(sourceCode.getFirstToken(node, </span><span class="s6">0</span><span class="s2">));</span>
				<span class="s2">checkSpacingAfter(sourceCode.getFirstToken(node, </span><span class="s6">1</span><span class="s2">));</span>
			<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
				<span class="s2">checkSpacingAroundFirstToken(node);</span>
			<span class="s2">}</span>

			<span class="s4">const </span><span class="s2">ofToken = sourceCode.getTokenBefore(</span>
				<span class="s2">node.right,</span>
				<span class="s2">astUtils.isNotOpeningParenToken,</span>
			<span class="s2">);</span>
			<span class="s4">const </span><span class="s2">previousToken = sourceCode.getTokenBefore(ofToken);</span>

			<span class="s4">if </span><span class="s2">(previousToken.type !== </span><span class="s3">&quot;PrivateIdentifier&quot;</span><span class="s2">) {</span>
				<span class="s2">checkSpacingBefore(ofToken);</span>
			<span class="s2">}</span>

			<span class="s2">checkSpacingAfter(ofToken);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports `import`, `export`, `as`, and `from` keywords of a given node if</span>
		 <span class="s0">* usage of spacing around those keywords is invalid.</span>
		 <span class="s0">*</span>
		 <span class="s0">* This rule handles the `*` token in module declarations.</span>
		 <span class="s0">*</span>
		 <span class="s0">*     import*as A from &quot;./a&quot;; /*error Expected space(s) after &quot;import&quot;.</span>
		 <span class="s0">*                               error Expected space(s) before &quot;as&quot;.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node A node to report.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkSpacingForModuleDeclaration(node) {</span>
			<span class="s4">const </span><span class="s2">firstToken = sourceCode.getFirstToken(node);</span>

			<span class="s2">checkSpacingBefore(firstToken, PREV_TOKEN_M);</span>
			<span class="s2">checkSpacingAfter(firstToken, NEXT_TOKEN_M);</span>

			<span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">&quot;ExportDefaultDeclaration&quot;</span><span class="s2">) {</span>
				<span class="s2">checkSpacingAround(sourceCode.getTokenAfter(firstToken));</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">&quot;ExportAllDeclaration&quot; </span><span class="s2">&amp;&amp; node.exported) {</span>
				<span class="s4">const </span><span class="s2">asToken = sourceCode.getTokenBefore(node.exported);</span>

				<span class="s2">checkSpacingBefore(asToken, PREV_TOKEN_M);</span>
				<span class="s2">checkSpacingAfter(asToken, NEXT_TOKEN_M);</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(node.source) {</span>
				<span class="s4">const </span><span class="s2">fromToken = sourceCode.getTokenBefore(node.source);</span>

				<span class="s2">checkSpacingBefore(fromToken, PREV_TOKEN_M);</span>
				<span class="s2">checkSpacingAfter(fromToken, NEXT_TOKEN_M);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports `as` keyword of a given node if usage of spacing around this</span>
		 <span class="s0">* keyword is invalid.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node An `ImportSpecifier` node to check.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkSpacingForImportSpecifier(node) {</span>
			<span class="s4">if </span><span class="s2">(node.imported.range[</span><span class="s6">0</span><span class="s2">] !== node.local.range[</span><span class="s6">0</span><span class="s2">]) {</span>
				<span class="s4">const </span><span class="s2">asToken = sourceCode.getTokenBefore(node.local);</span>

				<span class="s2">checkSpacingBefore(asToken, PREV_TOKEN_M);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports `as` keyword of a given node if usage of spacing around this</span>
		 <span class="s0">* keyword is invalid.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node An `ExportSpecifier` node to check.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkSpacingForExportSpecifier(node) {</span>
			<span class="s4">if </span><span class="s2">(node.local.range[</span><span class="s6">0</span><span class="s2">] !== node.exported.range[</span><span class="s6">0</span><span class="s2">]) {</span>
				<span class="s4">const </span><span class="s2">asToken = sourceCode.getTokenBefore(node.exported);</span>

				<span class="s2">checkSpacingBefore(asToken, PREV_TOKEN_M);</span>
				<span class="s2">checkSpacingAfter(asToken, NEXT_TOKEN_M);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports `as` keyword of a given node if usage of spacing around this</span>
		 <span class="s0">* keyword is invalid.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node A node to report.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkSpacingForImportNamespaceSpecifier(node) {</span>
			<span class="s4">const </span><span class="s2">asToken = sourceCode.getFirstToken(node, </span><span class="s6">1</span><span class="s2">);</span>

			<span class="s2">checkSpacingBefore(asToken, PREV_TOKEN_M);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports `static`, `get`, and `set` keywords of a given node if usage of</span>
		 <span class="s0">* spacing around those keywords is invalid.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node A node to report.</span>
		 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If unable to find token get, set, or async beside method name.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkSpacingForProperty(node) {</span>
			<span class="s4">if </span><span class="s2">(node.static) {</span>
				<span class="s2">checkSpacingAroundFirstToken(node);</span>
			<span class="s2">}</span>
			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">node.kind === </span><span class="s3">&quot;get&quot; </span><span class="s2">||</span>
				<span class="s2">node.kind === </span><span class="s3">&quot;set&quot; </span><span class="s2">||</span>
				<span class="s2">((node.method || node.type === </span><span class="s3">&quot;MethodDefinition&quot;</span><span class="s2">) &amp;&amp;</span>
					<span class="s2">node.value.async)</span>
			<span class="s2">) {</span>
				<span class="s4">const </span><span class="s2">token = sourceCode.getTokenBefore(node.key, tok =&gt; {</span>
					<span class="s4">switch </span><span class="s2">(tok.value) {</span>
						<span class="s4">case </span><span class="s3">&quot;get&quot;</span><span class="s2">:</span>
						<span class="s4">case </span><span class="s3">&quot;set&quot;</span><span class="s2">:</span>
						<span class="s4">case </span><span class="s3">&quot;async&quot;</span><span class="s2">:</span>
							<span class="s4">return true</span><span class="s2">;</span>
						<span class="s4">default</span><span class="s2">:</span>
							<span class="s4">return false</span><span class="s2">;</span>
					<span class="s2">}</span>
				<span class="s2">});</span>

				<span class="s4">if </span><span class="s2">(!token) {</span>
					<span class="s4">throw new </span><span class="s2">Error(</span>
						<span class="s3">&quot;Failed to find token get, set, or async beside method name&quot;</span><span class="s2">,</span>
					<span class="s2">);</span>
				<span class="s2">}</span>

				<span class="s2">checkSpacingAround(token);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports `await` keyword of a given node if usage of spacing before</span>
		 <span class="s0">* this keyword is invalid.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node A node to report.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkSpacingForAwaitExpression(node) {</span>
			<span class="s2">checkSpacingBefore(sourceCode.getFirstToken(node));</span>
		<span class="s2">}</span>

		<span class="s4">return </span><span class="s2">{</span>
			<span class="s0">// Statements</span>
			<span class="s2">DebuggerStatement: checkSpacingAroundFirstToken,</span>
			<span class="s2">WithStatement: checkSpacingAroundFirstToken,</span>

			<span class="s0">// Statements - Control flow</span>
			<span class="s2">BreakStatement: checkSpacingAroundFirstToken,</span>
			<span class="s2">ContinueStatement: checkSpacingAroundFirstToken,</span>
			<span class="s2">ReturnStatement: checkSpacingAroundFirstToken,</span>
			<span class="s2">ThrowStatement: checkSpacingAroundFirstToken,</span>
			<span class="s2">TryStatement: checkSpacingForTryStatement,</span>

			<span class="s0">// Statements - Choice</span>
			<span class="s2">IfStatement: checkSpacingForIfStatement,</span>
			<span class="s2">SwitchStatement: checkSpacingAroundFirstToken,</span>
			<span class="s2">SwitchCase: checkSpacingAroundFirstToken,</span>

			<span class="s0">// Statements - Loops</span>
			<span class="s2">DoWhileStatement: checkSpacingForDoWhileStatement,</span>
			<span class="s2">ForInStatement: checkSpacingForForInStatement,</span>
			<span class="s2">ForOfStatement: checkSpacingForForOfStatement,</span>
			<span class="s2">ForStatement: checkSpacingAroundFirstToken,</span>
			<span class="s2">WhileStatement: checkSpacingAroundFirstToken,</span>

			<span class="s0">// Statements - Declarations</span>
			<span class="s2">ClassDeclaration: checkSpacingForClass,</span>
			<span class="s2">ExportNamedDeclaration: checkSpacingForModuleDeclaration,</span>
			<span class="s2">ExportDefaultDeclaration: checkSpacingForModuleDeclaration,</span>
			<span class="s2">ExportAllDeclaration: checkSpacingForModuleDeclaration,</span>
			<span class="s2">FunctionDeclaration: checkSpacingForFunction,</span>
			<span class="s2">ImportDeclaration: checkSpacingForModuleDeclaration,</span>
			<span class="s2">VariableDeclaration: checkSpacingAroundFirstToken,</span>

			<span class="s0">// Expressions</span>
			<span class="s2">ArrowFunctionExpression: checkSpacingForFunction,</span>
			<span class="s2">AwaitExpression: checkSpacingForAwaitExpression,</span>
			<span class="s2">ClassExpression: checkSpacingForClass,</span>
			<span class="s2">FunctionExpression: checkSpacingForFunction,</span>
			<span class="s2">NewExpression: checkSpacingBeforeFirstToken,</span>
			<span class="s2">Super: checkSpacingBeforeFirstToken,</span>
			<span class="s2">ThisExpression: checkSpacingBeforeFirstToken,</span>
			<span class="s2">UnaryExpression: checkSpacingBeforeFirstToken,</span>
			<span class="s2">YieldExpression: checkSpacingBeforeFirstToken,</span>

			<span class="s0">// Others</span>
			<span class="s2">ImportSpecifier: checkSpacingForImportSpecifier,</span>
			<span class="s2">ExportSpecifier: checkSpacingForExportSpecifier,</span>
			<span class="s2">ImportNamespaceSpecifier: checkSpacingForImportNamespaceSpecifier,</span>
			<span class="s2">MethodDefinition: checkSpacingForProperty,</span>
			<span class="s2">PropertyDefinition: checkSpacingForProperty,</span>
			<span class="s2">StaticBlock: checkSpacingAroundFirstToken,</span>
			<span class="s2">Property: checkSpacingForProperty,</span>

			<span class="s0">// To avoid conflicts with `space-infix-ops`, e.g. `a &gt; this.b`</span>
			<span class="s3">&quot;BinaryExpression[operator='&gt;']&quot;</span><span class="s2">(node) {</span>
				<span class="s4">const </span><span class="s2">operatorToken = sourceCode.getTokenBefore(</span>
					<span class="s2">node.right,</span>
					<span class="s2">astUtils.isNotOpeningParenToken,</span>
				<span class="s2">);</span>

				<span class="s2">tokensToIgnore.add(operatorToken);</span>
			<span class="s2">},</span>
		<span class="s2">};</span>
	<span class="s2">},</span>
<span class="s2">};</span>
</pre>
</body>
</html>