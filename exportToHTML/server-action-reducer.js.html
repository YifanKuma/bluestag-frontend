<html>
<head>
<title>server-action-reducer.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
server-action-reducer.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;serverActionReducer&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">serverActionReducer;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_appcallserver = require(</span><span class="s0">&quot;../../../app-call-server&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_appfindsourcemapurl = require(</span><span class="s0">&quot;../../../app-find-source-map-url&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_approuterheaders = require(</span><span class="s0">&quot;../../app-router-headers&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_unrecognizedactionerror = require(</span><span class="s0">&quot;../../unrecognized-action-error&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_client = require(</span><span class="s0">&quot;react-server-dom-webpack/client&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_routerreducertypes = require(</span><span class="s0">&quot;../router-reducer-types&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_assignlocation = require(</span><span class="s0">&quot;../../../assign-location&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_createhreffromurl = require(</span><span class="s0">&quot;../create-href-from-url&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_navigatereducer = require(</span><span class="s0">&quot;./navigate-reducer&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_applyrouterstatepatchtotree = require(</span><span class="s0">&quot;../apply-router-state-patch-to-tree&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_isnavigatingtonewrootlayout = require(</span><span class="s0">&quot;../is-navigating-to-new-root-layout&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_handlemutable = require(</span><span class="s0">&quot;../handle-mutable&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_filllazyitemstillleafwithhead = require(</span><span class="s0">&quot;../fill-lazy-items-till-leaf-with-head&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_approuter = require(</span><span class="s0">&quot;../../app-router&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_hasinterceptionrouteincurrenttree = require(</span><span class="s0">&quot;./has-interception-route-in-current-tree&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_handlesegmentmismatch = require(</span><span class="s0">&quot;../handle-segment-mismatch&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_refetchinactiveparallelsegments = require(</span><span class="s0">&quot;../refetch-inactive-parallel-segments&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_flightdatahelpers = require(</span><span class="s0">&quot;../../../flight-data-helpers&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_redirect = require(</span><span class="s0">&quot;../../redirect&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_redirecterror = require(</span><span class="s0">&quot;../../redirect-error&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_prefetchcacheutils = require(</span><span class="s0">&quot;../prefetch-cache-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_removebasepath = require(</span><span class="s0">&quot;../../../remove-base-path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_hasbasepath = require(</span><span class="s0">&quot;../../../has-base-path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_serverreferenceinfo = require(</span><span class="s0">&quot;../../../../shared/lib/server-reference-info&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_segmentcache = require(</span><span class="s0">&quot;../../segment-cache&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">createFromFetch = _client.createFromFetch;</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">fetchServerAction(state, nextUrl, param) {</span>
    <span class="s2">let </span><span class="s1">{ actionId, actionArgs } = param;</span>
    <span class="s2">const </span><span class="s1">temporaryReferences = (</span><span class="s3">0</span><span class="s1">, _client.createTemporaryReferenceSet)();</span>
    <span class="s2">const </span><span class="s1">info = (</span><span class="s3">0</span><span class="s1">, _serverreferenceinfo.extractInfoFromServerReferenceId)(actionId);</span>
    <span class="s4">// TODO: Currently, we're only omitting unused args for the experimental &quot;use</span>
    <span class="s4">// cache&quot; functions. Once the server reference info byte feature is stable, we</span>
    <span class="s4">// should apply this to server actions as well.</span>
    <span class="s2">const </span><span class="s1">usedArgs = info.type === </span><span class="s0">'use-cache' </span><span class="s1">? (</span><span class="s3">0</span><span class="s1">, _serverreferenceinfo.omitUnusedArgs)(actionArgs, info) : actionArgs;</span>
    <span class="s2">const </span><span class="s1">body = </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _client.encodeReply)(usedArgs, {</span>
        <span class="s1">temporaryReferences</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">res = </span><span class="s2">await </span><span class="s1">fetch(state.canonicalUrl, {</span>
        <span class="s1">method: </span><span class="s0">'POST'</span><span class="s1">,</span>
        <span class="s1">headers: {</span>
            <span class="s1">Accept: _approuterheaders.RSC_CONTENT_TYPE_HEADER,</span>
            <span class="s1">[_approuterheaders.ACTION_HEADER]: actionId,</span>
            <span class="s1">[_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: (</span><span class="s3">0</span><span class="s1">, _flightdatahelpers.prepareFlightRouterStateForRequest)(state.tree),</span>
            <span class="s1">...process.env.NEXT_DEPLOYMENT_ID ? {</span>
                <span class="s0">'x-deployment-id'</span><span class="s1">: process.env.NEXT_DEPLOYMENT_ID</span>
            <span class="s1">} : {},</span>
            <span class="s1">...nextUrl ? {</span>
                <span class="s1">[_approuterheaders.NEXT_URL]: nextUrl</span>
            <span class="s1">} : {}</span>
        <span class="s1">},</span>
        <span class="s1">body</span>
    <span class="s1">});</span>
    <span class="s4">// Handle server actions that the server didn't recognize.</span>
    <span class="s2">const </span><span class="s1">unrecognizedActionHeader = res.headers.get(_approuterheaders.NEXT_ACTION_NOT_FOUND_HEADER);</span>
    <span class="s2">if </span><span class="s1">(unrecognizedActionHeader === </span><span class="s0">'1'</span><span class="s1">) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_unrecognizedactionerror.UnrecognizedActionError(</span><span class="s0">'Server Action &quot;' </span><span class="s1">+ actionId + </span><span class="s0">'&quot; was not found on the server. </span><span class="s5">\n</span><span class="s0">Read more: https://nextjs.org/docs/messages/failed-to-find-server-action'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E715&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">redirectHeader = res.headers.get(</span><span class="s0">'x-action-redirect'</span><span class="s1">);</span>
    <span class="s2">const </span><span class="s1">[location, _redirectType] = (redirectHeader == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: redirectHeader.split(</span><span class="s0">';'</span><span class="s1">)) || [];</span>
    <span class="s2">let </span><span class="s1">redirectType;</span>
    <span class="s2">switch</span><span class="s1">(_redirectType){</span>
        <span class="s2">case </span><span class="s0">'push'</span><span class="s1">:</span>
            <span class="s1">redirectType = _redirecterror.RedirectType.push;</span>
            <span class="s2">break</span><span class="s1">;</span>
        <span class="s2">case </span><span class="s0">'replace'</span><span class="s1">:</span>
            <span class="s1">redirectType = _redirecterror.RedirectType.replace;</span>
            <span class="s2">break</span><span class="s1">;</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s1">redirectType = undefined;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">isPrerender = !!res.headers.get(_approuterheaders.NEXT_IS_PRERENDER_HEADER);</span>
    <span class="s2">let </span><span class="s1">revalidatedParts;</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">revalidatedHeader = JSON.parse(res.headers.get(</span><span class="s0">'x-action-revalidated'</span><span class="s1">) || </span><span class="s0">'[[],0,0]'</span><span class="s1">);</span>
        <span class="s1">revalidatedParts = {</span>
            <span class="s1">paths: revalidatedHeader[</span><span class="s3">0</span><span class="s1">] || [],</span>
            <span class="s1">tag: !!revalidatedHeader[</span><span class="s3">1</span><span class="s1">],</span>
            <span class="s1">cookie: revalidatedHeader[</span><span class="s3">2</span><span class="s1">]</span>
        <span class="s1">};</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
        <span class="s1">revalidatedParts = NO_REVALIDATED_PARTS;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">redirectLocation = location ? (</span><span class="s3">0</span><span class="s1">, _assignlocation.assignLocation)(location, </span><span class="s2">new </span><span class="s1">URL(state.canonicalUrl, window.location.href)) : undefined;</span>
    <span class="s2">const </span><span class="s1">contentType = res.headers.get(</span><span class="s0">'content-type'</span><span class="s1">);</span>
    <span class="s2">const </span><span class="s1">isRscResponse = !!(contentType &amp;&amp; contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER));</span>
    <span class="s4">// Handle invalid server action responses.</span>
    <span class="s4">// A valid response must have `content-type: text/x-component`, unless it's an external redirect.</span>
    <span class="s4">// (external redirects have an 'x-action-redirect' header, but the body is an empty 'text/plain')</span>
    <span class="s2">if </span><span class="s1">(!isRscResponse &amp;&amp; !redirectLocation) {</span>
        <span class="s4">// The server can respond with a text/plain error message, but we'll fallback to something generic</span>
        <span class="s4">// if there isn't one.</span>
        <span class="s2">const </span><span class="s1">message = res.status &gt;= </span><span class="s3">400 </span><span class="s1">&amp;&amp; contentType === </span><span class="s0">'text/plain' </span><span class="s1">? </span><span class="s2">await </span><span class="s1">res.text() : </span><span class="s0">'An unexpected response was received from the server.'</span><span class="s1">;</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(message), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E394&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">actionResult;</span>
    <span class="s2">let </span><span class="s1">actionFlightData;</span>
    <span class="s2">if </span><span class="s1">(isRscResponse) {</span>
        <span class="s2">const </span><span class="s1">response = </span><span class="s2">await </span><span class="s1">createFromFetch(Promise.resolve(res), {</span>
            <span class="s1">callServer: _appcallserver.callServer,</span>
            <span class="s1">findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,</span>
            <span class="s1">temporaryReferences</span>
        <span class="s1">});</span>
        <span class="s4">// An internal redirect can send an RSC response, but does not have a useful `actionResult`.</span>
        <span class="s1">actionResult = redirectLocation ? undefined : response.a;</span>
        <span class="s1">actionFlightData = (</span><span class="s3">0</span><span class="s1">, _flightdatahelpers.normalizeFlightData)(response.f);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s4">// An external redirect doesn't contain RSC data.</span>
        <span class="s1">actionResult = undefined;</span>
        <span class="s1">actionFlightData = undefined;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">actionResult,</span>
        <span class="s1">actionFlightData,</span>
        <span class="s1">redirectLocation,</span>
        <span class="s1">redirectType,</span>
        <span class="s1">revalidatedParts,</span>
        <span class="s1">isPrerender</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">NO_REVALIDATED_PARTS = {</span>
    <span class="s1">paths: [],</span>
    <span class="s1">tag: </span><span class="s2">false</span><span class="s1">,</span>
    <span class="s1">cookie: </span><span class="s2">false</span>
<span class="s1">};</span>
<span class="s2">function </span><span class="s1">serverActionReducer(state, action) {</span>
    <span class="s2">const </span><span class="s1">{ resolve, reject } = action;</span>
    <span class="s2">const </span><span class="s1">mutable = {};</span>
    <span class="s2">let </span><span class="s1">currentTree = state.tree;</span>
    <span class="s1">mutable.preserveCustomHistoryState = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s4">// only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.</span>
    <span class="s4">// If the route has been intercepted, the action should be as well.</span>
    <span class="s4">// Otherwise the server action might be intercepted with the wrong action id</span>
    <span class="s4">// (ie, one that corresponds with the intercepted route)</span>
    <span class="s2">const </span><span class="s1">nextUrl = state.nextUrl &amp;&amp; (</span><span class="s3">0</span><span class="s1">, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree) ? state.nextUrl : </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">navigatedAt = Date.now();</span>
    <span class="s2">return </span><span class="s1">fetchServerAction(state, nextUrl, action).then(async (param)=&gt;{</span>
        <span class="s2">let </span><span class="s1">{ actionResult, actionFlightData: flightData, redirectLocation, redirectType, isPrerender, revalidatedParts } = param;</span>
        <span class="s2">let </span><span class="s1">redirectHref;</span>
        <span class="s4">// honor the redirect type instead of defaulting to push in case of server actions.</span>
        <span class="s2">if </span><span class="s1">(redirectLocation) {</span>
            <span class="s2">if </span><span class="s1">(redirectType === _redirecterror.RedirectType.replace) {</span>
                <span class="s1">state.pushRef.pendingPush = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s1">mutable.pendingPush = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">state.pushRef.pendingPush = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">mutable.pendingPush = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">redirectHref = (</span><span class="s3">0</span><span class="s1">, _createhreffromurl.createHrefFromUrl)(redirectLocation, </span><span class="s2">false</span><span class="s1">);</span>
            <span class="s1">mutable.canonicalUrl = redirectHref;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!flightData) {</span>
            <span class="s1">resolve(actionResult);</span>
            <span class="s4">// If there is a redirect but no flight data we need to do a mpaNavigation.</span>
            <span class="s2">if </span><span class="s1">(redirectLocation) {</span>
                <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _navigatereducer.handleExternalUrl)(state, mutable, redirectLocation.href, state.pushRef.pendingPush);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">state;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">flightData === </span><span class="s0">'string'</span><span class="s1">) {</span>
            <span class="s4">// Handle case when navigating to page in `pages` from `app`</span>
            <span class="s1">resolve(actionResult);</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">actionRevalidated = revalidatedParts.paths.length &gt; </span><span class="s3">0 </span><span class="s1">|| revalidatedParts.tag || revalidatedParts.cookie;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">normalizedFlightData of flightData){</span>
            <span class="s2">const </span><span class="s1">{ tree: treePatch, seedData: cacheNodeSeedData, head, isRootRender } = normalizedFlightData;</span>
            <span class="s2">if </span><span class="s1">(!isRootRender) {</span>
                <span class="s4">// TODO-APP: handle this case better</span>
                <span class="s1">console.log(</span><span class="s0">'SERVER ACTION APPLY FAILED'</span><span class="s1">);</span>
                <span class="s1">resolve(actionResult);</span>
                <span class="s2">return </span><span class="s1">state;</span>
            <span class="s1">}</span>
            <span class="s4">// Given the path can only have two items the items are only the router state and rsc for the root.</span>
            <span class="s2">const </span><span class="s1">newTree = (</span><span class="s3">0</span><span class="s1">, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(</span><span class="s4">// TODO-APP: remove ''</span>
            <span class="s1">[</span>
                <span class="s0">''</span>
            <span class="s1">], currentTree, treePatch, redirectHref ? redirectHref : state.canonicalUrl);</span>
            <span class="s2">if </span><span class="s1">(newTree === </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s1">resolve(actionResult);</span>
                <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {</span>
                <span class="s1">resolve(actionResult);</span>
                <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _navigatereducer.handleExternalUrl)(state, mutable, redirectHref || state.canonicalUrl, state.pushRef.pendingPush);</span>
            <span class="s1">}</span>
            <span class="s4">// The server sent back RSC data for the server action, so we need to apply it to the cache.</span>
            <span class="s2">if </span><span class="s1">(cacheNodeSeedData !== </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">const </span><span class="s1">rsc = cacheNodeSeedData[</span><span class="s3">1</span><span class="s1">];</span>
                <span class="s2">const </span><span class="s1">cache = (</span><span class="s3">0</span><span class="s1">, _approuter.createEmptyCacheNode)();</span>
                <span class="s1">cache.rsc = rsc;</span>
                <span class="s1">cache.prefetchRsc = </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s1">cache.loading = cacheNodeSeedData[</span><span class="s3">3</span><span class="s1">];</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, cache, </span><span class="s4">// Existing cache is not passed in as server actions have to invalidate the entire cache.</span>
                <span class="s1">undefined, treePatch, cacheNodeSeedData, head, undefined);</span>
                <span class="s1">mutable.cache = cache;</span>
                <span class="s2">if </span><span class="s1">(process.env.__NEXT_CLIENT_SEGMENT_CACHE) {</span>
                    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _segmentcache.revalidateEntireCache)(state.nextUrl, newTree);</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">mutable.prefetchCache = </span><span class="s2">new </span><span class="s1">Map();</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(actionRevalidated) {</span>
                    <span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({</span>
                        <span class="s1">navigatedAt,</span>
                        <span class="s1">state,</span>
                        <span class="s1">updatedTree: newTree,</span>
                        <span class="s1">updatedCache: cache,</span>
                        <span class="s1">includeNextUrl: Boolean(nextUrl),</span>
                        <span class="s1">canonicalUrl: mutable.canonicalUrl || state.canonicalUrl</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">mutable.patchedTree = newTree;</span>
            <span class="s1">currentTree = newTree;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(redirectLocation &amp;&amp; redirectHref) {</span>
            <span class="s2">if </span><span class="s1">(!process.env.__NEXT_CLIENT_SEGMENT_CACHE &amp;&amp; !actionRevalidated) {</span>
                <span class="s4">// Because the RedirectBoundary will trigger a navigation, we need to seed the prefetch cache</span>
                <span class="s4">// with the FlightData that we got from the server action for the target page, so that it's</span>
                <span class="s4">// available when the page is navigated to and doesn't need to be re-fetched.</span>
                <span class="s4">// We only do this if the server action didn't revalidate any data, as in that case the</span>
                <span class="s4">// client cache will be cleared and the data will be re-fetched anyway.</span>
                <span class="s4">// NOTE: We don't do this in the Segment Cache implementation.</span>
                <span class="s4">// Dynamic data should never be placed into the cache, unless it's</span>
                <span class="s4">// &quot;converted&quot; to static data using &lt;Link prefetch={true}&gt;. What we</span>
                <span class="s4">// do instead is re-prefetch links and forms whenever the cache is</span>
                <span class="s4">// invalidated.</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _prefetchcacheutils.createSeededPrefetchCacheEntry)({</span>
                    <span class="s1">url: redirectLocation,</span>
                    <span class="s1">data: {</span>
                        <span class="s1">flightData,</span>
                        <span class="s1">canonicalUrl: undefined,</span>
                        <span class="s1">couldBeIntercepted: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">prerendered: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">postponed: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s4">// TODO: We should be able to set this if the server action</span>
                        <span class="s4">// returned a fully static response.</span>
                        <span class="s1">staleTime: -</span><span class="s3">1</span>
                    <span class="s1">},</span>
                    <span class="s1">tree: state.tree,</span>
                    <span class="s1">prefetchCache: state.prefetchCache,</span>
                    <span class="s1">nextUrl: state.nextUrl,</span>
                    <span class="s1">kind: isPrerender ? _routerreducertypes.PrefetchKind.FULL : _routerreducertypes.PrefetchKind.AUTO</span>
                <span class="s1">});</span>
                <span class="s1">mutable.prefetchCache = state.prefetchCache;</span>
            <span class="s1">}</span>
            <span class="s4">// If the action triggered a redirect, the action promise will be rejected with</span>
            <span class="s4">// a redirect so that it's handled by RedirectBoundary as we won't have a valid</span>
            <span class="s4">// action result to resolve the promise with. This will effectively reset the state of</span>
            <span class="s4">// the component that called the action as the error boundary will remount the tree.</span>
            <span class="s4">// The status code doesn't matter here as the action handler will have already sent</span>
            <span class="s4">// a response with the correct status code.</span>
            <span class="s1">reject((</span><span class="s3">0</span><span class="s1">, _redirect.getRedirectError)((</span><span class="s3">0</span><span class="s1">, _hasbasepath.hasBasePath)(redirectHref) ? (</span><span class="s3">0</span><span class="s1">, _removebasepath.removeBasePath)(redirectHref) : redirectHref, redirectType || _redirecterror.RedirectType.push));</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">resolve(actionResult);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _handlemutable.handleMutable)(state, mutable);</span>
    <span class="s1">}, (e)=&gt;{</span>
        <span class="s4">// When the server action is rejected we don't update the state and instead call the reject handler of the promise.</span>
        <span class="s1">reject(e);</span>
        <span class="s2">return </span><span class="s1">state;</span>
    <span class="s1">});</span>
<span class="s1">}</span>

<span class="s2">if </span><span class="s1">((</span><span class="s2">typeof </span><span class="s1">exports.default === </span><span class="s0">'function' </span><span class="s1">|| (</span><span class="s2">typeof </span><span class="s1">exports.default === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; exports.default !== </span><span class="s2">null</span><span class="s1">)) &amp;&amp; </span><span class="s2">typeof </span><span class="s1">exports.default.__esModule === </span><span class="s0">'undefined'</span><span class="s1">) {</span>
  <span class="s1">Object.defineProperty(exports.default, </span><span class="s0">'__esModule'</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
  <span class="s1">Object.assign(exports.default, exports);</span>
  <span class="s1">module.exports = exports.default;</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=server-action-reducer.js.map</span></pre>
</body>
</html>