<html>
<head>
<title>fetch-event.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
fetch-event.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/server/web/spec-extension/fetch-event.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { WaitUntil } from '../../after/builtin-request-context'</span><span class="s3">\n</span><span class="s1">import { PageSignatureError } from '../error'</span><span class="s3">\n</span><span class="s1">import type { NextRequest } from './request'</span><span class="s3">\n\n</span><span class="s1">const responseSymbol = Symbol('response')</span><span class="s3">\n</span><span class="s1">const passThroughSymbol = Symbol('passThrough')</span><span class="s3">\n</span><span class="s1">const waitUntilSymbol = Symbol('waitUntil')</span><span class="s3">\n\n</span><span class="s1">class FetchEvent {</span><span class="s3">\n  </span><span class="s1">// TODO(after): get rid of the 'internal' variant and always use an external waitUntil</span><span class="s3">\n  </span><span class="s1">// (this means removing `FetchEventResult.waitUntil` which also requires a builder change)</span><span class="s3">\n  </span><span class="s1">readonly [waitUntilSymbol]:</span><span class="s3">\n    </span><span class="s1">| { kind: 'internal'; promises: Promise&lt;any&gt;[] }</span><span class="s3">\n    </span><span class="s1">| { kind: 'external'; function: WaitUntil };</span><span class="s3">\n\n  </span><span class="s1">[responseSymbol]?: Promise&lt;Response&gt;;</span><span class="s3">\n  </span><span class="s1">[passThroughSymbol] = false</span><span class="s3">\n\n  </span><span class="s1">constructor(_request: Request, waitUntil?: WaitUntil) {</span><span class="s3">\n    </span><span class="s1">this[waitUntilSymbol] = waitUntil</span><span class="s3">\n      </span><span class="s1">? { kind: 'external', function: waitUntil }</span><span class="s3">\n      </span><span class="s1">: { kind: 'internal', promises: [] }</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// TODO: is this dead code? NextFetchEvent never lets this get called</span><span class="s3">\n  </span><span class="s1">respondWith(response: Response | Promise&lt;Response&gt;): void {</span><span class="s3">\n    </span><span class="s1">if (!this[responseSymbol]) {</span><span class="s3">\n      </span><span class="s1">this[responseSymbol] = Promise.resolve(response)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// TODO: is this dead code? passThroughSymbol is unused</span><span class="s3">\n  </span><span class="s1">passThroughOnException(): void {</span><span class="s3">\n    </span><span class="s1">this[passThroughSymbol] = true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">waitUntil(promise: Promise&lt;any&gt;): void {</span><span class="s3">\n    </span><span class="s1">if (this[waitUntilSymbol].kind === 'external') {</span><span class="s3">\n      </span><span class="s1">// if we received an external waitUntil, we delegate to it</span><span class="s3">\n      </span><span class="s1">// TODO(after): this will make us not go through `getServerError(error, 'edge-server')` in `sandbox`</span><span class="s3">\n      </span><span class="s1">const waitUntil = this[waitUntilSymbol].function</span><span class="s3">\n      </span><span class="s1">return waitUntil(promise)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// if we didn't receive an external waitUntil, we make it work on our own</span><span class="s3">\n      </span><span class="s1">// (and expect the caller to do something with the promises)</span><span class="s3">\n      </span><span class="s1">this[waitUntilSymbol].promises.push(promise)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getWaitUntilPromiseFromEvent(</span><span class="s3">\n  </span><span class="s1">event: FetchEvent</span><span class="s3">\n</span><span class="s1">): Promise&lt;void&gt; | undefined {</span><span class="s3">\n  </span><span class="s1">return event[waitUntilSymbol].kind === 'internal'</span><span class="s3">\n    </span><span class="s1">? Promise.all(event[waitUntilSymbol].promises).then(() =&gt; {})</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class NextFetchEvent extends FetchEvent {</span><span class="s3">\n  </span><span class="s1">sourcePage: string</span><span class="s3">\n\n  </span><span class="s1">constructor(params: {</span><span class="s3">\n    </span><span class="s1">request: NextRequest</span><span class="s3">\n    </span><span class="s1">page: string</span><span class="s3">\n    </span><span class="s1">context: { waitUntil: WaitUntil } | undefined</span><span class="s3">\n  </span><span class="s1">}) {</span><span class="s3">\n    </span><span class="s1">super(params.request, params.context?.waitUntil)</span><span class="s3">\n    </span><span class="s1">this.sourcePage = params.page</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @deprecated The `request` is now the first parameter and the API is now async.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Read more: https://nextjs.org/docs/messages/middleware-new-signature</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get request() {</span><span class="s3">\n    </span><span class="s1">throw new PageSignatureError({</span><span class="s3">\n      </span><span class="s1">page: this.sourcePage,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @deprecated Using `respondWith` is no longer needed.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Read more: https://nextjs.org/docs/messages/middleware-new-signature</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">respondWith() {</span><span class="s3">\n    </span><span class="s1">throw new PageSignatureError({</span><span class="s3">\n      </span><span class="s1">page: this.sourcePage,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;NextFetchEvent&quot;</span><span class="s0">,</span><span class="s1">&quot;getWaitUntilPromiseFromEvent&quot;</span><span class="s0">,</span><span class="s1">&quot;responseSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;passThroughSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;waitUntilSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;FetchEvent&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;_request&quot;</span><span class="s0">,</span><span class="s1">&quot;waitUntil&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;function&quot;</span><span class="s0">,</span><span class="s1">&quot;promises&quot;</span><span class="s0">,</span><span class="s1">&quot;respondWith&quot;</span><span class="s0">,</span><span class="s1">&quot;response&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;passThroughOnException&quot;</span><span class="s0">,</span><span class="s1">&quot;promise&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;event&quot;</span><span class="s0">,</span><span class="s1">&quot;all&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;request&quot;</span><span class="s0">,</span><span class="s1">&quot;context&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcePage&quot;</span><span class="s0">,</span><span class="s1">&quot;page&quot;</span><span class="s0">,</span><span class="s1">&quot;PageSignatureError&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;IA0DaA,cAAc;eAAdA;;IARGC,4BAA4B;eAA5BA;;;uBAjDmB;AAGnC,MAAMC,iBAAiBC,OAAO;AAC9B,MAAMC,oBAAoBD,OAAO;AACjC,MAAME,kBAAkBF,OAAO;AAE/B,MAAMG;IAUJC,YAAYC,QAAiB,EAAEC,SAAqB,CAAE;YAFtD,CAACL,kBAAkB,GAAG;QAGpB,IAAI,CAACC,gBAAgB,GAAGI,YACpB;YAAEC,MAAM;YAAYC,UAAUF;QAAU,IACxC;YAAEC,MAAM;YAAYE,UAAU,EAAE;QAAC;IACvC;IAEA,qEAAqE;IACrEC,YAAYC,QAAsC,EAAQ;QACxD,IAAI,CAAC,IAAI,CAACZ,eAAe,EAAE;YACzB,IAAI,CAACA,eAAe,GAAGa,QAAQC,OAAO,CAACF;QACzC;IACF;IAEA,uDAAuD;IACvDG,yBAA+B;QAC7B,IAAI,CAACb,kBAAkB,GAAG;IAC5B;IAEAK,UAAUS,OAAqB,EAAQ;QACrC,IAAI,IAAI,CAACb,gBAAgB,CAACK,IAAI,KAAK,YAAY;YAC7C,0DAA0D;YAC1D,oGAAoG;YACpG,MAAMD,YAAY,IAAI,CAACJ,gBAAgB,CAACM,QAAQ;YAChD,OAAOF,UAAUS;QACnB,OAAO;YACL,yEAAyE;YACzE,4DAA4D;YAC5D,IAAI,CAACb,gBAAgB,CAACO,QAAQ,CAACO,IAAI,CAACD;QACtC;IACF;AACF;AAEO,SAASjB,6BACdmB,KAAiB;IAEjB,OAAOA,KAAK,CAACf,gBAAgB,CAACK,IAAI,KAAK,aACnCK,QAAQM,GAAG,CAACD,KAAK,CAACf,gBAAgB,CAACO,QAAQ,EAAEU,IAAI,CAAC,KAAO,KACzDC;AACN;AAEO,MAAMvB,uBAAuBM;IAGlCC,YAAYiB,MAIX,CAAE;YACqBA;QAAtB,KAAK,CAACA,OAAOC,OAAO,GAAED,kBAAAA,OAAOE,OAAO,qBAAdF,gBAAgBf,SAAS;QAC/C,IAAI,CAACkB,UAAU,GAAGH,OAAOI,IAAI;IAC/B;IAEA;;;;GAIC,GACD,IAAIH,UAAU;QACZ,MAAM,qBAEJ,CAFI,IAAII,yBAAkB,CAAC;YAC3BD,MAAM,IAAI,CAACD,UAAU;QACvB,IAFM,qBAAA;mBAAA;wBAAA;0BAAA;QAEL;IACH;IAEA;;;;GAIC,GACDd,cAAc;QACZ,MAAM,qBAEJ,CAFI,IAAIgB,yBAAkB,CAAC;YAC3BD,MAAM,IAAI,CAACD,UAAU;QACvB,IAFM,qBAAA;mBAAA;wBAAA;0BAAA;QAEL;IACH;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>