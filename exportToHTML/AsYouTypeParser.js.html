<html>
<head>
<title>AsYouTypeParser.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #264eff;}
.s5 { color: #8c8c8c; font-style: italic;}
.s6 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
AsYouTypeParser.js</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">extractCountryCallingCode from </span><span class="s2">'./helpers/extractCountryCallingCode.js'</span>
<span class="s0">import </span><span class="s1">extractCountryCallingCodeFromInternationalNumberWithoutPlusSign from </span><span class="s2">'./helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js'</span>
<span class="s0">import </span><span class="s1">extractNationalNumberFromPossiblyIncompleteNumber from </span><span class="s2">'./helpers/extractNationalNumberFromPossiblyIncompleteNumber.js'</span>
<span class="s0">import </span><span class="s1">stripIddPrefix from </span><span class="s2">'./helpers/stripIddPrefix.js'</span>
<span class="s0">import </span><span class="s1">parseDigits from </span><span class="s2">'./helpers/parseDigits.js'</span>

<span class="s0">import </span><span class="s1">{</span>
	<span class="s1">VALID_DIGITS,</span>
	<span class="s1">VALID_PUNCTUATION,</span>
	<span class="s1">PLUS_CHARS</span>
<span class="s1">} from </span><span class="s2">'./constants.js'</span>

<span class="s0">const </span><span class="s1">VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART =</span>
	<span class="s2">'[' </span><span class="s1">+</span>
		<span class="s1">VALID_PUNCTUATION +</span>
		<span class="s1">VALID_DIGITS +</span>
	<span class="s2">']+'</span>

<span class="s0">const </span><span class="s1">VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN = </span><span class="s0">new </span><span class="s1">RegExp(</span><span class="s2">'^' </span><span class="s1">+ VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART + </span><span class="s2">'$'</span><span class="s1">, </span><span class="s2">'i'</span><span class="s1">)</span>

<span class="s0">const </span><span class="s1">VALID_FORMATTED_PHONE_NUMBER_PART =</span>
	<span class="s2">'(?:' </span><span class="s1">+</span>
		<span class="s2">'[' </span><span class="s1">+ PLUS_CHARS + </span><span class="s2">']' </span><span class="s1">+</span>
		<span class="s2">'[' </span><span class="s1">+</span>
			<span class="s1">VALID_PUNCTUATION +</span>
			<span class="s1">VALID_DIGITS +</span>
		<span class="s2">']*' </span><span class="s1">+</span>
		<span class="s2">'|' </span><span class="s1">+</span>
		<span class="s2">'[' </span><span class="s1">+</span>
			<span class="s1">VALID_PUNCTUATION +</span>
			<span class="s1">VALID_DIGITS +</span>
		<span class="s2">']+' </span><span class="s1">+</span>
	<span class="s2">')'</span>

<span class="s0">const </span><span class="s1">AFTER_PHONE_NUMBER_DIGITS_END_PATTERN = </span><span class="s0">new </span><span class="s1">RegExp(</span>
	<span class="s2">'[^' </span><span class="s1">+</span>
		<span class="s1">VALID_PUNCTUATION +</span>
		<span class="s1">VALID_DIGITS +</span>
	<span class="s2">']+' </span><span class="s1">+</span>
	<span class="s2">'.*' </span><span class="s1">+</span>
	<span class="s2">'$'</span>
<span class="s1">)</span>

<span class="s3">// Tests whether `national_prefix_for_parsing` could match</span>
<span class="s3">// different national prefixes.</span>
<span class="s3">// Matches anything that's not a digit or a square bracket.</span>
<span class="s0">const </span><span class="s1">COMPLEX_NATIONAL_PREFIX = </span><span class="s4">/[^\d\[\]]/</span>

<span class="s0">export default class </span><span class="s1">AsYouTypeParser {</span>
	<span class="s1">constructor({</span>
		<span class="s1">defaultCountry,</span>
		<span class="s1">defaultCallingCode,</span>
		<span class="s1">metadata,</span>
		<span class="s1">onNationalSignificantNumberChange</span>
	<span class="s1">}) {</span>
		<span class="s0">this</span><span class="s1">.defaultCountry = defaultCountry</span>
		<span class="s0">this</span><span class="s1">.defaultCallingCode = defaultCallingCode</span>
		<span class="s0">this</span><span class="s1">.metadata = metadata</span>
		<span class="s0">this</span><span class="s1">.onNationalSignificantNumberChange = onNationalSignificantNumberChange</span>
	<span class="s1">}</span>

	<span class="s1">input(text, state) {</span>
		<span class="s0">const </span><span class="s1">[formattedDigits, hasPlus] = extractFormattedDigitsAndPlus(text)</span>
		<span class="s0">const </span><span class="s1">digits = parseDigits(formattedDigits)</span>
		<span class="s3">// Checks for a special case: just a leading `+` has been entered.</span>
		<span class="s0">let </span><span class="s1">justLeadingPlus</span>
		<span class="s0">if </span><span class="s1">(hasPlus) {</span>
			<span class="s0">if </span><span class="s1">(!state.digits) {</span>
				<span class="s1">state.startInternationalNumber(undefined, undefined)</span>
				<span class="s0">if </span><span class="s1">(!digits) {</span>
					<span class="s1">justLeadingPlus = </span><span class="s0">true</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s0">if </span><span class="s1">(digits) {</span>
			<span class="s0">this</span><span class="s1">.inputDigits(digits, state)</span>
		<span class="s1">}</span>
		<span class="s0">return </span><span class="s1">{</span>
			<span class="s1">digits,</span>
			<span class="s1">justLeadingPlus</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s3">/**</span>
	 <span class="s3">* Inputs &quot;next&quot; phone number digits.</span>
	 <span class="s3">* </span><span class="s5">@param  </span><span class="s3">{string} digits</span>
	 <span class="s3">* </span><span class="s5">@return </span><span class="s3">{string} [formattedNumber] Formatted national phone number (if it can be formatted at this stage). Returning `undefined` means &quot;don't format the national phone number at this stage&quot;.</span>
	 <span class="s3">*/</span>
	<span class="s1">inputDigits(nextDigits, state) {</span>
		<span class="s0">const </span><span class="s1">{ digits } = state</span>
		<span class="s0">const </span><span class="s1">hasReceivedThreeLeadingDigits = digits.length &lt; </span><span class="s6">3 </span><span class="s1">&amp;&amp; digits.length + nextDigits.length &gt;= </span><span class="s6">3</span>

		<span class="s3">// Append phone number digits.</span>
		<span class="s1">state.appendDigits(nextDigits)</span>

		<span class="s3">// Attempt to extract IDD prefix:</span>
		<span class="s3">// Some users input their phone number in international format,</span>
		<span class="s3">// but in an &quot;out-of-country&quot; dialing format instead of using the leading `+`.</span>
		<span class="s3">// https://github.com/catamphetamine/libphonenumber-js/issues/185</span>
		<span class="s3">// Detect such numbers as soon as there're at least 3 digits.</span>
		<span class="s3">// Google's library attempts to extract IDD prefix at 3 digits,</span>
		<span class="s3">// so this library just copies that behavior.</span>
		<span class="s3">// I guess that's because the most commot IDD prefixes are</span>
		<span class="s3">// `00` (Europe) and `011` (US).</span>
		<span class="s3">// There exist really long IDD prefixes too:</span>
		<span class="s3">// for example, in Australia the default IDD prefix is `0011`,</span>
		<span class="s3">// and it could even be as long as `14880011`.</span>
		<span class="s3">// An IDD prefix is extracted here, and then every time when</span>
		<span class="s3">// there's a new digit and the number couldn't be formatted.</span>
		<span class="s0">if </span><span class="s1">(hasReceivedThreeLeadingDigits) {</span>
			<span class="s0">this</span><span class="s1">.extractIddPrefix(state)</span>
		<span class="s1">}</span>

		<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isWaitingForCountryCallingCode(state)) {</span>
			<span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.extractCountryCallingCode(state)) {</span>
				<span class="s0">return</span>
			<span class="s1">}</span>
		<span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
			<span class="s1">state.appendNationalSignificantNumberDigits(nextDigits)</span>
		<span class="s1">}</span>

		<span class="s3">// If a phone number is being input in international format,</span>
		<span class="s3">// then it's not valid for it to have a national prefix.</span>
		<span class="s3">// Still, some people incorrectly input such numbers with a national prefix.</span>
		<span class="s3">// In such cases, only attempt to strip a national prefix if the number becomes too long.</span>
		<span class="s3">// (but that is done later, not here)</span>
		<span class="s0">if </span><span class="s1">(!state.international) {</span>
			<span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.hasExtractedNationalSignificantNumber) {</span>
				<span class="s0">this</span><span class="s1">.extractNationalSignificantNumber(</span>
					<span class="s1">state.getNationalDigits(),</span>
					<span class="s1">(stateUpdate) =&gt; state.update(stateUpdate)</span>
				<span class="s1">)</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">isWaitingForCountryCallingCode({ international, callingCode }) {</span>
		<span class="s0">return </span><span class="s1">international &amp;&amp; !callingCode</span>
	<span class="s1">}</span>

	<span class="s3">// Extracts a country calling code from a number</span>
	<span class="s3">// being entered in internatonal format.</span>
	<span class="s1">extractCountryCallingCode(state) {</span>
		<span class="s0">const </span><span class="s1">{ countryCallingCode, number } = extractCountryCallingCode(</span>
			<span class="s2">'+' </span><span class="s1">+ state.getDigitsWithoutInternationalPrefix(),</span>
			<span class="s1">state.country,</span>
			<span class="s0">this</span><span class="s1">.defaultCountry,</span>
			<span class="s0">this</span><span class="s1">.defaultCallingCode,</span>
			<span class="s0">this</span><span class="s1">.metadata.metadata</span>
		<span class="s1">)</span>
		<span class="s0">if </span><span class="s1">(countryCallingCode) {</span>
			<span class="s1">state.setCallingCode(countryCallingCode)</span>
			<span class="s1">state.update({</span>
				<span class="s1">nationalSignificantNumber: number</span>
			<span class="s1">})</span>
			<span class="s0">return true</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">reset(numberingPlan) {</span>
		<span class="s0">if </span><span class="s1">(numberingPlan) {</span>
			<span class="s0">this</span><span class="s1">.hasSelectedNumberingPlan = </span><span class="s0">true</span>
			<span class="s0">const </span><span class="s1">nationalPrefixForParsing = numberingPlan._nationalPrefixForParsing()</span>
			<span class="s0">this</span><span class="s1">.couldPossiblyExtractAnotherNationalSignificantNumber = nationalPrefixForParsing &amp;&amp; COMPLEX_NATIONAL_PREFIX.test(nationalPrefixForParsing)</span>
		<span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
			<span class="s0">this</span><span class="s1">.hasSelectedNumberingPlan = undefined</span>
			<span class="s0">this</span><span class="s1">.couldPossiblyExtractAnotherNationalSignificantNumber = undefined</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s3">/**</span>
	 <span class="s3">* Extracts a national (significant) number from user input.</span>
	 <span class="s3">* Google's library is different in that it only applies `national_prefix_for_parsing`</span>
	 <span class="s3">* and doesn't apply `national_prefix_transform_rule` after that.</span>
	 <span class="s3">* https://github.com/google/libphonenumber/blob/a3d70b0487875475e6ad659af404943211d26456/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L539</span>
	 <span class="s3">* </span><span class="s5">@return </span><span class="s3">{boolean} [extracted]</span>
	 <span class="s3">*/</span>
	<span class="s1">extractNationalSignificantNumber(nationalDigits, setState) {</span>
		<span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.hasSelectedNumberingPlan) {</span>
			<span class="s0">return</span>
		<span class="s1">}</span>
		<span class="s0">const </span><span class="s1">{</span>
			<span class="s1">nationalPrefix,</span>
			<span class="s1">nationalNumber,</span>
			<span class="s1">carrierCode</span>
		<span class="s1">} = extractNationalNumberFromPossiblyIncompleteNumber(</span>
			<span class="s1">nationalDigits,</span>
			<span class="s0">this</span><span class="s1">.metadata</span>
		<span class="s1">)</span>
		<span class="s0">if </span><span class="s1">(nationalNumber === nationalDigits) {</span>
			<span class="s0">return</span>
		<span class="s1">}</span>
		<span class="s0">this</span><span class="s1">.onExtractedNationalNumber(</span>
			<span class="s1">nationalPrefix,</span>
			<span class="s1">carrierCode,</span>
			<span class="s1">nationalNumber,</span>
			<span class="s1">nationalDigits,</span>
			<span class="s1">setState</span>
		<span class="s1">)</span>
		<span class="s0">return true</span>
	<span class="s1">}</span>

	<span class="s3">/**</span>
	 <span class="s3">* In Google's code this function is called &quot;attempt to extract longer NDD&quot;.</span>
	 <span class="s3">* &quot;Some national prefixes are a substring of others&quot;, they say.</span>
	 <span class="s3">* </span><span class="s5">@return </span><span class="s3">{boolean} [result] — Returns `true` if extracting a national prefix produced different results from what they were.</span>
	 <span class="s3">*/</span>
	<span class="s1">extractAnotherNationalSignificantNumber(nationalDigits, prevNationalSignificantNumber, setState) {</span>
		<span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.hasExtractedNationalSignificantNumber) {</span>
			<span class="s0">return this</span><span class="s1">.extractNationalSignificantNumber(nationalDigits, setState)</span>
		<span class="s1">}</span>
		<span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.couldPossiblyExtractAnotherNationalSignificantNumber) {</span>
			<span class="s0">return</span>
		<span class="s1">}</span>
		<span class="s0">const </span><span class="s1">{</span>
			<span class="s1">nationalPrefix,</span>
			<span class="s1">nationalNumber,</span>
			<span class="s1">carrierCode</span>
		<span class="s1">} = extractNationalNumberFromPossiblyIncompleteNumber(</span>
			<span class="s1">nationalDigits,</span>
			<span class="s0">this</span><span class="s1">.metadata</span>
		<span class="s1">)</span>
		<span class="s3">// If a national prefix has been extracted previously,</span>
		<span class="s3">// then it's always extracted as additional digits are added.</span>
		<span class="s3">// That's assuming `extractNationalNumberFromPossiblyIncompleteNumber()`</span>
		<span class="s3">// doesn't do anything different from what it currently does.</span>
		<span class="s3">// So, just in case, here's this check, though it doesn't occur.</span>
		<span class="s3">/* istanbul ignore if */</span>
		<span class="s0">if </span><span class="s1">(nationalNumber === prevNationalSignificantNumber) {</span>
			<span class="s0">return</span>
		<span class="s1">}</span>
		<span class="s0">this</span><span class="s1">.onExtractedNationalNumber(</span>
			<span class="s1">nationalPrefix,</span>
			<span class="s1">carrierCode,</span>
			<span class="s1">nationalNumber,</span>
			<span class="s1">nationalDigits,</span>
			<span class="s1">setState</span>
		<span class="s1">)</span>
		<span class="s0">return true</span>
	<span class="s1">}</span>

	<span class="s1">onExtractedNationalNumber(</span>
		<span class="s1">nationalPrefix,</span>
		<span class="s1">carrierCode,</span>
		<span class="s1">nationalSignificantNumber,</span>
		<span class="s1">nationalDigits,</span>
		<span class="s1">setState</span>
	<span class="s1">) {</span>
		<span class="s3">// Tells if the parsed national (significant) number is present as-is in the input string.</span>
		<span class="s3">// For example, when inputting &quot;0343515551212999&quot; Argentinian mobile number,</span>
		<span class="s3">// the parsed national (significant) number is &quot;93435551212999&quot;.</span>
		<span class="s3">// There, one can see how it stripped &quot;0&quot; national prefix and prepended a &quot;9&quot;,</span>
		<span class="s3">// because that's how it is instructed to do in Argentina's metadata.</span>
		<span class="s3">// So in the described example, the parsed national (significant) number is not present</span>
		<span class="s3">// as-is in the input string. Instead, it's &quot;modified&quot; in the input string.</span>
		<span class="s3">// https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule</span>
		<span class="s0">let </span><span class="s1">nationalSignificantNumberIsModified = </span><span class="s0">false</span>

		<span class="s3">// In some countries, a phone number could have a prefix that is not a &quot;national prefix&quot;</span>
		<span class="s3">// but rather some other type of &quot;utility&quot; prefix.</span>
		<span class="s3">// For example, when calling within Australia, one could prepend `1831` prefix to hide</span>
		<span class="s3">// caller's phone number.</span>
		<span class="s3">// https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule</span>
		<span class="s0">let </span><span class="s1">prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix</span>

		<span class="s3">// `nationalSignificantNumber` could be empty. In that case, `.lastIndexOf()` still works correctly.</span>
		<span class="s0">const </span><span class="s1">nationalSignificantNumberIndex = nationalDigits.lastIndexOf(nationalSignificantNumber)</span>

		<span class="s3">// If the parsed national (significant) number is the last substring of the `nationalDigits`,</span>
		<span class="s3">// then it means that it's present as-is in the input string.</span>
		<span class="s3">// In any other case, the parsed national (significant) number is &quot;modified&quot; in the input string.</span>
		<span class="s0">if </span><span class="s1">(</span>
			<span class="s1">nationalSignificantNumberIndex &lt; </span><span class="s6">0 </span><span class="s1">||</span>
			<span class="s1">nationalSignificantNumberIndex !== nationalDigits.length - nationalSignificantNumber.length</span>
		<span class="s1">) {</span>
			<span class="s1">nationalSignificantNumberIsModified = </span><span class="s0">true</span>
		<span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
			<span class="s0">const </span><span class="s1">prefixBeforeNationalNumber = nationalDigits.slice(</span><span class="s6">0</span><span class="s1">, nationalSignificantNumberIndex)</span>
			<span class="s3">// When national (significant) number is equal to the `nationalDigits`,</span>
			<span class="s3">// this `onExtractedNationalNumber()` function simply doesn't get called.</span>
			<span class="s3">// This means that at this point, `prefixBeforeNationalNumber` is always non-empty.</span>
			<span class="s3">// Still, added this `if` check just to prevent potential silly bugs.</span>
			<span class="s3">// The `!prefixBeforeNationalNumber` case is not really testable</span>
			<span class="s3">// so this line is exluded from the code coverage.</span>
			<span class="s3">/* istanbul ignore if */</span>
			<span class="s0">if </span><span class="s1">(prefixBeforeNationalNumber) {</span>
				<span class="s0">if </span><span class="s1">(prefixBeforeNationalNumber !== nationalPrefix) {</span>
					<span class="s1">prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix = prefixBeforeNationalNumber</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s1">setState({</span>
			<span class="s1">nationalPrefix,</span>
			<span class="s1">carrierCode,</span>
			<span class="s1">nationalSignificantNumber,</span>
			<span class="s1">nationalSignificantNumberIsModified,</span>
			<span class="s1">prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix</span>
		<span class="s1">})</span>
		<span class="s3">// `onExtractedNationalNumber()` is only called when</span>
		<span class="s3">// the national (significant) number actually did change.</span>
		<span class="s0">this</span><span class="s1">.hasExtractedNationalSignificantNumber = </span><span class="s0">true</span>
		<span class="s0">this</span><span class="s1">.onNationalSignificantNumberChange()</span>
	<span class="s1">}</span>

	<span class="s1">reExtractNationalSignificantNumber(state) {</span>
		<span class="s3">// Attempt to extract a national prefix.</span>
		<span class="s3">//</span>
		<span class="s3">// Some people incorrectly input national prefix</span>
		<span class="s3">// in an international phone number.</span>
		<span class="s3">// For example, some people write British phone numbers as `+44(0)...`.</span>
		<span class="s3">//</span>
		<span class="s3">// Also, in some rare cases, it is valid for a national prefix</span>
		<span class="s3">// to be a part of an international phone number.</span>
		<span class="s3">// For example, mobile phone numbers in Mexico are supposed to be</span>
		<span class="s3">// dialled internationally using a `1` national prefix,</span>
		<span class="s3">// so the national prefix will be part of an international number.</span>
		<span class="s3">//</span>
		<span class="s3">// Quote from:</span>
		<span class="s3">// https://www.mexperience.com/dialing-cell-phones-in-mexico/</span>
		<span class="s3">//</span>
		<span class="s3">// &quot;Dialing a Mexican cell phone from abroad</span>
		<span class="s3">// When you are calling a cell phone number in Mexico from outside Mexico,</span>
		<span class="s3">// it’s necessary to dial an additional “1” after Mexico’s country code</span>
		<span class="s3">// (which is “52”) and before the area code.</span>
		<span class="s3">// You also ignore the 045, and simply dial the area code and the</span>
		<span class="s3">// cell phone’s number.</span>
		<span class="s3">//</span>
		<span class="s3">// If you don’t add the “1”, you’ll receive a recorded announcement</span>
		<span class="s3">// asking you to redial using it.</span>
		<span class="s3">//</span>
		<span class="s3">// For example, if you are calling from the USA to a cell phone</span>
		<span class="s3">// in Mexico City, you would dial +52 – 1 – 55 – 1234 5678.</span>
		<span class="s3">// (Note that this is different to calling a land line in Mexico City</span>
		<span class="s3">// from abroad, where the number dialed would be +52 – 55 – 1234 5678)&quot;.</span>
		<span class="s3">//</span>
		<span class="s3">// Google's demo output:</span>
		<span class="s3">// https://libphonenumber.appspot.com/phonenumberparser?number=%2b5215512345678&amp;country=MX</span>
		<span class="s3">//</span>
		<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.extractAnotherNationalSignificantNumber(</span>
			<span class="s1">state.getNationalDigits(),</span>
			<span class="s1">state.nationalSignificantNumber,</span>
			<span class="s1">(stateUpdate) =&gt; state.update(stateUpdate)</span>
		<span class="s1">)) {</span>
			<span class="s0">return true</span>
		<span class="s1">}</span>
		<span class="s3">// If no format matches the phone number, then it could be</span>
		<span class="s3">// &quot;a really long IDD&quot; (quote from a comment in Google's library).</span>
		<span class="s3">// An IDD prefix is first extracted when the user has entered at least 3 digits,</span>
		<span class="s3">// and then here — every time when there's a new digit and the number</span>
		<span class="s3">// couldn't be formatted.</span>
		<span class="s3">// For example, in Australia the default IDD prefix is `0011`,</span>
		<span class="s3">// and it could even be as long as `14880011`.</span>
		<span class="s3">//</span>
		<span class="s3">// Could also check `!hasReceivedThreeLeadingDigits` here</span>
		<span class="s3">// to filter out the case when this check duplicates the one</span>
		<span class="s3">// already performed when there're 3 leading digits,</span>
		<span class="s3">// but it's not a big deal, and in most cases there</span>
		<span class="s3">// will be a suitable `format` when there're 3 leading digits.</span>
		<span class="s3">//</span>
		<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.extractIddPrefix(state)) {</span>
			<span class="s0">this</span><span class="s1">.extractCallingCodeAndNationalSignificantNumber(state)</span>
			<span class="s0">return true</span>
		<span class="s1">}</span>
		<span class="s3">// Google's AsYouType formatter supports sort of an &quot;autocorrection&quot; feature</span>
		<span class="s3">// when it &quot;autocorrects&quot; numbers that have been input for a country</span>
		<span class="s3">// with that country's calling code.</span>
		<span class="s3">// Such &quot;autocorrection&quot; feature looks weird, but different people have been requesting it:</span>
		<span class="s3">// https://github.com/catamphetamine/libphonenumber-js/issues/376</span>
		<span class="s3">// https://github.com/catamphetamine/libphonenumber-js/issues/375</span>
		<span class="s3">// https://github.com/catamphetamine/libphonenumber-js/issues/316</span>
		<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.fixMissingPlus(state)) {</span>
			<span class="s0">this</span><span class="s1">.extractCallingCodeAndNationalSignificantNumber(state)</span>
			<span class="s0">return true</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">extractIddPrefix(state) {</span>
		<span class="s3">// An IDD prefix can't be present in a number written with a `+`.</span>
		<span class="s3">// Also, don't re-extract an IDD prefix if has already been extracted.</span>
		<span class="s0">const </span><span class="s1">{</span>
			<span class="s1">international,</span>
			<span class="s1">IDDPrefix,</span>
			<span class="s1">digits,</span>
			<span class="s1">nationalSignificantNumber</span>
		<span class="s1">} = state</span>
		<span class="s0">if </span><span class="s1">(international || IDDPrefix) {</span>
			<span class="s0">return</span>
		<span class="s1">}</span>
		<span class="s3">// Some users input their phone number in &quot;out-of-country&quot;</span>
		<span class="s3">// dialing format instead of using the leading `+`.</span>
		<span class="s3">// https://github.com/catamphetamine/libphonenumber-js/issues/185</span>
		<span class="s3">// Detect such numbers.</span>
		<span class="s0">const </span><span class="s1">numberWithoutIDD = stripIddPrefix(</span>
			<span class="s1">digits,</span>
			<span class="s0">this</span><span class="s1">.defaultCountry,</span>
			<span class="s0">this</span><span class="s1">.defaultCallingCode,</span>
			<span class="s0">this</span><span class="s1">.metadata.metadata</span>
		<span class="s1">)</span>
		<span class="s0">if </span><span class="s1">(numberWithoutIDD !== undefined &amp;&amp; numberWithoutIDD !== digits) {</span>
			<span class="s3">// If an IDD prefix was stripped then convert the IDD-prefixed number</span>
			<span class="s3">// to international number for subsequent parsing.</span>
			<span class="s1">state.update({</span>
				<span class="s1">IDDPrefix: digits.slice(</span><span class="s6">0</span><span class="s1">, digits.length - numberWithoutIDD.length)</span>
			<span class="s1">})</span>
			<span class="s0">this</span><span class="s1">.startInternationalNumber(state, {</span>
				<span class="s1">country: undefined,</span>
				<span class="s1">callingCode: undefined</span>
			<span class="s1">})</span>
			<span class="s0">return true</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">fixMissingPlus(state) {</span>
		<span class="s0">if </span><span class="s1">(!state.international) {</span>
			<span class="s0">const </span><span class="s1">{</span>
				<span class="s1">countryCallingCode: newCallingCode</span>
			<span class="s1">} = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(</span>
				<span class="s1">state.digits,</span>
				<span class="s1">state.country,</span>
				<span class="s0">this</span><span class="s1">.defaultCountry,</span>
				<span class="s0">this</span><span class="s1">.defaultCallingCode,</span>
				<span class="s0">this</span><span class="s1">.metadata.metadata</span>
			<span class="s1">)</span>
			<span class="s0">if </span><span class="s1">(newCallingCode) {</span>
				<span class="s1">state.update({</span>
					<span class="s1">missingPlus: </span><span class="s0">true</span>
				<span class="s1">})</span>
				<span class="s0">this</span><span class="s1">.startInternationalNumber(state, {</span>
					<span class="s1">country: state.country,</span>
					<span class="s1">callingCode: newCallingCode</span>
				<span class="s1">})</span>
				<span class="s0">return true</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">startInternationalNumber(state, { country, callingCode }) {</span>
		<span class="s1">state.startInternationalNumber(country, callingCode)</span>
		<span class="s3">// If a national (significant) number has been extracted before, reset it.</span>
		<span class="s0">if </span><span class="s1">(state.nationalSignificantNumber) {</span>
			<span class="s1">state.resetNationalSignificantNumber()</span>
			<span class="s0">this</span><span class="s1">.onNationalSignificantNumberChange()</span>
			<span class="s0">this</span><span class="s1">.hasExtractedNationalSignificantNumber = undefined</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">extractCallingCodeAndNationalSignificantNumber(state) {</span>
		<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.extractCountryCallingCode(state)) {</span>
			<span class="s3">// `this.extractCallingCode()` is currently called when the number</span>
			<span class="s3">// couldn't be formatted during the standard procedure.</span>
			<span class="s3">// Normally, the national prefix would be re-extracted</span>
			<span class="s3">// for an international number if such number couldn't be formatted,</span>
			<span class="s3">// but since it's already not able to be formatted,</span>
			<span class="s3">// there won't be yet another retry, so also extract national prefix here.</span>
			<span class="s0">this</span><span class="s1">.extractNationalSignificantNumber(</span>
				<span class="s1">state.getNationalDigits(),</span>
				<span class="s1">(stateUpdate) =&gt; state.update(stateUpdate)</span>
			<span class="s1">)</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Extracts formatted phone number from text (if there's any).</span>
 <span class="s3">* </span><span class="s5">@param  </span><span class="s3">{string} text</span>
 <span class="s3">* </span><span class="s5">@return </span><span class="s3">{string} [formattedPhoneNumber]</span>
 <span class="s3">*/</span>
<span class="s0">function </span><span class="s1">extractFormattedPhoneNumber(text) {</span>
	<span class="s3">// Attempt to extract a possible number from the string passed in.</span>
	<span class="s0">const </span><span class="s1">startsAt = text.search(VALID_FORMATTED_PHONE_NUMBER_PART)</span>
	<span class="s0">if </span><span class="s1">(startsAt &lt; </span><span class="s6">0</span><span class="s1">) {</span>
		<span class="s0">return</span>
	<span class="s1">}</span>
	<span class="s3">// Trim everything to the left of the phone number.</span>
	<span class="s1">text = text.slice(startsAt)</span>
	<span class="s3">// Trim the `+`.</span>
	<span class="s0">let </span><span class="s1">hasPlus</span>
	<span class="s0">if </span><span class="s1">(text[</span><span class="s6">0</span><span class="s1">] === </span><span class="s2">'+'</span><span class="s1">) {</span>
		<span class="s1">hasPlus = </span><span class="s0">true</span>
		<span class="s1">text = text.slice(</span><span class="s2">'+'</span><span class="s1">.length)</span>
	<span class="s1">}</span>
	<span class="s3">// Trim everything to the right of the phone number.</span>
	<span class="s1">text = text.replace(AFTER_PHONE_NUMBER_DIGITS_END_PATTERN, </span><span class="s2">''</span><span class="s1">)</span>
	<span class="s3">// Re-add the previously trimmed `+`.</span>
	<span class="s0">if </span><span class="s1">(hasPlus) {</span>
		<span class="s1">text = </span><span class="s2">'+' </span><span class="s1">+ text</span>
	<span class="s1">}</span>
	<span class="s0">return </span><span class="s1">text</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Extracts formatted phone number digits (and a `+`) from text (if there're any).</span>
 <span class="s3">* </span><span class="s5">@param  </span><span class="s3">{string} text</span>
 <span class="s3">* </span><span class="s5">@return </span><span class="s3">{any[]}</span>
 <span class="s3">*/</span>
<span class="s0">function </span><span class="s1">_extractFormattedDigitsAndPlus(text) {</span>
	<span class="s3">// Extract a formatted phone number part from text.</span>
	<span class="s0">const </span><span class="s1">extractedNumber = extractFormattedPhoneNumber(text) || </span><span class="s2">''</span>
	<span class="s3">// Trim a `+`.</span>
	<span class="s0">if </span><span class="s1">(extractedNumber[</span><span class="s6">0</span><span class="s1">] === </span><span class="s2">'+'</span><span class="s1">) {</span>
		<span class="s0">return </span><span class="s1">[extractedNumber.slice(</span><span class="s2">'+'</span><span class="s1">.length), </span><span class="s0">true</span><span class="s1">]</span>
	<span class="s1">}</span>
	<span class="s0">return </span><span class="s1">[extractedNumber]</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Extracts formatted phone number digits (and a `+`) from text (if there're any).</span>
 <span class="s3">* </span><span class="s5">@param  </span><span class="s3">{string} text</span>
 <span class="s3">* </span><span class="s5">@return </span><span class="s3">{any[]}</span>
 <span class="s3">*/</span>
<span class="s0">export function </span><span class="s1">extractFormattedDigitsAndPlus(text) {</span>
	<span class="s0">let </span><span class="s1">[formattedDigits, hasPlus] = _extractFormattedDigitsAndPlus(text)</span>
	<span class="s3">// If the extracted phone number part</span>
	<span class="s3">// can possibly be a part of some valid phone number</span>
	<span class="s3">// then parse phone number characters from a formatted phone number.</span>
	<span class="s0">if </span><span class="s1">(!VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN.test(formattedDigits)) {</span>
		<span class="s1">formattedDigits = </span><span class="s2">''</span>
	<span class="s1">}</span>
	<span class="s0">return </span><span class="s1">[formattedDigits, hasPlus]</span>
<span class="s1">}</span></pre>
</body>
</html>