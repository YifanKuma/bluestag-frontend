<html>
<head>
<title>aliased-prefetch-navigations.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
aliased-prefetch-navigations.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">addSearchParamsToPageSegments: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">handleAliasedPrefetchEntry: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">addSearchParamsToPageSegments: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">addSearchParamsToPageSegments;</span>
    <span class="s1">},</span>
    <span class="s1">handleAliasedPrefetchEntry: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">handleAliasedPrefetchEntry;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_segment = require(</span><span class="s0">&quot;../../../shared/lib/segment&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_approuter = require(</span><span class="s0">&quot;../app-router&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_applyrouterstatepatchtotree = require(</span><span class="s0">&quot;./apply-router-state-patch-to-tree&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_createhreffromurl = require(</span><span class="s0">&quot;./create-href-from-url&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_createroutercachekey = require(</span><span class="s0">&quot;./create-router-cache-key&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_fillcachewithnewsubtreedata = require(</span><span class="s0">&quot;./fill-cache-with-new-subtree-data&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_handlemutable = require(</span><span class="s0">&quot;./handle-mutable&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_navigatereducer = require(</span><span class="s0">&quot;./reducers/navigate-reducer&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">handleAliasedPrefetchEntry(navigatedAt, state, flightData, url, mutable) {</span>
    <span class="s2">let </span><span class="s1">currentTree = state.tree;</span>
    <span class="s2">let </span><span class="s1">currentCache = state.cache;</span>
    <span class="s2">const </span><span class="s1">href = (</span><span class="s3">0</span><span class="s1">, _createhreffromurl.createHrefFromUrl)(url);</span>
    <span class="s2">let </span><span class="s1">applied;</span>
    <span class="s2">let </span><span class="s1">scrollableSegments = [];</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">flightData === </span><span class="s0">'string'</span><span class="s1">) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">normalizedFlightData of flightData){</span>
        <span class="s4">// If the segment doesn't have a loading component, we don't need to do anything.</span>
        <span class="s2">if </span><span class="s1">(!hasLoadingComponentInSeedData(normalizedFlightData.seedData)) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">treePatch = normalizedFlightData.tree;</span>
        <span class="s4">// Segments are keyed by searchParams (e.g. __PAGE__?{&quot;foo&quot;:&quot;bar&quot;}). We might return a less specific, param-less entry,</span>
        <span class="s4">// so we ensure that the final tree contains the correct searchParams (reflected in the URL) are provided in the updated FlightRouterState tree.</span>
        <span class="s4">// We only do this on the first read, as otherwise we'd be overwriting the searchParams that may have already been set</span>
        <span class="s1">treePatch = addSearchParamsToPageSegments(treePatch, Object.fromEntries(url.searchParams));</span>
        <span class="s2">const </span><span class="s1">{ seedData, isRootRender, pathToSegment } = normalizedFlightData;</span>
        <span class="s4">// TODO-APP: remove ''</span>
        <span class="s2">const </span><span class="s1">flightSegmentPathWithLeadingEmpty = [</span>
            <span class="s0">''</span><span class="s1">,</span>
            <span class="s1">...pathToSegment</span>
        <span class="s1">];</span>
        <span class="s4">// Segments are keyed by searchParams (e.g. __PAGE__?{&quot;foo&quot;:&quot;bar&quot;}). We might return a less specific, param-less entry,</span>
        <span class="s4">// so we ensure that the final tree contains the correct searchParams (reflected in the URL) are provided in the updated FlightRouterState tree.</span>
        <span class="s4">// We only do this on the first read, as otherwise we'd be overwriting the searchParams that may have already been set</span>
        <span class="s1">treePatch = addSearchParamsToPageSegments(treePatch, Object.fromEntries(url.searchParams));</span>
        <span class="s2">let </span><span class="s1">newTree = (</span><span class="s3">0</span><span class="s1">, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);</span>
        <span class="s2">const </span><span class="s1">newCache = (</span><span class="s3">0</span><span class="s1">, _approuter.createEmptyCacheNode)();</span>
        <span class="s4">// The prefetch cache entry was aliased -- this signals that we only fill in the cache with the</span>
        <span class="s4">// loading state and not the actual parallel route seed data.</span>
        <span class="s2">if </span><span class="s1">(isRootRender &amp;&amp; seedData) {</span>
            <span class="s4">// Fill in the cache with the new loading / rsc data</span>
            <span class="s2">const </span><span class="s1">rsc = seedData[</span><span class="s3">1</span><span class="s1">];</span>
            <span class="s2">const </span><span class="s1">loading = seedData[</span><span class="s3">3</span><span class="s1">];</span>
            <span class="s1">newCache.loading = loading;</span>
            <span class="s1">newCache.rsc = rsc;</span>
            <span class="s4">// Construct a new tree and apply the aliased loading state for each parallel route</span>
            <span class="s1">fillNewTreeWithOnlyLoadingSegments(navigatedAt, newCache, currentCache, treePatch, seedData);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s4">// Copy rsc for the root node of the cache.</span>
            <span class="s1">newCache.rsc = currentCache.rsc;</span>
            <span class="s1">newCache.prefetchRsc = currentCache.prefetchRsc;</span>
            <span class="s1">newCache.loading = currentCache.loading;</span>
            <span class="s1">newCache.parallelRoutes = </span><span class="s2">new </span><span class="s1">Map(currentCache.parallelRoutes);</span>
            <span class="s4">// copy the loading state only into the leaf node (the part that changed)</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _fillcachewithnewsubtreedata.fillCacheWithNewSubTreeDataButOnlyLoading)(navigatedAt, newCache, currentCache, normalizedFlightData);</span>
        <span class="s1">}</span>
        <span class="s4">// If we don't have an updated tree, there's no reason to update the cache, as the tree</span>
        <span class="s4">// dictates what cache nodes to render.</span>
        <span class="s2">if </span><span class="s1">(newTree) {</span>
            <span class="s1">currentTree = newTree;</span>
            <span class="s1">currentCache = newCache;</span>
            <span class="s1">applied = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">subSegment of (</span><span class="s3">0</span><span class="s1">, _navigatereducer.generateSegmentsFromPatch)(treePatch)){</span>
            <span class="s2">const </span><span class="s1">scrollableSegmentPath = [</span>
                <span class="s1">...normalizedFlightData.pathToSegment,</span>
                <span class="s1">...subSegment</span>
            <span class="s1">];</span>
            <span class="s4">// Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.</span>
            <span class="s2">if </span><span class="s1">(scrollableSegmentPath[scrollableSegmentPath.length - </span><span class="s3">1</span><span class="s1">] !== _segment.DEFAULT_SEGMENT_KEY) {</span>
                <span class="s1">scrollableSegments.push(scrollableSegmentPath);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!applied) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">mutable.patchedTree = currentTree;</span>
    <span class="s1">mutable.cache = currentCache;</span>
    <span class="s1">mutable.canonicalUrl = href;</span>
    <span class="s1">mutable.hashFragment = url.hash;</span>
    <span class="s1">mutable.scrollableSegments = scrollableSegments;</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _handlemutable.handleMutable)(state, mutable);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hasLoadingComponentInSeedData(seedData) {</span>
    <span class="s2">if </span><span class="s1">(!seedData) </span><span class="s2">return false</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">parallelRoutes = seedData[</span><span class="s3">2</span><span class="s1">];</span>
    <span class="s2">const </span><span class="s1">loading = seedData[</span><span class="s3">3</span><span class="s1">];</span>
    <span class="s2">if </span><span class="s1">(loading) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">parallelRoutes){</span>
        <span class="s2">if </span><span class="s1">(hasLoadingComponentInSeedData(parallelRoutes[key])) {</span>
            <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">fillNewTreeWithOnlyLoadingSegments(navigatedAt, newCache, existingCache, routerState, cacheNodeSeedData) {</span>
    <span class="s2">const </span><span class="s1">isLastSegment = Object.keys(routerState[</span><span class="s3">1</span><span class="s1">]).length === </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(isLastSegment) {</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">routerState[</span><span class="s3">1</span><span class="s1">]){</span>
        <span class="s2">const </span><span class="s1">parallelRouteState = routerState[</span><span class="s3">1</span><span class="s1">][key];</span>
        <span class="s2">const </span><span class="s1">segmentForParallelRoute = parallelRouteState[</span><span class="s3">0</span><span class="s1">];</span>
        <span class="s2">const </span><span class="s1">cacheKey = (</span><span class="s3">0</span><span class="s1">, _createroutercachekey.createRouterCacheKey)(segmentForParallelRoute);</span>
        <span class="s2">const </span><span class="s1">parallelSeedData = cacheNodeSeedData !== </span><span class="s2">null </span><span class="s1">&amp;&amp; cacheNodeSeedData[</span><span class="s3">2</span><span class="s1">][key] !== undefined ? cacheNodeSeedData[</span><span class="s3">2</span><span class="s1">][key] : </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">let </span><span class="s1">newCacheNode;</span>
        <span class="s2">if </span><span class="s1">(parallelSeedData !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s4">// New data was sent from the server.</span>
            <span class="s2">const </span><span class="s1">rsc = parallelSeedData[</span><span class="s3">1</span><span class="s1">];</span>
            <span class="s2">const </span><span class="s1">loading = parallelSeedData[</span><span class="s3">3</span><span class="s1">];</span>
            <span class="s1">newCacheNode = {</span>
                <span class="s1">lazyData: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s4">// copy the layout but null the page segment as that's not meant to be used</span>
                <span class="s1">rsc: segmentForParallelRoute.includes(_segment.PAGE_SEGMENT_KEY) ? </span><span class="s2">null </span><span class="s1">: rsc,</span>
                <span class="s1">prefetchRsc: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">head: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">prefetchHead: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">parallelRoutes: </span><span class="s2">new </span><span class="s1">Map(),</span>
                <span class="s1">loading,</span>
                <span class="s1">navigatedAt</span>
            <span class="s1">};</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s4">// No data available for this node. This will trigger a lazy fetch</span>
            <span class="s4">// during render.</span>
            <span class="s1">newCacheNode = {</span>
                <span class="s1">lazyData: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">rsc: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">prefetchRsc: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">head: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">prefetchHead: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">parallelRoutes: </span><span class="s2">new </span><span class="s1">Map(),</span>
                <span class="s1">loading: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">navigatedAt: -</span><span class="s3">1</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">existingParallelRoutes = newCache.parallelRoutes.get(key);</span>
        <span class="s2">if </span><span class="s1">(existingParallelRoutes) {</span>
            <span class="s1">existingParallelRoutes.set(cacheKey, newCacheNode);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">newCache.parallelRoutes.set(key, </span><span class="s2">new </span><span class="s1">Map([</span>
                <span class="s1">[</span>
                    <span class="s1">cacheKey,</span>
                    <span class="s1">newCacheNode</span>
                <span class="s1">]</span>
            <span class="s1">]));</span>
        <span class="s1">}</span>
        <span class="s1">fillNewTreeWithOnlyLoadingSegments(navigatedAt, newCacheNode, existingCache, parallelRouteState, parallelSeedData);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">addSearchParamsToPageSegments(flightRouterState, searchParams) {</span>
    <span class="s2">const </span><span class="s1">[segment, parallelRoutes, ...rest] = flightRouterState;</span>
    <span class="s4">// If it's a page segment, modify the segment by adding search params</span>
    <span class="s2">if </span><span class="s1">(segment.includes(_segment.PAGE_SEGMENT_KEY)) {</span>
        <span class="s2">const </span><span class="s1">newSegment = (</span><span class="s3">0</span><span class="s1">, _segment.addSearchParamsIfPageSegment)(segment, searchParams);</span>
        <span class="s2">return </span><span class="s1">[</span>
            <span class="s1">newSegment,</span>
            <span class="s1">parallelRoutes,</span>
            <span class="s1">...rest</span>
        <span class="s1">];</span>
    <span class="s1">}</span>
    <span class="s4">// Otherwise, recurse through the parallel routes and return a new tree</span>
    <span class="s2">const </span><span class="s1">updatedParallelRoutes = {};</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[key, parallelRoute] of Object.entries(parallelRoutes)){</span>
        <span class="s1">updatedParallelRoutes[key] = addSearchParamsToPageSegments(parallelRoute, searchParams);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">[</span>
        <span class="s1">segment,</span>
        <span class="s1">updatedParallelRoutes,</span>
        <span class="s1">...rest</span>
    <span class="s1">];</span>
<span class="s1">}</span>

<span class="s2">if </span><span class="s1">((</span><span class="s2">typeof </span><span class="s1">exports.default === </span><span class="s0">'function' </span><span class="s1">|| (</span><span class="s2">typeof </span><span class="s1">exports.default === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; exports.default !== </span><span class="s2">null</span><span class="s1">)) &amp;&amp; </span><span class="s2">typeof </span><span class="s1">exports.default.__esModule === </span><span class="s0">'undefined'</span><span class="s1">) {</span>
  <span class="s1">Object.defineProperty(exports.default, </span><span class="s0">'__esModule'</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
  <span class="s1">Object.assign(exports.default, exports);</span>
  <span class="s1">module.exports = exports.default;</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=aliased-prefetch-navigations.js.map</span></pre>
</body>
</html>