<html>
<head>
<title>handle-externals.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #264eff;}
.s6 { color: #0037a6;}
.s7 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
handle-externals.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">isResourceInPackages: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">makeExternalHandler: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">resolveExternal: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">isResourceInPackages: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">isResourceInPackages;</span>
    <span class="s1">},</span>
    <span class="s1">makeExternalHandler: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">makeExternalHandler;</span>
    <span class="s1">},</span>
    <span class="s1">resolveExternal: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">resolveExternal;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_requirehook = require(</span><span class="s0">&quot;../server/require-hook&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants = require(</span><span class="s0">&quot;../shared/lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_path = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;../shared/lib/isomorphic/path&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_webpackconfig = require(</span><span class="s0">&quot;./webpack-config&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils = require(</span><span class="s0">&quot;./utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_normalizepathsep = require(</span><span class="s0">&quot;../shared/lib/page-path/normalize-path-sep&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">reactPackagesRegex = </span><span class="s5">/^(react|react-dom|react-server-dom-webpack)($|\/)/</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">pathSeparators = </span><span class="s0">'[/</span><span class="s6">\\\\</span><span class="s0">]'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">optionalEsmPart = </span><span class="s0">`((</span><span class="s1">${pathSeparators}</span><span class="s0">esm)?</span><span class="s1">${pathSeparators}</span><span class="s0">)`</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">externalFileEnd = </span><span class="s0">'(</span><span class="s6">\\</span><span class="s0">.external(</span><span class="s6">\\</span><span class="s0">.js)?)$'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">nextDist = </span><span class="s0">`next</span><span class="s1">${pathSeparators}</span><span class="s0">dist`</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">externalPattern = </span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s0">`</span><span class="s1">${nextDist}${optionalEsmPart}</span><span class="s0">.*</span><span class="s1">${externalFileEnd}</span><span class="s0">`</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">nodeModulesRegex = </span><span class="s5">/node_modules[/\\].*\.[mc]?js$/</span><span class="s1">;</span>
<span class="s2">function </span><span class="s1">isResourceInPackages(resource, packageNames, packageDirMapping) {</span>
    <span class="s2">if </span><span class="s1">(!packageNames) </span><span class="s2">return false</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">packageNames.some((p)=&gt;packageDirMapping &amp;&amp; packageDirMapping.has(p) ? resource.startsWith(packageDirMapping.get(p) + _path.default.sep) : resource.includes(_path.default.sep + _path.default.join(</span><span class="s0">'node_modules'</span><span class="s1">, p.replace(</span><span class="s5">/\//g</span><span class="s1">, _path.default.sep)) + _path.default.sep));</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">resolveExternal(dir, esmExternalsConfig, context, request, isEsmRequested, getResolve, isLocalCallback, baseResolveCheck = </span><span class="s2">true</span><span class="s1">, esmResolveOptions = _webpackconfig.NODE_ESM_RESOLVE_OPTIONS, nodeResolveOptions = _webpackconfig.NODE_RESOLVE_OPTIONS, baseEsmResolveOptions = _webpackconfig.NODE_BASE_ESM_RESOLVE_OPTIONS, baseResolveOptions = _webpackconfig.NODE_BASE_RESOLVE_OPTIONS) {</span>
    <span class="s2">const </span><span class="s1">esmExternals = !!esmExternalsConfig;</span>
    <span class="s2">const </span><span class="s1">looseEsmExternals = esmExternalsConfig === </span><span class="s0">'loose'</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">res = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">isEsm = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">preferEsmOptions = esmExternals &amp;&amp; isEsmRequested ? [</span>
        <span class="s2">true</span><span class="s1">,</span>
        <span class="s2">false</span>
    <span class="s1">] : [</span>
        <span class="s2">false</span>
    <span class="s1">];</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">preferEsm of preferEsmOptions){</span>
        <span class="s2">const </span><span class="s1">resolveOptions = preferEsm ? esmResolveOptions : nodeResolveOptions;</span>
        <span class="s2">const </span><span class="s1">resolve = getResolve(resolveOptions);</span>
        <span class="s4">// Resolve the import with the webpack provided context, this</span>
        <span class="s4">// ensures we're resolving the correct version when multiple</span>
        <span class="s4">// exist.</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">;</span>
            <span class="s1">[res, isEsm] = </span><span class="s2">await </span><span class="s1">resolve(context, request);</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
            <span class="s1">res = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!res) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">// ESM externals can only be imported (and not required).</span>
        <span class="s4">// Make an exception in loose mode.</span>
        <span class="s2">if </span><span class="s1">(!isEsmRequested &amp;&amp; isEsm &amp;&amp; !looseEsmExternals) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isLocalCallback) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">localRes: isLocalCallback(res)</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s4">// Bundled Node.js code is relocated without its node_modules tree.</span>
        <span class="s4">// This means we need to make sure its request resolves to the same</span>
        <span class="s4">// package that'll be available at runtime. If it's not identical,</span>
        <span class="s4">// we need to bundle the code (even if it _should_ be external).</span>
        <span class="s2">if </span><span class="s1">(baseResolveCheck) {</span>
            <span class="s2">let </span><span class="s1">baseRes;</span>
            <span class="s2">let </span><span class="s1">baseIsEsm;</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s2">const </span><span class="s1">baseResolve = getResolve(isEsm ? baseEsmResolveOptions : baseResolveOptions);</span>
                <span class="s1">[baseRes, baseIsEsm] = </span><span class="s2">await </span><span class="s1">baseResolve(dir, request);</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
                <span class="s1">baseRes = </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s1">baseIsEsm = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// Same as above: if the package, when required from the root,</span>
            <span class="s4">// would be different from what the real resolution would use, we</span>
            <span class="s4">// cannot externalize it.</span>
            <span class="s4">// if request is pointing to a symlink it could point to the same file,</span>
            <span class="s4">// the resolver will resolve symlinks so this is handled</span>
            <span class="s2">if </span><span class="s1">(baseRes !== res || isEsm !== baseIsEsm) {</span>
                <span class="s1">res = </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">break</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">res,</span>
        <span class="s1">isEsm</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">makeExternalHandler({ config, optOutBundlingPackageRegex, transpiledPackages, dir }) {</span>
    <span class="s2">var </span><span class="s1">_config_experimental;</span>
    <span class="s2">let </span><span class="s1">resolvedExternalPackageDirs;</span>
    <span class="s2">const </span><span class="s1">looseEsmExternals = ((_config_experimental = config.experimental) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _config_experimental.esmExternals) === </span><span class="s0">'loose'</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">async </span><span class="s2">function </span><span class="s1">handleExternals(context, request, dependencyType, layer, getResolve) {</span>
        <span class="s4">// We need to externalize internal requests for files intended to</span>
        <span class="s4">// not be bundled.</span>
        <span class="s2">const </span><span class="s1">isLocal = request.startsWith(</span><span class="s0">'.'</span><span class="s1">) || </span><span class="s4">// Always check for unix-style path, as webpack sometimes</span>
        <span class="s4">// normalizes as posix.</span>
        <span class="s1">_path.default.posix.isAbsolute(request) || </span><span class="s4">// When on Windows, we also want to check for Windows-specific</span>
        <span class="s4">// absolute paths.</span>
        <span class="s1">process.platform === </span><span class="s0">'win32' </span><span class="s1">&amp;&amp; _path.default.win32.isAbsolute(request);</span>
        <span class="s4">// make sure import &quot;next&quot; shows a warning when imported</span>
        <span class="s4">// in pages/components</span>
        <span class="s2">if </span><span class="s1">(request === </span><span class="s0">'next'</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s0">`commonjs next/dist/lib/import-next-warning`</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">isAppLayer = (</span><span class="s3">0</span><span class="s1">, _utils.isWebpackBundledLayer)(layer);</span>
        <span class="s4">// Relative requires don't need custom resolution, because they</span>
        <span class="s4">// are relative to requests we've already resolved here.</span>
        <span class="s4">// Absolute requires (require('/foo')) are extremely uncommon, but</span>
        <span class="s4">// also have no need for customization as they're already resolved.</span>
        <span class="s2">if </span><span class="s1">(!isLocal) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s5">/^next$/</span><span class="s1">.test(request)) {</span>
                <span class="s2">return </span><span class="s0">`commonjs </span><span class="s1">${request}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(reactPackagesRegex.test(request) &amp;&amp; !isAppLayer) {</span>
                <span class="s2">return </span><span class="s0">`commonjs </span><span class="s1">${request}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// Handle Bun builtins as external modules</span>
            <span class="s2">if </span><span class="s1">(request === </span><span class="s0">'bun' </span><span class="s1">|| request.startsWith(</span><span class="s0">'bun:'</span><span class="s1">)) {</span>
                <span class="s2">return </span><span class="s0">`commonjs </span><span class="s1">${request}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">notExternalModules = </span><span class="s5">/^(?:private-next-pages\/|next\/(?:dist\/pages\/|(?:app|cache|document|link|form|head|image|legacy\/image|constants|dynamic|script|navigation|headers|router|compat\/router|server)$)|string-hash|private-next-rsc-action-validate|private-next-rsc-action-client-wrapper|private-next-rsc-server-reference|private-next-rsc-cache-wrapper|private-next-rsc-track-dynamic-import$)/</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(notExternalModules.test(request)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">// @swc/helpers should not be external as it would</span>
        <span class="s4">// require hoisting the package which we can't rely on</span>
        <span class="s2">if </span><span class="s1">(request.includes(</span><span class="s0">'@swc/helpers'</span><span class="s1">)) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">// BARREL_OPTIMIZATION_PREFIX is a special marker that tells Next.js to</span>
        <span class="s4">// optimize the import by removing unused exports. This has to be compiled.</span>
        <span class="s2">if </span><span class="s1">(request.startsWith(_constants.BARREL_OPTIMIZATION_PREFIX)) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">// When in esm externals mode, and using import, we resolve with</span>
        <span class="s4">// ESM resolving options.</span>
        <span class="s4">// Also disable esm request when appDir is enabled</span>
        <span class="s2">const </span><span class="s1">isEsmRequested = dependencyType === </span><span class="s0">'esm'</span><span class="s1">;</span>
        <span class="s4">// Don't bundle @vercel/og nodejs bundle for nodejs runtime.</span>
        <span class="s4">// TODO-APP: bundle route.js with different layer that externals common node_module deps.</span>
        <span class="s4">// Make sure @vercel/og is loaded as ESM for Node.js runtime</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _utils.shouldUseReactServerCondition)(layer) &amp;&amp; request === </span><span class="s0">'next/dist/compiled/@vercel/og/index.node.js'</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s0">`module </span><span class="s1">${request}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">// Specific Next.js imports that should remain external</span>
        <span class="s4">// TODO-APP: Investigate if we can remove this.</span>
        <span class="s2">if </span><span class="s1">(request.startsWith(</span><span class="s0">'next/dist/'</span><span class="s1">)) {</span>
            <span class="s4">// Non external that needs to be transpiled</span>
            <span class="s4">// Image loader needs to be transpiled</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s5">/^next[\\/]dist[\\/]shared[\\/]lib[\\/]image-loader/</span><span class="s1">.test(request)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s5">/^next[\\/]dist[\\/]compiled[\\/]next-server/</span><span class="s1">.test(request)) {</span>
                <span class="s2">return </span><span class="s0">`commonjs </span><span class="s1">${request}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s5">/^next[\\/]dist[\\/]shared[\\/](?!lib[\\/]router[\\/]router)/</span><span class="s1">.test(request) || </span><span class="s5">/^next[\\/]dist[\\/]compiled[\\/].*\.c?js$/</span><span class="s1">.test(request)) {</span>
                <span class="s2">return </span><span class="s0">`commonjs </span><span class="s1">${request}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s5">/^next[\\/]dist[\\/]esm[\\/]shared[\\/](?!lib[\\/]router[\\/]router)/</span><span class="s1">.test(request) || </span><span class="s5">/^next[\\/]dist[\\/]compiled[\\/].*\.mjs$/</span><span class="s1">.test(request)) {</span>
                <span class="s2">return </span><span class="s0">`module </span><span class="s1">${request}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">resolveNextExternal(request);</span>
        <span class="s1">}</span>
        <span class="s4">// TODO-APP: Let's avoid this resolve call as much as possible, and eventually get rid of it.</span>
        <span class="s2">const </span><span class="s1">resolveResult = </span><span class="s2">await </span><span class="s1">resolveExternal(dir, config.experimental.esmExternals, context, request, isEsmRequested, getResolve, isLocal ? resolveNextExternal : undefined);</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s0">'localRes' </span><span class="s2">in </span><span class="s1">resolveResult) {</span>
            <span class="s2">return </span><span class="s1">resolveResult.localRes;</span>
        <span class="s1">}</span>
        <span class="s4">// Forcedly resolve the styled-jsx installed by next.js,</span>
        <span class="s4">// since `resolveExternal` cannot find the styled-jsx dep with pnpm</span>
        <span class="s2">if </span><span class="s1">(request === </span><span class="s0">'styled-jsx/style'</span><span class="s1">) {</span>
            <span class="s1">resolveResult.res = _requirehook.defaultOverrides[</span><span class="s0">'styled-jsx/style'</span><span class="s1">];</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">{ res, isEsm } = resolveResult;</span>
        <span class="s4">// If the request cannot be resolved we need to have</span>
        <span class="s4">// webpack &quot;bundle&quot; it so it surfaces the not found error.</span>
        <span class="s2">if </span><span class="s1">(!res) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">isOptOutBundling = optOutBundlingPackageRegex.test(res);</span>
        <span class="s4">// Apply bundling rules to all app layers.</span>
        <span class="s4">// Since handleExternals only handle the server layers, we don't need to exclude client here</span>
        <span class="s2">if </span><span class="s1">(!isOptOutBundling &amp;&amp; isAppLayer) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">// ESM externals can only be imported (and not required).</span>
        <span class="s4">// Make an exception in loose mode.</span>
        <span class="s2">if </span><span class="s1">(!isEsmRequested &amp;&amp; isEsm &amp;&amp; !looseEsmExternals &amp;&amp; !isLocal) {</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`ESM packages (</span><span class="s1">${request}</span><span class="s0">) need to be imported. Use 'import' to reference the package instead. https://nextjs.org/docs/messages/import-esm-externals`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E310&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">externalType = isEsm ? </span><span class="s0">'module' </span><span class="s1">: </span><span class="s0">'commonjs'</span><span class="s1">;</span>
        <span class="s4">// Default pages have to be transpiled</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s4">// This is the @babel/plugin-transform-runtime &quot;helpers: true&quot; option</span>
        <span class="s5">/node_modules[/\\]@babel[/\\]runtime[/\\]/</span><span class="s1">.test(res)) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">// Webpack itself has to be compiled because it doesn't always use module relative paths</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s5">/node_modules[/\\]webpack/</span><span class="s1">.test(res) || </span><span class="s5">/node_modules[/\\]css-loader/</span><span class="s1">.test(res)) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">// If a package should be transpiled by Next.js, we skip making it external.</span>
        <span class="s4">// It doesn't matter what the extension is, as we'll transpile it anyway.</span>
        <span class="s2">if </span><span class="s1">(transpiledPackages &amp;&amp; !resolvedExternalPackageDirs) {</span>
            <span class="s1">resolvedExternalPackageDirs = </span><span class="s2">new </span><span class="s1">Map();</span>
            <span class="s4">// We need to resolve all the external package dirs initially.</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">pkg of transpiledPackages){</span>
                <span class="s2">const </span><span class="s1">pkgRes = </span><span class="s2">await </span><span class="s1">resolveExternal(dir, config.experimental.esmExternals, context, pkg + </span><span class="s0">'/package.json'</span><span class="s1">, isEsmRequested, getResolve, isLocal ? resolveNextExternal : undefined);</span>
                <span class="s2">if </span><span class="s1">(pkgRes.res) {</span>
                    <span class="s1">resolvedExternalPackageDirs.set(pkg, _path.default.dirname(pkgRes.res));</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">resolvedBundlingOptOutRes = resolveBundlingOptOutPackages({</span>
            <span class="s1">resolvedRes: res,</span>
            <span class="s1">config,</span>
            <span class="s1">resolvedExternalPackageDirs,</span>
            <span class="s1">isAppLayer,</span>
            <span class="s1">externalType,</span>
            <span class="s1">isOptOutBundling,</span>
            <span class="s1">request,</span>
            <span class="s1">transpiledPackages</span>
        <span class="s1">});</span>
        <span class="s2">if </span><span class="s1">(resolvedBundlingOptOutRes) {</span>
            <span class="s2">return </span><span class="s1">resolvedBundlingOptOutRes;</span>
        <span class="s1">}</span>
        <span class="s4">// if here, we default to bundling the file</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resolveBundlingOptOutPackages({ resolvedRes, config, resolvedExternalPackageDirs, isAppLayer, externalType, isOptOutBundling, request, transpiledPackages }) {</span>
    <span class="s2">if </span><span class="s1">(nodeModulesRegex.test(resolvedRes)) {</span>
        <span class="s2">const </span><span class="s1">shouldBundlePages = !isAppLayer &amp;&amp; config.bundlePagesRouterDependencies &amp;&amp; !isOptOutBundling;</span>
        <span class="s2">const </span><span class="s1">shouldBeBundled = shouldBundlePages || isResourceInPackages(resolvedRes, transpiledPackages, resolvedExternalPackageDirs);</span>
        <span class="s2">if </span><span class="s1">(!shouldBeBundled) {</span>
            <span class="s2">return </span><span class="s0">`</span><span class="s1">${externalType} ${request}</span><span class="s0">` </span><span class="s4">// Externalize if not bundled or opted out</span>
            <span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s4">/**</span>
 <span class="s4">* </span><span class="s7">@param </span><span class="s4">localRes the full path to the file</span>
 <span class="s4">* </span><span class="s7">@returns </span><span class="s4">the externalized path</span>
 <span class="s4">* </span><span class="s7">@description </span><span class="s4">returns an externalized path if the file is a Next.js file and ends with either `.shared-runtime.js` or `.external.js`</span>
 <span class="s4">* This is used to ensure that files used across the rendering runtime(s) and the user code are one and the same. The logic in this function</span>
 <span class="s4">* will rewrite the require to the correct bundle location depending on the layer at which the file is being used.</span>
 <span class="s4">*/ </span><span class="s2">function </span><span class="s1">resolveNextExternal(localRes) {</span>
    <span class="s2">const </span><span class="s1">isExternal = externalPattern.test(localRes);</span>
    <span class="s4">// if the file ends with .external, we need to make it a commonjs require in all cases</span>
    <span class="s4">// this is used mainly to share the async local storage across the routing, rendering and user layers.</span>
    <span class="s2">if </span><span class="s1">(isExternal) {</span>
        <span class="s4">// it's important we return the path that starts with `next/dist/` here instead of the absolute path</span>
        <span class="s4">// otherwise NFT will get tripped up</span>
        <span class="s2">return </span><span class="s0">`commonjs </span><span class="s1">${(</span><span class="s3">0</span><span class="s1">, _normalizepathsep.normalizePathSep)(localRes.replace(</span><span class="s5">/.*?next[/\\]dist/</span><span class="s1">, </span><span class="s0">'next/dist'</span><span class="s1">))}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=handle-externals.js.map</span></pre>
</body>
</html>