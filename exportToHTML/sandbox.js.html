<html>
<head>
<title>sandbox.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sandbox.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">ErrorSource: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getRuntimeContext: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">run: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">ErrorSource: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">ErrorSource;</span>
    <span class="s1">},</span>
    <span class="s1">getRuntimeContext: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getRuntimeContext;</span>
    <span class="s1">},</span>
    <span class="s1">run: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">run;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_context = require(</span><span class="s0">&quot;./context&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_bodystreams = require(</span><span class="s0">&quot;../../body-streams&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_builtinrequestcontext = require(</span><span class="s0">&quot;../../after/builtin-request-context&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_routerservercontext = require(</span><span class="s0">&quot;../../lib/router-utils/router-server-context&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">ErrorSource = Symbol(</span><span class="s0">'SandboxError'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">FORBIDDEN_HEADERS = [</span>
    <span class="s0">'content-length'</span><span class="s1">,</span>
    <span class="s0">'content-encoding'</span><span class="s1">,</span>
    <span class="s0">'transfer-encoding'</span>
<span class="s1">];</span>
<span class="s4">/**</span>
 <span class="s4">* Decorates the runner function making sure all errors it can produce are</span>
 <span class="s4">* tagged with `edge-server` so they can properly be rendered in dev.</span>
 <span class="s4">*/ </span><span class="s2">function </span><span class="s1">withTaggedErrors(fn) {</span>
    <span class="s2">if </span><span class="s1">(process.env.NODE_ENV === </span><span class="s0">'development'</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">{ getServerError } = require(</span><span class="s0">'../../dev/node-stack-frames'</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">(params)=&gt;fn(params).then((result)=&gt;{</span>
                <span class="s2">var </span><span class="s1">_result_waitUntil;</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">...result,</span>
                    <span class="s1">waitUntil: result == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_result_waitUntil = result.waitUntil) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _result_waitUntil.catch((error)=&gt;{</span>
                        <span class="s4">// TODO: used COMPILER_NAMES.edgeServer instead. Verify that it does not increase the runtime size.</span>
                        <span class="s2">throw </span><span class="s1">getServerError(error, </span><span class="s0">'edge-server'</span><span class="s1">);</span>
                    <span class="s1">})</span>
                <span class="s1">};</span>
            <span class="s1">}).catch((error)=&gt;{</span>
                <span class="s4">// TODO: used COMPILER_NAMES.edgeServer instead</span>
                <span class="s2">throw </span><span class="s1">getServerError(error, </span><span class="s0">'edge-server'</span><span class="s1">);</span>
            <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">fn;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">getRuntimeContext(params) {</span>
    <span class="s2">const </span><span class="s1">{ runtime, evaluateInContext } = </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _context.getModuleContext)({</span>
        <span class="s1">moduleName: params.name,</span>
        <span class="s1">onWarning: params.onWarning ?? (()=&gt;{}),</span>
        <span class="s1">onError: params.onError ?? (()=&gt;{}),</span>
        <span class="s1">useCache: params.useCache !== </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">edgeFunctionEntry: params.edgeFunctionEntry,</span>
        <span class="s1">distDir: params.distDir</span>
    <span class="s1">});</span>
    <span class="s2">if </span><span class="s1">(params.incrementalCache) {</span>
        <span class="s1">runtime.context.globalThis.__incrementalCacheShared = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">runtime.context.globalThis.__incrementalCache = params.incrementalCache;</span>
    <span class="s1">}</span>
    <span class="s4">// expose router server context for access to dev handlers like</span>
    <span class="s4">// logErrorWithOriginalStack</span>
    <span class="s1">;</span>
    <span class="s1">runtime.context.globalThis[_routerservercontext.RouterServerContextSymbol] = _routerservercontext.routerServerGlobal[_routerservercontext.RouterServerContextSymbol];</span>
    <span class="s2">if </span><span class="s1">(params.serverComponentsHmrCache) {</span>
        <span class="s1">runtime.context.globalThis.__serverComponentsHmrCache = params.serverComponentsHmrCache;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">paramPath of params.paths){</span>
        <span class="s1">evaluateInContext(paramPath);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">runtime;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">run = withTaggedErrors(async </span><span class="s2">function </span><span class="s1">runWithTaggedErrors(params) {</span>
    <span class="s2">var </span><span class="s1">_params_request_body;</span>
    <span class="s2">const </span><span class="s1">runtime = </span><span class="s2">await </span><span class="s1">getRuntimeContext(params);</span>
    <span class="s2">const </span><span class="s1">edgeFunction = (</span><span class="s2">await </span><span class="s1">runtime.context._ENTRIES[</span><span class="s0">`middleware_</span><span class="s1">${params.name}</span><span class="s0">`</span><span class="s1">]).default;</span>
    <span class="s2">const </span><span class="s1">cloned = ![</span>
        <span class="s0">'HEAD'</span><span class="s1">,</span>
        <span class="s0">'GET'</span>
    <span class="s1">].includes(params.request.method) ? (_params_request_body = params.request.body) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _params_request_body.cloneBodyStream() : undefined;</span>
    <span class="s2">const </span><span class="s1">KUint8Array = runtime.evaluate(</span><span class="s0">'Uint8Array'</span><span class="s1">);</span>
    <span class="s2">const </span><span class="s1">urlInstance = </span><span class="s2">new </span><span class="s1">URL(params.request.url);</span>
    <span class="s1">params.request.url = urlInstance.toString();</span>
    <span class="s2">const </span><span class="s1">headers = </span><span class="s2">new </span><span class="s1">Headers();</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[key, value] of Object.entries(params.request.headers)){</span>
        <span class="s1">headers.set(key, (value == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: value.toString()) ?? </span><span class="s0">''</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">let </span><span class="s1">result = undefined;</span>
        <span class="s2">const </span><span class="s1">builtinRequestCtx = {</span>
            <span class="s1">...(</span><span class="s3">0</span><span class="s1">, _builtinrequestcontext.getBuiltinRequestContext)(),</span>
            <span class="s4">// FIXME(after):</span>
            <span class="s4">// arguably, this is an abuse of &quot;@next/request-context&quot; --</span>
            <span class="s4">// it'd make more sense to simply forward its existing value into the sandbox (in `createModuleContext`)</span>
            <span class="s4">// but here we're using it to just pass in `waitUntil` regardless if we were running in this context or not.</span>
            <span class="s1">waitUntil: params.request.waitUntil</span>
        <span class="s1">};</span>
        <span class="s2">await </span><span class="s1">_context.edgeSandboxNextRequestContext.run(builtinRequestCtx, ()=&gt;_context.requestStore.run({</span>
                <span class="s1">headers</span>
            <span class="s1">}, async ()=&gt;{</span>
                <span class="s1">result = </span><span class="s2">await </span><span class="s1">edgeFunction({</span>
                    <span class="s1">request: {</span>
                        <span class="s1">...params.request,</span>
                        <span class="s1">body: cloned &amp;&amp; (</span><span class="s3">0</span><span class="s1">, _bodystreams.requestToBodyStream)(runtime.context, KUint8Array, cloned)</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">headerName of FORBIDDEN_HEADERS){</span>
                    <span class="s1">result.response.headers.delete(headerName);</span>
                <span class="s1">}</span>
            <span class="s1">}));</span>
        <span class="s2">if </span><span class="s1">(!result) </span><span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Edge function did not return a response'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E332&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">} </span><span class="s2">finally</span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">_params_request_body1;</span>
        <span class="s2">await </span><span class="s1">((_params_request_body1 = params.request.body) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _params_request_body1.finalize());</span>
    <span class="s1">}</span>
<span class="s1">});</span>

<span class="s4">//# sourceMappingURL=sandbox.js.map</span></pre>
</body>
</html>