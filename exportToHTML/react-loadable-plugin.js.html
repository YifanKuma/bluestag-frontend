<html>
<head>
<title>react-loadable-plugin.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #0033b3;}
.s4 { color: #1750eb;}
.s5 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
react-loadable-plugin.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
<span class="s0">COPYRIGHT (c) 2017-present James Kyle &lt;me@thejameskyle.com&gt;</span>
 <span class="s0">MIT License</span>
 <span class="s0">Permission is hereby granted, free of charge, to any person obtaining</span>
<span class="s0">a copy of this software and associated documentation files (the</span>
<span class="s0">&quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s0">without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s0">distribute, sublicense, and/or sell copies of the Software, and to</span>
<span class="s0">permit persons to whom the Software is furnished to do so, subject to</span>
<span class="s0">the following conditions:</span>
 <span class="s0">The above copyright notice and this permission notice shall be</span>
<span class="s0">included in all copies or substantial portions of the Software.</span>
 <span class="s0">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="s0">EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s0">MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="s0">NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE</span>
<span class="s0">LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION</span>
<span class="s0">OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION</span>
<span class="s0">WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWAR</span>
<span class="s0">*/ // Implementation of this PR: https://github.com/jamiebuilds/react-loadable/pull/132</span>
<span class="s0">// Modified to strip out unneeded results for Next's specific use case</span>
<span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s3">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s2">&quot;ReactLoadablePlugin&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">ReactLoadablePlugin;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s3">const </span><span class="s1">_path = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s2">&quot;path&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">_webpack = require(</span><span class="s2">&quot;next/dist/compiled/webpack/webpack&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_constants = require(</span><span class="s2">&quot;../../../shared/lib/constants&quot;</span><span class="s1">);</span>
<span class="s3">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s3">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s3">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getModuleId(compilation, module) {</span>
    <span class="s3">return </span><span class="s1">compilation.chunkGraph.getModuleId(module);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getModuleFromDependency(compilation, dep) {</span>
    <span class="s3">return </span><span class="s1">compilation.moduleGraph.getModule(dep);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getOriginModuleFromDependency(compilation, dep) {</span>
    <span class="s3">return </span><span class="s1">compilation.moduleGraph.getParentModule(dep);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getChunkGroupFromBlock(compilation, block) {</span>
    <span class="s3">return </span><span class="s1">compilation.chunkGraph.getBlockChunkGroup(block);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">buildManifest(_compiler, compilation, projectSrcDir, dev, shouldCreateDynamicCssManifest) {</span>
    <span class="s3">if </span><span class="s1">(!projectSrcDir) {</span>
        <span class="s3">return </span><span class="s1">{</span>
            <span class="s1">reactLoadableManifest: {},</span>
            <span class="s1">dynamicCssManifest: []</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s3">const </span><span class="s1">dynamicCssManifestSet = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s3">let </span><span class="s1">manifest = {};</span>
    <span class="s0">// This is allowed:</span>
    <span class="s0">// import(&quot;./module&quot;); &lt;- ImportDependency</span>
    <span class="s0">// We don't support that:</span>
    <span class="s0">// import(/* webpackMode: &quot;eager&quot; */ &quot;./module&quot;) &lt;- ImportEagerDependency</span>
    <span class="s0">// import(`./module/${param}`) &lt;- ImportContextDependency</span>
    <span class="s0">// Find all dependencies blocks which contains a `import()` dependency</span>
    <span class="s3">const </span><span class="s1">handleBlock = (block)=&gt;{</span>
        <span class="s1">block.blocks.forEach(handleBlock);</span>
        <span class="s3">const </span><span class="s1">chunkGroup = getChunkGroupFromBlock(compilation, block);</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">dependency of block.dependencies){</span>
            <span class="s3">if </span><span class="s1">(dependency.type.startsWith(</span><span class="s2">'import()'</span><span class="s1">)) {</span>
                <span class="s0">// get the referenced module</span>
                <span class="s3">const </span><span class="s1">module = getModuleFromDependency(compilation, dependency);</span>
                <span class="s3">if </span><span class="s1">(!module) </span><span class="s3">return</span><span class="s1">;</span>
                <span class="s0">// get the module containing the import()</span>
                <span class="s3">const </span><span class="s1">originModule = getOriginModuleFromDependency(compilation, dependency);</span>
                <span class="s3">const </span><span class="s1">originRequest = originModule == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: originModule.resource;</span>
                <span class="s3">if </span><span class="s1">(!originRequest) </span><span class="s3">return</span><span class="s1">;</span>
                <span class="s0">// We construct a &quot;unique&quot; key from origin module and request</span>
                <span class="s0">// It's not perfect unique, but that will be fine for us.</span>
                <span class="s0">// We also need to construct the same in the babel plugin.</span>
                <span class="s3">const </span><span class="s1">key = </span><span class="s2">`</span><span class="s1">${_path.default.relative(projectSrcDir, originRequest)} </span><span class="s2">-&gt; </span><span class="s1">${dependency.request}</span><span class="s2">`</span><span class="s1">;</span>
                <span class="s0">// Capture all files that need to be loaded.</span>
                <span class="s3">const </span><span class="s1">files = </span><span class="s3">new </span><span class="s1">Set();</span>
                <span class="s3">if </span><span class="s1">(manifest[key]) {</span>
                    <span class="s0">// In the &quot;rare&quot; case where multiple chunk groups</span>
                    <span class="s0">// are created for the same `import()` or multiple</span>
                    <span class="s0">// import()s reference the same module, we merge</span>
                    <span class="s0">// the files to make sure to not miss files</span>
                    <span class="s0">// This may cause overfetching in edge cases.</span>
                    <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">file of manifest[key].files){</span>
                        <span class="s1">files.add(file);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s0">// There might not be a chunk group when all modules</span>
                <span class="s0">// are already loaded. In this case we only need need</span>
                <span class="s0">// the module id and no files</span>
                <span class="s3">if </span><span class="s1">(chunkGroup) {</span>
                    <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">chunk of chunkGroup.chunks){</span>
                        <span class="s1">chunk.files.forEach((file)=&gt;{</span>
                            <span class="s3">if </span><span class="s1">((file.endsWith(</span><span class="s2">'.js'</span><span class="s1">) || file.endsWith(</span><span class="s2">'.css'</span><span class="s1">)) &amp;&amp; file.match(</span><span class="s5">/^static\/(chunks|css)\//</span><span class="s1">)) {</span>
                                <span class="s1">files.add(file);</span>
                                <span class="s3">if </span><span class="s1">(shouldCreateDynamicCssManifest &amp;&amp; file.endsWith(</span><span class="s2">'.css'</span><span class="s1">)) {</span>
                                    <span class="s1">dynamicCssManifestSet.add(file);</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s0">// usually we have to add the parent chunk groups too</span>
                <span class="s0">// but we assume that all parents are also imported by</span>
                <span class="s0">// next/dynamic so they are loaded by the same technique</span>
                <span class="s0">// add the id and files to the manifest</span>
                <span class="s3">const </span><span class="s1">id = dev ? key : getModuleId(compilation, module);</span>
                <span class="s1">manifest[key] = {</span>
                    <span class="s1">id,</span>
                    <span class="s1">files: Array.from(files)</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">module of compilation.modules){</span>
        <span class="s1">module.blocks.forEach(handleBlock);</span>
    <span class="s1">}</span>
    <span class="s1">manifest = Object.keys(manifest).sort()</span><span class="s0">// eslint-disable-next-line no-sequences</span>
    <span class="s1">.reduce((a, c)=&gt;(a[c] = manifest[c], a), {});</span>
    <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">reactLoadableManifest: manifest,</span>
        <span class="s1">dynamicCssManifest: Array.from(dynamicCssManifestSet)</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">class </span><span class="s1">ReactLoadablePlugin {</span>
    <span class="s1">constructor(opts){</span>
        <span class="s3">this</span><span class="s1">.filename = opts.filename;</span>
        <span class="s3">this</span><span class="s1">.pagesOrAppDir = opts.pagesDir || opts.appDir;</span>
        <span class="s3">this</span><span class="s1">.isPagesDir = Boolean(opts.pagesDir);</span>
        <span class="s3">this</span><span class="s1">.runtimeAsset = opts.runtimeAsset;</span>
        <span class="s3">this</span><span class="s1">.dev = opts.dev;</span>
    <span class="s1">}</span>
    <span class="s1">createAssets(compiler, compilation) {</span>
        <span class="s3">const </span><span class="s1">projectSrcDir = </span><span class="s3">this</span><span class="s1">.pagesOrAppDir ? _path.default.dirname(</span><span class="s3">this</span><span class="s1">.pagesOrAppDir) : undefined;</span>
        <span class="s3">const </span><span class="s1">shouldCreateDynamicCssManifest = !</span><span class="s3">this</span><span class="s1">.dev &amp;&amp; </span><span class="s3">this</span><span class="s1">.isPagesDir;</span>
        <span class="s3">const </span><span class="s1">{ reactLoadableManifest, dynamicCssManifest } = buildManifest(compiler, compilation, projectSrcDir, </span><span class="s3">this</span><span class="s1">.dev, shouldCreateDynamicCssManifest);</span>
        <span class="s1">compilation.emitAsset(</span><span class="s3">this</span><span class="s1">.filename, </span><span class="s3">new </span><span class="s1">_webpack.sources.RawSource(JSON.stringify(reactLoadableManifest, </span><span class="s3">null</span><span class="s1">, </span><span class="s4">2</span><span class="s1">)));</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.runtimeAsset) {</span>
            <span class="s1">compilation.emitAsset(</span><span class="s3">this</span><span class="s1">.runtimeAsset, </span><span class="s3">new </span><span class="s1">_webpack.sources.RawSource(</span><span class="s2">`self.__REACT_LOADABLE_MANIFEST=</span><span class="s1">${JSON.stringify(JSON.stringify(reactLoadableManifest))}</span><span class="s2">`</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s0">// This manifest prevents removing server rendered &lt;link&gt; tags after client</span>
        <span class="s0">// navigation. This is only needed under Pages dir &amp;&amp; Production &amp;&amp; Webpack.</span>
        <span class="s0">// x-ref: https://github.com/vercel/next.js/pull/72959</span>
        <span class="s3">if </span><span class="s1">(shouldCreateDynamicCssManifest) {</span>
            <span class="s1">compilation.emitAsset(</span><span class="s2">`</span><span class="s1">${_constants.DYNAMIC_CSS_MANIFEST}</span><span class="s2">.json`</span><span class="s1">, </span><span class="s3">new </span><span class="s1">_webpack.sources.RawSource(JSON.stringify(dynamicCssManifest, </span><span class="s3">null</span><span class="s1">, </span><span class="s4">2</span><span class="s1">)));</span>
            <span class="s0">// This is for edge runtime.</span>
            <span class="s1">compilation.emitAsset(</span><span class="s2">`server/</span><span class="s1">${_constants.DYNAMIC_CSS_MANIFEST}</span><span class="s2">.js`</span><span class="s1">, </span><span class="s3">new </span><span class="s1">_webpack.sources.RawSource(</span><span class="s2">`self.__DYNAMIC_CSS_MANIFEST=</span><span class="s1">${JSON.stringify(JSON.stringify(dynamicCssManifest))}</span><span class="s2">`</span><span class="s1">));</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">apply(compiler) {</span>
        <span class="s1">compiler.hooks.make.tap(</span><span class="s2">'ReactLoadableManifest'</span><span class="s1">, (compilation)=&gt;{</span>
            <span class="s1">compilation.hooks.processAssets.tap({</span>
                <span class="s1">name: </span><span class="s2">'ReactLoadableManifest'</span><span class="s1">,</span>
                <span class="s1">stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS</span>
            <span class="s1">}, ()=&gt;{</span>
                <span class="s3">this</span><span class="s1">.createAssets(compiler, compilation);</span>
            <span class="s1">});</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">//# sourceMappingURL=react-loadable-plugin.js.map</span></pre>
</body>
</html>