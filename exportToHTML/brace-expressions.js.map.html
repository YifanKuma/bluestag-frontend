<html>
<head>
<title>brace-expressions.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
brace-expressions.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;brace-expressions.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/brace-expressions.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;AAAA,wEAAwE;AACxE,wCAAwC;;;AAExC,8DAA8D;AAC9D,MAAM,YAAY,GAA0D;IAC1E,WAAW,EAAE,CAAC,sBAAsB,EAAE,IAAI,CAAC;IAC3C,WAAW,EAAE,CAAC,eAAe,EAAE,IAAI,CAAC;IACpC,WAAW,EAAE,CAAC,KAAK,GAAG,QAAQ,GAAG,IAAI,EAAE,KAAK,CAAC;IAC7C,WAAW,EAAE,CAAC,YAAY,EAAE,IAAI,CAAC;IACjC,WAAW,EAAE,CAAC,SAAS,EAAE,IAAI,CAAC;IAC9B,WAAW,EAAE,CAAC,SAAS,EAAE,IAAI,CAAC;IAC9B,WAAW,EAAE,CAAC,cAAc,EAAE,IAAI,EAAE,IAAI,CAAC;IACzC,WAAW,EAAE,CAAC,SAAS,EAAE,IAAI,CAAC;IAC9B,WAAW,EAAE,CAAC,QAAQ,EAAE,IAAI,CAAC;IAC7B,WAAW,EAAE,CAAC,QAAQ,EAAE,IAAI,CAAC;IAC7B,WAAW,EAAE,CAAC,uBAAuB,EAAE,IAAI,CAAC;IAC5C,WAAW,EAAE,CAAC,SAAS,EAAE,IAAI,CAAC;IAC9B,UAAU,EAAE,CAAC,6BAA6B,EAAE,IAAI,CAAC;IACjD,YAAY,EAAE,CAAC,WAAW,EAAE,KAAK,CAAC;CACnC,CAAA;AAED,+DAA+D;AAC/D,mBAAmB;AACnB,MAAM,WAAW,GAAG,CAAC,CAAS,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,WAAW,EAAE,MAAM,CAAC,CAAA;AACjE,qCAAqC;AACrC,MAAM,YAAY,GAAG,CAAC,CAAS,EAAE,EAAE,CACjC,CAAC,CAAC,OAAO,CAAC,0BAA0B,EAAE,MAAM,CAAC,CAAA;AAE/C,4DAA4D;AAC5D,MAAM,cAAc,GAAG,CAAC,MAAgB,EAAU,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;AASpE,+DAA+D;AAC/D,kEAAkE;AAClE,mEAAmE;AACnE,yCAAyC;AACzC,iEAAiE;AACjE,6BAA6B;AACtB,MAAM,UAAU,GAAG,CACxB,IAAY,EACZ,QAAgB,EACE,EAAE;IACpB,MAAM,GAAG,GAAG,QAAQ,CAAA;IACpB,qBAAqB;IACrB,IAAI,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,GAAG,EAAE;QAC5B,MAAM,IAAI,KAAK,CAAC,2BAA2B,CAAC,CAAA;KAC7C;IACD,oBAAoB;IACpB,MAAM,MAAM,GAAa,EAAE,CAAA;IAC3B,MAAM,IAAI,GAAa,EAAE,CAAA;IAEzB,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC,CAAA;IACf,IAAI,QAAQ,GAAG,KAAK,CAAA;IACpB,IAAI,KAAK,GAAG,KAAK,CAAA;IACjB,IAAI,QAAQ,GAAG,KAAK,CAAA;IACpB,IAAI,MAAM,GAAG,KAAK,CAAA;IAClB,IAAI,MAAM,GAAG,GAAG,CAAA;IAChB,IAAI,UAAU,GAAG,EAAE,CAAA;IACnB,KAAK,EAAE,OAAO,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE;QAC7B,MAAM,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAA;QACxB,IAAI,CAAC,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,KAAK,GAAG,GAAG,CAAC,EAAE;YAC7C,MAAM,GAAG,IAAI,CAAA;YACb,CAAC,EAAE,CAAA;YACH,SAAQ;SACT;QAED,IAAI,CAAC,KAAK,GAAG,IAAI,QAAQ,IAAI,CAAC,QAAQ,EAAE;YACtC,MAAM,GAAG,CAAC,GAAG,CAAC,CAAA;YACd,MAAK;SACN;QAED,QAAQ,GAAG,IAAI,CAAA;QACf,IAAI,CAAC,KAAK,IAAI,EAAE;YACd,IAAI,CAAC,QAAQ,EAAE;gBACb,QAAQ,GAAG,IAAI,CAAA;gBACf,CAAC,EAAE,CAAA;gBACH,SAAQ;aACT;YACD,0DAA0D;SAC3D;QACD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE;YAC1B,4DAA4D;YAC5D,KAAK,MAAM,CAAC,GAAG,EAAE,CAAC,IAAI,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE;gBAChE,IAAI,IAAI,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC,CAAC,EAAE;oBAC3B,+CAA+C;oBAC/C,IAAI,UAAU,EAAE;wBACd,OAAO,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC,MAAM,GAAG,GAAG,EAAE,IAAI,CAAC,CAAA;qBAC9C;oBACD,CAAC,IAAI,GAAG,CAAC,MAAM,CAAA;oBACf,IAAI,GAAG;wBAAE,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;;wBACnB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;oBACtB,KAAK,GAAG,KAAK,IAAI,CAAC,CAAA;oBAClB,SAAS,KAAK,CAAA;iBACf;aACF;SACF;QAED,gDAAgD;QAChD,QAAQ,GAAG,KAAK,CAAA;QAChB,IAAI,UAAU,EAAE;YACd,sDAAsD;YACtD,mBAAmB;YACnB,IAAI,CAAC,GAAG,UAAU,EAAE;gBAClB,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,GAAG,GAAG,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC,CAAA;aAC5D;iBAAM,IAAI,CAAC,KAAK,UAAU,EAAE;gBAC3B,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAA;aAC5B;YACD,UAAU,GAAG,EAAE,CAAA;YACf,CAAC,EAAE,CAAA;YACH,SAAQ;SACT;QAED,qCAAqC;QACrC,8DAA8D;QAC9D,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;YAChC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,CAAA;YACjC,CAAC,IAAI,CAAC,CAAA;YACN,SAAQ;SACT;QACD,IAAI,IAAI,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;YAC/B,UAAU,GAAG,CAAC,CAAA;YACd,CAAC,IAAI,CAAC,CAAA;YACN,SAAQ;SACT;QAED,oDAAoD;QACpD,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAA;QAC3B,CAAC,EAAE,CAAA;KACJ;IAED,IAAI,MAAM,GAAG,CAAC,EAAE;QACd,sDAAsD;QACtD,+CAA+C;QAC/C,OAAO,CAAC,EAAE,EAAE,KAAK,EAAE,CAAC,EAAE,KAAK,CAAC,CAAA;KAC7B;IAED,gEAAgE;IAChE,kEAAkE;IAClE,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;QAClC,OAAO,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC,MAAM,GAAG,GAAG,EAAE,IAAI,CAAC,CAAA;KAC9C;IAED,yEAAyE;IACzE,sEAAsE;IACtE,yEAAyE;IACzE,sEAAsE;IACtE,IACE,IAAI,CAAC,MAAM,KAAK,CAAC;QACjB,MAAM,CAAC,MAAM,KAAK,CAAC;QACnB,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QACxB,CAAC,MAAM,EACP;QACA,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAA;QAClE,OAAO,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,MAAM,GAAG,GAAG,EAAE,KAAK,CAAC,CAAA;KACrD;IAED,MAAM,OAAO,GAAG,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,cAAc,CAAC,MAAM,CAAC,GAAG,GAAG,CAAA;IACxE,MAAM,KAAK,GAAG,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,cAAc,CAAC,IAAI,CAAC,GAAG,GAAG,CAAA;IACpE,MAAM,IAAI,GACR,MAAM,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM;QAC1B,CAAC,CAAC,GAAG,GAAG,OAAO,GAAG,GAAG,GAAG,KAAK,GAAG,GAAG;QACnC,CAAC,CAAC,MAAM,CAAC,MAAM;YACf,CAAC,CAAC,OAAO;YACT,CAAC,CAAC,KAAK,CAAA;IAEX,OAAO,CAAC,IAAI,EAAE,KAAK,EAAE,MAAM,GAAG,GAAG,EAAE,IAAI,CAAC,CAAA;AAC1C,CAAC,CAAA;AAhIY,QAAA,UAAU,cAgItB&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// translate the various posix character classes into unicode properties</span><span class="s3">\n</span><span class="s1">// this works across all unicode locales</span><span class="s3">\n\n</span><span class="s1">// { &lt;posix class&gt;: [&lt;translation&gt;, /u flag required, negated]</span><span class="s3">\n</span><span class="s1">const posixClasses: { [k: string]: [e: string, u: boolean, n?: boolean] } = {</span><span class="s3">\n  </span><span class="s1">'[:alnum:]': ['</span><span class="s3">\\\\</span><span class="s1">p{L}</span><span class="s3">\\\\</span><span class="s1">p{Nl}</span><span class="s3">\\\\</span><span class="s1">p{Nd}', true],</span><span class="s3">\n  </span><span class="s1">'[:alpha:]': ['</span><span class="s3">\\\\</span><span class="s1">p{L}</span><span class="s3">\\\\</span><span class="s1">p{Nl}', true],</span><span class="s3">\n  </span><span class="s1">'[:ascii:]': ['</span><span class="s3">\\\\</span><span class="s1">x' + '00-</span><span class="s3">\\\\</span><span class="s1">x' + '7f', false],</span><span class="s3">\n  </span><span class="s1">'[:blank:]': ['</span><span class="s3">\\\\</span><span class="s1">p{Zs}</span><span class="s3">\\\\</span><span class="s1">t', true],</span><span class="s3">\n  </span><span class="s1">'[:cntrl:]': ['</span><span class="s3">\\\\</span><span class="s1">p{Cc}', true],</span><span class="s3">\n  </span><span class="s1">'[:digit:]': ['</span><span class="s3">\\\\</span><span class="s1">p{Nd}', true],</span><span class="s3">\n  </span><span class="s1">'[:graph:]': ['</span><span class="s3">\\\\</span><span class="s1">p{Z}</span><span class="s3">\\\\</span><span class="s1">p{C}', true, true],</span><span class="s3">\n  </span><span class="s1">'[:lower:]': ['</span><span class="s3">\\\\</span><span class="s1">p{Ll}', true],</span><span class="s3">\n  </span><span class="s1">'[:print:]': ['</span><span class="s3">\\\\</span><span class="s1">p{C}', true],</span><span class="s3">\n  </span><span class="s1">'[:punct:]': ['</span><span class="s3">\\\\</span><span class="s1">p{P}', true],</span><span class="s3">\n  </span><span class="s1">'[:space:]': ['</span><span class="s3">\\\\</span><span class="s1">p{Z}</span><span class="s3">\\\\</span><span class="s1">t</span><span class="s3">\\\\</span><span class="s1">r</span><span class="s3">\\\\</span><span class="s1">n</span><span class="s3">\\\\</span><span class="s1">v</span><span class="s3">\\\\</span><span class="s1">f', true],</span><span class="s3">\n  </span><span class="s1">'[:upper:]': ['</span><span class="s3">\\\\</span><span class="s1">p{Lu}', true],</span><span class="s3">\n  </span><span class="s1">'[:word:]': ['</span><span class="s3">\\\\</span><span class="s1">p{L}</span><span class="s3">\\\\</span><span class="s1">p{Nl}</span><span class="s3">\\\\</span><span class="s1">p{Nd}</span><span class="s3">\\\\</span><span class="s1">p{Pc}', true],</span><span class="s3">\n  </span><span class="s1">'[:xdigit:]': ['A-Fa-f0-9', false],</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// only need to escape a few things inside of brace expressions</span><span class="s3">\n</span><span class="s1">// escapes: [ </span><span class="s3">\\ </span><span class="s1">] -</span><span class="s3">\n</span><span class="s1">const braceEscape = (s: string) =&gt; s.replace(/[[</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\\\</span><span class="s1">-]/g, '</span><span class="s3">\\\\</span><span class="s1">$&amp;')</span><span class="s3">\n</span><span class="s1">// escape all regexp magic characters</span><span class="s3">\n</span><span class="s1">const regexpEscape = (s: string) =&gt;</span><span class="s3">\n  </span><span class="s1">s.replace(/[-[</span><span class="s3">\\</span><span class="s1">]{}()*+?.,</span><span class="s3">\\\\</span><span class="s1">^$|#</span><span class="s3">\\</span><span class="s1">s]/g, '</span><span class="s3">\\\\</span><span class="s1">$&amp;')</span><span class="s3">\n\n</span><span class="s1">// everything has already been escaped, we just have to join</span><span class="s3">\n</span><span class="s1">const rangesToString = (ranges: string[]): string =&gt; ranges.join('')</span><span class="s3">\n\n</span><span class="s1">export type ParseClassResult = [</span><span class="s3">\n  </span><span class="s1">src: string,</span><span class="s3">\n  </span><span class="s1">uFlag: boolean,</span><span class="s3">\n  </span><span class="s1">consumed: number,</span><span class="s3">\n  </span><span class="s1">hasMagic: boolean</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">// takes a glob string at a posix brace expression, and returns</span><span class="s3">\n</span><span class="s1">// an equivalent regular expression source, and boolean indicating</span><span class="s3">\n</span><span class="s1">// whether the /u flag needs to be applied, and the number of chars</span><span class="s3">\n</span><span class="s1">// consumed to parse the character class.</span><span class="s3">\n</span><span class="s1">// This also removes out of order ranges, and returns ($.) if the</span><span class="s3">\n</span><span class="s1">// entire class just no good.</span><span class="s3">\n</span><span class="s1">export const parseClass = (</span><span class="s3">\n  </span><span class="s1">glob: string,</span><span class="s3">\n  </span><span class="s1">position: number</span><span class="s3">\n</span><span class="s1">): ParseClassResult =&gt; {</span><span class="s3">\n  </span><span class="s1">const pos = position</span><span class="s3">\n  </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n  </span><span class="s1">if (glob.charAt(pos) !== '[') {</span><span class="s3">\n    </span><span class="s1">throw new Error('not in a brace expression')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n  </span><span class="s1">const ranges: string[] = []</span><span class="s3">\n  </span><span class="s1">const negs: string[] = []</span><span class="s3">\n\n  </span><span class="s1">let i = pos + 1</span><span class="s3">\n  </span><span class="s1">let sawStart = false</span><span class="s3">\n  </span><span class="s1">let uflag = false</span><span class="s3">\n  </span><span class="s1">let escaping = false</span><span class="s3">\n  </span><span class="s1">let negate = false</span><span class="s3">\n  </span><span class="s1">let endPos = pos</span><span class="s3">\n  </span><span class="s1">let rangeStart = ''</span><span class="s3">\n  </span><span class="s1">WHILE: while (i &lt; glob.length) {</span><span class="s3">\n    </span><span class="s1">const c = glob.charAt(i)</span><span class="s3">\n    </span><span class="s1">if ((c === '!' || c === '^') &amp;&amp; i === pos + 1) {</span><span class="s3">\n      </span><span class="s1">negate = true</span><span class="s3">\n      </span><span class="s1">i++</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (c === ']' &amp;&amp; sawStart &amp;&amp; !escaping) {</span><span class="s3">\n      </span><span class="s1">endPos = i + 1</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">sawStart = true</span><span class="s3">\n    </span><span class="s1">if (c === '</span><span class="s3">\\\\</span><span class="s1">') {</span><span class="s3">\n      </span><span class="s1">if (!escaping) {</span><span class="s3">\n        </span><span class="s1">escaping = true</span><span class="s3">\n        </span><span class="s1">i++</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// escaped </span><span class="s3">\\ </span><span class="s1">char, fall through and treat like normal char</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (c === '[' &amp;&amp; !escaping) {</span><span class="s3">\n      </span><span class="s1">// either a posix class, a collation equivalent, or just a [</span><span class="s3">\n      </span><span class="s1">for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {</span><span class="s3">\n        </span><span class="s1">if (glob.startsWith(cls, i)) {</span><span class="s3">\n          </span><span class="s1">// invalid, [a-[] is fine, but not [a-[:alpha]]</span><span class="s3">\n          </span><span class="s1">if (rangeStart) {</span><span class="s3">\n            </span><span class="s1">return ['$.', false, glob.length - pos, true]</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">i += cls.length</span><span class="s3">\n          </span><span class="s1">if (neg) negs.push(unip)</span><span class="s3">\n          </span><span class="s1">else ranges.push(unip)</span><span class="s3">\n          </span><span class="s1">uflag = uflag || u</span><span class="s3">\n          </span><span class="s1">continue WHILE</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// now it's just a normal character, effectively</span><span class="s3">\n    </span><span class="s1">escaping = false</span><span class="s3">\n    </span><span class="s1">if (rangeStart) {</span><span class="s3">\n      </span><span class="s1">// throw this range away if it's not valid, but others</span><span class="s3">\n      </span><span class="s1">// can still match.</span><span class="s3">\n      </span><span class="s1">if (c &gt; rangeStart) {</span><span class="s3">\n        </span><span class="s1">ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c))</span><span class="s3">\n      </span><span class="s1">} else if (c === rangeStart) {</span><span class="s3">\n        </span><span class="s1">ranges.push(braceEscape(c))</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">rangeStart = ''</span><span class="s3">\n      </span><span class="s1">i++</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// now might be the start of a range.</span><span class="s3">\n    </span><span class="s1">// can be either c-d or c-] or c&lt;more...&gt;] or c] at this point</span><span class="s3">\n    </span><span class="s1">if (glob.startsWith('-]', i + 1)) {</span><span class="s3">\n      </span><span class="s1">ranges.push(braceEscape(c + '-'))</span><span class="s3">\n      </span><span class="s1">i += 2</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (glob.startsWith('-', i + 1)) {</span><span class="s3">\n      </span><span class="s1">rangeStart = c</span><span class="s3">\n      </span><span class="s1">i += 2</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// not the start of a range, just a single character</span><span class="s3">\n    </span><span class="s1">ranges.push(braceEscape(c))</span><span class="s3">\n    </span><span class="s1">i++</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (endPos &lt; i) {</span><span class="s3">\n    </span><span class="s1">// didn't see the end of the class, not a valid class,</span><span class="s3">\n    </span><span class="s1">// but might still be valid as a literal match.</span><span class="s3">\n    </span><span class="s1">return ['', false, 0, false]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// if we got no ranges and no negates, then we have a range that</span><span class="s3">\n  </span><span class="s1">// cannot possibly match anything, and that poisons the whole glob</span><span class="s3">\n  </span><span class="s1">if (!ranges.length &amp;&amp; !negs.length) {</span><span class="s3">\n    </span><span class="s1">return ['$.', false, glob.length - pos, true]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// if we got one positive range, and it's a single character, then that's</span><span class="s3">\n  </span><span class="s1">// not actually a magic pattern, it's just that one literal character.</span><span class="s3">\n  </span><span class="s1">// we should not treat that as </span><span class="s3">\&quot;</span><span class="s1">magic</span><span class="s3">\&quot;</span><span class="s1">, we should just return the literal</span><span class="s3">\n  </span><span class="s1">// character. [_] is a perfectly valid way to escape glob magic chars.</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">negs.length === 0 &amp;&amp;</span><span class="s3">\n    </span><span class="s1">ranges.length === 1 &amp;&amp;</span><span class="s3">\n    </span><span class="s1">/^</span><span class="s3">\\\\</span><span class="s1">?.$/.test(ranges[0]) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!negate</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0]</span><span class="s3">\n    </span><span class="s1">return [regexpEscape(r), false, endPos - pos, false]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']'</span><span class="s3">\n  </span><span class="s1">const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']'</span><span class="s3">\n  </span><span class="s1">const comb =</span><span class="s3">\n    </span><span class="s1">ranges.length &amp;&amp; negs.length</span><span class="s3">\n      </span><span class="s1">? '(' + sranges + '|' + snegs + ')'</span><span class="s3">\n      </span><span class="s1">: ranges.length</span><span class="s3">\n      </span><span class="s1">? sranges</span><span class="s3">\n      </span><span class="s1">: snegs</span><span class="s3">\n\n  </span><span class="s1">return [comb, uflag, endPos - pos, true]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">]}</span></pre>
</body>
</html>