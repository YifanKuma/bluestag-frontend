<html>
<head>
<title>animation-state.mjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
animation-state.mjs</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">{ animateVisualElement } from </span><span class="s2">'../../animation/interfaces/visual-element.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ calcChildStagger } from </span><span class="s2">'../../animation/utils/calc-child-stagger.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ isAnimationControls } from </span><span class="s2">'../../animation/utils/is-animation-controls.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ isKeyframesTarget } from </span><span class="s2">'../../animation/utils/is-keyframes-target.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ shallowCompare } from </span><span class="s2">'../../utils/shallow-compare.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ getVariantContext } from </span><span class="s2">'./get-variant-context.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ isVariantLabel } from </span><span class="s2">'./is-variant-label.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ resolveVariant } from </span><span class="s2">'./resolve-dynamic-variants.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ variantPriorityOrder } from </span><span class="s2">'./variant-props.mjs'</span><span class="s1">;</span>

<span class="s0">const </span><span class="s1">reversePriorityOrder = [...variantPriorityOrder].reverse();</span>
<span class="s0">const </span><span class="s1">numAnimationTypes = variantPriorityOrder.length;</span>
<span class="s0">function </span><span class="s1">animateList(visualElement) {</span>
    <span class="s0">return </span><span class="s1">(animations) =&gt; Promise.all(animations.map(({ animation, options }) =&gt; animateVisualElement(visualElement, animation, options)));</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createAnimationState(visualElement) {</span>
    <span class="s0">let </span><span class="s1">animate = animateList(visualElement);</span>
    <span class="s0">let </span><span class="s1">state = createState();</span>
    <span class="s0">let </span><span class="s1">isInitialRender = </span><span class="s0">true</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* This function will be used to reduce the animation definitions for</span>
     <span class="s3">* each active animation type into an object of resolved values for it.</span>
     <span class="s3">*/</span>
    <span class="s0">const </span><span class="s1">buildResolvedTypeValues = (type) =&gt; (acc, definition) =&gt; {</span>
        <span class="s0">const </span><span class="s1">resolved = resolveVariant(visualElement, definition, type === </span><span class="s2">&quot;exit&quot;</span>
            <span class="s1">? visualElement.presenceContext?.custom</span>
            <span class="s1">: undefined);</span>
        <span class="s0">if </span><span class="s1">(resolved) {</span>
            <span class="s0">const </span><span class="s1">{ transition, transitionEnd, ...target } = resolved;</span>
            <span class="s1">acc = { ...acc, ...target, ...transitionEnd };</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">acc;</span>
    <span class="s1">};</span>
    <span class="s3">/**</span>
     <span class="s3">* This just allows us to inject mocked animation functions</span>
     <span class="s3">* </span><span class="s4">@internal</span>
     <span class="s3">*/</span>
    <span class="s0">function </span><span class="s1">setAnimateFunction(makeAnimator) {</span>
        <span class="s1">animate = makeAnimator(visualElement);</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* When we receive new props, we need to:</span>
     <span class="s3">* 1. Create a list of protected keys for each type. This is a directory of</span>
     <span class="s3">*    value keys that are currently being &quot;handled&quot; by types of a higher priority</span>
     <span class="s3">*    so that whenever an animation is played of a given type, these values are</span>
     <span class="s3">*    protected from being animated.</span>
     <span class="s3">* 2. Determine if an animation type needs animating.</span>
     <span class="s3">* 3. Determine if any values have been removed from a type and figure out</span>
     <span class="s3">*    what to animate those to.</span>
     <span class="s3">*/</span>
    <span class="s0">function </span><span class="s1">animateChanges(changedActiveType) {</span>
        <span class="s0">const </span><span class="s1">{ props } = visualElement;</span>
        <span class="s0">const </span><span class="s1">context = getVariantContext(visualElement.parent) || {};</span>
        <span class="s3">/**</span>
         <span class="s3">* A list of animations that we'll build into as we iterate through the animation</span>
         <span class="s3">* types. This will get executed at the end of the function.</span>
         <span class="s3">*/</span>
        <span class="s0">const </span><span class="s1">animations = [];</span>
        <span class="s3">/**</span>
         <span class="s3">* Keep track of which values have been removed. Then, as we hit lower priority</span>
         <span class="s3">* animation types, we can check if they contain removed values and animate to that.</span>
         <span class="s3">*/</span>
        <span class="s0">const </span><span class="s1">removedKeys = </span><span class="s0">new </span><span class="s1">Set();</span>
        <span class="s3">/**</span>
         <span class="s3">* A dictionary of all encountered keys. This is an object to let us build into and</span>
         <span class="s3">* copy it without iteration. Each time we hit an animation type we set its protected</span>
         <span class="s3">* keys - the keys its not allowed to animate - to the latest version of this object.</span>
         <span class="s3">*/</span>
        <span class="s0">let </span><span class="s1">encounteredKeys = {};</span>
        <span class="s3">/**</span>
         <span class="s3">* If a variant has been removed at a given index, and this component is controlling</span>
         <span class="s3">* variant animations, we want to ensure lower-priority variants are forced to animate.</span>
         <span class="s3">*/</span>
        <span class="s0">let </span><span class="s1">removedVariantIndex = Infinity;</span>
        <span class="s3">/**</span>
         <span class="s3">* Iterate through all animation types in reverse priority order. For each, we want to</span>
         <span class="s3">* detect which values it's handling and whether or not they've changed (and therefore</span>
         <span class="s3">* need to be animated). If any values have been removed, we want to detect those in</span>
         <span class="s3">* lower priority props and flag for animation.</span>
         <span class="s3">*/</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; numAnimationTypes; i++) {</span>
            <span class="s0">const </span><span class="s1">type = reversePriorityOrder[i];</span>
            <span class="s0">const </span><span class="s1">typeState = state[type];</span>
            <span class="s0">const </span><span class="s1">prop = props[type] !== undefined</span>
                <span class="s1">? props[type]</span>
                <span class="s1">: context[type];</span>
            <span class="s0">const </span><span class="s1">propIsVariant = isVariantLabel(prop);</span>
            <span class="s3">/**</span>
             <span class="s3">* If this type has *just* changed isActive status, set activeDelta</span>
             <span class="s3">* to that status. Otherwise set to null.</span>
             <span class="s3">*/</span>
            <span class="s0">const </span><span class="s1">activeDelta = type === changedActiveType ? typeState.isActive : </span><span class="s0">null</span><span class="s1">;</span>
            <span class="s0">if </span><span class="s1">(activeDelta === </span><span class="s0">false</span><span class="s1">)</span>
                <span class="s1">removedVariantIndex = i;</span>
            <span class="s3">/**</span>
             <span class="s3">* If this prop is an inherited variant, rather than been set directly on the</span>
             <span class="s3">* component itself, we want to make sure we allow the parent to trigger animations.</span>
             <span class="s3">*</span>
             <span class="s3">* TODO: Can probably change this to a !isControllingVariants check</span>
             <span class="s3">*/</span>
            <span class="s0">let </span><span class="s1">isInherited = prop === context[type] &amp;&amp;</span>
                <span class="s1">prop !== props[type] &amp;&amp;</span>
                <span class="s1">propIsVariant;</span>
            <span class="s0">if </span><span class="s1">(isInherited &amp;&amp;</span>
                <span class="s1">isInitialRender &amp;&amp;</span>
                <span class="s1">visualElement.manuallyAnimateOnMount) {</span>
                <span class="s1">isInherited = </span><span class="s0">false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* Set all encountered keys so far as the protected keys for this type. This will</span>
             <span class="s3">* be any key that has been animated or otherwise handled by active, higher-priortiy types.</span>
             <span class="s3">*/</span>
            <span class="s1">typeState.protectedKeys = { ...encounteredKeys };</span>
            <span class="s3">// Check if we can skip analysing this prop early</span>
            <span class="s0">if </span><span class="s1">(</span>
            <span class="s3">// If it isn't active and hasn't *just* been set as inactive</span>
            <span class="s1">(!typeState.isActive &amp;&amp; activeDelta === </span><span class="s0">null</span><span class="s1">) ||</span>
                <span class="s3">// If we didn't and don't have any defined prop for this animation type</span>
                <span class="s1">(!prop &amp;&amp; !typeState.prevProp) ||</span>
                <span class="s3">// Or if the prop doesn't define an animation</span>
                <span class="s1">isAnimationControls(prop) ||</span>
                <span class="s0">typeof </span><span class="s1">prop === </span><span class="s2">&quot;boolean&quot;</span><span class="s1">) {</span>
                <span class="s0">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* As we go look through the values defined on this type, if we detect</span>
             <span class="s3">* a changed value or a value that was removed in a higher priority, we set</span>
             <span class="s3">* this to true and add this prop to the animation list.</span>
             <span class="s3">*/</span>
            <span class="s0">const </span><span class="s1">variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);</span>
            <span class="s0">let </span><span class="s1">shouldAnimateType = variantDidChange ||</span>
                <span class="s3">// If we're making this variant active, we want to always make it active</span>
                <span class="s1">(type === changedActiveType &amp;&amp;</span>
                    <span class="s1">typeState.isActive &amp;&amp;</span>
                    <span class="s1">!isInherited &amp;&amp;</span>
                    <span class="s1">propIsVariant) ||</span>
                <span class="s3">// If we removed a higher-priority variant (i is in reverse order)</span>
                <span class="s1">(i &gt; removedVariantIndex &amp;&amp; propIsVariant);</span>
            <span class="s0">let </span><span class="s1">handledRemovedValues = </span><span class="s0">false</span><span class="s1">;</span>
            <span class="s3">/**</span>
             <span class="s3">* As animations can be set as variant lists, variants or target objects, we</span>
             <span class="s3">* coerce everything to an array if it isn't one already</span>
             <span class="s3">*/</span>
            <span class="s0">const </span><span class="s1">definitionList = Array.isArray(prop) ? prop : [prop];</span>
            <span class="s3">/**</span>
             <span class="s3">* Build an object of all the resolved values. We'll use this in the subsequent</span>
             <span class="s3">* animateChanges calls to determine whether a value has changed.</span>
             <span class="s3">*/</span>
            <span class="s0">let </span><span class="s1">resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});</span>
            <span class="s0">if </span><span class="s1">(activeDelta === </span><span class="s0">false</span><span class="s1">)</span>
                <span class="s1">resolvedValues = {};</span>
            <span class="s3">/**</span>
             <span class="s3">* Now we need to loop through all the keys in the prev prop and this prop,</span>
             <span class="s3">* and decide:</span>
             <span class="s3">* 1. If the value has changed, and needs animating</span>
             <span class="s3">* 2. If it has been removed, and needs adding to the removedKeys set</span>
             <span class="s3">* 3. If it has been removed in a higher priority type and needs animating</span>
             <span class="s3">* 4. If it hasn't been removed in a higher priority but hasn't changed, and</span>
             <span class="s3">*    needs adding to the type's protectedKeys list.</span>
             <span class="s3">*/</span>
            <span class="s0">const </span><span class="s1">{ prevResolvedValues = {} } = typeState;</span>
            <span class="s0">const </span><span class="s1">allKeys = {</span>
                <span class="s1">...prevResolvedValues,</span>
                <span class="s1">...resolvedValues,</span>
            <span class="s1">};</span>
            <span class="s0">const </span><span class="s1">markToAnimate = (key) =&gt; {</span>
                <span class="s1">shouldAnimateType = </span><span class="s0">true</span><span class="s1">;</span>
                <span class="s0">if </span><span class="s1">(removedKeys.has(key)) {</span>
                    <span class="s1">handledRemovedValues = </span><span class="s0">true</span><span class="s1">;</span>
                    <span class="s1">removedKeys.delete(key);</span>
                <span class="s1">}</span>
                <span class="s1">typeState.needsAnimating[key] = </span><span class="s0">true</span><span class="s1">;</span>
                <span class="s0">const </span><span class="s1">motionValue = visualElement.getValue(key);</span>
                <span class="s0">if </span><span class="s1">(motionValue)</span>
                    <span class="s1">motionValue.liveStyle = </span><span class="s0">false</span><span class="s1">;</span>
            <span class="s1">};</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">key </span><span class="s0">in </span><span class="s1">allKeys) {</span>
                <span class="s0">const </span><span class="s1">next = resolvedValues[key];</span>
                <span class="s0">const </span><span class="s1">prev = prevResolvedValues[key];</span>
                <span class="s3">// If we've already handled this we can just skip ahead</span>
                <span class="s0">if </span><span class="s1">(encounteredKeys.hasOwnProperty(key))</span>
                    <span class="s0">continue</span><span class="s1">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* If the value has changed, we probably want to animate it.</span>
                 <span class="s3">*/</span>
                <span class="s0">let </span><span class="s1">valueHasChanged = </span><span class="s0">false</span><span class="s1">;</span>
                <span class="s0">if </span><span class="s1">(isKeyframesTarget(next) &amp;&amp; isKeyframesTarget(prev)) {</span>
                    <span class="s1">valueHasChanged = !shallowCompare(next, prev);</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s1">valueHasChanged = next !== prev;</span>
                <span class="s1">}</span>
                <span class="s0">if </span><span class="s1">(valueHasChanged) {</span>
                    <span class="s0">if </span><span class="s1">(next !== undefined &amp;&amp; next !== </span><span class="s0">null</span><span class="s1">) {</span>
                        <span class="s3">// If next is defined and doesn't equal prev, it needs animating</span>
                        <span class="s1">markToAnimate(key);</span>
                    <span class="s1">}</span>
                    <span class="s0">else </span><span class="s1">{</span>
                        <span class="s3">// If it's undefined, it's been removed.</span>
                        <span class="s1">removedKeys.add(key);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(next !== undefined &amp;&amp; removedKeys.has(key)) {</span>
                    <span class="s3">/**</span>
                     <span class="s3">* If next hasn't changed and it isn't undefined, we want to check if it's</span>
                     <span class="s3">* been removed by a higher priority</span>
                     <span class="s3">*/</span>
                    <span class="s1">markToAnimate(key);</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s3">/**</span>
                     <span class="s3">* If it hasn't changed, we add it to the list of protected values</span>
                     <span class="s3">* to ensure it doesn't get animated.</span>
                     <span class="s3">*/</span>
                    <span class="s1">typeState.protectedKeys[key] = </span><span class="s0">true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* Update the typeState so next time animateChanges is called we can compare the</span>
             <span class="s3">* latest prop and resolvedValues to these.</span>
             <span class="s3">*/</span>
            <span class="s1">typeState.prevProp = prop;</span>
            <span class="s1">typeState.prevResolvedValues = resolvedValues;</span>
            <span class="s0">if </span><span class="s1">(typeState.isActive) {</span>
                <span class="s1">encounteredKeys = { ...encounteredKeys, ...resolvedValues };</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(isInitialRender &amp;&amp; visualElement.blockInitialAnimation) {</span>
                <span class="s1">shouldAnimateType = </span><span class="s0">false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* If this is an inherited prop we want to skip this animation</span>
             <span class="s3">* unless the inherited variants haven't changed on this render.</span>
             <span class="s3">*/</span>
            <span class="s0">const </span><span class="s1">willAnimateViaParent = isInherited &amp;&amp; variantDidChange;</span>
            <span class="s0">const </span><span class="s1">needsAnimating = !willAnimateViaParent || handledRemovedValues;</span>
            <span class="s0">if </span><span class="s1">(shouldAnimateType &amp;&amp; needsAnimating) {</span>
                <span class="s1">animations.push(...definitionList.map((animation) =&gt; {</span>
                    <span class="s0">const </span><span class="s1">options = { type };</span>
                    <span class="s3">/**</span>
                     <span class="s3">* If we're performing the initial animation, but we're not</span>
                     <span class="s3">* rendering at the same time as the variant-controlling parent,</span>
                     <span class="s3">* we want to use the parent's transition to calculate the stagger.</span>
                     <span class="s3">*/</span>
                    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">animation === </span><span class="s2">&quot;string&quot; </span><span class="s1">&amp;&amp;</span>
                        <span class="s1">isInitialRender &amp;&amp;</span>
                        <span class="s1">!willAnimateViaParent &amp;&amp;</span>
                        <span class="s1">visualElement.manuallyAnimateOnMount &amp;&amp;</span>
                        <span class="s1">visualElement.parent) {</span>
                        <span class="s0">const </span><span class="s1">{ parent } = visualElement;</span>
                        <span class="s0">const </span><span class="s1">parentVariant = resolveVariant(parent, animation);</span>
                        <span class="s0">if </span><span class="s1">(parent.enteringChildren &amp;&amp; parentVariant) {</span>
                            <span class="s0">const </span><span class="s1">{ delayChildren } = parentVariant.transition || {};</span>
                            <span class="s1">options.delay = calcChildStagger(parent.enteringChildren, visualElement, delayChildren);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s0">return </span><span class="s1">{</span>
                        <span class="s1">animation: animation,</span>
                        <span class="s1">options,</span>
                    <span class="s1">};</span>
                <span class="s1">}));</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">/**</span>
         <span class="s3">* If there are some removed value that haven't been dealt with,</span>
         <span class="s3">* we need to create a new animation that falls back either to the value</span>
         <span class="s3">* defined in the style prop, or the last read value.</span>
         <span class="s3">*/</span>
        <span class="s0">if </span><span class="s1">(removedKeys.size) {</span>
            <span class="s0">const </span><span class="s1">fallbackAnimation = {};</span>
            <span class="s3">/**</span>
             <span class="s3">* If the initial prop contains a transition we can use that, otherwise</span>
             <span class="s3">* allow the animation function to use the visual element's default.</span>
             <span class="s3">*/</span>
            <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">props.initial !== </span><span class="s2">&quot;boolean&quot;</span><span class="s1">) {</span>
                <span class="s0">const </span><span class="s1">initialTransition = resolveVariant(visualElement, Array.isArray(props.initial)</span>
                    <span class="s1">? props.initial[</span><span class="s5">0</span><span class="s1">]</span>
                    <span class="s1">: props.initial);</span>
                <span class="s0">if </span><span class="s1">(initialTransition &amp;&amp; initialTransition.transition) {</span>
                    <span class="s1">fallbackAnimation.transition = initialTransition.transition;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">removedKeys.forEach((key) =&gt; {</span>
                <span class="s0">const </span><span class="s1">fallbackTarget = visualElement.getBaseTarget(key);</span>
                <span class="s0">const </span><span class="s1">motionValue = visualElement.getValue(key);</span>
                <span class="s0">if </span><span class="s1">(motionValue)</span>
                    <span class="s1">motionValue.liveStyle = </span><span class="s0">true</span><span class="s1">;</span>
                <span class="s3">// @ts-expect-error - @mattgperry to figure if we should do something here</span>
                <span class="s1">fallbackAnimation[key] = fallbackTarget ?? </span><span class="s0">null</span><span class="s1">;</span>
            <span class="s1">});</span>
            <span class="s1">animations.push({ animation: fallbackAnimation });</span>
        <span class="s1">}</span>
        <span class="s0">let </span><span class="s1">shouldAnimate = Boolean(animations.length);</span>
        <span class="s0">if </span><span class="s1">(isInitialRender &amp;&amp;</span>
            <span class="s1">(props.initial === </span><span class="s0">false </span><span class="s1">|| props.initial === props.animate) &amp;&amp;</span>
            <span class="s1">!visualElement.manuallyAnimateOnMount) {</span>
            <span class="s1">shouldAnimate = </span><span class="s0">false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">isInitialRender = </span><span class="s0">false</span><span class="s1">;</span>
        <span class="s0">return </span><span class="s1">shouldAnimate ? animate(animations) : Promise.resolve();</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Change whether a certain animation type is active.</span>
     <span class="s3">*/</span>
    <span class="s0">function </span><span class="s1">setActive(type, isActive) {</span>
        <span class="s3">// If the active state hasn't changed, we can safely do nothing here</span>
        <span class="s0">if </span><span class="s1">(state[type].isActive === isActive)</span>
            <span class="s0">return </span><span class="s1">Promise.resolve();</span>
        <span class="s3">// Propagate active change to children</span>
        <span class="s1">visualElement.variantChildren?.forEach((child) =&gt; child.animationState?.setActive(type, isActive));</span>
        <span class="s1">state[type].isActive = isActive;</span>
        <span class="s0">const </span><span class="s1">animations = animateChanges(type);</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">key </span><span class="s0">in </span><span class="s1">state) {</span>
            <span class="s1">state[key].protectedKeys = {};</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">animations;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">animateChanges,</span>
        <span class="s1">setActive,</span>
        <span class="s1">setAnimateFunction,</span>
        <span class="s1">getState: () =&gt; state,</span>
        <span class="s1">reset: () =&gt; {</span>
            <span class="s1">state = createState();</span>
            <span class="s1">isInitialRender = </span><span class="s0">true</span><span class="s1">;</span>
        <span class="s1">},</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">checkVariantsDidChange(prev, next) {</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">next === </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
        <span class="s0">return </span><span class="s1">next !== prev;</span>
    <span class="s1">}</span>
    <span class="s0">else if </span><span class="s1">(Array.isArray(next)) {</span>
        <span class="s0">return </span><span class="s1">!shallowCompare(next, prev);</span>
    <span class="s1">}</span>
    <span class="s0">return false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createTypeState(isActive = </span><span class="s0">false</span><span class="s1">) {</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">isActive,</span>
        <span class="s1">protectedKeys: {},</span>
        <span class="s1">needsAnimating: {},</span>
        <span class="s1">prevResolvedValues: {},</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createState() {</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">animate: createTypeState(</span><span class="s0">true</span><span class="s1">),</span>
        <span class="s1">whileInView: createTypeState(),</span>
        <span class="s1">whileHover: createTypeState(),</span>
        <span class="s1">whileTap: createTypeState(),</span>
        <span class="s1">whileDrag: createTypeState(),</span>
        <span class="s1">whileFocus: createTypeState(),</span>
        <span class="s1">exit: createTypeState(),</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">{ checkVariantsDidChange, createAnimationState };</span>
</pre>
</body>
</html>