<html>
<head>
<title>explicit-module-boundary-types.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #0037a6;}
.s5 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
explicit-module-boundary-types.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s2">const </span><span class="s1">scope_manager_1 = require(</span><span class="s0">&quot;@typescript-eslint/scope-manager&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">utils_1 = require(</span><span class="s0">&quot;@typescript-eslint/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">util_1 = require(</span><span class="s0">&quot;../util&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">explicitReturnTypeUtils_1 = require(</span><span class="s0">&quot;../util/explicitReturnTypeUtils&quot;</span><span class="s1">);</span>
<span class="s1">exports.default = (</span><span class="s3">0</span><span class="s1">, util_1.createRule)({</span>
    <span class="s1">name: </span><span class="s0">'explicit-module-boundary-types'</span><span class="s1">,</span>
    <span class="s1">meta: {</span>
        <span class="s1">type: </span><span class="s0">'problem'</span><span class="s1">,</span>
        <span class="s1">docs: {</span>
            <span class="s1">description: </span><span class="s0">&quot;Require explicit return and argument types on exported functions' and classes' public class methods&quot;</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">messages: {</span>
            <span class="s1">anyTypedArg: </span><span class="s0">&quot;Argument '{{name}}' should be typed with a non-any type.&quot;</span><span class="s1">,</span>
            <span class="s1">anyTypedArgUnnamed: </span><span class="s0">'{{type}} argument should be typed with a non-any type.'</span><span class="s1">,</span>
            <span class="s1">missingArgType: </span><span class="s0">&quot;Argument '{{name}}' should be typed.&quot;</span><span class="s1">,</span>
            <span class="s1">missingArgTypeUnnamed: </span><span class="s0">'{{type}} argument should be typed.'</span><span class="s1">,</span>
            <span class="s1">missingReturnType: </span><span class="s0">'Missing return type on function.'</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">schema: [</span>
            <span class="s1">{</span>
                <span class="s1">type: </span><span class="s0">'object'</span><span class="s1">,</span>
                <span class="s1">additionalProperties: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">properties: {</span>
                    <span class="s1">allowArgumentsExplicitlyTypedAsAny: {</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                        <span class="s1">description: </span><span class="s0">'Whether to ignore arguments that are explicitly typed as `any`.'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">allowDirectConstAssertionInArrowFunctions: {</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                        <span class="s1">description: [</span>
                            <span class="s0">'Whether to ignore return type annotations on body-less arrow functions that return an `as const` type assertion.'</span><span class="s1">,</span>
                            <span class="s0">'You must still type the parameters of the function.'</span><span class="s1">,</span>
                        <span class="s1">].join(</span><span class="s0">'</span><span class="s4">\n</span><span class="s0">'</span><span class="s1">),</span>
                    <span class="s1">},</span>
                    <span class="s1">allowedNames: {</span>
                        <span class="s1">type: </span><span class="s0">'array'</span><span class="s1">,</span>
                        <span class="s1">description: </span><span class="s0">'An array of function/method names that will not have their arguments or return values checked.'</span><span class="s1">,</span>
                        <span class="s1">items: {</span>
                            <span class="s1">type: </span><span class="s0">'string'</span><span class="s1">,</span>
                        <span class="s1">},</span>
                    <span class="s1">},</span>
                    <span class="s1">allowHigherOrderFunctions: {</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                        <span class="s1">description: [</span>
                            <span class="s0">'Whether to ignore return type annotations on functions immediately returning another function expression.'</span><span class="s1">,</span>
                            <span class="s0">'You must still type the parameters of the function.'</span><span class="s1">,</span>
                        <span class="s1">].join(</span><span class="s0">'</span><span class="s4">\n</span><span class="s0">'</span><span class="s1">),</span>
                    <span class="s1">},</span>
                    <span class="s1">allowOverloadFunctions: {</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                        <span class="s1">description: </span><span class="s0">'Whether to ignore return type annotations on functions with overload signatures.'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">allowTypedFunctionExpressions: {</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                        <span class="s1">description: </span><span class="s0">'Whether to ignore type annotations on the variable of a function expression.'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                <span class="s1">},</span>
            <span class="s1">},</span>
        <span class="s1">],</span>
    <span class="s1">},</span>
    <span class="s1">defaultOptions: [</span>
        <span class="s1">{</span>
            <span class="s1">allowArgumentsExplicitlyTypedAsAny: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">allowDirectConstAssertionInArrowFunctions: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">allowedNames: [],</span>
            <span class="s1">allowHigherOrderFunctions: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">allowOverloadFunctions: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">allowTypedFunctionExpressions: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">},</span>
    <span class="s1">],</span>
    <span class="s1">create(context, [options]) {</span>
        <span class="s5">// tracks all of the functions we've already checked</span>
        <span class="s2">const </span><span class="s1">checkedFunctions = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s2">const </span><span class="s1">functionStack = [];</span>
        <span class="s2">const </span><span class="s1">functionReturnsMap = </span><span class="s2">new </span><span class="s1">Map();</span>
        <span class="s5">// all nodes visited, avoids infinite recursion for cyclic references</span>
        <span class="s5">// (such as class member referring to itself)</span>
        <span class="s2">const </span><span class="s1">alreadyVisited = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s2">function </span><span class="s1">getReturnsInFunction(node) {</span>
            <span class="s2">return </span><span class="s1">functionReturnsMap.get(node) ?? [];</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">enterFunction(node) {</span>
            <span class="s1">functionStack.push(node);</span>
            <span class="s1">functionReturnsMap.set(node, []);</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">exitFunction() {</span>
            <span class="s1">functionStack.pop();</span>
        <span class="s1">}</span>
        <span class="s5">/* 
        # How the rule works: 
     
        As the rule traverses the AST, it immediately checks every single function that it finds is exported. 
        &quot;exported&quot; means that it is either directly exported, or that its name is exported. 
     
        It also collects a list of every single function it finds on the way, but does not check them. 
        After it's finished traversing the AST, it then iterates through the list of found functions, and checks to see if 
        any of them are part of a higher-order function 
        */</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s0">'ArrowFunctionExpression, FunctionDeclaration, FunctionExpression'</span><span class="s1">: enterFunction,</span>
            <span class="s0">'ArrowFunctionExpression:exit'</span><span class="s1">: exitFunction,</span>
            <span class="s0">'ExportDefaultDeclaration:exit'</span><span class="s1">(node) {</span>
                <span class="s1">checkNode(node.declaration);</span>
            <span class="s1">},</span>
            <span class="s0">'ExportNamedDeclaration:not([source]):exit'</span><span class="s1">(node) {</span>
                <span class="s2">if </span><span class="s1">(node.declaration) {</span>
                    <span class="s1">checkNode(node.declaration);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">specifier of node.specifiers) {</span>
                        <span class="s1">followReference(specifier.local);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">},</span>
            <span class="s0">'FunctionDeclaration:exit'</span><span class="s1">: exitFunction,</span>
            <span class="s0">'FunctionExpression:exit'</span><span class="s1">: exitFunction,</span>
            <span class="s0">'Program:exit'</span><span class="s1">() {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[node, returns] of functionReturnsMap) {</span>
                    <span class="s2">if </span><span class="s1">(isExportedHigherOrderFunction({ node, returns })) {</span>
                        <span class="s1">checkNode(node);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">},</span>
            <span class="s1">ReturnStatement(node) {</span>
                <span class="s2">const </span><span class="s1">current = functionStack[functionStack.length - </span><span class="s3">1</span><span class="s1">];</span>
                <span class="s1">functionReturnsMap.get(current)?.push(node);</span>
            <span class="s1">},</span>
            <span class="s0">'TSExportAssignment:exit'</span><span class="s1">(node) {</span>
                <span class="s1">checkNode(node.expression);</span>
            <span class="s1">},</span>
        <span class="s1">};</span>
        <span class="s2">function </span><span class="s1">checkParameters(node) {</span>
            <span class="s2">function </span><span class="s1">checkParameter(param) {</span>
                <span class="s2">function </span><span class="s1">report(namedMessageId, unnamedMessageId) {</span>
                    <span class="s2">if </span><span class="s1">(param.type === utils_1.AST_NODE_TYPES.Identifier) {</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node: param,</span>
                            <span class="s1">messageId: namedMessageId,</span>
                            <span class="s1">data: { name: param.name },</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(param.type === utils_1.AST_NODE_TYPES.ArrayPattern) {</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node: param,</span>
                            <span class="s1">messageId: unnamedMessageId,</span>
                            <span class="s1">data: { type: </span><span class="s0">'Array pattern' </span><span class="s1">},</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(param.type === utils_1.AST_NODE_TYPES.ObjectPattern) {</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node: param,</span>
                            <span class="s1">messageId: unnamedMessageId,</span>
                            <span class="s1">data: { type: </span><span class="s0">'Object pattern' </span><span class="s1">},</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(param.type === utils_1.AST_NODE_TYPES.RestElement) {</span>
                        <span class="s2">if </span><span class="s1">(param.argument.type === utils_1.AST_NODE_TYPES.Identifier) {</span>
                            <span class="s1">context.report({</span>
                                <span class="s1">node: param,</span>
                                <span class="s1">messageId: namedMessageId,</span>
                                <span class="s1">data: { name: param.argument.name },</span>
                            <span class="s1">});</span>
                        <span class="s1">}</span>
                        <span class="s2">else </span><span class="s1">{</span>
                            <span class="s1">context.report({</span>
                                <span class="s1">node: param,</span>
                                <span class="s1">messageId: unnamedMessageId,</span>
                                <span class="s1">data: { type: </span><span class="s0">'Rest' </span><span class="s1">},</span>
                            <span class="s1">});</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">switch </span><span class="s1">(param.type) {</span>
                    <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.ArrayPattern:</span>
                    <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.Identifier:</span>
                    <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.ObjectPattern:</span>
                    <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.RestElement:</span>
                        <span class="s2">if </span><span class="s1">(!param.typeAnnotation) {</span>
                            <span class="s1">report(</span><span class="s0">'missingArgType'</span><span class="s1">, </span><span class="s0">'missingArgTypeUnnamed'</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s2">else if </span><span class="s1">(options.allowArgumentsExplicitlyTypedAsAny !== </span><span class="s2">true </span><span class="s1">&amp;&amp;</span>
                            <span class="s1">param.typeAnnotation.typeAnnotation.type ===</span>
                                <span class="s1">utils_1.AST_NODE_TYPES.TSAnyKeyword) {</span>
                            <span class="s1">report(</span><span class="s0">'anyTypedArg'</span><span class="s1">, </span><span class="s0">'anyTypedArgUnnamed'</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s2">return</span><span class="s1">;</span>
                    <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSParameterProperty:</span>
                        <span class="s2">return </span><span class="s1">checkParameter(param.parameter);</span>
                    <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.AssignmentPattern: </span><span class="s5">// ignored as it has a type via its assignment</span>
                        <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">arg of node.params) {</span>
                <span class="s1">checkParameter(arg);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s5">/**</span>
         <span class="s5">* Checks if a function name is allowed and should not be checked.</span>
         <span class="s5">*/</span>
        <span class="s2">function </span><span class="s1">isAllowedName(node) {</span>
            <span class="s2">if </span><span class="s1">(!node || !options.allowedNames || options.allowedNames.length === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.VariableDeclarator ||</span>
                <span class="s1">node.type === utils_1.AST_NODE_TYPES.FunctionDeclaration) {</span>
                <span class="s2">return </span><span class="s1">(node.id?.type === utils_1.AST_NODE_TYPES.Identifier &amp;&amp;</span>
                    <span class="s1">options.allowedNames.includes(node.id.name));</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.MethodDefinition ||</span>
                <span class="s1">node.type === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition ||</span>
                <span class="s1">(node.type === utils_1.AST_NODE_TYPES.Property &amp;&amp; node.method) ||</span>
                <span class="s1">node.type === utils_1.AST_NODE_TYPES.PropertyDefinition ||</span>
                <span class="s1">node.type === utils_1.AST_NODE_TYPES.AccessorProperty) {</span>
                <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, util_1.isStaticMemberAccessOfValue)(node, context, ...options.allowedNames);</span>
            <span class="s1">}</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">isExportedHigherOrderFunction({ node, }) {</span>
            <span class="s2">let </span><span class="s1">current = node.parent;</span>
            <span class="s2">while </span><span class="s1">(current) {</span>
                <span class="s2">if </span><span class="s1">(current.type === utils_1.AST_NODE_TYPES.ReturnStatement) {</span>
                    <span class="s5">// the parent of a return will always be a block statement, so we can skip over it</span>
                    <span class="s1">current = current.parent.parent;</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!(</span><span class="s3">0</span><span class="s1">, util_1.isFunction)(current)) {</span>
                    <span class="s2">return false</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">returns = getReturnsInFunction(current);</span>
                <span class="s2">if </span><span class="s1">(!(</span><span class="s3">0</span><span class="s1">, explicitReturnTypeUtils_1.doesImmediatelyReturnFunctionExpression)({ node: current, returns })) {</span>
                    <span class="s2">return false</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(checkedFunctions.has(current)) {</span>
                    <span class="s2">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">current = current.parent;</span>
            <span class="s1">}</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">followReference(node) {</span>
            <span class="s2">const </span><span class="s1">scope = context.sourceCode.getScope(node);</span>
            <span class="s2">const </span><span class="s1">variable = scope.set.get(node.name);</span>
            <span class="s5">/* istanbul ignore if */ </span><span class="s2">if </span><span class="s1">(!variable) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s5">// check all of the definitions</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">definition of variable.defs) {</span>
                <span class="s5">// cases we don't care about in this rule</span>
                <span class="s2">if </span><span class="s1">([</span>
                    <span class="s1">scope_manager_1.DefinitionType.CatchClause,</span>
                    <span class="s1">scope_manager_1.DefinitionType.ImplicitGlobalVariable,</span>
                    <span class="s1">scope_manager_1.DefinitionType.ImportBinding,</span>
                    <span class="s1">scope_manager_1.DefinitionType.Parameter,</span>
                <span class="s1">].includes(definition.type)) {</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">checkNode(definition.node);</span>
            <span class="s1">}</span>
            <span class="s5">// follow references to find writes to the variable</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">reference of variable.references) {</span>
                <span class="s2">if </span><span class="s1">(</span>
                <span class="s5">// we don't want to check the initialization ref, as this is handled by the declaration check</span>
                <span class="s1">!reference.init &amp;&amp;</span>
                    <span class="s1">reference.writeExpr) {</span>
                    <span class="s1">checkNode(reference.writeExpr);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkNode(node) {</span>
            <span class="s2">if </span><span class="s1">(node == </span><span class="s2">null </span><span class="s1">|| alreadyVisited.has(node)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">alreadyVisited.add(node);</span>
            <span class="s2">switch </span><span class="s1">(node.type) {</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.ArrowFunctionExpression:</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.FunctionExpression: {</span>
                    <span class="s2">const </span><span class="s1">returns = getReturnsInFunction(node);</span>
                    <span class="s2">return </span><span class="s1">checkFunctionExpression({ node, returns });</span>
                <span class="s1">}</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.ArrayExpression:</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">element of node.elements) {</span>
                        <span class="s1">checkNode(element);</span>
                    <span class="s1">}</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.PropertyDefinition:</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.AccessorProperty:</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.MethodDefinition:</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:</span>
                    <span class="s2">if </span><span class="s1">(node.accessibility === </span><span class="s0">'private' </span><span class="s1">||</span>
                        <span class="s1">node.key.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {</span>
                        <span class="s2">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">checkNode(node.value);</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.ClassDeclaration:</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.ClassExpression:</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">element of node.body.body) {</span>
                        <span class="s1">checkNode(element);</span>
                    <span class="s1">}</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.FunctionDeclaration: {</span>
                    <span class="s2">const </span><span class="s1">returns = getReturnsInFunction(node);</span>
                    <span class="s2">return </span><span class="s1">checkFunction({ node, returns });</span>
                <span class="s1">}</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.Identifier:</span>
                    <span class="s2">return </span><span class="s1">followReference(node);</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.ObjectExpression:</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">property of node.properties) {</span>
                        <span class="s1">checkNode(property);</span>
                    <span class="s1">}</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.Property:</span>
                    <span class="s2">return </span><span class="s1">checkNode(node.value);</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression:</span>
                    <span class="s2">return </span><span class="s1">checkEmptyBodyFunctionExpression(node);</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.VariableDeclaration:</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">declaration of node.declarations) {</span>
                        <span class="s1">checkNode(declaration);</span>
                    <span class="s1">}</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.VariableDeclarator:</span>
                    <span class="s2">return </span><span class="s1">checkNode(node.init);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkEmptyBodyFunctionExpression(node) {</span>
            <span class="s2">const </span><span class="s1">isConstructor = node.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition &amp;&amp;</span>
                <span class="s1">node.parent.kind === </span><span class="s0">'constructor'</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">isSetAccessor = (node.parent.type === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition ||</span>
                <span class="s1">node.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition) &amp;&amp;</span>
                <span class="s1">node.parent.kind === </span><span class="s0">'set'</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(!isConstructor &amp;&amp; !isSetAccessor &amp;&amp; !node.returnType) {</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node,</span>
                    <span class="s1">messageId: </span><span class="s0">'missingReturnType'</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s1">checkParameters(node);</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkFunctionExpression({ node, returns, }) {</span>
            <span class="s2">if </span><span class="s1">(checkedFunctions.has(node)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">checkedFunctions.add(node);</span>
            <span class="s2">if </span><span class="s1">(isAllowedName(node.parent) ||</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, explicitReturnTypeUtils_1.isTypedFunctionExpression)(node, options) ||</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, explicitReturnTypeUtils_1.ancestorHasReturnType)(node)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(options.allowOverloadFunctions &amp;&amp;</span>
                <span class="s1">node.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition &amp;&amp;</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, util_1.hasOverloadSignatures)(node.parent, context)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, explicitReturnTypeUtils_1.checkFunctionExpressionReturnType)({ node, returns }, options, context.sourceCode, loc =&gt; {</span>
                <span class="s1">context.report({</span>
                    <span class="s1">loc,</span>
                    <span class="s1">node,</span>
                    <span class="s1">messageId: </span><span class="s0">'missingReturnType'</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s1">});</span>
            <span class="s1">checkParameters(node);</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkFunction({ node, returns, }) {</span>
            <span class="s2">if </span><span class="s1">(checkedFunctions.has(node)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">checkedFunctions.add(node);</span>
            <span class="s2">if </span><span class="s1">(isAllowedName(node) || (</span><span class="s3">0</span><span class="s1">, explicitReturnTypeUtils_1.ancestorHasReturnType)(node)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(options.allowOverloadFunctions &amp;&amp;</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, util_1.hasOverloadSignatures)(node, context)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, explicitReturnTypeUtils_1.checkFunctionReturnType)({ node, returns }, options, context.sourceCode, loc =&gt; {</span>
                <span class="s1">context.report({</span>
                    <span class="s1">loc,</span>
                    <span class="s1">node,</span>
                    <span class="s1">messageId: </span><span class="s0">'missingReturnType'</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s1">});</span>
            <span class="s1">checkParameters(node);</span>
        <span class="s1">}</span>
    <span class="s1">},</span>
<span class="s1">});</span>
</pre>
</body>
</html>