<html>
<head>
<title>emnapi.d.mts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #8c8c8c; font-style: italic;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
emnapi.d.mts</font>
</center></td></tr></table>
<pre><span class="s0">export </span><span class="s1">declare type Ptr = number | bigint</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">IBuffer </span><span class="s0">extends </span><span class="s1">Uint8Array {}</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">BufferCtor {</span>
  <span class="s1">readonly prototype: IBuffer</span>
  <span class="s2">/** </span><span class="s3">@deprecated </span><span class="s2">*/</span>
  <span class="s0">new </span><span class="s1">(...args: any[]): IBuffer</span>
  <span class="s1">from: {</span>
    <span class="s1">(buffer: ArrayBufferLike): IBuffer</span>
    <span class="s1">(buffer: ArrayBufferLike, byteOffset: number, length: number): IBuffer</span>
  <span class="s1">}</span>
  <span class="s1">alloc: (size: number) =&gt; IBuffer</span>
  <span class="s1">isBuffer: (obj: unknown) =&gt; obj is IBuffer</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const enum </span><span class="s1">GlobalHandle {</span>
  <span class="s1">UNDEFINED = </span><span class="s4">1</span><span class="s1">,</span>
  <span class="s1">NULL,</span>
  <span class="s1">FALSE,</span>
  <span class="s1">TRUE,</span>
  <span class="s1">GLOBAL</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const enum </span><span class="s1">Version {</span>
  <span class="s1">NODE_API_SUPPORTED_VERSION_MIN = </span><span class="s4">1</span><span class="s1">,</span>
  <span class="s1">NODE_API_DEFAULT_MODULE_API_VERSION = </span><span class="s4">8</span><span class="s1">,</span>
  <span class="s1">NODE_API_SUPPORTED_VERSION_MAX = </span><span class="s4">10</span><span class="s1">,</span>
  <span class="s1">NAPI_VERSION_EXPERIMENTAL = </span><span class="s4">2147483647 </span><span class="s2">// INT_MAX</span>
<span class="s1">}</span>
<span class="s2">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span>
<span class="s0">export </span><span class="s1">declare type Pointer&lt;T&gt; = number</span>
<span class="s2">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span>
<span class="s0">export </span><span class="s1">declare type PointerPointer&lt;T&gt; = number</span>
<span class="s0">export </span><span class="s1">declare type FunctionPointer&lt;T </span><span class="s0">extends </span><span class="s1">(...args: any[]) =&gt; any&gt; = Pointer&lt;T&gt;</span>
<span class="s0">export </span><span class="s1">declare type Const&lt;T&gt; = T</span>

<span class="s0">export </span><span class="s1">declare type void_p = Pointer&lt;</span><span class="s0">void</span><span class="s1">&gt;</span>
<span class="s0">export </span><span class="s1">declare type void_pp = Pointer&lt;void_p&gt;</span>
<span class="s0">export </span><span class="s1">declare type bool = number</span>
<span class="s0">export </span><span class="s1">declare type char = number</span>
<span class="s0">export </span><span class="s1">declare type char_p = Pointer&lt;char&gt;</span>
<span class="s0">export </span><span class="s1">declare type unsigned_char = number</span>
<span class="s0">export </span><span class="s1">declare type const_char = Const&lt;char&gt;</span>
<span class="s0">export </span><span class="s1">declare type const_char_p = Pointer&lt;const_char&gt;</span>
<span class="s0">export </span><span class="s1">declare type char16_t_p = number</span>
<span class="s0">export </span><span class="s1">declare type const_char16_t_p = number</span>

<span class="s0">export </span><span class="s1">declare type short = number</span>
<span class="s0">export </span><span class="s1">declare type unsigned_short = number</span>
<span class="s0">export </span><span class="s1">declare type int = number</span>
<span class="s0">export </span><span class="s1">declare type unsigned_int = number</span>
<span class="s0">export </span><span class="s1">declare type long = number</span>
<span class="s0">export </span><span class="s1">declare type unsigned_long = number</span>
<span class="s0">export </span><span class="s1">declare type long_long = bigint</span>
<span class="s0">export </span><span class="s1">declare type unsigned_long_long = bigint</span>
<span class="s0">export </span><span class="s1">declare type float = number</span>
<span class="s0">export </span><span class="s1">declare type double = number</span>
<span class="s0">export </span><span class="s1">declare type long_double = number</span>
<span class="s0">export </span><span class="s1">declare type size_t = number</span>

<span class="s0">export </span><span class="s1">declare type int8_t = number</span>
<span class="s0">export </span><span class="s1">declare type uint8_t = number</span>
<span class="s0">export </span><span class="s1">declare type int16_t = number</span>
<span class="s0">export </span><span class="s1">declare type uint16_t = number</span>
<span class="s0">export </span><span class="s1">declare type int32_t = number</span>
<span class="s0">export </span><span class="s1">declare type uint32_t = number</span>
<span class="s0">export </span><span class="s1">declare type int64_t = bigint</span>
<span class="s0">export </span><span class="s1">declare type uint64_t = bigint</span>
<span class="s0">export </span><span class="s1">declare type napi_env = Pointer&lt;unknown&gt;</span>

<span class="s0">export </span><span class="s1">declare type napi_value = Pointer&lt;unknown&gt;</span>
<span class="s0">export </span><span class="s1">declare type napi_ref = Pointer&lt;unknown&gt;</span>
<span class="s0">export </span><span class="s1">declare type napi_deferred = Pointer&lt;unknown&gt;</span>
<span class="s0">export </span><span class="s1">declare type napi_handle_scope = Pointer&lt;unknown&gt;</span>
<span class="s0">export </span><span class="s1">declare type napi_escapable_handle_scope = Pointer&lt;unknown&gt;</span>

<span class="s0">export </span><span class="s1">declare type napi_addon_register_func = FunctionPointer&lt;(env: napi_env, exports: napi_value) =&gt; napi_value&gt;</span>

<span class="s0">export </span><span class="s1">declare type napi_callback_info = Pointer&lt;unknown&gt;</span>
<span class="s0">export </span><span class="s1">declare type napi_callback = FunctionPointer&lt;(env: napi_env, info: napi_callback_info) =&gt; napi_value&gt;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">napi_extended_error_info {</span>
  <span class="s1">error_message: const_char_p</span>
  <span class="s1">engine_reserved: void_p</span>
  <span class="s1">engine_error_code: uint32_t</span>
  <span class="s1">error_code: napi_status</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">napi_property_descriptor {</span>
  <span class="s2">// One of utf8name or name should be NULL.</span>
  <span class="s1">utf8name: const_char_p</span>
  <span class="s1">name: napi_value</span>

  <span class="s1">method: napi_callback</span>
  <span class="s1">getter: napi_callback</span>
  <span class="s1">setter: napi_callback</span>
  <span class="s1">value: napi_value</span>
  <span class="s2">/* napi_property_attributes */</span>
  <span class="s1">attributes: number</span>
  <span class="s1">data: void_p</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare type napi_finalize = FunctionPointer&lt;(</span>
  <span class="s1">env: napi_env,</span>
  <span class="s1">finalize_data: void_p,</span>
  <span class="s1">finalize_hint: void_p</span>
<span class="s1">) =&gt; </span><span class="s0">void</span><span class="s1">&gt;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">node_module {</span>
  <span class="s1">nm_version: int32_t</span>
  <span class="s1">nm_flags: uint32_t</span>
  <span class="s1">nm_filename: Pointer&lt;const_char&gt;</span>
  <span class="s1">nm_register_func: napi_addon_register_func</span>
  <span class="s1">nm_modname: Pointer&lt;const_char&gt;</span>
  <span class="s1">nm_priv: Pointer&lt;</span><span class="s0">void</span><span class="s1">&gt;</span>
  <span class="s1">reserved: PointerPointer&lt;</span><span class="s0">void</span><span class="s1">&gt;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">napi_node_version {</span>
  <span class="s1">major: uint32_t</span>
  <span class="s1">minor: uint32_t</span>
  <span class="s1">patch: uint32_t</span>
  <span class="s1">release: const_char_p</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">emnapi_emscripten_version {</span>
  <span class="s1">major: uint32_t</span>
  <span class="s1">minor: uint32_t</span>
  <span class="s1">patch: uint32_t</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const enum </span><span class="s1">napi_status {</span>
  <span class="s1">napi_ok,</span>
  <span class="s1">napi_invalid_arg,</span>
  <span class="s1">napi_object_expected,</span>
  <span class="s1">napi_string_expected,</span>
  <span class="s1">napi_name_expected,</span>
  <span class="s1">napi_function_expected,</span>
  <span class="s1">napi_number_expected,</span>
  <span class="s1">napi_boolean_expected,</span>
  <span class="s1">napi_array_expected,</span>
  <span class="s1">napi_generic_failure,</span>
  <span class="s1">napi_pending_exception,</span>
  <span class="s1">napi_cancelled,</span>
  <span class="s1">napi_escape_called_twice,</span>
  <span class="s1">napi_handle_scope_mismatch,</span>
  <span class="s1">napi_callback_scope_mismatch,</span>
  <span class="s1">napi_queue_full,</span>
  <span class="s1">napi_closing,</span>
  <span class="s1">napi_bigint_expected,</span>
  <span class="s1">napi_date_expected,</span>
  <span class="s1">napi_arraybuffer_expected,</span>
  <span class="s1">napi_detachable_arraybuffer_expected,</span>
  <span class="s1">napi_would_deadlock, </span><span class="s2">// unused</span>
  <span class="s1">napi_no_external_buffers_allowed,</span>
  <span class="s1">napi_cannot_run_js</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const enum </span><span class="s1">napi_property_attributes {</span>
  <span class="s1">napi_default = </span><span class="s4">0</span><span class="s1">,</span>
  <span class="s1">napi_writable = </span><span class="s4">1 </span><span class="s1">&lt;&lt; </span><span class="s4">0</span><span class="s1">,</span>
  <span class="s1">napi_enumerable = </span><span class="s4">1 </span><span class="s1">&lt;&lt; </span><span class="s4">1</span><span class="s1">,</span>
  <span class="s1">napi_configurable = </span><span class="s4">1 </span><span class="s1">&lt;&lt; </span><span class="s4">2</span><span class="s1">,</span>

  <span class="s2">// Used with napi_define_class to distinguish static properties</span>
  <span class="s2">// from instance properties. Ignored by napi_define_properties.</span>
  <span class="s1">napi_static = </span><span class="s4">1 </span><span class="s1">&lt;&lt; </span><span class="s4">10</span><span class="s1">,</span>

  <span class="s2">/// #ifdef NAPI_EXPERIMENTAL</span>
  <span class="s2">// Default for class methods.</span>
  <span class="s1">napi_default_method = napi_writable | napi_configurable,</span>

  <span class="s2">// Default for object properties, like in JS obj[prop].</span>
  <span class="s1">napi_default_jsproperty = napi_writable | napi_enumerable | napi_configurable</span>
  <span class="s2">/// #endif  // NAPI_EXPERIMENTAL</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const enum </span><span class="s1">napi_valuetype {</span>
  <span class="s1">napi_undefined,</span>
  <span class="s1">napi_null,</span>
  <span class="s1">napi_boolean,</span>
  <span class="s1">napi_number,</span>
  <span class="s1">napi_string,</span>
  <span class="s1">napi_symbol,</span>
  <span class="s1">napi_object,</span>
  <span class="s1">napi_function,</span>
  <span class="s1">napi_external,</span>
  <span class="s1">napi_bigint</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const enum </span><span class="s1">napi_typedarray_type {</span>
  <span class="s1">napi_int8_array,</span>
  <span class="s1">napi_uint8_array,</span>
  <span class="s1">napi_uint8_clamped_array,</span>
  <span class="s1">napi_int16_array,</span>
  <span class="s1">napi_uint16_array,</span>
  <span class="s1">napi_int32_array,</span>
  <span class="s1">napi_uint32_array,</span>
  <span class="s1">napi_float32_array,</span>
  <span class="s1">napi_float64_array,</span>
  <span class="s1">napi_bigint64_array,</span>
  <span class="s1">napi_biguint64_array</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const enum </span><span class="s1">napi_key_collection_mode {</span>
  <span class="s1">napi_key_include_prototypes,</span>
  <span class="s1">napi_key_own_only</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const enum </span><span class="s1">napi_key_filter {</span>
  <span class="s1">napi_key_all_properties = </span><span class="s4">0</span><span class="s1">,</span>
  <span class="s1">napi_key_writable = </span><span class="s4">1</span><span class="s1">,</span>
  <span class="s1">napi_key_enumerable = </span><span class="s4">1 </span><span class="s1">&lt;&lt; </span><span class="s4">1</span><span class="s1">,</span>
  <span class="s1">napi_key_configurable = </span><span class="s4">1 </span><span class="s1">&lt;&lt; </span><span class="s4">2</span><span class="s1">,</span>
  <span class="s1">napi_key_skip_strings = </span><span class="s4">1 </span><span class="s1">&lt;&lt; </span><span class="s4">3</span><span class="s1">,</span>
  <span class="s1">napi_key_skip_symbols = </span><span class="s4">1 </span><span class="s1">&lt;&lt; </span><span class="s4">4</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const enum </span><span class="s1">napi_key_conversion {</span>
  <span class="s1">napi_key_keep_numbers,</span>
  <span class="s1">napi_key_numbers_to_strings</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const enum </span><span class="s1">emnapi_memory_view_type {</span>
  <span class="s1">emnapi_int8_array,</span>
  <span class="s1">emnapi_uint8_array,</span>
  <span class="s1">emnapi_uint8_clamped_array,</span>
  <span class="s1">emnapi_int16_array,</span>
  <span class="s1">emnapi_uint16_array,</span>
  <span class="s1">emnapi_int32_array,</span>
  <span class="s1">emnapi_uint32_array,</span>
  <span class="s1">emnapi_float32_array,</span>
  <span class="s1">emnapi_float64_array,</span>
  <span class="s1">emnapi_bigint64_array,</span>
  <span class="s1">emnapi_biguint64_array,</span>
  <span class="s1">emnapi_data_view = -</span><span class="s4">1</span><span class="s1">,</span>
  <span class="s1">emnapi_buffer = -</span><span class="s4">2</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const enum </span><span class="s1">napi_threadsafe_function_call_mode {</span>
  <span class="s1">napi_tsfn_nonblocking,</span>
  <span class="s1">napi_tsfn_blocking</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const enum </span><span class="s1">napi_threadsafe_function_release_mode {</span>
  <span class="s1">napi_tsfn_release,</span>
  <span class="s1">napi_tsfn_abort</span>
<span class="s1">}</span>
<span class="s0">export </span><span class="s1">declare type CleanupHookCallbackFunction = number | ((arg: number) =&gt; </span><span class="s0">void</span><span class="s1">);</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">class </span><span class="s1">ConstHandle&lt;S </span><span class="s0">extends </span><span class="s1">undefined | </span><span class="s0">null </span><span class="s1">| boolean | </span><span class="s0">typeof </span><span class="s1">globalThis&gt; </span><span class="s0">extends </span><span class="s1">Handle&lt;S&gt; {</span>
    <span class="s1">constructor(id: number, value: S);</span>
    <span class="s1">dispose(): </span><span class="s0">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">class </span><span class="s1">Context {</span>
    <span class="s0">private </span><span class="s1">_isStopping;</span>
    <span class="s0">private </span><span class="s1">_canCallIntoJs;</span>
    <span class="s0">private </span><span class="s1">_suppressDestroy;</span>
    <span class="s1">envStore: Store&lt;Env&gt;;</span>
    <span class="s1">scopeStore: ScopeStore;</span>
    <span class="s1">refStore: Store&lt;Reference&gt;;</span>
    <span class="s1">deferredStore: Store&lt;Deferred&lt;any&gt;&gt;;</span>
    <span class="s1">handleStore: HandleStore;</span>
    <span class="s0">private </span><span class="s1">readonly refCounter?;</span>
    <span class="s0">private </span><span class="s1">readonly cleanupQueue;</span>
    <span class="s1">feature: {</span>
        <span class="s1">supportReflect: boolean;</span>
        <span class="s1">supportFinalizer: boolean;</span>
        <span class="s1">supportWeakSymbol: boolean;</span>
        <span class="s1">supportBigInt: boolean;</span>
        <span class="s1">supportNewFunction: boolean;</span>
        <span class="s1">canSetFunctionName: boolean;</span>
        <span class="s1">setImmediate: (callback: () =&gt; </span><span class="s0">void</span><span class="s1">) =&gt; </span><span class="s0">void</span><span class="s1">;</span>
        <span class="s1">Buffer: BufferCtor | undefined;</span>
        <span class="s1">MessageChannel: {</span>
            <span class="s0">new </span><span class="s1">(): MessageChannel;</span>
            <span class="s1">prototype: MessageChannel;</span>
        <span class="s1">} | undefined;</span>
    <span class="s1">};</span>
    <span class="s1">constructor();</span>
    <span class="s2">/**</span>
     <span class="s2">* Suppress the destroy on `beforeExit` event in Node.js.</span>
     <span class="s2">* Call this method if you want to keep the context and</span>
     <span class="s2">* all associated {</span><span class="s3">@link </span><span class="s2">Env | Env} alive,</span>
     <span class="s2">* this also means that cleanup hooks will not be called.</span>
     <span class="s2">* After call this method, you should call</span>
     <span class="s2">* {</span><span class="s3">@link </span><span class="s2">Context.destroy | `Context.prototype.destroy`} method manually.</span>
     <span class="s2">*/</span>
    <span class="s1">suppressDestroy(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">getRuntimeVersions(): {</span>
        <span class="s1">version: string;</span>
        <span class="s1">NODE_API_SUPPORTED_VERSION_MAX: Version;</span>
        <span class="s1">NAPI_VERSION_EXPERIMENTAL: Version;</span>
        <span class="s1">NODE_API_DEFAULT_MODULE_API_VERSION: Version;</span>
    <span class="s1">};</span>
    <span class="s1">createNotSupportWeakRefError(api: string, message: string): NotSupportWeakRefError;</span>
    <span class="s1">createNotSupportBufferError(api: string, message: string): NotSupportBufferError;</span>
    <span class="s1">createReference(envObject: Env, handle_id: napi_value, initialRefcount: uint32_t, ownership: ReferenceOwnership): Reference;</span>
    <span class="s1">createReferenceWithData(envObject: Env, handle_id: napi_value, initialRefcount: uint32_t, ownership: ReferenceOwnership, data: void_p): Reference;</span>
    <span class="s1">createReferenceWithFinalizer(envObject: Env, handle_id: napi_value, initialRefcount: uint32_t, ownership: ReferenceOwnership, finalize_callback?: napi_finalize, finalize_data?: void_p, finalize_hint?: void_p): Reference;</span>
    <span class="s1">createDeferred&lt;T = any&gt;(value: IDeferrdValue&lt;T&gt;): Deferred&lt;T&gt;;</span>
    <span class="s1">createEnv(filename: string, moduleApiVersion: number, makeDynCall_vppp: (cb: Ptr) =&gt; (a: Ptr, b: Ptr, c: Ptr) =&gt; </span><span class="s0">void</span><span class="s1">, makeDynCall_vp: (cb: Ptr) =&gt; (a: Ptr) =&gt; </span><span class="s0">void</span><span class="s1">, abort: (msg?: string) =&gt; never, nodeBinding?: any): Env;</span>
    <span class="s1">createTrackedFinalizer(envObject: Env, finalize_callback: napi_finalize, finalize_data: void_p, finalize_hint: void_p): TrackedFinalizer;</span>
    <span class="s1">getCurrentScope(): HandleScope | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">addToCurrentScope&lt;V&gt;(value: V): Handle&lt;V&gt;;</span>
    <span class="s1">openScope(envObject?: Env): HandleScope;</span>
    <span class="s1">closeScope(envObject?: Env, _scope?: HandleScope): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">ensureHandle&lt;S&gt;(value: S): Handle&lt;S&gt;;</span>
    <span class="s1">addCleanupHook(envObject: Env, fn: CleanupHookCallbackFunction, arg: number): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">removeCleanupHook(envObject: Env, fn: CleanupHookCallbackFunction, arg: number): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">runCleanup(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">increaseWaitingRequestCounter(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">decreaseWaitingRequestCounter(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">setCanCallIntoJs(value: boolean): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">setStopping(value: boolean): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">canCallIntoJs(): boolean;</span>
    <span class="s2">/**</span>
     <span class="s2">* Destroy the context and call cleanup hooks.</span>
     <span class="s2">* Associated {</span><span class="s3">@link </span><span class="s2">Env | Env} will be destroyed.</span>
     <span class="s2">*/</span>
    <span class="s1">destroy(): </span><span class="s0">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">createContext(): Context;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">class </span><span class="s1">Deferred&lt;T = any&gt; </span><span class="s0">implements </span><span class="s1">IStoreValue {</span>
    <span class="s0">static </span><span class="s1">create&lt;T = any&gt;(ctx: Context, value: IDeferrdValue&lt;T&gt;): Deferred;</span>
    <span class="s1">id: number;</span>
    <span class="s1">ctx: Context;</span>
    <span class="s1">value: IDeferrdValue&lt;T&gt;;</span>
    <span class="s1">constructor(ctx: Context, value: IDeferrdValue&lt;T&gt;);</span>
    <span class="s1">resolve(value: T): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">reject(reason?: any): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">dispose(): </span><span class="s0">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">class </span><span class="s1">EmnapiError </span><span class="s0">extends </span><span class="s1">Error {</span>
    <span class="s1">constructor(message?: string);</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare abstract </span><span class="s0">class </span><span class="s1">Env </span><span class="s0">implements </span><span class="s1">IStoreValue {</span>
    <span class="s1">readonly ctx: Context;</span>
    <span class="s1">moduleApiVersion: number;</span>
    <span class="s1">makeDynCall_vppp: (cb: Ptr) =&gt; (a: Ptr, b: Ptr, c: Ptr) =&gt; </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">makeDynCall_vp: (cb: Ptr) =&gt; (a: Ptr) =&gt; </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">abort: (msg?: string) =&gt; never;</span>
    <span class="s1">id: number;</span>
    <span class="s1">openHandleScopes: number;</span>
    <span class="s1">instanceData: TrackedFinalizer | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">tryCatch: TryCatch;</span>
    <span class="s1">refs: number;</span>
    <span class="s1">reflist: RefTracker;</span>
    <span class="s1">finalizing_reflist: RefTracker;</span>
    <span class="s1">pendingFinalizers: RefTracker[];</span>
    <span class="s1">lastError: {</span>
        <span class="s1">errorCode: napi_status;</span>
        <span class="s1">engineErrorCode: number;</span>
        <span class="s1">engineReserved: Ptr;</span>
    <span class="s1">};</span>
    <span class="s1">inGcFinalizer: boolean;</span>
    <span class="s1">constructor(ctx: Context, moduleApiVersion: number, makeDynCall_vppp: (cb: Ptr) =&gt; (a: Ptr, b: Ptr, c: Ptr) =&gt; </span><span class="s0">void</span><span class="s1">, makeDynCall_vp: (cb: Ptr) =&gt; (a: Ptr) =&gt; </span><span class="s0">void</span><span class="s1">, abort: (msg?: string) =&gt; never);</span>
    <span class="s2">/** </span><span class="s3">@virtual </span><span class="s2">*/</span>
    <span class="s1">canCallIntoJs(): boolean;</span>
    <span class="s1">terminatedOrTerminating(): boolean;</span>
    <span class="s1">ref(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">unref(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">ensureHandle&lt;S&gt;(value: S): Handle&lt;S&gt;;</span>
    <span class="s1">ensureHandleId(value: any): napi_value;</span>
    <span class="s1">clearLastError(): napi_status;</span>
    <span class="s1">setLastError(error_code: napi_status, engine_error_code?: uint32_t, engine_reserved?: void_p): napi_status;</span>
    <span class="s1">getReturnStatus(): napi_status;</span>
    <span class="s1">callIntoModule&lt;T&gt;(fn: (env: Env) =&gt; T, handleException?: (envObject: Env, value: any) =&gt; </span><span class="s0">void</span><span class="s1">): T;</span>
    <span class="s2">/** </span><span class="s3">@virtual </span><span class="s2">*/</span>
    <span class="s1">abstract callFinalizer(cb: napi_finalize, data: void_p, hint: void_p): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">invokeFinalizerFromGC(finalizer: RefTracker): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">checkGCAccess(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s2">/** </span><span class="s3">@virtual </span><span class="s2">*/</span>
    <span class="s1">enqueueFinalizer(finalizer: RefTracker): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s2">/** </span><span class="s3">@virtual </span><span class="s2">*/</span>
    <span class="s1">dequeueFinalizer(finalizer: RefTracker): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s2">/** </span><span class="s3">@virtual </span><span class="s2">*/</span>
    <span class="s1">deleteMe(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">dispose(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s0">private </span><span class="s1">readonly _bindingMap;</span>
    <span class="s1">initObjectBinding&lt;S </span><span class="s0">extends </span><span class="s1">object&gt;(value: S): IReferenceBinding;</span>
    <span class="s1">getObjectBinding&lt;S </span><span class="s0">extends </span><span class="s1">object&gt;(value: S): IReferenceBinding;</span>
    <span class="s1">setInstanceData(data: number, finalize_cb: number, finalize_hint: number): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">getInstanceData(): number;</span>
<span class="s1">}</span>

<span class="s2">/** </span><span class="s3">@public </span><span class="s2">*/</span>
<span class="s1">declare </span><span class="s0">interface </span><span class="s1">External_2 </span><span class="s0">extends </span><span class="s1">Record&lt;any, any&gt; {</span>
<span class="s1">}</span>

<span class="s2">/** </span><span class="s3">@public </span><span class="s2">*/</span>
<span class="s1">declare </span><span class="s0">const </span><span class="s1">External_2: {</span>
    <span class="s0">new </span><span class="s1">(value: number | bigint): External_2;</span>
    <span class="s1">prototype: </span><span class="s0">null</span><span class="s1">;</span>
<span class="s1">};</span>
<span class="s0">export </span><span class="s1">{ External_2 as External }</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">class </span><span class="s1">Finalizer {</span>
    <span class="s1">envObject: Env;</span>
    <span class="s0">private </span><span class="s1">_finalizeCallback;</span>
    <span class="s0">private </span><span class="s1">_finalizeData;</span>
    <span class="s0">private </span><span class="s1">_finalizeHint;</span>
    <span class="s0">private </span><span class="s1">_makeDynCall_vppp;</span>
    <span class="s1">constructor(envObject: Env, _finalizeCallback?: napi_finalize, _finalizeData?: void_p, _finalizeHint?: void_p);</span>
    <span class="s1">callback(): napi_finalize;</span>
    <span class="s1">data(): void_p;</span>
    <span class="s1">hint(): void_p;</span>
    <span class="s1">resetEnv(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">resetFinalizer(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">callFinalizer(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">dispose(): </span><span class="s0">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getDefaultContext(): Context;</span>

<span class="s2">/** </span><span class="s3">@public </span><span class="s2">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getExternalValue(external: External_2): number | bigint;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">class </span><span class="s1">Handle&lt;S&gt; {</span>
    <span class="s1">id: number;</span>
    <span class="s1">value: S;</span>
    <span class="s1">constructor(id: number, value: S);</span>
    <span class="s1">data(): void_p;</span>
    <span class="s1">isNumber(): boolean;</span>
    <span class="s1">isBigInt(): boolean;</span>
    <span class="s1">isString(): boolean;</span>
    <span class="s1">isFunction(): boolean;</span>
    <span class="s1">isExternal(): boolean;</span>
    <span class="s1">isObject(): boolean;</span>
    <span class="s1">isArray(): boolean;</span>
    <span class="s1">isArrayBuffer(): boolean;</span>
    <span class="s1">isTypedArray(): boolean;</span>
    <span class="s1">isBuffer(BufferConstructor?: BufferCtor): boolean;</span>
    <span class="s1">isDataView(): boolean;</span>
    <span class="s1">isDate(): boolean;</span>
    <span class="s1">isPromise(): boolean;</span>
    <span class="s1">isBoolean(): boolean;</span>
    <span class="s1">isUndefined(): boolean;</span>
    <span class="s1">isSymbol(): boolean;</span>
    <span class="s1">isNull(): boolean;</span>
    <span class="s1">dispose(): </span><span class="s0">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">class </span><span class="s1">HandleScope {</span>
    <span class="s1">handleStore: HandleStore;</span>
    <span class="s1">id: number;</span>
    <span class="s1">parent: HandleScope | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">child: HandleScope | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">start: number;</span>
    <span class="s1">end: number;</span>
    <span class="s0">private </span><span class="s1">_escapeCalled;</span>
    <span class="s1">callbackInfo: ICallbackInfo;</span>
    <span class="s1">constructor(handleStore: HandleStore, id: number, parentScope: HandleScope | </span><span class="s0">null</span><span class="s1">, start: number, end?: number);</span>
    <span class="s1">add&lt;V&gt;(value: V): Handle&lt;V&gt;;</span>
    <span class="s1">addExternal(data: void_p): Handle&lt;object&gt;;</span>
    <span class="s1">dispose(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">escape(handle: number): Handle&lt;any&gt; | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">escapeCalled(): boolean;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">class </span><span class="s1">HandleStore {</span>
    <span class="s0">static </span><span class="s1">UNDEFINED: ConstHandle&lt;undefined&gt;;</span>
    <span class="s0">static </span><span class="s1">NULL: ConstHandle&lt;</span><span class="s0">null</span><span class="s1">&gt;;</span>
    <span class="s0">static </span><span class="s1">FALSE: ConstHandle&lt;</span><span class="s0">false</span><span class="s1">&gt;;</span>
    <span class="s0">static </span><span class="s1">TRUE: ConstHandle&lt;</span><span class="s0">true</span><span class="s1">&gt;;</span>
    <span class="s0">static </span><span class="s1">GLOBAL: ConstHandle&lt;</span><span class="s0">typeof </span><span class="s1">globalThis&gt;;</span>
    <span class="s0">static </span><span class="s1">MIN_ID: </span><span class="s4">6</span><span class="s1">;</span>
    <span class="s0">private </span><span class="s1">readonly _values;</span>
    <span class="s0">private </span><span class="s1">_next;</span>
    <span class="s1">push&lt;S&gt;(value: S): Handle&lt;S&gt;;</span>
    <span class="s1">erase(start: number, end: number): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">get(id: Ptr): Handle&lt;any&gt; | undefined;</span>
    <span class="s1">swap(a: number, b: number): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">dispose(): </span><span class="s0">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">ICallbackInfo {</span>
    <span class="s1">thiz: any;</span>
    <span class="s1">data: void_p;</span>
    <span class="s1">args: ArrayLike&lt;any&gt;;</span>
    <span class="s1">fn: Function;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">IDeferrdValue&lt;T = any&gt; {</span>
    <span class="s1">resolve: (value: T) =&gt; </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">reject: (reason?: any) =&gt; </span><span class="s0">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">IReferenceBinding {</span>
    <span class="s1">wrapped: number;</span>
    <span class="s1">tag: Uint32Array | </span><span class="s0">null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">/** </span><span class="s3">@public </span><span class="s2">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">isExternal(object: unknown): object is External_2;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">isReferenceType(v: any): v is object;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">IStoreValue {</span>
    <span class="s1">id: number;</span>
    <span class="s1">dispose(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">[x: string]: any;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">NAPI_VERSION_EXPERIMENTAL = Version.NAPI_VERSION_EXPERIMENTAL;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">NODE_API_DEFAULT_MODULE_API_VERSION = Version.NODE_API_DEFAULT_MODULE_API_VERSION;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">NODE_API_SUPPORTED_VERSION_MAX = Version.NODE_API_SUPPORTED_VERSION_MAX;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">NODE_API_SUPPORTED_VERSION_MIN = Version.NODE_API_SUPPORTED_VERSION_MIN;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">class </span><span class="s1">NodeEnv </span><span class="s0">extends </span><span class="s1">Env {</span>
    <span class="s1">filename: string;</span>
    <span class="s0">private </span><span class="s1">readonly nodeBinding?;</span>
    <span class="s1">destructing: boolean;</span>
    <span class="s1">finalizationScheduled: boolean;</span>
    <span class="s1">constructor(ctx: Context, filename: string, moduleApiVersion: number, makeDynCall_vppp: (cb: Ptr) =&gt; (a: Ptr, b: Ptr, c: Ptr) =&gt; </span><span class="s0">void</span><span class="s1">, makeDynCall_vp: (cb: Ptr) =&gt; (a: Ptr) =&gt; </span><span class="s0">void</span><span class="s1">, abort: (msg?: string) =&gt; never, nodeBinding?: any);</span>
    <span class="s1">deleteMe(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">canCallIntoJs(): boolean;</span>
    <span class="s1">triggerFatalException(err: any): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">callbackIntoModule&lt;T&gt;(enforceUncaughtExceptionPolicy: boolean, fn: (env: Env) =&gt; T): T;</span>
    <span class="s1">callFinalizer(cb: napi_finalize, data: void_p, hint: void_p): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">callFinalizerInternal(forceUncaught: int, cb: napi_finalize, data: void_p, hint: void_p): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">enqueueFinalizer(finalizer: RefTracker): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">drainFinalizerQueue(): </span><span class="s0">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">class </span><span class="s1">NotSupportBufferError </span><span class="s0">extends </span><span class="s1">EmnapiError {</span>
    <span class="s1">constructor(api: string, message: string);</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">class </span><span class="s1">NotSupportWeakRefError </span><span class="s0">extends </span><span class="s1">EmnapiError {</span>
    <span class="s1">constructor(api: string, message: string);</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">class </span><span class="s1">Persistent&lt;T&gt; {</span>
    <span class="s0">private </span><span class="s1">_ref;</span>
    <span class="s0">private </span><span class="s1">_param;</span>
    <span class="s0">private </span><span class="s1">_callback;</span>
    <span class="s0">private static </span><span class="s1">readonly _registry;</span>
    <span class="s1">constructor(value: T);</span>
    <span class="s1">setWeak&lt;P&gt;(param: P, callback: (param: P) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">clearWeak(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">reset(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">isEmpty(): boolean;</span>
    <span class="s1">deref(): T | undefined;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">class </span><span class="s1">Reference </span><span class="s0">extends </span><span class="s1">RefTracker </span><span class="s0">implements </span><span class="s1">IStoreValue {</span>
    <span class="s0">private static </span><span class="s1">weakCallback;</span>
    <span class="s1">id: number;</span>
    <span class="s1">envObject: Env;</span>
    <span class="s0">private </span><span class="s1">readonly canBeWeak;</span>
    <span class="s0">private </span><span class="s1">_refcount;</span>
    <span class="s0">private </span><span class="s1">readonly _ownership;</span>
    <span class="s1">persistent: Persistent&lt;object&gt;;</span>
    <span class="s0">static </span><span class="s1">create(envObject: Env, handle_id: napi_value, initialRefcount: uint32_t, ownership: ReferenceOwnership, _unused1?: void_p, _unused2?: void_p, _unused3?: void_p): Reference;</span>
    <span class="s0">protected </span><span class="s1">constructor(envObject: Env, handle_id: napi_value, initialRefcount: uint32_t, ownership: ReferenceOwnership);</span>
    <span class="s1">ref(): number;</span>
    <span class="s1">unref(): number;</span>
    <span class="s1">get(envObject?: Env): napi_value;</span>
    <span class="s2">/** </span><span class="s3">@virtual </span><span class="s2">*/</span>
    <span class="s1">resetFinalizer(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s2">/** </span><span class="s3">@virtual </span><span class="s2">*/</span>
    <span class="s1">data(): void_p;</span>
    <span class="s1">refcount(): number;</span>
    <span class="s1">ownership(): ReferenceOwnership;</span>
    <span class="s2">/** </span><span class="s3">@virtual </span><span class="s2">*/</span>
    <span class="s0">protected </span><span class="s1">callUserFinalizer(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s2">/** </span><span class="s3">@virtual </span><span class="s2">*/</span>
    <span class="s0">protected </span><span class="s1">invokeFinalizerFromGC(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s0">private </span><span class="s1">_setWeak;</span>
    <span class="s1">finalize(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">dispose(): </span><span class="s0">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">enum </span><span class="s1">ReferenceOwnership {</span>
    <span class="s1">kRuntime = </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s1">kUserland = </span><span class="s4">1</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">class </span><span class="s1">ReferenceWithData </span><span class="s0">extends </span><span class="s1">Reference {</span>
    <span class="s0">private </span><span class="s1">readonly _data;</span>
    <span class="s0">static </span><span class="s1">create(envObject: Env, value: napi_value, initialRefcount: uint32_t, ownership: ReferenceOwnership, data: void_p): ReferenceWithData;</span>
    <span class="s0">private </span><span class="s1">constructor();</span>
    <span class="s1">data(): void_p;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">class </span><span class="s1">ReferenceWithFinalizer </span><span class="s0">extends </span><span class="s1">Reference {</span>
    <span class="s0">private </span><span class="s1">_finalizer;</span>
    <span class="s0">static </span><span class="s1">create(envObject: Env, value: napi_value, initialRefcount: uint32_t, ownership: ReferenceOwnership, finalize_callback: napi_finalize, finalize_data: void_p, finalize_hint: void_p): ReferenceWithFinalizer;</span>
    <span class="s0">private </span><span class="s1">constructor();</span>
    <span class="s1">resetFinalizer(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">data(): void_p;</span>
    <span class="s0">protected </span><span class="s1">callUserFinalizer(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s0">protected </span><span class="s1">invokeFinalizerFromGC(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">dispose(): </span><span class="s0">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">class </span><span class="s1">RefTracker {</span>
    <span class="s2">/** </span><span class="s3">@virtual </span><span class="s2">*/</span>
    <span class="s1">dispose(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s2">/** </span><span class="s3">@virtual </span><span class="s2">*/</span>
    <span class="s1">finalize(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s0">private </span><span class="s1">_next;</span>
    <span class="s0">private </span><span class="s1">_prev;</span>
    <span class="s1">link(list: RefTracker): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">unlink(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s0">static </span><span class="s1">finalizeAll(list: RefTracker): </span><span class="s0">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">class </span><span class="s1">ScopeStore {</span>
    <span class="s0">private </span><span class="s1">readonly _rootScope;</span>
    <span class="s1">currentScope: HandleScope;</span>
    <span class="s0">private </span><span class="s1">readonly _values;</span>
    <span class="s1">constructor();</span>
    <span class="s1">get(id: number): HandleScope | undefined;</span>
    <span class="s1">openScope(handleStore: HandleStore): HandleScope;</span>
    <span class="s1">closeScope(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">dispose(): </span><span class="s0">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">class </span><span class="s1">Store&lt;V </span><span class="s0">extends </span><span class="s1">IStoreValue&gt; {</span>
    <span class="s0">protected </span><span class="s1">_values: Array&lt;V | undefined&gt;;</span>
    <span class="s0">private </span><span class="s1">_freeList;</span>
    <span class="s0">private </span><span class="s1">_size;</span>
    <span class="s1">constructor();</span>
    <span class="s1">add(value: V): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">get(id: Ptr): V | undefined;</span>
    <span class="s1">has(id: Ptr): boolean;</span>
    <span class="s1">remove(id: Ptr): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">dispose(): </span><span class="s0">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">class </span><span class="s1">TrackedFinalizer </span><span class="s0">extends </span><span class="s1">RefTracker {</span>
    <span class="s0">private </span><span class="s1">_finalizer;</span>
    <span class="s0">static </span><span class="s1">create(envObject: Env, finalize_callback: napi_finalize, finalize_data: void_p, finalize_hint: void_p): TrackedFinalizer;</span>
    <span class="s0">private </span><span class="s1">constructor();</span>
    <span class="s1">data(): void_p;</span>
    <span class="s1">dispose(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">finalize(): </span><span class="s0">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">class </span><span class="s1">TryCatch {</span>
    <span class="s0">private </span><span class="s1">_exception;</span>
    <span class="s0">private </span><span class="s1">_caught;</span>
    <span class="s1">isEmpty(): boolean;</span>
    <span class="s1">hasCaught(): boolean;</span>
    <span class="s1">exception(): any;</span>
    <span class="s1">setError(err: any): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">reset(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">extractException(): any;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">version: string;</span>

<span class="s0">export </span><span class="s1">{ }</span>
</pre>
</body>
</html>