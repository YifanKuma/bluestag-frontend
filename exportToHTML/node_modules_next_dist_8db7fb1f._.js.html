<html>
<head>
<title>node_modules_next_dist_8db7fb1f._.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #0033b3;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #264eff;}
.s6 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
node_modules_next_dist_8db7fb1f._.js</font>
</center></td></tr></table>
<pre><span class="s0">(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([</span><span class="s1">typeof </span><span class="s0">document === </span><span class="s2">&quot;object&quot; </span><span class="s0">? document.currentScript : undefined,</span>
<span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/router/utils/disable-smooth-scroll.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;disableSmoothScrollDuringRouteTransition&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">disableSmoothScrollDuringRouteTransition;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_warnonce = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">disableSmoothScrollDuringRouteTransition(fn, options) {</span>
    <span class="s1">if </span><span class="s0">(options === </span><span class="s1">void </span><span class="s4">0</span><span class="s0">) options = {};</span>
    <span class="s3">// if only the hash is changed, we don't need to disable smooth scrolling</span>
    <span class="s3">// we only care to prevent smooth scrolling when navigating to a new page to avoid jarring UX</span>
    <span class="s1">if </span><span class="s0">(options.onlyHashChange) {</span>
        <span class="s0">fn();</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">htmlElement = document.documentElement;</span>
    <span class="s1">const </span><span class="s0">hasDataAttribute = htmlElement.dataset.scrollBehavior === </span><span class="s2">'smooth'</span><span class="s0">;</span>
    <span class="s3">// Since this is a breaking change, this is temporarily flagged</span>
    <span class="s3">// and will be false by default.</span>
    <span class="s3">// In the next major (v16), this will be automatically enabled</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
    <span class="s1">else </span><span class="s0">{</span>
        <span class="s3">// Old behavior: always manipulate styles, but warn about upcoming change</span>
        <span class="s3">// Warn if smooth scrolling is detected but no data attribute is present</span>
        <span class="s1">if </span><span class="s0">((</span><span class="s2">&quot;TURBOPACK compile-time value&quot;</span><span class="s0">, </span><span class="s2">&quot;development&quot;</span><span class="s0">) === </span><span class="s2">'development' </span><span class="s0">&amp;&amp; !hasDataAttribute &amp;&amp; getComputedStyle(htmlElement).scrollBehavior === </span><span class="s2">'smooth'</span><span class="s0">) {</span>
            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _warnonce.warnOnce)(</span><span class="s2">'Detected `scroll-behavior: smooth` on the `&lt;html&gt;` element. In a future version, ' </span><span class="s0">+ </span><span class="s2">'Next.js will no longer automatically disable smooth scrolling during route transitions. ' </span><span class="s0">+ </span><span class="s2">'To prepare for this change, add `data-scroll-behavior=&quot;smooth&quot;` to your &lt;html&gt; element. ' </span><span class="s0">+ </span><span class="s2">'Learn more: https://nextjs.org/docs/messages/missing-data-scroll-behavior'</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s3">// Proceed with temporarily disabling smooth scrolling</span>
    <span class="s1">const </span><span class="s0">existing = htmlElement.style.scrollBehavior;</span>
    <span class="s0">htmlElement.style.scrollBehavior = </span><span class="s2">'auto'</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(!options.dontForceLayout) {</span>
        <span class="s3">// In Chrome-based browsers we need to force reflow before calling `scrollTo`.</span>
        <span class="s3">// Otherwise it will not pickup the change in scrollBehavior</span>
        <span class="s3">// More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042</span>
        <span class="s0">htmlElement.getClientRects();</span>
    <span class="s0">}</span>
    <span class="s0">fn();</span>
    <span class="s0">htmlElement.style.scrollBehavior = existing;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=disable-smooth-scroll.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/bfcache.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;useRouterBFCache&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">useRouterBFCache;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_react = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s3">// When the flag is disabled, only track the currently active tree</span>
<span class="s1">const </span><span class="s0">MAX_BF_CACHE_ENTRIES = (</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) ? </span><span class="s2">&quot;TURBOPACK unreachable&quot; </span><span class="s0">: </span><span class="s4">1</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">useRouterBFCache(activeTree, activeStateKey) {</span>
    <span class="s3">// The currently active entry. The entries form a linked list, sorted in</span>
    <span class="s3">// order of most recently active. This allows us to reuse parts of the list</span>
    <span class="s3">// without cloning, unless there's a reordering or removal.</span>
    <span class="s3">// TODO: Once we start tracking back/forward history at each route level,</span>
    <span class="s3">// we should use the history order instead. In other words, when traversing</span>
    <span class="s3">// to an existing entry as a result of a popstate event, we should maintain</span>
    <span class="s3">// the existing order instead of moving it to the front of the list. I think</span>
    <span class="s3">// an initial implementation of this could be to pass an incrementing id</span>
    <span class="s3">// to history.pushState/replaceState, then use that here for ordering.</span>
    <span class="s1">const </span><span class="s0">[prevActiveEntry, setPrevActiveEntry] = (</span><span class="s4">0</span><span class="s0">, _react.useState)(()=&gt;{</span>
        <span class="s1">const </span><span class="s0">initialEntry = {</span>
            <span class="s0">tree: activeTree,</span>
            <span class="s0">stateKey: activeStateKey,</span>
            <span class="s0">next: </span><span class="s1">null</span>
        <span class="s0">};</span>
        <span class="s1">return </span><span class="s0">initialEntry;</span>
    <span class="s0">});</span>
    <span class="s1">if </span><span class="s0">(prevActiveEntry.tree === activeTree) {</span>
        <span class="s3">// Fast path. The active tree hasn't changed, so we can reuse the</span>
        <span class="s3">// existing state.</span>
        <span class="s1">return </span><span class="s0">prevActiveEntry;</span>
    <span class="s0">}</span>
    <span class="s3">// The route tree changed. Note that this doesn't mean that the tree changed</span>
    <span class="s3">// *at this level* â€” the change may be due to a child route. Either way, we</span>
    <span class="s3">// need to either add or update the router tree in the bfcache.</span>
    <span class="s3">//</span>
    <span class="s3">// The rest of the code looks more complicated than it actually is because we</span>
    <span class="s3">// can't mutate the state in place; we have to copy-on-write.</span>
    <span class="s3">// Create a new entry for the active cache key. This is the head of the new</span>
    <span class="s3">// linked list.</span>
    <span class="s1">const </span><span class="s0">newActiveEntry = {</span>
        <span class="s0">tree: activeTree,</span>
        <span class="s0">stateKey: activeStateKey,</span>
        <span class="s0">next: </span><span class="s1">null</span>
    <span class="s0">};</span>
    <span class="s3">// We need to append the old list onto the new list. If the head of the new</span>
    <span class="s3">// list was already present in the cache, then we'll need to clone everything</span>
    <span class="s3">// that came before it. Then we can reuse the rest.</span>
    <span class="s1">let </span><span class="s0">n = </span><span class="s4">1</span><span class="s0">;</span>
    <span class="s1">let </span><span class="s0">oldEntry = prevActiveEntry;</span>
    <span class="s1">let </span><span class="s0">clonedEntry = newActiveEntry;</span>
    <span class="s1">while</span><span class="s0">(oldEntry !== </span><span class="s1">null </span><span class="s0">&amp;&amp; n &lt; MAX_BF_CACHE_ENTRIES){</span>
        <span class="s1">if </span><span class="s0">(oldEntry.stateKey === activeStateKey) {</span>
            <span class="s3">// Fast path. This entry in the old list that corresponds to the key that</span>
            <span class="s3">// is now active. We've already placed a clone of this entry at the front</span>
            <span class="s3">// of the new list. We can reuse the rest of the old list without cloning.</span>
            <span class="s3">// NOTE: We don't need to worry about eviction in this case because we</span>
            <span class="s3">// haven't increased the size of the cache, and we assume the max size</span>
            <span class="s3">// is constant across renders. If we were to change it to a dynamic limit,</span>
            <span class="s3">// then the implementation would need to account for that.</span>
            <span class="s0">clonedEntry.next = oldEntry.next;</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s3">// Clone the entry and append it to the list.</span>
            <span class="s0">n++;</span>
            <span class="s1">const </span><span class="s0">entry = {</span>
                <span class="s0">tree: oldEntry.tree,</span>
                <span class="s0">stateKey: oldEntry.stateKey,</span>
                <span class="s0">next: </span><span class="s1">null</span>
            <span class="s0">};</span>
            <span class="s0">clonedEntry.next = entry;</span>
            <span class="s0">clonedEntry = entry;</span>
        <span class="s0">}</span>
        <span class="s0">oldEntry = oldEntry.next;</span>
    <span class="s0">}</span>
    <span class="s0">setPrevActiveEntry(newActiveEntry);</span>
    <span class="s1">return </span><span class="s0">newActiveEntry;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=bfcache.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/layout-router.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">'use client'</span><span class="s0">;</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s3">/**</span>
 <span class="s3">* OuterLayoutRouter handles the current segment as well as &lt;Offscreen&gt; rendering of other segments.</span>
 <span class="s3">* It can be rendered next to each other with a different `parallelRouterKey`, allowing for Parallel routes.</span>
 <span class="s3">*/ </span><span class="s2">&quot;default&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">OuterLayoutRouter;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_interop_require_default = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_interop_require_wildcard = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_jsxruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_routerreducertypes = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_react = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_interop_require_wildcard._(__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)&quot;</span><span class="s0">));</span>
<span class="s1">const </span><span class="s0">_reactdom = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_interop_require_default._(__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)&quot;</span><span class="s0">));</span>
<span class="s1">const </span><span class="s0">_approutercontextsharedruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_fetchserverresponse = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_unresolvedthenable = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/unresolved-thenable.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_errorboundary = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/error-boundary.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_matchsegments = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/match-segments.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_disablesmoothscroll = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/router/utils/disable-smooth-scroll.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_redirectboundary = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/redirect-boundary.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_errorboundary1 = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/http-access-fallback/error-boundary.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_createroutercachekey = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_hasinterceptionrouteincurrenttree = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_useactionqueue = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/use-action-queue.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_bfcache = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/bfcache.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_apppaths = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/router/utils/app-paths.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">Activity = (</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) ? </span><span class="s2">&quot;TURBOPACK unreachable&quot; </span><span class="s0">: </span><span class="s1">null</span><span class="s0">;</span>
<span class="s3">/**</span>
 <span class="s3">* Add refetch marker to router state at the point of the current layout segment.</span>
 <span class="s3">* This ensures the response returned is not further down than the current layout segment.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">walkAddRefetch(segmentPathToWalk, treeToRecreate) {</span>
    <span class="s1">if </span><span class="s0">(segmentPathToWalk) {</span>
        <span class="s1">const </span><span class="s0">[segment, parallelRouteKey] = segmentPathToWalk;</span>
        <span class="s1">const </span><span class="s0">isLast = segmentPathToWalk.length === </span><span class="s4">2</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">((</span><span class="s4">0</span><span class="s0">, _matchsegments.matchSegment)(treeToRecreate[</span><span class="s4">0</span><span class="s0">], segment)) {</span>
            <span class="s1">if </span><span class="s0">(treeToRecreate[</span><span class="s4">1</span><span class="s0">].hasOwnProperty(parallelRouteKey)) {</span>
                <span class="s1">if </span><span class="s0">(isLast) {</span>
                    <span class="s1">const </span><span class="s0">subTree = walkAddRefetch(undefined, treeToRecreate[</span><span class="s4">1</span><span class="s0">][parallelRouteKey]);</span>
                    <span class="s1">return </span><span class="s0">[</span>
                        <span class="s0">treeToRecreate[</span><span class="s4">0</span><span class="s0">],</span>
                        <span class="s0">{</span>
                            <span class="s0">...treeToRecreate[</span><span class="s4">1</span><span class="s0">],</span>
                            <span class="s0">[parallelRouteKey]: [</span>
                                <span class="s0">subTree[</span><span class="s4">0</span><span class="s0">],</span>
                                <span class="s0">subTree[</span><span class="s4">1</span><span class="s0">],</span>
                                <span class="s0">subTree[</span><span class="s4">2</span><span class="s0">],</span>
                                <span class="s2">'refetch'</span>
                            <span class="s0">]</span>
                        <span class="s0">}</span>
                    <span class="s0">];</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">[</span>
                    <span class="s0">treeToRecreate[</span><span class="s4">0</span><span class="s0">],</span>
                    <span class="s0">{</span>
                        <span class="s0">...treeToRecreate[</span><span class="s4">1</span><span class="s0">],</span>
                        <span class="s0">[parallelRouteKey]: walkAddRefetch(segmentPathToWalk.slice(</span><span class="s4">2</span><span class="s0">), treeToRecreate[</span><span class="s4">1</span><span class="s0">][parallelRouteKey])</span>
                    <span class="s0">}</span>
                <span class="s0">];</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">treeToRecreate;</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = _reactdom.default.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;</span>
<span class="s3">// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available</span>
<span class="s3">/**</span>
 <span class="s3">* Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">findDOMNode(instance) {</span>
    <span class="s3">// Tree-shake for server bundle</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">window === </span><span class="s2">'undefined'</span><span class="s0">) </span><span class="s1">return null</span><span class="s0">;</span>
    <span class="s3">// __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode is null during module init.</span>
    <span class="s3">// We need to lazily reference it.</span>
    <span class="s1">const </span><span class="s0">internal_reactDOMfindDOMNode = __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode;</span>
    <span class="s1">return </span><span class="s0">internal_reactDOMfindDOMNode(instance);</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">rectProperties = [</span>
    <span class="s2">'bottom'</span><span class="s0">,</span>
    <span class="s2">'height'</span><span class="s0">,</span>
    <span class="s2">'left'</span><span class="s0">,</span>
    <span class="s2">'right'</span><span class="s0">,</span>
    <span class="s2">'top'</span><span class="s0">,</span>
    <span class="s2">'width'</span><span class="s0">,</span>
    <span class="s2">'x'</span><span class="s0">,</span>
    <span class="s2">'y'</span>
<span class="s0">];</span>
<span class="s3">/**</span>
 <span class="s3">* Check if a HTMLElement is hidden or fixed/sticky position</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">shouldSkipElement(element) {</span>
    <span class="s3">// we ignore fixed or sticky positioned elements since they'll likely pass the &quot;in-viewport&quot; check</span>
    <span class="s3">// and will result in a situation we bail on scroll because of something like a fixed nav,</span>
    <span class="s3">// even though the actual page content is offscreen</span>
    <span class="s1">if </span><span class="s0">([</span>
        <span class="s2">'sticky'</span><span class="s0">,</span>
        <span class="s2">'fixed'</span>
    <span class="s0">].includes(getComputedStyle(element).position)) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s0">console.warn(</span><span class="s2">'Skipping auto-scroll behavior due to `position: sticky` or `position: fixed` on element:'</span><span class="s0">, element);</span>
        <span class="s0">}</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">// Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`</span>
    <span class="s3">// because `offsetParent` doesn't consider document/body</span>
    <span class="s1">const </span><span class="s0">rect = element.getBoundingClientRect();</span>
    <span class="s1">return </span><span class="s0">rectProperties.every((item)=&gt;rect[item] === </span><span class="s4">0</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* Check if the top corner of the HTMLElement is in the viewport.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">topOfElementInViewport(element, viewportHeight) {</span>
    <span class="s1">const </span><span class="s0">rect = element.getBoundingClientRect();</span>
    <span class="s1">return </span><span class="s0">rect.top &gt;= </span><span class="s4">0 </span><span class="s0">&amp;&amp; rect.top &lt;= viewportHeight;</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* Find the DOM node for a hash fragment.</span>
 <span class="s3">* If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.</span>
 <span class="s3">* If the hash fragment is an id, the page has to scroll to the element with that id.</span>
 <span class="s3">* If the hash fragment is a name, the page has to scroll to the first element with that name.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">getHashFragmentDomNode(hashFragment) {</span>
    <span class="s3">// If the hash fragment is `top` the page has to scroll to the top of the page.</span>
    <span class="s1">if </span><span class="s0">(hashFragment === </span><span class="s2">'top'</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">document.body;</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">_document_getElementById;</span>
    <span class="s3">// If the hash fragment is an id, the page has to scroll to the element with that id.</span>
    <span class="s1">return </span><span class="s0">(_document_getElementById = document.getElementById(hashFragment)) != </span><span class="s1">null </span><span class="s0">? _document_getElementById : document.getElementsByName(hashFragment)[</span><span class="s4">0</span><span class="s0">];</span>
<span class="s0">}</span>
<span class="s1">class </span><span class="s0">InnerScrollAndFocusHandler </span><span class="s1">extends </span><span class="s0">_react.default.Component {</span>
    <span class="s0">componentDidMount() {</span>
        <span class="s1">this</span><span class="s0">.handlePotentialScroll();</span>
    <span class="s0">}</span>
    <span class="s0">componentDidUpdate() {</span>
        <span class="s3">// Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.props.focusAndScrollRef.apply) {</span>
            <span class="s1">this</span><span class="s0">.handlePotentialScroll();</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">render() {</span>
        <span class="s1">return this</span><span class="s0">.props.children;</span>
    <span class="s0">}</span>
    <span class="s0">constructor(...args){</span>
        <span class="s1">super</span><span class="s0">(...args), </span><span class="s1">this</span><span class="s0">.handlePotentialScroll = ()=&gt;{</span>
            <span class="s3">// Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.</span>
            <span class="s1">const </span><span class="s0">{ focusAndScrollRef, segmentPath } = </span><span class="s1">this</span><span class="s0">.props;</span>
            <span class="s1">if </span><span class="s0">(focusAndScrollRef.apply) {</span>
                <span class="s3">// segmentPaths is an array of segment paths that should be scrolled to</span>
                <span class="s3">// if the current segment path is not in the array, the scroll is not applied</span>
                <span class="s3">// unless the array is empty, in which case the scroll is always applied</span>
                <span class="s1">if </span><span class="s0">(focusAndScrollRef.segmentPaths.length !== </span><span class="s4">0 </span><span class="s0">&amp;&amp; !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath)=&gt;segmentPath.every((segment, index)=&gt;(</span><span class="s4">0</span><span class="s0">, _matchsegments.matchSegment)(segment, scrollRefSegmentPath[index])))) {</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">let </span><span class="s0">domNode = </span><span class="s1">null</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">hashFragment = focusAndScrollRef.hashFragment;</span>
                <span class="s1">if </span><span class="s0">(hashFragment) {</span>
                    <span class="s0">domNode = getHashFragmentDomNode(hashFragment);</span>
                <span class="s0">}</span>
                <span class="s3">// `findDOMNode` is tricky because it returns just the first child if the component is a fragment.</span>
                <span class="s3">// This already caused a bug where the first child was a &lt;link/&gt; in head.</span>
                <span class="s1">if </span><span class="s0">(!domNode) {</span>
                    <span class="s0">domNode = findDOMNode(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s3">// If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.</span>
                <span class="s1">if </span><span class="s0">(!(domNode </span><span class="s1">instanceof </span><span class="s0">Element)) {</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s3">// Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.</span>
                <span class="s3">// If the element is skipped, try to select the next sibling and try again.</span>
                <span class="s1">while</span><span class="s0">(!(domNode </span><span class="s1">instanceof </span><span class="s0">HTMLElement) || shouldSkipElement(domNode)){</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
                        <span class="s1">var </span><span class="s0">_domNode_parentElement;</span>
                        <span class="s1">if </span><span class="s0">(((_domNode_parentElement = domNode.parentElement) == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: _domNode_parentElement.localName) === </span><span class="s2">'head'</span><span class="s0">) {</span>
                        <span class="s3">// TODO: We enter this state when metadata was rendered as part of the page or via Next.js.</span>
                        <span class="s3">// This is always a bug in Next.js and caused by React hoisting metadata.</span>
                        <span class="s3">// We need to replace `findDOMNode` in favor of Fragment Refs (when available) so that we can skip over metadata.</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                    <span class="s3">// No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.</span>
                    <span class="s1">if </span><span class="s0">(domNode.nextElementSibling === </span><span class="s1">null</span><span class="s0">) {</span>
                        <span class="s1">return</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s0">domNode = domNode.nextElementSibling;</span>
                <span class="s0">}</span>
                <span class="s3">// State is mutated to ensure that the focus and scroll is applied only once.</span>
                <span class="s0">focusAndScrollRef.apply = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">focusAndScrollRef.hashFragment = </span><span class="s1">null</span><span class="s0">;</span>
                <span class="s0">focusAndScrollRef.segmentPaths = [];</span>
                <span class="s0">(</span><span class="s4">0</span><span class="s0">, _disablesmoothscroll.disableSmoothScrollDuringRouteTransition)(()=&gt;{</span>
                    <span class="s3">// In case of hash scroll, we only need to scroll the element into view</span>
                    <span class="s1">if </span><span class="s0">(hashFragment) {</span>
                        <span class="s0">;</span>
                        <span class="s0">domNode.scrollIntoView();</span>
                        <span class="s1">return</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s3">// Store the current viewport height because reading `clientHeight` causes a reflow,</span>
                    <span class="s3">// and it won't change during this function.</span>
                    <span class="s1">const </span><span class="s0">htmlElement = document.documentElement;</span>
                    <span class="s1">const </span><span class="s0">viewportHeight = htmlElement.clientHeight;</span>
                    <span class="s3">// If the element's top edge is already in the viewport, exit early.</span>
                    <span class="s1">if </span><span class="s0">(topOfElementInViewport(domNode, viewportHeight)) {</span>
                        <span class="s1">return</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s3">// Otherwise, try scrolling go the top of the document to be backward compatible with pages</span>
                    <span class="s3">// scrollIntoView() called on `&lt;html/&gt;` element scrolls horizontally on chrome and firefox (that shouldn't happen)</span>
                    <span class="s3">// We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left</span>
                    <span class="s3">// scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically</span>
                    <span class="s0">htmlElement.scrollTop = </span><span class="s4">0</span><span class="s0">;</span>
                    <span class="s3">// Scroll to domNode if domNode is not in viewport when scrolled to top of document</span>
                    <span class="s1">if </span><span class="s0">(!topOfElementInViewport(domNode, viewportHeight)) {</span>
                        <span class="s3">// Scroll into view doesn't scroll horizontally by default when not needed</span>
                        <span class="s0">;</span>
                        <span class="s0">domNode.scrollIntoView();</span>
                    <span class="s0">}</span>
                <span class="s0">}, {</span>
                    <span class="s3">// We will force layout by querying domNode position</span>
                    <span class="s0">dontForceLayout: </span><span class="s1">true</span><span class="s0">,</span>
                    <span class="s0">onlyHashChange: focusAndScrollRef.onlyHashChange</span>
                <span class="s0">});</span>
                <span class="s3">// Mutate after scrolling so that it can be read by `disableSmoothScrollDuringRouteTransition`</span>
                <span class="s0">focusAndScrollRef.onlyHashChange = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s3">// Set focus on the element</span>
                <span class="s0">domNode.focus();</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">ScrollAndFocusHandler(param) {</span>
    <span class="s1">let </span><span class="s0">{ segmentPath, children } = param;</span>
    <span class="s1">const </span><span class="s0">context = (</span><span class="s4">0</span><span class="s0">, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);</span>
    <span class="s1">if </span><span class="s0">(!context) {</span>
        <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">'invariant global layout router not mounted'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
            <span class="s0">value: </span><span class="s2">&quot;E473&quot;</span><span class="s0">,</span>
            <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">configurable: </span><span class="s1">true</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(InnerScrollAndFocusHandler, {</span>
        <span class="s0">segmentPath: segmentPath,</span>
        <span class="s0">focusAndScrollRef: context.focusAndScrollRef,</span>
        <span class="s0">children: children</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* InnerLayoutRouter handles rendering the provided segment based on the cache.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">InnerLayoutRouter(param) {</span>
    <span class="s1">let </span><span class="s0">{ tree, segmentPath, cacheNode, url } = param;</span>
    <span class="s1">const </span><span class="s0">context = (</span><span class="s4">0</span><span class="s0">, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);</span>
    <span class="s1">if </span><span class="s0">(!context) {</span>
        <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">'invariant global layout router not mounted'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
            <span class="s0">value: </span><span class="s2">&quot;E473&quot;</span><span class="s0">,</span>
            <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">configurable: </span><span class="s1">true</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">{ tree: fullTree } = context;</span>
    <span class="s3">// `rsc` represents the renderable node for this segment.</span>
    <span class="s3">// If this segment has a `prefetchRsc`, it's the statically prefetched data.</span>
    <span class="s3">// We should use that on initial render instead of `rsc`. Then we'll switch</span>
    <span class="s3">// to `rsc` when the dynamic response streams in.</span>
    <span class="s3">//</span>
    <span class="s3">// If no prefetch data is available, then we go straight to rendering `rsc`.</span>
    <span class="s1">const </span><span class="s0">resolvedPrefetchRsc = cacheNode.prefetchRsc !== </span><span class="s1">null </span><span class="s0">? cacheNode.prefetchRsc : cacheNode.rsc;</span>
    <span class="s3">// We use `useDeferredValue` to handle switching between the prefetched and</span>
    <span class="s3">// final values. The second argument is returned on initial render, then it</span>
    <span class="s3">// re-renders with the first argument.</span>
    <span class="s1">const </span><span class="s0">rsc = (</span><span class="s4">0</span><span class="s0">, _react.useDeferredValue)(cacheNode.rsc, resolvedPrefetchRsc);</span>
    <span class="s3">// `rsc` is either a React node or a promise for a React node, except we</span>
    <span class="s3">// special case `null` to represent that this segment's data is missing. If</span>
    <span class="s3">// it's a promise, we need to unwrap it so we can determine whether or not the</span>
    <span class="s3">// data is missing.</span>
    <span class="s1">const </span><span class="s0">resolvedRsc = </span><span class="s1">typeof </span><span class="s0">rsc === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; rsc !== </span><span class="s1">null </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">rsc.then === </span><span class="s2">'function' </span><span class="s0">? (</span><span class="s4">0</span><span class="s0">, _react.use)(rsc) : rsc;</span>
    <span class="s1">if </span><span class="s0">(!resolvedRsc) {</span>
        <span class="s3">// The data for this segment is not available, and there's no pending</span>
        <span class="s3">// navigation that will be able to fulfill it. We need to fetch more from</span>
        <span class="s3">// the server and patch the cache.</span>
        <span class="s3">// Check if there's already a pending request.</span>
        <span class="s1">let </span><span class="s0">lazyData = cacheNode.lazyData;</span>
        <span class="s1">if </span><span class="s0">(lazyData === </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s3">/**</span>
       <span class="s3">* Router state with refetch marker added</span>
       <span class="s3">*/ // TODO-APP: remove ''</span>
            <span class="s1">const </span><span class="s0">refetchTree = walkAddRefetch([</span>
                <span class="s2">''</span><span class="s0">,</span>
                <span class="s0">...segmentPath</span>
            <span class="s0">], fullTree);</span>
            <span class="s1">const </span><span class="s0">includeNextUrl = (</span><span class="s4">0</span><span class="s0">, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(fullTree);</span>
            <span class="s1">const </span><span class="s0">navigatedAt = Date.now();</span>
            <span class="s0">cacheNode.lazyData = lazyData = (</span><span class="s4">0</span><span class="s0">, _fetchserverresponse.fetchServerResponse)(</span><span class="s1">new </span><span class="s0">URL(url, location.origin), {</span>
                <span class="s0">flightRouterState: refetchTree,</span>
                <span class="s0">nextUrl: includeNextUrl ? context.nextUrl : </span><span class="s1">null</span>
            <span class="s0">}).then((serverResponse)=&gt;{</span>
                <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.startTransition)(()=&gt;{</span>
                    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _useactionqueue.dispatchAppRouterAction)({</span>
                        <span class="s0">type: _routerreducertypes.ACTION_SERVER_PATCH,</span>
                        <span class="s0">previousTree: fullTree,</span>
                        <span class="s0">serverResponse,</span>
                        <span class="s0">navigatedAt</span>
                    <span class="s0">});</span>
                <span class="s0">});</span>
                <span class="s1">return </span><span class="s0">serverResponse;</span>
            <span class="s0">});</span>
            <span class="s3">// Suspend while waiting for lazyData to resolve</span>
            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.use)(lazyData);</span>
        <span class="s0">}</span>
        <span class="s3">// Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.</span>
        <span class="s3">// A falsey `resolvedRsc` indicates missing data -- we should not commit that branch, and we need to wait for the data to arrive.</span>
        <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.use)(_unresolvedthenable.unresolvedThenable);</span>
    <span class="s0">}</span>
    <span class="s3">// If we get to this point, then we know we have something we can render.</span>
    <span class="s1">const </span><span class="s0">subtree = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_approutercontextsharedruntime.LayoutRouterContext.Provider, {</span>
        <span class="s0">value: {</span>
            <span class="s0">parentTree: tree,</span>
            <span class="s0">parentCacheNode: cacheNode,</span>
            <span class="s0">parentSegmentPath: segmentPath,</span>
            <span class="s3">// TODO-APP: overriding of url for parallel routes</span>
            <span class="s0">url: url</span>
        <span class="s0">},</span>
        <span class="s0">children: resolvedRsc</span>
    <span class="s0">});</span>
    <span class="s3">// Ensure root layout is not wrapped in a div as the root layout renders `&lt;html&gt;`</span>
    <span class="s1">return </span><span class="s0">subtree;</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* Renders suspense boundary with the provided &quot;loading&quot; property as the fallback.</span>
 <span class="s3">* If no loading property is provided it renders the children without a suspense boundary.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">LoadingBoundary(param) {</span>
    <span class="s1">let </span><span class="s0">{ loading, children } = param;</span>
    <span class="s3">// If loading is a promise, unwrap it. This happens in cases where we haven't</span>
    <span class="s3">// yet received the loading data from the server â€” which includes whether or</span>
    <span class="s3">// not this layout has a loading component at all.</span>
    <span class="s3">//</span>
    <span class="s3">// It's OK to suspend here instead of inside the fallback because this</span>
    <span class="s3">// promise will resolve simultaneously with the data for the segment itself.</span>
    <span class="s3">// So it will never suspend for longer than it would have if we didn't use</span>
    <span class="s3">// a Suspense fallback at all.</span>
    <span class="s1">let </span><span class="s0">loadingModuleData;</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">loading === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; loading !== </span><span class="s1">null </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">loading.then === </span><span class="s2">'function'</span><span class="s0">) {</span>
        <span class="s1">const </span><span class="s0">promiseForLoading = loading;</span>
        <span class="s0">loadingModuleData = (</span><span class="s4">0</span><span class="s0">, _react.use)(promiseForLoading);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">loadingModuleData = loading;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(loadingModuleData) {</span>
        <span class="s1">const </span><span class="s0">loadingRsc = loadingModuleData[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s1">const </span><span class="s0">loadingStyles = loadingModuleData[</span><span class="s4">1</span><span class="s0">];</span>
        <span class="s1">const </span><span class="s0">loadingScripts = loadingModuleData[</span><span class="s4">2</span><span class="s0">];</span>
        <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_react.Suspense, {</span>
            <span class="s0">fallback: </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsxs)(_jsxruntime.Fragment, {</span>
                <span class="s0">children: [</span>
                    <span class="s0">loadingStyles,</span>
                    <span class="s0">loadingScripts,</span>
                    <span class="s0">loadingRsc</span>
                <span class="s0">]</span>
            <span class="s0">}),</span>
            <span class="s0">children: children</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_jsxruntime.Fragment, {</span>
        <span class="s0">children: children</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">OuterLayoutRouter(param) {</span>
    <span class="s1">let </span><span class="s0">{ parallelRouterKey, error, errorStyles, errorScripts, templateStyles, templateScripts, template, notFound, forbidden, unauthorized, segmentViewBoundaries } = param;</span>
    <span class="s1">const </span><span class="s0">context = (</span><span class="s4">0</span><span class="s0">, _react.useContext)(_approutercontextsharedruntime.LayoutRouterContext);</span>
    <span class="s1">if </span><span class="s0">(!context) {</span>
        <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">'invariant expected layout router to be mounted'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
            <span class="s0">value: </span><span class="s2">&quot;E56&quot;</span><span class="s0">,</span>
            <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">configurable: </span><span class="s1">true</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">{ parentTree, parentCacheNode, parentSegmentPath, url } = context;</span>
    <span class="s3">// Get the CacheNode for this segment by reading it from the parent segment's</span>
    <span class="s3">// child map.</span>
    <span class="s1">const </span><span class="s0">parentParallelRoutes = parentCacheNode.parallelRoutes;</span>
    <span class="s1">let </span><span class="s0">segmentMap = parentParallelRoutes.get(parallelRouterKey);</span>
    <span class="s3">// If the parallel router cache node does not exist yet, create it.</span>
    <span class="s3">// This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.</span>
    <span class="s1">if </span><span class="s0">(!segmentMap) {</span>
        <span class="s0">segmentMap = </span><span class="s1">new </span><span class="s0">Map();</span>
        <span class="s0">parentParallelRoutes.set(parallelRouterKey, segmentMap);</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">parentTreeSegment = parentTree[</span><span class="s4">0</span><span class="s0">];</span>
    <span class="s1">const </span><span class="s0">segmentPath = parentSegmentPath === </span><span class="s1">null </span><span class="s0">? </span><span class="s3">// the code. We should clean this up.</span>
    <span class="s0">[</span>
        <span class="s0">parallelRouterKey</span>
    <span class="s0">] : parentSegmentPath.concat([</span>
        <span class="s0">parentTreeSegment,</span>
        <span class="s0">parallelRouterKey</span>
    <span class="s0">]);</span>
    <span class="s3">// The &quot;state&quot; key of a segment is the one passed to React â€” it represents the</span>
    <span class="s3">// identity of the UI tree. Whenever the state key changes, the tree is</span>
    <span class="s3">// recreated and the state is reset. In the App Router model, search params do</span>
    <span class="s3">// not cause state to be lost, so two segments with the same segment path but</span>
    <span class="s3">// different search params should have the same state key.</span>
    <span class="s3">//</span>
    <span class="s3">// The &quot;cache&quot; key of a segment, however, *does* include the search params, if</span>
    <span class="s3">// it's possible that the segment accessed the search params on the server.</span>
    <span class="s3">// (This only applies to page segments; layout segments cannot access search</span>
    <span class="s3">// params on the server.)</span>
    <span class="s1">const </span><span class="s0">activeTree = parentTree[</span><span class="s4">1</span><span class="s0">][parallelRouterKey];</span>
    <span class="s1">const </span><span class="s0">activeSegment = activeTree[</span><span class="s4">0</span><span class="s0">];</span>
    <span class="s1">const </span><span class="s0">activeStateKey = (</span><span class="s4">0</span><span class="s0">, _createroutercachekey.createRouterCacheKey)(activeSegment, </span><span class="s1">true</span><span class="s0">) </span><span class="s3">// no search params</span>
    <span class="s0">;</span>
    <span class="s3">// At each level of the route tree, not only do we render the currently</span>
    <span class="s3">// active segment â€” we also render the last N segments that were active at</span>
    <span class="s3">// this level inside a hidden &lt;Activity&gt; boundary, to preserve their state</span>
    <span class="s3">// if or when the user navigates to them again.</span>
    <span class="s3">//</span>
    <span class="s3">// bfcacheEntry is a linked list of FlightRouterStates.</span>
    <span class="s1">let </span><span class="s0">bfcacheEntry = (</span><span class="s4">0</span><span class="s0">, _bfcache.useRouterBFCache)(activeTree, activeStateKey);</span>
    <span class="s1">let </span><span class="s0">children = [];</span>
    <span class="s1">do </span><span class="s0">{</span>
        <span class="s1">const </span><span class="s0">tree = bfcacheEntry.tree;</span>
        <span class="s1">const </span><span class="s0">stateKey = bfcacheEntry.stateKey;</span>
        <span class="s1">const </span><span class="s0">segment = tree[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s1">const </span><span class="s0">cacheKey = (</span><span class="s4">0</span><span class="s0">, _createroutercachekey.createRouterCacheKey)(segment);</span>
        <span class="s3">// Read segment path from the parallel router cache node.</span>
        <span class="s1">let </span><span class="s0">cacheNode = segmentMap.get(cacheKey);</span>
        <span class="s1">if </span><span class="s0">(cacheNode === undefined) {</span>
            <span class="s3">// When data is not available during rendering client-side we need to fetch</span>
            <span class="s3">// it from the server.</span>
            <span class="s1">const </span><span class="s0">newLazyCacheNode = {</span>
                <span class="s0">lazyData: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">rsc: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">prefetchRsc: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">head: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">prefetchHead: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">parallelRoutes: </span><span class="s1">new </span><span class="s0">Map(),</span>
                <span class="s0">loading: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">navigatedAt: -</span><span class="s4">1</span>
            <span class="s0">};</span>
            <span class="s3">// Flight data fetch kicked off during render and put into the cache.</span>
            <span class="s0">cacheNode = newLazyCacheNode;</span>
            <span class="s0">segmentMap.set(cacheKey, newLazyCacheNode);</span>
        <span class="s0">}</span>
        <span class="s3">/* 
    - Error boundary 
      - Only renders error boundary if error component is provided. 
      - Rendered for each segment to ensure they have their own error state. 
      - When gracefully degrade for bots, skip rendering error boundary. 
    - Loading boundary 
      - Only renders suspense boundary if loading components is provided. 
      - Rendered for each segment to ensure they have their own loading state. 
      - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch. 
  */ </span><span class="s1">let </span><span class="s0">segmentBoundaryTriggerNode = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">segmentViewStateNode = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s1">const </span><span class="s0">{ SegmentBoundaryTriggerNode, SegmentViewStateNode } = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
            <span class="s1">const </span><span class="s0">pagePrefix = (</span><span class="s4">0</span><span class="s0">, _apppaths.normalizeAppPath)(url);</span>
            <span class="s0">segmentViewStateNode = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(SegmentViewStateNode, {</span>
                <span class="s0">page: pagePrefix</span>
            <span class="s0">}, pagePrefix);</span>
            <span class="s0">segmentBoundaryTriggerNode = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_jsxruntime.Fragment, {</span>
                <span class="s0">children: </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(SegmentBoundaryTriggerNode, {})</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s3">// TODO: The loading module data for a segment is stored on the parent, then</span>
        <span class="s3">// applied to each of that parent segment's parallel route slots. In the</span>
        <span class="s3">// simple case where there's only one parallel route (the `children` slot),</span>
        <span class="s3">// this is no different from if the loading module data where stored on the</span>
        <span class="s3">// child directly. But I'm not sure this actually makes sense when there are</span>
        <span class="s3">// multiple parallel routes. It's not a huge issue because you always have</span>
        <span class="s3">// the option to define a narrower loading boundary for a particular slot. But</span>
        <span class="s3">// this sort of smells like an implementation accident to me.</span>
        <span class="s1">const </span><span class="s0">loadingModuleData = parentCacheNode.loading;</span>
        <span class="s1">let </span><span class="s0">child = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsxs)(_approutercontextsharedruntime.TemplateContext.Provider, {</span>
            <span class="s0">value: </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsxs)(ScrollAndFocusHandler, {</span>
                <span class="s0">segmentPath: segmentPath,</span>
                <span class="s0">children: [</span>
                    <span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_errorboundary.ErrorBoundary, {</span>
                        <span class="s0">errorComponent: error,</span>
                        <span class="s0">errorStyles: errorStyles,</span>
                        <span class="s0">errorScripts: errorScripts,</span>
                        <span class="s0">children: </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(LoadingBoundary, {</span>
                            <span class="s0">loading: loadingModuleData,</span>
                            <span class="s0">children: </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_errorboundary1.HTTPAccessFallbackBoundary, {</span>
                                <span class="s0">notFound: notFound,</span>
                                <span class="s0">forbidden: forbidden,</span>
                                <span class="s0">unauthorized: unauthorized,</span>
                                <span class="s0">children: </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsxs)(_redirectboundary.RedirectBoundary, {</span>
                                    <span class="s0">children: [</span>
                                        <span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(InnerLayoutRouter, {</span>
                                            <span class="s0">url: url,</span>
                                            <span class="s0">tree: tree,</span>
                                            <span class="s0">cacheNode: cacheNode,</span>
                                            <span class="s0">segmentPath: segmentPath</span>
                                        <span class="s0">}),</span>
                                        <span class="s0">segmentBoundaryTriggerNode</span>
                                    <span class="s0">]</span>
                                <span class="s0">})</span>
                            <span class="s0">})</span>
                        <span class="s0">})</span>
                    <span class="s0">}),</span>
                    <span class="s0">segmentViewStateNode</span>
                <span class="s0">]</span>
            <span class="s0">}),</span>
            <span class="s0">children: [</span>
                <span class="s0">templateStyles,</span>
                <span class="s0">templateScripts,</span>
                <span class="s0">template</span>
            <span class="s0">]</span>
        <span class="s0">}, stateKey);</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s1">const </span><span class="s0">{ SegmentStateProvider } = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
            <span class="s0">child = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsxs)(SegmentStateProvider, {</span>
                <span class="s0">children: [</span>
                    <span class="s0">child,</span>
                    <span class="s0">segmentViewBoundaries</span>
                <span class="s0">]</span>
            <span class="s0">}, stateKey);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
        <span class="s0">;</span>
        <span class="s0">children.push(child);</span>
        <span class="s0">bfcacheEntry = bfcacheEntry.next;</span>
    <span class="s0">}</span><span class="s1">while </span><span class="s0">(bfcacheEntry !== </span><span class="s1">null</span><span class="s0">)</span>
    <span class="s1">return </span><span class="s0">children;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=layout-router.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/render-from-template-context.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;default&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">RenderFromTemplateContext;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_interop_require_wildcard = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_jsxruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_react = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_interop_require_wildcard._(__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)&quot;</span><span class="s0">));</span>
<span class="s1">const </span><span class="s0">_approutercontextsharedruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">RenderFromTemplateContext() {</span>
    <span class="s1">const </span><span class="s0">children = (</span><span class="s4">0</span><span class="s0">, _react.useContext)(_approutercontextsharedruntime.TemplateContext);</span>
    <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_jsxruntime.Fragment, {</span>
        <span class="s0">children: children</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=render-from-template-context.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;ReflectAdapter&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">ReflectAdapter;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">class </span><span class="s0">ReflectAdapter {</span>
    <span class="s1">static </span><span class="s0">get(target, prop, receiver) {</span>
        <span class="s1">const </span><span class="s0">value = Reflect.get(target, prop, receiver);</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">'function'</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">value.bind(target);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">value;</span>
    <span class="s0">}</span>
    <span class="s1">static </span><span class="s0">set(target, prop, value, receiver) {</span>
        <span class="s1">return </span><span class="s0">Reflect.set(target, prop, value, receiver);</span>
    <span class="s0">}</span>
    <span class="s1">static </span><span class="s0">has(target, prop) {</span>
        <span class="s1">return </span><span class="s0">Reflect.has(target, prop);</span>
    <span class="s0">}</span>
    <span class="s1">static </span><span class="s0">deleteProperty(target, prop) {</span>
        <span class="s1">return </span><span class="s0">Reflect.deleteProperty(target, prop);</span>
    <span class="s0">}</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=reflect.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/utils/reflect-utils.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s3">// This regex will have fast negatives meaning valid identifiers may not pass</span>
<span class="s3">// this test. However this is only used during static generation to provide hints</span>
<span class="s3">// about why a page bailed out of some or all prerendering and we can use bracket notation</span>
<span class="s3">// for example while `à² _à² ` is a valid identifier it's ok to print `searchParams['à² _à² ']`</span>
<span class="s3">// even if this would have been fine too `searchParams.à² _à² `</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">describeHasCheckingStringProperty: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">describeStringPropertyAccess: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">wellKnownProperties: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">describeHasCheckingStringProperty: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">describeHasCheckingStringProperty;</span>
    <span class="s0">},</span>
    <span class="s0">describeStringPropertyAccess: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">describeStringPropertyAccess;</span>
    <span class="s0">},</span>
    <span class="s0">wellKnownProperties: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">wellKnownProperties;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">isDefinitelyAValidIdentifier = </span><span class="s5">/^[A-Za-z_$][A-Za-z0-9_$]*$/</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">describeStringPropertyAccess(target, prop) {</span>
    <span class="s1">if </span><span class="s0">(isDefinitelyAValidIdentifier.test(prop)) {</span>
        <span class="s1">return </span><span class="s2">&quot;`&quot; </span><span class="s0">+ target + </span><span class="s2">&quot;.&quot; </span><span class="s0">+ prop + </span><span class="s2">&quot;`&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s2">&quot;`&quot; </span><span class="s0">+ target + </span><span class="s2">&quot;[&quot; </span><span class="s0">+ JSON.stringify(prop) + </span><span class="s2">&quot;]`&quot;</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">describeHasCheckingStringProperty(target, prop) {</span>
    <span class="s1">const </span><span class="s0">stringifiedProp = JSON.stringify(prop);</span>
    <span class="s1">return </span><span class="s2">&quot;`Reflect.has(&quot; </span><span class="s0">+ target + </span><span class="s2">&quot;, &quot; </span><span class="s0">+ stringifiedProp + </span><span class="s2">&quot;)`, `&quot; </span><span class="s0">+ stringifiedProp + </span><span class="s2">&quot; in &quot; </span><span class="s0">+ target + </span><span class="s2">&quot;`, or similar&quot;</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">wellKnownProperties = </span><span class="s1">new </span><span class="s0">Set([</span>
    <span class="s2">'hasOwnProperty'</span><span class="s0">,</span>
    <span class="s2">'isPrototypeOf'</span><span class="s0">,</span>
    <span class="s2">'propertyIsEnumerable'</span><span class="s0">,</span>
    <span class="s2">'toString'</span><span class="s0">,</span>
    <span class="s2">'valueOf'</span><span class="s0">,</span>
    <span class="s2">'toLocaleString'</span><span class="s0">,</span>
    <span class="s3">// Promise prototype</span>
    <span class="s3">// fallthrough</span>
    <span class="s2">'then'</span><span class="s0">,</span>
    <span class="s2">'catch'</span><span class="s0">,</span>
    <span class="s2">'finally'</span><span class="s0">,</span>
    <span class="s3">// React Promise extension</span>
    <span class="s3">// fallthrough</span>
    <span class="s2">'status'</span><span class="s0">,</span>
    <span class="s3">// React introspection</span>
    <span class="s2">'displayName'</span><span class="s0">,</span>
    <span class="s2">'_debugInfo'</span><span class="s0">,</span>
    <span class="s3">// Common tested properties</span>
    <span class="s3">// fallthrough</span>
    <span class="s2">'toJSON'</span><span class="s0">,</span>
    <span class="s2">'$$typeof'</span><span class="s0">,</span>
    <span class="s2">'__esModule'</span>
<span class="s0">]); </span><span class="s3">//# sourceMappingURL=reflect-utils.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/request/search-params.browser.dev.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;createRenderSearchParamsFromClient&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">createRenderSearchParamsFromClient;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_reflect = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_reflectutils = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/utils/reflect-utils.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">CachedSearchParams = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
<span class="s1">function </span><span class="s0">makeUntrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams) {</span>
    <span class="s1">const </span><span class="s0">cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);</span>
    <span class="s1">if </span><span class="s0">(cachedSearchParams) {</span>
        <span class="s1">return </span><span class="s0">cachedSearchParams;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">proxiedProperties = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s1">const </span><span class="s0">unproxiedProperties = [];</span>
    <span class="s1">const </span><span class="s0">promise = Promise.resolve(underlyingSearchParams);</span>
    <span class="s0">Object.keys(underlyingSearchParams).forEach((prop)=&gt;{</span>
        <span class="s1">if </span><span class="s0">(_reflectutils.wellKnownProperties.has(prop)) {</span>
            <span class="s3">// These properties cannot be shadowed because they need to be the</span>
            <span class="s3">// true underlying value for Promises to work correctly at runtime</span>
            <span class="s0">unproxiedProperties.push(prop);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">proxiedProperties.add(prop);</span>
            <span class="s0">promise[prop] = underlyingSearchParams[prop];</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s1">const </span><span class="s0">proxiedPromise = </span><span class="s1">new </span><span class="s0">Proxy(promise, {</span>
        <span class="s0">get (target, prop, receiver) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(!_reflectutils.wellKnownProperties.has(prop) &amp;&amp; (proxiedProperties.has(prop) || </span><span class="s3">// We are accessing a property that doesn't exist on the promise nor</span>
                <span class="s3">// the underlying searchParams.</span>
                <span class="s0">Reflect.has(target, prop) === </span><span class="s1">false</span><span class="s0">)) {</span>
                    <span class="s1">const </span><span class="s0">expression = (</span><span class="s4">0</span><span class="s0">, _reflectutils.describeStringPropertyAccess)(</span><span class="s2">'searchParams'</span><span class="s0">, prop);</span>
                    <span class="s0">warnForSyncAccess(expression);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
        <span class="s0">},</span>
        <span class="s0">set (target, prop, value, receiver) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s0">proxiedProperties.delete(prop);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">Reflect.set(target, prop, value, receiver);</span>
        <span class="s0">},</span>
        <span class="s0">has (target, prop) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(!_reflectutils.wellKnownProperties.has(prop) &amp;&amp; (proxiedProperties.has(prop) || </span><span class="s3">// We are accessing a property that doesn't exist on the promise nor</span>
                <span class="s3">// the underlying searchParams.</span>
                <span class="s0">Reflect.has(target, prop) === </span><span class="s1">false</span><span class="s0">)) {</span>
                    <span class="s1">const </span><span class="s0">expression = (</span><span class="s4">0</span><span class="s0">, _reflectutils.describeHasCheckingStringProperty)(</span><span class="s2">'searchParams'</span><span class="s0">, prop);</span>
                    <span class="s0">warnForSyncAccess(expression);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">Reflect.has(target, prop);</span>
        <span class="s0">},</span>
        <span class="s0">ownKeys (target) {</span>
            <span class="s0">warnForSyncSpread();</span>
            <span class="s1">return </span><span class="s0">Reflect.ownKeys(target);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">CachedSearchParams.set(underlyingSearchParams, proxiedPromise);</span>
    <span class="s1">return </span><span class="s0">proxiedPromise;</span>
<span class="s0">}</span>
<span class="s3">// Similar to `makeUntrackedExoticSearchParamsWithDevWarnings`, but just logging</span>
<span class="s3">// the sync access without actually defining the search params on the promise.</span>
<span class="s1">function </span><span class="s0">makeUntrackedSearchParamsWithDevWarnings(underlyingSearchParams) {</span>
    <span class="s1">const </span><span class="s0">cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);</span>
    <span class="s1">if </span><span class="s0">(cachedSearchParams) {</span>
        <span class="s1">return </span><span class="s0">cachedSearchParams;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">proxiedProperties = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s1">const </span><span class="s0">unproxiedProperties = [];</span>
    <span class="s1">const </span><span class="s0">promise = Promise.resolve(underlyingSearchParams);</span>
    <span class="s0">Object.keys(underlyingSearchParams).forEach((prop)=&gt;{</span>
        <span class="s1">if </span><span class="s0">(_reflectutils.wellKnownProperties.has(prop)) {</span>
            <span class="s3">// These properties cannot be shadowed because they need to be the</span>
            <span class="s3">// true underlying value for Promises to work correctly at runtime</span>
            <span class="s0">unproxiedProperties.push(prop);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">proxiedProperties.add(prop);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s1">const </span><span class="s0">proxiedPromise = </span><span class="s1">new </span><span class="s0">Proxy(promise, {</span>
        <span class="s0">get (target, prop, receiver) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(!_reflectutils.wellKnownProperties.has(prop) &amp;&amp; (proxiedProperties.has(prop) || </span><span class="s3">// We are accessing a property that doesn't exist on the promise nor</span>
                <span class="s3">// the underlying searchParams.</span>
                <span class="s0">Reflect.has(target, prop) === </span><span class="s1">false</span><span class="s0">)) {</span>
                    <span class="s1">const </span><span class="s0">expression = (</span><span class="s4">0</span><span class="s0">, _reflectutils.describeStringPropertyAccess)(</span><span class="s2">'searchParams'</span><span class="s0">, prop);</span>
                    <span class="s0">warnForSyncAccess(expression);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
        <span class="s0">},</span>
        <span class="s0">set (target, prop, value, receiver) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s0">proxiedProperties.delete(prop);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">Reflect.set(target, prop, value, receiver);</span>
        <span class="s0">},</span>
        <span class="s0">has (target, prop) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(!_reflectutils.wellKnownProperties.has(prop) &amp;&amp; (proxiedProperties.has(prop) || </span><span class="s3">// We are accessing a property that doesn't exist on the promise nor</span>
                <span class="s3">// the underlying searchParams.</span>
                <span class="s0">Reflect.has(target, prop) === </span><span class="s1">false</span><span class="s0">)) {</span>
                    <span class="s1">const </span><span class="s0">expression = (</span><span class="s4">0</span><span class="s0">, _reflectutils.describeHasCheckingStringProperty)(</span><span class="s2">'searchParams'</span><span class="s0">, prop);</span>
                    <span class="s0">warnForSyncAccess(expression);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">Reflect.has(target, prop);</span>
        <span class="s0">},</span>
        <span class="s0">ownKeys (target) {</span>
            <span class="s0">warnForSyncSpread();</span>
            <span class="s1">return </span><span class="s0">Reflect.ownKeys(target);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">CachedSearchParams.set(underlyingSearchParams, proxiedPromise);</span>
    <span class="s1">return </span><span class="s0">proxiedPromise;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">warnForSyncAccess(expression) {</span>
    <span class="s0">console.error(</span><span class="s2">&quot;A searchParam property was accessed directly with &quot; </span><span class="s0">+ expression + </span><span class="s2">&quot;. &quot; </span><span class="s0">+ </span><span class="s2">&quot;`searchParams` should be unwrapped with `React.use()` before accessing its properties. &quot; </span><span class="s0">+ </span><span class="s2">&quot;Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis&quot;</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">warnForSyncSpread() {</span>
    <span class="s0">console.error(</span><span class="s2">&quot;The keys of `searchParams` were accessed directly. &quot; </span><span class="s0">+ </span><span class="s2">&quot;`searchParams` should be unwrapped with `React.use()` before accessing its properties. &quot; </span><span class="s0">+ </span><span class="s2">&quot;Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis&quot;</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createRenderSearchParamsFromClient(underlyingSearchParams) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
    <span class="s1">return </span><span class="s0">makeUntrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams);</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=search-params.browser.dev.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/request/search-params.browser.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;createRenderSearchParamsFromClient&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">createRenderSearchParamsFromClient;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">createRenderSearchParamsFromClient = (</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) ? __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/request/search-params.browser.dev.js [app-client] (ecmascript)&quot;</span><span class="s0">).createRenderSearchParamsFromClient : </span><span class="s2">&quot;TURBOPACK unreachable&quot;</span><span class="s0">;</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=search-params.browser.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/request/params.browser.dev.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;createRenderParamsFromClient&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">createRenderParamsFromClient;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_reflect = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_invarianterror = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_reflectutils = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/utils/reflect-utils.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">CachedParams = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
<span class="s1">function </span><span class="s0">makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams) {</span>
    <span class="s1">const </span><span class="s0">cachedParams = CachedParams.get(underlyingParams);</span>
    <span class="s1">if </span><span class="s0">(cachedParams) {</span>
        <span class="s1">return </span><span class="s0">cachedParams;</span>
    <span class="s0">}</span>
    <span class="s3">// We don't use makeResolvedReactPromise here because params</span>
    <span class="s3">// supports copying with spread and we don't want to unnecessarily</span>
    <span class="s3">// instrument the promise with spreadable properties of ReactPromise.</span>
    <span class="s1">const </span><span class="s0">promise = Promise.resolve(underlyingParams);</span>
    <span class="s1">const </span><span class="s0">proxiedProperties = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s1">const </span><span class="s0">unproxiedProperties = [];</span>
    <span class="s0">Object.keys(underlyingParams).forEach((prop)=&gt;{</span>
        <span class="s1">if </span><span class="s0">(_reflectutils.wellKnownProperties.has(prop)) {</span>
        <span class="s3">// These properties cannot be shadowed because they need to be the</span>
        <span class="s3">// true underlying value for Promises to work correctly at runtime</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">proxiedProperties.add(prop);</span>
            <span class="s0">promise[prop] = underlyingParams[prop];</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s1">const </span><span class="s0">proxiedPromise = </span><span class="s1">new </span><span class="s0">Proxy(promise, {</span>
        <span class="s0">get (target, prop, receiver) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(proxiedProperties.has(prop)) {</span>
                    <span class="s1">const </span><span class="s0">expression = (</span><span class="s4">0</span><span class="s0">, _reflectutils.describeStringPropertyAccess)(</span><span class="s2">'params'</span><span class="s0">, prop);</span>
                    <span class="s0">warnForSyncAccess(expression);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
        <span class="s0">},</span>
        <span class="s0">set (target, prop, value, receiver) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s0">proxiedProperties.delete(prop);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">_reflect.ReflectAdapter.set(target, prop, value, receiver);</span>
        <span class="s0">},</span>
        <span class="s0">ownKeys (target) {</span>
            <span class="s0">warnForEnumeration(unproxiedProperties);</span>
            <span class="s1">return </span><span class="s0">Reflect.ownKeys(target);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">CachedParams.set(underlyingParams, proxiedPromise);</span>
    <span class="s1">return </span><span class="s0">proxiedPromise;</span>
<span class="s0">}</span>
<span class="s3">// Similar to `makeDynamicallyTrackedExoticParamsWithDevWarnings`, but just</span>
<span class="s3">// logging the sync access without actually defining the params on the promise.</span>
<span class="s1">function </span><span class="s0">makeDynamicallyTrackedParamsWithDevWarnings(underlyingParams) {</span>
    <span class="s1">const </span><span class="s0">cachedParams = CachedParams.get(underlyingParams);</span>
    <span class="s1">if </span><span class="s0">(cachedParams) {</span>
        <span class="s1">return </span><span class="s0">cachedParams;</span>
    <span class="s0">}</span>
    <span class="s3">// We don't use makeResolvedReactPromise here because params</span>
    <span class="s3">// supports copying with spread and we don't want to unnecessarily</span>
    <span class="s3">// instrument the promise with spreadable properties of ReactPromise.</span>
    <span class="s1">const </span><span class="s0">promise = Promise.resolve(underlyingParams);</span>
    <span class="s1">const </span><span class="s0">proxiedProperties = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s1">const </span><span class="s0">unproxiedProperties = [];</span>
    <span class="s0">Object.keys(underlyingParams).forEach((prop)=&gt;{</span>
        <span class="s1">if </span><span class="s0">(_reflectutils.wellKnownProperties.has(prop)) {</span>
        <span class="s3">// These properties cannot be shadowed because they need to be the</span>
        <span class="s3">// true underlying value for Promises to work correctly at runtime</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">proxiedProperties.add(prop);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s1">const </span><span class="s0">proxiedPromise = </span><span class="s1">new </span><span class="s0">Proxy(promise, {</span>
        <span class="s0">get (target, prop, receiver) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(proxiedProperties.has(prop)) {</span>
                    <span class="s1">const </span><span class="s0">expression = (</span><span class="s4">0</span><span class="s0">, _reflectutils.describeStringPropertyAccess)(</span><span class="s2">'params'</span><span class="s0">, prop);</span>
                    <span class="s0">warnForSyncAccess(expression);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
        <span class="s0">},</span>
        <span class="s0">set (target, prop, value, receiver) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s0">proxiedProperties.delete(prop);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">_reflect.ReflectAdapter.set(target, prop, value, receiver);</span>
        <span class="s0">},</span>
        <span class="s0">ownKeys (target) {</span>
            <span class="s0">warnForEnumeration(unproxiedProperties);</span>
            <span class="s1">return </span><span class="s0">Reflect.ownKeys(target);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">CachedParams.set(underlyingParams, proxiedPromise);</span>
    <span class="s1">return </span><span class="s0">proxiedPromise;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">warnForSyncAccess(expression) {</span>
    <span class="s0">console.error(</span><span class="s2">&quot;A param property was accessed directly with &quot; </span><span class="s0">+ expression + </span><span class="s2">&quot;. `params` is now a Promise and should be unwrapped with `React.use()` before accessing properties of the underlying params object. In this version of Next.js direct access to param properties is still supported to facilitate migration but in a future version you will be required to unwrap `params` with `React.use()`.&quot;</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">warnForEnumeration(missingProperties) {</span>
    <span class="s1">if </span><span class="s0">(missingProperties.length) {</span>
        <span class="s1">const </span><span class="s0">describedMissingProperties = describeListOfPropertyNames(missingProperties);</span>
        <span class="s0">console.error(</span><span class="s2">&quot;params are being enumerated incompletely missing these properties: &quot; </span><span class="s0">+ describedMissingProperties + </span><span class="s2">&quot;. &quot; </span><span class="s0">+ </span><span class="s2">&quot;`params` should be unwrapped with `React.use()` before using its value. &quot; </span><span class="s0">+ </span><span class="s2">&quot;Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis&quot;</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">console.error(</span><span class="s2">&quot;params are being enumerated. &quot; </span><span class="s0">+ </span><span class="s2">&quot;`params` should be unwrapped with `React.use()` before using its value. &quot; </span><span class="s0">+ </span><span class="s2">&quot;Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis&quot;</span><span class="s0">);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">describeListOfPropertyNames(properties) {</span>
    <span class="s1">switch</span><span class="s0">(properties.length){</span>
        <span class="s1">case </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">_invarianterror.InvariantError(</span><span class="s2">'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
                <span class="s0">value: </span><span class="s2">&quot;E531&quot;</span><span class="s0">,</span>
                <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
                <span class="s0">configurable: </span><span class="s1">true</span>
            <span class="s0">});</span>
        <span class="s1">case </span><span class="s4">1</span><span class="s0">:</span>
            <span class="s1">return </span><span class="s2">&quot;`&quot; </span><span class="s0">+ properties[</span><span class="s4">0</span><span class="s0">] + </span><span class="s2">&quot;`&quot;</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s4">2</span><span class="s0">:</span>
            <span class="s1">return </span><span class="s2">&quot;`&quot; </span><span class="s0">+ properties[</span><span class="s4">0</span><span class="s0">] + </span><span class="s2">&quot;` and `&quot; </span><span class="s0">+ properties[</span><span class="s4">1</span><span class="s0">] + </span><span class="s2">&quot;`&quot;</span><span class="s0">;</span>
        <span class="s1">default</span><span class="s0">:</span>
            <span class="s0">{</span>
                <span class="s1">let </span><span class="s0">description = </span><span class="s2">''</span><span class="s0">;</span>
                <span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; properties.length - </span><span class="s4">1</span><span class="s0">; i++){</span>
                    <span class="s0">description += </span><span class="s2">&quot;`&quot; </span><span class="s0">+ properties[i] + </span><span class="s2">&quot;`, &quot;</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">description += </span><span class="s2">&quot;, and `&quot; </span><span class="s0">+ properties[properties.length - </span><span class="s4">1</span><span class="s0">] + </span><span class="s2">&quot;`&quot;</span><span class="s0">;</span>
                <span class="s1">return </span><span class="s0">description;</span>
            <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createRenderParamsFromClient(clientParams) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
    <span class="s1">return </span><span class="s0">makeDynamicallyTrackedExoticParamsWithDevWarnings(clientParams);</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=params.browser.dev.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/request/params.browser.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;createRenderParamsFromClient&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">createRenderParamsFromClient;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">createRenderParamsFromClient = (</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) ? __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/request/params.browser.dev.js [app-client] (ecmascript)&quot;</span><span class="s0">).createRenderParamsFromClient : </span><span class="s2">&quot;TURBOPACK unreachable&quot;</span><span class="s0">;</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=params.browser.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;createDedupedByCallsiteServerErrorLoggerDev&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">createDedupedByCallsiteServerErrorLoggerDev;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_react = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_interop_require_wildcard(__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)&quot;</span><span class="s0">));</span>
<span class="s1">function </span><span class="s0">_getRequireWildcardCache(nodeInterop) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">WeakMap !== </span><span class="s2">&quot;function&quot;</span><span class="s0">) </span><span class="s1">return null</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">cacheBabelInterop = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
    <span class="s1">var </span><span class="s0">cacheNodeInterop = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
    <span class="s1">return </span><span class="s0">(_getRequireWildcardCache = </span><span class="s1">function</span><span class="s0">(nodeInterop) {</span>
        <span class="s1">return </span><span class="s0">nodeInterop ? cacheNodeInterop : cacheBabelInterop;</span>
    <span class="s0">})(nodeInterop);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">_interop_require_wildcard(obj, nodeInterop) {</span>
    <span class="s1">if </span><span class="s0">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) {</span>
        <span class="s1">return </span><span class="s0">obj;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(obj === </span><span class="s1">null </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">obj !== </span><span class="s2">&quot;object&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">obj !== </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s1">default</span><span class="s0">: obj</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">cache = _getRequireWildcardCache(nodeInterop);</span>
    <span class="s1">if </span><span class="s0">(cache &amp;&amp; cache.has(obj)) {</span>
        <span class="s1">return </span><span class="s0">cache.get(obj);</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">newObj = {</span>
        <span class="s0">__proto__: </span><span class="s1">null</span>
    <span class="s0">};</span>
    <span class="s1">var </span><span class="s0">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor;</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">key </span><span class="s1">in </span><span class="s0">obj){</span>
        <span class="s1">if </span><span class="s0">(key !== </span><span class="s2">&quot;default&quot; </span><span class="s0">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) {</span>
            <span class="s1">var </span><span class="s0">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(desc &amp;&amp; (desc.get || desc.set)) {</span>
                <span class="s0">Object.defineProperty(newObj, key, desc);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">newObj[key] = obj[key];</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">newObj.default = obj;</span>
    <span class="s1">if </span><span class="s0">(cache) {</span>
        <span class="s0">cache.set(obj, newObj);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">newObj;</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">errorRef = {</span>
    <span class="s0">current: </span><span class="s1">null</span>
<span class="s0">};</span>
<span class="s3">// React.cache is currently only available in canary/experimental React channels.</span>
<span class="s1">const </span><span class="s0">cache = </span><span class="s1">typeof </span><span class="s0">_react.cache === </span><span class="s2">'function' </span><span class="s0">? _react.cache : (fn)=&gt;fn;</span>
<span class="s3">// When Cache Components is enabled, we record these as errors so that they</span>
<span class="s3">// are captured by the dev overlay as it's more critical to fix these</span>
<span class="s3">// when enabled.</span>
<span class="s1">const </span><span class="s0">logErrorOrWarn = (</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) ? </span><span class="s2">&quot;TURBOPACK unreachable&quot; </span><span class="s0">: console.warn;</span>
<span class="s3">// We don't want to dedupe across requests.</span>
<span class="s3">// The developer might've just attempted to fix the warning so we should warn again if it still happens.</span>
<span class="s1">const </span><span class="s0">flushCurrentErrorIfNew = cache((key)=&gt;{</span>
    <span class="s1">try </span><span class="s0">{</span>
        <span class="s0">logErrorOrWarn(errorRef.current);</span>
    <span class="s0">} </span><span class="s1">finally</span><span class="s0">{</span>
        <span class="s0">errorRef.current = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">createDedupedByCallsiteServerErrorLoggerDev(getMessage) {</span>
    <span class="s1">return function </span><span class="s0">logDedupedError() {</span>
        <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">_len = arguments.length, args = </span><span class="s1">new </span><span class="s0">Array(_len), _key = </span><span class="s4">0</span><span class="s0">; _key &lt; _len; _key++){</span>
            <span class="s0">args[_key] = arguments[_key];</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">message = getMessage(...args);</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s1">var </span><span class="s0">_stack;</span>
            <span class="s1">const </span><span class="s0">callStackFrames = (_stack = </span><span class="s1">new </span><span class="s0">Error().stack) == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: _stack.split(</span><span class="s2">'</span><span class="s6">\n</span><span class="s2">'</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(callStackFrames === undefined || callStackFrames.length &lt; </span><span class="s4">4</span><span class="s0">) {</span>
                <span class="s0">logErrorOrWarn(message);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s3">// Error:</span>
                <span class="s3">//   logDedupedError</span>
                <span class="s3">//   asyncApiBeingAccessedSynchronously</span>
                <span class="s3">//   &lt;userland callsite&gt;</span>
                <span class="s3">// TODO: This breaks if sourcemaps with ignore lists are enabled.</span>
                <span class="s1">const </span><span class="s0">key = callStackFrames[</span><span class="s4">4</span><span class="s0">];</span>
                <span class="s0">errorRef.current = message;</span>
                <span class="s0">flushCurrentErrorIfNew(key);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s3">//TURBOPACK unreachable</span>
        <span class="s0">;</span>
    <span class="s0">};</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=create-deduped-by-callsite-server-error-logger.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/server/app-render/after-task-async-storage-instance.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;afterTaskAsyncStorageInstance&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">afterTaskAsyncStorageInstance;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_asynclocalstorage = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/app-render/async-local-storage.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">afterTaskAsyncStorageInstance = (</span><span class="s4">0</span><span class="s0">, _asynclocalstorage.createAsyncLocalStorage)(); </span><span class="s3">//# sourceMappingURL=after-task-async-storage-instance.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/server/app-render/after-task-async-storage.external.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;afterTaskAsyncStorage&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">_aftertaskasyncstorageinstance.afterTaskAsyncStorageInstance;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_aftertaskasyncstorageinstance = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/app-render/after-task-async-storage-instance.js [app-client] (ecmascript)&quot;</span><span class="s0">); </span><span class="s3">//# sourceMappingURL=after-task-async-storage.external.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/server/request/utils.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">isRequestAPICallableInsideAfter: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">throwForSearchParamsAccessInUseCache: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">throwWithStaticGenerationBailoutError: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">throwWithStaticGenerationBailoutErrorWithDynamicError: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">isRequestAPICallableInsideAfter: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">isRequestAPICallableInsideAfter;</span>
    <span class="s0">},</span>
    <span class="s0">throwForSearchParamsAccessInUseCache: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">throwForSearchParamsAccessInUseCache;</span>
    <span class="s0">},</span>
    <span class="s0">throwWithStaticGenerationBailoutError: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">throwWithStaticGenerationBailoutError;</span>
    <span class="s0">},</span>
    <span class="s0">throwWithStaticGenerationBailoutErrorWithDynamicError: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">throwWithStaticGenerationBailoutErrorWithDynamicError;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_staticgenerationbailout = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_aftertaskasyncstorageexternal = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/app-render/after-task-async-storage.external.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">throwWithStaticGenerationBailoutError(route, expression) {</span>
    <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">_staticgenerationbailout.StaticGenBailoutError(</span><span class="s2">&quot;Route &quot;</span><span class="s0">.concat(route, </span><span class="s2">&quot; couldn't be rendered statically because it used &quot;</span><span class="s0">).concat(expression, </span><span class="s2">&quot;. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering&quot;</span><span class="s0">)), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s2">&quot;E576&quot;</span><span class="s0">,</span>
        <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">configurable: </span><span class="s1">true</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">throwWithStaticGenerationBailoutErrorWithDynamicError(route, expression) {</span>
    <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">_staticgenerationbailout.StaticGenBailoutError(</span><span class="s2">&quot;Route &quot;</span><span class="s0">.concat(route, </span><span class="s2">' with `dynamic = &quot;error&quot;` couldn</span><span class="s6">\'</span><span class="s2">t be rendered statically because it used '</span><span class="s0">).concat(expression, </span><span class="s2">&quot;. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering&quot;</span><span class="s0">)), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s2">&quot;E543&quot;</span><span class="s0">,</span>
        <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">configurable: </span><span class="s1">true</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">throwForSearchParamsAccessInUseCache(workStore, constructorOpt) {</span>
    <span class="s1">var </span><span class="s0">_workStore;</span>
    <span class="s1">const </span><span class="s0">error = Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">&quot;Route &quot;</span><span class="s0">.concat(workStore.route, </span><span class="s2">' used &quot;searchParams&quot; inside &quot;use cache&quot;. Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await &quot;searchParams&quot; outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache'</span><span class="s0">)), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s2">&quot;E779&quot;</span><span class="s0">,</span>
        <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">configurable: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Error.captureStackTrace(error, constructorOpt);</span>
    <span class="s1">var </span><span class="s0">_invalidDynamicUsageError;</span>
    <span class="s0">(_invalidDynamicUsageError = (_workStore = workStore).invalidDynamicUsageError) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _invalidDynamicUsageError !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _invalidDynamicUsageError : _workStore.invalidDynamicUsageError = error;</span>
    <span class="s1">throw </span><span class="s0">error;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">isRequestAPICallableInsideAfter() {</span>
    <span class="s1">const </span><span class="s0">afterTaskStore = _aftertaskasyncstorageexternal.afterTaskAsyncStorage.getStore();</span>
    <span class="s1">return </span><span class="s0">(afterTaskStore == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: afterTaskStore.rootTaskSpawnPhase) === </span><span class="s2">'action'</span><span class="s0">;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=utils.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/server/request/search-params.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">createPrerenderSearchParamsForClientPage: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">createSearchParamsFromClient: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">createServerSearchParamsForMetadata: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">createServerSearchParamsForServerPage: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">makeErroringSearchParamsForUseCache: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">createPrerenderSearchParamsForClientPage: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">createPrerenderSearchParamsForClientPage;</span>
    <span class="s0">},</span>
    <span class="s0">createSearchParamsFromClient: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">createSearchParamsFromClient;</span>
    <span class="s0">},</span>
    <span class="s0">createServerSearchParamsForMetadata: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">createServerSearchParamsForMetadata;</span>
    <span class="s0">},</span>
    <span class="s0">createServerSearchParamsForServerPage: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">createServerSearchParamsForServerPage;</span>
    <span class="s0">},</span>
    <span class="s0">makeErroringSearchParamsForUseCache: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">makeErroringSearchParamsForUseCache;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_reflect = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_dynamicrendering = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_workunitasyncstorageexternal = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/app-render/work-unit-async-storage.external.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_invarianterror = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_dynamicrenderingutils = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_creatededupedbycallsiteservererrorlogger = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_reflectutils = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/utils/reflect-utils.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_utils = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/request/utils.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">createSearchParamsFromClient(underlyingSearchParams, workStore) {</span>
    <span class="s1">const </span><span class="s0">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
    <span class="s1">if </span><span class="s0">(workUnitStore) {</span>
        <span class="s1">switch</span><span class="s0">(workUnitStore.type){</span>
            <span class="s1">case </span><span class="s2">'prerender'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-client'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-ppr'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-legacy'</span><span class="s0">:</span>
                <span class="s1">return </span><span class="s0">createStaticPrerenderSearchParams(workStore, workUnitStore);</span>
            <span class="s1">case </span><span class="s2">'prerender-runtime'</span><span class="s0">:</span>
                <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">_invarianterror.InvariantError(</span><span class="s2">'createSearchParamsFromClient should not be called in a runtime prerender.'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
                    <span class="s0">value: </span><span class="s2">&quot;E769&quot;</span><span class="s0">,</span>
                    <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
                    <span class="s0">configurable: </span><span class="s1">true</span>
                <span class="s0">});</span>
            <span class="s1">case </span><span class="s2">'cache'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'private-cache'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'unstable-cache'</span><span class="s0">:</span>
                <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">_invarianterror.InvariantError(</span><span class="s2">'createSearchParamsFromClient should not be called in cache contexts.'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
                    <span class="s0">value: </span><span class="s2">&quot;E739&quot;</span><span class="s0">,</span>
                    <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
                    <span class="s0">configurable: </span><span class="s1">true</span>
                <span class="s0">});</span>
            <span class="s1">case </span><span class="s2">'request'</span><span class="s0">:</span>
                <span class="s1">return </span><span class="s0">createRenderSearchParams(underlyingSearchParams, workStore);</span>
            <span class="s1">default</span><span class="s0">:</span>
                <span class="s0">workUnitStore;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _workunitasyncstorageexternal.throwInvariantForMissingStore)();</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">createServerSearchParamsForMetadata = createServerSearchParamsForServerPage;</span>
<span class="s1">function </span><span class="s0">createServerSearchParamsForServerPage(underlyingSearchParams, workStore) {</span>
    <span class="s1">const </span><span class="s0">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
    <span class="s1">if </span><span class="s0">(workUnitStore) {</span>
        <span class="s1">switch</span><span class="s0">(workUnitStore.type){</span>
            <span class="s1">case </span><span class="s2">'prerender'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-client'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-ppr'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-legacy'</span><span class="s0">:</span>
                <span class="s1">return </span><span class="s0">createStaticPrerenderSearchParams(workStore, workUnitStore);</span>
            <span class="s1">case </span><span class="s2">'cache'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'private-cache'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'unstable-cache'</span><span class="s0">:</span>
                <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">_invarianterror.InvariantError(</span><span class="s2">'createServerSearchParamsForServerPage should not be called in cache contexts.'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
                    <span class="s0">value: </span><span class="s2">&quot;E747&quot;</span><span class="s0">,</span>
                    <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
                    <span class="s0">configurable: </span><span class="s1">true</span>
                <span class="s0">});</span>
            <span class="s1">case </span><span class="s2">'prerender-runtime'</span><span class="s0">:</span>
                <span class="s1">return </span><span class="s0">createRuntimePrerenderSearchParams(underlyingSearchParams, workUnitStore);</span>
            <span class="s1">case </span><span class="s2">'request'</span><span class="s0">:</span>
                <span class="s1">return </span><span class="s0">createRenderSearchParams(underlyingSearchParams, workStore);</span>
            <span class="s1">default</span><span class="s0">:</span>
                <span class="s0">workUnitStore;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _workunitasyncstorageexternal.throwInvariantForMissingStore)();</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createPrerenderSearchParamsForClientPage(workStore) {</span>
    <span class="s1">if </span><span class="s0">(workStore.forceStatic) {</span>
        <span class="s3">// When using forceStatic we override all other logic and always just return an empty</span>
        <span class="s3">// dictionary object.</span>
        <span class="s1">return </span><span class="s0">Promise.resolve({});</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
    <span class="s1">if </span><span class="s0">(workUnitStore) {</span>
        <span class="s1">switch</span><span class="s0">(workUnitStore.type){</span>
            <span class="s1">case </span><span class="s2">'prerender'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-client'</span><span class="s0">:</span>
                <span class="s3">// We're prerendering in a mode that aborts (cacheComponents) and should stall</span>
                <span class="s3">// the promise to ensure the RSC side is considered dynamic</span>
                <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, </span><span class="s2">'`searchParams`'</span><span class="s0">);</span>
            <span class="s1">case </span><span class="s2">'prerender-runtime'</span><span class="s0">:</span>
                <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">_invarianterror.InvariantError(</span><span class="s2">'createPrerenderSearchParamsForClientPage should not be called in a runtime prerender.'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
                    <span class="s0">value: </span><span class="s2">&quot;E768&quot;</span><span class="s0">,</span>
                    <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
                    <span class="s0">configurable: </span><span class="s1">true</span>
                <span class="s0">});</span>
            <span class="s1">case </span><span class="s2">'cache'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'private-cache'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'unstable-cache'</span><span class="s0">:</span>
                <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">_invarianterror.InvariantError(</span><span class="s2">'createPrerenderSearchParamsForClientPage should not be called in cache contexts.'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
                    <span class="s0">value: </span><span class="s2">&quot;E746&quot;</span><span class="s0">,</span>
                    <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
                    <span class="s0">configurable: </span><span class="s1">true</span>
                <span class="s0">});</span>
            <span class="s1">case </span><span class="s2">'prerender-ppr'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-legacy'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'request'</span><span class="s0">:</span>
                <span class="s1">return </span><span class="s0">Promise.resolve({});</span>
            <span class="s1">default</span><span class="s0">:</span>
                <span class="s0">workUnitStore;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _workunitasyncstorageexternal.throwInvariantForMissingStore)();</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createStaticPrerenderSearchParams(workStore, prerenderStore) {</span>
    <span class="s1">if </span><span class="s0">(workStore.forceStatic) {</span>
        <span class="s3">// When using forceStatic we override all other logic and always just return an empty</span>
        <span class="s3">// dictionary object.</span>
        <span class="s1">return </span><span class="s0">Promise.resolve({});</span>
    <span class="s0">}</span>
    <span class="s1">switch</span><span class="s0">(prerenderStore.type){</span>
        <span class="s1">case </span><span class="s2">'prerender'</span><span class="s0">:</span>
        <span class="s1">case </span><span class="s2">'prerender-client'</span><span class="s0">:</span>
            <span class="s3">// We are in a cacheComponents (PPR or otherwise) prerender</span>
            <span class="s1">return </span><span class="s0">makeHangingSearchParams(workStore, prerenderStore);</span>
        <span class="s1">case </span><span class="s2">'prerender-ppr'</span><span class="s0">:</span>
        <span class="s1">case </span><span class="s2">'prerender-legacy'</span><span class="s0">:</span>
            <span class="s3">// We are in a legacy static generation and need to interrupt the</span>
            <span class="s3">// prerender when search params are accessed.</span>
            <span class="s1">return </span><span class="s0">makeErroringExoticSearchParams(workStore, prerenderStore);</span>
        <span class="s1">default</span><span class="s0">:</span>
            <span class="s1">return </span><span class="s0">prerenderStore;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createRuntimePrerenderSearchParams(underlyingSearchParams, workUnitStore) {</span>
    <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _dynamicrendering.delayUntilRuntimeStage)(workUnitStore, (</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) ? </span><span class="s2">&quot;TURBOPACK unreachable&quot; </span><span class="s0">: makeUntrackedExoticSearchParams(underlyingSearchParams));</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createRenderSearchParams(underlyingSearchParams, workStore) {</span>
    <span class="s1">if </span><span class="s0">(workStore.forceStatic) {</span>
        <span class="s3">// When using forceStatic we override all other logic and always just return an empty</span>
        <span class="s3">// dictionary object.</span>
        <span class="s1">return </span><span class="s0">Promise.resolve({});</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s3">// Semantically we only need the dev tracking when running in `next dev`</span>
            <span class="s3">// but since you would never use next dev with production NODE_ENV we use this</span>
            <span class="s3">// as a proxy so we can statically exclude this code from production builds.</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
            <span class="s0">;</span>
            <span class="s1">return </span><span class="s0">makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams, workStore);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s3">//TURBOPACK unreachable</span>
        <span class="s0">;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">CachedSearchParams = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
<span class="s1">const </span><span class="s0">CachedSearchParamsForUseCache = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
<span class="s1">function </span><span class="s0">makeHangingSearchParams(workStore, prerenderStore) {</span>
    <span class="s1">const </span><span class="s0">cachedSearchParams = CachedSearchParams.get(prerenderStore);</span>
    <span class="s1">if </span><span class="s0">(cachedSearchParams) {</span>
        <span class="s1">return </span><span class="s0">cachedSearchParams;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">promise = (</span><span class="s4">0</span><span class="s0">, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, workStore.route, </span><span class="s2">'`searchParams`'</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">proxiedPromise = </span><span class="s1">new </span><span class="s0">Proxy(promise, {</span>
        <span class="s0">get (target, prop, receiver) {</span>
            <span class="s1">if </span><span class="s0">(Object.hasOwn(promise, prop)) {</span>
                <span class="s3">// The promise has this property directly. we must return it.</span>
                <span class="s3">// We know it isn't a dynamic access because it can only be something</span>
                <span class="s3">// that was previously written to the promise and thus not an underlying searchParam value</span>
                <span class="s1">return </span><span class="s0">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
            <span class="s0">}</span>
            <span class="s1">switch</span><span class="s0">(prop){</span>
                <span class="s1">case </span><span class="s2">'then'</span><span class="s0">:</span>
                    <span class="s0">{</span>
                        <span class="s1">const </span><span class="s0">expression = </span><span class="s2">'`await searchParams`, `searchParams.then`, or similar'</span><span class="s0">;</span>
                        <span class="s0">(</span><span class="s4">0</span><span class="s0">, _dynamicrendering.annotateDynamicAccess)(expression, prerenderStore);</span>
                        <span class="s1">return </span><span class="s0">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
                    <span class="s0">}</span>
                <span class="s1">case </span><span class="s2">'status'</span><span class="s0">:</span>
                    <span class="s0">{</span>
                        <span class="s1">const </span><span class="s0">expression = </span><span class="s2">'`use(searchParams)`, `searchParams.status`, or similar'</span><span class="s0">;</span>
                        <span class="s0">(</span><span class="s4">0</span><span class="s0">, _dynamicrendering.annotateDynamicAccess)(expression, prerenderStore);</span>
                        <span class="s1">return </span><span class="s0">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
                    <span class="s0">}</span>
                <span class="s1">default</span><span class="s0">:</span>
                    <span class="s0">{</span>
                        <span class="s1">return </span><span class="s0">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
                    <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">CachedSearchParams.set(prerenderStore, proxiedPromise);</span>
    <span class="s1">return </span><span class="s0">proxiedPromise;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">makeErroringExoticSearchParams(workStore, prerenderStore) {</span>
    <span class="s1">const </span><span class="s0">cachedSearchParams = CachedSearchParams.get(workStore);</span>
    <span class="s1">if </span><span class="s0">(cachedSearchParams) {</span>
        <span class="s1">return </span><span class="s0">cachedSearchParams;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">underlyingSearchParams = {};</span>
    <span class="s3">// For search params we don't construct a ReactPromise because we want to interrupt</span>
    <span class="s3">// rendering on any property access that was not set from outside and so we only want</span>
    <span class="s3">// to have properties like value and status if React sets them.</span>
    <span class="s1">const </span><span class="s0">promise = Promise.resolve(underlyingSearchParams);</span>
    <span class="s1">const </span><span class="s0">proxiedPromise = </span><span class="s1">new </span><span class="s0">Proxy(promise, {</span>
        <span class="s0">get (target, prop, receiver) {</span>
            <span class="s1">if </span><span class="s0">(Object.hasOwn(promise, prop)) {</span>
                <span class="s3">// The promise has this property directly. we must return it.</span>
                <span class="s3">// We know it isn't a dynamic access because it can only be something</span>
                <span class="s3">// that was previously written to the promise and thus not an underlying searchParam value</span>
                <span class="s1">return </span><span class="s0">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
            <span class="s0">}</span>
            <span class="s1">switch</span><span class="s0">(prop){</span>
                <span class="s1">case </span><span class="s2">'then'</span><span class="s0">:</span>
                    <span class="s0">{</span>
                        <span class="s1">const </span><span class="s0">expression = </span><span class="s2">'`await searchParams`, `searchParams.then`, or similar'</span><span class="s0">;</span>
                        <span class="s1">if </span><span class="s0">(workStore.dynamicShouldError) {</span>
                            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);</span>
                        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(prerenderStore.type === </span><span class="s2">'prerender-ppr'</span><span class="s0">) {</span>
                            <span class="s3">// PPR Prerender (no cacheComponents)</span>
                            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);</span>
                        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                            <span class="s3">// Legacy Prerender</span>
                            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);</span>
                        <span class="s0">}</span>
                        <span class="s1">return</span><span class="s0">;</span>
                    <span class="s0">}</span>
                <span class="s1">case </span><span class="s2">'status'</span><span class="s0">:</span>
                    <span class="s0">{</span>
                        <span class="s1">const </span><span class="s0">expression = </span><span class="s2">'`use(searchParams)`, `searchParams.status`, or similar'</span><span class="s0">;</span>
                        <span class="s1">if </span><span class="s0">(workStore.dynamicShouldError) {</span>
                            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);</span>
                        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(prerenderStore.type === </span><span class="s2">'prerender-ppr'</span><span class="s0">) {</span>
                            <span class="s3">// PPR Prerender (no cacheComponents)</span>
                            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);</span>
                        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                            <span class="s3">// Legacy Prerender</span>
                            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);</span>
                        <span class="s0">}</span>
                        <span class="s1">return</span><span class="s0">;</span>
                    <span class="s0">}</span>
                <span class="s1">default</span><span class="s0">:</span>
                    <span class="s0">{</span>
                        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string' </span><span class="s0">&amp;&amp; !_reflectutils.wellKnownProperties.has(prop)) {</span>
                            <span class="s1">const </span><span class="s0">expression = (</span><span class="s4">0</span><span class="s0">, _reflectutils.describeStringPropertyAccess)(</span><span class="s2">'searchParams'</span><span class="s0">, prop);</span>
                            <span class="s1">if </span><span class="s0">(workStore.dynamicShouldError) {</span>
                                <span class="s0">(</span><span class="s4">0</span><span class="s0">, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);</span>
                            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(prerenderStore.type === </span><span class="s2">'prerender-ppr'</span><span class="s0">) {</span>
                                <span class="s3">// PPR Prerender (no cacheComponents)</span>
                                <span class="s0">(</span><span class="s4">0</span><span class="s0">, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);</span>
                            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                                <span class="s3">// Legacy Prerender</span>
                                <span class="s0">(</span><span class="s4">0</span><span class="s0">, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);</span>
                            <span class="s0">}</span>
                        <span class="s0">}</span>
                        <span class="s1">return </span><span class="s0">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
                    <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">},</span>
        <span class="s0">has (target, prop) {</span>
            <span class="s3">// We don't expect key checking to be used except for testing the existence of</span>
            <span class="s3">// searchParams so we make all has tests trigger dynamic. this means that `promise.then`</span>
            <span class="s3">// can resolve to the then function on the Promise prototype but 'then' in promise will assume</span>
            <span class="s3">// you are testing whether the searchParams has a 'then' property.</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s1">const </span><span class="s0">expression = (</span><span class="s4">0</span><span class="s0">, _reflectutils.describeHasCheckingStringProperty)(</span><span class="s2">'searchParams'</span><span class="s0">, prop);</span>
                <span class="s1">if </span><span class="s0">(workStore.dynamicShouldError) {</span>
                    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(prerenderStore.type === </span><span class="s2">'prerender-ppr'</span><span class="s0">) {</span>
                    <span class="s3">// PPR Prerender (no cacheComponents)</span>
                    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s3">// Legacy Prerender</span>
                    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);</span>
                <span class="s0">}</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">_reflect.ReflectAdapter.has(target, prop);</span>
        <span class="s0">},</span>
        <span class="s0">ownKeys () {</span>
            <span class="s1">const </span><span class="s0">expression = </span><span class="s2">'`{...searchParams}`, `Object.keys(searchParams)`, or similar'</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(workStore.dynamicShouldError) {</span>
                <span class="s0">(</span><span class="s4">0</span><span class="s0">, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(prerenderStore.type === </span><span class="s2">'prerender-ppr'</span><span class="s0">) {</span>
                <span class="s3">// PPR Prerender (no cacheComponents)</span>
                <span class="s0">(</span><span class="s4">0</span><span class="s0">, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s3">// Legacy Prerender</span>
                <span class="s0">(</span><span class="s4">0</span><span class="s0">, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">CachedSearchParams.set(workStore, proxiedPromise);</span>
    <span class="s1">return </span><span class="s0">proxiedPromise;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">makeErroringSearchParamsForUseCache(workStore) {</span>
    <span class="s1">const </span><span class="s0">cachedSearchParams = CachedSearchParamsForUseCache.get(workStore);</span>
    <span class="s1">if </span><span class="s0">(cachedSearchParams) {</span>
        <span class="s1">return </span><span class="s0">cachedSearchParams;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">promise = Promise.resolve({});</span>
    <span class="s1">const </span><span class="s0">proxiedPromise = </span><span class="s1">new </span><span class="s0">Proxy(promise, {</span>
        <span class="s0">get: </span><span class="s1">function </span><span class="s0">get(target, prop, receiver) {</span>
            <span class="s1">if </span><span class="s0">(Object.hasOwn(promise, prop)) {</span>
                <span class="s3">// The promise has this property directly. we must return it. We know it</span>
                <span class="s3">// isn't a dynamic access because it can only be something that was</span>
                <span class="s3">// previously written to the promise and thus not an underlying</span>
                <span class="s3">// searchParam value</span>
                <span class="s1">return </span><span class="s0">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string' </span><span class="s0">&amp;&amp; (prop === </span><span class="s2">'then' </span><span class="s0">|| !_reflectutils.wellKnownProperties.has(prop))) {</span>
                <span class="s0">(</span><span class="s4">0</span><span class="s0">, _utils.throwForSearchParamsAccessInUseCache)(workStore, get);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
        <span class="s0">},</span>
        <span class="s0">has: </span><span class="s1">function </span><span class="s0">has(target, prop) {</span>
            <span class="s3">// We don't expect key checking to be used except for testing the existence of</span>
            <span class="s3">// searchParams so we make all has tests throw an error. this means that `promise.then`</span>
            <span class="s3">// can resolve to the then function on the Promise prototype but 'then' in promise will assume</span>
            <span class="s3">// you are testing whether the searchParams has a 'then' property.</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string' </span><span class="s0">&amp;&amp; (prop === </span><span class="s2">'then' </span><span class="s0">|| !_reflectutils.wellKnownProperties.has(prop))) {</span>
                <span class="s0">(</span><span class="s4">0</span><span class="s0">, _utils.throwForSearchParamsAccessInUseCache)(workStore, has);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">_reflect.ReflectAdapter.has(target, prop);</span>
        <span class="s0">},</span>
        <span class="s0">ownKeys: </span><span class="s1">function </span><span class="s0">ownKeys() {</span>
            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _utils.throwForSearchParamsAccessInUseCache)(workStore, ownKeys);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">CachedSearchParamsForUseCache.set(workStore, proxiedPromise);</span>
    <span class="s1">return </span><span class="s0">proxiedPromise;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">makeUntrackedExoticSearchParams(underlyingSearchParams) {</span>
    <span class="s1">const </span><span class="s0">cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);</span>
    <span class="s1">if </span><span class="s0">(cachedSearchParams) {</span>
        <span class="s1">return </span><span class="s0">cachedSearchParams;</span>
    <span class="s0">}</span>
    <span class="s3">// We don't use makeResolvedReactPromise here because searchParams</span>
    <span class="s3">// supports copying with spread and we don't want to unnecessarily</span>
    <span class="s3">// instrument the promise with spreadable properties of ReactPromise.</span>
    <span class="s1">const </span><span class="s0">promise = Promise.resolve(underlyingSearchParams);</span>
    <span class="s0">CachedSearchParams.set(underlyingSearchParams, promise);</span>
    <span class="s0">Object.keys(underlyingSearchParams).forEach((prop)=&gt;{</span>
        <span class="s1">if </span><span class="s0">(!_reflectutils.wellKnownProperties.has(prop)) {</span>
            <span class="s0">Object.defineProperty(promise, prop, {</span>
                <span class="s0">get () {</span>
                    <span class="s1">const </span><span class="s0">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
                    <span class="s1">if </span><span class="s0">(workUnitStore) {</span>
                        <span class="s0">(</span><span class="s4">0</span><span class="s0">, _dynamicrendering.trackDynamicDataInDynamicRender)(workUnitStore);</span>
                    <span class="s0">}</span>
                    <span class="s1">return </span><span class="s0">underlyingSearchParams[prop];</span>
                <span class="s0">},</span>
                <span class="s0">set (value) {</span>
                    <span class="s0">Object.defineProperty(promise, prop, {</span>
                        <span class="s0">value,</span>
                        <span class="s0">writable: </span><span class="s1">true</span><span class="s0">,</span>
                        <span class="s0">enumerable: </span><span class="s1">true</span>
                    <span class="s0">});</span>
                <span class="s0">},</span>
                <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
                <span class="s0">configurable: </span><span class="s1">true</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">promise;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">makeUntrackedSearchParams(underlyingSearchParams) {</span>
    <span class="s1">const </span><span class="s0">cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);</span>
    <span class="s1">if </span><span class="s0">(cachedSearchParams) {</span>
        <span class="s1">return </span><span class="s0">cachedSearchParams;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">promise = Promise.resolve(underlyingSearchParams);</span>
    <span class="s0">CachedSearchParams.set(underlyingSearchParams, promise);</span>
    <span class="s1">return </span><span class="s0">promise;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams, store) {</span>
    <span class="s1">const </span><span class="s0">cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);</span>
    <span class="s1">if </span><span class="s0">(cachedSearchParams) {</span>
        <span class="s1">return </span><span class="s0">cachedSearchParams;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">proxiedProperties = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s1">const </span><span class="s0">unproxiedProperties = [];</span>
    <span class="s3">// We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying</span>
    <span class="s3">// searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender</span>
    <span class="s3">// indicator. However when we pass this proxy to our Promise.resolve() below the VM checks if the resolved value is a promise by looking</span>
    <span class="s3">// at the `.then` property. To our dynamic tracking logic this is indistinguishable from a `then` searchParam and so we would normally trigger</span>
    <span class="s3">// dynamic tracking. However we know that this .then is not real dynamic access, it's just how thenables resolve in sequence. So we introduce</span>
    <span class="s3">// this initialization concept so we omit the dynamic check until after we've constructed our resolved promise.</span>
    <span class="s1">let </span><span class="s0">promiseInitialized = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">proxiedUnderlying = </span><span class="s1">new </span><span class="s0">Proxy(underlyingSearchParams, {</span>
        <span class="s0">get (target, prop, receiver) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string' </span><span class="s0">&amp;&amp; promiseInitialized) {</span>
                <span class="s1">if </span><span class="s0">(store.dynamicShouldError) {</span>
                    <span class="s1">const </span><span class="s0">expression = (</span><span class="s4">0</span><span class="s0">, _reflectutils.describeStringPropertyAccess)(</span><span class="s2">'searchParams'</span><span class="s0">, prop);</span>
                    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
                <span class="s1">if </span><span class="s0">(workUnitStore) {</span>
                    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _dynamicrendering.trackDynamicDataInDynamicRender)(workUnitStore);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
        <span class="s0">},</span>
        <span class="s0">has (target, prop) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(store.dynamicShouldError) {</span>
                    <span class="s1">const </span><span class="s0">expression = (</span><span class="s4">0</span><span class="s0">, _reflectutils.describeHasCheckingStringProperty)(</span><span class="s2">'searchParams'</span><span class="s0">, prop);</span>
                    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">Reflect.has(target, prop);</span>
        <span class="s0">},</span>
        <span class="s0">ownKeys (target) {</span>
            <span class="s1">if </span><span class="s0">(store.dynamicShouldError) {</span>
                <span class="s1">const </span><span class="s0">expression = </span><span class="s2">'`{...searchParams}`, `Object.keys(searchParams)`, or similar'</span><span class="s0">;</span>
                <span class="s0">(</span><span class="s4">0</span><span class="s0">, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">Reflect.ownKeys(target);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s3">// We don't use makeResolvedReactPromise here because searchParams</span>
    <span class="s3">// supports copying with spread and we don't want to unnecessarily</span>
    <span class="s3">// instrument the promise with spreadable properties of ReactPromise.</span>
    <span class="s1">const </span><span class="s0">promise = (</span><span class="s4">0</span><span class="s0">, _dynamicrenderingutils.makeDevtoolsIOAwarePromise)(underlyingSearchParams);</span>
    <span class="s0">promise.then(()=&gt;{</span>
        <span class="s0">promiseInitialized = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">});</span>
    <span class="s0">Object.keys(underlyingSearchParams).forEach((prop)=&gt;{</span>
        <span class="s1">if </span><span class="s0">(_reflectutils.wellKnownProperties.has(prop)) {</span>
            <span class="s3">// These properties cannot be shadowed because they need to be the</span>
            <span class="s3">// true underlying value for Promises to work correctly at runtime</span>
            <span class="s0">unproxiedProperties.push(prop);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">proxiedProperties.add(prop);</span>
            <span class="s0">Object.defineProperty(promise, prop, {</span>
                <span class="s0">get () {</span>
                    <span class="s1">return </span><span class="s0">proxiedUnderlying[prop];</span>
                <span class="s0">},</span>
                <span class="s0">set (newValue) {</span>
                    <span class="s0">Object.defineProperty(promise, prop, {</span>
                        <span class="s0">value: newValue,</span>
                        <span class="s0">writable: </span><span class="s1">true</span><span class="s0">,</span>
                        <span class="s0">enumerable: </span><span class="s1">true</span>
                    <span class="s0">});</span>
                <span class="s0">},</span>
                <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
                <span class="s0">configurable: </span><span class="s1">true</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s1">const </span><span class="s0">proxiedPromise = </span><span class="s1">new </span><span class="s0">Proxy(promise, {</span>
        <span class="s0">get (target, prop, receiver) {</span>
            <span class="s1">if </span><span class="s0">(prop === </span><span class="s2">'then' </span><span class="s0">&amp;&amp; store.dynamicShouldError) {</span>
                <span class="s1">const </span><span class="s0">expression = </span><span class="s2">'`searchParams.then`'</span><span class="s0">;</span>
                <span class="s0">(</span><span class="s4">0</span><span class="s0">, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(!_reflectutils.wellKnownProperties.has(prop) &amp;&amp; (proxiedProperties.has(prop) || </span><span class="s3">// We are accessing a property that doesn't exist on the promise nor</span>
                <span class="s3">// the underlying searchParams.</span>
                <span class="s0">Reflect.has(target, prop) === </span><span class="s1">false</span><span class="s0">)) {</span>
                    <span class="s1">const </span><span class="s0">expression = (</span><span class="s4">0</span><span class="s0">, _reflectutils.describeStringPropertyAccess)(</span><span class="s2">'searchParams'</span><span class="s0">, prop);</span>
                    <span class="s0">syncIODev(store.route, expression);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
        <span class="s0">},</span>
        <span class="s0">set (target, prop, value, receiver) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s0">proxiedProperties.delete(prop);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">Reflect.set(target, prop, value, receiver);</span>
        <span class="s0">},</span>
        <span class="s0">has (target, prop) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(!_reflectutils.wellKnownProperties.has(prop) &amp;&amp; (proxiedProperties.has(prop) || </span><span class="s3">// We are accessing a property that doesn't exist on the promise nor</span>
                <span class="s3">// the underlying searchParams.</span>
                <span class="s0">Reflect.has(target, prop) === </span><span class="s1">false</span><span class="s0">)) {</span>
                    <span class="s1">const </span><span class="s0">expression = (</span><span class="s4">0</span><span class="s0">, _reflectutils.describeHasCheckingStringProperty)(</span><span class="s2">'searchParams'</span><span class="s0">, prop);</span>
                    <span class="s0">syncIODev(store.route, expression);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">Reflect.has(target, prop);</span>
        <span class="s0">},</span>
        <span class="s0">ownKeys (target) {</span>
            <span class="s1">const </span><span class="s0">expression = </span><span class="s2">'`Object.keys(searchParams)` or similar'</span><span class="s0">;</span>
            <span class="s0">syncIODev(store.route, expression, unproxiedProperties);</span>
            <span class="s1">return </span><span class="s0">Reflect.ownKeys(target);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">CachedSearchParams.set(underlyingSearchParams, proxiedPromise);</span>
    <span class="s1">return </span><span class="s0">proxiedPromise;</span>
<span class="s0">}</span>
<span class="s3">// Similar to `makeDynamicallyTrackedExoticSearchParamsWithDevWarnings`, but</span>
<span class="s3">// just logging the sync access without actually defining the search params on</span>
<span class="s3">// the promise.</span>
<span class="s1">function </span><span class="s0">makeUntrackedSearchParamsWithDevWarnings(underlyingSearchParams, store) {</span>
    <span class="s1">const </span><span class="s0">cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);</span>
    <span class="s1">if </span><span class="s0">(cachedSearchParams) {</span>
        <span class="s1">return </span><span class="s0">cachedSearchParams;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">proxiedProperties = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s1">const </span><span class="s0">unproxiedProperties = [];</span>
    <span class="s1">const </span><span class="s0">promise = (</span><span class="s4">0</span><span class="s0">, _dynamicrenderingutils.makeDevtoolsIOAwarePromise)(underlyingSearchParams);</span>
    <span class="s0">Object.keys(underlyingSearchParams).forEach((prop)=&gt;{</span>
        <span class="s1">if </span><span class="s0">(_reflectutils.wellKnownProperties.has(prop)) {</span>
            <span class="s3">// These properties cannot be shadowed because they need to be the</span>
            <span class="s3">// true underlying value for Promises to work correctly at runtime</span>
            <span class="s0">unproxiedProperties.push(prop);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">proxiedProperties.add(prop);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s1">const </span><span class="s0">proxiedPromise = </span><span class="s1">new </span><span class="s0">Proxy(promise, {</span>
        <span class="s0">get (target, prop, receiver) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(!_reflectutils.wellKnownProperties.has(prop) &amp;&amp; (proxiedProperties.has(prop) || </span><span class="s3">// We are accessing a property that doesn't exist on the promise nor</span>
                <span class="s3">// the underlying searchParams.</span>
                <span class="s0">Reflect.has(target, prop) === </span><span class="s1">false</span><span class="s0">)) {</span>
                    <span class="s1">const </span><span class="s0">expression = (</span><span class="s4">0</span><span class="s0">, _reflectutils.describeStringPropertyAccess)(</span><span class="s2">'searchParams'</span><span class="s0">, prop);</span>
                    <span class="s0">warnForSyncAccess(store.route, expression);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
        <span class="s0">},</span>
        <span class="s0">set (target, prop, value, receiver) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s0">proxiedProperties.delete(prop);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">Reflect.set(target, prop, value, receiver);</span>
        <span class="s0">},</span>
        <span class="s0">has (target, prop) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(!_reflectutils.wellKnownProperties.has(prop) &amp;&amp; (proxiedProperties.has(prop) || </span><span class="s3">// We are accessing a property that doesn't exist on the promise nor</span>
                <span class="s3">// the underlying searchParams.</span>
                <span class="s0">Reflect.has(target, prop) === </span><span class="s1">false</span><span class="s0">)) {</span>
                    <span class="s1">const </span><span class="s0">expression = (</span><span class="s4">0</span><span class="s0">, _reflectutils.describeHasCheckingStringProperty)(</span><span class="s2">'searchParams'</span><span class="s0">, prop);</span>
                    <span class="s0">warnForSyncAccess(store.route, expression);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">Reflect.has(target, prop);</span>
        <span class="s0">},</span>
        <span class="s0">ownKeys (target) {</span>
            <span class="s1">const </span><span class="s0">expression = </span><span class="s2">'`Object.keys(searchParams)` or similar'</span><span class="s0">;</span>
            <span class="s0">warnForIncompleteEnumeration(store.route, expression, unproxiedProperties);</span>
            <span class="s1">return </span><span class="s0">Reflect.ownKeys(target);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">CachedSearchParams.set(underlyingSearchParams, proxiedPromise);</span>
    <span class="s1">return </span><span class="s0">proxiedPromise;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">syncIODev(route, expression, missingProperties) {</span>
    <span class="s3">// In all cases we warn normally</span>
    <span class="s1">if </span><span class="s0">(missingProperties &amp;&amp; missingProperties.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s0">warnForIncompleteEnumeration(route, expression, missingProperties);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">warnForSyncAccess(route, expression);</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
    <span class="s1">if </span><span class="s0">(workUnitStore) {</span>
        <span class="s1">switch</span><span class="s0">(workUnitStore.type){</span>
            <span class="s1">case </span><span class="s2">'request'</span><span class="s0">:</span>
                <span class="s1">if </span><span class="s0">(workUnitStore.prerenderPhase === </span><span class="s1">true</span><span class="s0">) {</span>
                    <span class="s3">// When we're rendering dynamically in dev, we need to advance out of</span>
                    <span class="s3">// the Prerender environment when we read Request data synchronously.</span>
                    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(workUnitStore);</span>
                <span class="s0">}</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s2">'prerender'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-client'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-runtime'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-ppr'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-legacy'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'cache'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'private-cache'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'unstable-cache'</span><span class="s0">:</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s1">default</span><span class="s0">:</span>
                <span class="s0">workUnitStore;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">warnForSyncAccess = (</span><span class="s4">0</span><span class="s0">, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createSearchAccessError);</span>
<span class="s1">const </span><span class="s0">warnForIncompleteEnumeration = (</span><span class="s4">0</span><span class="s0">, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createIncompleteEnumerationError);</span>
<span class="s1">function </span><span class="s0">createSearchAccessError(route, expression) {</span>
    <span class="s1">const </span><span class="s0">prefix = route ? </span><span class="s2">'Route &quot;'</span><span class="s0">.concat(route, </span><span class="s2">'&quot; '</span><span class="s0">) : </span><span class="s2">'This route '</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">&quot;&quot;</span><span class="s0">.concat(prefix, </span><span class="s2">&quot;used &quot;</span><span class="s0">).concat(expression, </span><span class="s2">&quot;. &quot;</span><span class="s0">) + </span><span class="s2">&quot;`searchParams` should be awaited before using its properties. &quot; </span><span class="s0">+ </span><span class="s2">&quot;Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis&quot;</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s2">&quot;E249&quot;</span><span class="s0">,</span>
        <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">configurable: </span><span class="s1">true</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createIncompleteEnumerationError(route, expression, missingProperties) {</span>
    <span class="s1">const </span><span class="s0">prefix = route ? </span><span class="s2">'Route &quot;'</span><span class="s0">.concat(route, </span><span class="s2">'&quot; '</span><span class="s0">) : </span><span class="s2">'This route '</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">&quot;&quot;</span><span class="s0">.concat(prefix, </span><span class="s2">&quot;used &quot;</span><span class="s0">).concat(expression, </span><span class="s2">&quot;. &quot;</span><span class="s0">) + </span><span class="s2">&quot;`searchParams` should be awaited before using its properties. &quot; </span><span class="s0">+ </span><span class="s2">&quot;The following properties were not available through enumeration &quot; </span><span class="s0">+ </span><span class="s2">&quot;because they conflict with builtin or well-known property names: &quot; </span><span class="s0">+ </span><span class="s2">&quot;&quot;</span><span class="s0">.concat(describeListOfPropertyNames(missingProperties), </span><span class="s2">&quot;. &quot;</span><span class="s0">) + </span><span class="s2">&quot;Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis&quot;</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s2">&quot;E2&quot;</span><span class="s0">,</span>
        <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">configurable: </span><span class="s1">true</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">describeListOfPropertyNames(properties) {</span>
    <span class="s1">switch</span><span class="s0">(properties.length){</span>
        <span class="s1">case </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">_invarianterror.InvariantError(</span><span class="s2">'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
                <span class="s0">value: </span><span class="s2">&quot;E531&quot;</span><span class="s0">,</span>
                <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
                <span class="s0">configurable: </span><span class="s1">true</span>
            <span class="s0">});</span>
        <span class="s1">case </span><span class="s4">1</span><span class="s0">:</span>
            <span class="s1">return </span><span class="s2">&quot;`&quot;</span><span class="s0">.concat(properties[</span><span class="s4">0</span><span class="s0">], </span><span class="s2">&quot;`&quot;</span><span class="s0">);</span>
        <span class="s1">case </span><span class="s4">2</span><span class="s0">:</span>
            <span class="s1">return </span><span class="s2">&quot;`&quot;</span><span class="s0">.concat(properties[</span><span class="s4">0</span><span class="s0">], </span><span class="s2">&quot;` and `&quot;</span><span class="s0">).concat(properties[</span><span class="s4">1</span><span class="s0">], </span><span class="s2">&quot;`&quot;</span><span class="s0">);</span>
        <span class="s1">default</span><span class="s0">:</span>
            <span class="s0">{</span>
                <span class="s1">let </span><span class="s0">description = </span><span class="s2">''</span><span class="s0">;</span>
                <span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; properties.length - </span><span class="s4">1</span><span class="s0">; i++){</span>
                    <span class="s0">description += </span><span class="s2">&quot;`&quot;</span><span class="s0">.concat(properties[i], </span><span class="s2">&quot;`, &quot;</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s0">description += </span><span class="s2">&quot;, and `&quot;</span><span class="s0">.concat(properties[properties.length - </span><span class="s4">1</span><span class="s0">], </span><span class="s2">&quot;`&quot;</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s0">description;</span>
            <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=search-params.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/server/app-render/dynamic-access-async-storage-instance.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;dynamicAccessAsyncStorageInstance&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">dynamicAccessAsyncStorageInstance;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_asynclocalstorage = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/app-render/async-local-storage.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">dynamicAccessAsyncStorageInstance = (</span><span class="s4">0</span><span class="s0">, _asynclocalstorage.createAsyncLocalStorage)(); </span><span class="s3">//# sourceMappingURL=dynamic-access-async-storage-instance.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/server/app-render/dynamic-access-async-storage.external.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;dynamicAccessAsyncStorage&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">_dynamicaccessasyncstorageinstance.dynamicAccessAsyncStorageInstance;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_dynamicaccessasyncstorageinstance = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/app-render/dynamic-access-async-storage-instance.js [app-client] (ecmascript)&quot;</span><span class="s0">); </span><span class="s3">//# sourceMappingURL=dynamic-access-async-storage.external.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/server/request/params.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">createParamsFromClient: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">createPrerenderParamsForClientSegment: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">createServerParamsForMetadata: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">createServerParamsForRoute: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">createServerParamsForServerSegment: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">createParamsFromClient: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">createParamsFromClient;</span>
    <span class="s0">},</span>
    <span class="s0">createPrerenderParamsForClientSegment: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">createPrerenderParamsForClientSegment;</span>
    <span class="s0">},</span>
    <span class="s0">createServerParamsForMetadata: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">createServerParamsForMetadata;</span>
    <span class="s0">},</span>
    <span class="s0">createServerParamsForRoute: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">createServerParamsForRoute;</span>
    <span class="s0">},</span>
    <span class="s0">createServerParamsForServerSegment: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">createServerParamsForServerSegment;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_workasyncstorageexternal = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/app-render/work-async-storage.external.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_reflect = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_dynamicrendering = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_workunitasyncstorageexternal = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/app-render/work-unit-async-storage.external.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_invarianterror = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_reflectutils = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/utils/reflect-utils.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_dynamicrenderingutils = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_creatededupedbycallsiteservererrorlogger = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_dynamicaccessasyncstorageexternal = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/app-render/dynamic-access-async-storage.external.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">createParamsFromClient(underlyingParams, workStore) {</span>
    <span class="s1">const </span><span class="s0">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
    <span class="s1">if </span><span class="s0">(workUnitStore) {</span>
        <span class="s1">switch</span><span class="s0">(workUnitStore.type){</span>
            <span class="s1">case </span><span class="s2">'prerender'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-client'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-ppr'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-legacy'</span><span class="s0">:</span>
                <span class="s1">return </span><span class="s0">createStaticPrerenderParams(underlyingParams, workStore, workUnitStore);</span>
            <span class="s1">case </span><span class="s2">'cache'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'private-cache'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'unstable-cache'</span><span class="s0">:</span>
                <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">_invarianterror.InvariantError(</span><span class="s2">'createParamsFromClient should not be called in cache contexts.'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
                    <span class="s0">value: </span><span class="s2">&quot;E736&quot;</span><span class="s0">,</span>
                    <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
                    <span class="s0">configurable: </span><span class="s1">true</span>
                <span class="s0">});</span>
            <span class="s1">case </span><span class="s2">'prerender-runtime'</span><span class="s0">:</span>
                <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">_invarianterror.InvariantError(</span><span class="s2">'createParamsFromClient should not be called in a runtime prerender.'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
                    <span class="s0">value: </span><span class="s2">&quot;E770&quot;</span><span class="s0">,</span>
                    <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
                    <span class="s0">configurable: </span><span class="s1">true</span>
                <span class="s0">});</span>
            <span class="s1">case </span><span class="s2">'request'</span><span class="s0">:</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
                    <span class="s3">// Semantically we only need the dev tracking when running in `next dev`</span>
                    <span class="s3">// but since you would never use next dev with production NODE_ENV we use this</span>
                    <span class="s3">// as a proxy so we can statically exclude this code from production builds.</span>
                    <span class="s1">const </span><span class="s0">devFallbackParams = workUnitStore.devFallbackParams;</span>
                    <span class="s1">return </span><span class="s0">createRenderParamsInDev(underlyingParams, devFallbackParams, workStore);</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s3">//TURBOPACK unreachable</span>
                <span class="s0">;</span>
            <span class="s1">default</span><span class="s0">:</span>
                <span class="s0">workUnitStore;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _workunitasyncstorageexternal.throwInvariantForMissingStore)();</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">createServerParamsForMetadata = createServerParamsForServerSegment;</span>
<span class="s1">function </span><span class="s0">createServerParamsForRoute(underlyingParams, workStore) {</span>
    <span class="s1">const </span><span class="s0">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
    <span class="s1">if </span><span class="s0">(workUnitStore) {</span>
        <span class="s1">switch</span><span class="s0">(workUnitStore.type){</span>
            <span class="s1">case </span><span class="s2">'prerender'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-client'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-ppr'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-legacy'</span><span class="s0">:</span>
                <span class="s1">return </span><span class="s0">createStaticPrerenderParams(underlyingParams, workStore, workUnitStore);</span>
            <span class="s1">case </span><span class="s2">'cache'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'private-cache'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'unstable-cache'</span><span class="s0">:</span>
                <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">_invarianterror.InvariantError(</span><span class="s2">'createServerParamsForRoute should not be called in cache contexts.'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
                    <span class="s0">value: </span><span class="s2">&quot;E738&quot;</span><span class="s0">,</span>
                    <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
                    <span class="s0">configurable: </span><span class="s1">true</span>
                <span class="s0">});</span>
            <span class="s1">case </span><span class="s2">'prerender-runtime'</span><span class="s0">:</span>
                <span class="s1">return </span><span class="s0">createRuntimePrerenderParams(underlyingParams, workUnitStore);</span>
            <span class="s1">case </span><span class="s2">'request'</span><span class="s0">:</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
                    <span class="s3">// Semantically we only need the dev tracking when running in `next dev`</span>
                    <span class="s3">// but since you would never use next dev with production NODE_ENV we use this</span>
                    <span class="s3">// as a proxy so we can statically exclude this code from production builds.</span>
                    <span class="s1">const </span><span class="s0">devFallbackParams = workUnitStore.devFallbackParams;</span>
                    <span class="s1">return </span><span class="s0">createRenderParamsInDev(underlyingParams, devFallbackParams, workStore);</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s3">//TURBOPACK unreachable</span>
                <span class="s0">;</span>
            <span class="s1">default</span><span class="s0">:</span>
                <span class="s0">workUnitStore;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _workunitasyncstorageexternal.throwInvariantForMissingStore)();</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createServerParamsForServerSegment(underlyingParams, workStore) {</span>
    <span class="s1">const </span><span class="s0">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
    <span class="s1">if </span><span class="s0">(workUnitStore) {</span>
        <span class="s1">switch</span><span class="s0">(workUnitStore.type){</span>
            <span class="s1">case </span><span class="s2">'prerender'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-client'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-ppr'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-legacy'</span><span class="s0">:</span>
                <span class="s1">return </span><span class="s0">createStaticPrerenderParams(underlyingParams, workStore, workUnitStore);</span>
            <span class="s1">case </span><span class="s2">'cache'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'private-cache'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'unstable-cache'</span><span class="s0">:</span>
                <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">_invarianterror.InvariantError(</span><span class="s2">'createServerParamsForServerSegment should not be called in cache contexts.'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
                    <span class="s0">value: </span><span class="s2">&quot;E743&quot;</span><span class="s0">,</span>
                    <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
                    <span class="s0">configurable: </span><span class="s1">true</span>
                <span class="s0">});</span>
            <span class="s1">case </span><span class="s2">'prerender-runtime'</span><span class="s0">:</span>
                <span class="s1">return </span><span class="s0">createRuntimePrerenderParams(underlyingParams, workUnitStore);</span>
            <span class="s1">case </span><span class="s2">'request'</span><span class="s0">:</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
                    <span class="s3">// Semantically we only need the dev tracking when running in `next dev`</span>
                    <span class="s3">// but since you would never use next dev with production NODE_ENV we use this</span>
                    <span class="s3">// as a proxy so we can statically exclude this code from production builds.</span>
                    <span class="s1">const </span><span class="s0">devFallbackParams = workUnitStore.devFallbackParams;</span>
                    <span class="s1">return </span><span class="s0">createRenderParamsInDev(underlyingParams, devFallbackParams, workStore);</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s3">//TURBOPACK unreachable</span>
                <span class="s0">;</span>
            <span class="s1">default</span><span class="s0">:</span>
                <span class="s0">workUnitStore;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _workunitasyncstorageexternal.throwInvariantForMissingStore)();</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createPrerenderParamsForClientSegment(underlyingParams) {</span>
    <span class="s1">const </span><span class="s0">workStore = _workasyncstorageexternal.workAsyncStorage.getStore();</span>
    <span class="s1">if </span><span class="s0">(!workStore) {</span>
        <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">_invarianterror.InvariantError(</span><span class="s2">'Missing workStore in createPrerenderParamsForClientSegment'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
            <span class="s0">value: </span><span class="s2">&quot;E773&quot;</span><span class="s0">,</span>
            <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">configurable: </span><span class="s1">true</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
    <span class="s1">if </span><span class="s0">(workUnitStore) {</span>
        <span class="s1">switch</span><span class="s0">(workUnitStore.type){</span>
            <span class="s1">case </span><span class="s2">'prerender'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-client'</span><span class="s0">:</span>
                <span class="s1">const </span><span class="s0">fallbackParams = workUnitStore.fallbackRouteParams;</span>
                <span class="s1">if </span><span class="s0">(fallbackParams) {</span>
                    <span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">key </span><span class="s1">in </span><span class="s0">underlyingParams){</span>
                        <span class="s1">if </span><span class="s0">(fallbackParams.has(key)) {</span>
                            <span class="s3">// This params object has one or more fallback params, so we need</span>
                            <span class="s3">// to consider the awaiting of this params object &quot;dynamic&quot;. Since</span>
                            <span class="s3">// we are in cacheComponents mode we encode this as a promise that never</span>
                            <span class="s3">// resolves.</span>
                            <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, </span><span class="s2">'`params`'</span><span class="s0">);</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s2">'cache'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'private-cache'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'unstable-cache'</span><span class="s0">:</span>
                <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">_invarianterror.InvariantError(</span><span class="s2">'createPrerenderParamsForClientSegment should not be called in cache contexts.'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
                    <span class="s0">value: </span><span class="s2">&quot;E734&quot;</span><span class="s0">,</span>
                    <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
                    <span class="s0">configurable: </span><span class="s1">true</span>
                <span class="s0">});</span>
            <span class="s1">case </span><span class="s2">'prerender-ppr'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-legacy'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-runtime'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'request'</span><span class="s0">:</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s1">default</span><span class="s0">:</span>
                <span class="s0">workUnitStore;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s3">// We're prerendering in a mode that does not abort. We resolve the promise without</span>
    <span class="s3">// any tracking because we're just transporting a value from server to client where the tracking</span>
    <span class="s3">// will be applied.</span>
    <span class="s1">return </span><span class="s0">Promise.resolve(underlyingParams);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createStaticPrerenderParams(underlyingParams, workStore, prerenderStore) {</span>
    <span class="s1">switch</span><span class="s0">(prerenderStore.type){</span>
        <span class="s1">case </span><span class="s2">'prerender'</span><span class="s0">:</span>
        <span class="s1">case </span><span class="s2">'prerender-client'</span><span class="s0">:</span>
            <span class="s0">{</span>
                <span class="s1">const </span><span class="s0">fallbackParams = prerenderStore.fallbackRouteParams;</span>
                <span class="s1">if </span><span class="s0">(fallbackParams) {</span>
                    <span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">underlyingParams){</span>
                        <span class="s1">if </span><span class="s0">(fallbackParams.has(key)) {</span>
                            <span class="s3">// This params object has one or more fallback params, so we need</span>
                            <span class="s3">// to consider the awaiting of this params object &quot;dynamic&quot;. Since</span>
                            <span class="s3">// we are in cacheComponents mode we encode this as a promise that never</span>
                            <span class="s3">// resolves.</span>
                            <span class="s1">return </span><span class="s0">makeHangingParams(underlyingParams, workStore, prerenderStore);</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s1">case </span><span class="s2">'prerender-ppr'</span><span class="s0">:</span>
            <span class="s0">{</span>
                <span class="s1">const </span><span class="s0">fallbackParams = prerenderStore.fallbackRouteParams;</span>
                <span class="s1">if </span><span class="s0">(fallbackParams) {</span>
                    <span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">underlyingParams){</span>
                        <span class="s1">if </span><span class="s0">(fallbackParams.has(key)) {</span>
                            <span class="s1">return </span><span class="s0">makeErroringExoticParams(underlyingParams, fallbackParams, workStore, prerenderStore);</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s1">case </span><span class="s2">'prerender-legacy'</span><span class="s0">:</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s1">default</span><span class="s0">:</span>
            <span class="s0">prerenderStore;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
    <span class="s1">else </span><span class="s0">{</span>
        <span class="s1">return </span><span class="s0">makeUntrackedExoticParams(underlyingParams);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createRuntimePrerenderParams(underlyingParams, workUnitStore) {</span>
    <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _dynamicrendering.delayUntilRuntimeStage)(workUnitStore, (</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) ? </span><span class="s2">&quot;TURBOPACK unreachable&quot; </span><span class="s0">: makeUntrackedExoticParams(underlyingParams));</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createRenderParamsInProd(underlyingParams) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
    <span class="s1">return </span><span class="s0">makeUntrackedExoticParams(underlyingParams);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createRenderParamsInDev(underlyingParams, devFallbackParams, workStore) {</span>
    <span class="s1">let </span><span class="s0">hasFallbackParams = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(devFallbackParams) {</span>
        <span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">key </span><span class="s1">in </span><span class="s0">underlyingParams){</span>
            <span class="s1">if </span><span class="s0">(devFallbackParams.has(key)) {</span>
                <span class="s0">hasFallbackParams = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
    <span class="s1">return </span><span class="s0">makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams, hasFallbackParams, workStore);</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">CachedParams = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
<span class="s1">const </span><span class="s0">fallbackParamsProxyHandler = {</span>
    <span class="s0">get: </span><span class="s1">function </span><span class="s0">get(target, prop, receiver) {</span>
        <span class="s1">if </span><span class="s0">(prop === </span><span class="s2">'then' </span><span class="s0">|| prop === </span><span class="s2">'catch' </span><span class="s0">|| prop === </span><span class="s2">'finally'</span><span class="s0">) {</span>
            <span class="s1">const </span><span class="s0">originalMethod = _reflect.ReflectAdapter.get(target, prop, receiver);</span>
            <span class="s1">return </span><span class="s0">({</span>
                <span class="s0">[prop]: </span><span class="s1">function</span><span class="s0">() {</span>
                    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">_len = arguments.length, args = </span><span class="s1">new </span><span class="s0">Array(_len), _key = </span><span class="s4">0</span><span class="s0">; _key &lt; _len; _key++){</span>
                        <span class="s0">args[_key] = arguments[_key];</span>
                    <span class="s0">}</span>
                    <span class="s1">const </span><span class="s0">store = _dynamicaccessasyncstorageexternal.dynamicAccessAsyncStorage.getStore();</span>
                    <span class="s1">if </span><span class="s0">(store) {</span>
                        <span class="s0">store.abortController.abort(Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">&quot;Accessed fallback `params` during prerendering.&quot;</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
                            <span class="s0">value: </span><span class="s2">&quot;E691&quot;</span><span class="s0">,</span>
                            <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
                            <span class="s0">configurable: </span><span class="s1">true</span>
                        <span class="s0">}));</span>
                    <span class="s0">}</span>
                    <span class="s1">return new </span><span class="s0">Proxy(originalMethod.apply(target, args), fallbackParamsProxyHandler);</span>
                <span class="s0">}</span>
            <span class="s0">})[prop];</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
    <span class="s0">}</span>
<span class="s0">};</span>
<span class="s1">function </span><span class="s0">makeHangingParams(underlyingParams, workStore, prerenderStore) {</span>
    <span class="s1">const </span><span class="s0">cachedParams = CachedParams.get(underlyingParams);</span>
    <span class="s1">if </span><span class="s0">(cachedParams) {</span>
        <span class="s1">return </span><span class="s0">cachedParams;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">promise = </span><span class="s1">new </span><span class="s0">Proxy((</span><span class="s4">0</span><span class="s0">, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, workStore.route, </span><span class="s2">'`params`'</span><span class="s0">), fallbackParamsProxyHandler);</span>
    <span class="s0">CachedParams.set(underlyingParams, promise);</span>
    <span class="s1">return </span><span class="s0">promise;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">makeErroringExoticParams(underlyingParams, fallbackParams, workStore, prerenderStore) {</span>
    <span class="s1">const </span><span class="s0">cachedParams = CachedParams.get(underlyingParams);</span>
    <span class="s1">if </span><span class="s0">(cachedParams) {</span>
        <span class="s1">return </span><span class="s0">cachedParams;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">augmentedUnderlying = {</span>
        <span class="s0">...underlyingParams</span>
    <span class="s0">};</span>
    <span class="s3">// We don't use makeResolvedReactPromise here because params</span>
    <span class="s3">// supports copying with spread and we don't want to unnecessarily</span>
    <span class="s3">// instrument the promise with spreadable properties of ReactPromise.</span>
    <span class="s1">const </span><span class="s0">promise = Promise.resolve(augmentedUnderlying);</span>
    <span class="s0">CachedParams.set(underlyingParams, promise);</span>
    <span class="s0">Object.keys(underlyingParams).forEach((prop)=&gt;{</span>
        <span class="s1">if </span><span class="s0">(_reflectutils.wellKnownProperties.has(prop)) {</span>
        <span class="s3">// These properties cannot be shadowed because they need to be the</span>
        <span class="s3">// true underlying value for Promises to work correctly at runtime</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">if </span><span class="s0">(fallbackParams.has(prop)) {</span>
                <span class="s0">Object.defineProperty(augmentedUnderlying, prop, {</span>
                    <span class="s0">get () {</span>
                        <span class="s1">const </span><span class="s0">expression = (</span><span class="s4">0</span><span class="s0">, _reflectutils.describeStringPropertyAccess)(</span><span class="s2">'params'</span><span class="s0">, prop);</span>
                        <span class="s3">// In most dynamic APIs we also throw if `dynamic = &quot;error&quot;` however</span>
                        <span class="s3">// for params is only dynamic when we're generating a fallback shell</span>
                        <span class="s3">// and even when `dynamic = &quot;error&quot;` we still support generating dynamic</span>
                        <span class="s3">// fallback shells</span>
                        <span class="s3">// TODO remove this comment when cacheComponents is the default since there</span>
                        <span class="s3">// will be no `dynamic = &quot;error&quot;`</span>
                        <span class="s1">if </span><span class="s0">(prerenderStore.type === </span><span class="s2">'prerender-ppr'</span><span class="s0">) {</span>
                            <span class="s3">// PPR Prerender (no cacheComponents)</span>
                            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);</span>
                        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                            <span class="s3">// Legacy Prerender</span>
                            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);</span>
                        <span class="s0">}</span>
                    <span class="s0">},</span>
                    <span class="s0">enumerable: </span><span class="s1">true</span>
                <span class="s0">});</span>
                <span class="s0">Object.defineProperty(promise, prop, {</span>
                    <span class="s0">get () {</span>
                        <span class="s1">const </span><span class="s0">expression = (</span><span class="s4">0</span><span class="s0">, _reflectutils.describeStringPropertyAccess)(</span><span class="s2">'params'</span><span class="s0">, prop);</span>
                        <span class="s3">// In most dynamic APIs we also throw if `dynamic = &quot;error&quot;` however</span>
                        <span class="s3">// for params is only dynamic when we're generating a fallback shell</span>
                        <span class="s3">// and even when `dynamic = &quot;error&quot;` we still support generating dynamic</span>
                        <span class="s3">// fallback shells</span>
                        <span class="s3">// TODO remove this comment when cacheComponents is the default since there</span>
                        <span class="s3">// will be no `dynamic = &quot;error&quot;`</span>
                        <span class="s1">if </span><span class="s0">(prerenderStore.type === </span><span class="s2">'prerender-ppr'</span><span class="s0">) {</span>
                            <span class="s3">// PPR Prerender (no cacheComponents)</span>
                            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);</span>
                        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                            <span class="s3">// Legacy Prerender</span>
                            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);</span>
                        <span class="s0">}</span>
                    <span class="s0">},</span>
                    <span class="s0">set (newValue) {</span>
                        <span class="s0">Object.defineProperty(promise, prop, {</span>
                            <span class="s0">value: newValue,</span>
                            <span class="s0">writable: </span><span class="s1">true</span><span class="s0">,</span>
                            <span class="s0">enumerable: </span><span class="s1">true</span>
                        <span class="s0">});</span>
                    <span class="s0">},</span>
                    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
                    <span class="s0">configurable: </span><span class="s1">true</span>
                <span class="s0">});</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">;</span>
                <span class="s0">promise[prop] = underlyingParams[prop];</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">promise;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">makeUntrackedExoticParams(underlyingParams) {</span>
    <span class="s1">const </span><span class="s0">cachedParams = CachedParams.get(underlyingParams);</span>
    <span class="s1">if </span><span class="s0">(cachedParams) {</span>
        <span class="s1">return </span><span class="s0">cachedParams;</span>
    <span class="s0">}</span>
    <span class="s3">// We don't use makeResolvedReactPromise here because params</span>
    <span class="s3">// supports copying with spread and we don't want to unnecessarily</span>
    <span class="s3">// instrument the promise with spreadable properties of ReactPromise.</span>
    <span class="s1">const </span><span class="s0">promise = Promise.resolve(underlyingParams);</span>
    <span class="s0">CachedParams.set(underlyingParams, promise);</span>
    <span class="s0">Object.keys(underlyingParams).forEach((prop)=&gt;{</span>
        <span class="s1">if </span><span class="s0">(_reflectutils.wellKnownProperties.has(prop)) {</span>
        <span class="s3">// These properties cannot be shadowed because they need to be the</span>
        <span class="s3">// true underlying value for Promises to work correctly at runtime</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">;</span>
            <span class="s0">promise[prop] = underlyingParams[prop];</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">promise;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">makeUntrackedParams(underlyingParams) {</span>
    <span class="s1">const </span><span class="s0">cachedParams = CachedParams.get(underlyingParams);</span>
    <span class="s1">if </span><span class="s0">(cachedParams) {</span>
        <span class="s1">return </span><span class="s0">cachedParams;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">promise = Promise.resolve(underlyingParams);</span>
    <span class="s0">CachedParams.set(underlyingParams, promise);</span>
    <span class="s1">return </span><span class="s0">promise;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams, hasFallbackParams, store) {</span>
    <span class="s1">const </span><span class="s0">cachedParams = CachedParams.get(underlyingParams);</span>
    <span class="s1">if </span><span class="s0">(cachedParams) {</span>
        <span class="s1">return </span><span class="s0">cachedParams;</span>
    <span class="s0">}</span>
    <span class="s3">// We don't use makeResolvedReactPromise here because params</span>
    <span class="s3">// supports copying with spread and we don't want to unnecessarily</span>
    <span class="s3">// instrument the promise with spreadable properties of ReactPromise.</span>
    <span class="s1">const </span><span class="s0">promise = hasFallbackParams ? (</span><span class="s4">0</span><span class="s0">, _dynamicrenderingutils.makeDevtoolsIOAwarePromise)(underlyingParams) : Promise.resolve(underlyingParams);</span>
    <span class="s1">const </span><span class="s0">proxiedProperties = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s1">const </span><span class="s0">unproxiedProperties = [];</span>
    <span class="s0">Object.keys(underlyingParams).forEach((prop)=&gt;{</span>
        <span class="s1">if </span><span class="s0">(_reflectutils.wellKnownProperties.has(prop)) {</span>
            <span class="s3">// These properties cannot be shadowed because they need to be the</span>
            <span class="s3">// true underlying value for Promises to work correctly at runtime</span>
            <span class="s0">unproxiedProperties.push(prop);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">proxiedProperties.add(prop);</span>
            <span class="s0">promise[prop] = underlyingParams[prop];</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s1">const </span><span class="s0">proxiedPromise = </span><span class="s1">new </span><span class="s0">Proxy(promise, {</span>
        <span class="s0">get (target, prop, receiver) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(proxiedProperties.has(prop)) {</span>
                    <span class="s1">const </span><span class="s0">expression = (</span><span class="s4">0</span><span class="s0">, _reflectutils.describeStringPropertyAccess)(</span><span class="s2">'params'</span><span class="s0">, prop);</span>
                    <span class="s0">syncIODev(store.route, expression);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
        <span class="s0">},</span>
        <span class="s0">set (target, prop, value, receiver) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s0">proxiedProperties.delete(prop);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">_reflect.ReflectAdapter.set(target, prop, value, receiver);</span>
        <span class="s0">},</span>
        <span class="s0">ownKeys (target) {</span>
            <span class="s1">const </span><span class="s0">expression = </span><span class="s2">'`...params` or similar expression'</span><span class="s0">;</span>
            <span class="s0">syncIODev(store.route, expression, unproxiedProperties);</span>
            <span class="s1">return </span><span class="s0">Reflect.ownKeys(target);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">CachedParams.set(underlyingParams, proxiedPromise);</span>
    <span class="s1">return </span><span class="s0">proxiedPromise;</span>
<span class="s0">}</span>
<span class="s3">// Similar to `makeDynamicallyTrackedExoticParamsWithDevWarnings`, but just</span>
<span class="s3">// logging the sync access without actually defining the params on the promise.</span>
<span class="s1">function </span><span class="s0">makeDynamicallyTrackedParamsWithDevWarnings(underlyingParams, hasFallbackParams, store) {</span>
    <span class="s1">const </span><span class="s0">cachedParams = CachedParams.get(underlyingParams);</span>
    <span class="s1">if </span><span class="s0">(cachedParams) {</span>
        <span class="s1">return </span><span class="s0">cachedParams;</span>
    <span class="s0">}</span>
    <span class="s3">// We don't use makeResolvedReactPromise here because params</span>
    <span class="s3">// supports copying with spread and we don't want to unnecessarily</span>
    <span class="s3">// instrument the promise with spreadable properties of ReactPromise.</span>
    <span class="s1">const </span><span class="s0">promise = hasFallbackParams ? (</span><span class="s4">0</span><span class="s0">, _dynamicrenderingutils.makeDevtoolsIOAwarePromise)(underlyingParams) : Promise.resolve(underlyingParams);</span>
    <span class="s1">const </span><span class="s0">proxiedProperties = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s1">const </span><span class="s0">unproxiedProperties = [];</span>
    <span class="s0">Object.keys(underlyingParams).forEach((prop)=&gt;{</span>
        <span class="s1">if </span><span class="s0">(_reflectutils.wellKnownProperties.has(prop)) {</span>
            <span class="s3">// These properties cannot be shadowed because they need to be the</span>
            <span class="s3">// true underlying value for Promises to work correctly at runtime</span>
            <span class="s0">unproxiedProperties.push(prop);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">proxiedProperties.add(prop);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s1">const </span><span class="s0">proxiedPromise = </span><span class="s1">new </span><span class="s0">Proxy(promise, {</span>
        <span class="s0">get (target, prop, receiver) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(proxiedProperties.has(prop)) {</span>
                    <span class="s1">const </span><span class="s0">expression = (</span><span class="s4">0</span><span class="s0">, _reflectutils.describeStringPropertyAccess)(</span><span class="s2">'params'</span><span class="s0">, prop);</span>
                    <span class="s0">warnForSyncAccess(store.route, expression);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
        <span class="s0">},</span>
        <span class="s0">set (target, prop, value, receiver) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s0">proxiedProperties.delete(prop);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">_reflect.ReflectAdapter.set(target, prop, value, receiver);</span>
        <span class="s0">},</span>
        <span class="s0">ownKeys (target) {</span>
            <span class="s1">const </span><span class="s0">expression = </span><span class="s2">'`...params` or similar expression'</span><span class="s0">;</span>
            <span class="s0">warnForIncompleteEnumeration(store.route, expression, unproxiedProperties);</span>
            <span class="s1">return </span><span class="s0">Reflect.ownKeys(target);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">CachedParams.set(underlyingParams, proxiedPromise);</span>
    <span class="s1">return </span><span class="s0">proxiedPromise;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">syncIODev(route, expression, missingProperties) {</span>
    <span class="s1">const </span><span class="s0">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
    <span class="s1">if </span><span class="s0">(workUnitStore) {</span>
        <span class="s1">switch</span><span class="s0">(workUnitStore.type){</span>
            <span class="s1">case </span><span class="s2">'request'</span><span class="s0">:</span>
                <span class="s1">if </span><span class="s0">(workUnitStore.prerenderPhase === </span><span class="s1">true</span><span class="s0">) {</span>
                    <span class="s3">// When we're rendering dynamically in dev, we need to advance out of</span>
                    <span class="s3">// the Prerender environment when we read Request data synchronously.</span>
                    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(workUnitStore);</span>
                <span class="s0">}</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s2">'prerender'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-client'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-runtime'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-ppr'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-legacy'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'cache'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'private-cache'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'unstable-cache'</span><span class="s0">:</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s1">default</span><span class="s0">:</span>
                <span class="s0">workUnitStore;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s3">// In all cases we warn normally</span>
    <span class="s1">if </span><span class="s0">(missingProperties &amp;&amp; missingProperties.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s0">warnForIncompleteEnumeration(route, expression, missingProperties);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">warnForSyncAccess(route, expression);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">warnForSyncAccess = (</span><span class="s4">0</span><span class="s0">, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createParamsAccessError);</span>
<span class="s1">const </span><span class="s0">warnForIncompleteEnumeration = (</span><span class="s4">0</span><span class="s0">, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createIncompleteEnumerationError);</span>
<span class="s1">function </span><span class="s0">createParamsAccessError(route, expression) {</span>
    <span class="s1">const </span><span class="s0">prefix = route ? </span><span class="s2">'Route &quot;'</span><span class="s0">.concat(route, </span><span class="s2">'&quot; '</span><span class="s0">) : </span><span class="s2">'This route '</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">&quot;&quot;</span><span class="s0">.concat(prefix, </span><span class="s2">&quot;used &quot;</span><span class="s0">).concat(expression, </span><span class="s2">&quot;. &quot;</span><span class="s0">) + </span><span class="s2">&quot;`params` should be awaited before using its properties. &quot; </span><span class="s0">+ </span><span class="s2">&quot;Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis&quot;</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s2">&quot;E307&quot;</span><span class="s0">,</span>
        <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">configurable: </span><span class="s1">true</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createIncompleteEnumerationError(route, expression, missingProperties) {</span>
    <span class="s1">const </span><span class="s0">prefix = route ? </span><span class="s2">'Route &quot;'</span><span class="s0">.concat(route, </span><span class="s2">'&quot; '</span><span class="s0">) : </span><span class="s2">'This route '</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">&quot;&quot;</span><span class="s0">.concat(prefix, </span><span class="s2">&quot;used &quot;</span><span class="s0">).concat(expression, </span><span class="s2">&quot;. &quot;</span><span class="s0">) + </span><span class="s2">&quot;`params` should be awaited before using its properties. &quot; </span><span class="s0">+ </span><span class="s2">&quot;The following properties were not available through enumeration &quot; </span><span class="s0">+ </span><span class="s2">&quot;because they conflict with builtin property names: &quot; </span><span class="s0">+ </span><span class="s2">&quot;&quot;</span><span class="s0">.concat(describeListOfPropertyNames(missingProperties), </span><span class="s2">&quot;. &quot;</span><span class="s0">) + </span><span class="s2">&quot;Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis&quot;</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s2">&quot;E482&quot;</span><span class="s0">,</span>
        <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">configurable: </span><span class="s1">true</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">describeListOfPropertyNames(properties) {</span>
    <span class="s1">switch</span><span class="s0">(properties.length){</span>
        <span class="s1">case </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">_invarianterror.InvariantError(</span><span class="s2">'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
                <span class="s0">value: </span><span class="s2">&quot;E531&quot;</span><span class="s0">,</span>
                <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
                <span class="s0">configurable: </span><span class="s1">true</span>
            <span class="s0">});</span>
        <span class="s1">case </span><span class="s4">1</span><span class="s0">:</span>
            <span class="s1">return </span><span class="s2">&quot;`&quot;</span><span class="s0">.concat(properties[</span><span class="s4">0</span><span class="s0">], </span><span class="s2">&quot;`&quot;</span><span class="s0">);</span>
        <span class="s1">case </span><span class="s4">2</span><span class="s0">:</span>
            <span class="s1">return </span><span class="s2">&quot;`&quot;</span><span class="s0">.concat(properties[</span><span class="s4">0</span><span class="s0">], </span><span class="s2">&quot;` and `&quot;</span><span class="s0">).concat(properties[</span><span class="s4">1</span><span class="s0">], </span><span class="s2">&quot;`&quot;</span><span class="s0">);</span>
        <span class="s1">default</span><span class="s0">:</span>
            <span class="s0">{</span>
                <span class="s1">let </span><span class="s0">description = </span><span class="s2">''</span><span class="s0">;</span>
                <span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; properties.length - </span><span class="s4">1</span><span class="s0">; i++){</span>
                    <span class="s0">description += </span><span class="s2">&quot;`&quot;</span><span class="s0">.concat(properties[i], </span><span class="s2">&quot;`, &quot;</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s0">description += </span><span class="s2">&quot;, and `&quot;</span><span class="s0">.concat(properties[properties.length - </span><span class="s4">1</span><span class="s0">], </span><span class="s2">&quot;`&quot;</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s0">description;</span>
            <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=params.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/client-page.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;ClientPageRoot&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">ClientPageRoot;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_jsxruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_invarianterror = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">ClientPageRoot(param) {</span>
    <span class="s1">let </span><span class="s0">{ Component, searchParams, params, promises } = param;</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">window === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
        <span class="s1">const </span><span class="s0">{ workAsyncStorage } = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/app-render/work-async-storage.external.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
        <span class="s1">let </span><span class="s0">clientSearchParams;</span>
        <span class="s1">let </span><span class="s0">clientParams;</span>
        <span class="s3">// We are going to instrument the searchParams prop with tracking for the</span>
        <span class="s3">// appropriate context. We wrap differently in prerendering vs rendering</span>
        <span class="s1">const </span><span class="s0">store = workAsyncStorage.getStore();</span>
        <span class="s1">if </span><span class="s0">(!store) {</span>
            <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">_invarianterror.InvariantError(</span><span class="s2">'Expected workStore to exist when handling searchParams in a client Page.'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
                <span class="s0">value: </span><span class="s2">&quot;E564&quot;</span><span class="s0">,</span>
                <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
                <span class="s0">configurable: </span><span class="s1">true</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">{ createSearchParamsFromClient } = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/request/search-params.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
        <span class="s0">clientSearchParams = createSearchParamsFromClient(searchParams, store);</span>
        <span class="s1">const </span><span class="s0">{ createParamsFromClient } = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/request/params.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
        <span class="s0">clientParams = createParamsFromClient(params, store);</span>
        <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(Component, {</span>
            <span class="s0">params: clientParams,</span>
            <span class="s0">searchParams: clientSearchParams</span>
        <span class="s0">});</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">const </span><span class="s0">{ createRenderSearchParamsFromClient } = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/request/search-params.browser.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">clientSearchParams = createRenderSearchParamsFromClient(searchParams);</span>
        <span class="s1">const </span><span class="s0">{ createRenderParamsFromClient } = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/request/params.browser.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">clientParams = createRenderParamsFromClient(params);</span>
        <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(Component, {</span>
            <span class="s0">params: clientParams,</span>
            <span class="s0">searchParams: clientSearchParams</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=client-page.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/client-segment.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;ClientSegmentRoot&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">ClientSegmentRoot;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_jsxruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_invarianterror = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">ClientSegmentRoot(param) {</span>
    <span class="s1">let </span><span class="s0">{ Component, slots, params, promise } = param;</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">window === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
        <span class="s1">const </span><span class="s0">{ workAsyncStorage } = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/app-render/work-async-storage.external.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
        <span class="s1">let </span><span class="s0">clientParams;</span>
        <span class="s3">// We are going to instrument the searchParams prop with tracking for the</span>
        <span class="s3">// appropriate context. We wrap differently in prerendering vs rendering</span>
        <span class="s1">const </span><span class="s0">store = workAsyncStorage.getStore();</span>
        <span class="s1">if </span><span class="s0">(!store) {</span>
            <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">_invarianterror.InvariantError(</span><span class="s2">'Expected workStore to exist when handling params in a client segment such as a Layout or Template.'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
                <span class="s0">value: </span><span class="s2">&quot;E600&quot;</span><span class="s0">,</span>
                <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
                <span class="s0">configurable: </span><span class="s1">true</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">{ createParamsFromClient } = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/request/params.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
        <span class="s0">clientParams = createParamsFromClient(params, store);</span>
        <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(Component, {</span>
            <span class="s0">...slots,</span>
            <span class="s0">params: clientParams</span>
        <span class="s0">});</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">const </span><span class="s0">{ createRenderParamsFromClient } = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/request/params.browser.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">clientParams = createRenderParamsFromClient(params);</span>
        <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(Component, {</span>
            <span class="s0">...slots,</span>
            <span class="s0">params: clientParams</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=client-segment.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/lib/metadata/generate/icon-mark.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;IconMark&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">IconMark;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_jsxruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">IconMark = ()=&gt;{</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">window !== </span><span class="s2">'undefined'</span><span class="s0">) {</span>
        <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(</span><span class="s2">&quot;meta&quot;</span><span class="s0">, {</span>
        <span class="s0">name: </span><span class="s2">&quot;</span><span class="s6">\xab</span><span class="s2">nxt-icon</span><span class="s6">\xbb</span><span class="s2">&quot;</span>
    <span class="s0">});</span>
<span class="s0">}; </span><span class="s3">//# sourceMappingURL=icon-mark.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/metadata/async-metadata.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;AsyncMetadataOutlet&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">AsyncMetadataOutlet;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_jsxruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_react = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">MetadataOutlet(param) {</span>
    <span class="s1">let </span><span class="s0">{ promise } = param;</span>
    <span class="s1">const </span><span class="s0">{ error, digest } = (</span><span class="s4">0</span><span class="s0">, _react.use)(promise);</span>
    <span class="s1">if </span><span class="s0">(error) {</span>
        <span class="s1">if </span><span class="s0">(digest) {</span>
            <span class="s3">// The error will lose its original digest after passing from server layer to client layerï¼›</span>
            <span class="s3">// We recover the digest property here to override the React created one if original digest exists.</span>
            <span class="s0">;</span>
            <span class="s0">error.digest = digest;</span>
        <span class="s0">}</span>
        <span class="s1">throw </span><span class="s0">error;</span>
    <span class="s0">}</span>
    <span class="s1">return null</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">AsyncMetadataOutlet(param) {</span>
    <span class="s1">let </span><span class="s0">{ promise } = param;</span>
    <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_react.Suspense, {</span>
        <span class="s0">fallback: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">children: </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(MetadataOutlet, {</span>
            <span class="s0">promise: promise</span>
        <span class="s0">})</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=async-metadata.js.map</span>
<span class="s0">}),</span>
<span class="s0">]);</span>

<span class="s3">//# sourceMappingURL=node_modules_next_dist_8db7fb1f._.js.map</span></pre>
</body>
</html>