<html>
<head>
<title>test.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* The `node:test` module facilitates the creation of JavaScript tests.</span>
 <span class="s0">* To access it:</span>
 <span class="s0">*</span>
 <span class="s0">* ```js</span>
 <span class="s0">* import test from 'node:test';</span>
 <span class="s0">* ```</span>
 <span class="s0">*</span>
 <span class="s0">* This module is only available under the `node:` scheme. The following will not</span>
 <span class="s0">* work:</span>
 <span class="s0">*</span>
 <span class="s0">* ```js</span>
 <span class="s0">* import test from 'test';</span>
 <span class="s0">* ```</span>
 <span class="s0">*</span>
 <span class="s0">* Tests created via the `test` module consist of a single function that is</span>
 <span class="s0">* processed in one of three ways:</span>
 <span class="s0">*</span>
 <span class="s0">* 1. A synchronous function that is considered failing if it throws an exception,</span>
 <span class="s0">* and is considered passing otherwise.</span>
 <span class="s0">* 2. A function that returns a `Promise` that is considered failing if the `Promise` rejects, and is considered passing if the `Promise` fulfills.</span>
 <span class="s0">* 3. A function that receives a callback function. If the callback receives any</span>
 <span class="s0">* truthy value as its first argument, the test is considered failing. If a</span>
 <span class="s0">* falsy value is passed as the first argument to the callback, the test is</span>
 <span class="s0">* considered passing. If the test function receives a callback function and</span>
 <span class="s0">* also returns a `Promise`, the test will fail.</span>
 <span class="s0">*</span>
 <span class="s0">* The following example illustrates how tests are written using the `test` module.</span>
 <span class="s0">*</span>
 <span class="s0">* ```js</span>
 <span class="s0">* test('synchronous passing test', (t) =&gt; {</span>
 <span class="s0">*   // This test passes because it does not throw an exception.</span>
 <span class="s0">*   assert.strictEqual(1, 1);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* test('synchronous failing test', (t) =&gt; {</span>
 <span class="s0">*   // This test fails because it throws an exception.</span>
 <span class="s0">*   assert.strictEqual(1, 2);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* test('asynchronous passing test', async (t) =&gt; {</span>
 <span class="s0">*   // This test passes because the Promise returned by the async</span>
 <span class="s0">*   // function is settled and not rejected.</span>
 <span class="s0">*   assert.strictEqual(1, 1);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* test('asynchronous failing test', async (t) =&gt; {</span>
 <span class="s0">*   // This test fails because the Promise returned by the async</span>
 <span class="s0">*   // function is rejected.</span>
 <span class="s0">*   assert.strictEqual(1, 2);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* test('failing test using Promises', (t) =&gt; {</span>
 <span class="s0">*   // Promises can be used directly as well.</span>
 <span class="s0">*   return new Promise((resolve, reject) =&gt; {</span>
 <span class="s0">*     setImmediate(() =&gt; {</span>
 <span class="s0">*       reject(new Error('this will cause the test to fail'));</span>
 <span class="s0">*     });</span>
 <span class="s0">*   });</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* test('callback passing test', (t, done) =&gt; {</span>
 <span class="s0">*   // done() is the callback function. When the setImmediate() runs, it invokes</span>
 <span class="s0">*   // done() with no arguments.</span>
 <span class="s0">*   setImmediate(done);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* test('callback failing test', (t, done) =&gt; {</span>
 <span class="s0">*   // When the setImmediate() runs, done() is invoked with an Error object and</span>
 <span class="s0">*   // the test fails.</span>
 <span class="s0">*   setImmediate(() =&gt; {</span>
 <span class="s0">*     done(new Error('callback failure'));</span>
 <span class="s0">*   });</span>
 <span class="s0">* });</span>
 <span class="s0">* ```</span>
 <span class="s0">*</span>
 <span class="s0">* If any tests fail, the process exit code is set to `1`.</span>
 <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.0.0, v16.17.0</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[source](https://github.com/nodejs/node/blob/v20.13.1/lib/test.js)</span>
 <span class="s0">*/</span>
<span class="s2">declare module </span><span class="s3">&quot;node:test&quot; </span><span class="s2">{</span>
    <span class="s4">import </span><span class="s2">{ AssertMethodNames } from </span><span class="s3">&quot;node:assert&quot;</span><span class="s2">;</span>
    <span class="s4">import </span><span class="s2">{ Readable } from </span><span class="s3">&quot;node:stream&quot;</span><span class="s2">;</span>
    <span class="s4">import </span><span class="s2">TestFn = test.TestFn;</span>
    <span class="s4">import </span><span class="s2">TestOptions = test.TestOptions;</span>
    <span class="s0">/**</span>
     <span class="s0">* The `test()` function is the value imported from the `test` module. Each</span>
     <span class="s0">* invocation of this function results in reporting the test to the `TestsStream`.</span>
     <span class="s0">*</span>
     <span class="s0">* The `TestContext` object passed to the `fn` argument can be used to perform</span>
     <span class="s0">* actions related to the current test. Examples include skipping the test, adding</span>
     <span class="s0">* additional diagnostic information, or creating subtests.</span>
     <span class="s0">*</span>
     <span class="s0">* `test()` returns a `Promise` that fulfills once the test completes.</span>
     <span class="s0">* if `test()` is called within a suite, it fulfills immediately.</span>
     <span class="s0">* The return value can usually be discarded for top level tests.</span>
     <span class="s0">* However, the return value from subtests should be used to prevent the parent</span>
     <span class="s0">* test from finishing first and cancelling the subtest</span>
     <span class="s0">* as shown in the following example.</span>
     <span class="s0">*</span>
     <span class="s0">* ```js</span>
     <span class="s0">* test('top level test', async (t) =&gt; {</span>
     <span class="s0">*   // The setTimeout() in the following subtest would cause it to outlive its</span>
     <span class="s0">*   // parent test if 'await' is removed on the next line. Once the parent test</span>
     <span class="s0">*   // completes, it will cancel any outstanding subtests.</span>
     <span class="s0">*   await t.test('longer running subtest', async (t) =&gt; {</span>
     <span class="s0">*     return new Promise((resolve, reject) =&gt; {</span>
     <span class="s0">*       setTimeout(resolve, 1000);</span>
     <span class="s0">*     });</span>
     <span class="s0">*   });</span>
     <span class="s0">* });</span>
     <span class="s0">* ```</span>
     <span class="s0">*</span>
     <span class="s0">* The `timeout` option can be used to fail the test if it takes longer than `timeout` milliseconds to complete. However, it is not a reliable mechanism for</span>
     <span class="s0">* canceling tests because a running test might block the application thread and</span>
     <span class="s0">* thus prevent the scheduled cancellation.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.0.0, v16.17.0</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">name The name of the test, which is displayed when reporting test results.</span>
     <span class="s0">* Defaults to the `name` property of `fn`, or `'&lt;anonymous&gt;'` if `fn` does not have a name.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Configuration options for the test.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn The function under test. The first argument to this function is a {</span><span class="s1">@link </span><span class="s0">TestContext} object.</span>
     <span class="s0">* If the test uses callbacks, the callback function is passed as the second argument.</span>
     <span class="s0">* </span><span class="s1">@return </span><span class="s0">Fulfilled with `undefined` once the test completes, or immediately if the test runs within a suite.</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">test(name?: string, fn?: TestFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
    <span class="s4">function </span><span class="s2">test(name?: string, options?: TestOptions, fn?: TestFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
    <span class="s4">function </span><span class="s2">test(options?: TestOptions, fn?: TestFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
    <span class="s4">function </span><span class="s2">test(fn?: TestFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
    <span class="s2">namespace test {</span>
        <span class="s4">export </span><span class="s2">{ test };</span>
        <span class="s4">export </span><span class="s2">{ suite as describe, test as it };</span>
    <span class="s2">}</span>
    <span class="s2">namespace test {</span>
        <span class="s0">/**</span>
         <span class="s0">* **Note:** `shard` is used to horizontally parallelize test running across</span>
         <span class="s0">* machines or processes, ideal for large-scale executions across varied</span>
         <span class="s0">* environments. It's incompatible with `watch` mode, tailored for rapid</span>
         <span class="s0">* code iteration by automatically rerunning tests on file changes.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import { tap } from 'node:test/reporters';</span>
         <span class="s0">* import { run } from 'node:test';</span>
         <span class="s0">* import process from 'node:process';</span>
         <span class="s0">* import path from 'node:path';</span>
         <span class="s0">*</span>
         <span class="s0">* run({ files: [path.resolve('./tests/test.js')] })</span>
         <span class="s0">*   .compose(tap)</span>
         <span class="s0">*   .pipe(process.stdout);</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.9.0, v16.19.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Configuration options for running tests.</span>
         <span class="s0">*/</span>
        <span class="s4">function </span><span class="s2">run(options?: RunOptions): TestsStream;</span>
        <span class="s0">/**</span>
         <span class="s0">* The `suite()` function is imported from the `node:test` module.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">name The name of the suite, which is displayed when reporting test results.</span>
         <span class="s0">* Defaults to the `name` property of `fn`, or `'&lt;anonymous&gt;'` if `fn` does not have a name.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Configuration options for the suite. This supports the same options as {</span><span class="s1">@link </span><span class="s0">test}.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn The suite function declaring nested tests and suites. The first argument to this function is a {</span><span class="s1">@link </span><span class="s0">SuiteContext} object.</span>
         <span class="s0">* </span><span class="s1">@return </span><span class="s0">Immediately fulfilled with `undefined`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.13.0</span>
         <span class="s0">*/</span>
        <span class="s4">function </span><span class="s2">suite(name?: string, options?: TestOptions, fn?: SuiteFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s4">function </span><span class="s2">suite(name?: string, fn?: SuiteFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s4">function </span><span class="s2">suite(options?: TestOptions, fn?: SuiteFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s4">function </span><span class="s2">suite(fn?: SuiteFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s2">namespace suite {</span>
            <span class="s0">/**</span>
             <span class="s0">* Shorthand for skipping a suite. This is the same as calling {</span><span class="s1">@link </span><span class="s0">suite} with `options.skip` set to `true`.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.13.0</span>
             <span class="s0">*/</span>
            <span class="s4">function </span><span class="s2">skip(name?: string, options?: TestOptions, fn?: SuiteFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
            <span class="s4">function </span><span class="s2">skip(name?: string, fn?: SuiteFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
            <span class="s4">function </span><span class="s2">skip(options?: TestOptions, fn?: SuiteFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
            <span class="s4">function </span><span class="s2">skip(fn?: SuiteFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
            <span class="s0">/**</span>
             <span class="s0">* Shorthand for marking a suite as `TODO`. This is the same as calling {</span><span class="s1">@link </span><span class="s0">suite} with `options.todo` set to `true`.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.13.0</span>
             <span class="s0">*/</span>
            <span class="s4">function </span><span class="s2">todo(name?: string, options?: TestOptions, fn?: SuiteFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
            <span class="s4">function </span><span class="s2">todo(name?: string, fn?: SuiteFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
            <span class="s4">function </span><span class="s2">todo(options?: TestOptions, fn?: SuiteFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
            <span class="s4">function </span><span class="s2">todo(fn?: SuiteFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
            <span class="s0">/**</span>
             <span class="s0">* Shorthand for marking a suite as `only`. This is the same as calling {</span><span class="s1">@link </span><span class="s0">suite} with `options.only` set to `true`.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.13.0</span>
             <span class="s0">*/</span>
            <span class="s4">function </span><span class="s2">only(name?: string, options?: TestOptions, fn?: SuiteFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
            <span class="s4">function </span><span class="s2">only(name?: string, fn?: SuiteFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
            <span class="s4">function </span><span class="s2">only(options?: TestOptions, fn?: SuiteFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
            <span class="s4">function </span><span class="s2">only(fn?: SuiteFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s2">}</span>
        <span class="s0">/**</span>
         <span class="s0">* Shorthand for skipping a test. This is the same as calling {</span><span class="s1">@link </span><span class="s0">test} with `options.skip` set to `true`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.2.0</span>
         <span class="s0">*/</span>
        <span class="s4">function </span><span class="s2">skip(name?: string, options?: TestOptions, fn?: TestFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s4">function </span><span class="s2">skip(name?: string, fn?: TestFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s4">function </span><span class="s2">skip(options?: TestOptions, fn?: TestFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s4">function </span><span class="s2">skip(fn?: TestFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Shorthand for marking a test as `TODO`. This is the same as calling {</span><span class="s1">@link </span><span class="s0">test} with `options.todo` set to `true`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.2.0</span>
         <span class="s0">*/</span>
        <span class="s4">function </span><span class="s2">todo(name?: string, options?: TestOptions, fn?: TestFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s4">function </span><span class="s2">todo(name?: string, fn?: TestFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s4">function </span><span class="s2">todo(options?: TestOptions, fn?: TestFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s4">function </span><span class="s2">todo(fn?: TestFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Shorthand for marking a test as `only`. This is the same as calling {</span><span class="s1">@link </span><span class="s0">test} with `options.only` set to `true`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.2.0</span>
         <span class="s0">*/</span>
        <span class="s4">function </span><span class="s2">only(name?: string, options?: TestOptions, fn?: TestFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s4">function </span><span class="s2">only(name?: string, fn?: TestFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s4">function </span><span class="s2">only(options?: TestOptions, fn?: TestFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s4">function </span><span class="s2">only(fn?: TestFn): Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* The type of a function passed to {</span><span class="s1">@link </span><span class="s0">test}. The first argument to this function is a {</span><span class="s1">@link </span><span class="s0">TestContext} object.</span>
         <span class="s0">* If the test uses callbacks, the callback function is passed as the second argument.</span>
         <span class="s0">*/</span>
        <span class="s2">type TestFn = (t: TestContext, done: (result?: any) =&gt; </span><span class="s4">void</span><span class="s2">) =&gt; </span><span class="s4">void </span><span class="s2">| Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* The type of a suite test function. The argument to this function is a {</span><span class="s1">@link </span><span class="s0">SuiteContext} object.</span>
         <span class="s0">*/</span>
        <span class="s2">type SuiteFn = (s: SuiteContext) =&gt; </span><span class="s4">void </span><span class="s2">| Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s4">interface </span><span class="s2">TestShard {</span>
            <span class="s0">/**</span>
             <span class="s0">* A positive integer between 1 and `total` that specifies the index of the shard to run.</span>
             <span class="s0">*/</span>
            <span class="s2">index: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* A positive integer that specifies the total number of shards to split the test files to.</span>
             <span class="s0">*/</span>
            <span class="s2">total: number;</span>
        <span class="s2">}</span>
        <span class="s4">interface </span><span class="s2">RunOptions {</span>
            <span class="s0">/**</span>
             <span class="s0">* If a number is provided, then that many test processes would run in parallel, where each process corresponds to one test file.</span>
             <span class="s0">* If `true`, it would run `os.availableParallelism() - 1` test files in parallel. If `false`, it would only run one test file at a time.</span>
             <span class="s0">* </span><span class="s1">@default </span><span class="s0">false</span>
             <span class="s0">*/</span>
            <span class="s2">concurrency?: number | boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* An array containing the list of files to run. If omitted, files are run according to the</span>
             <span class="s0">* [test runner execution model](https://nodejs.org/docs/latest-v20.x/api/test.html#test-runner-execution-model).</span>
             <span class="s0">*/</span>
            <span class="s2">files?: readonly string[] | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Configures the test runner to exit the process once all known</span>
             <span class="s0">* tests have finished executing even if the event loop would</span>
             <span class="s0">* otherwise remain active.</span>
             <span class="s0">* </span><span class="s1">@default </span><span class="s0">false</span>
             <span class="s0">*/</span>
            <span class="s2">forceExit?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Sets inspector port of test child process.</span>
             <span class="s0">* If a nullish value is provided, each process gets its own port,</span>
             <span class="s0">* incremented from the primary's `process.debugPort`.</span>
             <span class="s0">* </span><span class="s1">@default </span><span class="s0">undefined</span>
             <span class="s0">*/</span>
            <span class="s2">inspectPort?: number | (() =&gt; number) | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* If truthy, the test context will only run tests that have the `only` option set</span>
             <span class="s0">*/</span>
            <span class="s2">only?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* A function that accepts the `TestsStream` instance and can be used to setup listeners before any tests are run.</span>
             <span class="s0">* </span><span class="s1">@default </span><span class="s0">undefined</span>
             <span class="s0">*/</span>
            <span class="s2">setup?: ((reporter: TestsStream) =&gt; </span><span class="s4">void </span><span class="s2">| Promise&lt;</span><span class="s4">void</span><span class="s2">&gt;) | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Allows aborting an in-progress test execution.</span>
             <span class="s0">*/</span>
            <span class="s2">signal?: AbortSignal | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* If provided, only run tests whose name matches the provided pattern.</span>
             <span class="s0">* Strings are interpreted as JavaScript regular expressions.</span>
             <span class="s0">* </span><span class="s1">@default </span><span class="s0">undefined</span>
             <span class="s0">*/</span>
            <span class="s2">testNamePatterns?: string | RegExp | ReadonlyArray&lt;string | RegExp&gt; | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* The number of milliseconds after which the test execution will fail.</span>
             <span class="s0">* If unspecified, subtests inherit this value from their parent.</span>
             <span class="s0">* </span><span class="s1">@default </span><span class="s0">Infinity</span>
             <span class="s0">*/</span>
            <span class="s2">timeout?: number | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Whether to run in watch mode or not.</span>
             <span class="s0">* </span><span class="s1">@default </span><span class="s0">false</span>
             <span class="s0">*/</span>
            <span class="s2">watch?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Running tests in a specific shard.</span>
             <span class="s0">* </span><span class="s1">@default </span><span class="s0">undefined</span>
             <span class="s0">*/</span>
            <span class="s2">shard?: TestShard | undefined;</span>
        <span class="s2">}</span>
        <span class="s0">/**</span>
         <span class="s0">* A successful call to `run()` will return a new `TestsStream` object, streaming a series of events representing the execution of the tests.</span>
         <span class="s0">*</span>
         <span class="s0">* Some of the events are guaranteed to be emitted in the same order as the tests are defined, while others are emitted in the order that the tests execute.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.9.0, v16.19.0</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s2">TestsStream </span><span class="s4">extends </span><span class="s2">Readable {</span>
            <span class="s2">addListener(event: </span><span class="s3">&quot;test:coverage&quot;</span><span class="s2">, listener: (data: EventData.TestCoverage) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">addListener(event: </span><span class="s3">&quot;test:complete&quot;</span><span class="s2">, listener: (data: EventData.TestComplete) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">addListener(event: </span><span class="s3">&quot;test:dequeue&quot;</span><span class="s2">, listener: (data: EventData.TestDequeue) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">addListener(event: </span><span class="s3">&quot;test:diagnostic&quot;</span><span class="s2">, listener: (data: EventData.TestDiagnostic) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">addListener(event: </span><span class="s3">&quot;test:enqueue&quot;</span><span class="s2">, listener: (data: EventData.TestEnqueue) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">addListener(event: </span><span class="s3">&quot;test:fail&quot;</span><span class="s2">, listener: (data: EventData.TestFail) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">addListener(event: </span><span class="s3">&quot;test:pass&quot;</span><span class="s2">, listener: (data: EventData.TestPass) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">addListener(event: </span><span class="s3">&quot;test:plan&quot;</span><span class="s2">, listener: (data: EventData.TestPlan) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">addListener(event: </span><span class="s3">&quot;test:start&quot;</span><span class="s2">, listener: (data: EventData.TestStart) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">addListener(event: </span><span class="s3">&quot;test:stderr&quot;</span><span class="s2">, listener: (data: EventData.TestStderr) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">addListener(event: </span><span class="s3">&quot;test:stdout&quot;</span><span class="s2">, listener: (data: EventData.TestStdout) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">addListener(event: </span><span class="s3">&quot;test:watch:drained&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">addListener(event: string, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">emit(event: </span><span class="s3">&quot;test:coverage&quot;</span><span class="s2">, data: EventData.TestCoverage): boolean;</span>
            <span class="s2">emit(event: </span><span class="s3">&quot;test:complete&quot;</span><span class="s2">, data: EventData.TestComplete): boolean;</span>
            <span class="s2">emit(event: </span><span class="s3">&quot;test:dequeue&quot;</span><span class="s2">, data: EventData.TestDequeue): boolean;</span>
            <span class="s2">emit(event: </span><span class="s3">&quot;test:diagnostic&quot;</span><span class="s2">, data: EventData.TestDiagnostic): boolean;</span>
            <span class="s2">emit(event: </span><span class="s3">&quot;test:enqueue&quot;</span><span class="s2">, data: EventData.TestEnqueue): boolean;</span>
            <span class="s2">emit(event: </span><span class="s3">&quot;test:fail&quot;</span><span class="s2">, data: EventData.TestFail): boolean;</span>
            <span class="s2">emit(event: </span><span class="s3">&quot;test:pass&quot;</span><span class="s2">, data: EventData.TestPass): boolean;</span>
            <span class="s2">emit(event: </span><span class="s3">&quot;test:plan&quot;</span><span class="s2">, data: EventData.TestPlan): boolean;</span>
            <span class="s2">emit(event: </span><span class="s3">&quot;test:start&quot;</span><span class="s2">, data: EventData.TestStart): boolean;</span>
            <span class="s2">emit(event: </span><span class="s3">&quot;test:stderr&quot;</span><span class="s2">, data: EventData.TestStderr): boolean;</span>
            <span class="s2">emit(event: </span><span class="s3">&quot;test:stdout&quot;</span><span class="s2">, data: EventData.TestStdout): boolean;</span>
            <span class="s2">emit(event: </span><span class="s3">&quot;test:watch:drained&quot;</span><span class="s2">): boolean;</span>
            <span class="s2">emit(event: string | symbol, ...args: any[]): boolean;</span>
            <span class="s2">on(event: </span><span class="s3">&quot;test:coverage&quot;</span><span class="s2">, listener: (data: EventData.TestCoverage) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">on(event: </span><span class="s3">&quot;test:complete&quot;</span><span class="s2">, listener: (data: EventData.TestComplete) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">on(event: </span><span class="s3">&quot;test:dequeue&quot;</span><span class="s2">, listener: (data: EventData.TestDequeue) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">on(event: </span><span class="s3">&quot;test:diagnostic&quot;</span><span class="s2">, listener: (data: EventData.TestDiagnostic) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">on(event: </span><span class="s3">&quot;test:enqueue&quot;</span><span class="s2">, listener: (data: EventData.TestEnqueue) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">on(event: </span><span class="s3">&quot;test:fail&quot;</span><span class="s2">, listener: (data: EventData.TestFail) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">on(event: </span><span class="s3">&quot;test:pass&quot;</span><span class="s2">, listener: (data: EventData.TestPass) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">on(event: </span><span class="s3">&quot;test:plan&quot;</span><span class="s2">, listener: (data: EventData.TestPlan) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">on(event: </span><span class="s3">&quot;test:start&quot;</span><span class="s2">, listener: (data: EventData.TestStart) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">on(event: </span><span class="s3">&quot;test:stderr&quot;</span><span class="s2">, listener: (data: EventData.TestStderr) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">on(event: </span><span class="s3">&quot;test:stdout&quot;</span><span class="s2">, listener: (data: EventData.TestStdout) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">on(event: </span><span class="s3">&quot;test:watch:drained&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">on(event: string, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">once(event: </span><span class="s3">&quot;test:coverage&quot;</span><span class="s2">, listener: (data: EventData.TestCoverage) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">once(event: </span><span class="s3">&quot;test:complete&quot;</span><span class="s2">, listener: (data: EventData.TestComplete) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">once(event: </span><span class="s3">&quot;test:dequeue&quot;</span><span class="s2">, listener: (data: EventData.TestDequeue) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">once(event: </span><span class="s3">&quot;test:diagnostic&quot;</span><span class="s2">, listener: (data: EventData.TestDiagnostic) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">once(event: </span><span class="s3">&quot;test:enqueue&quot;</span><span class="s2">, listener: (data: EventData.TestEnqueue) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">once(event: </span><span class="s3">&quot;test:fail&quot;</span><span class="s2">, listener: (data: EventData.TestFail) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">once(event: </span><span class="s3">&quot;test:pass&quot;</span><span class="s2">, listener: (data: EventData.TestPass) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">once(event: </span><span class="s3">&quot;test:plan&quot;</span><span class="s2">, listener: (data: EventData.TestPlan) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">once(event: </span><span class="s3">&quot;test:start&quot;</span><span class="s2">, listener: (data: EventData.TestStart) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">once(event: </span><span class="s3">&quot;test:stderr&quot;</span><span class="s2">, listener: (data: EventData.TestStderr) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">once(event: </span><span class="s3">&quot;test:stdout&quot;</span><span class="s2">, listener: (data: EventData.TestStdout) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">once(event: </span><span class="s3">&quot;test:watch:drained&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">once(event: string, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependListener(event: </span><span class="s3">&quot;test:coverage&quot;</span><span class="s2">, listener: (data: EventData.TestCoverage) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependListener(event: </span><span class="s3">&quot;test:complete&quot;</span><span class="s2">, listener: (data: EventData.TestComplete) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependListener(event: </span><span class="s3">&quot;test:dequeue&quot;</span><span class="s2">, listener: (data: EventData.TestDequeue) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependListener(event: </span><span class="s3">&quot;test:diagnostic&quot;</span><span class="s2">, listener: (data: EventData.TestDiagnostic) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependListener(event: </span><span class="s3">&quot;test:enqueue&quot;</span><span class="s2">, listener: (data: EventData.TestEnqueue) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependListener(event: </span><span class="s3">&quot;test:fail&quot;</span><span class="s2">, listener: (data: EventData.TestFail) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependListener(event: </span><span class="s3">&quot;test:pass&quot;</span><span class="s2">, listener: (data: EventData.TestPass) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependListener(event: </span><span class="s3">&quot;test:plan&quot;</span><span class="s2">, listener: (data: EventData.TestPlan) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependListener(event: </span><span class="s3">&quot;test:start&quot;</span><span class="s2">, listener: (data: EventData.TestStart) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependListener(event: </span><span class="s3">&quot;test:stderr&quot;</span><span class="s2">, listener: (data: EventData.TestStderr) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependListener(event: </span><span class="s3">&quot;test:stdout&quot;</span><span class="s2">, listener: (data: EventData.TestStdout) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependListener(event: </span><span class="s3">&quot;test:watch:drained&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependListener(event: string, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;test:coverage&quot;</span><span class="s2">, listener: (data: EventData.TestCoverage) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;test:complete&quot;</span><span class="s2">, listener: (data: EventData.TestComplete) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;test:dequeue&quot;</span><span class="s2">, listener: (data: EventData.TestDequeue) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;test:diagnostic&quot;</span><span class="s2">, listener: (data: EventData.TestDiagnostic) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;test:enqueue&quot;</span><span class="s2">, listener: (data: EventData.TestEnqueue) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;test:fail&quot;</span><span class="s2">, listener: (data: EventData.TestFail) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;test:pass&quot;</span><span class="s2">, listener: (data: EventData.TestPass) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;test:plan&quot;</span><span class="s2">, listener: (data: EventData.TestPlan) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;test:start&quot;</span><span class="s2">, listener: (data: EventData.TestStart) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;test:stderr&quot;</span><span class="s2">, listener: (data: EventData.TestStderr) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;test:stdout&quot;</span><span class="s2">, listener: (data: EventData.TestStdout) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;test:watch:drained&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
            <span class="s2">prependOnceListener(event: string, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s2">namespace EventData {</span>
            <span class="s4">interface </span><span class="s2">Error </span><span class="s4">extends </span><span class="s2">globalThis.Error {</span>
                <span class="s2">cause: globalThis.Error;</span>
            <span class="s2">}</span>
            <span class="s4">interface </span><span class="s2">LocationInfo {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The column number where the test is defined, or</span>
                 <span class="s0">* `undefined` if the test was run through the REPL.</span>
                 <span class="s0">*/</span>
                <span class="s2">column?: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The path of the test file, `undefined` if test was run through the REPL.</span>
                 <span class="s0">*/</span>
                <span class="s2">file?: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The line number where the test is defined, or `undefined` if the test was run through the REPL.</span>
                 <span class="s0">*/</span>
                <span class="s2">line?: number;</span>
            <span class="s2">}</span>
            <span class="s4">interface </span><span class="s2">TestDiagnostic </span><span class="s4">extends </span><span class="s2">LocationInfo {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The diagnostic message.</span>
                 <span class="s0">*/</span>
                <span class="s2">message: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The nesting level of the test.</span>
                 <span class="s0">*/</span>
                <span class="s2">nesting: number;</span>
            <span class="s2">}</span>
            <span class="s4">interface </span><span class="s2">TestCoverage {</span>
                <span class="s0">/**</span>
                 <span class="s0">* An object containing the coverage report.</span>
                 <span class="s0">*/</span>
                <span class="s2">summary: {</span>
                    <span class="s0">/**</span>
                     <span class="s0">* An array of coverage reports for individual files.</span>
                     <span class="s0">*/</span>
                    <span class="s2">files: Array&lt;{</span>
                        <span class="s0">/**</span>
                         <span class="s0">* The absolute path of the file.</span>
                         <span class="s0">*/</span>
                        <span class="s2">path: string;</span>
                        <span class="s0">/**</span>
                         <span class="s0">* The total number of lines.</span>
                         <span class="s0">*/</span>
                        <span class="s2">totalLineCount: number;</span>
                        <span class="s0">/**</span>
                         <span class="s0">* The total number of branches.</span>
                         <span class="s0">*/</span>
                        <span class="s2">totalBranchCount: number;</span>
                        <span class="s0">/**</span>
                         <span class="s0">* The total number of functions.</span>
                         <span class="s0">*/</span>
                        <span class="s2">totalFunctionCount: number;</span>
                        <span class="s0">/**</span>
                         <span class="s0">* The number of covered lines.</span>
                         <span class="s0">*/</span>
                        <span class="s2">coveredLineCount: number;</span>
                        <span class="s0">/**</span>
                         <span class="s0">* The number of covered branches.</span>
                         <span class="s0">*/</span>
                        <span class="s2">coveredBranchCount: number;</span>
                        <span class="s0">/**</span>
                         <span class="s0">* The number of covered functions.</span>
                         <span class="s0">*/</span>
                        <span class="s2">coveredFunctionCount: number;</span>
                        <span class="s0">/**</span>
                         <span class="s0">* The percentage of lines covered.</span>
                         <span class="s0">*/</span>
                        <span class="s2">coveredLinePercent: number;</span>
                        <span class="s0">/**</span>
                         <span class="s0">* The percentage of branches covered.</span>
                         <span class="s0">*/</span>
                        <span class="s2">coveredBranchPercent: number;</span>
                        <span class="s0">/**</span>
                         <span class="s0">* The percentage of functions covered.</span>
                         <span class="s0">*/</span>
                        <span class="s2">coveredFunctionPercent: number;</span>
                        <span class="s0">/**</span>
                         <span class="s0">* An array of functions representing function coverage.</span>
                         <span class="s0">*/</span>
                        <span class="s2">functions: Array&lt;{</span>
                            <span class="s0">/**</span>
                             <span class="s0">* The name of the function.</span>
                             <span class="s0">*/</span>
                            <span class="s2">name: string;</span>
                            <span class="s0">/**</span>
                             <span class="s0">* The line number where the function is defined.</span>
                             <span class="s0">*/</span>
                            <span class="s2">line: number;</span>
                            <span class="s0">/**</span>
                             <span class="s0">* The number of times the function was called.</span>
                             <span class="s0">*/</span>
                            <span class="s2">count: number;</span>
                        <span class="s2">}&gt;;</span>
                        <span class="s0">/**</span>
                         <span class="s0">* An array of branches representing branch coverage.</span>
                         <span class="s0">*/</span>
                        <span class="s2">branches: Array&lt;{</span>
                            <span class="s0">/**</span>
                             <span class="s0">* The line number where the branch is defined.</span>
                             <span class="s0">*/</span>
                            <span class="s2">line: number;</span>
                            <span class="s0">/**</span>
                             <span class="s0">* The number of times the branch was taken.</span>
                             <span class="s0">*/</span>
                            <span class="s2">count: number;</span>
                        <span class="s2">}&gt;;</span>
                        <span class="s0">/**</span>
                         <span class="s0">* An array of lines representing line numbers and the number of times they were covered.</span>
                         <span class="s0">*/</span>
                        <span class="s2">lines: Array&lt;{</span>
                            <span class="s0">/**</span>
                             <span class="s0">* The line number.</span>
                             <span class="s0">*/</span>
                            <span class="s2">line: number;</span>
                            <span class="s0">/**</span>
                             <span class="s0">* The number of times the line was covered.</span>
                             <span class="s0">*/</span>
                            <span class="s2">count: number;</span>
                        <span class="s2">}&gt;;</span>
                    <span class="s2">}&gt;;</span>
                    <span class="s0">/**</span>
                     <span class="s0">* An object containing a summary of coverage for all files.</span>
                     <span class="s0">*/</span>
                    <span class="s2">totals: {</span>
                        <span class="s0">/**</span>
                         <span class="s0">* The total number of lines.</span>
                         <span class="s0">*/</span>
                        <span class="s2">totalLineCount: number;</span>
                        <span class="s0">/**</span>
                         <span class="s0">* The total number of branches.</span>
                         <span class="s0">*/</span>
                        <span class="s2">totalBranchCount: number;</span>
                        <span class="s0">/**</span>
                         <span class="s0">* The total number of functions.</span>
                         <span class="s0">*/</span>
                        <span class="s2">totalFunctionCount: number;</span>
                        <span class="s0">/**</span>
                         <span class="s0">* The number of covered lines.</span>
                         <span class="s0">*/</span>
                        <span class="s2">coveredLineCount: number;</span>
                        <span class="s0">/**</span>
                         <span class="s0">* The number of covered branches.</span>
                         <span class="s0">*/</span>
                        <span class="s2">coveredBranchCount: number;</span>
                        <span class="s0">/**</span>
                         <span class="s0">* The number of covered functions.</span>
                         <span class="s0">*/</span>
                        <span class="s2">coveredFunctionCount: number;</span>
                        <span class="s0">/**</span>
                         <span class="s0">* The percentage of lines covered.</span>
                         <span class="s0">*/</span>
                        <span class="s2">coveredLinePercent: number;</span>
                        <span class="s0">/**</span>
                         <span class="s0">* The percentage of branches covered.</span>
                         <span class="s0">*/</span>
                        <span class="s2">coveredBranchPercent: number;</span>
                        <span class="s0">/**</span>
                         <span class="s0">* The percentage of functions covered.</span>
                         <span class="s0">*/</span>
                        <span class="s2">coveredFunctionPercent: number;</span>
                    <span class="s2">};</span>
                    <span class="s0">/**</span>
                     <span class="s0">* The working directory when code coverage began. This</span>
                     <span class="s0">* is useful for displaying relative path names in case</span>
                     <span class="s0">* the tests changed the working directory of the Node.js process.</span>
                     <span class="s0">*/</span>
                    <span class="s2">workingDirectory: string;</span>
                <span class="s2">};</span>
                <span class="s0">/**</span>
                 <span class="s0">* The nesting level of the test.</span>
                 <span class="s0">*/</span>
                <span class="s2">nesting: number;</span>
            <span class="s2">}</span>
            <span class="s4">interface </span><span class="s2">TestComplete </span><span class="s4">extends </span><span class="s2">LocationInfo {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Additional execution metadata.</span>
                 <span class="s0">*/</span>
                <span class="s2">details: {</span>
                    <span class="s0">/**</span>
                     <span class="s0">* Whether the test passed or not.</span>
                     <span class="s0">*/</span>
                    <span class="s2">passed: boolean;</span>
                    <span class="s0">/**</span>
                     <span class="s0">* The duration of the test in milliseconds.</span>
                     <span class="s0">*/</span>
                    <span class="s2">duration_ms: number;</span>
                    <span class="s0">/**</span>
                     <span class="s0">* An error wrapping the error thrown by the test if it did not pass.</span>
                     <span class="s0">*/</span>
                    <span class="s2">error?: Error;</span>
                    <span class="s0">/**</span>
                     <span class="s0">* The type of the test, used to denote whether this is a suite.</span>
                     <span class="s0">*/</span>
                    <span class="s2">type?: </span><span class="s3">&quot;suite&quot;</span><span class="s2">;</span>
                <span class="s2">};</span>
                <span class="s0">/**</span>
                 <span class="s0">* The test name.</span>
                 <span class="s0">*/</span>
                <span class="s2">name: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The nesting level of the test.</span>
                 <span class="s0">*/</span>
                <span class="s2">nesting: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The ordinal number of the test.</span>
                 <span class="s0">*/</span>
                <span class="s2">testNumber: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Present if `context.todo` is called.</span>
                 <span class="s0">*/</span>
                <span class="s2">todo?: string | boolean;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Present if `context.skip` is called.</span>
                 <span class="s0">*/</span>
                <span class="s2">skip?: string | boolean;</span>
            <span class="s2">}</span>
            <span class="s4">interface </span><span class="s2">TestDequeue </span><span class="s4">extends </span><span class="s2">LocationInfo {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The test name.</span>
                 <span class="s0">*/</span>
                <span class="s2">name: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The nesting level of the test.</span>
                 <span class="s0">*/</span>
                <span class="s2">nesting: number;</span>
            <span class="s2">}</span>
            <span class="s4">interface </span><span class="s2">TestEnqueue </span><span class="s4">extends </span><span class="s2">LocationInfo {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The test name.</span>
                 <span class="s0">*/</span>
                <span class="s2">name: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The nesting level of the test.</span>
                 <span class="s0">*/</span>
                <span class="s2">nesting: number;</span>
            <span class="s2">}</span>
            <span class="s4">interface </span><span class="s2">TestFail </span><span class="s4">extends </span><span class="s2">LocationInfo {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Additional execution metadata.</span>
                 <span class="s0">*/</span>
                <span class="s2">details: {</span>
                    <span class="s0">/**</span>
                     <span class="s0">* The duration of the test in milliseconds.</span>
                     <span class="s0">*/</span>
                    <span class="s2">duration_ms: number;</span>
                    <span class="s0">/**</span>
                     <span class="s0">* An error wrapping the error thrown by the test.</span>
                     <span class="s0">*/</span>
                    <span class="s2">error: Error;</span>
                    <span class="s0">/**</span>
                     <span class="s0">* The type of the test, used to denote whether this is a suite.</span>
                     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.0.0, v19.9.0, v18.17.0</span>
                     <span class="s0">*/</span>
                    <span class="s2">type?: </span><span class="s3">&quot;suite&quot;</span><span class="s2">;</span>
                <span class="s2">};</span>
                <span class="s0">/**</span>
                 <span class="s0">* The test name.</span>
                 <span class="s0">*/</span>
                <span class="s2">name: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The nesting level of the test.</span>
                 <span class="s0">*/</span>
                <span class="s2">nesting: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The ordinal number of the test.</span>
                 <span class="s0">*/</span>
                <span class="s2">testNumber: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Present if `context.todo` is called.</span>
                 <span class="s0">*/</span>
                <span class="s2">todo?: string | boolean;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Present if `context.skip` is called.</span>
                 <span class="s0">*/</span>
                <span class="s2">skip?: string | boolean;</span>
            <span class="s2">}</span>
            <span class="s4">interface </span><span class="s2">TestPass </span><span class="s4">extends </span><span class="s2">LocationInfo {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Additional execution metadata.</span>
                 <span class="s0">*/</span>
                <span class="s2">details: {</span>
                    <span class="s0">/**</span>
                     <span class="s0">* The duration of the test in milliseconds.</span>
                     <span class="s0">*/</span>
                    <span class="s2">duration_ms: number;</span>
                    <span class="s0">/**</span>
                     <span class="s0">* The type of the test, used to denote whether this is a suite.</span>
                     <span class="s0">* </span><span class="s1">@since </span><span class="s0">20.0.0, 19.9.0, 18.17.0</span>
                     <span class="s0">*/</span>
                    <span class="s2">type?: </span><span class="s3">&quot;suite&quot;</span><span class="s2">;</span>
                <span class="s2">};</span>
                <span class="s0">/**</span>
                 <span class="s0">* The test name.</span>
                 <span class="s0">*/</span>
                <span class="s2">name: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The nesting level of the test.</span>
                 <span class="s0">*/</span>
                <span class="s2">nesting: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The ordinal number of the test.</span>
                 <span class="s0">*/</span>
                <span class="s2">testNumber: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Present if `context.todo` is called.</span>
                 <span class="s0">*/</span>
                <span class="s2">todo?: string | boolean;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Present if `context.skip` is called.</span>
                 <span class="s0">*/</span>
                <span class="s2">skip?: string | boolean;</span>
            <span class="s2">}</span>
            <span class="s4">interface </span><span class="s2">TestPlan </span><span class="s4">extends </span><span class="s2">LocationInfo {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The nesting level of the test.</span>
                 <span class="s0">*/</span>
                <span class="s2">nesting: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The number of subtests that have ran.</span>
                 <span class="s0">*/</span>
                <span class="s2">count: number;</span>
            <span class="s2">}</span>
            <span class="s4">interface </span><span class="s2">TestStart </span><span class="s4">extends </span><span class="s2">LocationInfo {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The test name.</span>
                 <span class="s0">*/</span>
                <span class="s2">name: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The nesting level of the test.</span>
                 <span class="s0">*/</span>
                <span class="s2">nesting: number;</span>
            <span class="s2">}</span>
            <span class="s4">interface </span><span class="s2">TestStderr {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The path of the test file.</span>
                 <span class="s0">*/</span>
                <span class="s2">file: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The message written to `stderr`.</span>
                 <span class="s0">*/</span>
                <span class="s2">message: string;</span>
            <span class="s2">}</span>
            <span class="s4">interface </span><span class="s2">TestStdout {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The path of the test file.</span>
                 <span class="s0">*/</span>
                <span class="s2">file: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The message written to `stdout`.</span>
                 <span class="s0">*/</span>
                <span class="s2">message: string;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s0">/**</span>
         <span class="s0">* An instance of `TestContext` is passed to each test function in order to</span>
         <span class="s0">* interact with the test runner. However, the `TestContext` constructor is not</span>
         <span class="s0">* exposed as part of the API.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.0.0, v16.17.0</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s2">TestContext {</span>
            <span class="s0">/**</span>
             <span class="s0">* An object containing assertion methods bound to the test context.</span>
             <span class="s0">* The top-level functions from the `node:assert` module are exposed here for the purpose of creating test plans.</span>
             <span class="s0">*</span>
             <span class="s0">* **Note:** Some of the functions from `node:assert` contain type assertions. If these are called via the</span>
             <span class="s0">* TestContext `assert` object, then the context parameter in the test's function signature **must be explicitly typed**</span>
             <span class="s0">* (ie. the parameter must have a type annotation), otherwise an error will be raised by the TypeScript compiler:</span>
             <span class="s0">* ```ts</span>
             <span class="s0">* import { test, type TestContext } from 'node:test';</span>
             <span class="s0">*</span>
             <span class="s0">* // The test function's context parameter must have a type annotation.</span>
             <span class="s0">* test('example', (t: TestContext) =&gt; {</span>
             <span class="s0">*   t.assert.deepStrictEqual(actual, expected);</span>
             <span class="s0">* });</span>
             <span class="s0">*</span>
             <span class="s0">* // Omitting the type annotation will result in a compilation error.</span>
             <span class="s0">* test('example', t =&gt; {</span>
             <span class="s0">*   t.assert.deepStrictEqual(actual, expected); // Error: 't' needs an explicit type annotation.</span>
             <span class="s0">* });</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.15.0</span>
             <span class="s0">*/</span>
            <span class="s2">readonly assert: TestContextAssert;</span>
            <span class="s0">/**</span>
             <span class="s0">* This function is used to create a hook running before subtest of the current test.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn The hook function. The first argument to this function is a `TestContext` object.</span>
             <span class="s0">* If the hook uses callbacks, the callback function is passed as the second argument.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Configuration options for the hook.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.1.0, v18.17.0</span>
             <span class="s0">*/</span>
            <span class="s2">before(fn?: TestContextHookFn, options?: HookOptions): </span><span class="s4">void</span><span class="s2">;</span>
            <span class="s0">/**</span>
             <span class="s0">* This function is used to create a hook running before each subtest of the current test.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn The hook function. The first argument to this function is a `TestContext` object.</span>
             <span class="s0">* If the hook uses callbacks, the callback function is passed as the second argument.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Configuration options for the hook.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.8.0</span>
             <span class="s0">*/</span>
            <span class="s2">beforeEach(fn?: TestContextHookFn, options?: HookOptions): </span><span class="s4">void</span><span class="s2">;</span>
            <span class="s0">/**</span>
             <span class="s0">* This function is used to create a hook that runs after the current test finishes.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn The hook function. The first argument to this function is a `TestContext` object.</span>
             <span class="s0">* If the hook uses callbacks, the callback function is passed as the second argument.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Configuration options for the hook.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.13.0</span>
             <span class="s0">*/</span>
            <span class="s2">after(fn?: TestContextHookFn, options?: HookOptions): </span><span class="s4">void</span><span class="s2">;</span>
            <span class="s0">/**</span>
             <span class="s0">* This function is used to create a hook running after each subtest of the current test.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn The hook function. The first argument to this function is a `TestContext` object.</span>
             <span class="s0">* If the hook uses callbacks, the callback function is passed as the second argument.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Configuration options for the hook.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.8.0</span>
             <span class="s0">*/</span>
            <span class="s2">afterEach(fn?: TestContextHookFn, options?: HookOptions): </span><span class="s4">void</span><span class="s2">;</span>
            <span class="s0">/**</span>
             <span class="s0">* This function is used to write diagnostics to the output. Any diagnostic</span>
             <span class="s0">* information is included at the end of the test's results. This function does</span>
             <span class="s0">* not return a value.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* test('top level test', (t) =&gt; {</span>
             <span class="s0">*   t.diagnostic('A diagnostic message');</span>
             <span class="s0">* });</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.0.0, v16.17.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">message Message to be reported.</span>
             <span class="s0">*/</span>
            <span class="s2">diagnostic(message: string): </span><span class="s4">void</span><span class="s2">;</span>
            <span class="s0">/**</span>
             <span class="s0">* The name of the test and each of its ancestors, separated by `&gt;`.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.16.0</span>
             <span class="s0">*/</span>
            <span class="s2">readonly fullName: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* The name of the test.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.8.0, v16.18.0</span>
             <span class="s0">*/</span>
            <span class="s2">readonly name: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Used to set the number of assertions and subtests that are expected to run within the test.</span>
             <span class="s0">* If the number of assertions and subtests that run does not match the expected count, the test will fail.</span>
             <span class="s0">*</span>
             <span class="s0">* To make sure assertions are tracked, the assert functions on `context.assert` must be used,</span>
             <span class="s0">* instead of importing from the `node:assert` module.</span>
             <span class="s0">* ```js</span>
             <span class="s0">* test('top level test', (t) =&gt; {</span>
             <span class="s0">*   t.plan(2);</span>
             <span class="s0">*   t.assert.ok('some relevant assertion here');</span>
             <span class="s0">*   t.test('subtest', () =&gt; {});</span>
             <span class="s0">* });</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* When working with asynchronous code, the `plan` function can be used to ensure that the correct number of assertions are run:</span>
             <span class="s0">* ```js</span>
             <span class="s0">* test('planning with streams', (t, done) =&gt; {</span>
             <span class="s0">*   function* generate() {</span>
             <span class="s0">*     yield 'a';</span>
             <span class="s0">*     yield 'b';</span>
             <span class="s0">*     yield 'c';</span>
             <span class="s0">*   }</span>
             <span class="s0">*   const expected = ['a', 'b', 'c'];</span>
             <span class="s0">*   t.plan(expected.length);</span>
             <span class="s0">*   const stream = Readable.from(generate());</span>
             <span class="s0">*   stream.on('data', (chunk) =&gt; {</span>
             <span class="s0">*     t.assert.strictEqual(chunk, expected.shift());</span>
             <span class="s0">*   });</span>
             <span class="s0">*   stream.on('end', () =&gt; {</span>
             <span class="s0">*     done();</span>
             <span class="s0">*   });</span>
             <span class="s0">* });</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.15.0</span>
             <span class="s0">*/</span>
            <span class="s2">plan(count: number): </span><span class="s4">void</span><span class="s2">;</span>
            <span class="s0">/**</span>
             <span class="s0">* If `shouldRunOnlyTests` is truthy, the test context will only run tests that</span>
             <span class="s0">* have the `only` option set. Otherwise, all tests are run. If Node.js was not</span>
             <span class="s0">* started with the `--test-only` command-line option, this function is a</span>
             <span class="s0">* no-op.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* test('top level test', (t) =&gt; {</span>
             <span class="s0">*   // The test context can be set to run subtests with the 'only' option.</span>
             <span class="s0">*   t.runOnly(true);</span>
             <span class="s0">*   return Promise.all([</span>
             <span class="s0">*     t.test('this subtest is now skipped'),</span>
             <span class="s0">*     t.test('this subtest is run', { only: true }),</span>
             <span class="s0">*   ]);</span>
             <span class="s0">* });</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.0.0, v16.17.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">shouldRunOnlyTests Whether or not to run `only` tests.</span>
             <span class="s0">*/</span>
            <span class="s2">runOnly(shouldRunOnlyTests: boolean): </span><span class="s4">void</span><span class="s2">;</span>
            <span class="s0">/**</span>
             <span class="s0">* ```js</span>
             <span class="s0">* test('top level test', async (t) =&gt; {</span>
             <span class="s0">*   await fetch('some/uri', { signal: t.signal });</span>
             <span class="s0">* });</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.7.0, v16.17.0</span>
             <span class="s0">*/</span>
            <span class="s2">readonly signal: AbortSignal;</span>
            <span class="s0">/**</span>
             <span class="s0">* This function causes the test's output to indicate the test as skipped. If `message` is provided, it is included in the output. Calling `skip()` does</span>
             <span class="s0">* not terminate execution of the test function. This function does not return a</span>
             <span class="s0">* value.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* test('top level test', (t) =&gt; {</span>
             <span class="s0">*   // Make sure to return here as well if the test contains additional logic.</span>
             <span class="s0">*   t.skip('this is skipped');</span>
             <span class="s0">* });</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.0.0, v16.17.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">message Optional skip message.</span>
             <span class="s0">*/</span>
            <span class="s2">skip(message?: string): </span><span class="s4">void</span><span class="s2">;</span>
            <span class="s0">/**</span>
             <span class="s0">* This function adds a `TODO` directive to the test's output. If `message` is</span>
             <span class="s0">* provided, it is included in the output. Calling `todo()` does not terminate</span>
             <span class="s0">* execution of the test function. This function does not return a value.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* test('top level test', (t) =&gt; {</span>
             <span class="s0">*   // This test is marked as `TODO`</span>
             <span class="s0">*   t.todo('this is a todo');</span>
             <span class="s0">* });</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.0.0, v16.17.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">message Optional `TODO` message.</span>
             <span class="s0">*/</span>
            <span class="s2">todo(message?: string): </span><span class="s4">void</span><span class="s2">;</span>
            <span class="s0">/**</span>
             <span class="s0">* This function is used to create subtests under the current test. This function behaves in</span>
             <span class="s0">* the same fashion as the top level {</span><span class="s1">@link </span><span class="s0">test} function.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.0.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">name The name of the test, which is displayed when reporting test results.</span>
             <span class="s0">* Defaults to the `name` property of `fn`, or `'&lt;anonymous&gt;'` if `fn` does not have a name.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Configuration options for the test.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn The function under test. This first argument to this function is a {</span><span class="s1">@link </span><span class="s0">TestContext} object.</span>
             <span class="s0">* If the test uses callbacks, the callback function is passed as the second argument.</span>
             <span class="s0">* </span><span class="s1">@returns </span><span class="s0">A {</span><span class="s1">@link </span><span class="s0">Promise} resolved with `undefined` once the test completes.</span>
             <span class="s0">*/</span>
            <span class="s2">test: </span><span class="s4">typeof </span><span class="s2">test;</span>
            <span class="s0">/**</span>
             <span class="s0">* Each test provides its own MockTracker instance.</span>
             <span class="s0">*/</span>
            <span class="s2">readonly mock: MockTracker;</span>
        <span class="s2">}</span>
        <span class="s4">interface </span><span class="s2">TestContextAssert </span><span class="s4">extends </span><span class="s2">Pick&lt;</span><span class="s4">typeof import</span><span class="s2">(</span><span class="s3">&quot;assert&quot;</span><span class="s2">), AssertMethodNames&gt; {}</span>
        <span class="s0">/**</span>
         <span class="s0">* An instance of `SuiteContext` is passed to each suite function in order to</span>
         <span class="s0">* interact with the test runner. However, the `SuiteContext` constructor is not</span>
         <span class="s0">* exposed as part of the API.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.7.0, v16.17.0</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s2">SuiteContext {</span>
            <span class="s0">/**</span>
             <span class="s0">* The name of the suite.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.8.0, v16.18.0</span>
             <span class="s0">*/</span>
            <span class="s2">readonly name: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Can be used to abort test subtasks when the test has been aborted.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.7.0, v16.17.0</span>
             <span class="s0">*/</span>
            <span class="s2">readonly signal: AbortSignal;</span>
        <span class="s2">}</span>
        <span class="s4">interface </span><span class="s2">TestOptions {</span>
            <span class="s0">/**</span>
             <span class="s0">* If a number is provided, then that many tests would run in parallel.</span>
             <span class="s0">* If truthy, it would run (number of cpu cores - 1) tests in parallel.</span>
             <span class="s0">* For subtests, it will be `Infinity` tests in parallel.</span>
             <span class="s0">* If falsy, it would only run one test at a time.</span>
             <span class="s0">* If unspecified, subtests inherit this value from their parent.</span>
             <span class="s0">* </span><span class="s1">@default </span><span class="s0">false</span>
             <span class="s0">*/</span>
            <span class="s2">concurrency?: number | boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* If truthy, and the test context is configured to run `only` tests, then this test will be</span>
             <span class="s0">* run. Otherwise, the test is skipped.</span>
             <span class="s0">* </span><span class="s1">@default </span><span class="s0">false</span>
             <span class="s0">*/</span>
            <span class="s2">only?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Allows aborting an in-progress test.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.8.0</span>
             <span class="s0">*/</span>
            <span class="s2">signal?: AbortSignal | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* If truthy, the test is skipped. If a string is provided, that string is displayed in the</span>
             <span class="s0">* test results as the reason for skipping the test.</span>
             <span class="s0">* </span><span class="s1">@default </span><span class="s0">false</span>
             <span class="s0">*/</span>
            <span class="s2">skip?: boolean | string | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* A number of milliseconds the test will fail after. If unspecified, subtests inherit this</span>
             <span class="s0">* value from their parent.</span>
             <span class="s0">* </span><span class="s1">@default </span><span class="s0">Infinity</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.7.0</span>
             <span class="s0">*/</span>
            <span class="s2">timeout?: number | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* If truthy, the test marked as `TODO`. If a string is provided, that string is displayed in</span>
             <span class="s0">* the test results as the reason why the test is `TODO`.</span>
             <span class="s0">* </span><span class="s1">@default </span><span class="s0">false</span>
             <span class="s0">*/</span>
            <span class="s2">todo?: boolean | string | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* The number of assertions and subtests expected to be run in the test.</span>
             <span class="s0">* If the number of assertions run in the test does not match the number</span>
             <span class="s0">* specified in the plan, the test will fail.</span>
             <span class="s0">* </span><span class="s1">@default </span><span class="s0">undefined</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.15.0</span>
             <span class="s0">*/</span>
            <span class="s2">plan?: number | undefined;</span>
        <span class="s2">}</span>
        <span class="s0">/**</span>
         <span class="s0">* This function creates a hook that runs before executing a suite.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* describe('tests', async () =&gt; {</span>
         <span class="s0">*   before(() =&gt; console.log('about to run some test'));</span>
         <span class="s0">*   it('is a subtest', () =&gt; {</span>
         <span class="s0">*     assert.ok('some relevant assertion here');</span>
         <span class="s0">*   });</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.8.0, v16.18.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn The hook function. If the hook uses callbacks, the callback function is passed as the second argument.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Configuration options for the hook.</span>
         <span class="s0">*/</span>
        <span class="s4">function </span><span class="s2">before(fn?: HookFn, options?: HookOptions): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function creates a hook that runs after executing a suite.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* describe('tests', async () =&gt; {</span>
         <span class="s0">*   after(() =&gt; console.log('finished running tests'));</span>
         <span class="s0">*   it('is a subtest', () =&gt; {</span>
         <span class="s0">*     assert.ok('some relevant assertion here');</span>
         <span class="s0">*   });</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.8.0, v16.18.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn The hook function. If the hook uses callbacks, the callback function is passed as the second argument.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Configuration options for the hook.</span>
         <span class="s0">*/</span>
        <span class="s4">function </span><span class="s2">after(fn?: HookFn, options?: HookOptions): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function creates a hook that runs before each test in the current suite.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* describe('tests', async () =&gt; {</span>
         <span class="s0">*   beforeEach(() =&gt; console.log('about to run a test'));</span>
         <span class="s0">*   it('is a subtest', () =&gt; {</span>
         <span class="s0">*     assert.ok('some relevant assertion here');</span>
         <span class="s0">*   });</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.8.0, v16.18.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn The hook function. If the hook uses callbacks, the callback function is passed as the second argument.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Configuration options for the hook.</span>
         <span class="s0">*/</span>
        <span class="s4">function </span><span class="s2">beforeEach(fn?: HookFn, options?: HookOptions): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function creates a hook that runs after each test in the current suite.</span>
         <span class="s0">* The `afterEach()` hook is run even if the test fails.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* describe('tests', async () =&gt; {</span>
         <span class="s0">*   afterEach(() =&gt; console.log('finished running a test'));</span>
         <span class="s0">*   it('is a subtest', () =&gt; {</span>
         <span class="s0">*     assert.ok('some relevant assertion here');</span>
         <span class="s0">*   });</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.8.0, v16.18.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn The hook function. If the hook uses callbacks, the callback function is passed as the second argument.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Configuration options for the hook.</span>
         <span class="s0">*/</span>
        <span class="s4">function </span><span class="s2">afterEach(fn?: HookFn, options?: HookOptions): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The hook function. The first argument is the context in which the hook is called.</span>
         <span class="s0">* If the hook uses callbacks, the callback function is passed as the second argument.</span>
         <span class="s0">*/</span>
        <span class="s2">type HookFn = (c: TestContext | SuiteContext, done: (result?: any) =&gt; </span><span class="s4">void</span><span class="s2">) =&gt; any;</span>
        <span class="s0">/**</span>
         <span class="s0">* The hook function. The first argument is a `TestContext` object.</span>
         <span class="s0">* If the hook uses callbacks, the callback function is passed as the second argument.</span>
         <span class="s0">*/</span>
        <span class="s2">type TestContextHookFn = (t: TestContext, done: (result?: any) =&gt; </span><span class="s4">void</span><span class="s2">) =&gt; any;</span>
        <span class="s0">/**</span>
         <span class="s0">* Configuration options for hooks.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.8.0</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s2">HookOptions {</span>
            <span class="s0">/**</span>
             <span class="s0">* Allows aborting an in-progress hook.</span>
             <span class="s0">*/</span>
            <span class="s2">signal?: AbortSignal | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* A number of milliseconds the hook will fail after. If unspecified, subtests inherit this</span>
             <span class="s0">* value from their parent.</span>
             <span class="s0">* </span><span class="s1">@default </span><span class="s0">Infinity</span>
             <span class="s0">*/</span>
            <span class="s2">timeout?: number | undefined;</span>
        <span class="s2">}</span>
        <span class="s4">interface </span><span class="s2">MockFunctionOptions {</span>
            <span class="s0">/**</span>
             <span class="s0">* The number of times that the mock will use the behavior of `implementation`.</span>
             <span class="s0">* Once the mock function has been called `times` times,</span>
             <span class="s0">* it will automatically restore the behavior of `original`.</span>
             <span class="s0">* This value must be an integer greater than zero.</span>
             <span class="s0">* </span><span class="s1">@default </span><span class="s0">Infinity</span>
             <span class="s0">*/</span>
            <span class="s2">times?: number | undefined;</span>
        <span class="s2">}</span>
        <span class="s4">interface </span><span class="s2">MockMethodOptions </span><span class="s4">extends </span><span class="s2">MockFunctionOptions {</span>
            <span class="s0">/**</span>
             <span class="s0">* If `true`, `object[methodName]` is treated as a getter.</span>
             <span class="s0">* This option cannot be used with the `setter` option.</span>
             <span class="s0">*/</span>
            <span class="s2">getter?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* If `true`, `object[methodName]` is treated as a setter.</span>
             <span class="s0">* This option cannot be used with the `getter` option.</span>
             <span class="s0">*/</span>
            <span class="s2">setter?: boolean | undefined;</span>
        <span class="s2">}</span>
        <span class="s2">type Mock&lt;F </span><span class="s4">extends </span><span class="s2">Function&gt; = F &amp; {</span>
            <span class="s2">mock: MockFunctionContext&lt;F&gt;;</span>
        <span class="s2">};</span>
        <span class="s4">interface </span><span class="s2">MockModuleOptions {</span>
            <span class="s0">/**</span>
             <span class="s0">* If false, each call to `require()` or `import()` generates a new mock module.</span>
             <span class="s0">* If true, subsequent calls will return the same module mock, and the mock module is inserted into the CommonJS cache.</span>
             <span class="s0">* </span><span class="s1">@default </span><span class="s0">false</span>
             <span class="s0">*/</span>
            <span class="s2">cache?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* The value to use as the mocked module's default export.</span>
             <span class="s0">*</span>
             <span class="s0">* If this value is not provided, ESM mocks do not include a default export.</span>
             <span class="s0">* If the mock is a CommonJS or builtin module, this setting is used as the value of `module.exports`.</span>
             <span class="s0">* If this value is not provided, CJS and builtin mocks use an empty object as the value of `module.exports`.</span>
             <span class="s0">*/</span>
            <span class="s2">defaultExport?: any;</span>
            <span class="s0">/**</span>
             <span class="s0">* An object whose keys and values are used to create the named exports of the mock module.</span>
             <span class="s0">*</span>
             <span class="s0">* If the mock is a CommonJS or builtin module, these values are copied onto `module.exports`.</span>
             <span class="s0">* Therefore, if a mock is created with both named exports and a non-object default export,</span>
             <span class="s0">* the mock will throw an exception when used as a CJS or builtin module.</span>
             <span class="s0">*/</span>
            <span class="s2">namedExports?: object | undefined;</span>
        <span class="s2">}</span>
        <span class="s0">/**</span>
         <span class="s0">* The `MockTracker` class is used to manage mocking functionality. The test runner</span>
         <span class="s0">* module provides a top level `mock` export which is a `MockTracker` instance.</span>
         <span class="s0">* Each test also provides its own `MockTracker` instance via the test context's `mock` property.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s2">MockTracker {</span>
            <span class="s0">/**</span>
             <span class="s0">* This function is used to create a mock function.</span>
             <span class="s0">*</span>
             <span class="s0">* The following example creates a mock function that increments a counter by one</span>
             <span class="s0">* on each invocation. The `times` option is used to modify the mock behavior such</span>
             <span class="s0">* that the first two invocations add two to the counter instead of one.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* test('mocks a counting function', (t) =&gt; {</span>
             <span class="s0">*   let cnt = 0;</span>
             <span class="s0">*</span>
             <span class="s0">*   function addOne() {</span>
             <span class="s0">*     cnt++;</span>
             <span class="s0">*     return cnt;</span>
             <span class="s0">*   }</span>
             <span class="s0">*</span>
             <span class="s0">*   function addTwo() {</span>
             <span class="s0">*     cnt += 2;</span>
             <span class="s0">*     return cnt;</span>
             <span class="s0">*   }</span>
             <span class="s0">*</span>
             <span class="s0">*   const fn = t.mock.fn(addOne, addTwo, { times: 2 });</span>
             <span class="s0">*</span>
             <span class="s0">*   assert.strictEqual(fn(), 2);</span>
             <span class="s0">*   assert.strictEqual(fn(), 4);</span>
             <span class="s0">*   assert.strictEqual(fn(), 5);</span>
             <span class="s0">*   assert.strictEqual(fn(), 6);</span>
             <span class="s0">* });</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">original An optional function to create a mock on.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">implementation An optional function used as the mock implementation for `original`. This is useful for creating mocks that exhibit one behavior for a specified number of calls and</span>
             <span class="s0">* then restore the behavior of `original`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Optional configuration options for the mock function.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">The mocked function. The mocked function contains a special `mock` property, which is an instance of {</span><span class="s1">@link </span><span class="s0">MockFunctionContext}, and can be used for inspecting and changing the</span>
             <span class="s0">* behavior of the mocked function.</span>
             <span class="s0">*/</span>
            <span class="s2">fn&lt;F </span><span class="s4">extends </span><span class="s2">Function = (...args: any[]) =&gt; undefined&gt;(</span>
                <span class="s2">original?: F,</span>
                <span class="s2">options?: MockFunctionOptions,</span>
            <span class="s2">): Mock&lt;F&gt;;</span>
            <span class="s2">fn&lt;F </span><span class="s4">extends </span><span class="s2">Function = (...args: any[]) =&gt; undefined, Implementation </span><span class="s4">extends </span><span class="s2">Function = F&gt;(</span>
                <span class="s2">original?: F,</span>
                <span class="s2">implementation?: Implementation,</span>
                <span class="s2">options?: MockFunctionOptions,</span>
            <span class="s2">): Mock&lt;F | Implementation&gt;;</span>
            <span class="s0">/**</span>
             <span class="s0">* This function is used to create a mock on an existing object method. The</span>
             <span class="s0">* following example demonstrates how a mock is created on an existing object</span>
             <span class="s0">* method.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* test('spies on an object method', (t) =&gt; {</span>
             <span class="s0">*   const number = {</span>
             <span class="s0">*     value: 5,</span>
             <span class="s0">*     subtract(a) {</span>
             <span class="s0">*       return this.value - a;</span>
             <span class="s0">*     },</span>
             <span class="s0">*   };</span>
             <span class="s0">*</span>
             <span class="s0">*   t.mock.method(number, 'subtract');</span>
             <span class="s0">*   assert.strictEqual(number.subtract.mock.calls.length, 0);</span>
             <span class="s0">*   assert.strictEqual(number.subtract(3), 2);</span>
             <span class="s0">*   assert.strictEqual(number.subtract.mock.calls.length, 1);</span>
             <span class="s0">*</span>
             <span class="s0">*   const call = number.subtract.mock.calls[0];</span>
             <span class="s0">*</span>
             <span class="s0">*   assert.deepStrictEqual(call.arguments, [3]);</span>
             <span class="s0">*   assert.strictEqual(call.result, 2);</span>
             <span class="s0">*   assert.strictEqual(call.error, undefined);</span>
             <span class="s0">*   assert.strictEqual(call.target, undefined);</span>
             <span class="s0">*   assert.strictEqual(call.this, number);</span>
             <span class="s0">* });</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">object The object whose method is being mocked.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">methodName The identifier of the method on `object` to mock. If `object[methodName]` is not a function, an error is thrown.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">implementation An optional function used as the mock implementation for `object[methodName]`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Optional configuration options for the mock method.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">The mocked method. The mocked method contains a special `mock` property, which is an instance of {</span><span class="s1">@link </span><span class="s0">MockFunctionContext}, and can be used for inspecting and changing the</span>
             <span class="s0">* behavior of the mocked method.</span>
             <span class="s0">*/</span>
            <span class="s2">method&lt;</span>
                <span class="s2">MockedObject </span><span class="s4">extends </span><span class="s2">object,</span>
                <span class="s2">MethodName </span><span class="s4">extends </span><span class="s2">FunctionPropertyNames&lt;MockedObject&gt;,</span>
            <span class="s2">&gt;(</span>
                <span class="s2">object: MockedObject,</span>
                <span class="s2">methodName: MethodName,</span>
                <span class="s2">options?: MockFunctionOptions,</span>
            <span class="s2">): MockedObject[MethodName] </span><span class="s4">extends </span><span class="s2">Function ? Mock&lt;MockedObject[MethodName]&gt;</span>
                <span class="s2">: never;</span>
            <span class="s2">method&lt;</span>
                <span class="s2">MockedObject </span><span class="s4">extends </span><span class="s2">object,</span>
                <span class="s2">MethodName </span><span class="s4">extends </span><span class="s2">FunctionPropertyNames&lt;MockedObject&gt;,</span>
                <span class="s2">Implementation </span><span class="s4">extends </span><span class="s2">Function,</span>
            <span class="s2">&gt;(</span>
                <span class="s2">object: MockedObject,</span>
                <span class="s2">methodName: MethodName,</span>
                <span class="s2">implementation: Implementation,</span>
                <span class="s2">options?: MockFunctionOptions,</span>
            <span class="s2">): MockedObject[MethodName] </span><span class="s4">extends </span><span class="s2">Function ? Mock&lt;MockedObject[MethodName] | Implementation&gt;</span>
                <span class="s2">: never;</span>
            <span class="s2">method&lt;MockedObject </span><span class="s4">extends </span><span class="s2">object&gt;(</span>
                <span class="s2">object: MockedObject,</span>
                <span class="s2">methodName: keyof MockedObject,</span>
                <span class="s2">options: MockMethodOptions,</span>
            <span class="s2">): Mock&lt;Function&gt;;</span>
            <span class="s2">method&lt;MockedObject </span><span class="s4">extends </span><span class="s2">object&gt;(</span>
                <span class="s2">object: MockedObject,</span>
                <span class="s2">methodName: keyof MockedObject,</span>
                <span class="s2">implementation: Function,</span>
                <span class="s2">options: MockMethodOptions,</span>
            <span class="s2">): Mock&lt;Function&gt;;</span>
            <span class="s0">/**</span>
             <span class="s0">* This function is syntax sugar for `MockTracker.method` with `options.getter` set to `true`.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.3.0, v18.13.0</span>
             <span class="s0">*/</span>
            <span class="s2">getter&lt;</span>
                <span class="s2">MockedObject </span><span class="s4">extends </span><span class="s2">object,</span>
                <span class="s2">MethodName </span><span class="s4">extends </span><span class="s2">keyof MockedObject,</span>
            <span class="s2">&gt;(</span>
                <span class="s2">object: MockedObject,</span>
                <span class="s2">methodName: MethodName,</span>
                <span class="s2">options?: MockFunctionOptions,</span>
            <span class="s2">): Mock&lt;() =&gt; MockedObject[MethodName]&gt;;</span>
            <span class="s2">getter&lt;</span>
                <span class="s2">MockedObject </span><span class="s4">extends </span><span class="s2">object,</span>
                <span class="s2">MethodName </span><span class="s4">extends </span><span class="s2">keyof MockedObject,</span>
                <span class="s2">Implementation </span><span class="s4">extends </span><span class="s2">Function,</span>
            <span class="s2">&gt;(</span>
                <span class="s2">object: MockedObject,</span>
                <span class="s2">methodName: MethodName,</span>
                <span class="s2">implementation?: Implementation,</span>
                <span class="s2">options?: MockFunctionOptions,</span>
            <span class="s2">): Mock&lt;(() =&gt; MockedObject[MethodName]) | Implementation&gt;;</span>
            <span class="s0">/**</span>
             <span class="s0">* This function is syntax sugar for `MockTracker.method` with `options.setter` set to `true`.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.3.0, v18.13.0</span>
             <span class="s0">*/</span>
            <span class="s2">setter&lt;</span>
                <span class="s2">MockedObject </span><span class="s4">extends </span><span class="s2">object,</span>
                <span class="s2">MethodName </span><span class="s4">extends </span><span class="s2">keyof MockedObject,</span>
            <span class="s2">&gt;(</span>
                <span class="s2">object: MockedObject,</span>
                <span class="s2">methodName: MethodName,</span>
                <span class="s2">options?: MockFunctionOptions,</span>
            <span class="s2">): Mock&lt;(value: MockedObject[MethodName]) =&gt; </span><span class="s4">void</span><span class="s2">&gt;;</span>
            <span class="s2">setter&lt;</span>
                <span class="s2">MockedObject </span><span class="s4">extends </span><span class="s2">object,</span>
                <span class="s2">MethodName </span><span class="s4">extends </span><span class="s2">keyof MockedObject,</span>
                <span class="s2">Implementation </span><span class="s4">extends </span><span class="s2">Function,</span>
            <span class="s2">&gt;(</span>
                <span class="s2">object: MockedObject,</span>
                <span class="s2">methodName: MethodName,</span>
                <span class="s2">implementation?: Implementation,</span>
                <span class="s2">options?: MockFunctionOptions,</span>
            <span class="s2">): Mock&lt;((value: MockedObject[MethodName]) =&gt; </span><span class="s4">void</span><span class="s2">) | Implementation&gt;;</span>
            <span class="s0">/**</span>
             <span class="s0">* This function is used to mock the exports of ECMAScript modules, CommonJS modules, and Node.js builtin modules.</span>
             <span class="s0">* Any references to the original module prior to mocking are not impacted.</span>
             <span class="s0">*</span>
             <span class="s0">* Only available through the [--experimental-test-module-mocks](https://nodejs.org/api/cli.html#--experimental-test-module-mocks) flag.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.18.0</span>
             <span class="s0">* </span><span class="s1">@experimental</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">specifier A string identifying the module to mock.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Optional configuration options for the mock module.</span>
             <span class="s0">*/</span>
            <span class="s2">module(specifier: string, options?: MockModuleOptions): MockModuleContext;</span>
            <span class="s0">/**</span>
             <span class="s0">* This function restores the default behavior of all mocks that were previously</span>
             <span class="s0">* created by this `MockTracker` and disassociates the mocks from the `MockTracker` instance. Once disassociated, the mocks can still be used, but the `MockTracker` instance can no longer be</span>
             <span class="s0">* used to reset their behavior or</span>
             <span class="s0">* otherwise interact with them.</span>
             <span class="s0">*</span>
             <span class="s0">* After each test completes, this function is called on the test context's `MockTracker`. If the global `MockTracker` is used extensively, calling this</span>
             <span class="s0">* function manually is recommended.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0</span>
             <span class="s0">*/</span>
            <span class="s2">reset(): </span><span class="s4">void</span><span class="s2">;</span>
            <span class="s0">/**</span>
             <span class="s0">* This function restores the default behavior of all mocks that were previously</span>
             <span class="s0">* created by this `MockTracker`. Unlike `mock.reset()`, `mock.restoreAll()` does</span>
             <span class="s0">* not disassociate the mocks from the `MockTracker` instance.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0</span>
             <span class="s0">*/</span>
            <span class="s2">restoreAll(): </span><span class="s4">void</span><span class="s2">;</span>
            <span class="s2">readonly timers: MockTimers;</span>
        <span class="s2">}</span>
        <span class="s4">const </span><span class="s2">mock: MockTracker;</span>
        <span class="s4">interface </span><span class="s2">MockFunctionCall&lt;</span>
            <span class="s2">F </span><span class="s4">extends </span><span class="s2">Function,</span>
            <span class="s2">ReturnType = F </span><span class="s4">extends </span><span class="s2">(...args: any) =&gt; infer T ? T</span>
                <span class="s2">: F </span><span class="s4">extends </span><span class="s2">abstract </span><span class="s4">new</span><span class="s2">(...args: any) =&gt; infer T ? T</span>
                <span class="s2">: unknown,</span>
            <span class="s2">Args = F </span><span class="s4">extends </span><span class="s2">(...args: infer Y) =&gt; any ? Y</span>
                <span class="s2">: F </span><span class="s4">extends </span><span class="s2">abstract </span><span class="s4">new</span><span class="s2">(...args: infer Y) =&gt; any ? Y</span>
                <span class="s2">: unknown[],</span>
        <span class="s2">&gt; {</span>
            <span class="s0">/**</span>
             <span class="s0">* An array of the arguments passed to the mock function.</span>
             <span class="s0">*/</span>
            <span class="s2">arguments: Args;</span>
            <span class="s0">/**</span>
             <span class="s0">* If the mocked function threw then this property contains the thrown value.</span>
             <span class="s0">*/</span>
            <span class="s2">error: unknown | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* The value returned by the mocked function.</span>
             <span class="s0">*</span>
             <span class="s0">* If the mocked function threw, it will be `undefined`.</span>
             <span class="s0">*/</span>
            <span class="s2">result: ReturnType | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* An `Error` object whose stack can be used to determine the callsite of the mocked function invocation.</span>
             <span class="s0">*/</span>
            <span class="s2">stack: Error;</span>
            <span class="s0">/**</span>
             <span class="s0">* If the mocked function is a constructor, this field contains the class being constructed.</span>
             <span class="s0">* Otherwise this will be `undefined`.</span>
             <span class="s0">*/</span>
            <span class="s2">target: F </span><span class="s4">extends </span><span class="s2">abstract </span><span class="s4">new</span><span class="s2">(...args: any) =&gt; any ? F : undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* The mocked function's `this` value.</span>
             <span class="s0">*/</span>
            <span class="s4">this</span><span class="s2">: unknown;</span>
        <span class="s2">}</span>
        <span class="s0">/**</span>
         <span class="s0">* The `MockFunctionContext` class is used to inspect or manipulate the behavior of</span>
         <span class="s0">* mocks created via the `MockTracker` APIs.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s2">MockFunctionContext&lt;F </span><span class="s4">extends </span><span class="s2">Function&gt; {</span>
            <span class="s0">/**</span>
             <span class="s0">* A getter that returns a copy of the internal array used to track calls to the</span>
             <span class="s0">* mock. Each entry in the array is an object with the following properties.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0</span>
             <span class="s0">*/</span>
            <span class="s2">readonly calls: MockFunctionCall&lt;F&gt;[];</span>
            <span class="s0">/**</span>
             <span class="s0">* This function returns the number of times that this mock has been invoked. This</span>
             <span class="s0">* function is more efficient than checking `ctx.calls.length` because `ctx.calls` is a getter that creates a copy of the internal call tracking array.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">The number of times that this mock has been invoked.</span>
             <span class="s0">*/</span>
            <span class="s2">callCount(): number;</span>
            <span class="s0">/**</span>
             <span class="s0">* This function is used to change the behavior of an existing mock.</span>
             <span class="s0">*</span>
             <span class="s0">* The following example creates a mock function using `t.mock.fn()`, calls the</span>
             <span class="s0">* mock function, and then changes the mock implementation to a different function.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* test('changes a mock behavior', (t) =&gt; {</span>
             <span class="s0">*   let cnt = 0;</span>
             <span class="s0">*</span>
             <span class="s0">*   function addOne() {</span>
             <span class="s0">*     cnt++;</span>
             <span class="s0">*     return cnt;</span>
             <span class="s0">*   }</span>
             <span class="s0">*</span>
             <span class="s0">*   function addTwo() {</span>
             <span class="s0">*     cnt += 2;</span>
             <span class="s0">*     return cnt;</span>
             <span class="s0">*   }</span>
             <span class="s0">*</span>
             <span class="s0">*   const fn = t.mock.fn(addOne);</span>
             <span class="s0">*</span>
             <span class="s0">*   assert.strictEqual(fn(), 1);</span>
             <span class="s0">*   fn.mock.mockImplementation(addTwo);</span>
             <span class="s0">*   assert.strictEqual(fn(), 3);</span>
             <span class="s0">*   assert.strictEqual(fn(), 5);</span>
             <span class="s0">* });</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">implementation The function to be used as the mock's new implementation.</span>
             <span class="s0">*/</span>
            <span class="s2">mockImplementation(implementation: F): </span><span class="s4">void</span><span class="s2">;</span>
            <span class="s0">/**</span>
             <span class="s0">* This function is used to change the behavior of an existing mock for a single</span>
             <span class="s0">* invocation. Once invocation `onCall` has occurred, the mock will revert to</span>
             <span class="s0">* whatever behavior it would have used had `mockImplementationOnce()` not been</span>
             <span class="s0">* called.</span>
             <span class="s0">*</span>
             <span class="s0">* The following example creates a mock function using `t.mock.fn()`, calls the</span>
             <span class="s0">* mock function, changes the mock implementation to a different function for the</span>
             <span class="s0">* next invocation, and then resumes its previous behavior.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* test('changes a mock behavior once', (t) =&gt; {</span>
             <span class="s0">*   let cnt = 0;</span>
             <span class="s0">*</span>
             <span class="s0">*   function addOne() {</span>
             <span class="s0">*     cnt++;</span>
             <span class="s0">*     return cnt;</span>
             <span class="s0">*   }</span>
             <span class="s0">*</span>
             <span class="s0">*   function addTwo() {</span>
             <span class="s0">*     cnt += 2;</span>
             <span class="s0">*     return cnt;</span>
             <span class="s0">*   }</span>
             <span class="s0">*</span>
             <span class="s0">*   const fn = t.mock.fn(addOne);</span>
             <span class="s0">*</span>
             <span class="s0">*   assert.strictEqual(fn(), 1);</span>
             <span class="s0">*   fn.mock.mockImplementationOnce(addTwo);</span>
             <span class="s0">*   assert.strictEqual(fn(), 3);</span>
             <span class="s0">*   assert.strictEqual(fn(), 4);</span>
             <span class="s0">* });</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">implementation The function to be used as the mock's implementation for the invocation number specified by `onCall`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">onCall The invocation number that will use `implementation`. If the specified invocation has already occurred then an exception is thrown.</span>
             <span class="s0">*/</span>
            <span class="s2">mockImplementationOnce(implementation: F, onCall?: number): </span><span class="s4">void</span><span class="s2">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Resets the call history of the mock function.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.3.0, v18.13.0</span>
             <span class="s0">*/</span>
            <span class="s2">resetCalls(): </span><span class="s4">void</span><span class="s2">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Resets the implementation of the mock function to its original behavior. The</span>
             <span class="s0">* mock can still be used after calling this function.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0</span>
             <span class="s0">*/</span>
            <span class="s2">restore(): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.18.0</span>
         <span class="s0">* </span><span class="s1">@experimental</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s2">MockModuleContext {</span>
            <span class="s0">/**</span>
             <span class="s0">* Resets the implementation of the mock module.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.18.0</span>
             <span class="s0">*/</span>
            <span class="s2">restore(): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s4">interface </span><span class="s2">MockTimersOptions {</span>
            <span class="s2">apis: ReadonlyArray&lt;</span><span class="s3">&quot;setInterval&quot; </span><span class="s2">| </span><span class="s3">&quot;setTimeout&quot; </span><span class="s2">| </span><span class="s3">&quot;setImmediate&quot; </span><span class="s2">| </span><span class="s3">&quot;Date&quot;</span><span class="s2">&gt;;</span>
            <span class="s2">now?: number | Date | undefined;</span>
        <span class="s2">}</span>
        <span class="s0">/**</span>
         <span class="s0">* Mocking timers is a technique commonly used in software testing to simulate and</span>
         <span class="s0">* control the behavior of timers, such as `setInterval` and `setTimeout`,</span>
         <span class="s0">* without actually waiting for the specified time intervals.</span>
         <span class="s0">*</span>
         <span class="s0">* The MockTimers API also allows for mocking of the `Date` constructor and</span>
         <span class="s0">* `setImmediate`/`clearImmediate` functions.</span>
         <span class="s0">*</span>
         <span class="s0">* The `MockTracker` provides a top-level `timers` export</span>
         <span class="s0">* which is a `MockTimers` instance.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.4.0</span>
         <span class="s0">* </span><span class="s1">@experimental</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s2">MockTimers {</span>
            <span class="s0">/**</span>
             <span class="s0">* Enables timer mocking for the specified timers.</span>
             <span class="s0">*</span>
             <span class="s0">* **Note:** When you enable mocking for a specific timer, its associated</span>
             <span class="s0">* clear function will also be implicitly mocked.</span>
             <span class="s0">*</span>
             <span class="s0">* **Note:** Mocking `Date` will affect the behavior of the mocked timers</span>
             <span class="s0">* as they use the same internal clock.</span>
             <span class="s0">*</span>
             <span class="s0">* Example usage without setting initial time:</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { mock } from 'node:test';</span>
             <span class="s0">* mock.timers.enable({ apis: ['setInterval', 'Date'], now: 1234 });</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* The above example enables mocking for the `Date` constructor, `setInterval` timer and</span>
             <span class="s0">* implicitly mocks the `clearInterval` function. Only the `Date` constructor from `globalThis`,</span>
             <span class="s0">* `setInterval` and `clearInterval` functions from `node:timers`, `node:timers/promises`, and `globalThis` will be mocked.</span>
             <span class="s0">*</span>
             <span class="s0">* Example usage with initial time set</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { mock } from 'node:test';</span>
             <span class="s0">* mock.timers.enable({ apis: ['Date'], now: 1000 });</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* Example usage with initial Date object as time set</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { mock } from 'node:test';</span>
             <span class="s0">* mock.timers.enable({ apis: ['Date'], now: new Date() });</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* Alternatively, if you call `mock.timers.enable()` without any parameters:</span>
             <span class="s0">*</span>
             <span class="s0">* All timers (`'setInterval'`, `'clearInterval'`, `'Date'`, `'setImmediate'`, `'clearImmediate'`, `'setTimeout'`, and `'clearTimeout'`)</span>
             <span class="s0">* will be mocked.</span>
             <span class="s0">*</span>
             <span class="s0">* The `setInterval`, `clearInterval`, `setTimeout`, and `clearTimeout` functions from `node:timers`, `node:timers/promises`,</span>
             <span class="s0">* and `globalThis` will be mocked.</span>
             <span class="s0">* The `Date` constructor from `globalThis` will be mocked.</span>
             <span class="s0">*</span>
             <span class="s0">* If there is no initial epoch set, the initial date will be based on 0 in the Unix epoch. This is `January 1st, 1970, 00:00:00 UTC`. You can</span>
             <span class="s0">* set an initial date by passing a now property to the `.enable()` method. This value will be used as the initial date for the mocked Date</span>
             <span class="s0">* object. It can either be a positive integer, or another Date object.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.4.0</span>
             <span class="s0">*/</span>
            <span class="s2">enable(options?: MockTimersOptions): </span><span class="s4">void</span><span class="s2">;</span>
            <span class="s0">/**</span>
             <span class="s0">* You can use the `.setTime()` method to manually move the mocked date to another time. This method only accepts a positive integer.</span>
             <span class="s0">* Note: This method will execute any mocked timers that are in the past from the new time.</span>
             <span class="s0">* In the below example we are setting a new time for the mocked date.</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import assert from 'node:assert';</span>
             <span class="s0">* import { test } from 'node:test';</span>
             <span class="s0">* test('sets the time of a date object', (context) =&gt; {</span>
             <span class="s0">*   // Optionally choose what to mock</span>
             <span class="s0">*   context.mock.timers.enable({ apis: ['Date'], now: 100 });</span>
             <span class="s0">*   assert.strictEqual(Date.now(), 100);</span>
             <span class="s0">*   // Advance in time will also advance the date</span>
             <span class="s0">*   context.mock.timers.setTime(1000);</span>
             <span class="s0">*   context.mock.timers.tick(200);</span>
             <span class="s0">*   assert.strictEqual(Date.now(), 1200);</span>
             <span class="s0">* });</span>
             <span class="s0">* ```</span>
             <span class="s0">*/</span>
            <span class="s2">setTime(time: number): </span><span class="s4">void</span><span class="s2">;</span>
            <span class="s0">/**</span>
             <span class="s0">* This function restores the default behavior of all mocks that were previously</span>
             <span class="s0">* created by this `MockTimers` instance and disassociates the mocks</span>
             <span class="s0">* from the `MockTracker` instance.</span>
             <span class="s0">*</span>
             <span class="s0">* **Note:** After each test completes, this function is called on</span>
             <span class="s0">* the test context's `MockTracker`.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { mock } from 'node:test';</span>
             <span class="s0">* mock.timers.reset();</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.4.0</span>
             <span class="s0">*/</span>
            <span class="s2">reset(): </span><span class="s4">void</span><span class="s2">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Advances time for all mocked timers.</span>
             <span class="s0">*</span>
             <span class="s0">* **Note:** This diverges from how `setTimeout` in Node.js behaves and accepts</span>
             <span class="s0">* only positive numbers. In Node.js, `setTimeout` with negative numbers is</span>
             <span class="s0">* only supported for web compatibility reasons.</span>
             <span class="s0">*</span>
             <span class="s0">* The following example mocks a `setTimeout` function and</span>
             <span class="s0">* by using `.tick` advances in</span>
             <span class="s0">* time triggering all pending timers.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import assert from 'node:assert';</span>
             <span class="s0">* import { test } from 'node:test';</span>
             <span class="s0">*</span>
             <span class="s0">* test('mocks setTimeout to be executed synchronously without having to actually wait for it', (context) =&gt; {</span>
             <span class="s0">*   const fn = context.mock.fn();</span>
             <span class="s0">*</span>
             <span class="s0">*   context.mock.timers.enable({ apis: ['setTimeout'] });</span>
             <span class="s0">*</span>
             <span class="s0">*   setTimeout(fn, 9999);</span>
             <span class="s0">*</span>
             <span class="s0">*   assert.strictEqual(fn.mock.callCount(), 0);</span>
             <span class="s0">*</span>
             <span class="s0">*   // Advance in time</span>
             <span class="s0">*   context.mock.timers.tick(9999);</span>
             <span class="s0">*</span>
             <span class="s0">*   assert.strictEqual(fn.mock.callCount(), 1);</span>
             <span class="s0">* });</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* Alternativelly, the `.tick` function can be called many times</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import assert from 'node:assert';</span>
             <span class="s0">* import { test } from 'node:test';</span>
             <span class="s0">*</span>
             <span class="s0">* test('mocks setTimeout to be executed synchronously without having to actually wait for it', (context) =&gt; {</span>
             <span class="s0">*   const fn = context.mock.fn();</span>
             <span class="s0">*   context.mock.timers.enable({ apis: ['setTimeout'] });</span>
             <span class="s0">*   const nineSecs = 9000;</span>
             <span class="s0">*   setTimeout(fn, nineSecs);</span>
             <span class="s0">*</span>
             <span class="s0">*   const twoSeconds = 3000;</span>
             <span class="s0">*   context.mock.timers.tick(twoSeconds);</span>
             <span class="s0">*   context.mock.timers.tick(twoSeconds);</span>
             <span class="s0">*   context.mock.timers.tick(twoSeconds);</span>
             <span class="s0">*</span>
             <span class="s0">*   assert.strictEqual(fn.mock.callCount(), 1);</span>
             <span class="s0">* });</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* Advancing time using `.tick` will also advance the time for any `Date` object</span>
             <span class="s0">* created after the mock was enabled (if `Date` was also set to be mocked).</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import assert from 'node:assert';</span>
             <span class="s0">* import { test } from 'node:test';</span>
             <span class="s0">*</span>
             <span class="s0">* test('mocks setTimeout to be executed synchronously without having to actually wait for it', (context) =&gt; {</span>
             <span class="s0">*   const fn = context.mock.fn();</span>
             <span class="s0">*</span>
             <span class="s0">*   context.mock.timers.enable({ apis: ['setTimeout', 'Date'] });</span>
             <span class="s0">*   setTimeout(fn, 9999);</span>
             <span class="s0">*</span>
             <span class="s0">*   assert.strictEqual(fn.mock.callCount(), 0);</span>
             <span class="s0">*   assert.strictEqual(Date.now(), 0);</span>
             <span class="s0">*</span>
             <span class="s0">*   // Advance in time</span>
             <span class="s0">*   context.mock.timers.tick(9999);</span>
             <span class="s0">*   assert.strictEqual(fn.mock.callCount(), 1);</span>
             <span class="s0">*   assert.strictEqual(Date.now(), 9999);</span>
             <span class="s0">* });</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.4.0</span>
             <span class="s0">*/</span>
            <span class="s2">tick(milliseconds: number): </span><span class="s4">void</span><span class="s2">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Triggers all pending mocked timers immediately. If the `Date` object is also</span>
             <span class="s0">* mocked, it will also advance the `Date` object to the furthest timer's time.</span>
             <span class="s0">*</span>
             <span class="s0">* The example below triggers all pending timers immediately,</span>
             <span class="s0">* causing them to execute without any delay.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import assert from 'node:assert';</span>
             <span class="s0">* import { test } from 'node:test';</span>
             <span class="s0">*</span>
             <span class="s0">* test('runAll functions following the given order', (context) =&gt; {</span>
             <span class="s0">*   context.mock.timers.enable({ apis: ['setTimeout', 'Date'] });</span>
             <span class="s0">*   const results = [];</span>
             <span class="s0">*   setTimeout(() =&gt; results.push(1), 9999);</span>
             <span class="s0">*</span>
             <span class="s0">*   // Notice that if both timers have the same timeout,</span>
             <span class="s0">*   // the order of execution is guaranteed</span>
             <span class="s0">*   setTimeout(() =&gt; results.push(3), 8888);</span>
             <span class="s0">*   setTimeout(() =&gt; results.push(2), 8888);</span>
             <span class="s0">*</span>
             <span class="s0">*   assert.deepStrictEqual(results, []);</span>
             <span class="s0">*</span>
             <span class="s0">*   context.mock.timers.runAll();</span>
             <span class="s0">*   assert.deepStrictEqual(results, [3, 2, 1]);</span>
             <span class="s0">*   // The Date object is also advanced to the furthest timer's time</span>
             <span class="s0">*   assert.strictEqual(Date.now(), 9999);</span>
             <span class="s0">* });</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* **Note:** The `runAll()` function is specifically designed for</span>
             <span class="s0">* triggering timers in the context of timer mocking.</span>
             <span class="s0">* It does not have any effect on real-time system</span>
             <span class="s0">* clocks or actual timers outside of the mocking environment.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.4.0</span>
             <span class="s0">*/</span>
            <span class="s2">runAll(): </span><span class="s4">void</span><span class="s2">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Calls {</span><span class="s1">@link </span><span class="s0">MockTimers.reset()}.</span>
             <span class="s0">*/</span>
            <span class="s2">[Symbol.dispose](): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">type FunctionPropertyNames&lt;T&gt; = {</span>
        <span class="s2">[K </span><span class="s4">in </span><span class="s2">keyof T]: T[K] </span><span class="s4">extends </span><span class="s2">Function ? K : never;</span>
    <span class="s2">}[keyof T];</span>
    <span class="s4">export </span><span class="s2">= test;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* The `node:test/reporters` module exposes the builtin-reporters for `node:test`.</span>
 <span class="s0">* To access it:</span>
 <span class="s0">*</span>
 <span class="s0">* ```js</span>
 <span class="s0">* import test from 'node:test/reporters';</span>
 <span class="s0">* ```</span>
 <span class="s0">*</span>
 <span class="s0">* This module is only available under the `node:` scheme. The following will not</span>
 <span class="s0">* work:</span>
 <span class="s0">*</span>
 <span class="s0">* ```js</span>
 <span class="s0">* import test from 'test/reporters';</span>
 <span class="s0">* ```</span>
 <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.9.0</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[source](https://github.com/nodejs/node/blob/v20.13.1/lib/test/reporters.js)</span>
 <span class="s0">*/</span>
<span class="s2">declare module </span><span class="s3">&quot;node:test/reporters&quot; </span><span class="s2">{</span>
    <span class="s4">import </span><span class="s2">{ Transform, TransformOptions } from </span><span class="s3">&quot;node:stream&quot;</span><span class="s2">;</span>
    <span class="s4">import </span><span class="s2">{ EventData } from </span><span class="s3">&quot;node:test&quot;</span><span class="s2">;</span>

    <span class="s2">type TestEvent =</span>
        <span class="s2">| { type: </span><span class="s3">&quot;test:coverage&quot;</span><span class="s2">; data: EventData.TestCoverage }</span>
        <span class="s2">| { type: </span><span class="s3">&quot;test:complete&quot;</span><span class="s2">; data: EventData.TestComplete }</span>
        <span class="s2">| { type: </span><span class="s3">&quot;test:dequeue&quot;</span><span class="s2">; data: EventData.TestDequeue }</span>
        <span class="s2">| { type: </span><span class="s3">&quot;test:diagnostic&quot;</span><span class="s2">; data: EventData.TestDiagnostic }</span>
        <span class="s2">| { type: </span><span class="s3">&quot;test:enqueue&quot;</span><span class="s2">; data: EventData.TestEnqueue }</span>
        <span class="s2">| { type: </span><span class="s3">&quot;test:fail&quot;</span><span class="s2">; data: EventData.TestFail }</span>
        <span class="s2">| { type: </span><span class="s3">&quot;test:pass&quot;</span><span class="s2">; data: EventData.TestPass }</span>
        <span class="s2">| { type: </span><span class="s3">&quot;test:plan&quot;</span><span class="s2">; data: EventData.TestPlan }</span>
        <span class="s2">| { type: </span><span class="s3">&quot;test:start&quot;</span><span class="s2">; data: EventData.TestStart }</span>
        <span class="s2">| { type: </span><span class="s3">&quot;test:stderr&quot;</span><span class="s2">; data: EventData.TestStderr }</span>
        <span class="s2">| { type: </span><span class="s3">&quot;test:stdout&quot;</span><span class="s2">; data: EventData.TestStdout }</span>
        <span class="s2">| { type: </span><span class="s3">&quot;test:watch:drained&quot;</span><span class="s2">; data: undefined };</span>
    <span class="s2">type TestEventGenerator = AsyncGenerator&lt;TestEvent, </span><span class="s4">void</span><span class="s2">&gt;;</span>

    <span class="s0">/**</span>
     <span class="s0">* The `dot` reporter outputs the test results in a compact format,</span>
     <span class="s0">* where each passing test is represented by a `.`,</span>
     <span class="s0">* and each failing test is represented by a `X`.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.0.0</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">dot(source: TestEventGenerator): AsyncGenerator&lt;</span><span class="s3">&quot;</span><span class="s5">\n</span><span class="s3">&quot; </span><span class="s2">| </span><span class="s3">&quot;.&quot; </span><span class="s2">| </span><span class="s3">&quot;X&quot;</span><span class="s2">, </span><span class="s4">void</span><span class="s2">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* The `tap` reporter outputs the test results in the [TAP](https://testanything.org/) format.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.0.0</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">tap(source: TestEventGenerator): AsyncGenerator&lt;string, </span><span class="s4">void</span><span class="s2">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* The `spec` reporter outputs the test results in a human-readable format.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.0.0</span>
     <span class="s0">*/</span>
    <span class="s4">class </span><span class="s2">SpecReporter </span><span class="s4">extends </span><span class="s2">Transform {</span>
        <span class="s2">constructor();</span>
    <span class="s2">}</span>
    <span class="s0">/**</span>
     <span class="s0">* The `junit` reporter outputs test results in a jUnit XML format.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v21.0.0</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">junit(source: TestEventGenerator): AsyncGenerator&lt;string, </span><span class="s4">void</span><span class="s2">&gt;;</span>
    <span class="s4">class </span><span class="s2">LcovReporter </span><span class="s4">extends </span><span class="s2">Transform {</span>
        <span class="s2">constructor(opts?: Omit&lt;TransformOptions, </span><span class="s3">&quot;writableObjectMode&quot;</span><span class="s2">&gt;);</span>
    <span class="s2">}</span>
    <span class="s0">/**</span>
     <span class="s0">* The `lcov` reporter outputs test coverage when used with the</span>
     <span class="s0">* [`--experimental-test-coverage`](https://nodejs.org/docs/latest-v20.x/api/cli.html#--experimental-test-coverage) flag.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.0.0</span>
     <span class="s0">*/</span>
    <span class="s4">const </span><span class="s2">lcov: LcovReporter;</span>

    <span class="s4">export </span><span class="s2">{ dot, junit, lcov, SpecReporter as spec, tap, TestEvent };</span>
<span class="s2">}</span>
</pre>
</body>
</html>