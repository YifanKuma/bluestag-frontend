<html>
<head>
<title>size-rollup-dom-max.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #1750eb;}
.s4 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
size-rollup-dom-max.js</font>
</center></td></tr></table>
<pre><span class="s0">import</span><span class="s1">{q as t,t as e,u as i,v as n,w as s,x as o,y as r,z as a,A as l,B as h,C as u,D as c,b as d,m as p,o as m,r as f,E as y,n as g,i as v,h as x,p as T,k as P,F as w,d as S,s as A,P as b,L as E,S as V,G as M,a as D,H as C,j as k,I as R,J as L,l as j,e as B,f as F,g as I}from</span><span class="s2">&quot;./size-rollup-dom-max-assets.js&quot;</span><span class="s1">;</span><span class="s0">import</span><span class="s1">{jsx as O}from</span><span class="s2">&quot;react/jsx-runtime&quot;</span><span class="s1">;</span><span class="s0">import</span><span class="s1">{useContext as U,useId as N,useEffect as K,useCallback as W,Component as $,Fragment as z}from</span><span class="s2">&quot;react&quot;</span><span class="s1">;</span><span class="s0">function </span><span class="s1">Y(t,e){-</span><span class="s3">1</span><span class="s1">===t.indexOf(e)&amp;&amp;t.push(e)}</span><span class="s0">function </span><span class="s1">X(t,e){</span><span class="s0">const </span><span class="s1">i=t.indexOf(e);i&gt;-</span><span class="s3">1</span><span class="s1">&amp;&amp;t.splice(i,</span><span class="s3">1</span><span class="s1">)}</span><span class="s0">const </span><span class="s1">H={},G=t=&gt;</span><span class="s4">/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u</span><span class="s1">.test(t);</span><span class="s0">function </span><span class="s1">q(t){</span><span class="s0">return</span><span class="s2">&quot;object&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t&amp;&amp;</span><span class="s0">null</span><span class="s1">!==t}</span><span class="s0">const </span><span class="s1">_=t=&gt;</span><span class="s4">/^0[^.\s]+$/u</span><span class="s1">.test(t);</span><span class="s0">function </span><span class="s1">Z(t){</span><span class="s0">let </span><span class="s1">e;</span><span class="s0">return</span><span class="s1">()=&gt;(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===e&amp;&amp;(e=t()),e)}</span><span class="s0">const </span><span class="s1">J=t=&gt;t,Q=(t,e)=&gt;i=&gt;e(t(i)),tt=(...t)=&gt;t.reduce(Q),et=(t,e,i)=&gt;{</span><span class="s0">const </span><span class="s1">n=e-t;</span><span class="s0">return </span><span class="s3">0</span><span class="s1">===n?</span><span class="s3">1</span><span class="s1">:(i-t)/n};</span><span class="s0">class </span><span class="s1">it{constructor(){</span><span class="s0">this</span><span class="s1">.subscriptions=[]}add(t){</span><span class="s0">return </span><span class="s1">Y(</span><span class="s0">this</span><span class="s1">.subscriptions,t),()=&gt;X(</span><span class="s0">this</span><span class="s1">.subscriptions,t)}notify(t,e,i){</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">this</span><span class="s1">.subscriptions.length;</span><span class="s0">if</span><span class="s1">(n)</span><span class="s0">if</span><span class="s1">(</span><span class="s3">1</span><span class="s1">===n)</span><span class="s0">this</span><span class="s1">.subscriptions[</span><span class="s3">0</span><span class="s1">](t,e,i);</span><span class="s0">else for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">s=</span><span class="s3">0</span><span class="s1">;s&lt;n;s++){</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">this</span><span class="s1">.subscriptions[s];n&amp;&amp;n(t,e,i)}}getSize(){</span><span class="s0">return this</span><span class="s1">.subscriptions.length}clear(){</span><span class="s0">this</span><span class="s1">.subscriptions.length=</span><span class="s3">0</span><span class="s1">}}</span><span class="s0">const </span><span class="s1">nt=t=&gt;</span><span class="s3">1e3</span><span class="s1">*t,st=t=&gt;t/</span><span class="s3">1e3</span><span class="s1">;</span><span class="s0">function </span><span class="s1">ot(t,e){</span><span class="s0">return </span><span class="s1">e?t*(</span><span class="s3">1e3</span><span class="s1">/e):</span><span class="s3">0</span><span class="s1">}</span><span class="s0">const </span><span class="s1">rt=(t,e,i)=&gt;(((</span><span class="s3">1</span><span class="s1">-</span><span class="s3">3</span><span class="s1">*i+</span><span class="s3">3</span><span class="s1">*e)*t+(</span><span class="s3">3</span><span class="s1">*i-</span><span class="s3">6</span><span class="s1">*e))*t+</span><span class="s3">3</span><span class="s1">*e)*t;</span><span class="s0">function </span><span class="s1">at(t,e,i,n){</span><span class="s0">if</span><span class="s1">(t===e&amp;&amp;i===n)</span><span class="s0">return </span><span class="s1">J;</span><span class="s0">const </span><span class="s1">s=e=&gt;</span><span class="s0">function</span><span class="s1">(t,e,i,n,s){</span><span class="s0">let </span><span class="s1">o,r,a=</span><span class="s3">0</span><span class="s1">;</span><span class="s0">do</span><span class="s1">{r=e+(i-e)/</span><span class="s3">2</span><span class="s1">,o=rt(r,n,s)-t,o&gt;</span><span class="s3">0</span><span class="s1">?i=r:e=r}</span><span class="s0">while</span><span class="s1">(Math.abs(o)&gt;</span><span class="s3">1e-7</span><span class="s1">&amp;&amp;++a&lt;</span><span class="s3">12</span><span class="s1">);</span><span class="s0">return </span><span class="s1">r}(e,</span><span class="s3">0</span><span class="s1">,</span><span class="s3">1</span><span class="s1">,t,i);</span><span class="s0">return </span><span class="s1">t=&gt;</span><span class="s3">0</span><span class="s1">===t||</span><span class="s3">1</span><span class="s1">===t?t:rt(s(t),e,n)}</span><span class="s0">const </span><span class="s1">lt=t=&gt;e=&gt;e&lt;=</span><span class="s3">.5</span><span class="s1">?t(</span><span class="s3">2</span><span class="s1">*e)/</span><span class="s3">2</span><span class="s1">:(</span><span class="s3">2</span><span class="s1">-t(</span><span class="s3">2</span><span class="s1">*(</span><span class="s3">1</span><span class="s1">-e)))/</span><span class="s3">2</span><span class="s1">,ht=t=&gt;e=&gt;</span><span class="s3">1</span><span class="s1">-t(</span><span class="s3">1</span><span class="s1">-e),ut=at(</span><span class="s3">.33</span><span class="s1">,</span><span class="s3">1.53</span><span class="s1">,</span><span class="s3">.69</span><span class="s1">,</span><span class="s3">.99</span><span class="s1">),ct=ht(ut),dt=lt(ct),pt=t=&gt;(t*=</span><span class="s3">2</span><span class="s1">)&lt;</span><span class="s3">1</span><span class="s1">?</span><span class="s3">.5</span><span class="s1">*ct(t):</span><span class="s3">.5</span><span class="s1">*(</span><span class="s3">2</span><span class="s1">-Math.pow(</span><span class="s3">2</span><span class="s1">,-</span><span class="s3">10</span><span class="s1">*(t-</span><span class="s3">1</span><span class="s1">))),mt=t=&gt;</span><span class="s3">1</span><span class="s1">-Math.sin(Math.acos(t)),ft=ht(mt),yt=lt(mt),gt=at(</span><span class="s3">.42</span><span class="s1">,</span><span class="s3">0</span><span class="s1">,</span><span class="s3">1</span><span class="s1">,</span><span class="s3">1</span><span class="s1">),vt=at(</span><span class="s3">0</span><span class="s1">,</span><span class="s3">0</span><span class="s1">,</span><span class="s3">.58</span><span class="s1">,</span><span class="s3">1</span><span class="s1">),xt=at(</span><span class="s3">.42</span><span class="s1">,</span><span class="s3">0</span><span class="s1">,</span><span class="s3">.58</span><span class="s1">,</span><span class="s3">1</span><span class="s1">),Tt=t=&gt;Array.isArray(t)&amp;&amp;</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t[</span><span class="s3">0</span><span class="s1">],Pt={linear:J,easeIn:gt,easeInOut:xt,easeOut:vt,circIn:mt,circInOut:yt,circOut:ft,backIn:ct,backInOut:dt,backOut:ut,anticipate:pt},wt=t=&gt;{</span><span class="s0">if</span><span class="s1">(Tt(t)){t.length;</span><span class="s0">const</span><span class="s1">[e,i,n,s]=t;</span><span class="s0">return </span><span class="s1">at(e,i,n,s)}</span><span class="s0">return</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t?Pt[t]:t},St=[</span><span class="s2">&quot;setup&quot;</span><span class="s1">,</span><span class="s2">&quot;read&quot;</span><span class="s1">,</span><span class="s2">&quot;resolveKeyframes&quot;</span><span class="s1">,</span><span class="s2">&quot;preUpdate&quot;</span><span class="s1">,</span><span class="s2">&quot;update&quot;</span><span class="s1">,</span><span class="s2">&quot;preRender&quot;</span><span class="s1">,</span><span class="s2">&quot;render&quot;</span><span class="s1">,</span><span class="s2">&quot;postRender&quot;</span><span class="s1">],At={value:</span><span class="s0">null</span><span class="s1">,addProjectionMetrics:</span><span class="s0">null</span><span class="s1">};</span><span class="s0">function </span><span class="s1">bt(t,e){</span><span class="s0">let </span><span class="s1">i=!</span><span class="s3">1</span><span class="s1">,n=!</span><span class="s3">0</span><span class="s1">;</span><span class="s0">const </span><span class="s1">s={delta:</span><span class="s3">0</span><span class="s1">,timestamp:</span><span class="s3">0</span><span class="s1">,isProcessing:!</span><span class="s3">1</span><span class="s1">},o=()=&gt;i=!</span><span class="s3">0</span><span class="s1">,r=St.reduce((t,i)=&gt;(t[i]=</span><span class="s0">function</span><span class="s1">(t,e){</span><span class="s0">let </span><span class="s1">i=</span><span class="s0">new </span><span class="s1">Set,n=</span><span class="s0">new </span><span class="s1">Set,s=!</span><span class="s3">1</span><span class="s1">,o=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">const </span><span class="s1">r=</span><span class="s0">new </span><span class="s1">WeakSet;</span><span class="s0">let </span><span class="s1">a={delta:</span><span class="s3">0</span><span class="s1">,timestamp:</span><span class="s3">0</span><span class="s1">,isProcessing:!</span><span class="s3">1</span><span class="s1">},l=</span><span class="s3">0</span><span class="s1">;</span><span class="s0">function </span><span class="s1">h(e){r.has(e)&amp;&amp;(u.schedule(e),t()),l++,e(a)}</span><span class="s0">const </span><span class="s1">u={schedule:(t,e=!</span><span class="s3">1</span><span class="s1">,o=!</span><span class="s3">1</span><span class="s1">)=&gt;{</span><span class="s0">const </span><span class="s1">a=o&amp;&amp;s?i:n;</span><span class="s0">return </span><span class="s1">e&amp;&amp;r.add(t),a.has(t)||a.add(t),t},cancel:t=&gt;{n.delete(t),r.delete(t)},process:t=&gt;{a=t,s?o=!</span><span class="s3">0</span><span class="s1">:(s=!</span><span class="s3">0</span><span class="s1">,[i,n]=[n,i],i.forEach(h),e&amp;&amp;At.value&amp;&amp;At.value.frameloop[e].push(l),l=</span><span class="s3">0</span><span class="s1">,i.clear(),s=!</span><span class="s3">1</span><span class="s1">,o&amp;&amp;(o=!</span><span class="s3">1</span><span class="s1">,u.process(t)))}};</span><span class="s0">return </span><span class="s1">u}(o,e?i:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">),t),{}),{setup:a,read:l,resolveKeyframes:h,preUpdate:u,update:c,preRender:d,render:p,postRender:m}=r,f=()=&gt;{</span><span class="s0">const </span><span class="s1">o=H.useManualTiming?s.timestamp:performance.now();i=!</span><span class="s3">1</span><span class="s1">,H.useManualTiming||(s.delta=n?</span><span class="s3">1e3</span><span class="s1">/</span><span class="s3">60</span><span class="s1">:Math.max(Math.min(o-s.timestamp,</span><span class="s3">40</span><span class="s1">),</span><span class="s3">1</span><span class="s1">)),s.timestamp=o,s.isProcessing=!</span><span class="s3">0</span><span class="s1">,a.process(s),l.process(s),h.process(s),u.process(s),c.process(s),d.process(s),p.process(s),m.process(s),s.isProcessing=!</span><span class="s3">1</span><span class="s1">,i&amp;&amp;e&amp;&amp;(n=!</span><span class="s3">1</span><span class="s1">,t(f))};</span><span class="s0">return</span><span class="s1">{schedule:St.reduce((e,o)=&gt;{</span><span class="s0">const </span><span class="s1">a=r[o];</span><span class="s0">return </span><span class="s1">e[o]=(e,o=!</span><span class="s3">1</span><span class="s1">,r=!</span><span class="s3">1</span><span class="s1">)=&gt;(i||(i=!</span><span class="s3">0</span><span class="s1">,n=!</span><span class="s3">0</span><span class="s1">,s.isProcessing||t(f)),a.schedule(e,o,r)),e},{}),cancel:t=&gt;{</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">0</span><span class="s1">;e&lt;St.length;e++)r[St[e]].cancel(t)},state:s,steps:r}}</span><span class="s0">const</span><span class="s1">{schedule:Et,cancel:Vt,state:Mt,steps:Dt}=bt(</span><span class="s2">&quot;undefined&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">requestAnimationFrame?requestAnimationFrame:J,!</span><span class="s3">0</span><span class="s1">);</span><span class="s0">let </span><span class="s1">Ct;</span><span class="s0">function </span><span class="s1">kt(){Ct=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}</span><span class="s0">const </span><span class="s1">Rt={now:()=&gt;(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===Ct&amp;&amp;Rt.set(Mt.isProcessing||H.useManualTiming?Mt.timestamp:performance.now()),Ct),set:t=&gt;{Ct=t,queueMicrotask(kt)}},Lt=t=&gt;Math.round(</span><span class="s3">1e5</span><span class="s1">*t)/</span><span class="s3">1e5</span><span class="s1">,jt=</span><span class="s4">/-?(?:\d+(?:\.\d+)?|\.\d+)/gu</span><span class="s1">;</span><span class="s0">const </span><span class="s1">Bt=</span><span class="s4">/^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu</span><span class="s1">,Ft=(t,e)=&gt;i=&gt;Boolean(</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">i&amp;&amp;Bt.test(i)&amp;&amp;i.startsWith(t)||e&amp;&amp;!</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">return null</span><span class="s1">==t}(i)&amp;&amp;Object.prototype.hasOwnProperty.call(i,e)),It=(t,e,i)=&gt;n=&gt;{</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;string&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">n)</span><span class="s0">return </span><span class="s1">n;</span><span class="s0">const</span><span class="s1">[s,o,r,a]=n.match(jt);</span><span class="s0">return</span><span class="s1">{[t]:parseFloat(s),[e]:parseFloat(o),[i]:parseFloat(r),alpha:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==a?parseFloat(a):</span><span class="s3">1</span><span class="s1">}},Ot={...t,transform:t=&gt;Math.round((t=&gt;i(</span><span class="s3">0</span><span class="s1">,</span><span class="s3">255</span><span class="s1">,t))(t))},Ut={test:Ft(</span><span class="s2">&quot;rgb&quot;</span><span class="s1">,</span><span class="s2">&quot;red&quot;</span><span class="s1">),parse:It(</span><span class="s2">&quot;red&quot;</span><span class="s1">,</span><span class="s2">&quot;green&quot;</span><span class="s1">,</span><span class="s2">&quot;blue&quot;</span><span class="s1">),transform:({red:t,green:i,blue:n,alpha:s=</span><span class="s3">1</span><span class="s1">})=&gt;</span><span class="s2">&quot;rgba(&quot;</span><span class="s1">+Ot.transform(t)+</span><span class="s2">&quot;, &quot;</span><span class="s1">+Ot.transform(i)+</span><span class="s2">&quot;, &quot;</span><span class="s1">+Ot.transform(n)+</span><span class="s2">&quot;, &quot;</span><span class="s1">+Lt(e.transform(s))+</span><span class="s2">&quot;)&quot;</span><span class="s1">};</span><span class="s0">const </span><span class="s1">Nt={test:Ft(</span><span class="s2">&quot;#&quot;</span><span class="s1">),parse:</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">let </span><span class="s1">e=</span><span class="s2">&quot;&quot;</span><span class="s1">,i=</span><span class="s2">&quot;&quot;</span><span class="s1">,n=</span><span class="s2">&quot;&quot;</span><span class="s1">,s=</span><span class="s2">&quot;&quot;</span><span class="s1">;</span><span class="s0">return </span><span class="s1">t.length&gt;</span><span class="s3">5</span><span class="s1">?(e=t.substring(</span><span class="s3">1</span><span class="s1">,</span><span class="s3">3</span><span class="s1">),i=t.substring(</span><span class="s3">3</span><span class="s1">,</span><span class="s3">5</span><span class="s1">),n=t.substring(</span><span class="s3">5</span><span class="s1">,</span><span class="s3">7</span><span class="s1">),s=t.substring(</span><span class="s3">7</span><span class="s1">,</span><span class="s3">9</span><span class="s1">)):(e=t.substring(</span><span class="s3">1</span><span class="s1">,</span><span class="s3">2</span><span class="s1">),i=t.substring(</span><span class="s3">2</span><span class="s1">,</span><span class="s3">3</span><span class="s1">),n=t.substring(</span><span class="s3">3</span><span class="s1">,</span><span class="s3">4</span><span class="s1">),s=t.substring(</span><span class="s3">4</span><span class="s1">,</span><span class="s3">5</span><span class="s1">),e+=e,i+=i,n+=n,s+=s),{red:parseInt(e,</span><span class="s3">16</span><span class="s1">),green:parseInt(i,</span><span class="s3">16</span><span class="s1">),blue:parseInt(n,</span><span class="s3">16</span><span class="s1">),alpha:s?parseInt(s,</span><span class="s3">16</span><span class="s1">)/</span><span class="s3">255</span><span class="s1">:</span><span class="s3">1</span><span class="s1">}},transform:Ut.transform},Kt={test:Ft(</span><span class="s2">&quot;hsl&quot;</span><span class="s1">,</span><span class="s2">&quot;hue&quot;</span><span class="s1">),parse:It(</span><span class="s2">&quot;hue&quot;</span><span class="s1">,</span><span class="s2">&quot;saturation&quot;</span><span class="s1">,</span><span class="s2">&quot;lightness&quot;</span><span class="s1">),transform:({hue:t,saturation:i,lightness:s,alpha:o=</span><span class="s3">1</span><span class="s1">})=&gt;</span><span class="s2">&quot;hsla(&quot;</span><span class="s1">+Math.round(t)+</span><span class="s2">&quot;, &quot;</span><span class="s1">+n.transform(Lt(i))+</span><span class="s2">&quot;, &quot;</span><span class="s1">+n.transform(Lt(s))+</span><span class="s2">&quot;, &quot;</span><span class="s1">+Lt(e.transform(o))+</span><span class="s2">&quot;)&quot;</span><span class="s1">},Wt={test:t=&gt;Ut.test(t)||Nt.test(t)||Kt.test(t),parse:t=&gt;Ut.test(t)?Ut.parse(t):Kt.test(t)?Kt.parse(t):Nt.parse(t),transform:t=&gt;</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t?t:t.hasOwnProperty(</span><span class="s2">&quot;red&quot;</span><span class="s1">)?Ut.transform(t):Kt.transform(t),getAnimatableNone:t=&gt;{</span><span class="s0">const </span><span class="s1">e=Wt.parse(t);</span><span class="s0">return </span><span class="s1">e.alpha=</span><span class="s3">0</span><span class="s1">,Wt.transform(e)}},$t=</span><span class="s4">/(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu</span><span class="s1">;</span><span class="s0">const </span><span class="s1">zt=</span><span class="s2">&quot;number&quot;</span><span class="s1">,Yt=</span><span class="s2">&quot;color&quot;</span><span class="s1">,Xt=</span><span class="s4">/var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu</span><span class="s1">;</span><span class="s0">function </span><span class="s1">Ht(t){</span><span class="s0">const </span><span class="s1">e=t.toString(),i=[],n={color:[],number:[],</span><span class="s0">var</span><span class="s1">:[]},s=[];</span><span class="s0">let </span><span class="s1">o=</span><span class="s3">0</span><span class="s1">;</span><span class="s0">const </span><span class="s1">r=e.replace(Xt,t=&gt;(Wt.test(t)?(n.color.push(o),s.push(Yt),i.push(Wt.parse(t))):t.startsWith(</span><span class="s2">&quot;var(&quot;</span><span class="s1">)?(n.var.push(o),s.push(</span><span class="s2">&quot;var&quot;</span><span class="s1">),i.push(t)):(n.number.push(o),s.push(zt),i.push(parseFloat(t))),++o,</span><span class="s2">&quot;${}&quot;</span><span class="s1">)).split(</span><span class="s2">&quot;${}&quot;</span><span class="s1">);</span><span class="s0">return</span><span class="s1">{values:i,split:r,indexes:n,types:s}}</span><span class="s0">function </span><span class="s1">Gt(t){</span><span class="s0">return </span><span class="s1">Ht(t).values}</span><span class="s0">function </span><span class="s1">qt(t){</span><span class="s0">const</span><span class="s1">{split:e,types:i}=Ht(t),n=e.length;</span><span class="s0">return </span><span class="s1">t=&gt;{</span><span class="s0">let </span><span class="s1">s=</span><span class="s2">&quot;&quot;</span><span class="s1">;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">o=</span><span class="s3">0</span><span class="s1">;o&lt;n;o++)</span><span class="s0">if</span><span class="s1">(s+=e[o],</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==t[o]){</span><span class="s0">const </span><span class="s1">e=i[o];s+=e===zt?Lt(t[o]):e===Yt?Wt.transform(t[o]):t[o]}</span><span class="s0">return </span><span class="s1">s}}</span><span class="s0">const </span><span class="s1">_t=t=&gt;</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t?</span><span class="s3">0</span><span class="s1">:Wt.test(t)?Wt.getAnimatableNone(t):t;</span><span class="s0">const </span><span class="s1">Zt={test:</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">return </span><span class="s1">isNaN(t)&amp;&amp;</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t&amp;&amp;(t.match(jt)?.length||</span><span class="s3">0</span><span class="s1">)+(t.match($t)?.length||</span><span class="s3">0</span><span class="s1">)&gt;</span><span class="s3">0</span><span class="s1">},parse:Gt,createTransformer:qt,getAnimatableNone:</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">const </span><span class="s1">e=Gt(t);</span><span class="s0">return </span><span class="s1">qt(t)(e.map(_t))}};</span><span class="s0">function </span><span class="s1">Jt(t,e,i){</span><span class="s0">return </span><span class="s1">i&lt;</span><span class="s3">0</span><span class="s1">&amp;&amp;(i+=</span><span class="s3">1</span><span class="s1">),i&gt;</span><span class="s3">1</span><span class="s1">&amp;&amp;(i-=</span><span class="s3">1</span><span class="s1">),i&lt;</span><span class="s3">1</span><span class="s1">/</span><span class="s3">6</span><span class="s1">?t+</span><span class="s3">6</span><span class="s1">*(e-t)*i:i&lt;</span><span class="s3">.5</span><span class="s1">?e:i&lt;</span><span class="s3">2</span><span class="s1">/</span><span class="s3">3</span><span class="s1">?t+(e-t)*(</span><span class="s3">2</span><span class="s1">/</span><span class="s3">3</span><span class="s1">-i)*</span><span class="s3">6</span><span class="s1">:t}</span><span class="s0">function </span><span class="s1">Qt(t,e){</span><span class="s0">return </span><span class="s1">i=&gt;i&gt;</span><span class="s3">0</span><span class="s1">?e:t}</span><span class="s0">const </span><span class="s1">te=(t,e,i)=&gt;t+(e-t)*i,ee=(t,e,i)=&gt;{</span><span class="s0">const </span><span class="s1">n=t*t,s=i*(e*e-n)+n;</span><span class="s0">return </span><span class="s1">s&lt;</span><span class="s3">0</span><span class="s1">?</span><span class="s3">0</span><span class="s1">:Math.sqrt(s)},ie=[Nt,Ut,Kt];</span><span class="s0">function </span><span class="s1">ne(t){</span><span class="s0">const </span><span class="s1">e=(i=t,ie.find(t=&gt;t.test(i)));</span><span class="s0">var </span><span class="s1">i;</span><span class="s0">if</span><span class="s1">(!Boolean(e))</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">let </span><span class="s1">n=e.parse(t);</span><span class="s0">return </span><span class="s1">e===Kt&amp;&amp;(n=</span><span class="s0">function</span><span class="s1">({hue:t,saturation:e,lightness:i,alpha:n}){t/=</span><span class="s3">360</span><span class="s1">,i/=</span><span class="s3">100</span><span class="s1">;</span><span class="s0">let </span><span class="s1">s=</span><span class="s3">0</span><span class="s1">,o=</span><span class="s3">0</span><span class="s1">,r=</span><span class="s3">0</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(e/=</span><span class="s3">100</span><span class="s1">){</span><span class="s0">const </span><span class="s1">n=i&lt;</span><span class="s3">.5</span><span class="s1">?i*(</span><span class="s3">1</span><span class="s1">+e):i+e-i*e,a=</span><span class="s3">2</span><span class="s1">*i-n;s=Jt(a,n,t+</span><span class="s3">1</span><span class="s1">/</span><span class="s3">3</span><span class="s1">),o=Jt(a,n,t),r=Jt(a,n,t-</span><span class="s3">1</span><span class="s1">/</span><span class="s3">3</span><span class="s1">)}</span><span class="s0">else </span><span class="s1">s=o=r=i;</span><span class="s0">return</span><span class="s1">{red:Math.round(</span><span class="s3">255</span><span class="s1">*s),green:Math.round(</span><span class="s3">255</span><span class="s1">*o),blue:Math.round(</span><span class="s3">255</span><span class="s1">*r),alpha:n}}(n)),n}</span><span class="s0">const </span><span class="s1">se=(t,e)=&gt;{</span><span class="s0">const </span><span class="s1">i=ne(t),n=ne(e);</span><span class="s0">if</span><span class="s1">(!i||!n)</span><span class="s0">return </span><span class="s1">Qt(t,e);</span><span class="s0">const </span><span class="s1">s={...i};</span><span class="s0">return </span><span class="s1">t=&gt;(s.red=ee(i.red,n.red,t),s.green=ee(i.green,n.green,t),s.blue=ee(i.blue,n.blue,t),s.alpha=te(i.alpha,n.alpha,t),Ut.transform(s))},oe=</span><span class="s0">new </span><span class="s1">Set([</span><span class="s2">&quot;none&quot;</span><span class="s1">,</span><span class="s2">&quot;hidden&quot;</span><span class="s1">]);</span><span class="s0">function </span><span class="s1">re(t,e){</span><span class="s0">return </span><span class="s1">i=&gt;te(t,e,i)}</span><span class="s0">function </span><span class="s1">ae(t){</span><span class="s0">return</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t?re:</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t?s(t)?Qt:Wt.test(t)?se:ue:Array.isArray(t)?le:</span><span class="s2">&quot;object&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t?Wt.test(t)?se:he:Qt}</span><span class="s0">function </span><span class="s1">le(t,e){</span><span class="s0">const </span><span class="s1">i=[...t],n=i.length,s=t.map((t,i)=&gt;ae(t)(t,e[i]));</span><span class="s0">return </span><span class="s1">t=&gt;{</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">0</span><span class="s1">;e&lt;n;e++)i[e]=s[e](t);</span><span class="s0">return </span><span class="s1">i}}</span><span class="s0">function </span><span class="s1">he(t,e){</span><span class="s0">const </span><span class="s1">i={...t,...e},n={};</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">s </span><span class="s0">in </span><span class="s1">i)</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==t[s]&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==e[s]&amp;&amp;(n[s]=ae(t[s])(t[s],e[s]));</span><span class="s0">return </span><span class="s1">t=&gt;{</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">e </span><span class="s0">in </span><span class="s1">n)i[e]=n[e](t);</span><span class="s0">return </span><span class="s1">i}}</span><span class="s0">const </span><span class="s1">ue=(t,e)=&gt;{</span><span class="s0">const </span><span class="s1">i=Zt.createTransformer(e),n=Ht(t),s=Ht(e);</span><span class="s0">return </span><span class="s1">n.indexes.var.length===s.indexes.var.length&amp;&amp;n.indexes.color.length===s.indexes.color.length&amp;&amp;n.indexes.number.length&gt;=s.indexes.number.length?oe.has(t)&amp;&amp;!s.values.length||oe.has(e)&amp;&amp;!n.values.length?</span><span class="s0">function</span><span class="s1">(t,e){</span><span class="s0">return </span><span class="s1">oe.has(t)?i=&gt;i&lt;=</span><span class="s3">0</span><span class="s1">?t:e:i=&gt;i&gt;=</span><span class="s3">1</span><span class="s1">?e:t}(t,e):tt(le(</span><span class="s0">function</span><span class="s1">(t,e){</span><span class="s0">const </span><span class="s1">i=[],n={color:</span><span class="s3">0</span><span class="s1">,</span><span class="s0">var</span><span class="s1">:</span><span class="s3">0</span><span class="s1">,number:</span><span class="s3">0</span><span class="s1">};</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">s=</span><span class="s3">0</span><span class="s1">;s&lt;e.values.length;s++){</span><span class="s0">const </span><span class="s1">o=e.types[s],r=t.indexes[o][n[o]],a=t.values[r]??</span><span class="s3">0</span><span class="s1">;i[s]=a,n[o]++}</span><span class="s0">return </span><span class="s1">i}(n,s),s.values),i):Qt(t,e)};</span><span class="s0">function </span><span class="s1">ce(t,e,i){</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t&amp;&amp;</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e&amp;&amp;</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">i)</span><span class="s0">return </span><span class="s1">te(t,e,i);</span><span class="s0">return </span><span class="s1">ae(t)(t,e)}</span><span class="s0">const </span><span class="s1">de=t=&gt;{</span><span class="s0">const </span><span class="s1">e=({timestamp:e})=&gt;t(e);</span><span class="s0">return</span><span class="s1">{start:(t=!</span><span class="s3">0</span><span class="s1">)=&gt;Et.update(e,t),stop:()=&gt;Vt(e),now:()=&gt;Mt.isProcessing?Mt.timestamp:Rt.now()}},pe=(t,e,i=</span><span class="s3">10</span><span class="s1">)=&gt;{</span><span class="s0">let </span><span class="s1">n=</span><span class="s2">&quot;&quot;</span><span class="s1">;</span><span class="s0">const </span><span class="s1">s=Math.max(Math.round(e/i),</span><span class="s3">2</span><span class="s1">);</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">0</span><span class="s1">;e&lt;s;e++)n+=Math.round(</span><span class="s3">1e4</span><span class="s1">*t(e/(s-</span><span class="s3">1</span><span class="s1">)))/</span><span class="s3">1e4</span><span class="s1">+</span><span class="s2">&quot;, &quot;</span><span class="s1">;</span><span class="s0">return</span><span class="s2">`linear(</span><span class="s1">${n.substring(</span><span class="s3">0</span><span class="s1">,n.length-</span><span class="s3">2</span><span class="s1">)}</span><span class="s2">)`</span><span class="s1">},me=</span><span class="s3">2e4</span><span class="s1">;</span><span class="s0">function </span><span class="s1">fe(t){</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">0</span><span class="s1">;</span><span class="s0">let </span><span class="s1">i=t.next(e);</span><span class="s0">for</span><span class="s1">(;!i.done&amp;&amp;e&lt;me;)e+=</span><span class="s3">50</span><span class="s1">,i=t.next(e);</span><span class="s0">return </span><span class="s1">e&gt;=me?</span><span class="s3">1</span><span class="s1">/</span><span class="s3">0</span><span class="s1">:e}</span><span class="s0">function </span><span class="s1">ye(t,e,i){</span><span class="s0">const </span><span class="s1">n=Math.max(e-</span><span class="s3">5</span><span class="s1">,</span><span class="s3">0</span><span class="s1">);</span><span class="s0">return </span><span class="s1">ot(i-t(n),e-n)}</span><span class="s0">const </span><span class="s1">ge=</span><span class="s3">100</span><span class="s1">,ve=</span><span class="s3">10</span><span class="s1">,xe=</span><span class="s3">1</span><span class="s1">,Te=</span><span class="s3">0</span><span class="s1">,Pe=</span><span class="s3">800</span><span class="s1">,we=</span><span class="s3">.3</span><span class="s1">,Se=</span><span class="s3">.3</span><span class="s1">,Ae={granular:</span><span class="s3">.01</span><span class="s1">,</span><span class="s0">default</span><span class="s1">:</span><span class="s3">2</span><span class="s1">},be={granular:</span><span class="s3">.005</span><span class="s1">,</span><span class="s0">default</span><span class="s1">:</span><span class="s3">.5</span><span class="s1">},Ee=</span><span class="s3">.01</span><span class="s1">,Ve=</span><span class="s3">10</span><span class="s1">,Me=</span><span class="s3">.05</span><span class="s1">,De=</span><span class="s3">1</span><span class="s1">,Ce=</span><span class="s3">.001</span><span class="s1">;</span><span class="s0">function </span><span class="s1">ke({duration:t=Pe,bounce:e=we,velocity:n=Te,mass:s=xe}){</span><span class="s0">let </span><span class="s1">o,r,a=</span><span class="s3">1</span><span class="s1">-e;a=i(Me,De,a),t=i(Ee,Ve,st(t)),a&lt;</span><span class="s3">1</span><span class="s1">?(o=e=&gt;{</span><span class="s0">const </span><span class="s1">i=e*a,s=i*t,o=i-n,r=Le(e,a),l=Math.exp(-s);</span><span class="s0">return </span><span class="s1">Ce-o/r*l},r=e=&gt;{</span><span class="s0">const </span><span class="s1">i=e*a*t,s=i*n+n,r=Math.pow(a,</span><span class="s3">2</span><span class="s1">)*Math.pow(e,</span><span class="s3">2</span><span class="s1">)*t,l=Math.exp(-i),h=Le(Math.pow(e,</span><span class="s3">2</span><span class="s1">),a);</span><span class="s0">return</span><span class="s1">(-o(e)+Ce&gt;</span><span class="s3">0</span><span class="s1">?-</span><span class="s3">1</span><span class="s1">:</span><span class="s3">1</span><span class="s1">)*((s-r)*l)/h}):(o=e=&gt;Math.exp(-e*t)*((e-n)*t+</span><span class="s3">1</span><span class="s1">)-</span><span class="s3">.001</span><span class="s1">,r=e=&gt;Math.exp(-e*t)*(t*t*(n-e)));</span><span class="s0">const </span><span class="s1">l=</span><span class="s0">function</span><span class="s1">(t,e,i){</span><span class="s0">let </span><span class="s1">n=i;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">i=</span><span class="s3">1</span><span class="s1">;i&lt;Re;i++)n-=t(n)/e(n);</span><span class="s0">return </span><span class="s1">n}(o,r,</span><span class="s3">5</span><span class="s1">/t);</span><span class="s0">if</span><span class="s1">(t=nt(t),isNaN(l))</span><span class="s0">return</span><span class="s1">{stiffness:ge,damping:ve,duration:t};{</span><span class="s0">const </span><span class="s1">e=Math.pow(l,</span><span class="s3">2</span><span class="s1">)*s;</span><span class="s0">return</span><span class="s1">{stiffness:e,damping:</span><span class="s3">2</span><span class="s1">*a*Math.sqrt(s*e),duration:t}}}</span><span class="s0">const </span><span class="s1">Re=</span><span class="s3">12</span><span class="s1">;</span><span class="s0">function </span><span class="s1">Le(t,e){</span><span class="s0">return </span><span class="s1">t*Math.sqrt(</span><span class="s3">1</span><span class="s1">-e*e)}</span><span class="s0">const </span><span class="s1">je=[</span><span class="s2">&quot;duration&quot;</span><span class="s1">,</span><span class="s2">&quot;bounce&quot;</span><span class="s1">],Be=[</span><span class="s2">&quot;stiffness&quot;</span><span class="s1">,</span><span class="s2">&quot;damping&quot;</span><span class="s1">,</span><span class="s2">&quot;mass&quot;</span><span class="s1">];</span><span class="s0">function </span><span class="s1">Fe(t,e){</span><span class="s0">return </span><span class="s1">e.some(e=&gt;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==t[e])}</span><span class="s0">function </span><span class="s1">Ie(t=Se,e=we){</span><span class="s0">const </span><span class="s1">n=</span><span class="s2">&quot;object&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">t?{visualDuration:t,keyframes:[</span><span class="s3">0</span><span class="s1">,</span><span class="s3">1</span><span class="s1">],bounce:e}:t;</span><span class="s0">let</span><span class="s1">{restSpeed:s,restDelta:o}=n;</span><span class="s0">const </span><span class="s1">r=n.keyframes[</span><span class="s3">0</span><span class="s1">],a=n.keyframes[n.keyframes.length-</span><span class="s3">1</span><span class="s1">],l={done:!</span><span class="s3">1</span><span class="s1">,value:r},{stiffness:h,damping:u,mass:c,duration:d,velocity:p,isResolvedFromDuration:m}=</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">let </span><span class="s1">e={velocity:Te,stiffness:ge,damping:ve,mass:xe,isResolvedFromDuration:!</span><span class="s3">1</span><span class="s1">,...t};</span><span class="s0">if</span><span class="s1">(!Fe(t,Be)&amp;&amp;Fe(t,je))</span><span class="s0">if</span><span class="s1">(t.visualDuration){</span><span class="s0">const </span><span class="s1">n=t.visualDuration,s=</span><span class="s3">2</span><span class="s1">*Math.PI/(</span><span class="s3">1.2</span><span class="s1">*n),o=s*s,r=</span><span class="s3">2</span><span class="s1">*i(</span><span class="s3">.05</span><span class="s1">,</span><span class="s3">1</span><span class="s1">,</span><span class="s3">1</span><span class="s1">-(t.bounce||</span><span class="s3">0</span><span class="s1">))*Math.sqrt(o);e={...e,mass:xe,stiffness:o,damping:r}}</span><span class="s0">else</span><span class="s1">{</span><span class="s0">const </span><span class="s1">i=ke(t);e={...e,...i,mass:xe},e.isResolvedFromDuration=!</span><span class="s3">0</span><span class="s1">}</span><span class="s0">return </span><span class="s1">e}({...n,velocity:-st(n.velocity||</span><span class="s3">0</span><span class="s1">)}),f=p||</span><span class="s3">0</span><span class="s1">,y=u/(</span><span class="s3">2</span><span class="s1">*Math.sqrt(h*c)),g=a-r,v=st(Math.sqrt(h/c)),x=Math.abs(g)&lt;</span><span class="s3">5</span><span class="s1">;</span><span class="s0">let </span><span class="s1">T;</span><span class="s0">if</span><span class="s1">(s||(s=x?Ae.granular:Ae.default),o||(o=x?be.granular:be.default),y&lt;</span><span class="s3">1</span><span class="s1">){</span><span class="s0">const </span><span class="s1">t=Le(v,y);T=e=&gt;{</span><span class="s0">const </span><span class="s1">i=Math.exp(-y*v*e);</span><span class="s0">return </span><span class="s1">a-i*((f+y*v*g)/t*Math.sin(t*e)+g*Math.cos(t*e))}}</span><span class="s0">else if</span><span class="s1">(</span><span class="s3">1</span><span class="s1">===y)T=t=&gt;a-Math.exp(-v*t)*(g+(f+v*g)*t);</span><span class="s0">else</span><span class="s1">{</span><span class="s0">const </span><span class="s1">t=v*Math.sqrt(y*y-</span><span class="s3">1</span><span class="s1">);T=e=&gt;{</span><span class="s0">const </span><span class="s1">i=Math.exp(-y*v*e),n=Math.min(t*e,</span><span class="s3">300</span><span class="s1">);</span><span class="s0">return </span><span class="s1">a-i*((f+y*v*g)*Math.sinh(n)+t*g*Math.cosh(n))/t}}</span><span class="s0">const </span><span class="s1">P={calculatedDuration:m&amp;&amp;d||</span><span class="s0">null</span><span class="s1">,next:t=&gt;{</span><span class="s0">const </span><span class="s1">e=T(t);</span><span class="s0">if</span><span class="s1">(m)l.done=t&gt;=d;</span><span class="s0">else</span><span class="s1">{</span><span class="s0">let </span><span class="s1">i=</span><span class="s3">0</span><span class="s1">===t?f:</span><span class="s3">0</span><span class="s1">;y&lt;</span><span class="s3">1</span><span class="s1">&amp;&amp;(i=</span><span class="s3">0</span><span class="s1">===t?nt(f):ye(T,t,e));</span><span class="s0">const </span><span class="s1">n=Math.abs(i)&lt;=s,r=Math.abs(a-e)&lt;=o;l.done=n&amp;&amp;r}</span><span class="s0">return </span><span class="s1">l.value=l.done?a:e,l},toString:()=&gt;{</span><span class="s0">const </span><span class="s1">t=Math.min(fe(P),me),e=pe(e=&gt;P.next(t*e).value,t,</span><span class="s3">30</span><span class="s1">);</span><span class="s0">return </span><span class="s1">t+</span><span class="s2">&quot;ms &quot;</span><span class="s1">+e},toTransition:()=&gt;{}};</span><span class="s0">return </span><span class="s1">P}</span><span class="s0">function </span><span class="s1">Oe({keyframes:t,velocity:e=</span><span class="s3">0</span><span class="s1">,power:i=</span><span class="s3">.8</span><span class="s1">,timeConstant:n=</span><span class="s3">325</span><span class="s1">,bounceDamping:s=</span><span class="s3">10</span><span class="s1">,bounceStiffness:o=</span><span class="s3">500</span><span class="s1">,modifyTarget:r,min:a,max:l,restDelta:h=</span><span class="s3">.5</span><span class="s1">,restSpeed:u}){</span><span class="s0">const </span><span class="s1">c=t[</span><span class="s3">0</span><span class="s1">],d={done:!</span><span class="s3">1</span><span class="s1">,value:c},p=t=&gt;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===a?l:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===l||Math.abs(a-t)&lt;Math.abs(l-t)?a:l;</span><span class="s0">let </span><span class="s1">m=i*e;</span><span class="s0">const </span><span class="s1">f=c+m,y=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===r?f:r(f);y!==f&amp;&amp;(m=y-c);</span><span class="s0">const </span><span class="s1">g=t=&gt;-m*Math.exp(-t/n),v=t=&gt;y+g(t),x=t=&gt;{</span><span class="s0">const </span><span class="s1">e=g(t),i=v(t);d.done=Math.abs(e)&lt;=h,d.value=d.done?y:i};</span><span class="s0">let </span><span class="s1">T,P;</span><span class="s0">const </span><span class="s1">w=t=&gt;{</span><span class="s0">var </span><span class="s1">e;(e=d.value,</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==a&amp;&amp;e&lt;a||</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==l&amp;&amp;e&gt;l)&amp;&amp;(T=t,P=Ie({keyframes:[d.value,p(d.value)],velocity:ye(v,t,d.value),damping:s,stiffness:o,restDelta:h,restSpeed:u}))};</span><span class="s0">return </span><span class="s1">w(</span><span class="s3">0</span><span class="s1">),{calculatedDuration:</span><span class="s0">null</span><span class="s1">,next:t=&gt;{</span><span class="s0">let </span><span class="s1">e=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">return </span><span class="s1">P||</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==T||(e=!</span><span class="s3">0</span><span class="s1">,x(t),w(t)),</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==T&amp;&amp;t&gt;=T?P.next(t-T):(!e&amp;&amp;x(t),d)}}}</span><span class="s0">function </span><span class="s1">Ue(t,e,{clamp:n=!</span><span class="s3">0</span><span class="s1">,ease:s,mixer:o}={}){</span><span class="s0">const </span><span class="s1">r=t.length;</span><span class="s0">if</span><span class="s1">(e.length,</span><span class="s3">1</span><span class="s1">===r)</span><span class="s0">return</span><span class="s1">()=&gt;e[</span><span class="s3">0</span><span class="s1">];</span><span class="s0">if</span><span class="s1">(</span><span class="s3">2</span><span class="s1">===r&amp;&amp;e[</span><span class="s3">0</span><span class="s1">]===e[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">return</span><span class="s1">()=&gt;e[</span><span class="s3">1</span><span class="s1">];</span><span class="s0">const </span><span class="s1">a=t[</span><span class="s3">0</span><span class="s1">]===t[</span><span class="s3">1</span><span class="s1">];t[</span><span class="s3">0</span><span class="s1">]&gt;t[r-</span><span class="s3">1</span><span class="s1">]&amp;&amp;(t=[...t].reverse(),e=[...e].reverse());</span><span class="s0">const </span><span class="s1">l=</span><span class="s0">function</span><span class="s1">(t,e,i){</span><span class="s0">const </span><span class="s1">n=[],s=i||H.mix||ce,o=t.length-</span><span class="s3">1</span><span class="s1">;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">i=</span><span class="s3">0</span><span class="s1">;i&lt;o;i++){</span><span class="s0">let </span><span class="s1">o=s(t[i],t[i+</span><span class="s3">1</span><span class="s1">]);</span><span class="s0">if</span><span class="s1">(e){</span><span class="s0">const </span><span class="s1">t=Array.isArray(e)?e[i]||J:e;o=tt(t,o)}n.push(o)}</span><span class="s0">return </span><span class="s1">n}(e,s,o),h=l.length,u=i=&gt;{</span><span class="s0">if</span><span class="s1">(a&amp;&amp;i&lt;t[</span><span class="s3">0</span><span class="s1">])</span><span class="s0">return </span><span class="s1">e[</span><span class="s3">0</span><span class="s1">];</span><span class="s0">let </span><span class="s1">n=</span><span class="s3">0</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(h&gt;</span><span class="s3">1</span><span class="s1">)</span><span class="s0">for</span><span class="s1">(;n&lt;t.length-</span><span class="s3">2</span><span class="s1">&amp;&amp;!(i&lt;t[n+</span><span class="s3">1</span><span class="s1">]);n++);</span><span class="s0">const </span><span class="s1">s=et(t[n],t[n+</span><span class="s3">1</span><span class="s1">],i);</span><span class="s0">return </span><span class="s1">l[n](s)};</span><span class="s0">return </span><span class="s1">n?e=&gt;u(i(t[</span><span class="s3">0</span><span class="s1">],t[r-</span><span class="s3">1</span><span class="s1">],e)):u}</span><span class="s0">function </span><span class="s1">Ne(t){</span><span class="s0">const </span><span class="s1">e=[</span><span class="s3">0</span><span class="s1">];</span><span class="s0">return function</span><span class="s1">(t,e){</span><span class="s0">const </span><span class="s1">i=t[t.length-</span><span class="s3">1</span><span class="s1">];</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">n=</span><span class="s3">1</span><span class="s1">;n&lt;=e;n++){</span><span class="s0">const </span><span class="s1">s=et(</span><span class="s3">0</span><span class="s1">,e,n);t.push(te(i,</span><span class="s3">1</span><span class="s1">,s))}}(e,t.length-</span><span class="s3">1</span><span class="s1">),e}</span><span class="s0">function </span><span class="s1">Ke({duration:t=</span><span class="s3">300</span><span class="s1">,keyframes:e,times:i,ease:n=</span><span class="s2">&quot;easeInOut&quot;</span><span class="s1">}){</span><span class="s0">const </span><span class="s1">s=(t=&gt;Array.isArray(t)&amp;&amp;</span><span class="s2">&quot;number&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">t[</span><span class="s3">0</span><span class="s1">])(n)?n.map(wt):wt(n),o={done:!</span><span class="s3">1</span><span class="s1">,value:e[</span><span class="s3">0</span><span class="s1">]},r=</span><span class="s0">function</span><span class="s1">(t,e){</span><span class="s0">return </span><span class="s1">t.map(t=&gt;t*e)}(i&amp;&amp;i.length===e.length?i:Ne(e),t),a=Ue(r,e,{ease:Array.isArray(s)?s:(l=e,h=s,l.map(()=&gt;h||xt).splice(</span><span class="s3">0</span><span class="s1">,l.length-</span><span class="s3">1</span><span class="s1">))});</span><span class="s0">var </span><span class="s1">l,h;</span><span class="s0">return</span><span class="s1">{calculatedDuration:t,next:e=&gt;(o.value=a(e),o.done=e&gt;=t,o)}}Ie.applyToOptions=t=&gt;{</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">function</span><span class="s1">(t,e=</span><span class="s3">100</span><span class="s1">,i){</span><span class="s0">const </span><span class="s1">n=i({...t,keyframes:[</span><span class="s3">0</span><span class="s1">,e]}),s=Math.min(fe(n),me);</span><span class="s0">return</span><span class="s1">{type:</span><span class="s2">&quot;keyframes&quot;</span><span class="s1">,ease:t=&gt;n.next(s*t).value/e,duration:st(s)}}(t,</span><span class="s3">100</span><span class="s1">,Ie);</span><span class="s0">return </span><span class="s1">t.ease=e.ease,t.duration=nt(e.duration),t.type=</span><span class="s2">&quot;keyframes&quot;</span><span class="s1">,t};</span><span class="s0">const </span><span class="s1">We=t=&gt;</span><span class="s0">null</span><span class="s1">!==t;</span><span class="s0">function </span><span class="s1">$e(t,{repeat:e,repeatType:i=</span><span class="s2">&quot;loop&quot;</span><span class="s1">},n,s=</span><span class="s3">1</span><span class="s1">){</span><span class="s0">const </span><span class="s1">o=t.filter(We),r=s&lt;</span><span class="s3">0</span><span class="s1">||e&amp;&amp;</span><span class="s2">&quot;loop&quot;</span><span class="s1">!==i&amp;&amp;e%</span><span class="s3">2</span><span class="s1">==</span><span class="s3">1</span><span class="s1">?</span><span class="s3">0</span><span class="s1">:o.length-</span><span class="s3">1</span><span class="s1">;</span><span class="s0">return </span><span class="s1">r&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==n?n:o[r]}</span><span class="s0">const </span><span class="s1">ze={decay:Oe,inertia:Oe,tween:Ke,keyframes:Ke,spring:Ie};</span><span class="s0">function </span><span class="s1">Ye(t){</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t.type&amp;&amp;(t.type=ze[t.type])}</span><span class="s0">class </span><span class="s1">Xe{constructor(){</span><span class="s0">this</span><span class="s1">.updateFinished()}get finished(){</span><span class="s0">return this</span><span class="s1">._finished}updateFinished(){</span><span class="s0">this</span><span class="s1">._finished=</span><span class="s0">new </span><span class="s1">Promise(t=&gt;{</span><span class="s0">this</span><span class="s1">.resolve=t})}notifyFinished(){</span><span class="s0">this</span><span class="s1">.resolve()}then(t,e){</span><span class="s0">return this</span><span class="s1">.finished.then(t,e)}}</span><span class="s0">const </span><span class="s1">He=t=&gt;t/</span><span class="s3">100</span><span class="s1">;</span><span class="s0">class </span><span class="s1">Ge </span><span class="s0">extends </span><span class="s1">Xe{constructor(t){</span><span class="s0">super</span><span class="s1">(),</span><span class="s0">this</span><span class="s1">.state=</span><span class="s2">&quot;idle&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.startTime=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isStopped=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.currentTime=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.holdTime=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.playbackSpeed=</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.stop=()=&gt;{</span><span class="s0">const</span><span class="s1">{motionValue:t}=</span><span class="s0">this</span><span class="s1">.options;t&amp;&amp;t.updatedAt!==Rt.now()&amp;&amp;</span><span class="s0">this</span><span class="s1">.tick(Rt.now()),</span><span class="s0">this</span><span class="s1">.isStopped=!</span><span class="s3">0</span><span class="s1">,</span><span class="s2">&quot;idle&quot;</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.state&amp;&amp;(</span><span class="s0">this</span><span class="s1">.teardown(),</span><span class="s0">this</span><span class="s1">.options.onStop?.())},</span><span class="s0">this</span><span class="s1">.options=t,</span><span class="s0">this</span><span class="s1">.initAnimation(),</span><span class="s0">this</span><span class="s1">.play(),!</span><span class="s3">1</span><span class="s1">===t.autoplay&amp;&amp;</span><span class="s0">this</span><span class="s1">.pause()}initAnimation(){</span><span class="s0">const</span><span class="s1">{options:t}=</span><span class="s0">this</span><span class="s1">;Ye(t);</span><span class="s0">const</span><span class="s1">{type:e=Ke,repeat:i=</span><span class="s3">0</span><span class="s1">,repeatDelay:n=</span><span class="s3">0</span><span class="s1">,repeatType:s,velocity:o=</span><span class="s3">0</span><span class="s1">}=t;</span><span class="s0">let</span><span class="s1">{keyframes:r}=t;</span><span class="s0">const </span><span class="s1">a=e||Ke;a!==Ke&amp;&amp;</span><span class="s2">&quot;number&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">r[</span><span class="s3">0</span><span class="s1">]&amp;&amp;(</span><span class="s0">this</span><span class="s1">.mixKeyframes=tt(He,ce(r[</span><span class="s3">0</span><span class="s1">],r[</span><span class="s3">1</span><span class="s1">])),r=[</span><span class="s3">0</span><span class="s1">,</span><span class="s3">100</span><span class="s1">]);</span><span class="s0">const </span><span class="s1">l=a({...t,keyframes:r});</span><span class="s2">&quot;mirror&quot;</span><span class="s1">===s&amp;&amp;(</span><span class="s0">this</span><span class="s1">.mirroredGenerator=a({...t,keyframes:[...r].reverse(),velocity:-o})),</span><span class="s0">null</span><span class="s1">===l.calculatedDuration&amp;&amp;(l.calculatedDuration=fe(l));</span><span class="s0">const</span><span class="s1">{calculatedDuration:h}=l;</span><span class="s0">this</span><span class="s1">.calculatedDuration=h,</span><span class="s0">this</span><span class="s1">.resolvedDuration=h+n,</span><span class="s0">this</span><span class="s1">.totalDuration=</span><span class="s0">this</span><span class="s1">.resolvedDuration*(i+</span><span class="s3">1</span><span class="s1">)-n,</span><span class="s0">this</span><span class="s1">.generator=l}updateTime(t){</span><span class="s0">const </span><span class="s1">e=Math.round(t-</span><span class="s0">this</span><span class="s1">.startTime)*</span><span class="s0">this</span><span class="s1">.playbackSpeed;</span><span class="s0">null</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.holdTime?</span><span class="s0">this</span><span class="s1">.currentTime=</span><span class="s0">this</span><span class="s1">.holdTime:</span><span class="s0">this</span><span class="s1">.currentTime=e}tick(t,e=!</span><span class="s3">1</span><span class="s1">){</span><span class="s0">const</span><span class="s1">{generator:n,totalDuration:s,mixKeyframes:o,mirroredGenerator:r,resolvedDuration:a,calculatedDuration:l}=</span><span class="s0">this</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">null</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.startTime)</span><span class="s0">return </span><span class="s1">n.next(</span><span class="s3">0</span><span class="s1">);</span><span class="s0">const</span><span class="s1">{delay:h=</span><span class="s3">0</span><span class="s1">,keyframes:u,repeat:c,repeatType:d,repeatDelay:p,type:m,onUpdate:f,finalKeyframe:y}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">this</span><span class="s1">.speed&gt;</span><span class="s3">0</span><span class="s1">?</span><span class="s0">this</span><span class="s1">.startTime=Math.min(</span><span class="s0">this</span><span class="s1">.startTime,t):</span><span class="s0">this</span><span class="s1">.speed&lt;</span><span class="s3">0</span><span class="s1">&amp;&amp;(</span><span class="s0">this</span><span class="s1">.startTime=Math.min(t-s/</span><span class="s0">this</span><span class="s1">.speed,</span><span class="s0">this</span><span class="s1">.startTime)),e?</span><span class="s0">this</span><span class="s1">.currentTime=t:</span><span class="s0">this</span><span class="s1">.updateTime(t);</span><span class="s0">const </span><span class="s1">g=</span><span class="s0">this</span><span class="s1">.currentTime-h*(</span><span class="s0">this</span><span class="s1">.playbackSpeed&gt;=</span><span class="s3">0</span><span class="s1">?</span><span class="s3">1</span><span class="s1">:-</span><span class="s3">1</span><span class="s1">),v=</span><span class="s0">this</span><span class="s1">.playbackSpeed&gt;=</span><span class="s3">0</span><span class="s1">?g&lt;</span><span class="s3">0</span><span class="s1">:g&gt;s;</span><span class="s0">this</span><span class="s1">.currentTime=Math.max(g,</span><span class="s3">0</span><span class="s1">),</span><span class="s2">&quot;finished&quot;</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.state&amp;&amp;</span><span class="s0">null</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.holdTime&amp;&amp;(</span><span class="s0">this</span><span class="s1">.currentTime=s);</span><span class="s0">let </span><span class="s1">x=</span><span class="s0">this</span><span class="s1">.currentTime,T=n;</span><span class="s0">if</span><span class="s1">(c){</span><span class="s0">const </span><span class="s1">t=Math.min(</span><span class="s0">this</span><span class="s1">.currentTime,s)/a;</span><span class="s0">let </span><span class="s1">e=Math.floor(t),n=t%</span><span class="s3">1</span><span class="s1">;!n&amp;&amp;t&gt;=</span><span class="s3">1</span><span class="s1">&amp;&amp;(n=</span><span class="s3">1</span><span class="s1">),</span><span class="s3">1</span><span class="s1">===n&amp;&amp;e--,e=Math.min(e,c+</span><span class="s3">1</span><span class="s1">);Boolean(e%</span><span class="s3">2</span><span class="s1">)&amp;&amp;(</span><span class="s2">&quot;reverse&quot;</span><span class="s1">===d?(n=</span><span class="s3">1</span><span class="s1">-n,p&amp;&amp;(n-=p/a)):</span><span class="s2">&quot;mirror&quot;</span><span class="s1">===d&amp;&amp;(T=r)),x=i(</span><span class="s3">0</span><span class="s1">,</span><span class="s3">1</span><span class="s1">,n)*a}</span><span class="s0">const </span><span class="s1">P=v?{done:!</span><span class="s3">1</span><span class="s1">,value:u[</span><span class="s3">0</span><span class="s1">]}:T.next(x);o&amp;&amp;(P.value=o(P.value));</span><span class="s0">let</span><span class="s1">{done:w}=P;v||</span><span class="s0">null</span><span class="s1">===l||(w=</span><span class="s0">this</span><span class="s1">.playbackSpeed&gt;=</span><span class="s3">0</span><span class="s1">?</span><span class="s0">this</span><span class="s1">.currentTime&gt;=s:</span><span class="s0">this</span><span class="s1">.currentTime&lt;=</span><span class="s3">0</span><span class="s1">);</span><span class="s0">const </span><span class="s1">S=</span><span class="s0">null</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.holdTime&amp;&amp;(</span><span class="s2">&quot;finished&quot;</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.state||</span><span class="s2">&quot;running&quot;</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.state&amp;&amp;w);</span><span class="s0">return </span><span class="s1">S&amp;&amp;m!==Oe&amp;&amp;(P.value=$e(u,</span><span class="s0">this</span><span class="s1">.options,y,</span><span class="s0">this</span><span class="s1">.speed)),f&amp;&amp;f(P.value),S&amp;&amp;</span><span class="s0">this</span><span class="s1">.finish(),P}then(t,e){</span><span class="s0">return this</span><span class="s1">.finished.then(t,e)}get duration(){</span><span class="s0">return </span><span class="s1">st(</span><span class="s0">this</span><span class="s1">.calculatedDuration)}get iterationDuration(){</span><span class="s0">const</span><span class="s1">{delay:t=</span><span class="s3">0</span><span class="s1">}=</span><span class="s0">this</span><span class="s1">.options||{};</span><span class="s0">return this</span><span class="s1">.duration+st(t)}get time(){</span><span class="s0">return </span><span class="s1">st(</span><span class="s0">this</span><span class="s1">.currentTime)}set time(t){t=nt(t),</span><span class="s0">this</span><span class="s1">.currentTime=t,</span><span class="s0">null</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.startTime||</span><span class="s0">null</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.holdTime||</span><span class="s3">0</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.playbackSpeed?</span><span class="s0">this</span><span class="s1">.holdTime=t:</span><span class="s0">this</span><span class="s1">.driver&amp;&amp;(</span><span class="s0">this</span><span class="s1">.startTime=</span><span class="s0">this</span><span class="s1">.driver.now()-t/</span><span class="s0">this</span><span class="s1">.playbackSpeed),</span><span class="s0">this</span><span class="s1">.driver?.start(!</span><span class="s3">1</span><span class="s1">)}get speed(){</span><span class="s0">return this</span><span class="s1">.playbackSpeed}set speed(t){</span><span class="s0">this</span><span class="s1">.updateTime(Rt.now());</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.playbackSpeed!==t;</span><span class="s0">this</span><span class="s1">.playbackSpeed=t,e&amp;&amp;(</span><span class="s0">this</span><span class="s1">.time=st(</span><span class="s0">this</span><span class="s1">.currentTime))}play(){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isStopped)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{driver:t=de,startTime:e}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">this</span><span class="s1">.driver||(</span><span class="s0">this</span><span class="s1">.driver=t(t=&gt;</span><span class="s0">this</span><span class="s1">.tick(t))),</span><span class="s0">this</span><span class="s1">.options.onPlay?.();</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">.driver.now();</span><span class="s2">&quot;finished&quot;</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.state?(</span><span class="s0">this</span><span class="s1">.updateFinished(),</span><span class="s0">this</span><span class="s1">.startTime=i):</span><span class="s0">null</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.holdTime?</span><span class="s0">this</span><span class="s1">.startTime=i-</span><span class="s0">this</span><span class="s1">.holdTime:</span><span class="s0">this</span><span class="s1">.startTime||(</span><span class="s0">this</span><span class="s1">.startTime=e??i),</span><span class="s2">&quot;finished&quot;</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.state&amp;&amp;</span><span class="s0">this</span><span class="s1">.speed&lt;</span><span class="s3">0</span><span class="s1">&amp;&amp;(</span><span class="s0">this</span><span class="s1">.startTime+=</span><span class="s0">this</span><span class="s1">.calculatedDuration),</span><span class="s0">this</span><span class="s1">.holdTime=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.state=</span><span class="s2">&quot;running&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.driver.start()}pause(){</span><span class="s0">this</span><span class="s1">.state=</span><span class="s2">&quot;paused&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.updateTime(Rt.now()),</span><span class="s0">this</span><span class="s1">.holdTime=</span><span class="s0">this</span><span class="s1">.currentTime}complete(){</span><span class="s2">&quot;running&quot;</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.state&amp;&amp;</span><span class="s0">this</span><span class="s1">.play(),</span><span class="s0">this</span><span class="s1">.state=</span><span class="s2">&quot;finished&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.holdTime=</span><span class="s0">null</span><span class="s1">}finish(){</span><span class="s0">this</span><span class="s1">.notifyFinished(),</span><span class="s0">this</span><span class="s1">.teardown(),</span><span class="s0">this</span><span class="s1">.state=</span><span class="s2">&quot;finished&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.options.onComplete?.()}cancel(){</span><span class="s0">this</span><span class="s1">.holdTime=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.startTime=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.tick(</span><span class="s3">0</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.teardown(),</span><span class="s0">this</span><span class="s1">.options.onCancel?.()}teardown(){</span><span class="s0">this</span><span class="s1">.state=</span><span class="s2">&quot;idle&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.stopDriver(),</span><span class="s0">this</span><span class="s1">.startTime=</span><span class="s0">this</span><span class="s1">.holdTime=</span><span class="s0">null</span><span class="s1">}stopDriver(){</span><span class="s0">this</span><span class="s1">.driver&amp;&amp;(</span><span class="s0">this</span><span class="s1">.driver.stop(),</span><span class="s0">this</span><span class="s1">.driver=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">)}sample(t){</span><span class="s0">return this</span><span class="s1">.startTime=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.tick(t,!</span><span class="s3">0</span><span class="s1">)}attachTimeline(t){</span><span class="s0">return this</span><span class="s1">.options.allowFlatten&amp;&amp;(</span><span class="s0">this</span><span class="s1">.options.type=</span><span class="s2">&quot;keyframes&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.options.ease=</span><span class="s2">&quot;linear&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.initAnimation()),</span><span class="s0">this</span><span class="s1">.driver?.stop(),t.observe(</span><span class="s0">this</span><span class="s1">)}}</span><span class="s0">const </span><span class="s1">qe=t=&gt;</span><span class="s3">180</span><span class="s1">*t/Math.PI,_e=t=&gt;{</span><span class="s0">const </span><span class="s1">e=qe(Math.atan2(t[</span><span class="s3">1</span><span class="s1">],t[</span><span class="s3">0</span><span class="s1">]));</span><span class="s0">return </span><span class="s1">Je(e)},Ze={x:</span><span class="s3">4</span><span class="s1">,y:</span><span class="s3">5</span><span class="s1">,translateX:</span><span class="s3">4</span><span class="s1">,translateY:</span><span class="s3">5</span><span class="s1">,scaleX:</span><span class="s3">0</span><span class="s1">,scaleY:</span><span class="s3">3</span><span class="s1">,scale:t=&gt;(Math.abs(t[</span><span class="s3">0</span><span class="s1">])+Math.abs(t[</span><span class="s3">3</span><span class="s1">]))/</span><span class="s3">2</span><span class="s1">,rotate:_e,rotateZ:_e,skewX:t=&gt;qe(Math.atan(t[</span><span class="s3">1</span><span class="s1">])),skewY:t=&gt;qe(Math.atan(t[</span><span class="s3">2</span><span class="s1">])),skew:t=&gt;(Math.abs(t[</span><span class="s3">1</span><span class="s1">])+Math.abs(t[</span><span class="s3">2</span><span class="s1">]))/</span><span class="s3">2</span><span class="s1">},Je=t=&gt;((t%=</span><span class="s3">360</span><span class="s1">)&lt;</span><span class="s3">0</span><span class="s1">&amp;&amp;(t+=</span><span class="s3">360</span><span class="s1">),t),Qe=t=&gt;Math.sqrt(t[</span><span class="s3">0</span><span class="s1">]*t[</span><span class="s3">0</span><span class="s1">]+t[</span><span class="s3">1</span><span class="s1">]*t[</span><span class="s3">1</span><span class="s1">]),ti=t=&gt;Math.sqrt(t[</span><span class="s3">4</span><span class="s1">]*t[</span><span class="s3">4</span><span class="s1">]+t[</span><span class="s3">5</span><span class="s1">]*t[</span><span class="s3">5</span><span class="s1">]),ei={x:</span><span class="s3">12</span><span class="s1">,y:</span><span class="s3">13</span><span class="s1">,z:</span><span class="s3">14</span><span class="s1">,translateX:</span><span class="s3">12</span><span class="s1">,translateY:</span><span class="s3">13</span><span class="s1">,translateZ:</span><span class="s3">14</span><span class="s1">,scaleX:Qe,scaleY:ti,scale:t=&gt;(Qe(t)+ti(t))/</span><span class="s3">2</span><span class="s1">,rotateX:t=&gt;Je(qe(Math.atan2(t[</span><span class="s3">6</span><span class="s1">],t[</span><span class="s3">5</span><span class="s1">]))),rotateY:t=&gt;Je(qe(Math.atan2(-t[</span><span class="s3">2</span><span class="s1">],t[</span><span class="s3">0</span><span class="s1">]))),rotateZ:_e,rotate:_e,skewX:t=&gt;qe(Math.atan(t[</span><span class="s3">4</span><span class="s1">])),skewY:t=&gt;qe(Math.atan(t[</span><span class="s3">1</span><span class="s1">])),skew:t=&gt;(Math.abs(t[</span><span class="s3">1</span><span class="s1">])+Math.abs(t[</span><span class="s3">4</span><span class="s1">]))/</span><span class="s3">2</span><span class="s1">};</span><span class="s0">function </span><span class="s1">ii(t){</span><span class="s0">return </span><span class="s1">t.includes(</span><span class="s2">&quot;scale&quot;</span><span class="s1">)?</span><span class="s3">1</span><span class="s1">:</span><span class="s3">0</span><span class="s1">}</span><span class="s0">function </span><span class="s1">ni(t,e){</span><span class="s0">if</span><span class="s1">(!t||</span><span class="s2">&quot;none&quot;</span><span class="s1">===t)</span><span class="s0">return </span><span class="s1">ii(e);</span><span class="s0">const </span><span class="s1">i=t.match(</span><span class="s4">/^matrix3d\(([-\d.e\s,]+)\)$/u</span><span class="s1">);</span><span class="s0">let </span><span class="s1">n,s;</span><span class="s0">if</span><span class="s1">(i)n=ei,s=i;</span><span class="s0">else</span><span class="s1">{</span><span class="s0">const </span><span class="s1">e=t.match(</span><span class="s4">/^matrix\(([-\d.e\s,]+)\)$/u</span><span class="s1">);n=Ze,s=e}</span><span class="s0">if</span><span class="s1">(!s)</span><span class="s0">return </span><span class="s1">ii(e);</span><span class="s0">const </span><span class="s1">o=n[e],r=s[</span><span class="s3">1</span><span class="s1">].split(</span><span class="s2">&quot;,&quot;</span><span class="s1">).map(si);</span><span class="s0">return</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">o?o(r):r[o]}</span><span class="s0">function </span><span class="s1">si(t){</span><span class="s0">return </span><span class="s1">parseFloat(t.trim())}</span><span class="s0">const </span><span class="s1">oi=e=&gt;e===t||e===o,ri=</span><span class="s0">new </span><span class="s1">Set([</span><span class="s2">&quot;x&quot;</span><span class="s1">,</span><span class="s2">&quot;y&quot;</span><span class="s1">,</span><span class="s2">&quot;z&quot;</span><span class="s1">]),ai=r.filter(t=&gt;!ri.has(t));</span><span class="s0">const </span><span class="s1">li={width:({x:t},{paddingLeft:e=</span><span class="s2">&quot;0&quot;</span><span class="s1">,paddingRight:i=</span><span class="s2">&quot;0&quot;</span><span class="s1">})=&gt;t.max-t.min-parseFloat(e)-parseFloat(i),height:({y:t},{paddingTop:e=</span><span class="s2">&quot;0&quot;</span><span class="s1">,paddingBottom:i=</span><span class="s2">&quot;0&quot;</span><span class="s1">})=&gt;t.max-t.min-parseFloat(e)-parseFloat(i),top:(t,{top:e})=&gt;parseFloat(e),left:(t,{left:e})=&gt;parseFloat(e),bottom:({y:t},{top:e})=&gt;parseFloat(e)+(t.max-t.min),right:({x:t},{left:e})=&gt;parseFloat(e)+(t.max-t.min),x:(t,{transform:e})=&gt;ni(e,</span><span class="s2">&quot;x&quot;</span><span class="s1">),y:(t,{transform:e})=&gt;ni(e,</span><span class="s2">&quot;y&quot;</span><span class="s1">)};li.translateX=li.x,li.translateY=li.y;</span><span class="s0">const </span><span class="s1">hi=</span><span class="s0">new </span><span class="s1">Set;</span><span class="s0">let </span><span class="s1">ui=!</span><span class="s3">1</span><span class="s1">,ci=!</span><span class="s3">1</span><span class="s1">,di=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">function </span><span class="s1">pi(){</span><span class="s0">if</span><span class="s1">(ci){</span><span class="s0">const </span><span class="s1">t=Array.from(hi).filter(t=&gt;t.needsMeasurement),e=</span><span class="s0">new </span><span class="s1">Set(t.map(t=&gt;t.element)),i=</span><span class="s0">new </span><span class="s1">Map;e.forEach(t=&gt;{</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">const </span><span class="s1">e=[];</span><span class="s0">return </span><span class="s1">ai.forEach(i=&gt;{</span><span class="s0">const </span><span class="s1">n=t.getValue(i);</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==n&amp;&amp;(e.push([i,n.get()]),n.set(i.startsWith(</span><span class="s2">&quot;scale&quot;</span><span class="s1">)?</span><span class="s3">1</span><span class="s1">:</span><span class="s3">0</span><span class="s1">))}),e}(t);e.length&amp;&amp;(i.set(t,e),t.render())}),t.forEach(t=&gt;t.measureInitialState()),e.forEach(t=&gt;{t.render();</span><span class="s0">const </span><span class="s1">e=i.get(t);e&amp;&amp;e.forEach(([e,i])=&gt;{t.getValue(e)?.set(i)})}),t.forEach(t=&gt;t.measureEndState()),t.forEach(t=&gt;{</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==t.suspendedScrollY&amp;&amp;window.scrollTo(</span><span class="s3">0</span><span class="s1">,t.suspendedScrollY)})}ci=!</span><span class="s3">1</span><span class="s1">,ui=!</span><span class="s3">1</span><span class="s1">,hi.forEach(t=&gt;t.complete(di)),hi.clear()}</span><span class="s0">function </span><span class="s1">mi(){hi.forEach(t=&gt;{t.readKeyframes(),t.needsMeasurement&amp;&amp;(ci=!</span><span class="s3">0</span><span class="s1">)})}</span><span class="s0">class </span><span class="s1">fi{constructor(t,e,i,n,s,o=!</span><span class="s3">1</span><span class="s1">){</span><span class="s0">this</span><span class="s1">.state=</span><span class="s2">&quot;pending&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isAsync=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.needsMeasurement=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.unresolvedKeyframes=[...t],</span><span class="s0">this</span><span class="s1">.onComplete=e,</span><span class="s0">this</span><span class="s1">.name=i,</span><span class="s0">this</span><span class="s1">.motionValue=n,</span><span class="s0">this</span><span class="s1">.element=s,</span><span class="s0">this</span><span class="s1">.isAsync=o}scheduleResolve(){</span><span class="s0">this</span><span class="s1">.state=</span><span class="s2">&quot;scheduled&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isAsync?(hi.add(</span><span class="s0">this</span><span class="s1">),ui||(ui=!</span><span class="s3">0</span><span class="s1">,Et.read(mi),Et.resolveKeyframes(pi))):(</span><span class="s0">this</span><span class="s1">.readKeyframes(),</span><span class="s0">this</span><span class="s1">.complete())}readKeyframes(){</span><span class="s0">const</span><span class="s1">{unresolvedKeyframes:t,name:e,element:i,motionValue:n}=</span><span class="s0">this</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">null</span><span class="s1">===t[</span><span class="s3">0</span><span class="s1">]){</span><span class="s0">const </span><span class="s1">s=n?.get(),o=t[t.length-</span><span class="s3">1</span><span class="s1">];</span><span class="s0">if</span><span class="s1">(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==s)t[</span><span class="s3">0</span><span class="s1">]=s;</span><span class="s0">else if</span><span class="s1">(i&amp;&amp;e){</span><span class="s0">const </span><span class="s1">n=i.readValue(e,o);</span><span class="s0">null</span><span class="s1">!=n&amp;&amp;(t[</span><span class="s3">0</span><span class="s1">]=n)}</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===t[</span><span class="s3">0</span><span class="s1">]&amp;&amp;(t[</span><span class="s3">0</span><span class="s1">]=o),n&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===s&amp;&amp;n.set(t[</span><span class="s3">0</span><span class="s1">])}!</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">1</span><span class="s1">;e&lt;t.length;e++)t[e]??(t[e]=t[e-</span><span class="s3">1</span><span class="s1">])}(t)}setFinalKeyframe(){}measureInitialState(){}renderEndStyles(){}measureEndState(){}complete(t=!</span><span class="s3">1</span><span class="s1">){</span><span class="s0">this</span><span class="s1">.state=</span><span class="s2">&quot;complete&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.onComplete(</span><span class="s0">this</span><span class="s1">.unresolvedKeyframes,</span><span class="s0">this</span><span class="s1">.finalKeyframe,t),hi.delete(</span><span class="s0">this</span><span class="s1">)}cancel(){</span><span class="s2">&quot;scheduled&quot;</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.state&amp;&amp;(hi.delete(</span><span class="s0">this</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.state=</span><span class="s2">&quot;pending&quot;</span><span class="s1">)}resume(){</span><span class="s2">&quot;pending&quot;</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.state&amp;&amp;</span><span class="s0">this</span><span class="s1">.scheduleResolve()}}</span><span class="s0">const </span><span class="s1">yi=Z(()=&gt;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==window.ScrollTimeline),gi={};</span><span class="s0">function </span><span class="s1">vi(t,e){</span><span class="s0">const </span><span class="s1">i=Z(t);</span><span class="s0">return</span><span class="s1">()=&gt;gi[e]??i()}</span><span class="s0">const </span><span class="s1">xi=vi(()=&gt;{</span><span class="s0">try</span><span class="s1">{document.createElement(</span><span class="s2">&quot;div&quot;</span><span class="s1">).animate({opacity:</span><span class="s3">0</span><span class="s1">},{easing:</span><span class="s2">&quot;linear(0, 1)&quot;</span><span class="s1">})}</span><span class="s0">catch</span><span class="s1">(t){</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">}</span><span class="s0">return</span><span class="s1">!</span><span class="s3">0</span><span class="s1">},</span><span class="s2">&quot;linearEasing&quot;</span><span class="s1">),Ti=([t,e,i,n])=&gt;</span><span class="s2">`cubic-bezier(</span><span class="s1">${t}</span><span class="s2">, </span><span class="s1">${e}</span><span class="s2">, </span><span class="s1">${i}</span><span class="s2">, </span><span class="s1">${n}</span><span class="s2">)`</span><span class="s1">,Pi={linear:</span><span class="s2">&quot;linear&quot;</span><span class="s1">,ease:</span><span class="s2">&quot;ease&quot;</span><span class="s1">,easeIn:</span><span class="s2">&quot;ease-in&quot;</span><span class="s1">,easeOut:</span><span class="s2">&quot;ease-out&quot;</span><span class="s1">,easeInOut:</span><span class="s2">&quot;ease-in-out&quot;</span><span class="s1">,circIn:Ti([</span><span class="s3">0</span><span class="s1">,</span><span class="s3">.65</span><span class="s1">,</span><span class="s3">.55</span><span class="s1">,</span><span class="s3">1</span><span class="s1">]),circOut:Ti([</span><span class="s3">.55</span><span class="s1">,</span><span class="s3">0</span><span class="s1">,</span><span class="s3">1</span><span class="s1">,</span><span class="s3">.45</span><span class="s1">]),backIn:Ti([</span><span class="s3">.31</span><span class="s1">,</span><span class="s3">.01</span><span class="s1">,</span><span class="s3">.66</span><span class="s1">,-</span><span class="s3">.59</span><span class="s1">]),backOut:Ti([</span><span class="s3">.33</span><span class="s1">,</span><span class="s3">1.53</span><span class="s1">,</span><span class="s3">.69</span><span class="s1">,</span><span class="s3">.99</span><span class="s1">])};</span><span class="s0">function </span><span class="s1">wi(t,e){</span><span class="s0">return </span><span class="s1">t?</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t?xi()?pe(t,e):</span><span class="s2">&quot;ease-out&quot;</span><span class="s1">:Tt(t)?Ti(t):Array.isArray(t)?t.map(t=&gt;wi(t,e)||Pi.easeOut):Pi[t]:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}</span><span class="s0">function </span><span class="s1">Si(t,e,i,{delay:n=</span><span class="s3">0</span><span class="s1">,duration:s=</span><span class="s3">300</span><span class="s1">,repeat:o=</span><span class="s3">0</span><span class="s1">,repeatType:r=</span><span class="s2">&quot;loop&quot;</span><span class="s1">,ease:a=</span><span class="s2">&quot;easeOut&quot;</span><span class="s1">,times:l}={},h=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">){</span><span class="s0">const </span><span class="s1">u={[e]:i};l&amp;&amp;(u.offset=l);</span><span class="s0">const </span><span class="s1">c=wi(a,s);Array.isArray(c)&amp;&amp;(u.easing=c);</span><span class="s0">const </span><span class="s1">d={delay:n,duration:s,easing:Array.isArray(c)?</span><span class="s2">&quot;linear&quot;</span><span class="s1">:c,fill:</span><span class="s2">&quot;both&quot;</span><span class="s1">,iterations:o+</span><span class="s3">1</span><span class="s1">,direction:</span><span class="s2">&quot;reverse&quot;</span><span class="s1">===r?</span><span class="s2">&quot;alternate&quot;</span><span class="s1">:</span><span class="s2">&quot;normal&quot;</span><span class="s1">};h&amp;&amp;(d.pseudoElement=h);</span><span class="s0">return </span><span class="s1">t.animate(u,d)}</span><span class="s0">function </span><span class="s1">Ai(t){</span><span class="s0">return</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t&amp;&amp;</span><span class="s2">&quot;applyToOptions&quot;</span><span class="s0">in </span><span class="s1">t}</span><span class="s0">class </span><span class="s1">bi </span><span class="s0">extends </span><span class="s1">Xe{constructor(t){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">super</span><span class="s1">(),</span><span class="s0">this</span><span class="s1">.finishedTime=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isStopped=!</span><span class="s3">1</span><span class="s1">,!t)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{element:e,name:i,keyframes:n,pseudoElement:s,allowFlatten:o=!</span><span class="s3">1</span><span class="s1">,finalKeyframe:r,onComplete:a}=t;</span><span class="s0">this</span><span class="s1">.isPseudoElement=Boolean(s),</span><span class="s0">this</span><span class="s1">.allowFlatten=o,</span><span class="s0">this</span><span class="s1">.options=t,t.type;</span><span class="s0">const </span><span class="s1">l=</span><span class="s0">function</span><span class="s1">({type:t,...e}){</span><span class="s0">return </span><span class="s1">Ai(t)&amp;&amp;xi()?t.applyToOptions(e):(e.duration??(e.duration=</span><span class="s3">300</span><span class="s1">),e.ease??(e.ease=</span><span class="s2">&quot;easeOut&quot;</span><span class="s1">),e)}(t);</span><span class="s0">this</span><span class="s1">.animation=Si(e,i,n,l,s),!</span><span class="s3">1</span><span class="s1">===l.autoplay&amp;&amp;</span><span class="s0">this</span><span class="s1">.animation.pause(),</span><span class="s0">this</span><span class="s1">.animation.onfinish=()=&gt;{</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.finishedTime=</span><span class="s0">this</span><span class="s1">.time,!s){</span><span class="s0">const </span><span class="s1">t=$e(n,</span><span class="s0">this</span><span class="s1">.options,r,</span><span class="s0">this</span><span class="s1">.speed);</span><span class="s0">this</span><span class="s1">.updateMotionValue?</span><span class="s0">this</span><span class="s1">.updateMotionValue(t):</span><span class="s0">function</span><span class="s1">(t,e,i){(t=&gt;t.startsWith(</span><span class="s2">&quot;--&quot;</span><span class="s1">))(e)?t.style.setProperty(e,i):t.style[e]=i}(e,i,t),</span><span class="s0">this</span><span class="s1">.animation.cancel()}a?.(),</span><span class="s0">this</span><span class="s1">.notifyFinished()}}play(){</span><span class="s0">this</span><span class="s1">.isStopped||(</span><span class="s0">this</span><span class="s1">.animation.play(),</span><span class="s2">&quot;finished&quot;</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.state&amp;&amp;</span><span class="s0">this</span><span class="s1">.updateFinished())}pause(){</span><span class="s0">this</span><span class="s1">.animation.pause()}complete(){</span><span class="s0">this</span><span class="s1">.animation.finish?.()}cancel(){</span><span class="s0">try</span><span class="s1">{</span><span class="s0">this</span><span class="s1">.animation.cancel()}</span><span class="s0">catch</span><span class="s1">(t){}}stop(){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isStopped)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">this</span><span class="s1">.isStopped=!</span><span class="s3">0</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{state:t}=</span><span class="s0">this</span><span class="s1">;</span><span class="s2">&quot;idle&quot;</span><span class="s1">!==t&amp;&amp;</span><span class="s2">&quot;finished&quot;</span><span class="s1">!==t&amp;&amp;(</span><span class="s0">this</span><span class="s1">.updateMotionValue?</span><span class="s0">this</span><span class="s1">.updateMotionValue():</span><span class="s0">this</span><span class="s1">.commitStyles(),</span><span class="s0">this</span><span class="s1">.isPseudoElement||</span><span class="s0">this</span><span class="s1">.cancel())}commitStyles(){</span><span class="s0">this</span><span class="s1">.isPseudoElement||</span><span class="s0">this</span><span class="s1">.animation.commitStyles?.()}get duration(){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.animation.effect?.getComputedTiming?.().duration||</span><span class="s3">0</span><span class="s1">;</span><span class="s0">return </span><span class="s1">st(Number(t))}get iterationDuration(){</span><span class="s0">const</span><span class="s1">{delay:t=</span><span class="s3">0</span><span class="s1">}=</span><span class="s0">this</span><span class="s1">.options||{};</span><span class="s0">return this</span><span class="s1">.duration+st(t)}get time(){</span><span class="s0">return </span><span class="s1">st(Number(</span><span class="s0">this</span><span class="s1">.animation.currentTime)||</span><span class="s3">0</span><span class="s1">)}set time(t){</span><span class="s0">this</span><span class="s1">.finishedTime=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.animation.currentTime=nt(t)}get speed(){</span><span class="s0">return this</span><span class="s1">.animation.playbackRate}set speed(t){t&lt;</span><span class="s3">0</span><span class="s1">&amp;&amp;(</span><span class="s0">this</span><span class="s1">.finishedTime=</span><span class="s0">null</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.animation.playbackRate=t}get state(){</span><span class="s0">return null</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.finishedTime?</span><span class="s2">&quot;finished&quot;</span><span class="s1">:</span><span class="s0">this</span><span class="s1">.animation.playState}get startTime(){</span><span class="s0">return </span><span class="s1">Number(</span><span class="s0">this</span><span class="s1">.animation.startTime)}set startTime(t){</span><span class="s0">this</span><span class="s1">.animation.startTime=t}attachTimeline({timeline:t,observe:e}){</span><span class="s0">return this</span><span class="s1">.allowFlatten&amp;&amp;</span><span class="s0">this</span><span class="s1">.animation.effect?.updateTiming({easing:</span><span class="s2">&quot;linear&quot;</span><span class="s1">}),</span><span class="s0">this</span><span class="s1">.animation.onfinish=</span><span class="s0">null</span><span class="s1">,t&amp;&amp;yi()?(</span><span class="s0">this</span><span class="s1">.animation.timeline=t,J):e(</span><span class="s0">this</span><span class="s1">)}}</span><span class="s0">const </span><span class="s1">Ei={anticipate:pt,backInOut:dt,circInOut:yt};</span><span class="s0">function </span><span class="s1">Vi(t){</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t.ease&amp;&amp;t.ease </span><span class="s0">in </span><span class="s1">Ei&amp;&amp;(t.ease=Ei[t.ease])}</span><span class="s0">class </span><span class="s1">Mi </span><span class="s0">extends </span><span class="s1">bi{constructor(t){Vi(t),Ye(t),</span><span class="s0">super</span><span class="s1">(t),t.startTime&amp;&amp;(</span><span class="s0">this</span><span class="s1">.startTime=t.startTime),</span><span class="s0">this</span><span class="s1">.options=t}updateMotionValue(t){</span><span class="s0">const</span><span class="s1">{motionValue:e,onUpdate:i,onComplete:n,element:s,...o}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">if</span><span class="s1">(!e)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==t)</span><span class="s0">return void </span><span class="s1">e.set(t);</span><span class="s0">const </span><span class="s1">r=</span><span class="s0">new </span><span class="s1">Ge({...o,autoplay:!</span><span class="s3">1</span><span class="s1">}),a=nt(</span><span class="s0">this</span><span class="s1">.finishedTime??</span><span class="s0">this</span><span class="s1">.time);e.setWithVelocity(r.sample(a-</span><span class="s3">10</span><span class="s1">).value,r.sample(a).value,</span><span class="s3">10</span><span class="s1">),r.stop()}}</span><span class="s0">const </span><span class="s1">Di=(t,e)=&gt;</span><span class="s2">&quot;zIndex&quot;</span><span class="s1">!==e&amp;&amp;(!(</span><span class="s2">&quot;number&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">t&amp;&amp;!Array.isArray(t))||!(</span><span class="s2">&quot;string&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">t||!Zt.test(t)&amp;&amp;</span><span class="s2">&quot;0&quot;</span><span class="s1">!==t||t.startsWith(</span><span class="s2">&quot;url(&quot;</span><span class="s1">)));</span><span class="s0">function </span><span class="s1">Ci(t){t.duration=</span><span class="s3">0</span><span class="s1">,t.type=</span><span class="s2">&quot;keyframes&quot;</span><span class="s1">}</span><span class="s0">const </span><span class="s1">ki=</span><span class="s0">new </span><span class="s1">Set([</span><span class="s2">&quot;opacity&quot;</span><span class="s1">,</span><span class="s2">&quot;clipPath&quot;</span><span class="s1">,</span><span class="s2">&quot;filter&quot;</span><span class="s1">,</span><span class="s2">&quot;transform&quot;</span><span class="s1">]),Ri=Z(()=&gt;Object.hasOwnProperty.call(Element.prototype,</span><span class="s2">&quot;animate&quot;</span><span class="s1">));</span><span class="s0">class </span><span class="s1">Li </span><span class="s0">extends </span><span class="s1">Xe{constructor({autoplay:t=!</span><span class="s3">0</span><span class="s1">,delay:e=</span><span class="s3">0</span><span class="s1">,type:i=</span><span class="s2">&quot;keyframes&quot;</span><span class="s1">,repeat:n=</span><span class="s3">0</span><span class="s1">,repeatDelay:s=</span><span class="s3">0</span><span class="s1">,repeatType:o=</span><span class="s2">&quot;loop&quot;</span><span class="s1">,keyframes:r,name:a,motionValue:l,element:h,...u}){</span><span class="s0">super</span><span class="s1">(),</span><span class="s0">this</span><span class="s1">.stop=()=&gt;{</span><span class="s0">this</span><span class="s1">._animation&amp;&amp;(</span><span class="s0">this</span><span class="s1">._animation.stop(),</span><span class="s0">this</span><span class="s1">.stopTimeline?.()),</span><span class="s0">this</span><span class="s1">.keyframeResolver?.cancel()},</span><span class="s0">this</span><span class="s1">.createdAt=Rt.now();</span><span class="s0">const </span><span class="s1">c={autoplay:t,delay:e,type:i,repeat:n,repeatDelay:s,repeatType:o,name:a,motionValue:l,element:h,...u},d=h?.KeyframeResolver||fi;</span><span class="s0">this</span><span class="s1">.keyframeResolver=</span><span class="s0">new </span><span class="s1">d(r,(t,e,i)=&gt;</span><span class="s0">this</span><span class="s1">.onKeyframesResolved(t,e,c,!i),a,l,h),</span><span class="s0">this</span><span class="s1">.keyframeResolver?.scheduleResolve()}onKeyframesResolved(t,e,i,n){</span><span class="s0">this</span><span class="s1">.keyframeResolver=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{name:s,type:o,velocity:r,delay:a,isHandoff:l,onUpdate:h}=i;</span><span class="s0">this</span><span class="s1">.resolvedAt=Rt.now(),</span><span class="s0">function</span><span class="s1">(t,e,i,n){</span><span class="s0">const </span><span class="s1">s=t[</span><span class="s3">0</span><span class="s1">];</span><span class="s0">if</span><span class="s1">(</span><span class="s0">null</span><span class="s1">===s)</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;display&quot;</span><span class="s1">===e||</span><span class="s2">&quot;visibility&quot;</span><span class="s1">===e)</span><span class="s0">return</span><span class="s1">!</span><span class="s3">0</span><span class="s1">;</span><span class="s0">const </span><span class="s1">o=t[t.length-</span><span class="s3">1</span><span class="s1">],r=Di(s,e),a=Di(o,e);</span><span class="s0">return</span><span class="s1">!(!r||!a)&amp;&amp;(</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">const </span><span class="s1">e=t[</span><span class="s3">0</span><span class="s1">];</span><span class="s0">if</span><span class="s1">(</span><span class="s3">1</span><span class="s1">===t.length)</span><span class="s0">return</span><span class="s1">!</span><span class="s3">0</span><span class="s1">;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">i=</span><span class="s3">0</span><span class="s1">;i&lt;t.length;i++)</span><span class="s0">if</span><span class="s1">(t[i]!==e)</span><span class="s0">return</span><span class="s1">!</span><span class="s3">0</span><span class="s1">}(t)||(</span><span class="s2">&quot;spring&quot;</span><span class="s1">===i||Ai(i))&amp;&amp;n)}(t,s,o,r)||(!H.instantAnimations&amp;&amp;a||h?.($e(t,i,e)),t[</span><span class="s3">0</span><span class="s1">]=t[t.length-</span><span class="s3">1</span><span class="s1">],Ci(i),i.repeat=</span><span class="s3">0</span><span class="s1">);</span><span class="s0">const </span><span class="s1">u={startTime:n?</span><span class="s0">this</span><span class="s1">.resolvedAt&amp;&amp;</span><span class="s0">this</span><span class="s1">.resolvedAt-</span><span class="s0">this</span><span class="s1">.createdAt&gt;</span><span class="s3">40</span><span class="s1">?</span><span class="s0">this</span><span class="s1">.resolvedAt:</span><span class="s0">this</span><span class="s1">.createdAt:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,finalKeyframe:e,...i,keyframes:t},c=!l&amp;&amp;</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">const</span><span class="s1">{motionValue:e,name:i,repeatDelay:n,repeatType:s,damping:o,type:r}=t,a=e?.owner?.current;</span><span class="s0">if</span><span class="s1">(!(a </span><span class="s0">instanceof </span><span class="s1">HTMLElement))</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{onUpdate:l,transformTemplate:h}=e.owner.getProps();</span><span class="s0">return </span><span class="s1">Ri()&amp;&amp;i&amp;&amp;ki.has(i)&amp;&amp;(</span><span class="s2">&quot;transform&quot;</span><span class="s1">!==i||!h)&amp;&amp;!l&amp;&amp;!n&amp;&amp;</span><span class="s2">&quot;mirror&quot;</span><span class="s1">!==s&amp;&amp;</span><span class="s3">0</span><span class="s1">!==o&amp;&amp;</span><span class="s2">&quot;inertia&quot;</span><span class="s1">!==r}(u)?</span><span class="s0">new </span><span class="s1">Mi({...u,element:u.motionValue.owner.current}):</span><span class="s0">new </span><span class="s1">Ge(u);c.finished.then(()=&gt;</span><span class="s0">this</span><span class="s1">.notifyFinished()).catch(J),</span><span class="s0">this</span><span class="s1">.pendingTimeline&amp;&amp;(</span><span class="s0">this</span><span class="s1">.stopTimeline=c.attachTimeline(</span><span class="s0">this</span><span class="s1">.pendingTimeline),</span><span class="s0">this</span><span class="s1">.pendingTimeline=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">),</span><span class="s0">this</span><span class="s1">._animation=c}get finished(){</span><span class="s0">return this</span><span class="s1">._animation?</span><span class="s0">this</span><span class="s1">.animation.finished:</span><span class="s0">this</span><span class="s1">._finished}then(t,e){</span><span class="s0">return this</span><span class="s1">.finished.finally(t).then(()=&gt;{})}get animation(){</span><span class="s0">return this</span><span class="s1">._animation||(</span><span class="s0">this</span><span class="s1">.keyframeResolver?.resume(),di=!</span><span class="s3">0</span><span class="s1">,mi(),pi(),di=!</span><span class="s3">1</span><span class="s1">),</span><span class="s0">this</span><span class="s1">._animation}get duration(){</span><span class="s0">return this</span><span class="s1">.animation.duration}get iterationDuration(){</span><span class="s0">return this</span><span class="s1">.animation.iterationDuration}get time(){</span><span class="s0">return this</span><span class="s1">.animation.time}set time(t){</span><span class="s0">this</span><span class="s1">.animation.time=t}get speed(){</span><span class="s0">return this</span><span class="s1">.animation.speed}get state(){</span><span class="s0">return this</span><span class="s1">.animation.state}set speed(t){</span><span class="s0">this</span><span class="s1">.animation.speed=t}get startTime(){</span><span class="s0">return this</span><span class="s1">.animation.startTime}attachTimeline(t){</span><span class="s0">return this</span><span class="s1">._animation?</span><span class="s0">this</span><span class="s1">.stopTimeline=</span><span class="s0">this</span><span class="s1">.animation.attachTimeline(t):</span><span class="s0">this</span><span class="s1">.pendingTimeline=t,()=&gt;</span><span class="s0">this</span><span class="s1">.stop()}play(){</span><span class="s0">this</span><span class="s1">.animation.play()}pause(){</span><span class="s0">this</span><span class="s1">.animation.pause()}complete(){</span><span class="s0">this</span><span class="s1">.animation.complete()}cancel(){</span><span class="s0">this</span><span class="s1">._animation&amp;&amp;</span><span class="s0">this</span><span class="s1">.animation.cancel(),</span><span class="s0">this</span><span class="s1">.keyframeResolver?.cancel()}}</span><span class="s0">const </span><span class="s1">ji=</span><span class="s4">/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u</span><span class="s1">;</span><span class="s0">function </span><span class="s1">Bi(t,e,i=</span><span class="s3">1</span><span class="s1">){</span><span class="s0">const</span><span class="s1">[n,o]=</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">const </span><span class="s1">e=ji.exec(t);</span><span class="s0">if</span><span class="s1">(!e)</span><span class="s0">return</span><span class="s1">[,];</span><span class="s0">const</span><span class="s1">[,i,n,s]=e;</span><span class="s0">return</span><span class="s1">[</span><span class="s2">`--</span><span class="s1">${i??n}</span><span class="s2">`</span><span class="s1">,s]}(t);</span><span class="s0">if</span><span class="s1">(!n)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">r=window.getComputedStyle(e).getPropertyValue(n);</span><span class="s0">if</span><span class="s1">(r){</span><span class="s0">const </span><span class="s1">t=r.trim();</span><span class="s0">return </span><span class="s1">G(t)?parseFloat(t):t}</span><span class="s0">return </span><span class="s1">s(o)?Bi(o,e,i+</span><span class="s3">1</span><span class="s1">):o}</span><span class="s0">function </span><span class="s1">Fi(t,e){</span><span class="s0">return </span><span class="s1">t?.[e]??t?.default??t}</span><span class="s0">const </span><span class="s1">Ii=</span><span class="s0">new </span><span class="s1">Set([</span><span class="s2">&quot;width&quot;</span><span class="s1">,</span><span class="s2">&quot;height&quot;</span><span class="s1">,</span><span class="s2">&quot;top&quot;</span><span class="s1">,</span><span class="s2">&quot;left&quot;</span><span class="s1">,</span><span class="s2">&quot;right&quot;</span><span class="s1">,</span><span class="s2">&quot;bottom&quot;</span><span class="s1">,...r]),Oi=t=&gt;e=&gt;e.test(t),Ui=[t,o,n,a,l,h,{test:t=&gt;</span><span class="s2">&quot;auto&quot;</span><span class="s1">===t,parse:t=&gt;t}],Ni=t=&gt;Ui.find(Oi(t));</span><span class="s0">function </span><span class="s1">Ki(t){</span><span class="s0">return</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t?</span><span class="s3">0</span><span class="s1">===t:</span><span class="s0">null</span><span class="s1">===t||(</span><span class="s2">&quot;none&quot;</span><span class="s1">===t||</span><span class="s2">&quot;0&quot;</span><span class="s1">===t||_(t))}</span><span class="s0">const </span><span class="s1">Wi=</span><span class="s0">new </span><span class="s1">Set([</span><span class="s2">&quot;brightness&quot;</span><span class="s1">,</span><span class="s2">&quot;contrast&quot;</span><span class="s1">,</span><span class="s2">&quot;saturate&quot;</span><span class="s1">,</span><span class="s2">&quot;opacity&quot;</span><span class="s1">]);</span><span class="s0">function </span><span class="s1">$i(t){</span><span class="s0">const</span><span class="s1">[e,i]=t.slice(</span><span class="s3">0</span><span class="s1">,-</span><span class="s3">1</span><span class="s1">).split(</span><span class="s2">&quot;(&quot;</span><span class="s1">);</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;drop-shadow&quot;</span><span class="s1">===e)</span><span class="s0">return </span><span class="s1">t;</span><span class="s0">const</span><span class="s1">[n]=i.match(jt)||[];</span><span class="s0">if</span><span class="s1">(!n)</span><span class="s0">return </span><span class="s1">t;</span><span class="s0">const </span><span class="s1">s=i.replace(n,</span><span class="s2">&quot;&quot;</span><span class="s1">);</span><span class="s0">let </span><span class="s1">o=Wi.has(e)?</span><span class="s3">1</span><span class="s1">:</span><span class="s3">0</span><span class="s1">;</span><span class="s0">return </span><span class="s1">n!==i&amp;&amp;(o*=</span><span class="s3">100</span><span class="s1">),e+</span><span class="s2">&quot;(&quot;</span><span class="s1">+o+s+</span><span class="s2">&quot;)&quot;</span><span class="s1">}</span><span class="s0">const </span><span class="s1">zi=</span><span class="s4">/\b([a-z-]*)\(.*?\)/gu</span><span class="s1">,Yi={...Zt,getAnimatableNone:t=&gt;{</span><span class="s0">const </span><span class="s1">e=t.match(zi);</span><span class="s0">return </span><span class="s1">e?e.map($i).join(</span><span class="s2">&quot; &quot;</span><span class="s1">):t}},Xi={...u,color:Wt,backgroundColor:Wt,outlineColor:Wt,fill:Wt,stroke:Wt,borderColor:Wt,borderTopColor:Wt,borderRightColor:Wt,borderBottomColor:Wt,borderLeftColor:Wt,filter:Yi,WebkitFilter:Yi},Hi=t=&gt;Xi[t];</span><span class="s0">function </span><span class="s1">Gi(t,e){</span><span class="s0">let </span><span class="s1">i=Hi(t);</span><span class="s0">return </span><span class="s1">i!==Yi&amp;&amp;(i=Zt),i.getAnimatableNone?i.getAnimatableNone(e):</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}</span><span class="s0">const </span><span class="s1">qi=</span><span class="s0">new </span><span class="s1">Set([</span><span class="s2">&quot;auto&quot;</span><span class="s1">,</span><span class="s2">&quot;none&quot;</span><span class="s1">,</span><span class="s2">&quot;0&quot;</span><span class="s1">]);</span><span class="s0">class </span><span class="s1">_i </span><span class="s0">extends </span><span class="s1">fi{constructor(t,e,i,n,s){</span><span class="s0">super</span><span class="s1">(t,e,i,n,s,!</span><span class="s3">0</span><span class="s1">)}readKeyframes(){</span><span class="s0">const</span><span class="s1">{unresolvedKeyframes:t,element:e,name:i}=</span><span class="s0">this</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(!e||!e.current)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">super</span><span class="s1">.readKeyframes();</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">i=</span><span class="s3">0</span><span class="s1">;i&lt;t.length;i++){</span><span class="s0">let </span><span class="s1">n=t[i];</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">n&amp;&amp;(n=n.trim(),s(n))){</span><span class="s0">const </span><span class="s1">s=Bi(n,e.current);</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==s&amp;&amp;(t[i]=s),i===t.length-</span><span class="s3">1</span><span class="s1">&amp;&amp;(</span><span class="s0">this</span><span class="s1">.finalKeyframe=n)}}</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.resolveNoneKeyframes(),!Ii.has(i)||</span><span class="s3">2</span><span class="s1">!==t.length)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">[n,o]=t,r=Ni(n),a=Ni(o);</span><span class="s0">if</span><span class="s1">(r!==a)</span><span class="s0">if</span><span class="s1">(oi(r)&amp;&amp;oi(a))</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">0</span><span class="s1">;e&lt;t.length;e++){</span><span class="s0">const </span><span class="s1">i=t[e];</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">i&amp;&amp;(t[e]=parseFloat(i))}</span><span class="s0">else </span><span class="s1">li[i]&amp;&amp;(</span><span class="s0">this</span><span class="s1">.needsMeasurement=!</span><span class="s3">0</span><span class="s1">)}resolveNoneKeyframes(){</span><span class="s0">const</span><span class="s1">{unresolvedKeyframes:t,name:e}=</span><span class="s0">this</span><span class="s1">,i=[];</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">0</span><span class="s1">;e&lt;t.length;e++)(</span><span class="s0">null</span><span class="s1">===t[e]||Ki(t[e]))&amp;&amp;i.push(e);i.length&amp;&amp;</span><span class="s0">function</span><span class="s1">(t,e,i){</span><span class="s0">let </span><span class="s1">n,s=</span><span class="s3">0</span><span class="s1">;</span><span class="s0">for</span><span class="s1">(;s&lt;t.length&amp;&amp;!n;){</span><span class="s0">const </span><span class="s1">e=t[s];</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e&amp;&amp;!qi.has(e)&amp;&amp;Ht(e).values.length&amp;&amp;(n=t[s]),s++}</span><span class="s0">if</span><span class="s1">(n&amp;&amp;i)</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">s of e)t[s]=Gi(i,n)}(t,i,e)}measureInitialState(){</span><span class="s0">const</span><span class="s1">{element:t,unresolvedKeyframes:e,name:i}=</span><span class="s0">this</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(!t||!t.current)</span><span class="s0">return</span><span class="s1">;</span><span class="s2">&quot;height&quot;</span><span class="s1">===i&amp;&amp;(</span><span class="s0">this</span><span class="s1">.suspendedScrollY=window.pageYOffset),</span><span class="s0">this</span><span class="s1">.measuredOrigin=li[i](t.measureViewportBox(),window.getComputedStyle(t.current)),e[</span><span class="s3">0</span><span class="s1">]=</span><span class="s0">this</span><span class="s1">.measuredOrigin;</span><span class="s0">const </span><span class="s1">n=e[e.length-</span><span class="s3">1</span><span class="s1">];</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==n&amp;&amp;t.getValue(i,n).jump(n,!</span><span class="s3">1</span><span class="s1">)}measureEndState(){</span><span class="s0">const</span><span class="s1">{element:t,name:e,unresolvedKeyframes:i}=</span><span class="s0">this</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(!t||!t.current)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">n=t.getValue(e);n&amp;&amp;n.jump(</span><span class="s0">this</span><span class="s1">.measuredOrigin,!</span><span class="s3">1</span><span class="s1">);</span><span class="s0">const </span><span class="s1">s=i.length-</span><span class="s3">1</span><span class="s1">,o=i[s];i[s]=li[e](t.measureViewportBox(),window.getComputedStyle(t.current)),</span><span class="s0">null</span><span class="s1">!==o&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.finalKeyframe&amp;&amp;(</span><span class="s0">this</span><span class="s1">.finalKeyframe=o),</span><span class="s0">this</span><span class="s1">.removedTransforms?.length&amp;&amp;</span><span class="s0">this</span><span class="s1">.removedTransforms.forEach(([e,i])=&gt;{t.getValue(e).set(i)}),</span><span class="s0">this</span><span class="s1">.resolveNoneKeyframes()}}</span><span class="s0">class </span><span class="s1">Zi{constructor(t,e={}){</span><span class="s0">this</span><span class="s1">.canTrackVelocity=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.events={},</span><span class="s0">this</span><span class="s1">.updateAndNotify=t=&gt;{</span><span class="s0">const </span><span class="s1">e=Rt.now();</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.updatedAt!==e&amp;&amp;</span><span class="s0">this</span><span class="s1">.setPrevFrameValue(),</span><span class="s0">this</span><span class="s1">.prev=</span><span class="s0">this</span><span class="s1">.current,</span><span class="s0">this</span><span class="s1">.setCurrent(t),</span><span class="s0">this</span><span class="s1">.current!==</span><span class="s0">this</span><span class="s1">.prev&amp;&amp;(</span><span class="s0">this</span><span class="s1">.events.change?.notify(</span><span class="s0">this</span><span class="s1">.current),</span><span class="s0">this</span><span class="s1">.dependents))</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">t of </span><span class="s0">this</span><span class="s1">.dependents)t.dirty()},</span><span class="s0">this</span><span class="s1">.hasAnimated=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.setCurrent(t),</span><span class="s0">this</span><span class="s1">.owner=e.owner}setCurrent(t){</span><span class="s0">var </span><span class="s1">e;</span><span class="s0">this</span><span class="s1">.current=t,</span><span class="s0">this</span><span class="s1">.updatedAt=Rt.now(),</span><span class="s0">null</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.canTrackVelocity&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==t&amp;&amp;(</span><span class="s0">this</span><span class="s1">.canTrackVelocity=(e=</span><span class="s0">this</span><span class="s1">.current,!isNaN(parseFloat(e))))}setPrevFrameValue(t=</span><span class="s0">this</span><span class="s1">.current){</span><span class="s0">this</span><span class="s1">.prevFrameValue=t,</span><span class="s0">this</span><span class="s1">.prevUpdatedAt=</span><span class="s0">this</span><span class="s1">.updatedAt}onChange(t){</span><span class="s0">return this</span><span class="s1">.on(</span><span class="s2">&quot;change&quot;</span><span class="s1">,t)}on(t,e){</span><span class="s0">this</span><span class="s1">.events[t]||(</span><span class="s0">this</span><span class="s1">.events[t]=</span><span class="s0">new </span><span class="s1">it);</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">.events[t].add(e);</span><span class="s0">return</span><span class="s2">&quot;change&quot;</span><span class="s1">===t?()=&gt;{i(),Et.read(()=&gt;{</span><span class="s0">this</span><span class="s1">.events.change.getSize()||</span><span class="s0">this</span><span class="s1">.stop()})}:i}clearListeners(){</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">t </span><span class="s0">in this</span><span class="s1">.events)</span><span class="s0">this</span><span class="s1">.events[t].clear()}attach(t,e){</span><span class="s0">this</span><span class="s1">.passiveEffect=t,</span><span class="s0">this</span><span class="s1">.stopPassiveEffect=e}set(t){</span><span class="s0">this</span><span class="s1">.passiveEffect?</span><span class="s0">this</span><span class="s1">.passiveEffect(t,</span><span class="s0">this</span><span class="s1">.updateAndNotify):</span><span class="s0">this</span><span class="s1">.updateAndNotify(t)}setWithVelocity(t,e,i){</span><span class="s0">this</span><span class="s1">.set(e),</span><span class="s0">this</span><span class="s1">.prev=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.prevFrameValue=t,</span><span class="s0">this</span><span class="s1">.prevUpdatedAt=</span><span class="s0">this</span><span class="s1">.updatedAt-i}jump(t,e=!</span><span class="s3">0</span><span class="s1">){</span><span class="s0">this</span><span class="s1">.updateAndNotify(t),</span><span class="s0">this</span><span class="s1">.prev=t,</span><span class="s0">this</span><span class="s1">.prevUpdatedAt=</span><span class="s0">this</span><span class="s1">.prevFrameValue=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,e&amp;&amp;</span><span class="s0">this</span><span class="s1">.stop(),</span><span class="s0">this</span><span class="s1">.stopPassiveEffect&amp;&amp;</span><span class="s0">this</span><span class="s1">.stopPassiveEffect()}dirty(){</span><span class="s0">this</span><span class="s1">.events.change?.notify(</span><span class="s0">this</span><span class="s1">.current)}addDependent(t){</span><span class="s0">this</span><span class="s1">.dependents||(</span><span class="s0">this</span><span class="s1">.dependents=</span><span class="s0">new </span><span class="s1">Set),</span><span class="s0">this</span><span class="s1">.dependents.add(t)}removeDependent(t){</span><span class="s0">this</span><span class="s1">.dependents&amp;&amp;</span><span class="s0">this</span><span class="s1">.dependents.delete(t)}get(){</span><span class="s0">return this</span><span class="s1">.current}getPrevious(){</span><span class="s0">return this</span><span class="s1">.prev}getVelocity(){</span><span class="s0">const </span><span class="s1">t=Rt.now();</span><span class="s0">if</span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.canTrackVelocity||</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.prevFrameValue||t-</span><span class="s0">this</span><span class="s1">.updatedAt&gt;</span><span class="s3">30</span><span class="s1">)</span><span class="s0">return </span><span class="s3">0</span><span class="s1">;</span><span class="s0">const </span><span class="s1">e=Math.min(</span><span class="s0">this</span><span class="s1">.updatedAt-</span><span class="s0">this</span><span class="s1">.prevUpdatedAt,</span><span class="s3">30</span><span class="s1">);</span><span class="s0">return </span><span class="s1">ot(parseFloat(</span><span class="s0">this</span><span class="s1">.current)-parseFloat(</span><span class="s0">this</span><span class="s1">.prevFrameValue),e)}start(t){</span><span class="s0">return this</span><span class="s1">.stop(),</span><span class="s0">new </span><span class="s1">Promise(e=&gt;{</span><span class="s0">this</span><span class="s1">.hasAnimated=!</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.animation=t(e),</span><span class="s0">this</span><span class="s1">.events.animationStart&amp;&amp;</span><span class="s0">this</span><span class="s1">.events.animationStart.notify()}).then(()=&gt;{</span><span class="s0">this</span><span class="s1">.events.animationComplete&amp;&amp;</span><span class="s0">this</span><span class="s1">.events.animationComplete.notify(),</span><span class="s0">this</span><span class="s1">.clearAnimation()})}stop(){</span><span class="s0">this</span><span class="s1">.animation&amp;&amp;(</span><span class="s0">this</span><span class="s1">.animation.stop(),</span><span class="s0">this</span><span class="s1">.events.animationCancel&amp;&amp;</span><span class="s0">this</span><span class="s1">.events.animationCancel.notify()),</span><span class="s0">this</span><span class="s1">.clearAnimation()}isAnimating(){</span><span class="s0">return</span><span class="s1">!!</span><span class="s0">this</span><span class="s1">.animation}clearAnimation(){</span><span class="s0">delete this</span><span class="s1">.animation}destroy(){</span><span class="s0">this</span><span class="s1">.dependents?.clear(),</span><span class="s0">this</span><span class="s1">.events.destroy?.notify(),</span><span class="s0">this</span><span class="s1">.clearListeners(),</span><span class="s0">this</span><span class="s1">.stop(),</span><span class="s0">this</span><span class="s1">.stopPassiveEffect&amp;&amp;</span><span class="s0">this</span><span class="s1">.stopPassiveEffect()}}</span><span class="s0">function </span><span class="s1">Ji(t,e){</span><span class="s0">return new </span><span class="s1">Zi(t,e)}</span><span class="s0">const</span><span class="s1">{schedule:Qi,cancel:tn}=bt(queueMicrotask,!</span><span class="s3">1</span><span class="s1">),en={x:!</span><span class="s3">1</span><span class="s1">,y:!</span><span class="s3">1</span><span class="s1">};</span><span class="s0">function </span><span class="s1">nn(){</span><span class="s0">return </span><span class="s1">en.x||en.y}</span><span class="s0">function </span><span class="s1">sn(t,e){</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">if</span><span class="s1">(t </span><span class="s0">instanceof </span><span class="s1">EventTarget)</span><span class="s0">return</span><span class="s1">[t];</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t){</span><span class="s0">const </span><span class="s1">e=document.querySelectorAll(t);</span><span class="s0">return </span><span class="s1">e?Array.from(e):[]}</span><span class="s0">return </span><span class="s1">Array.from(t)}(t),n=</span><span class="s0">new </span><span class="s1">AbortController;</span><span class="s0">return</span><span class="s1">[i,{passive:!</span><span class="s3">0</span><span class="s1">,...e,signal:n.signal},()=&gt;n.abort()]}</span><span class="s0">function </span><span class="s1">on(t){</span><span class="s0">return</span><span class="s1">!(</span><span class="s2">&quot;touch&quot;</span><span class="s1">===t.pointerType||nn())}</span><span class="s0">const </span><span class="s1">rn=(t,e)=&gt;!!e&amp;&amp;(t===e||rn(t,e.parentElement)),an=t=&gt;</span><span class="s2">&quot;mouse&quot;</span><span class="s1">===t.pointerType?</span><span class="s2">&quot;number&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">t.button||t.button&lt;=</span><span class="s3">0</span><span class="s1">:!</span><span class="s3">1</span><span class="s1">!==t.isPrimary,ln=</span><span class="s0">new </span><span class="s1">Set([</span><span class="s2">&quot;BUTTON&quot;</span><span class="s1">,</span><span class="s2">&quot;INPUT&quot;</span><span class="s1">,</span><span class="s2">&quot;SELECT&quot;</span><span class="s1">,</span><span class="s2">&quot;TEXTAREA&quot;</span><span class="s1">,</span><span class="s2">&quot;A&quot;</span><span class="s1">]);</span><span class="s0">const </span><span class="s1">hn=</span><span class="s0">new </span><span class="s1">WeakSet;</span><span class="s0">function </span><span class="s1">un(t){</span><span class="s0">return </span><span class="s1">e=&gt;{</span><span class="s2">&quot;Enter&quot;</span><span class="s1">===e.key&amp;&amp;t(e)}}</span><span class="s0">function </span><span class="s1">cn(t,e){t.dispatchEvent(</span><span class="s0">new </span><span class="s1">PointerEvent(</span><span class="s2">&quot;pointer&quot;</span><span class="s1">+e,{isPrimary:!</span><span class="s3">0</span><span class="s1">,bubbles:!</span><span class="s3">0</span><span class="s1">}))}</span><span class="s0">function </span><span class="s1">dn(t){</span><span class="s0">return </span><span class="s1">an(t)&amp;&amp;!nn()}</span><span class="s0">function </span><span class="s1">pn(t,e,i={}){</span><span class="s0">const</span><span class="s1">[n,s,o]=sn(t,i),r=t=&gt;{</span><span class="s0">const </span><span class="s1">n=t.currentTarget;</span><span class="s0">if</span><span class="s1">(!dn(t))</span><span class="s0">return</span><span class="s1">;hn.add(n);</span><span class="s0">const </span><span class="s1">o=e(n,t),r=(t,e)=&gt;{window.removeEventListener(</span><span class="s2">&quot;pointerup&quot;</span><span class="s1">,a),window.removeEventListener(</span><span class="s2">&quot;pointercancel&quot;</span><span class="s1">,l),hn.has(n)&amp;&amp;hn.delete(n),dn(t)&amp;&amp;</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">o&amp;&amp;o(t,{success:e})},a=t=&gt;{r(t,n===window||n===document||i.useGlobalTarget||rn(n,t.target))},l=t=&gt;{r(t,!</span><span class="s3">1</span><span class="s1">)};window.addEventListener(</span><span class="s2">&quot;pointerup&quot;</span><span class="s1">,a,s),window.addEventListener(</span><span class="s2">&quot;pointercancel&quot;</span><span class="s1">,l,s)};</span><span class="s0">return </span><span class="s1">n.forEach(t=&gt;{</span><span class="s0">var </span><span class="s1">e;(i.useGlobalTarget?window:t).addEventListener(</span><span class="s2">&quot;pointerdown&quot;</span><span class="s1">,r,s),q(e=t)&amp;&amp;</span><span class="s2">&quot;offsetHeight&quot;</span><span class="s0">in </span><span class="s1">e&amp;&amp;(t.addEventListener(</span><span class="s2">&quot;focus&quot;</span><span class="s1">,t=&gt;((t,e)=&gt;{</span><span class="s0">const </span><span class="s1">i=t.currentTarget;</span><span class="s0">if</span><span class="s1">(!i)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">n=un(()=&gt;{</span><span class="s0">if</span><span class="s1">(hn.has(i))</span><span class="s0">return</span><span class="s1">;cn(i,</span><span class="s2">&quot;down&quot;</span><span class="s1">);</span><span class="s0">const </span><span class="s1">t=un(()=&gt;{cn(i,</span><span class="s2">&quot;up&quot;</span><span class="s1">)});i.addEventListener(</span><span class="s2">&quot;keyup&quot;</span><span class="s1">,t,e),i.addEventListener(</span><span class="s2">&quot;blur&quot;</span><span class="s1">,()=&gt;cn(i,</span><span class="s2">&quot;cancel&quot;</span><span class="s1">),e)});i.addEventListener(</span><span class="s2">&quot;keydown&quot;</span><span class="s1">,n,e),i.addEventListener(</span><span class="s2">&quot;blur&quot;</span><span class="s1">,()=&gt;i.removeEventListener(</span><span class="s2">&quot;keydown&quot;</span><span class="s1">,n),e)})(t,s)),</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">return </span><span class="s1">ln.has(t.tagName)||-</span><span class="s3">1</span><span class="s1">!==t.tabIndex}(t)||t.hasAttribute(</span><span class="s2">&quot;tabindex&quot;</span><span class="s1">)||(t.tabIndex=</span><span class="s3">0</span><span class="s1">))}),o}</span><span class="s0">function </span><span class="s1">mn(t){</span><span class="s0">return </span><span class="s1">q(t)&amp;&amp;</span><span class="s2">&quot;ownerSVGElement&quot;</span><span class="s0">in </span><span class="s1">t}</span><span class="s0">const </span><span class="s1">fn=[...Ui,Wt,Zt];</span><span class="s0">class </span><span class="s1">yn{constructor(t){</span><span class="s0">this</span><span class="s1">.isMounted=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.node=t}update(){}}</span><span class="s0">const </span><span class="s1">gn=t=&gt;</span><span class="s0">null</span><span class="s1">!==t;</span><span class="s0">const </span><span class="s1">vn={type:</span><span class="s2">&quot;spring&quot;</span><span class="s1">,stiffness:</span><span class="s3">500</span><span class="s1">,damping:</span><span class="s3">25</span><span class="s1">,restSpeed:</span><span class="s3">10</span><span class="s1">},xn={type:</span><span class="s2">&quot;keyframes&quot;</span><span class="s1">,duration:</span><span class="s3">.8</span><span class="s1">},Tn={type:</span><span class="s2">&quot;keyframes&quot;</span><span class="s1">,ease:[</span><span class="s3">.25</span><span class="s1">,</span><span class="s3">.1</span><span class="s1">,</span><span class="s3">.35</span><span class="s1">,</span><span class="s3">1</span><span class="s1">],duration:</span><span class="s3">.3</span><span class="s1">},Pn=(t,{keyframes:e})=&gt;e.length&gt;</span><span class="s3">2</span><span class="s1">?xn:c.has(t)?t.startsWith(</span><span class="s2">&quot;scale&quot;</span><span class="s1">)?{type:</span><span class="s2">&quot;spring&quot;</span><span class="s1">,stiffness:</span><span class="s3">550</span><span class="s1">,damping:</span><span class="s3">0</span><span class="s1">===e[</span><span class="s3">1</span><span class="s1">]?</span><span class="s3">2</span><span class="s1">*Math.sqrt(</span><span class="s3">550</span><span class="s1">):</span><span class="s3">30</span><span class="s1">,restSpeed:</span><span class="s3">10</span><span class="s1">}:vn:Tn;</span><span class="s0">const </span><span class="s1">wn=(t,e,i,n={},s,o)=&gt;r=&gt;{</span><span class="s0">const </span><span class="s1">a=Fi(n,t)||{},l=a.delay||n.delay||</span><span class="s3">0</span><span class="s1">;</span><span class="s0">let</span><span class="s1">{elapsed:h=</span><span class="s3">0</span><span class="s1">}=n;h-=nt(l);</span><span class="s0">const </span><span class="s1">u={keyframes:Array.isArray(i)?i:[</span><span class="s0">null</span><span class="s1">,i],ease:</span><span class="s2">&quot;easeOut&quot;</span><span class="s1">,velocity:e.getVelocity(),...a,delay:-h,onUpdate:t=&gt;{e.set(t),a.onUpdate&amp;&amp;a.onUpdate(t)},onComplete:()=&gt;{r(),a.onComplete&amp;&amp;a.onComplete()},name:t,motionValue:e,element:o?</span><span class="s0">void </span><span class="s3">0</span><span class="s1">:s};(</span><span class="s0">function</span><span class="s1">({when:t,delay:e,delayChildren:i,staggerChildren:n,staggerDirection:s,repeat:o,repeatType:r,repeatDelay:a,from:l,elapsed:h,...u}){</span><span class="s0">return</span><span class="s1">!!Object.keys(u).length})(a)||Object.assign(u,Pn(t,u)),u.duration&amp;&amp;(u.duration=nt(u.duration)),u.repeatDelay&amp;&amp;(u.repeatDelay=nt(u.repeatDelay)),</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==u.from&amp;&amp;(u.keyframes[</span><span class="s3">0</span><span class="s1">]=u.from);</span><span class="s0">let </span><span class="s1">c=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">if</span><span class="s1">((!</span><span class="s3">1</span><span class="s1">===u.type||</span><span class="s3">0</span><span class="s1">===u.duration&amp;&amp;!u.repeatDelay)&amp;&amp;(Ci(u),</span><span class="s3">0</span><span class="s1">===u.delay&amp;&amp;(c=!</span><span class="s3">0</span><span class="s1">)),(H.instantAnimations||H.skipAnimations)&amp;&amp;(c=!</span><span class="s3">0</span><span class="s1">,Ci(u),u.delay=</span><span class="s3">0</span><span class="s1">),u.allowFlatten=!a.type&amp;&amp;!a.ease,c&amp;&amp;!o&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==e.get()){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">function</span><span class="s1">(t,{repeat:e,repeatType:i=</span><span class="s2">&quot;loop&quot;</span><span class="s1">},n){</span><span class="s0">const </span><span class="s1">s=t.filter(gn),o=e&amp;&amp;</span><span class="s2">&quot;loop&quot;</span><span class="s1">!==i&amp;&amp;e%</span><span class="s3">2</span><span class="s1">==</span><span class="s3">1</span><span class="s1">?</span><span class="s3">0</span><span class="s1">:s.length-</span><span class="s3">1</span><span class="s1">;</span><span class="s0">return </span><span class="s1">o&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==n?n:s[o]}(u.keyframes,a);</span><span class="s0">if</span><span class="s1">(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==t)</span><span class="s0">return void </span><span class="s1">Et.update(()=&gt;{u.onUpdate(t),u.onComplete()})}</span><span class="s0">return </span><span class="s1">a.isSync?</span><span class="s0">new </span><span class="s1">Ge(u):</span><span class="s0">new </span><span class="s1">Li(u)};</span><span class="s0">function </span><span class="s1">Sn(t,e,i,n={passive:!</span><span class="s3">0</span><span class="s1">}){</span><span class="s0">return </span><span class="s1">t.addEventListener(e,i,n),()=&gt;t.removeEventListener(e,i)}</span><span class="s0">function </span><span class="s1">An(t){</span><span class="s0">return</span><span class="s1">{point:{x:t.pageX,y:t.pageY}}}</span><span class="s0">function </span><span class="s1">bn(t,e,i,n){</span><span class="s0">return </span><span class="s1">Sn(t,e,(t=&gt;e=&gt;an(e)&amp;&amp;t(e,An(e)))(i),n)}</span><span class="s0">function </span><span class="s1">En({top:t,left:e,right:i,bottom:n}){</span><span class="s0">return</span><span class="s1">{x:{min:e,max:i},y:{min:t,max:n}}}</span><span class="s0">function </span><span class="s1">Vn(t){</span><span class="s0">return </span><span class="s1">t.max-t.min}</span><span class="s0">function </span><span class="s1">Mn(t,e,i,n=</span><span class="s3">.5</span><span class="s1">){t.origin=n,t.originPoint=te(e.min,e.max,t.origin),t.scale=Vn(i)/Vn(e),t.translate=te(i.min,i.max,t.origin)-t.originPoint,(t.scale&gt;=</span><span class="s3">.9999</span><span class="s1">&amp;&amp;t.scale&lt;=</span><span class="s3">1.0001</span><span class="s1">||isNaN(t.scale))&amp;&amp;(t.scale=</span><span class="s3">1</span><span class="s1">),(t.translate&gt;=-</span><span class="s3">.01</span><span class="s1">&amp;&amp;t.translate&lt;=</span><span class="s3">.01</span><span class="s1">||isNaN(t.translate))&amp;&amp;(t.translate=</span><span class="s3">0</span><span class="s1">)}</span><span class="s0">function </span><span class="s1">Dn(t,e,i,n){Mn(t.x,e.x,i.x,n?n.originX:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">),Mn(t.y,e.y,i.y,n?n.originY:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">)}</span><span class="s0">function </span><span class="s1">Cn(t,e,i){t.min=i.min+e.min,t.max=t.min+Vn(e)}</span><span class="s0">function </span><span class="s1">kn(t,e,i){t.min=e.min-i.min,t.max=t.min+Vn(e)}</span><span class="s0">function </span><span class="s1">Rn(t,e,i){kn(t.x,e.x,i.x),kn(t.y,e.y,i.y)}</span><span class="s0">const </span><span class="s1">Ln=()=&gt;({x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}});</span><span class="s0">function </span><span class="s1">jn(t){</span><span class="s0">return</span><span class="s1">[t(</span><span class="s2">&quot;x&quot;</span><span class="s1">),t(</span><span class="s2">&quot;y&quot;</span><span class="s1">)]}</span><span class="s0">function </span><span class="s1">Bn(t){</span><span class="s0">return void </span><span class="s3">0</span><span class="s1">===t||</span><span class="s3">1</span><span class="s1">===t}</span><span class="s0">function </span><span class="s1">Fn({scale:t,scaleX:e,scaleY:i}){</span><span class="s0">return</span><span class="s1">!Bn(t)||!Bn(e)||!Bn(i)}</span><span class="s0">function </span><span class="s1">In(t){</span><span class="s0">return </span><span class="s1">Fn(t)||On(t)||t.z||t.rotate||t.rotateX||t.rotateY||t.skewX||t.skewY}</span><span class="s0">function </span><span class="s1">On(t){</span><span class="s0">return </span><span class="s1">Un(t.x)||Un(t.y)}</span><span class="s0">function </span><span class="s1">Un(t){</span><span class="s0">return </span><span class="s1">t&amp;&amp;</span><span class="s2">&quot;0%&quot;</span><span class="s1">!==t}</span><span class="s0">function </span><span class="s1">Nn(t,e,i){</span><span class="s0">return </span><span class="s1">i+e*(t-i)}</span><span class="s0">function </span><span class="s1">Kn(t,e,i,n,s){</span><span class="s0">return void </span><span class="s3">0</span><span class="s1">!==s&amp;&amp;(t=Nn(t,s,n)),Nn(t,i,n)+e}</span><span class="s0">function </span><span class="s1">Wn(t,e=</span><span class="s3">0</span><span class="s1">,i=</span><span class="s3">1</span><span class="s1">,n,s){t.min=Kn(t.min,e,i,n,s),t.max=Kn(t.max,e,i,n,s)}</span><span class="s0">function </span><span class="s1">$n(t,{x:e,y:i}){Wn(t.x,e.translate,e.scale,e.originPoint),Wn(t.y,i.translate,i.scale,i.originPoint)}</span><span class="s0">const </span><span class="s1">zn=</span><span class="s3">.999999999999</span><span class="s1">,Yn=</span><span class="s3">1.0000000000001</span><span class="s1">;</span><span class="s0">function </span><span class="s1">Xn(t,e){t.min=t.min+e,t.max=t.max+e}</span><span class="s0">function </span><span class="s1">Hn(t,e,i,n,s=</span><span class="s3">.5</span><span class="s1">){Wn(t,e,i,te(t.min,t.max,s),n)}</span><span class="s0">function </span><span class="s1">Gn(t,e){Hn(t.x,e.x,e.scaleX,e.scale,e.originX),Hn(t.y,e.y,e.scaleY,e.scale,e.originY)}</span><span class="s0">function </span><span class="s1">qn(t,e){</span><span class="s0">return </span><span class="s1">En(</span><span class="s0">function</span><span class="s1">(t,e){</span><span class="s0">if</span><span class="s1">(!e)</span><span class="s0">return </span><span class="s1">t;</span><span class="s0">const </span><span class="s1">i=e({x:t.left,y:t.top}),n=e({x:t.right,y:t.bottom});</span><span class="s0">return</span><span class="s1">{top:i.y,left:i.x,bottom:n.y,right:n.x}}(t.getBoundingClientRect(),e))}</span><span class="s0">const </span><span class="s1">_n=({current:t})=&gt;t?t.ownerDocument.defaultView:</span><span class="s0">null</span><span class="s1">;</span><span class="s0">function </span><span class="s1">Zn(t,e){</span><span class="s0">const </span><span class="s1">i=t.getValue(</span><span class="s2">&quot;willChange&quot;</span><span class="s1">);</span><span class="s0">if</span><span class="s1">(n=i,Boolean(d(n)&amp;&amp;n.add))</span><span class="s0">return </span><span class="s1">i.add(e);</span><span class="s0">if</span><span class="s1">(!i&amp;&amp;H.WillChange){</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">new </span><span class="s1">H.WillChange(</span><span class="s2">&quot;auto&quot;</span><span class="s1">);t.addValue(</span><span class="s2">&quot;willChange&quot;</span><span class="s1">,i),i.add(e)}</span><span class="s0">var </span><span class="s1">n}</span><span class="s0">const </span><span class="s1">Jn=(t,e)=&gt;Math.abs(t-e);</span><span class="s0">class </span><span class="s1">Qn{constructor(t,e,{transformPagePoint:i,contextWindow:n=window,dragSnapToOrigin:s=!</span><span class="s3">1</span><span class="s1">,distanceThreshold:o=</span><span class="s3">3</span><span class="s1">}={}){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.startEvent=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.lastMoveEvent=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.lastMoveEventInfo=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.handlers={},</span><span class="s0">this</span><span class="s1">.contextWindow=window,</span><span class="s0">this</span><span class="s1">.updatePoint=()=&gt;{</span><span class="s0">if</span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.lastMoveEvent||!</span><span class="s0">this</span><span class="s1">.lastMoveEventInfo)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">t=is(</span><span class="s0">this</span><span class="s1">.lastMoveEventInfo,</span><span class="s0">this</span><span class="s1">.history),e=</span><span class="s0">null</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.startEvent,i=</span><span class="s0">function</span><span class="s1">(t,e){</span><span class="s0">const </span><span class="s1">i=Jn(t.x,e.x),n=Jn(t.y,e.y);</span><span class="s0">return </span><span class="s1">Math.sqrt(i**</span><span class="s3">2</span><span class="s1">+n**</span><span class="s3">2</span><span class="s1">)}(t.offset,{x:</span><span class="s3">0</span><span class="s1">,y:</span><span class="s3">0</span><span class="s1">})&gt;=</span><span class="s0">this</span><span class="s1">.distanceThreshold;</span><span class="s0">if</span><span class="s1">(!e&amp;&amp;!i)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{point:n}=t,{timestamp:s}=Mt;</span><span class="s0">this</span><span class="s1">.history.push({...n,timestamp:s});</span><span class="s0">const</span><span class="s1">{onStart:o,onMove:r}=</span><span class="s0">this</span><span class="s1">.handlers;e||(o&amp;&amp;o(</span><span class="s0">this</span><span class="s1">.lastMoveEvent,t),</span><span class="s0">this</span><span class="s1">.startEvent=</span><span class="s0">this</span><span class="s1">.lastMoveEvent),r&amp;&amp;r(</span><span class="s0">this</span><span class="s1">.lastMoveEvent,t)},</span><span class="s0">this</span><span class="s1">.handlePointerMove=(t,e)=&gt;{</span><span class="s0">this</span><span class="s1">.lastMoveEvent=t,</span><span class="s0">this</span><span class="s1">.lastMoveEventInfo=ts(e,</span><span class="s0">this</span><span class="s1">.transformPagePoint),Et.update(</span><span class="s0">this</span><span class="s1">.updatePoint,!</span><span class="s3">0</span><span class="s1">)},</span><span class="s0">this</span><span class="s1">.handlePointerUp=(t,e)=&gt;{</span><span class="s0">this</span><span class="s1">.end();</span><span class="s0">const</span><span class="s1">{onEnd:i,onSessionEnd:n,resumeAnimation:s}=</span><span class="s0">this</span><span class="s1">.handlers;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.dragSnapToOrigin&amp;&amp;s&amp;&amp;s(),!</span><span class="s0">this</span><span class="s1">.lastMoveEvent||!</span><span class="s0">this</span><span class="s1">.lastMoveEventInfo)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">o=is(</span><span class="s2">&quot;pointercancel&quot;</span><span class="s1">===t.type?</span><span class="s0">this</span><span class="s1">.lastMoveEventInfo:ts(e,</span><span class="s0">this</span><span class="s1">.transformPagePoint),</span><span class="s0">this</span><span class="s1">.history);</span><span class="s0">this</span><span class="s1">.startEvent&amp;&amp;i&amp;&amp;i(t,o),n&amp;&amp;n(t,o)},!an(t))</span><span class="s0">return</span><span class="s1">;</span><span class="s0">this</span><span class="s1">.dragSnapToOrigin=s,</span><span class="s0">this</span><span class="s1">.handlers=e,</span><span class="s0">this</span><span class="s1">.transformPagePoint=i,</span><span class="s0">this</span><span class="s1">.distanceThreshold=o,</span><span class="s0">this</span><span class="s1">.contextWindow=n||window;</span><span class="s0">const </span><span class="s1">r=ts(An(t),</span><span class="s0">this</span><span class="s1">.transformPagePoint),{point:a}=r,{timestamp:l}=Mt;</span><span class="s0">this</span><span class="s1">.history=[{...a,timestamp:l}];</span><span class="s0">const</span><span class="s1">{onSessionStart:h}=e;h&amp;&amp;h(t,is(r,</span><span class="s0">this</span><span class="s1">.history)),</span><span class="s0">this</span><span class="s1">.removeListeners=tt(bn(</span><span class="s0">this</span><span class="s1">.contextWindow,</span><span class="s2">&quot;pointermove&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.handlePointerMove),bn(</span><span class="s0">this</span><span class="s1">.contextWindow,</span><span class="s2">&quot;pointerup&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.handlePointerUp),bn(</span><span class="s0">this</span><span class="s1">.contextWindow,</span><span class="s2">&quot;pointercancel&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.handlePointerUp))}updateHandlers(t){</span><span class="s0">this</span><span class="s1">.handlers=t}end(){</span><span class="s0">this</span><span class="s1">.removeListeners&amp;&amp;</span><span class="s0">this</span><span class="s1">.removeListeners(),Vt(</span><span class="s0">this</span><span class="s1">.updatePoint)}}</span><span class="s0">function </span><span class="s1">ts(t,e){</span><span class="s0">return </span><span class="s1">e?{point:e(t.point)}:t}</span><span class="s0">function </span><span class="s1">es(t,e){</span><span class="s0">return</span><span class="s1">{x:t.x-e.x,y:t.y-e.y}}</span><span class="s0">function </span><span class="s1">is({point:t},e){</span><span class="s0">return</span><span class="s1">{point:t,delta:es(t,ss(e)),offset:es(t,ns(e)),velocity:os(e,</span><span class="s3">.1</span><span class="s1">)}}</span><span class="s0">function </span><span class="s1">ns(t){</span><span class="s0">return </span><span class="s1">t[</span><span class="s3">0</span><span class="s1">]}</span><span class="s0">function </span><span class="s1">ss(t){</span><span class="s0">return </span><span class="s1">t[t.length-</span><span class="s3">1</span><span class="s1">]}</span><span class="s0">function </span><span class="s1">os(t,e){</span><span class="s0">if</span><span class="s1">(t.length&lt;</span><span class="s3">2</span><span class="s1">)</span><span class="s0">return</span><span class="s1">{x:</span><span class="s3">0</span><span class="s1">,y:</span><span class="s3">0</span><span class="s1">};</span><span class="s0">let </span><span class="s1">i=t.length-</span><span class="s3">1</span><span class="s1">,n=</span><span class="s0">null</span><span class="s1">;</span><span class="s0">const </span><span class="s1">s=ss(t);</span><span class="s0">for</span><span class="s1">(;i&gt;=</span><span class="s3">0</span><span class="s1">&amp;&amp;(n=t[i],!(s.timestamp-n.timestamp&gt;nt(e)));)i--;</span><span class="s0">if</span><span class="s1">(!n)</span><span class="s0">return</span><span class="s1">{x:</span><span class="s3">0</span><span class="s1">,y:</span><span class="s3">0</span><span class="s1">};</span><span class="s0">const </span><span class="s1">o=st(s.timestamp-n.timestamp);</span><span class="s0">if</span><span class="s1">(</span><span class="s3">0</span><span class="s1">===o)</span><span class="s0">return</span><span class="s1">{x:</span><span class="s3">0</span><span class="s1">,y:</span><span class="s3">0</span><span class="s1">};</span><span class="s0">const </span><span class="s1">r={x:(s.x-n.x)/o,y:(s.y-n.y)/o};</span><span class="s0">return </span><span class="s1">r.x===</span><span class="s3">1</span><span class="s1">/</span><span class="s3">0</span><span class="s1">&amp;&amp;(r.x=</span><span class="s3">0</span><span class="s1">),r.y===</span><span class="s3">1</span><span class="s1">/</span><span class="s3">0</span><span class="s1">&amp;&amp;(r.y=</span><span class="s3">0</span><span class="s1">),r}</span><span class="s0">function </span><span class="s1">rs(t,e,i){</span><span class="s0">return</span><span class="s1">{min:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==e?t.min+e:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,max:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==i?t.max+i-(t.max-t.min):</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}}</span><span class="s0">function </span><span class="s1">as(t,e){</span><span class="s0">let </span><span class="s1">i=e.min-t.min,n=e.max-t.max;</span><span class="s0">return </span><span class="s1">e.max-e.min&lt;t.max-t.min&amp;&amp;([i,n]=[n,i]),{min:i,max:n}}</span><span class="s0">const </span><span class="s1">ls=</span><span class="s3">.35</span><span class="s1">;</span><span class="s0">function </span><span class="s1">hs(t,e,i){</span><span class="s0">return</span><span class="s1">{min:us(t,e),max:us(t,i)}}</span><span class="s0">function </span><span class="s1">us(t,e){</span><span class="s0">return</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t?t:t[e]||</span><span class="s3">0</span><span class="s1">}</span><span class="s0">const </span><span class="s1">cs=</span><span class="s0">new </span><span class="s1">WeakMap;</span><span class="s0">class </span><span class="s1">ds{constructor(t){</span><span class="s0">this</span><span class="s1">.openDragLock=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isDragging=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.currentDirection=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.originPoint={x:</span><span class="s3">0</span><span class="s1">,y:</span><span class="s3">0</span><span class="s1">},</span><span class="s0">this</span><span class="s1">.constraints=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.hasMutatedConstraints=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.elastic={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}},</span><span class="s0">this</span><span class="s1">.latestPointerEvent=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.latestPanInfo=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.visualElement=t}start(t,{snapToCursor:e=!</span><span class="s3">1</span><span class="s1">,distanceThreshold:i}={}){</span><span class="s0">const</span><span class="s1">{presenceContext:s}=</span><span class="s0">this</span><span class="s1">.visualElement;</span><span class="s0">if</span><span class="s1">(s&amp;&amp;!</span><span class="s3">1</span><span class="s1">===s.isPresent)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{dragSnapToOrigin:o}=</span><span class="s0">this</span><span class="s1">.getProps();</span><span class="s0">this</span><span class="s1">.panSession=</span><span class="s0">new </span><span class="s1">Qn(t,{onSessionStart:t=&gt;{</span><span class="s0">const</span><span class="s1">{dragSnapToOrigin:i}=</span><span class="s0">this</span><span class="s1">.getProps();i?</span><span class="s0">this</span><span class="s1">.pauseAnimation():</span><span class="s0">this</span><span class="s1">.stopAnimation(),e&amp;&amp;</span><span class="s0">this</span><span class="s1">.snapToCursor(An(t).point)},onStart:(t,e)=&gt;{</span><span class="s0">const</span><span class="s1">{drag:i,dragPropagation:s,onDragStart:o}=</span><span class="s0">this</span><span class="s1">.getProps();</span><span class="s0">if</span><span class="s1">(i&amp;&amp;!s&amp;&amp;(</span><span class="s0">this</span><span class="s1">.openDragLock&amp;&amp;</span><span class="s0">this</span><span class="s1">.openDragLock(),</span><span class="s0">this</span><span class="s1">.openDragLock=</span><span class="s2">&quot;x&quot;</span><span class="s1">===(r=i)||</span><span class="s2">&quot;y&quot;</span><span class="s1">===r?en[r]?</span><span class="s0">null</span><span class="s1">:(en[r]=!</span><span class="s3">0</span><span class="s1">,()=&gt;{en[r]=!</span><span class="s3">1</span><span class="s1">}):en.x||en.y?</span><span class="s0">null</span><span class="s1">:(en.x=en.y=!</span><span class="s3">0</span><span class="s1">,()=&gt;{en.x=en.y=!</span><span class="s3">1</span><span class="s1">}),!</span><span class="s0">this</span><span class="s1">.openDragLock))</span><span class="s0">return</span><span class="s1">;</span><span class="s0">var </span><span class="s1">r;</span><span class="s0">this</span><span class="s1">.latestPointerEvent=t,</span><span class="s0">this</span><span class="s1">.latestPanInfo=e,</span><span class="s0">this</span><span class="s1">.isDragging=!</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.currentDirection=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.resolveConstraints(),</span><span class="s0">this</span><span class="s1">.visualElement.projection&amp;&amp;(</span><span class="s0">this</span><span class="s1">.visualElement.projection.isAnimationBlocked=!</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.visualElement.projection.target=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">),jn(t=&gt;{</span><span class="s0">let </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.getAxisMotionValue(t).get()||</span><span class="s3">0</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(n.test(e)){</span><span class="s0">const</span><span class="s1">{projection:i}=</span><span class="s0">this</span><span class="s1">.visualElement;</span><span class="s0">if</span><span class="s1">(i&amp;&amp;i.layout){</span><span class="s0">const </span><span class="s1">n=i.layout.layoutBox[t];</span><span class="s0">if</span><span class="s1">(n){e=Vn(n)*(parseFloat(e)/</span><span class="s3">100</span><span class="s1">)}}}</span><span class="s0">this</span><span class="s1">.originPoint[t]=e}),o&amp;&amp;Et.postRender(()=&gt;o(t,e)),Zn(</span><span class="s0">this</span><span class="s1">.visualElement,</span><span class="s2">&quot;transform&quot;</span><span class="s1">);</span><span class="s0">const</span><span class="s1">{animationState:a}=</span><span class="s0">this</span><span class="s1">.visualElement;a&amp;&amp;a.setActive(</span><span class="s2">&quot;whileDrag&quot;</span><span class="s1">,!</span><span class="s3">0</span><span class="s1">)},onMove:(t,e)=&gt;{</span><span class="s0">this</span><span class="s1">.latestPointerEvent=t,</span><span class="s0">this</span><span class="s1">.latestPanInfo=e;</span><span class="s0">const</span><span class="s1">{dragPropagation:i,dragDirectionLock:n,onDirectionLock:s,onDrag:o}=</span><span class="s0">this</span><span class="s1">.getProps();</span><span class="s0">if</span><span class="s1">(!i&amp;&amp;!</span><span class="s0">this</span><span class="s1">.openDragLock)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{offset:r}=e;</span><span class="s0">if</span><span class="s1">(n&amp;&amp;</span><span class="s0">null</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.currentDirection)</span><span class="s0">return this</span><span class="s1">.currentDirection=</span><span class="s0">function</span><span class="s1">(t,e=</span><span class="s3">10</span><span class="s1">){</span><span class="s0">let </span><span class="s1">i=</span><span class="s0">null</span><span class="s1">;Math.abs(t.y)&gt;e?i=</span><span class="s2">&quot;y&quot;</span><span class="s1">:Math.abs(t.x)&gt;e&amp;&amp;(i=</span><span class="s2">&quot;x&quot;</span><span class="s1">);</span><span class="s0">return </span><span class="s1">i}(r),</span><span class="s0">void</span><span class="s1">(</span><span class="s0">null</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.currentDirection&amp;&amp;s&amp;&amp;s(</span><span class="s0">this</span><span class="s1">.currentDirection));</span><span class="s0">this</span><span class="s1">.updateAxis(</span><span class="s2">&quot;x&quot;</span><span class="s1">,e.point,r),</span><span class="s0">this</span><span class="s1">.updateAxis(</span><span class="s2">&quot;y&quot;</span><span class="s1">,e.point,r),</span><span class="s0">this</span><span class="s1">.visualElement.render(),o&amp;&amp;o(t,e)},onSessionEnd:(t,e)=&gt;{</span><span class="s0">this</span><span class="s1">.latestPointerEvent=t,</span><span class="s0">this</span><span class="s1">.latestPanInfo=e,</span><span class="s0">this</span><span class="s1">.stop(t,e),</span><span class="s0">this</span><span class="s1">.latestPointerEvent=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.latestPanInfo=</span><span class="s0">null</span><span class="s1">},resumeAnimation:()=&gt;jn(t=&gt;</span><span class="s2">&quot;paused&quot;</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.getAnimationState(t)&amp;&amp;</span><span class="s0">this</span><span class="s1">.getAxisMotionValue(t).animation?.play())},{transformPagePoint:</span><span class="s0">this</span><span class="s1">.visualElement.getTransformPagePoint(),dragSnapToOrigin:o,distanceThreshold:i,contextWindow:_n(</span><span class="s0">this</span><span class="s1">.visualElement)})}stop(t,e){</span><span class="s0">const </span><span class="s1">i=t||</span><span class="s0">this</span><span class="s1">.latestPointerEvent,n=e||</span><span class="s0">this</span><span class="s1">.latestPanInfo,s=</span><span class="s0">this</span><span class="s1">.isDragging;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.cancel(),!s||!n||!i)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{velocity:o}=n;</span><span class="s0">this</span><span class="s1">.startAnimation(o);</span><span class="s0">const</span><span class="s1">{onDragEnd:r}=</span><span class="s0">this</span><span class="s1">.getProps();r&amp;&amp;Et.postRender(()=&gt;r(i,n))}cancel(){</span><span class="s0">this</span><span class="s1">.isDragging=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{projection:t,animationState:e}=</span><span class="s0">this</span><span class="s1">.visualElement;t&amp;&amp;(t.isAnimationBlocked=!</span><span class="s3">1</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.panSession&amp;&amp;</span><span class="s0">this</span><span class="s1">.panSession.end(),</span><span class="s0">this</span><span class="s1">.panSession=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{dragPropagation:i}=</span><span class="s0">this</span><span class="s1">.getProps();!i&amp;&amp;</span><span class="s0">this</span><span class="s1">.openDragLock&amp;&amp;(</span><span class="s0">this</span><span class="s1">.openDragLock(),</span><span class="s0">this</span><span class="s1">.openDragLock=</span><span class="s0">null</span><span class="s1">),e&amp;&amp;e.setActive(</span><span class="s2">&quot;whileDrag&quot;</span><span class="s1">,!</span><span class="s3">1</span><span class="s1">)}updateAxis(t,e,i){</span><span class="s0">const</span><span class="s1">{drag:n}=</span><span class="s0">this</span><span class="s1">.getProps();</span><span class="s0">if</span><span class="s1">(!i||!ps(t,n,</span><span class="s0">this</span><span class="s1">.currentDirection))</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">s=</span><span class="s0">this</span><span class="s1">.getAxisMotionValue(t);</span><span class="s0">let </span><span class="s1">o=</span><span class="s0">this</span><span class="s1">.originPoint[t]+i[t];</span><span class="s0">this</span><span class="s1">.constraints&amp;&amp;</span><span class="s0">this</span><span class="s1">.constraints[t]&amp;&amp;(o=</span><span class="s0">function</span><span class="s1">(t,{min:e,max:i},n){</span><span class="s0">return void </span><span class="s3">0</span><span class="s1">!==e&amp;&amp;t&lt;e?t=n?te(e,t,n.min):Math.max(t,e):</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==i&amp;&amp;t&gt;i&amp;&amp;(t=n?te(i,t,n.max):Math.min(t,i)),t}(o,</span><span class="s0">this</span><span class="s1">.constraints[t],</span><span class="s0">this</span><span class="s1">.elastic[t])),s.set(o)}resolveConstraints(){</span><span class="s0">const</span><span class="s1">{dragConstraints:t,dragElastic:e}=</span><span class="s0">this</span><span class="s1">.getProps(),i=</span><span class="s0">this</span><span class="s1">.visualElement.projection&amp;&amp;!</span><span class="s0">this</span><span class="s1">.visualElement.projection.layout?</span><span class="s0">this</span><span class="s1">.visualElement.projection.measure(!</span><span class="s3">1</span><span class="s1">):</span><span class="s0">this</span><span class="s1">.visualElement.projection?.layout,n=</span><span class="s0">this</span><span class="s1">.constraints;t&amp;&amp;p(t)?</span><span class="s0">this</span><span class="s1">.constraints||(</span><span class="s0">this</span><span class="s1">.constraints=</span><span class="s0">this</span><span class="s1">.resolveRefConstraints()):</span><span class="s0">this</span><span class="s1">.constraints=!(!t||!i)&amp;&amp;</span><span class="s0">function</span><span class="s1">(t,{top:e,left:i,bottom:n,right:s}){</span><span class="s0">return</span><span class="s1">{x:rs(t.x,i,s),y:rs(t.y,e,n)}}(i.layoutBox,t),</span><span class="s0">this</span><span class="s1">.elastic=</span><span class="s0">function</span><span class="s1">(t=ls){</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">===t?t=</span><span class="s3">0</span><span class="s1">:!</span><span class="s3">0</span><span class="s1">===t&amp;&amp;(t=ls),{x:hs(t,</span><span class="s2">&quot;left&quot;</span><span class="s1">,</span><span class="s2">&quot;right&quot;</span><span class="s1">),y:hs(t,</span><span class="s2">&quot;top&quot;</span><span class="s1">,</span><span class="s2">&quot;bottom&quot;</span><span class="s1">)}}(e),n!==</span><span class="s0">this</span><span class="s1">.constraints&amp;&amp;i&amp;&amp;</span><span class="s0">this</span><span class="s1">.constraints&amp;&amp;!</span><span class="s0">this</span><span class="s1">.hasMutatedConstraints&amp;&amp;jn(t=&gt;{!</span><span class="s3">1</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.constraints&amp;&amp;</span><span class="s0">this</span><span class="s1">.getAxisMotionValue(t)&amp;&amp;(</span><span class="s0">this</span><span class="s1">.constraints[t]=</span><span class="s0">function</span><span class="s1">(t,e){</span><span class="s0">const </span><span class="s1">i={};</span><span class="s0">return void </span><span class="s3">0</span><span class="s1">!==e.min&amp;&amp;(i.min=e.min-t.min),</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==e.max&amp;&amp;(i.max=e.max-t.min),i}(i.layoutBox[t],</span><span class="s0">this</span><span class="s1">.constraints[t]))})}resolveRefConstraints(){</span><span class="s0">const</span><span class="s1">{dragConstraints:t,onMeasureDragConstraints:e}=</span><span class="s0">this</span><span class="s1">.getProps();</span><span class="s0">if</span><span class="s1">(!t||!p(t))</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">const </span><span class="s1">i=t.current,{projection:n}=</span><span class="s0">this</span><span class="s1">.visualElement;</span><span class="s0">if</span><span class="s1">(!n||!n.layout)</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">const </span><span class="s1">s=</span><span class="s0">function</span><span class="s1">(t,e,i){</span><span class="s0">const </span><span class="s1">n=qn(t,i),{scroll:s}=e;</span><span class="s0">return </span><span class="s1">s&amp;&amp;(Xn(n.x,s.offset.x),Xn(n.y,s.offset.y)),n}(i,n.root,</span><span class="s0">this</span><span class="s1">.visualElement.getTransformPagePoint());</span><span class="s0">let </span><span class="s1">o=</span><span class="s0">function</span><span class="s1">(t,e){</span><span class="s0">return</span><span class="s1">{x:as(t.x,e.x),y:as(t.y,e.y)}}(n.layout.layoutBox,s);</span><span class="s0">if</span><span class="s1">(e){</span><span class="s0">const </span><span class="s1">t=e(</span><span class="s0">function</span><span class="s1">({x:t,y:e}){</span><span class="s0">return</span><span class="s1">{top:e.min,right:t.max,bottom:e.max,left:t.min}}(o));</span><span class="s0">this</span><span class="s1">.hasMutatedConstraints=!!t,t&amp;&amp;(o=En(t))}</span><span class="s0">return </span><span class="s1">o}startAnimation(t){</span><span class="s0">const</span><span class="s1">{drag:e,dragMomentum:i,dragElastic:n,dragTransition:s,dragSnapToOrigin:o,onDragTransitionEnd:r}=</span><span class="s0">this</span><span class="s1">.getProps(),a=</span><span class="s0">this</span><span class="s1">.constraints||{},l=jn(r=&gt;{</span><span class="s0">if</span><span class="s1">(!ps(r,e,</span><span class="s0">this</span><span class="s1">.currentDirection))</span><span class="s0">return</span><span class="s1">;</span><span class="s0">let </span><span class="s1">l=a&amp;&amp;a[r]||{};o&amp;&amp;(l={min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">});</span><span class="s0">const </span><span class="s1">h=n?</span><span class="s3">200</span><span class="s1">:</span><span class="s3">1e6</span><span class="s1">,u=n?</span><span class="s3">40</span><span class="s1">:</span><span class="s3">1e7</span><span class="s1">,c={type:</span><span class="s2">&quot;inertia&quot;</span><span class="s1">,velocity:i?t[r]:</span><span class="s3">0</span><span class="s1">,bounceStiffness:h,bounceDamping:u,timeConstant:</span><span class="s3">750</span><span class="s1">,restDelta:</span><span class="s3">1</span><span class="s1">,restSpeed:</span><span class="s3">10</span><span class="s1">,...s,...l};</span><span class="s0">return this</span><span class="s1">.startAxisValueAnimation(r,c)});</span><span class="s0">return </span><span class="s1">Promise.all(l).then(r)}startAxisValueAnimation(t,e){</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">.getAxisMotionValue(t);</span><span class="s0">return </span><span class="s1">Zn(</span><span class="s0">this</span><span class="s1">.visualElement,t),i.start(wn(t,i,</span><span class="s3">0</span><span class="s1">,e,</span><span class="s0">this</span><span class="s1">.visualElement,!</span><span class="s3">1</span><span class="s1">))}stopAnimation(){jn(t=&gt;</span><span class="s0">this</span><span class="s1">.getAxisMotionValue(t).stop())}pauseAnimation(){jn(t=&gt;</span><span class="s0">this</span><span class="s1">.getAxisMotionValue(t).animation?.pause())}getAnimationState(t){</span><span class="s0">return this</span><span class="s1">.getAxisMotionValue(t).animation?.state}getAxisMotionValue(t){</span><span class="s0">const </span><span class="s1">e=</span><span class="s2">`_drag</span><span class="s1">${t.toUpperCase()}</span><span class="s2">`</span><span class="s1">,i=</span><span class="s0">this</span><span class="s1">.visualElement.getProps(),n=i[e];</span><span class="s0">return </span><span class="s1">n||</span><span class="s0">this</span><span class="s1">.visualElement.getValue(t,(i.initial?i.initial[t]:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">)||</span><span class="s3">0</span><span class="s1">)}snapToCursor(t){jn(e=&gt;{</span><span class="s0">const</span><span class="s1">{drag:i}=</span><span class="s0">this</span><span class="s1">.getProps();</span><span class="s0">if</span><span class="s1">(!ps(e,i,</span><span class="s0">this</span><span class="s1">.currentDirection))</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{projection:n}=</span><span class="s0">this</span><span class="s1">.visualElement,s=</span><span class="s0">this</span><span class="s1">.getAxisMotionValue(e);</span><span class="s0">if</span><span class="s1">(n&amp;&amp;n.layout){</span><span class="s0">const</span><span class="s1">{min:i,max:o}=n.layout.layoutBox[e];s.set(t[e]-te(i,o,</span><span class="s3">.5</span><span class="s1">))}})}scalePositionWithinConstraints(){</span><span class="s0">if</span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.visualElement.current)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{drag:t,dragConstraints:e}=</span><span class="s0">this</span><span class="s1">.getProps(),{projection:n}=</span><span class="s0">this</span><span class="s1">.visualElement;</span><span class="s0">if</span><span class="s1">(!p(e)||!n||!</span><span class="s0">this</span><span class="s1">.constraints)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">this</span><span class="s1">.stopAnimation();</span><span class="s0">const </span><span class="s1">s={x:</span><span class="s3">0</span><span class="s1">,y:</span><span class="s3">0</span><span class="s1">};jn(t=&gt;{</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.getAxisMotionValue(t);</span><span class="s0">if</span><span class="s1">(e&amp;&amp;!</span><span class="s3">1</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.constraints){</span><span class="s0">const </span><span class="s1">n=e.get();s[t]=</span><span class="s0">function</span><span class="s1">(t,e){</span><span class="s0">let </span><span class="s1">n=</span><span class="s3">.5</span><span class="s1">;</span><span class="s0">const </span><span class="s1">s=Vn(t),o=Vn(e);</span><span class="s0">return </span><span class="s1">o&gt;s?n=et(e.min,e.max-s,t.min):s&gt;o&amp;&amp;(n=et(t.min,t.max-o,e.min)),i(</span><span class="s3">0</span><span class="s1">,</span><span class="s3">1</span><span class="s1">,n)}({min:n,max:n},</span><span class="s0">this</span><span class="s1">.constraints[t])}});</span><span class="s0">const</span><span class="s1">{transformTemplate:o}=</span><span class="s0">this</span><span class="s1">.visualElement.getProps();</span><span class="s0">this</span><span class="s1">.visualElement.current.style.transform=o?o({},</span><span class="s2">&quot;&quot;</span><span class="s1">):</span><span class="s2">&quot;none&quot;</span><span class="s1">,n.root&amp;&amp;n.root.updateScroll(),n.updateLayout(),</span><span class="s0">this</span><span class="s1">.resolveConstraints(),jn(e=&gt;{</span><span class="s0">if</span><span class="s1">(!ps(e,t,</span><span class="s0">null</span><span class="s1">))</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">.getAxisMotionValue(e),{min:n,max:o}=</span><span class="s0">this</span><span class="s1">.constraints[e];i.set(te(n,o,s[e]))})}addListeners(){</span><span class="s0">if</span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.visualElement.current)</span><span class="s0">return</span><span class="s1">;cs.set(</span><span class="s0">this</span><span class="s1">.visualElement,</span><span class="s0">this</span><span class="s1">);</span><span class="s0">const </span><span class="s1">t=bn(</span><span class="s0">this</span><span class="s1">.visualElement.current,</span><span class="s2">&quot;pointerdown&quot;</span><span class="s1">,t=&gt;{</span><span class="s0">const</span><span class="s1">{drag:e,dragListener:i=!</span><span class="s3">0</span><span class="s1">}=</span><span class="s0">this</span><span class="s1">.getProps();e&amp;&amp;i&amp;&amp;</span><span class="s0">this</span><span class="s1">.start(t)}),e=()=&gt;{</span><span class="s0">const</span><span class="s1">{dragConstraints:t}=</span><span class="s0">this</span><span class="s1">.getProps();p(t)&amp;&amp;t.current&amp;&amp;(</span><span class="s0">this</span><span class="s1">.constraints=</span><span class="s0">this</span><span class="s1">.resolveRefConstraints())},{projection:i}=</span><span class="s0">this</span><span class="s1">.visualElement,n=i.addEventListener(</span><span class="s2">&quot;measure&quot;</span><span class="s1">,e);i&amp;&amp;!i.layout&amp;&amp;(i.root&amp;&amp;i.root.updateScroll(),i.updateLayout()),Et.read(e);</span><span class="s0">const </span><span class="s1">s=Sn(window,</span><span class="s2">&quot;resize&quot;</span><span class="s1">,()=&gt;</span><span class="s0">this</span><span class="s1">.scalePositionWithinConstraints()),o=i.addEventListener(</span><span class="s2">&quot;didUpdate&quot;</span><span class="s1">,({delta:t,hasLayoutChanged:e})=&gt;{</span><span class="s0">this</span><span class="s1">.isDragging&amp;&amp;e&amp;&amp;(jn(e=&gt;{</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">.getAxisMotionValue(e);i&amp;&amp;(</span><span class="s0">this</span><span class="s1">.originPoint[e]+=t[e].translate,i.set(i.get()+t[e].translate))}),</span><span class="s0">this</span><span class="s1">.visualElement.render())});</span><span class="s0">return</span><span class="s1">()=&gt;{s(),t(),n(),o&amp;&amp;o()}}getProps(){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.visualElement.getProps(),{drag:e=!</span><span class="s3">1</span><span class="s1">,dragDirectionLock:i=!</span><span class="s3">1</span><span class="s1">,dragPropagation:n=!</span><span class="s3">1</span><span class="s1">,dragConstraints:s=!</span><span class="s3">1</span><span class="s1">,dragElastic:o=ls,dragMomentum:r=!</span><span class="s3">0</span><span class="s1">}=t;</span><span class="s0">return</span><span class="s1">{...t,drag:e,dragDirectionLock:i,dragPropagation:n,dragConstraints:s,dragElastic:o,dragMomentum:r}}}</span><span class="s0">function </span><span class="s1">ps(t,e,i){</span><span class="s0">return</span><span class="s1">!(!</span><span class="s3">0</span><span class="s1">!==e&amp;&amp;e!==t||</span><span class="s0">null</span><span class="s1">!==i&amp;&amp;i!==t)}</span><span class="s0">const </span><span class="s1">ms=t=&gt;(e,i)=&gt;{t&amp;&amp;Et.postRender(()=&gt;t(e,i))};</span><span class="s0">function </span><span class="s1">fs(t){</span><span class="s0">return </span><span class="s1">t.props[m]}</span><span class="s0">const </span><span class="s1">ys=(t,e)=&gt;t.depth-e.depth;</span><span class="s0">class </span><span class="s1">gs{constructor(){</span><span class="s0">this</span><span class="s1">.children=[],</span><span class="s0">this</span><span class="s1">.isDirty=!</span><span class="s3">1</span><span class="s1">}add(t){Y(</span><span class="s0">this</span><span class="s1">.children,t),</span><span class="s0">this</span><span class="s1">.isDirty=!</span><span class="s3">0</span><span class="s1">}remove(t){X(</span><span class="s0">this</span><span class="s1">.children,t),</span><span class="s0">this</span><span class="s1">.isDirty=!</span><span class="s3">0</span><span class="s1">}forEach(t){</span><span class="s0">this</span><span class="s1">.isDirty&amp;&amp;</span><span class="s0">this</span><span class="s1">.children.sort(ys),</span><span class="s0">this</span><span class="s1">.isDirty=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.children.forEach(t)}}</span><span class="s0">const </span><span class="s1">vs=[</span><span class="s2">&quot;TopLeft&quot;</span><span class="s1">,</span><span class="s2">&quot;TopRight&quot;</span><span class="s1">,</span><span class="s2">&quot;BottomLeft&quot;</span><span class="s1">,</span><span class="s2">&quot;BottomRight&quot;</span><span class="s1">],xs=vs.length,Ts=t=&gt;</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t?parseFloat(t):t,Ps=t=&gt;</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t||o.test(t);</span><span class="s0">function </span><span class="s1">ws(t,e){</span><span class="s0">return void </span><span class="s3">0</span><span class="s1">!==t[e]?t[e]:t.borderRadius}</span><span class="s0">const </span><span class="s1">Ss=bs(</span><span class="s3">0</span><span class="s1">,</span><span class="s3">.5</span><span class="s1">,ft),As=bs(</span><span class="s3">.5</span><span class="s1">,</span><span class="s3">.95</span><span class="s1">,J);</span><span class="s0">function </span><span class="s1">bs(t,e,i){</span><span class="s0">return </span><span class="s1">n=&gt;n&lt;t?</span><span class="s3">0</span><span class="s1">:n&gt;e?</span><span class="s3">1</span><span class="s1">:i(et(t,e,n))}</span><span class="s0">function </span><span class="s1">Es(t,e){t.min=e.min,t.max=e.max}</span><span class="s0">function </span><span class="s1">Vs(t,e){Es(t.x,e.x),Es(t.y,e.y)}</span><span class="s0">function </span><span class="s1">Ms(t,e){t.translate=e.translate,t.scale=e.scale,t.originPoint=e.originPoint,t.origin=e.origin}</span><span class="s0">function </span><span class="s1">Ds(t,e,i,n,s){</span><span class="s0">return </span><span class="s1">t=Nn(t-=e,</span><span class="s3">1</span><span class="s1">/i,n),</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==s&amp;&amp;(t=Nn(t,</span><span class="s3">1</span><span class="s1">/s,n)),t}</span><span class="s0">function </span><span class="s1">Cs(t,e,[i,s,o],r,a){!</span><span class="s0">function</span><span class="s1">(t,e=</span><span class="s3">0</span><span class="s1">,i=</span><span class="s3">1</span><span class="s1">,s=</span><span class="s3">.5</span><span class="s1">,o,r=t,a=t){n.test(e)&amp;&amp;(e=parseFloat(e),e=te(a.min,a.max,e/</span><span class="s3">100</span><span class="s1">)-a.min);</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;number&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">e)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">let </span><span class="s1">l=te(r.min,r.max,s);t===r&amp;&amp;(l-=e),t.min=Ds(t.min,e,i,l,o),t.max=Ds(t.max,e,i,l,o)}(t,e[i],e[s],e[o],e.scale,r,a)}</span><span class="s0">const </span><span class="s1">ks=[</span><span class="s2">&quot;x&quot;</span><span class="s1">,</span><span class="s2">&quot;scaleX&quot;</span><span class="s1">,</span><span class="s2">&quot;originX&quot;</span><span class="s1">],Rs=[</span><span class="s2">&quot;y&quot;</span><span class="s1">,</span><span class="s2">&quot;scaleY&quot;</span><span class="s1">,</span><span class="s2">&quot;originY&quot;</span><span class="s1">];</span><span class="s0">function </span><span class="s1">Ls(t,e,i,n){Cs(t.x,e,ks,i?i.x:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,n?n.x:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">),Cs(t.y,e,Rs,i?i.y:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,n?n.y:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">)}</span><span class="s0">function </span><span class="s1">js(t){</span><span class="s0">return </span><span class="s3">0</span><span class="s1">===t.translate&amp;&amp;</span><span class="s3">1</span><span class="s1">===t.scale}</span><span class="s0">function </span><span class="s1">Bs(t){</span><span class="s0">return </span><span class="s1">js(t.x)&amp;&amp;js(t.y)}</span><span class="s0">function </span><span class="s1">Fs(t,e){</span><span class="s0">return </span><span class="s1">t.min===e.min&amp;&amp;t.max===e.max}</span><span class="s0">function </span><span class="s1">Is(t,e){</span><span class="s0">return </span><span class="s1">Math.round(t.min)===Math.round(e.min)&amp;&amp;Math.round(t.max)===Math.round(e.max)}</span><span class="s0">function </span><span class="s1">Os(t,e){</span><span class="s0">return </span><span class="s1">Is(t.x,e.x)&amp;&amp;Is(t.y,e.y)}</span><span class="s0">function </span><span class="s1">Us(t){</span><span class="s0">return </span><span class="s1">Vn(t.x)/Vn(t.y)}</span><span class="s0">function </span><span class="s1">Ns(t,e){</span><span class="s0">return </span><span class="s1">t.translate===e.translate&amp;&amp;t.scale===e.scale&amp;&amp;t.originPoint===e.originPoint}</span><span class="s0">class </span><span class="s1">Ks{constructor(){</span><span class="s0">this</span><span class="s1">.members=[]}add(t){Y(</span><span class="s0">this</span><span class="s1">.members,t),t.scheduleRender()}remove(t){</span><span class="s0">if</span><span class="s1">(X(</span><span class="s0">this</span><span class="s1">.members,t),t===</span><span class="s0">this</span><span class="s1">.prevLead&amp;&amp;(</span><span class="s0">this</span><span class="s1">.prevLead=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">),t===</span><span class="s0">this</span><span class="s1">.lead){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.members[</span><span class="s0">this</span><span class="s1">.members.length-</span><span class="s3">1</span><span class="s1">];t&amp;&amp;</span><span class="s0">this</span><span class="s1">.promote(t)}}relegate(t){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.members.findIndex(e=&gt;t===e);</span><span class="s0">if</span><span class="s1">(</span><span class="s3">0</span><span class="s1">===e)</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">let </span><span class="s1">i;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">t=e;t&gt;=</span><span class="s3">0</span><span class="s1">;t--){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.members[t];</span><span class="s0">if</span><span class="s1">(!</span><span class="s3">1</span><span class="s1">!==e.isPresent){i=e;</span><span class="s0">break</span><span class="s1">}}</span><span class="s0">return</span><span class="s1">!!i&amp;&amp;(</span><span class="s0">this</span><span class="s1">.promote(i),!</span><span class="s3">0</span><span class="s1">)}promote(t,e){</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">.lead;</span><span class="s0">if</span><span class="s1">(t!==i&amp;&amp;(</span><span class="s0">this</span><span class="s1">.prevLead=i,</span><span class="s0">this</span><span class="s1">.lead=t,t.show(),i)){i.instance&amp;&amp;i.scheduleRender(),t.scheduleRender(),t.resumeFrom=i,e&amp;&amp;(t.resumeFrom.preserveOpacity=!</span><span class="s3">0</span><span class="s1">),i.snapshot&amp;&amp;(t.snapshot=i.snapshot,t.snapshot.latestValues=i.animationValues||i.latestValues),t.root&amp;&amp;t.root.isUpdating&amp;&amp;(t.isLayoutDirty=!</span><span class="s3">0</span><span class="s1">);</span><span class="s0">const</span><span class="s1">{crossfade:n}=t.options;!</span><span class="s3">1</span><span class="s1">===n&amp;&amp;i.hide()}}exitAnimationComplete(){</span><span class="s0">this</span><span class="s1">.members.forEach(t=&gt;{</span><span class="s0">const</span><span class="s1">{options:e,resumingFrom:i}=t;e.onExitComplete&amp;&amp;e.onExitComplete(),i&amp;&amp;i.options.onExitComplete&amp;&amp;i.options.onExitComplete()})}scheduleRender(){</span><span class="s0">this</span><span class="s1">.members.forEach(t=&gt;{t.instance&amp;&amp;t.scheduleRender(!</span><span class="s3">1</span><span class="s1">)})}removeLeadSnapshot(){</span><span class="s0">this</span><span class="s1">.lead&amp;&amp;</span><span class="s0">this</span><span class="s1">.lead.snapshot&amp;&amp;(</span><span class="s0">this</span><span class="s1">.lead.snapshot=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">)}}</span><span class="s0">const </span><span class="s1">Ws={hasAnimatedSinceResize:!</span><span class="s3">0</span><span class="s1">,hasEverUpdated:!</span><span class="s3">1</span><span class="s1">},$s=[</span><span class="s2">&quot;&quot;</span><span class="s1">,</span><span class="s2">&quot;X&quot;</span><span class="s1">,</span><span class="s2">&quot;Y&quot;</span><span class="s1">,</span><span class="s2">&quot;Z&quot;</span><span class="s1">];</span><span class="s0">let </span><span class="s1">zs=</span><span class="s3">0</span><span class="s1">;</span><span class="s0">function </span><span class="s1">Ys(t,e,i,n){</span><span class="s0">const</span><span class="s1">{latestValues:s}=e;s[t]&amp;&amp;(i[t]=s[t],e.setStaticValue(t,</span><span class="s3">0</span><span class="s1">),n&amp;&amp;(n[t]=</span><span class="s3">0</span><span class="s1">))}</span><span class="s0">function </span><span class="s1">Xs(t){</span><span class="s0">if</span><span class="s1">(t.hasCheckedOptimisedAppear=!</span><span class="s3">0</span><span class="s1">,t.root===t)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{visualElement:e}=t.options;</span><span class="s0">if</span><span class="s1">(!e)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">i=fs(e);</span><span class="s0">if</span><span class="s1">(window.MotionHasOptimisedAnimation(i,</span><span class="s2">&quot;transform&quot;</span><span class="s1">)){</span><span class="s0">const</span><span class="s1">{layout:e,layoutId:n}=t.options;window.MotionCancelOptimisedAnimation(i,</span><span class="s2">&quot;transform&quot;</span><span class="s1">,Et,!(e||n))}</span><span class="s0">const</span><span class="s1">{parent:n}=t;n&amp;&amp;!n.hasCheckedOptimisedAppear&amp;&amp;Xs(n)}</span><span class="s0">function </span><span class="s1">Hs({attachResizeListener:t,defaultParent:e,measureScroll:s,checkIsScrollRoot:o,resetTransform:r}){</span><span class="s0">return class</span><span class="s1">{constructor(t={},i=e?.()){</span><span class="s0">this</span><span class="s1">.id=zs++,</span><span class="s0">this</span><span class="s1">.animationId=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.animationCommitId=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.children=</span><span class="s0">new </span><span class="s1">Set,</span><span class="s0">this</span><span class="s1">.options={},</span><span class="s0">this</span><span class="s1">.isTreeAnimating=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isAnimationBlocked=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isLayoutDirty=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isProjectionDirty=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isSharedProjectionDirty=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isTransformDirty=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.updateManuallyBlocked=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.updateBlockedByResize=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isUpdating=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isSVG=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.needsReset=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.shouldResetTransform=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.hasCheckedOptimisedAppear=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.treeScale={x:</span><span class="s3">1</span><span class="s1">,y:</span><span class="s3">1</span><span class="s1">},</span><span class="s0">this</span><span class="s1">.eventHandlers=</span><span class="s0">new </span><span class="s1">Map,</span><span class="s0">this</span><span class="s1">.hasTreeAnimated=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.updateScheduled=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.scheduleUpdate=()=&gt;</span><span class="s0">this</span><span class="s1">.update(),</span><span class="s0">this</span><span class="s1">.projectionUpdateScheduled=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.checkUpdateFailed=()=&gt;{</span><span class="s0">this</span><span class="s1">.isUpdating&amp;&amp;(</span><span class="s0">this</span><span class="s1">.isUpdating=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.clearAllSnapshots())},</span><span class="s0">this</span><span class="s1">.updateProjection=()=&gt;{</span><span class="s0">this</span><span class="s1">.projectionUpdateScheduled=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.nodes.forEach(_s),</span><span class="s0">this</span><span class="s1">.nodes.forEach(no),</span><span class="s0">this</span><span class="s1">.nodes.forEach(so),</span><span class="s0">this</span><span class="s1">.nodes.forEach(Zs)},</span><span class="s0">this</span><span class="s1">.resolvedRelativeTargetAt=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.hasProjected=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isVisible=!</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.animationProgress=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.sharedNodes=</span><span class="s0">new </span><span class="s1">Map,</span><span class="s0">this</span><span class="s1">.latestValues=t,</span><span class="s0">this</span><span class="s1">.root=i?i.root||i:</span><span class="s0">this</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.path=i?[...i.path,i]:[],</span><span class="s0">this</span><span class="s1">.parent=i,</span><span class="s0">this</span><span class="s1">.depth=i?i.depth+</span><span class="s3">1</span><span class="s1">:</span><span class="s3">0</span><span class="s1">;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">t=</span><span class="s3">0</span><span class="s1">;t&lt;</span><span class="s0">this</span><span class="s1">.path.length;t++)</span><span class="s0">this</span><span class="s1">.path[t].shouldResetTransform=!</span><span class="s3">0</span><span class="s1">;</span><span class="s0">this</span><span class="s1">.root===</span><span class="s0">this</span><span class="s1">&amp;&amp;(</span><span class="s0">this</span><span class="s1">.nodes=</span><span class="s0">new </span><span class="s1">gs)}addEventListener(t,e){</span><span class="s0">return this</span><span class="s1">.eventHandlers.has(t)||</span><span class="s0">this</span><span class="s1">.eventHandlers.set(t,</span><span class="s0">new </span><span class="s1">it),</span><span class="s0">this</span><span class="s1">.eventHandlers.get(t).add(e)}notifyListeners(t,...e){</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">.eventHandlers.get(t);i&amp;&amp;i.notify(...e)}hasListeners(t){</span><span class="s0">return this</span><span class="s1">.eventHandlers.has(t)}mount(e){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.instance)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">var </span><span class="s1">i;</span><span class="s0">this</span><span class="s1">.isSVG=mn(e)&amp;&amp;!(mn(i=e)&amp;&amp;</span><span class="s2">&quot;svg&quot;</span><span class="s1">===i.tagName),</span><span class="s0">this</span><span class="s1">.instance=e;</span><span class="s0">const</span><span class="s1">{layoutId:n,layout:s,visualElement:o}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">if</span><span class="s1">(o&amp;&amp;!o.current&amp;&amp;o.mount(e),</span><span class="s0">this</span><span class="s1">.root.nodes.add(</span><span class="s0">this</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.parent&amp;&amp;</span><span class="s0">this</span><span class="s1">.parent.children.add(</span><span class="s0">this</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.root.hasTreeAnimated&amp;&amp;(s||n)&amp;&amp;(</span><span class="s0">this</span><span class="s1">.isLayoutDirty=!</span><span class="s3">0</span><span class="s1">),t){</span><span class="s0">let </span><span class="s1">i,n=</span><span class="s3">0</span><span class="s1">;</span><span class="s0">const </span><span class="s1">s=()=&gt;</span><span class="s0">this</span><span class="s1">.root.updateBlockedByResize=!</span><span class="s3">1</span><span class="s1">;Et.read(()=&gt;{n=window.innerWidth}),t(e,()=&gt;{</span><span class="s0">const </span><span class="s1">t=window.innerWidth;t!==n&amp;&amp;(n=t,</span><span class="s0">this</span><span class="s1">.root.updateBlockedByResize=!</span><span class="s3">0</span><span class="s1">,i&amp;&amp;i(),i=</span><span class="s0">function</span><span class="s1">(t,e){</span><span class="s0">const </span><span class="s1">i=Rt.now(),n=({timestamp:s})=&gt;{</span><span class="s0">const </span><span class="s1">o=s-i;o&gt;=e&amp;&amp;(Vt(n),t(o-e))};</span><span class="s0">return </span><span class="s1">Et.setup(n,!</span><span class="s3">0</span><span class="s1">),()=&gt;Vt(n)}(s,</span><span class="s3">250</span><span class="s1">),Ws.hasAnimatedSinceResize&amp;&amp;(Ws.hasAnimatedSinceResize=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.nodes.forEach(io)))})}n&amp;&amp;</span><span class="s0">this</span><span class="s1">.root.registerSharedNode(n,</span><span class="s0">this</span><span class="s1">),!</span><span class="s3">1</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.options.animate&amp;&amp;o&amp;&amp;(n||s)&amp;&amp;</span><span class="s0">this</span><span class="s1">.addEventListener(</span><span class="s2">&quot;didUpdate&quot;</span><span class="s1">,({delta:t,hasLayoutChanged:e,hasRelativeLayoutChanged:i,layout:n})=&gt;{</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isTreeAnimationBlocked())</span><span class="s0">return this</span><span class="s1">.target=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">void</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.relativeTarget=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">);</span><span class="s0">const </span><span class="s1">s=</span><span class="s0">this</span><span class="s1">.options.transition||o.getDefaultTransition()||uo,{onLayoutAnimationStart:r,onLayoutAnimationComplete:a}=o.getProps(),l=!</span><span class="s0">this</span><span class="s1">.targetLayout||!Os(</span><span class="s0">this</span><span class="s1">.targetLayout,n),h=!e&amp;&amp;i;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.options.layoutRoot||</span><span class="s0">this</span><span class="s1">.resumeFrom||h||e&amp;&amp;(l||!</span><span class="s0">this</span><span class="s1">.currentAnimation)){</span><span class="s0">this</span><span class="s1">.resumeFrom&amp;&amp;(</span><span class="s0">this</span><span class="s1">.resumingFrom=</span><span class="s0">this</span><span class="s1">.resumeFrom,</span><span class="s0">this</span><span class="s1">.resumingFrom.resumingFrom=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">);</span><span class="s0">const </span><span class="s1">e={...Fi(s,</span><span class="s2">&quot;layout&quot;</span><span class="s1">),onPlay:r,onComplete:a};(o.shouldReduceMotion||</span><span class="s0">this</span><span class="s1">.options.layoutRoot)&amp;&amp;(e.delay=</span><span class="s3">0</span><span class="s1">,e.type=!</span><span class="s3">1</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.startAnimation(e),</span><span class="s0">this</span><span class="s1">.setAnimationOrigin(t,h)}</span><span class="s0">else </span><span class="s1">e||io(</span><span class="s0">this</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.isLead()&amp;&amp;</span><span class="s0">this</span><span class="s1">.options.onExitComplete&amp;&amp;</span><span class="s0">this</span><span class="s1">.options.onExitComplete();</span><span class="s0">this</span><span class="s1">.targetLayout=n})}unmount(){</span><span class="s0">this</span><span class="s1">.options.layoutId&amp;&amp;</span><span class="s0">this</span><span class="s1">.willUpdate(),</span><span class="s0">this</span><span class="s1">.root.nodes.remove(</span><span class="s0">this</span><span class="s1">);</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.getStack();t&amp;&amp;t.remove(</span><span class="s0">this</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.parent&amp;&amp;</span><span class="s0">this</span><span class="s1">.parent.children.delete(</span><span class="s0">this</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.instance=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.eventHandlers.clear(),Vt(</span><span class="s0">this</span><span class="s1">.updateProjection)}blockUpdate(){</span><span class="s0">this</span><span class="s1">.updateManuallyBlocked=!</span><span class="s3">0</span><span class="s1">}unblockUpdate(){</span><span class="s0">this</span><span class="s1">.updateManuallyBlocked=!</span><span class="s3">1</span><span class="s1">}isUpdateBlocked(){</span><span class="s0">return this</span><span class="s1">.updateManuallyBlocked||</span><span class="s0">this</span><span class="s1">.updateBlockedByResize}isTreeAnimationBlocked(){</span><span class="s0">return this</span><span class="s1">.isAnimationBlocked||</span><span class="s0">this</span><span class="s1">.parent&amp;&amp;</span><span class="s0">this</span><span class="s1">.parent.isTreeAnimationBlocked()||!</span><span class="s3">1</span><span class="s1">}startUpdate(){</span><span class="s0">this</span><span class="s1">.isUpdateBlocked()||(</span><span class="s0">this</span><span class="s1">.isUpdating=!</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.nodes&amp;&amp;</span><span class="s0">this</span><span class="s1">.nodes.forEach(oo),</span><span class="s0">this</span><span class="s1">.animationId++)}getTransformTemplate(){</span><span class="s0">const</span><span class="s1">{visualElement:t}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">return </span><span class="s1">t&amp;&amp;t.getProps().transformTemplate}willUpdate(t=!</span><span class="s3">0</span><span class="s1">){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.root.hasTreeAnimated=!</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.root.isUpdateBlocked())</span><span class="s0">return void</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.options.onExitComplete&amp;&amp;</span><span class="s0">this</span><span class="s1">.options.onExitComplete());</span><span class="s0">if</span><span class="s1">(window.MotionCancelOptimisedAnimation&amp;&amp;!</span><span class="s0">this</span><span class="s1">.hasCheckedOptimisedAppear&amp;&amp;Xs(</span><span class="s0">this</span><span class="s1">),!</span><span class="s0">this</span><span class="s1">.root.isUpdating&amp;&amp;</span><span class="s0">this</span><span class="s1">.root.startUpdate(),</span><span class="s0">this</span><span class="s1">.isLayoutDirty)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">this</span><span class="s1">.isLayoutDirty=!</span><span class="s3">0</span><span class="s1">;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">t=</span><span class="s3">0</span><span class="s1">;t&lt;</span><span class="s0">this</span><span class="s1">.path.length;t++){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.path[t];e.shouldResetTransform=!</span><span class="s3">0</span><span class="s1">,e.updateScroll(</span><span class="s2">&quot;snapshot&quot;</span><span class="s1">),e.options.layoutRoot&amp;&amp;e.willUpdate(!</span><span class="s3">1</span><span class="s1">)}</span><span class="s0">const</span><span class="s1">{layoutId:e,layout:i}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===e&amp;&amp;!i)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">this</span><span class="s1">.getTransformTemplate();</span><span class="s0">this</span><span class="s1">.prevTransformTemplateValue=n?n(</span><span class="s0">this</span><span class="s1">.latestValues,</span><span class="s2">&quot;&quot;</span><span class="s1">):</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.updateSnapshot(),t&amp;&amp;</span><span class="s0">this</span><span class="s1">.notifyListeners(</span><span class="s2">&quot;willUpdate&quot;</span><span class="s1">)}update(){</span><span class="s0">this</span><span class="s1">.updateScheduled=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isUpdateBlocked())</span><span class="s0">return this</span><span class="s1">.unblockUpdate(),</span><span class="s0">this</span><span class="s1">.clearAllSnapshots(),</span><span class="s0">void this</span><span class="s1">.nodes.forEach(Qs);</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.animationId&lt;=</span><span class="s0">this</span><span class="s1">.animationCommitId)</span><span class="s0">return void this</span><span class="s1">.nodes.forEach(to);</span><span class="s0">this</span><span class="s1">.animationCommitId=</span><span class="s0">this</span><span class="s1">.animationId,</span><span class="s0">this</span><span class="s1">.isUpdating?(</span><span class="s0">this</span><span class="s1">.isUpdating=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.nodes.forEach(eo),</span><span class="s0">this</span><span class="s1">.nodes.forEach(Gs),</span><span class="s0">this</span><span class="s1">.nodes.forEach(qs)):</span><span class="s0">this</span><span class="s1">.nodes.forEach(to),</span><span class="s0">this</span><span class="s1">.clearAllSnapshots();</span><span class="s0">const </span><span class="s1">t=Rt.now();Mt.delta=i(</span><span class="s3">0</span><span class="s1">,</span><span class="s3">1e3</span><span class="s1">/</span><span class="s3">60</span><span class="s1">,t-Mt.timestamp),Mt.timestamp=t,Mt.isProcessing=!</span><span class="s3">0</span><span class="s1">,Dt.update.process(Mt),Dt.preRender.process(Mt),Dt.render.process(Mt),Mt.isProcessing=!</span><span class="s3">1</span><span class="s1">}didUpdate(){</span><span class="s0">this</span><span class="s1">.updateScheduled||(</span><span class="s0">this</span><span class="s1">.updateScheduled=!</span><span class="s3">0</span><span class="s1">,Qi.read(</span><span class="s0">this</span><span class="s1">.scheduleUpdate))}clearAllSnapshots(){</span><span class="s0">this</span><span class="s1">.nodes.forEach(Js),</span><span class="s0">this</span><span class="s1">.sharedNodes.forEach(ro)}scheduleUpdateProjection(){</span><span class="s0">this</span><span class="s1">.projectionUpdateScheduled||(</span><span class="s0">this</span><span class="s1">.projectionUpdateScheduled=!</span><span class="s3">0</span><span class="s1">,Et.preRender(</span><span class="s0">this</span><span class="s1">.updateProjection,!</span><span class="s3">1</span><span class="s1">,!</span><span class="s3">0</span><span class="s1">))}scheduleCheckAfterUnmount(){Et.postRender(()=&gt;{</span><span class="s0">this</span><span class="s1">.isLayoutDirty?</span><span class="s0">this</span><span class="s1">.root.didUpdate():</span><span class="s0">this</span><span class="s1">.root.checkUpdateFailed()})}updateSnapshot(){!</span><span class="s0">this</span><span class="s1">.snapshot&amp;&amp;</span><span class="s0">this</span><span class="s1">.instance&amp;&amp;(</span><span class="s0">this</span><span class="s1">.snapshot=</span><span class="s0">this</span><span class="s1">.measure(),!</span><span class="s0">this</span><span class="s1">.snapshot||Vn(</span><span class="s0">this</span><span class="s1">.snapshot.measuredBox.x)||Vn(</span><span class="s0">this</span><span class="s1">.snapshot.measuredBox.y)||(</span><span class="s0">this</span><span class="s1">.snapshot=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">))}updateLayout(){</span><span class="s0">if</span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.instance)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.updateScroll(),!(</span><span class="s0">this</span><span class="s1">.options.alwaysMeasureLayout&amp;&amp;</span><span class="s0">this</span><span class="s1">.isLead()||</span><span class="s0">this</span><span class="s1">.isLayoutDirty))</span><span class="s0">return</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.resumeFrom&amp;&amp;!</span><span class="s0">this</span><span class="s1">.resumeFrom.instance)</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">t=</span><span class="s3">0</span><span class="s1">;t&lt;</span><span class="s0">this</span><span class="s1">.path.length;t++){</span><span class="s0">this</span><span class="s1">.path[t].updateScroll()}</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.layout;</span><span class="s0">this</span><span class="s1">.layout=</span><span class="s0">this</span><span class="s1">.measure(!</span><span class="s3">1</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.layoutCorrected={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}},</span><span class="s0">this</span><span class="s1">.isLayoutDirty=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.projectionDelta=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.notifyListeners(</span><span class="s2">&quot;measure&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.layout.layoutBox);</span><span class="s0">const</span><span class="s1">{visualElement:e}=</span><span class="s0">this</span><span class="s1">.options;e&amp;&amp;e.notify(</span><span class="s2">&quot;LayoutMeasure&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.layout.layoutBox,t?t.layoutBox:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">)}updateScroll(t=</span><span class="s2">&quot;measure&quot;</span><span class="s1">){</span><span class="s0">let </span><span class="s1">e=Boolean(</span><span class="s0">this</span><span class="s1">.options.layoutScroll&amp;&amp;</span><span class="s0">this</span><span class="s1">.instance);</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.scroll&amp;&amp;</span><span class="s0">this</span><span class="s1">.scroll.animationId===</span><span class="s0">this</span><span class="s1">.root.animationId&amp;&amp;</span><span class="s0">this</span><span class="s1">.scroll.phase===t&amp;&amp;(e=!</span><span class="s3">1</span><span class="s1">),e&amp;&amp;</span><span class="s0">this</span><span class="s1">.instance){</span><span class="s0">const </span><span class="s1">e=o(</span><span class="s0">this</span><span class="s1">.instance);</span><span class="s0">this</span><span class="s1">.scroll={animationId:</span><span class="s0">this</span><span class="s1">.root.animationId,phase:t,isRoot:e,offset:s(</span><span class="s0">this</span><span class="s1">.instance),wasRoot:</span><span class="s0">this</span><span class="s1">.scroll?</span><span class="s0">this</span><span class="s1">.scroll.isRoot:e}}}resetTransform(){</span><span class="s0">if</span><span class="s1">(!r)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.isLayoutDirty||</span><span class="s0">this</span><span class="s1">.shouldResetTransform||</span><span class="s0">this</span><span class="s1">.options.alwaysMeasureLayout,e=</span><span class="s0">this</span><span class="s1">.projectionDelta&amp;&amp;!Bs(</span><span class="s0">this</span><span class="s1">.projectionDelta),i=</span><span class="s0">this</span><span class="s1">.getTransformTemplate(),n=i?i(</span><span class="s0">this</span><span class="s1">.latestValues,</span><span class="s2">&quot;&quot;</span><span class="s1">):</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,s=n!==</span><span class="s0">this</span><span class="s1">.prevTransformTemplateValue;t&amp;&amp;</span><span class="s0">this</span><span class="s1">.instance&amp;&amp;(e||In(</span><span class="s0">this</span><span class="s1">.latestValues)||s)&amp;&amp;(r(</span><span class="s0">this</span><span class="s1">.instance,n),</span><span class="s0">this</span><span class="s1">.shouldResetTransform=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.scheduleRender())}measure(t=!</span><span class="s3">0</span><span class="s1">){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.measurePageBox();</span><span class="s0">let </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">.removeElementScroll(e);</span><span class="s0">var </span><span class="s1">n;</span><span class="s0">return </span><span class="s1">t&amp;&amp;(i=</span><span class="s0">this</span><span class="s1">.removeTransform(i)),mo((n=i).x),mo(n.y),{animationId:</span><span class="s0">this</span><span class="s1">.root.animationId,measuredBox:e,layoutBox:i,latestValues:{},source:</span><span class="s0">this</span><span class="s1">.id}}measurePageBox(){</span><span class="s0">const</span><span class="s1">{visualElement:t}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">if</span><span class="s1">(!t)</span><span class="s0">return</span><span class="s1">{x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}};</span><span class="s0">const </span><span class="s1">e=t.measureViewportBox();</span><span class="s0">if</span><span class="s1">(!(</span><span class="s0">this</span><span class="s1">.scroll?.wasRoot||</span><span class="s0">this</span><span class="s1">.path.some(yo))){</span><span class="s0">const</span><span class="s1">{scroll:t}=</span><span class="s0">this</span><span class="s1">.root;t&amp;&amp;(Xn(e.x,t.offset.x),Xn(e.y,t.offset.y))}</span><span class="s0">return </span><span class="s1">e}removeElementScroll(t){</span><span class="s0">const </span><span class="s1">e={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}};</span><span class="s0">if</span><span class="s1">(Vs(e,t),</span><span class="s0">this</span><span class="s1">.scroll?.wasRoot)</span><span class="s0">return </span><span class="s1">e;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">i=</span><span class="s3">0</span><span class="s1">;i&lt;</span><span class="s0">this</span><span class="s1">.path.length;i++){</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">this</span><span class="s1">.path[i],{scroll:s,options:o}=n;n!==</span><span class="s0">this</span><span class="s1">.root&amp;&amp;s&amp;&amp;o.layoutScroll&amp;&amp;(s.wasRoot&amp;&amp;Vs(e,t),Xn(e.x,s.offset.x),Xn(e.y,s.offset.y))}</span><span class="s0">return </span><span class="s1">e}applyTransform(t,e=!</span><span class="s3">1</span><span class="s1">){</span><span class="s0">const </span><span class="s1">i={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}};Vs(i,t);</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">t=</span><span class="s3">0</span><span class="s1">;t&lt;</span><span class="s0">this</span><span class="s1">.path.length;t++){</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">this</span><span class="s1">.path[t];!e&amp;&amp;n.options.layoutScroll&amp;&amp;n.scroll&amp;&amp;n!==n.root&amp;&amp;Gn(i,{x:-n.scroll.offset.x,y:-n.scroll.offset.y}),In(n.latestValues)&amp;&amp;Gn(i,n.latestValues)}</span><span class="s0">return </span><span class="s1">In(</span><span class="s0">this</span><span class="s1">.latestValues)&amp;&amp;Gn(i,</span><span class="s0">this</span><span class="s1">.latestValues),i}removeTransform(t){</span><span class="s0">const </span><span class="s1">e={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}};Vs(e,t);</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">t=</span><span class="s3">0</span><span class="s1">;t&lt;</span><span class="s0">this</span><span class="s1">.path.length;t++){</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">.path[t];</span><span class="s0">if</span><span class="s1">(!i.instance)</span><span class="s0">continue</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(!In(i.latestValues))</span><span class="s0">continue</span><span class="s1">;Fn(i.latestValues)&amp;&amp;i.updateSnapshot();</span><span class="s0">const </span><span class="s1">n=Ln();Vs(n,i.measurePageBox()),Ls(e,i.latestValues,i.snapshot?i.snapshot.layoutBox:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,n)}</span><span class="s0">return </span><span class="s1">In(</span><span class="s0">this</span><span class="s1">.latestValues)&amp;&amp;Ls(e,</span><span class="s0">this</span><span class="s1">.latestValues),e}setTargetDelta(t){</span><span class="s0">this</span><span class="s1">.targetDelta=t,</span><span class="s0">this</span><span class="s1">.root.scheduleUpdateProjection(),</span><span class="s0">this</span><span class="s1">.isProjectionDirty=!</span><span class="s3">0</span><span class="s1">}setOptions(t){</span><span class="s0">this</span><span class="s1">.options={...</span><span class="s0">this</span><span class="s1">.options,...t,crossfade:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===t.crossfade||t.crossfade}}clearMeasurements(){</span><span class="s0">this</span><span class="s1">.scroll=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.layout=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.snapshot=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.prevTransformTemplateValue=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.targetDelta=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.target=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isLayoutDirty=!</span><span class="s3">1</span><span class="s1">}forceRelativeParentToResolveTarget(){</span><span class="s0">this</span><span class="s1">.relativeParent&amp;&amp;</span><span class="s0">this</span><span class="s1">.relativeParent.resolvedRelativeTargetAt!==Mt.timestamp&amp;&amp;</span><span class="s0">this</span><span class="s1">.relativeParent.resolveTargetDelta(!</span><span class="s3">0</span><span class="s1">)}resolveTargetDelta(t=!</span><span class="s3">1</span><span class="s1">){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.getLead();</span><span class="s0">this</span><span class="s1">.isProjectionDirty||(</span><span class="s0">this</span><span class="s1">.isProjectionDirty=e.isProjectionDirty),</span><span class="s0">this</span><span class="s1">.isTransformDirty||(</span><span class="s0">this</span><span class="s1">.isTransformDirty=e.isTransformDirty),</span><span class="s0">this</span><span class="s1">.isSharedProjectionDirty||(</span><span class="s0">this</span><span class="s1">.isSharedProjectionDirty=e.isSharedProjectionDirty);</span><span class="s0">const </span><span class="s1">i=Boolean(</span><span class="s0">this</span><span class="s1">.resumingFrom)||</span><span class="s0">this</span><span class="s1">!==e;</span><span class="s0">if</span><span class="s1">(!(t||i&amp;&amp;</span><span class="s0">this</span><span class="s1">.isSharedProjectionDirty||</span><span class="s0">this</span><span class="s1">.isProjectionDirty||</span><span class="s0">this</span><span class="s1">.parent?.isProjectionDirty||</span><span class="s0">this</span><span class="s1">.attemptToResolveRelativeTarget||</span><span class="s0">this</span><span class="s1">.root.updateBlockedByResize))</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{layout:n,layoutId:s}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.layout&amp;&amp;(n||s)){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.resolvedRelativeTargetAt=Mt.timestamp,!</span><span class="s0">this</span><span class="s1">.targetDelta&amp;&amp;!</span><span class="s0">this</span><span class="s1">.relativeTarget){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.getClosestProjectingParent();t&amp;&amp;t.layout&amp;&amp;</span><span class="s3">1</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.animationProgress?(</span><span class="s0">this</span><span class="s1">.relativeParent=t,</span><span class="s0">this</span><span class="s1">.forceRelativeParentToResolveTarget(),</span><span class="s0">this</span><span class="s1">.relativeTarget={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}},</span><span class="s0">this</span><span class="s1">.relativeTargetOrigin={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}},Rn(</span><span class="s0">this</span><span class="s1">.relativeTargetOrigin,</span><span class="s0">this</span><span class="s1">.layout.layoutBox,t.layout.layoutBox),Vs(</span><span class="s0">this</span><span class="s1">.relativeTarget,</span><span class="s0">this</span><span class="s1">.relativeTargetOrigin)):</span><span class="s0">this</span><span class="s1">.relativeParent=</span><span class="s0">this</span><span class="s1">.relativeTarget=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}</span><span class="s0">var </span><span class="s1">o,r,a;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.relativeTarget||</span><span class="s0">this</span><span class="s1">.targetDelta)</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.target||(</span><span class="s0">this</span><span class="s1">.target={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}},</span><span class="s0">this</span><span class="s1">.targetWithTransforms={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}}),</span><span class="s0">this</span><span class="s1">.relativeTarget&amp;&amp;</span><span class="s0">this</span><span class="s1">.relativeTargetOrigin&amp;&amp;</span><span class="s0">this</span><span class="s1">.relativeParent&amp;&amp;</span><span class="s0">this</span><span class="s1">.relativeParent.target?(</span><span class="s0">this</span><span class="s1">.forceRelativeParentToResolveTarget(),o=</span><span class="s0">this</span><span class="s1">.target,r=</span><span class="s0">this</span><span class="s1">.relativeTarget,a=</span><span class="s0">this</span><span class="s1">.relativeParent.target,Cn(o.x,r.x,a.x),Cn(o.y,r.y,a.y)):</span><span class="s0">this</span><span class="s1">.targetDelta?(Boolean(</span><span class="s0">this</span><span class="s1">.resumingFrom)?</span><span class="s0">this</span><span class="s1">.target=</span><span class="s0">this</span><span class="s1">.applyTransform(</span><span class="s0">this</span><span class="s1">.layout.layoutBox):Vs(</span><span class="s0">this</span><span class="s1">.target,</span><span class="s0">this</span><span class="s1">.layout.layoutBox),$n(</span><span class="s0">this</span><span class="s1">.target,</span><span class="s0">this</span><span class="s1">.targetDelta)):Vs(</span><span class="s0">this</span><span class="s1">.target,</span><span class="s0">this</span><span class="s1">.layout.layoutBox),</span><span class="s0">this</span><span class="s1">.attemptToResolveRelativeTarget){</span><span class="s0">this</span><span class="s1">.attemptToResolveRelativeTarget=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.getClosestProjectingParent();t&amp;&amp;Boolean(t.resumingFrom)===Boolean(</span><span class="s0">this</span><span class="s1">.resumingFrom)&amp;&amp;!t.options.layoutScroll&amp;&amp;t.target&amp;&amp;</span><span class="s3">1</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.animationProgress?(</span><span class="s0">this</span><span class="s1">.relativeParent=t,</span><span class="s0">this</span><span class="s1">.forceRelativeParentToResolveTarget(),</span><span class="s0">this</span><span class="s1">.relativeTarget={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}},</span><span class="s0">this</span><span class="s1">.relativeTargetOrigin={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}},Rn(</span><span class="s0">this</span><span class="s1">.relativeTargetOrigin,</span><span class="s0">this</span><span class="s1">.target,t.target),Vs(</span><span class="s0">this</span><span class="s1">.relativeTarget,</span><span class="s0">this</span><span class="s1">.relativeTargetOrigin)):</span><span class="s0">this</span><span class="s1">.relativeParent=</span><span class="s0">this</span><span class="s1">.relativeTarget=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}}}getClosestProjectingParent(){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.parent&amp;&amp;!Fn(</span><span class="s0">this</span><span class="s1">.parent.latestValues)&amp;&amp;!On(</span><span class="s0">this</span><span class="s1">.parent.latestValues))</span><span class="s0">return this</span><span class="s1">.parent.isProjecting()?</span><span class="s0">this</span><span class="s1">.parent:</span><span class="s0">this</span><span class="s1">.parent.getClosestProjectingParent()}isProjecting(){</span><span class="s0">return </span><span class="s1">Boolean((</span><span class="s0">this</span><span class="s1">.relativeTarget||</span><span class="s0">this</span><span class="s1">.targetDelta||</span><span class="s0">this</span><span class="s1">.options.layoutRoot)&amp;&amp;</span><span class="s0">this</span><span class="s1">.layout)}calcProjection(){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.getLead(),e=Boolean(</span><span class="s0">this</span><span class="s1">.resumingFrom)||</span><span class="s0">this</span><span class="s1">!==t;</span><span class="s0">let </span><span class="s1">i=!</span><span class="s3">0</span><span class="s1">;</span><span class="s0">if</span><span class="s1">((</span><span class="s0">this</span><span class="s1">.isProjectionDirty||</span><span class="s0">this</span><span class="s1">.parent?.isProjectionDirty)&amp;&amp;(i=!</span><span class="s3">1</span><span class="s1">),e&amp;&amp;(</span><span class="s0">this</span><span class="s1">.isSharedProjectionDirty||</span><span class="s0">this</span><span class="s1">.isTransformDirty)&amp;&amp;(i=!</span><span class="s3">1</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.resolvedRelativeTargetAt===Mt.timestamp&amp;&amp;(i=!</span><span class="s3">1</span><span class="s1">),i)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{layout:n,layoutId:s}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isTreeAnimating=Boolean(</span><span class="s0">this</span><span class="s1">.parent&amp;&amp;</span><span class="s0">this</span><span class="s1">.parent.isTreeAnimating||</span><span class="s0">this</span><span class="s1">.currentAnimation||</span><span class="s0">this</span><span class="s1">.pendingAnimation),</span><span class="s0">this</span><span class="s1">.isTreeAnimating||(</span><span class="s0">this</span><span class="s1">.targetDelta=</span><span class="s0">this</span><span class="s1">.relativeTarget=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">),!</span><span class="s0">this</span><span class="s1">.layout||!n&amp;&amp;!s)</span><span class="s0">return</span><span class="s1">;Vs(</span><span class="s0">this</span><span class="s1">.layoutCorrected,</span><span class="s0">this</span><span class="s1">.layout.layoutBox);</span><span class="s0">const </span><span class="s1">o=</span><span class="s0">this</span><span class="s1">.treeScale.x,r=</span><span class="s0">this</span><span class="s1">.treeScale.y;!</span><span class="s0">function</span><span class="s1">(t,e,i,n=!</span><span class="s3">1</span><span class="s1">){</span><span class="s0">const </span><span class="s1">s=i.length;</span><span class="s0">if</span><span class="s1">(!s)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">let </span><span class="s1">o,r;e.x=e.y=</span><span class="s3">1</span><span class="s1">;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">a=</span><span class="s3">0</span><span class="s1">;a&lt;s;a++){o=i[a],r=o.projectionDelta;</span><span class="s0">const</span><span class="s1">{visualElement:s}=o.options;s&amp;&amp;s.props.style&amp;&amp;</span><span class="s2">&quot;contents&quot;</span><span class="s1">===s.props.style.display||(n&amp;&amp;o.options.layoutScroll&amp;&amp;o.scroll&amp;&amp;o!==o.root&amp;&amp;Gn(t,{x:-o.scroll.offset.x,y:-o.scroll.offset.y}),r&amp;&amp;(e.x*=r.x.scale,e.y*=r.y.scale,$n(t,r)),n&amp;&amp;In(o.latestValues)&amp;&amp;Gn(t,o.latestValues))}e.x&lt;Yn&amp;&amp;e.x&gt;zn&amp;&amp;(e.x=</span><span class="s3">1</span><span class="s1">),e.y&lt;Yn&amp;&amp;e.y&gt;zn&amp;&amp;(e.y=</span><span class="s3">1</span><span class="s1">)}(</span><span class="s0">this</span><span class="s1">.layoutCorrected,</span><span class="s0">this</span><span class="s1">.treeScale,</span><span class="s0">this</span><span class="s1">.path,e),!t.layout||t.target||</span><span class="s3">1</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.treeScale.x&amp;&amp;</span><span class="s3">1</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.treeScale.y||(t.target=t.layout.layoutBox,t.targetWithTransforms={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}});</span><span class="s0">const</span><span class="s1">{target:a}=t;a?(</span><span class="s0">this</span><span class="s1">.projectionDelta&amp;&amp;</span><span class="s0">this</span><span class="s1">.prevProjectionDelta?(Ms(</span><span class="s0">this</span><span class="s1">.prevProjectionDelta.x,</span><span class="s0">this</span><span class="s1">.projectionDelta.x),Ms(</span><span class="s0">this</span><span class="s1">.prevProjectionDelta.y,</span><span class="s0">this</span><span class="s1">.projectionDelta.y)):</span><span class="s0">this</span><span class="s1">.createProjectionDeltas(),Dn(</span><span class="s0">this</span><span class="s1">.projectionDelta,</span><span class="s0">this</span><span class="s1">.layoutCorrected,a,</span><span class="s0">this</span><span class="s1">.latestValues),</span><span class="s0">this</span><span class="s1">.treeScale.x===o&amp;&amp;</span><span class="s0">this</span><span class="s1">.treeScale.y===r&amp;&amp;Ns(</span><span class="s0">this</span><span class="s1">.projectionDelta.x,</span><span class="s0">this</span><span class="s1">.prevProjectionDelta.x)&amp;&amp;Ns(</span><span class="s0">this</span><span class="s1">.projectionDelta.y,</span><span class="s0">this</span><span class="s1">.prevProjectionDelta.y)||(</span><span class="s0">this</span><span class="s1">.hasProjected=!</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.scheduleRender(),</span><span class="s0">this</span><span class="s1">.notifyListeners(</span><span class="s2">&quot;projectionUpdate&quot;</span><span class="s1">,a))):</span><span class="s0">this</span><span class="s1">.prevProjectionDelta&amp;&amp;(</span><span class="s0">this</span><span class="s1">.createProjectionDeltas(),</span><span class="s0">this</span><span class="s1">.scheduleRender())}hide(){</span><span class="s0">this</span><span class="s1">.isVisible=!</span><span class="s3">1</span><span class="s1">}show(){</span><span class="s0">this</span><span class="s1">.isVisible=!</span><span class="s3">0</span><span class="s1">}scheduleRender(t=!</span><span class="s3">0</span><span class="s1">){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.options.visualElement?.scheduleRender(),t){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.getStack();t&amp;&amp;t.scheduleRender()}</span><span class="s0">this</span><span class="s1">.resumingFrom&amp;&amp;!</span><span class="s0">this</span><span class="s1">.resumingFrom.instance&amp;&amp;(</span><span class="s0">this</span><span class="s1">.resumingFrom=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">)}createProjectionDeltas(){</span><span class="s0">this</span><span class="s1">.prevProjectionDelta={x:{translate:</span><span class="s3">0</span><span class="s1">,scale:</span><span class="s3">1</span><span class="s1">,origin:</span><span class="s3">0</span><span class="s1">,originPoint:</span><span class="s3">0</span><span class="s1">},y:{translate:</span><span class="s3">0</span><span class="s1">,scale:</span><span class="s3">1</span><span class="s1">,origin:</span><span class="s3">0</span><span class="s1">,originPoint:</span><span class="s3">0</span><span class="s1">}},</span><span class="s0">this</span><span class="s1">.projectionDelta={x:{translate:</span><span class="s3">0</span><span class="s1">,scale:</span><span class="s3">1</span><span class="s1">,origin:</span><span class="s3">0</span><span class="s1">,originPoint:</span><span class="s3">0</span><span class="s1">},y:{translate:</span><span class="s3">0</span><span class="s1">,scale:</span><span class="s3">1</span><span class="s1">,origin:</span><span class="s3">0</span><span class="s1">,originPoint:</span><span class="s3">0</span><span class="s1">}},</span><span class="s0">this</span><span class="s1">.projectionDeltaWithTransform={x:{translate:</span><span class="s3">0</span><span class="s1">,scale:</span><span class="s3">1</span><span class="s1">,origin:</span><span class="s3">0</span><span class="s1">,originPoint:</span><span class="s3">0</span><span class="s1">},y:{translate:</span><span class="s3">0</span><span class="s1">,scale:</span><span class="s3">1</span><span class="s1">,origin:</span><span class="s3">0</span><span class="s1">,originPoint:</span><span class="s3">0</span><span class="s1">}}}setAnimationOrigin(t,e=!</span><span class="s3">1</span><span class="s1">){</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">.snapshot,s=i?i.latestValues:{},o={...</span><span class="s0">this</span><span class="s1">.latestValues},r={x:{translate:</span><span class="s3">0</span><span class="s1">,scale:</span><span class="s3">1</span><span class="s1">,origin:</span><span class="s3">0</span><span class="s1">,originPoint:</span><span class="s3">0</span><span class="s1">},y:{translate:</span><span class="s3">0</span><span class="s1">,scale:</span><span class="s3">1</span><span class="s1">,origin:</span><span class="s3">0</span><span class="s1">,originPoint:</span><span class="s3">0</span><span class="s1">}};</span><span class="s0">this</span><span class="s1">.relativeParent&amp;&amp;</span><span class="s0">this</span><span class="s1">.relativeParent.options.layoutRoot||(</span><span class="s0">this</span><span class="s1">.relativeTarget=</span><span class="s0">this</span><span class="s1">.relativeTargetOrigin=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.attemptToResolveRelativeTarget=!e;</span><span class="s0">const </span><span class="s1">a={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}},l=(i?i.source:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">)!==(</span><span class="s0">this</span><span class="s1">.layout?</span><span class="s0">this</span><span class="s1">.layout.source:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">),h=</span><span class="s0">this</span><span class="s1">.getStack(),u=!h||h.members.length&lt;=</span><span class="s3">1</span><span class="s1">,c=Boolean(l&amp;&amp;!u&amp;&amp;!</span><span class="s3">0</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.options.crossfade&amp;&amp;!</span><span class="s0">this</span><span class="s1">.path.some(ho));</span><span class="s0">let </span><span class="s1">d;</span><span class="s0">this</span><span class="s1">.animationProgress=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.mixTargetDelta=e=&gt;{</span><span class="s0">const </span><span class="s1">i=e/</span><span class="s3">1e3</span><span class="s1">;</span><span class="s0">var </span><span class="s1">h,p,m,f,y,g;ao(r.x,t.x,i),ao(r.y,t.y,i),</span><span class="s0">this</span><span class="s1">.setTargetDelta(r),</span><span class="s0">this</span><span class="s1">.relativeTarget&amp;&amp;</span><span class="s0">this</span><span class="s1">.relativeTargetOrigin&amp;&amp;</span><span class="s0">this</span><span class="s1">.layout&amp;&amp;</span><span class="s0">this</span><span class="s1">.relativeParent&amp;&amp;</span><span class="s0">this</span><span class="s1">.relativeParent.layout&amp;&amp;(Rn(a,</span><span class="s0">this</span><span class="s1">.layout.layoutBox,</span><span class="s0">this</span><span class="s1">.relativeParent.layout.layoutBox),m=</span><span class="s0">this</span><span class="s1">.relativeTarget,f=</span><span class="s0">this</span><span class="s1">.relativeTargetOrigin,y=a,g=i,lo(m.x,f.x,y.x,g),lo(m.y,f.y,y.y,g),d&amp;&amp;(h=</span><span class="s0">this</span><span class="s1">.relativeTarget,p=d,Fs(h.x,p.x)&amp;&amp;Fs(h.y,p.y))&amp;&amp;(</span><span class="s0">this</span><span class="s1">.isProjectionDirty=!</span><span class="s3">1</span><span class="s1">),d||(d={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}}),Vs(d,</span><span class="s0">this</span><span class="s1">.relativeTarget)),l&amp;&amp;(</span><span class="s0">this</span><span class="s1">.animationValues=o,</span><span class="s0">function</span><span class="s1">(t,e,i,s,o,r){o?(t.opacity=te(</span><span class="s3">0</span><span class="s1">,i.opacity??</span><span class="s3">1</span><span class="s1">,Ss(s)),t.opacityExit=te(e.opacity??</span><span class="s3">1</span><span class="s1">,</span><span class="s3">0</span><span class="s1">,As(s))):r&amp;&amp;(t.opacity=te(e.opacity??</span><span class="s3">1</span><span class="s1">,i.opacity??</span><span class="s3">1</span><span class="s1">,s));</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">o=</span><span class="s3">0</span><span class="s1">;o&lt;xs;o++){</span><span class="s0">const </span><span class="s1">r=</span><span class="s2">`border</span><span class="s1">${vs[o]}</span><span class="s2">Radius`</span><span class="s1">;</span><span class="s0">let </span><span class="s1">a=ws(e,r),l=ws(i,r);</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===a&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===l||(a||(a=</span><span class="s3">0</span><span class="s1">),l||(l=</span><span class="s3">0</span><span class="s1">),</span><span class="s3">0</span><span class="s1">===a||</span><span class="s3">0</span><span class="s1">===l||Ps(a)===Ps(l)?(t[r]=Math.max(te(Ts(a),Ts(l),s),</span><span class="s3">0</span><span class="s1">),(n.test(l)||n.test(a))&amp;&amp;(t[r]+=</span><span class="s2">&quot;%&quot;</span><span class="s1">)):t[r]=l)}(e.rotate||i.rotate)&amp;&amp;(t.rotate=te(e.rotate||</span><span class="s3">0</span><span class="s1">,i.rotate||</span><span class="s3">0</span><span class="s1">,s))}(o,s,</span><span class="s0">this</span><span class="s1">.latestValues,i,c,u)),</span><span class="s0">this</span><span class="s1">.root.scheduleUpdateProjection(),</span><span class="s0">this</span><span class="s1">.scheduleRender(),</span><span class="s0">this</span><span class="s1">.animationProgress=i},</span><span class="s0">this</span><span class="s1">.mixTargetDelta(</span><span class="s0">this</span><span class="s1">.options.layoutRoot?</span><span class="s3">1e3</span><span class="s1">:</span><span class="s3">0</span><span class="s1">)}startAnimation(t){</span><span class="s0">this</span><span class="s1">.notifyListeners(</span><span class="s2">&quot;animationStart&quot;</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.currentAnimation?.stop(),</span><span class="s0">this</span><span class="s1">.resumingFrom?.currentAnimation?.stop(),</span><span class="s0">this</span><span class="s1">.pendingAnimation&amp;&amp;(Vt(</span><span class="s0">this</span><span class="s1">.pendingAnimation),</span><span class="s0">this</span><span class="s1">.pendingAnimation=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.pendingAnimation=Et.update(()=&gt;{Ws.hasAnimatedSinceResize=!</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.motionValue||(</span><span class="s0">this</span><span class="s1">.motionValue=Ji(</span><span class="s3">0</span><span class="s1">)),</span><span class="s0">this</span><span class="s1">.currentAnimation=</span><span class="s0">function</span><span class="s1">(t,e,i){</span><span class="s0">const </span><span class="s1">n=d(t)?t:Ji(t);</span><span class="s0">return </span><span class="s1">n.start(wn(</span><span class="s2">&quot;&quot;</span><span class="s1">,n,e,i)),n.animation}(</span><span class="s0">this</span><span class="s1">.motionValue,[</span><span class="s3">0</span><span class="s1">,</span><span class="s3">1e3</span><span class="s1">],{...t,velocity:</span><span class="s3">0</span><span class="s1">,isSync:!</span><span class="s3">0</span><span class="s1">,onUpdate:e=&gt;{</span><span class="s0">this</span><span class="s1">.mixTargetDelta(e),t.onUpdate&amp;&amp;t.onUpdate(e)},onStop:()=&gt;{},onComplete:()=&gt;{t.onComplete&amp;&amp;t.onComplete(),</span><span class="s0">this</span><span class="s1">.completeAnimation()}}),</span><span class="s0">this</span><span class="s1">.resumingFrom&amp;&amp;(</span><span class="s0">this</span><span class="s1">.resumingFrom.currentAnimation=</span><span class="s0">this</span><span class="s1">.currentAnimation),</span><span class="s0">this</span><span class="s1">.pendingAnimation=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">})}completeAnimation(){</span><span class="s0">this</span><span class="s1">.resumingFrom&amp;&amp;(</span><span class="s0">this</span><span class="s1">.resumingFrom.currentAnimation=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.resumingFrom.preserveOpacity=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">);</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.getStack();t&amp;&amp;t.exitAnimationComplete(),</span><span class="s0">this</span><span class="s1">.resumingFrom=</span><span class="s0">this</span><span class="s1">.currentAnimation=</span><span class="s0">this</span><span class="s1">.animationValues=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.notifyListeners(</span><span class="s2">&quot;animationComplete&quot;</span><span class="s1">)}finishAnimation(){</span><span class="s0">this</span><span class="s1">.currentAnimation&amp;&amp;(</span><span class="s0">this</span><span class="s1">.mixTargetDelta&amp;&amp;</span><span class="s0">this</span><span class="s1">.mixTargetDelta(</span><span class="s3">1e3</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.currentAnimation.stop()),</span><span class="s0">this</span><span class="s1">.completeAnimation()}applyTransformsToTarget(){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.getLead();</span><span class="s0">let</span><span class="s1">{targetWithTransforms:e,target:i,layout:n,latestValues:s}=t;</span><span class="s0">if</span><span class="s1">(e&amp;&amp;i&amp;&amp;n){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">!==t&amp;&amp;</span><span class="s0">this</span><span class="s1">.layout&amp;&amp;n&amp;&amp;fo(</span><span class="s0">this</span><span class="s1">.options.animationType,</span><span class="s0">this</span><span class="s1">.layout.layoutBox,n.layoutBox)){i=</span><span class="s0">this</span><span class="s1">.target||{x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}};</span><span class="s0">const </span><span class="s1">e=Vn(</span><span class="s0">this</span><span class="s1">.layout.layoutBox.x);i.x.min=t.target.x.min,i.x.max=i.x.min+e;</span><span class="s0">const </span><span class="s1">n=Vn(</span><span class="s0">this</span><span class="s1">.layout.layoutBox.y);i.y.min=t.target.y.min,i.y.max=i.y.min+n}Vs(e,i),Gn(e,s),Dn(</span><span class="s0">this</span><span class="s1">.projectionDeltaWithTransform,</span><span class="s0">this</span><span class="s1">.layoutCorrected,e,s)}}registerSharedNode(t,e){</span><span class="s0">this</span><span class="s1">.sharedNodes.has(t)||</span><span class="s0">this</span><span class="s1">.sharedNodes.set(t,</span><span class="s0">new </span><span class="s1">Ks);</span><span class="s0">this</span><span class="s1">.sharedNodes.get(t).add(e);</span><span class="s0">const </span><span class="s1">i=e.options.initialPromotionConfig;e.promote({transition:i?i.transition:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,preserveFollowOpacity:i&amp;&amp;i.shouldPreserveFollowOpacity?i.shouldPreserveFollowOpacity(e):</span><span class="s0">void </span><span class="s3">0</span><span class="s1">})}isLead(){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.getStack();</span><span class="s0">return</span><span class="s1">!t||t.lead===</span><span class="s0">this</span><span class="s1">}getLead(){</span><span class="s0">const</span><span class="s1">{layoutId:t}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">return </span><span class="s1">t&amp;&amp;</span><span class="s0">this</span><span class="s1">.getStack()?.lead||</span><span class="s0">this</span><span class="s1">}getPrevLead(){</span><span class="s0">const</span><span class="s1">{layoutId:t}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">return </span><span class="s1">t?</span><span class="s0">this</span><span class="s1">.getStack()?.prevLead:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}getStack(){</span><span class="s0">const</span><span class="s1">{layoutId:t}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">if</span><span class="s1">(t)</span><span class="s0">return this</span><span class="s1">.root.sharedNodes.get(t)}promote({needsReset:t,transition:e,preserveFollowOpacity:i}={}){</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">this</span><span class="s1">.getStack();n&amp;&amp;n.promote(</span><span class="s0">this</span><span class="s1">,i),t&amp;&amp;(</span><span class="s0">this</span><span class="s1">.projectionDelta=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.needsReset=!</span><span class="s3">0</span><span class="s1">),e&amp;&amp;</span><span class="s0">this</span><span class="s1">.setOptions({transition:e})}relegate(){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.getStack();</span><span class="s0">return</span><span class="s1">!!t&amp;&amp;t.relegate(</span><span class="s0">this</span><span class="s1">)}resetSkewAndRotation(){</span><span class="s0">const</span><span class="s1">{visualElement:t}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">if</span><span class="s1">(!t)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">let </span><span class="s1">e=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{latestValues:i}=t;</span><span class="s0">if</span><span class="s1">((i.z||i.rotate||i.rotateX||i.rotateY||i.rotateZ||i.skewX||i.skewY)&amp;&amp;(e=!</span><span class="s3">0</span><span class="s1">),!e)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">n={};i.z&amp;&amp;Ys(</span><span class="s2">&quot;z&quot;</span><span class="s1">,t,n,</span><span class="s0">this</span><span class="s1">.animationValues);</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">0</span><span class="s1">;e&lt;$s.length;e++)Ys(</span><span class="s2">`rotate</span><span class="s1">${$s[e]}</span><span class="s2">`</span><span class="s1">,t,n,</span><span class="s0">this</span><span class="s1">.animationValues),Ys(</span><span class="s2">`skew</span><span class="s1">${$s[e]}</span><span class="s2">`</span><span class="s1">,t,n,</span><span class="s0">this</span><span class="s1">.animationValues);t.render();</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">e </span><span class="s0">in </span><span class="s1">n)t.setStaticValue(e,n[e]),</span><span class="s0">this</span><span class="s1">.animationValues&amp;&amp;(</span><span class="s0">this</span><span class="s1">.animationValues[e]=n[e]);t.scheduleRender()}applyProjectionStyles(t,e){</span><span class="s0">if</span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.instance||</span><span class="s0">this</span><span class="s1">.isSVG)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.isVisible)</span><span class="s0">return void</span><span class="s1">(t.visibility=</span><span class="s2">&quot;hidden&quot;</span><span class="s1">);</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">.getTransformTemplate();</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.needsReset)</span><span class="s0">return this</span><span class="s1">.needsReset=!</span><span class="s3">1</span><span class="s1">,t.visibility=</span><span class="s2">&quot;&quot;</span><span class="s1">,t.opacity=</span><span class="s2">&quot;&quot;</span><span class="s1">,t.pointerEvents=f(e?.pointerEvents)||</span><span class="s2">&quot;&quot;</span><span class="s1">,</span><span class="s0">void</span><span class="s1">(t.transform=i?i(</span><span class="s0">this</span><span class="s1">.latestValues,</span><span class="s2">&quot;&quot;</span><span class="s1">):</span><span class="s2">&quot;none&quot;</span><span class="s1">);</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">this</span><span class="s1">.getLead();</span><span class="s0">if</span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.projectionDelta||!</span><span class="s0">this</span><span class="s1">.layout||!n.target)</span><span class="s0">return this</span><span class="s1">.options.layoutId&amp;&amp;(t.opacity=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.latestValues.opacity?</span><span class="s0">this</span><span class="s1">.latestValues.opacity:</span><span class="s3">1</span><span class="s1">,t.pointerEvents=f(e?.pointerEvents)||</span><span class="s2">&quot;&quot;</span><span class="s1">),</span><span class="s0">void</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.hasProjected&amp;&amp;!In(</span><span class="s0">this</span><span class="s1">.latestValues)&amp;&amp;(t.transform=i?i({},</span><span class="s2">&quot;&quot;</span><span class="s1">):</span><span class="s2">&quot;none&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.hasProjected=!</span><span class="s3">1</span><span class="s1">));t.visibility=</span><span class="s2">&quot;&quot;</span><span class="s1">;</span><span class="s0">const </span><span class="s1">s=n.animationValues||n.latestValues;</span><span class="s0">this</span><span class="s1">.applyTransformsToTarget();</span><span class="s0">let </span><span class="s1">o=</span><span class="s0">function</span><span class="s1">(t,e,i){</span><span class="s0">let </span><span class="s1">n=</span><span class="s2">&quot;&quot;</span><span class="s1">;</span><span class="s0">const </span><span class="s1">s=t.x.translate/e.x,o=t.y.translate/e.y,r=i?.z||</span><span class="s3">0</span><span class="s1">;</span><span class="s0">if</span><span class="s1">((s||o||r)&amp;&amp;(n=</span><span class="s2">`translate3d(</span><span class="s1">${s}</span><span class="s2">px, </span><span class="s1">${o}</span><span class="s2">px, </span><span class="s1">${r}</span><span class="s2">px) `</span><span class="s1">),</span><span class="s3">1</span><span class="s1">===e.x&amp;&amp;</span><span class="s3">1</span><span class="s1">===e.y||(n+=</span><span class="s2">`scale(</span><span class="s1">${</span><span class="s3">1</span><span class="s1">/e.x}</span><span class="s2">, </span><span class="s1">${</span><span class="s3">1</span><span class="s1">/e.y}</span><span class="s2">) `</span><span class="s1">),i){</span><span class="s0">const</span><span class="s1">{transformPerspective:t,rotate:e,rotateX:s,rotateY:o,skewX:r,skewY:a}=i;t&amp;&amp;(n=</span><span class="s2">`perspective(</span><span class="s1">${t}</span><span class="s2">px) </span><span class="s1">${n}</span><span class="s2">`</span><span class="s1">),e&amp;&amp;(n+=</span><span class="s2">`rotate(</span><span class="s1">${e}</span><span class="s2">deg) `</span><span class="s1">),s&amp;&amp;(n+=</span><span class="s2">`rotateX(</span><span class="s1">${s}</span><span class="s2">deg) `</span><span class="s1">),o&amp;&amp;(n+=</span><span class="s2">`rotateY(</span><span class="s1">${o}</span><span class="s2">deg) `</span><span class="s1">),r&amp;&amp;(n+=</span><span class="s2">`skewX(</span><span class="s1">${r}</span><span class="s2">deg) `</span><span class="s1">),a&amp;&amp;(n+=</span><span class="s2">`skewY(</span><span class="s1">${a}</span><span class="s2">deg) `</span><span class="s1">)}</span><span class="s0">const </span><span class="s1">a=t.x.scale*e.x,l=t.y.scale*e.y;</span><span class="s0">return </span><span class="s3">1</span><span class="s1">===a&amp;&amp;</span><span class="s3">1</span><span class="s1">===l||(n+=</span><span class="s2">`scale(</span><span class="s1">${a}</span><span class="s2">, </span><span class="s1">${l}</span><span class="s2">)`</span><span class="s1">),n||</span><span class="s2">&quot;none&quot;</span><span class="s1">}(</span><span class="s0">this</span><span class="s1">.projectionDeltaWithTransform,</span><span class="s0">this</span><span class="s1">.treeScale,s);i&amp;&amp;(o=i(s,o)),t.transform=o;</span><span class="s0">const</span><span class="s1">{x:r,y:a}=</span><span class="s0">this</span><span class="s1">.projectionDelta;t.transformOrigin=</span><span class="s2">`</span><span class="s1">${</span><span class="s3">100</span><span class="s1">*r.origin}</span><span class="s2">% </span><span class="s1">${</span><span class="s3">100</span><span class="s1">*a.origin}</span><span class="s2">% 0`</span><span class="s1">,n.animationValues?t.opacity=n===</span><span class="s0">this</span><span class="s1">?s.opacity??</span><span class="s0">this</span><span class="s1">.latestValues.opacity??</span><span class="s3">1</span><span class="s1">:</span><span class="s0">this</span><span class="s1">.preserveOpacity?</span><span class="s0">this</span><span class="s1">.latestValues.opacity:s.opacityExit:t.opacity=n===</span><span class="s0">this</span><span class="s1">?</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==s.opacity?s.opacity:</span><span class="s2">&quot;&quot;</span><span class="s1">:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==s.opacityExit?s.opacityExit:</span><span class="s3">0</span><span class="s1">;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">e </span><span class="s0">in </span><span class="s1">y){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===s[e])</span><span class="s0">continue</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{correct:i,applyTo:r,isCSSVariable:a}=y[e],l=</span><span class="s2">&quot;none&quot;</span><span class="s1">===o?s[e]:i(s[e],n);</span><span class="s0">if</span><span class="s1">(r){</span><span class="s0">const </span><span class="s1">e=r.length;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">i=</span><span class="s3">0</span><span class="s1">;i&lt;e;i++)t[r[i]]=l}</span><span class="s0">else </span><span class="s1">a?</span><span class="s0">this</span><span class="s1">.options.visualElement.renderState.vars[e]=l:t[e]=l}</span><span class="s0">this</span><span class="s1">.options.layoutId&amp;&amp;(t.pointerEvents=n===</span><span class="s0">this</span><span class="s1">?f(e?.pointerEvents)||</span><span class="s2">&quot;&quot;</span><span class="s1">:</span><span class="s2">&quot;none&quot;</span><span class="s1">)}clearSnapshot(){</span><span class="s0">this</span><span class="s1">.resumeFrom=</span><span class="s0">this</span><span class="s1">.snapshot=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}resetTree(){</span><span class="s0">this</span><span class="s1">.root.nodes.forEach(t=&gt;t.currentAnimation?.stop()),</span><span class="s0">this</span><span class="s1">.root.nodes.forEach(Qs),</span><span class="s0">this</span><span class="s1">.root.sharedNodes.clear()}}}</span><span class="s0">function </span><span class="s1">Gs(t){t.updateLayout()}</span><span class="s0">function </span><span class="s1">qs(t){</span><span class="s0">const </span><span class="s1">e=t.resumeFrom?.snapshot||t.snapshot;</span><span class="s0">if</span><span class="s1">(t.isLead()&amp;&amp;t.layout&amp;&amp;e&amp;&amp;t.hasListeners(</span><span class="s2">&quot;didUpdate&quot;</span><span class="s1">)){</span><span class="s0">const</span><span class="s1">{layoutBox:i,measuredBox:n}=t.layout,{animationType:s}=t.options,o=e.source!==t.layout.source;</span><span class="s2">&quot;size&quot;</span><span class="s1">===s?jn(t=&gt;{</span><span class="s0">const </span><span class="s1">n=o?e.measuredBox[t]:e.layoutBox[t],s=Vn(n);n.min=i[t].min,n.max=n.min+s}):fo(s,e.layoutBox,i)&amp;&amp;jn(n=&gt;{</span><span class="s0">const </span><span class="s1">s=o?e.measuredBox[n]:e.layoutBox[n],r=Vn(i[n]);s.max=s.min+r,t.relativeTarget&amp;&amp;!t.currentAnimation&amp;&amp;(t.isProjectionDirty=!</span><span class="s3">0</span><span class="s1">,t.relativeTarget[n].max=t.relativeTarget[n].min+r)});</span><span class="s0">const </span><span class="s1">r={x:{translate:</span><span class="s3">0</span><span class="s1">,scale:</span><span class="s3">1</span><span class="s1">,origin:</span><span class="s3">0</span><span class="s1">,originPoint:</span><span class="s3">0</span><span class="s1">},y:{translate:</span><span class="s3">0</span><span class="s1">,scale:</span><span class="s3">1</span><span class="s1">,origin:</span><span class="s3">0</span><span class="s1">,originPoint:</span><span class="s3">0</span><span class="s1">}};Dn(r,i,e.layoutBox);</span><span class="s0">const </span><span class="s1">a={x:{translate:</span><span class="s3">0</span><span class="s1">,scale:</span><span class="s3">1</span><span class="s1">,origin:</span><span class="s3">0</span><span class="s1">,originPoint:</span><span class="s3">0</span><span class="s1">},y:{translate:</span><span class="s3">0</span><span class="s1">,scale:</span><span class="s3">1</span><span class="s1">,origin:</span><span class="s3">0</span><span class="s1">,originPoint:</span><span class="s3">0</span><span class="s1">}};o?Dn(a,t.applyTransform(n,!</span><span class="s3">0</span><span class="s1">),e.measuredBox):Dn(a,i,e.layoutBox);</span><span class="s0">const </span><span class="s1">l=!Bs(r);</span><span class="s0">let </span><span class="s1">h=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(!t.resumeFrom){</span><span class="s0">const </span><span class="s1">n=t.getClosestProjectingParent();</span><span class="s0">if</span><span class="s1">(n&amp;&amp;!n.resumeFrom){</span><span class="s0">const</span><span class="s1">{snapshot:s,layout:o}=n;</span><span class="s0">if</span><span class="s1">(s&amp;&amp;o){</span><span class="s0">const </span><span class="s1">r={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}};Rn(r,e.layoutBox,s.layoutBox);</span><span class="s0">const </span><span class="s1">a={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}};Rn(a,i,o.layoutBox),Os(r,a)||(h=!</span><span class="s3">0</span><span class="s1">),n.options.layoutRoot&amp;&amp;(t.relativeTarget=a,t.relativeTargetOrigin=r,t.relativeParent=n)}}}t.notifyListeners(</span><span class="s2">&quot;didUpdate&quot;</span><span class="s1">,{layout:i,snapshot:e,delta:a,layoutDelta:r,hasLayoutChanged:l,hasRelativeLayoutChanged:h})}</span><span class="s0">else if</span><span class="s1">(t.isLead()){</span><span class="s0">const</span><span class="s1">{onExitComplete:e}=t.options;e&amp;&amp;e()}t.options.transition=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}</span><span class="s0">function </span><span class="s1">_s(t){t.parent&amp;&amp;(t.isProjecting()||(t.isProjectionDirty=t.parent.isProjectionDirty),t.isSharedProjectionDirty||(t.isSharedProjectionDirty=Boolean(t.isProjectionDirty||t.parent.isProjectionDirty||t.parent.isSharedProjectionDirty)),t.isTransformDirty||(t.isTransformDirty=t.parent.isTransformDirty))}</span><span class="s0">function </span><span class="s1">Zs(t){t.isProjectionDirty=t.isSharedProjectionDirty=t.isTransformDirty=!</span><span class="s3">1</span><span class="s1">}</span><span class="s0">function </span><span class="s1">Js(t){t.clearSnapshot()}</span><span class="s0">function </span><span class="s1">Qs(t){t.clearMeasurements()}</span><span class="s0">function </span><span class="s1">to(t){t.isLayoutDirty=!</span><span class="s3">1</span><span class="s1">}</span><span class="s0">function </span><span class="s1">eo(t){</span><span class="s0">const</span><span class="s1">{visualElement:e}=t.options;e&amp;&amp;e.getProps().onBeforeLayoutMeasure&amp;&amp;e.notify(</span><span class="s2">&quot;BeforeLayoutMeasure&quot;</span><span class="s1">),t.resetTransform()}</span><span class="s0">function </span><span class="s1">io(t){t.finishAnimation(),t.targetDelta=t.relativeTarget=t.target=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,t.isProjectionDirty=!</span><span class="s3">0</span><span class="s1">}</span><span class="s0">function </span><span class="s1">no(t){t.resolveTargetDelta()}</span><span class="s0">function </span><span class="s1">so(t){t.calcProjection()}</span><span class="s0">function </span><span class="s1">oo(t){t.resetSkewAndRotation()}</span><span class="s0">function </span><span class="s1">ro(t){t.removeLeadSnapshot()}</span><span class="s0">function </span><span class="s1">ao(t,e,i){t.translate=te(e.translate,</span><span class="s3">0</span><span class="s1">,i),t.scale=te(e.scale,</span><span class="s3">1</span><span class="s1">,i),t.origin=e.origin,t.originPoint=e.originPoint}</span><span class="s0">function </span><span class="s1">lo(t,e,i,n){t.min=te(e.min,i.min,n),t.max=te(e.max,i.max,n)}</span><span class="s0">function </span><span class="s1">ho(t){</span><span class="s0">return </span><span class="s1">t.animationValues&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==t.animationValues.opacityExit}</span><span class="s0">const </span><span class="s1">uo={duration:</span><span class="s3">.45</span><span class="s1">,ease:[</span><span class="s3">.4</span><span class="s1">,</span><span class="s3">0</span><span class="s1">,</span><span class="s3">.1</span><span class="s1">,</span><span class="s3">1</span><span class="s1">]},co=t=&gt;</span><span class="s2">&quot;undefined&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">navigator&amp;&amp;navigator.userAgent&amp;&amp;navigator.userAgent.toLowerCase().includes(t),po=co(</span><span class="s2">&quot;applewebkit/&quot;</span><span class="s1">)&amp;&amp;!co(</span><span class="s2">&quot;chrome/&quot;</span><span class="s1">)?Math.round:J;</span><span class="s0">function </span><span class="s1">mo(t){t.min=po(t.min),t.max=po(t.max)}</span><span class="s0">function </span><span class="s1">fo(t,e,i){</span><span class="s0">return</span><span class="s2">&quot;position&quot;</span><span class="s1">===t||</span><span class="s2">&quot;preserve-aspect&quot;</span><span class="s1">===t&amp;&amp;(n=Us(e),s=Us(i),o=</span><span class="s3">.2</span><span class="s1">,!(Math.abs(n-s)&lt;=o));</span><span class="s0">var </span><span class="s1">n,s,o}</span><span class="s0">function </span><span class="s1">yo(t){</span><span class="s0">return </span><span class="s1">t!==t.root&amp;&amp;t.scroll?.wasRoot}</span><span class="s0">const </span><span class="s1">go=Hs({attachResizeListener:(t,e)=&gt;Sn(t,</span><span class="s2">&quot;resize&quot;</span><span class="s1">,e),measureScroll:()=&gt;({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=&gt;!</span><span class="s3">0</span><span class="s1">}),vo={current:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">},xo=Hs({measureScroll:t=&gt;({x:t.scrollLeft,y:t.scrollTop}),defaultParent:()=&gt;{</span><span class="s0">if</span><span class="s1">(!vo.current){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">new </span><span class="s1">go({});t.mount(window),t.setOptions({layoutScroll:!</span><span class="s3">0</span><span class="s1">}),vo.current=t}</span><span class="s0">return </span><span class="s1">vo.current},resetTransform:(t,e)=&gt;{t.style.transform=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==e?e:</span><span class="s2">&quot;none&quot;</span><span class="s1">},checkIsScrollRoot:t=&gt;Boolean(</span><span class="s2">&quot;fixed&quot;</span><span class="s1">===window.getComputedStyle(t).position)});</span><span class="s0">function </span><span class="s1">To(t,e){</span><span class="s0">return </span><span class="s1">e.max===e.min?</span><span class="s3">0</span><span class="s1">:t/(e.max-e.min)*</span><span class="s3">100</span><span class="s1">}</span><span class="s0">const </span><span class="s1">Po={correct:(t,e)=&gt;{</span><span class="s0">if</span><span class="s1">(!e.target)</span><span class="s0">return </span><span class="s1">t;</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t){</span><span class="s0">if</span><span class="s1">(!o.test(t))</span><span class="s0">return </span><span class="s1">t;t=parseFloat(t)}</span><span class="s0">return</span><span class="s2">`</span><span class="s1">${To(t,e.target.x)}</span><span class="s2">% </span><span class="s1">${To(t,e.target.y)}</span><span class="s2">%`</span><span class="s1">}},wo={correct:(t,{treeScale:e,projectionDelta:i})=&gt;{</span><span class="s0">const </span><span class="s1">n=t,s=Zt.parse(t);</span><span class="s0">if</span><span class="s1">(s.length&gt;</span><span class="s3">5</span><span class="s1">)</span><span class="s0">return </span><span class="s1">n;</span><span class="s0">const </span><span class="s1">o=Zt.createTransformer(t),r=</span><span class="s2">&quot;number&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">s[</span><span class="s3">0</span><span class="s1">]?</span><span class="s3">1</span><span class="s1">:</span><span class="s3">0</span><span class="s1">,a=i.x.scale*e.x,l=i.y.scale*e.y;s[</span><span class="s3">0</span><span class="s1">+r]/=a,s[</span><span class="s3">1</span><span class="s1">+r]/=l;</span><span class="s0">const </span><span class="s1">h=te(a,l,</span><span class="s3">.5</span><span class="s1">);</span><span class="s0">return</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">s[</span><span class="s3">2</span><span class="s1">+r]&amp;&amp;(s[</span><span class="s3">2</span><span class="s1">+r]/=h),</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">s[</span><span class="s3">3</span><span class="s1">+r]&amp;&amp;(s[</span><span class="s3">3</span><span class="s1">+r]/=h),o(s)}},So={current:</span><span class="s0">null</span><span class="s1">},Ao={current:!</span><span class="s3">1</span><span class="s1">};</span><span class="s0">const </span><span class="s1">bo=</span><span class="s0">new </span><span class="s1">WeakMap;</span><span class="s0">const </span><span class="s1">Eo=[</span><span class="s2">&quot;AnimationStart&quot;</span><span class="s1">,</span><span class="s2">&quot;AnimationComplete&quot;</span><span class="s1">,</span><span class="s2">&quot;Update&quot;</span><span class="s1">,</span><span class="s2">&quot;BeforeLayoutMeasure&quot;</span><span class="s1">,</span><span class="s2">&quot;LayoutMeasure&quot;</span><span class="s1">,</span><span class="s2">&quot;LayoutAnimationStart&quot;</span><span class="s1">,</span><span class="s2">&quot;LayoutAnimationComplete&quot;</span><span class="s1">];</span><span class="s0">class </span><span class="s1">Vo{scrapeMotionValuesFromProps(t,e,i){</span><span class="s0">return</span><span class="s1">{}}constructor({parent:t,props:e,presenceContext:i,reducedMotionConfig:n,blockInitialAnimation:s,visualState:o},r={}){</span><span class="s0">this</span><span class="s1">.current=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.children=</span><span class="s0">new </span><span class="s1">Set,</span><span class="s0">this</span><span class="s1">.isVariantNode=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isControllingVariants=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.shouldReduceMotion=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.values=</span><span class="s0">new </span><span class="s1">Map,</span><span class="s0">this</span><span class="s1">.KeyframeResolver=fi,</span><span class="s0">this</span><span class="s1">.features={},</span><span class="s0">this</span><span class="s1">.valueSubscriptions=</span><span class="s0">new </span><span class="s1">Map,</span><span class="s0">this</span><span class="s1">.prevMotionValues={},</span><span class="s0">this</span><span class="s1">.events={},</span><span class="s0">this</span><span class="s1">.propEventSubscriptions={},</span><span class="s0">this</span><span class="s1">.notifyUpdate=()=&gt;</span><span class="s0">this</span><span class="s1">.notify(</span><span class="s2">&quot;Update&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.latestValues),</span><span class="s0">this</span><span class="s1">.render=()=&gt;{</span><span class="s0">this</span><span class="s1">.current&amp;&amp;(</span><span class="s0">this</span><span class="s1">.triggerBuild(),</span><span class="s0">this</span><span class="s1">.renderInstance(</span><span class="s0">this</span><span class="s1">.current,</span><span class="s0">this</span><span class="s1">.renderState,</span><span class="s0">this</span><span class="s1">.props.style,</span><span class="s0">this</span><span class="s1">.projection))},</span><span class="s0">this</span><span class="s1">.renderScheduledAt=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.scheduleRender=()=&gt;{</span><span class="s0">const </span><span class="s1">t=Rt.now();</span><span class="s0">this</span><span class="s1">.renderScheduledAt&lt;t&amp;&amp;(</span><span class="s0">this</span><span class="s1">.renderScheduledAt=t,Et.render(</span><span class="s0">this</span><span class="s1">.render,!</span><span class="s3">1</span><span class="s1">,!</span><span class="s3">0</span><span class="s1">))};</span><span class="s0">const</span><span class="s1">{latestValues:a,renderState:l}=o;</span><span class="s0">this</span><span class="s1">.latestValues=a,</span><span class="s0">this</span><span class="s1">.baseTarget={...a},</span><span class="s0">this</span><span class="s1">.initialValues=e.initial?{...a}:{},</span><span class="s0">this</span><span class="s1">.renderState=l,</span><span class="s0">this</span><span class="s1">.parent=t,</span><span class="s0">this</span><span class="s1">.props=e,</span><span class="s0">this</span><span class="s1">.presenceContext=i,</span><span class="s0">this</span><span class="s1">.depth=t?t.depth+</span><span class="s3">1</span><span class="s1">:</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.reducedMotionConfig=n,</span><span class="s0">this</span><span class="s1">.options=r,</span><span class="s0">this</span><span class="s1">.blockInitialAnimation=Boolean(s),</span><span class="s0">this</span><span class="s1">.isControllingVariants=v(e),</span><span class="s0">this</span><span class="s1">.isVariantNode=x(e),</span><span class="s0">this</span><span class="s1">.isVariantNode&amp;&amp;(</span><span class="s0">this</span><span class="s1">.variantChildren=</span><span class="s0">new </span><span class="s1">Set),</span><span class="s0">this</span><span class="s1">.manuallyAnimateOnMount=Boolean(t&amp;&amp;t.current);</span><span class="s0">const</span><span class="s1">{willChange:h,...u}=</span><span class="s0">this</span><span class="s1">.scrapeMotionValuesFromProps(e,{},</span><span class="s0">this</span><span class="s1">);</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">t </span><span class="s0">in </span><span class="s1">u){</span><span class="s0">const </span><span class="s1">e=u[t];</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==a[t]&amp;&amp;d(e)&amp;&amp;e.set(a[t])}}mount(t){</span><span class="s0">this</span><span class="s1">.current=t,bo.set(t,</span><span class="s0">this</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.projection&amp;&amp;!</span><span class="s0">this</span><span class="s1">.projection.instance&amp;&amp;</span><span class="s0">this</span><span class="s1">.projection.mount(t),</span><span class="s0">this</span><span class="s1">.parent&amp;&amp;</span><span class="s0">this</span><span class="s1">.isVariantNode&amp;&amp;!</span><span class="s0">this</span><span class="s1">.isControllingVariants&amp;&amp;(</span><span class="s0">this</span><span class="s1">.removeFromVariantTree=</span><span class="s0">this</span><span class="s1">.parent.addVariantChild(</span><span class="s0">this</span><span class="s1">)),</span><span class="s0">this</span><span class="s1">.values.forEach((t,e)=&gt;</span><span class="s0">this</span><span class="s1">.bindToMotionValue(e,t)),Ao.current||</span><span class="s0">function</span><span class="s1">(){</span><span class="s0">if</span><span class="s1">(Ao.current=!</span><span class="s3">0</span><span class="s1">,g)</span><span class="s0">if</span><span class="s1">(window.matchMedia){</span><span class="s0">const </span><span class="s1">t=window.matchMedia(</span><span class="s2">&quot;(prefers-reduced-motion)&quot;</span><span class="s1">),e=()=&gt;So.current=t.matches;t.addEventListener(</span><span class="s2">&quot;change&quot;</span><span class="s1">,e),e()}</span><span class="s0">else </span><span class="s1">So.current=!</span><span class="s3">1</span><span class="s1">}(),</span><span class="s0">this</span><span class="s1">.shouldReduceMotion=</span><span class="s2">&quot;never&quot;</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.reducedMotionConfig&amp;&amp;(</span><span class="s2">&quot;always&quot;</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.reducedMotionConfig||So.current),</span><span class="s0">this</span><span class="s1">.parent?.addChild(</span><span class="s0">this</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.update(</span><span class="s0">this</span><span class="s1">.props,</span><span class="s0">this</span><span class="s1">.presenceContext)}unmount(){</span><span class="s0">this</span><span class="s1">.projection&amp;&amp;</span><span class="s0">this</span><span class="s1">.projection.unmount(),Vt(</span><span class="s0">this</span><span class="s1">.notifyUpdate),Vt(</span><span class="s0">this</span><span class="s1">.render),</span><span class="s0">this</span><span class="s1">.valueSubscriptions.forEach(t=&gt;t()),</span><span class="s0">this</span><span class="s1">.valueSubscriptions.clear(),</span><span class="s0">this</span><span class="s1">.removeFromVariantTree&amp;&amp;</span><span class="s0">this</span><span class="s1">.removeFromVariantTree(),</span><span class="s0">this</span><span class="s1">.parent?.removeChild(</span><span class="s0">this</span><span class="s1">);</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">t </span><span class="s0">in this</span><span class="s1">.events)</span><span class="s0">this</span><span class="s1">.events[t].clear();</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">t </span><span class="s0">in this</span><span class="s1">.features){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.features[t];e&amp;&amp;(e.unmount(),e.isMounted=!</span><span class="s3">1</span><span class="s1">)}</span><span class="s0">this</span><span class="s1">.current=</span><span class="s0">null</span><span class="s1">}addChild(t){</span><span class="s0">this</span><span class="s1">.children.add(t),</span><span class="s0">this</span><span class="s1">.enteringChildren??(</span><span class="s0">this</span><span class="s1">.enteringChildren=</span><span class="s0">new </span><span class="s1">Set),</span><span class="s0">this</span><span class="s1">.enteringChildren.add(t)}removeChild(t){</span><span class="s0">this</span><span class="s1">.children.delete(t),</span><span class="s0">this</span><span class="s1">.enteringChildren&amp;&amp;</span><span class="s0">this</span><span class="s1">.enteringChildren.delete(t)}bindToMotionValue(t,e){</span><span class="s0">this</span><span class="s1">.valueSubscriptions.has(t)&amp;&amp;</span><span class="s0">this</span><span class="s1">.valueSubscriptions.get(t)();</span><span class="s0">const </span><span class="s1">i=c.has(t);i&amp;&amp;</span><span class="s0">this</span><span class="s1">.onBindTransform&amp;&amp;</span><span class="s0">this</span><span class="s1">.onBindTransform();</span><span class="s0">const </span><span class="s1">n=e.on(</span><span class="s2">&quot;change&quot;</span><span class="s1">,e=&gt;{</span><span class="s0">this</span><span class="s1">.latestValues[t]=e,</span><span class="s0">this</span><span class="s1">.props.onUpdate&amp;&amp;Et.preRender(</span><span class="s0">this</span><span class="s1">.notifyUpdate),i&amp;&amp;</span><span class="s0">this</span><span class="s1">.projection&amp;&amp;(</span><span class="s0">this</span><span class="s1">.projection.isTransformDirty=!</span><span class="s3">0</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.scheduleRender()});</span><span class="s0">let </span><span class="s1">s;window.MotionCheckAppearSync&amp;&amp;(s=window.MotionCheckAppearSync(</span><span class="s0">this</span><span class="s1">,t,e)),</span><span class="s0">this</span><span class="s1">.valueSubscriptions.set(t,()=&gt;{n(),s&amp;&amp;s(),e.owner&amp;&amp;e.stop()})}sortNodePosition(t){</span><span class="s0">return this</span><span class="s1">.current&amp;&amp;</span><span class="s0">this</span><span class="s1">.sortInstanceNodePosition&amp;&amp;</span><span class="s0">this</span><span class="s1">.type===t.type?</span><span class="s0">this</span><span class="s1">.sortInstanceNodePosition(</span><span class="s0">this</span><span class="s1">.current,t.current):</span><span class="s3">0</span><span class="s1">}updateFeatures(){</span><span class="s0">let </span><span class="s1">t=</span><span class="s2">&quot;animation&quot;</span><span class="s1">;</span><span class="s0">for</span><span class="s1">(t </span><span class="s0">in </span><span class="s1">T){</span><span class="s0">const </span><span class="s1">e=T[t];</span><span class="s0">if</span><span class="s1">(!e)</span><span class="s0">continue</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{isEnabled:i,Feature:n}=e;</span><span class="s0">if</span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.features[t]&amp;&amp;n&amp;&amp;i(</span><span class="s0">this</span><span class="s1">.props)&amp;&amp;(</span><span class="s0">this</span><span class="s1">.features[t]=</span><span class="s0">new </span><span class="s1">n(</span><span class="s0">this</span><span class="s1">)),</span><span class="s0">this</span><span class="s1">.features[t]){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.features[t];e.isMounted?e.update():(e.mount(),e.isMounted=!</span><span class="s3">0</span><span class="s1">)}}}triggerBuild(){</span><span class="s0">this</span><span class="s1">.build(</span><span class="s0">this</span><span class="s1">.renderState,</span><span class="s0">this</span><span class="s1">.latestValues,</span><span class="s0">this</span><span class="s1">.props)}measureViewportBox(){</span><span class="s0">return this</span><span class="s1">.current?</span><span class="s0">this</span><span class="s1">.measureInstanceViewportBox(</span><span class="s0">this</span><span class="s1">.current,</span><span class="s0">this</span><span class="s1">.props):{x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}}}getStaticValue(t){</span><span class="s0">return this</span><span class="s1">.latestValues[t]}setStaticValue(t,e){</span><span class="s0">this</span><span class="s1">.latestValues[t]=e}update(t,e){(t.transformTemplate||</span><span class="s0">this</span><span class="s1">.props.transformTemplate)&amp;&amp;</span><span class="s0">this</span><span class="s1">.scheduleRender(),</span><span class="s0">this</span><span class="s1">.prevProps=</span><span class="s0">this</span><span class="s1">.props,</span><span class="s0">this</span><span class="s1">.props=t,</span><span class="s0">this</span><span class="s1">.prevPresenceContext=</span><span class="s0">this</span><span class="s1">.presenceContext,</span><span class="s0">this</span><span class="s1">.presenceContext=e;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">0</span><span class="s1">;e&lt;Eo.length;e++){</span><span class="s0">const </span><span class="s1">i=Eo[e];</span><span class="s0">this</span><span class="s1">.propEventSubscriptions[i]&amp;&amp;(</span><span class="s0">this</span><span class="s1">.propEventSubscriptions[i](),</span><span class="s0">delete this</span><span class="s1">.propEventSubscriptions[i]);</span><span class="s0">const </span><span class="s1">n=t[</span><span class="s2">&quot;on&quot;</span><span class="s1">+i];n&amp;&amp;(</span><span class="s0">this</span><span class="s1">.propEventSubscriptions[i]=</span><span class="s0">this</span><span class="s1">.on(i,n))}</span><span class="s0">this</span><span class="s1">.prevMotionValues=</span><span class="s0">function</span><span class="s1">(t,e,i){</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">n </span><span class="s0">in </span><span class="s1">e){</span><span class="s0">const </span><span class="s1">s=e[n],o=i[n];</span><span class="s0">if</span><span class="s1">(d(s))t.addValue(n,s);</span><span class="s0">else if</span><span class="s1">(d(o))t.addValue(n,Ji(s,{owner:t}));</span><span class="s0">else if</span><span class="s1">(o!==s)</span><span class="s0">if</span><span class="s1">(t.hasValue(n)){</span><span class="s0">const </span><span class="s1">e=t.getValue(n);!</span><span class="s3">0</span><span class="s1">===e.liveStyle?e.jump(s):e.hasAnimated||e.set(s)}</span><span class="s0">else</span><span class="s1">{</span><span class="s0">const </span><span class="s1">e=t.getStaticValue(n);t.addValue(n,Ji(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==e?e:s,{owner:t}))}}</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">n </span><span class="s0">in </span><span class="s1">i)</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===e[n]&amp;&amp;t.removeValue(n);</span><span class="s0">return </span><span class="s1">e}(</span><span class="s0">this</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.scrapeMotionValuesFromProps(t,</span><span class="s0">this</span><span class="s1">.prevProps,</span><span class="s0">this</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.prevMotionValues),</span><span class="s0">this</span><span class="s1">.handleChildMotionValue&amp;&amp;</span><span class="s0">this</span><span class="s1">.handleChildMotionValue()}getProps(){</span><span class="s0">return this</span><span class="s1">.props}getVariant(t){</span><span class="s0">return this</span><span class="s1">.props.variants?</span><span class="s0">this</span><span class="s1">.props.variants[t]:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}getDefaultTransition(){</span><span class="s0">return this</span><span class="s1">.props.transition}getTransformPagePoint(){</span><span class="s0">return this</span><span class="s1">.props.transformPagePoint}getClosestVariantNode(){</span><span class="s0">return this</span><span class="s1">.isVariantNode?</span><span class="s0">this</span><span class="s1">:</span><span class="s0">this</span><span class="s1">.parent?</span><span class="s0">this</span><span class="s1">.parent.getClosestVariantNode():</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}addVariantChild(t){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.getClosestVariantNode();</span><span class="s0">if</span><span class="s1">(e)</span><span class="s0">return </span><span class="s1">e.variantChildren&amp;&amp;e.variantChildren.add(t),()=&gt;e.variantChildren.delete(t)}addValue(t,e){</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">.values.get(t);e!==i&amp;&amp;(i&amp;&amp;</span><span class="s0">this</span><span class="s1">.removeValue(t),</span><span class="s0">this</span><span class="s1">.bindToMotionValue(t,e),</span><span class="s0">this</span><span class="s1">.values.set(t,e),</span><span class="s0">this</span><span class="s1">.latestValues[t]=e.get())}removeValue(t){</span><span class="s0">this</span><span class="s1">.values.delete(t);</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.valueSubscriptions.get(t);e&amp;&amp;(e(),</span><span class="s0">this</span><span class="s1">.valueSubscriptions.delete(t)),</span><span class="s0">delete this</span><span class="s1">.latestValues[t],</span><span class="s0">this</span><span class="s1">.removeValueFromRenderState(t,</span><span class="s0">this</span><span class="s1">.renderState)}hasValue(t){</span><span class="s0">return this</span><span class="s1">.values.has(t)}getValue(t,e){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.props.values&amp;&amp;</span><span class="s0">this</span><span class="s1">.props.values[t])</span><span class="s0">return this</span><span class="s1">.props.values[t];</span><span class="s0">let </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">.values.get(t);</span><span class="s0">return void </span><span class="s3">0</span><span class="s1">===i&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==e&amp;&amp;(i=Ji(</span><span class="s0">null</span><span class="s1">===e?</span><span class="s0">void </span><span class="s3">0</span><span class="s1">:e,{owner:</span><span class="s0">this</span><span class="s1">}),</span><span class="s0">this</span><span class="s1">.addValue(t,i)),i}readValue(t,e){</span><span class="s0">let </span><span class="s1">i=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.latestValues[t]&amp;&amp;</span><span class="s0">this</span><span class="s1">.current?</span><span class="s0">this</span><span class="s1">.getBaseTargetFromProps(</span><span class="s0">this</span><span class="s1">.props,t)??</span><span class="s0">this</span><span class="s1">.readValueFromInstance(</span><span class="s0">this</span><span class="s1">.current,t,</span><span class="s0">this</span><span class="s1">.options):</span><span class="s0">this</span><span class="s1">.latestValues[t];</span><span class="s0">var </span><span class="s1">n;</span><span class="s0">return null</span><span class="s1">!=i&amp;&amp;(</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">i&amp;&amp;(G(i)||_(i))?i=parseFloat(i):(n=i,!fn.find(Oi(n))&amp;&amp;Zt.test(e)&amp;&amp;(i=Gi(t,e))),</span><span class="s0">this</span><span class="s1">.setBaseTarget(t,d(i)?i.get():i)),d(i)?i.get():i}setBaseTarget(t,e){</span><span class="s0">this</span><span class="s1">.baseTarget[t]=e}getBaseTarget(t){</span><span class="s0">const</span><span class="s1">{initial:e}=</span><span class="s0">this</span><span class="s1">.props;</span><span class="s0">let </span><span class="s1">i;</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e||</span><span class="s2">&quot;object&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e){</span><span class="s0">const </span><span class="s1">n=P(</span><span class="s0">this</span><span class="s1">.props,e,</span><span class="s0">this</span><span class="s1">.presenceContext?.custom);n&amp;&amp;(i=n[t])}</span><span class="s0">if</span><span class="s1">(e&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==i)</span><span class="s0">return </span><span class="s1">i;</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">this</span><span class="s1">.getBaseTargetFromProps(</span><span class="s0">this</span><span class="s1">.props,t);</span><span class="s0">return void </span><span class="s3">0</span><span class="s1">===n||d(n)?</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.initialValues[t]&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===i?</span><span class="s0">void </span><span class="s3">0</span><span class="s1">:</span><span class="s0">this</span><span class="s1">.baseTarget[t]:n}on(t,e){</span><span class="s0">return this</span><span class="s1">.events[t]||(</span><span class="s0">this</span><span class="s1">.events[t]=</span><span class="s0">new </span><span class="s1">it),</span><span class="s0">this</span><span class="s1">.events[t].add(e)}notify(t,...e){</span><span class="s0">this</span><span class="s1">.events[t]&amp;&amp;</span><span class="s0">this</span><span class="s1">.events[t].notify(...e)}scheduleRenderMicrotask(){Qi.render(</span><span class="s0">this</span><span class="s1">.render)}}</span><span class="s0">class </span><span class="s1">Mo </span><span class="s0">extends </span><span class="s1">Vo{constructor(){</span><span class="s0">super</span><span class="s1">(...arguments),</span><span class="s0">this</span><span class="s1">.KeyframeResolver=_i}sortInstanceNodePosition(t,e){</span><span class="s0">return </span><span class="s3">2</span><span class="s1">&amp;t.compareDocumentPosition(e)?</span><span class="s3">1</span><span class="s1">:-</span><span class="s3">1</span><span class="s1">}getBaseTargetFromProps(t,e){</span><span class="s0">return </span><span class="s1">t.style?t.style[e]:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}removeValueFromRenderState(t,{vars:e,style:i}){</span><span class="s0">delete </span><span class="s1">e[t],</span><span class="s0">delete </span><span class="s1">i[t]}handleChildMotionValue(){</span><span class="s0">this</span><span class="s1">.childSubscription&amp;&amp;(</span><span class="s0">this</span><span class="s1">.childSubscription(),</span><span class="s0">delete this</span><span class="s1">.childSubscription);</span><span class="s0">const</span><span class="s1">{children:t}=</span><span class="s0">this</span><span class="s1">.props;d(t)&amp;&amp;(</span><span class="s0">this</span><span class="s1">.childSubscription=t.on(</span><span class="s2">&quot;change&quot;</span><span class="s1">,t=&gt;{</span><span class="s0">this</span><span class="s1">.current&amp;&amp;(</span><span class="s0">this</span><span class="s1">.current.textContent=</span><span class="s2">`</span><span class="s1">${t}</span><span class="s2">`</span><span class="s1">)}))}}</span><span class="s0">function </span><span class="s1">Do(t,{style:e,vars:i},n,s){</span><span class="s0">const </span><span class="s1">o=t.style;</span><span class="s0">let </span><span class="s1">r;</span><span class="s0">for</span><span class="s1">(r </span><span class="s0">in </span><span class="s1">e)o[r]=e[r];</span><span class="s0">for</span><span class="s1">(r </span><span class="s0">in </span><span class="s1">s?.applyProjectionStyles(o,n),i)o.setProperty(r,i[r])}</span><span class="s0">class </span><span class="s1">Co </span><span class="s0">extends </span><span class="s1">Mo{constructor(){</span><span class="s0">super</span><span class="s1">(...arguments),</span><span class="s0">this</span><span class="s1">.type=</span><span class="s2">&quot;html&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.renderInstance=Do}readValueFromInstance(t,e){</span><span class="s0">if</span><span class="s1">(c.has(e))</span><span class="s0">return this</span><span class="s1">.projection?.isProjecting?ii(e):((t,e)=&gt;{</span><span class="s0">const</span><span class="s1">{transform:i=</span><span class="s2">&quot;none&quot;</span><span class="s1">}=getComputedStyle(t);</span><span class="s0">return </span><span class="s1">ni(i,e)})(t,e);{</span><span class="s0">const </span><span class="s1">n=(i=t,window.getComputedStyle(i)),s=(w(e)?n.getPropertyValue(e):n[e])||</span><span class="s3">0</span><span class="s1">;</span><span class="s0">return</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">s?s.trim():s}</span><span class="s0">var </span><span class="s1">i}measureInstanceViewportBox(t,{transformPagePoint:e}){</span><span class="s0">return </span><span class="s1">qn(t,e)}build(t,e,i){S(t,e,i.transformTemplate)}scrapeMotionValuesFromProps(t,e,i){</span><span class="s0">return </span><span class="s1">A(t,e,i)}}</span><span class="s0">let </span><span class="s1">ko=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">class </span><span class="s1">Ro </span><span class="s0">extends </span><span class="s1">${componentDidMount(){</span><span class="s0">const</span><span class="s1">{visualElement:t,layoutGroup:e,switchLayoutGroup:i,layoutId:n}=</span><span class="s0">this</span><span class="s1">.props,{projection:s}=t;M(jo),s&amp;&amp;(e.group&amp;&amp;e.group.add(s),i&amp;&amp;i.register&amp;&amp;n&amp;&amp;i.register(s),ko&amp;&amp;s.root.didUpdate(),s.addEventListener(</span><span class="s2">&quot;animationComplete&quot;</span><span class="s1">,()=&gt;{</span><span class="s0">this</span><span class="s1">.safeToRemove()}),s.setOptions({...s.options,onExitComplete:()=&gt;</span><span class="s0">this</span><span class="s1">.safeToRemove()})),Ws.hasEverUpdated=!</span><span class="s3">0</span><span class="s1">}getSnapshotBeforeUpdate(t){</span><span class="s0">const</span><span class="s1">{layoutDependency:e,visualElement:i,drag:n,isPresent:s}=</span><span class="s0">this</span><span class="s1">.props,{projection:o}=i;</span><span class="s0">return </span><span class="s1">o?(o.isPresent=s,ko=!</span><span class="s3">0</span><span class="s1">,n||t.layoutDependency!==e||</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===e||t.isPresent!==s?o.willUpdate():</span><span class="s0">this</span><span class="s1">.safeToRemove(),t.isPresent!==s&amp;&amp;(s?o.promote():o.relegate()||Et.postRender(()=&gt;{</span><span class="s0">const </span><span class="s1">t=o.getStack();t&amp;&amp;t.members.length||</span><span class="s0">this</span><span class="s1">.safeToRemove()})),</span><span class="s0">null</span><span class="s1">):</span><span class="s0">null</span><span class="s1">}componentDidUpdate(){</span><span class="s0">const</span><span class="s1">{projection:t}=</span><span class="s0">this</span><span class="s1">.props.visualElement;t&amp;&amp;(t.root.didUpdate(),Qi.postRender(()=&gt;{!t.currentAnimation&amp;&amp;t.isLead()&amp;&amp;</span><span class="s0">this</span><span class="s1">.safeToRemove()}))}componentWillUnmount(){</span><span class="s0">const</span><span class="s1">{visualElement:t,layoutGroup:e,switchLayoutGroup:i}=</span><span class="s0">this</span><span class="s1">.props,{projection:n}=t;ko=!</span><span class="s3">0</span><span class="s1">,n&amp;&amp;(n.scheduleCheckAfterUnmount(),e&amp;&amp;e.group&amp;&amp;e.group.remove(n),i&amp;&amp;i.deregister&amp;&amp;i.deregister(n))}safeToRemove(){</span><span class="s0">const</span><span class="s1">{safeToRemove:t}=</span><span class="s0">this</span><span class="s1">.props;t&amp;&amp;t()}render(){</span><span class="s0">return null</span><span class="s1">}}</span><span class="s0">function </span><span class="s1">Lo(t){</span><span class="s0">const</span><span class="s1">[e,i]=</span><span class="s0">function</span><span class="s1">(t=!</span><span class="s3">0</span><span class="s1">){</span><span class="s0">const </span><span class="s1">e=U(b);</span><span class="s0">if</span><span class="s1">(</span><span class="s0">null</span><span class="s1">===e)</span><span class="s0">return</span><span class="s1">[!</span><span class="s3">0</span><span class="s1">,</span><span class="s0">null</span><span class="s1">];</span><span class="s0">const</span><span class="s1">{isPresent:i,onExitComplete:n,register:s}=e,o=N();K(()=&gt;{</span><span class="s0">if</span><span class="s1">(t)</span><span class="s0">return </span><span class="s1">s(o)},[t]);</span><span class="s0">const </span><span class="s1">r=W(()=&gt;t&amp;&amp;n&amp;&amp;n(o),[o,n,t]);</span><span class="s0">return</span><span class="s1">!i&amp;&amp;n?[!</span><span class="s3">1</span><span class="s1">,r]:[!</span><span class="s3">0</span><span class="s1">]}(),n=U(E);</span><span class="s0">return </span><span class="s1">O(Ro,{...t,layoutGroup:n,switchLayoutGroup:U(V),isPresent:e,safeToRemove:i})}</span><span class="s0">const </span><span class="s1">jo={borderRadius:{...Po,applyTo:[</span><span class="s2">&quot;borderTopLeftRadius&quot;</span><span class="s1">,</span><span class="s2">&quot;borderTopRightRadius&quot;</span><span class="s1">,</span><span class="s2">&quot;borderBottomLeftRadius&quot;</span><span class="s1">,</span><span class="s2">&quot;borderBottomRightRadius&quot;</span><span class="s1">]},borderTopLeftRadius:Po,borderTopRightRadius:Po,borderBottomLeftRadius:Po,borderBottomRightRadius:Po,boxShadow:wo},Bo={pan:{Feature:</span><span class="s0">class extends </span><span class="s1">yn{constructor(){</span><span class="s0">super</span><span class="s1">(...arguments),</span><span class="s0">this</span><span class="s1">.removePointerDownListener=J}onPointerDown(t){</span><span class="s0">this</span><span class="s1">.session=</span><span class="s0">new </span><span class="s1">Qn(t,</span><span class="s0">this</span><span class="s1">.createPanHandlers(),{transformPagePoint:</span><span class="s0">this</span><span class="s1">.node.getTransformPagePoint(),contextWindow:_n(</span><span class="s0">this</span><span class="s1">.node)})}createPanHandlers(){</span><span class="s0">const</span><span class="s1">{onPanSessionStart:t,onPanStart:e,onPan:i,onPanEnd:n}=</span><span class="s0">this</span><span class="s1">.node.getProps();</span><span class="s0">return</span><span class="s1">{onSessionStart:ms(t),onStart:ms(e),onMove:i,onEnd:(t,e)=&gt;{</span><span class="s0">delete this</span><span class="s1">.session,n&amp;&amp;Et.postRender(()=&gt;n(t,e))}}}mount(){</span><span class="s0">this</span><span class="s1">.removePointerDownListener=bn(</span><span class="s0">this</span><span class="s1">.node.current,</span><span class="s2">&quot;pointerdown&quot;</span><span class="s1">,t=&gt;</span><span class="s0">this</span><span class="s1">.onPointerDown(t))}update(){</span><span class="s0">this</span><span class="s1">.session&amp;&amp;</span><span class="s0">this</span><span class="s1">.session.updateHandlers(</span><span class="s0">this</span><span class="s1">.createPanHandlers())}unmount(){</span><span class="s0">this</span><span class="s1">.removePointerDownListener(),</span><span class="s0">this</span><span class="s1">.session&amp;&amp;</span><span class="s0">this</span><span class="s1">.session.end()}}},drag:{Feature:</span><span class="s0">class extends </span><span class="s1">yn{constructor(t){</span><span class="s0">super</span><span class="s1">(t),</span><span class="s0">this</span><span class="s1">.removeGroupControls=J,</span><span class="s0">this</span><span class="s1">.removeListeners=J,</span><span class="s0">this</span><span class="s1">.controls=</span><span class="s0">new </span><span class="s1">ds(t)}mount(){</span><span class="s0">const</span><span class="s1">{dragControls:t}=</span><span class="s0">this</span><span class="s1">.node.getProps();t&amp;&amp;(</span><span class="s0">this</span><span class="s1">.removeGroupControls=t.subscribe(</span><span class="s0">this</span><span class="s1">.controls)),</span><span class="s0">this</span><span class="s1">.removeListeners=</span><span class="s0">this</span><span class="s1">.controls.addListeners()||J}unmount(){</span><span class="s0">this</span><span class="s1">.removeGroupControls(),</span><span class="s0">this</span><span class="s1">.removeListeners()}},ProjectionNode:xo,MeasureLayout:Lo}},Fo={layout:{ProjectionNode:xo,MeasureLayout:Lo}};</span><span class="s0">function </span><span class="s1">Io(t,e,i){</span><span class="s0">const </span><span class="s1">n=t.getProps();</span><span class="s0">return </span><span class="s1">P(n,e,</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==i?i:n.custom,t)}</span><span class="s0">const </span><span class="s1">Oo=t=&gt;Array.isArray(t);</span><span class="s0">function </span><span class="s1">Uo(t,e,i){t.hasValue(e)?t.getValue(e).set(i):t.addValue(e,Ji(i))}</span><span class="s0">function </span><span class="s1">No(t){</span><span class="s0">return </span><span class="s1">Oo(t)?t[t.length-</span><span class="s3">1</span><span class="s1">]||</span><span class="s3">0</span><span class="s1">:t}</span><span class="s0">function </span><span class="s1">Ko({protectedKeys:t,needsAnimating:e},i){</span><span class="s0">const </span><span class="s1">n=t.hasOwnProperty(i)&amp;&amp;!</span><span class="s3">0</span><span class="s1">!==e[i];</span><span class="s0">return </span><span class="s1">e[i]=!</span><span class="s3">1</span><span class="s1">,n}</span><span class="s0">function </span><span class="s1">Wo(t,e,{delay:i=</span><span class="s3">0</span><span class="s1">,transitionOverride:n,type:s}={}){</span><span class="s0">let</span><span class="s1">{transition:o=t.getDefaultTransition(),transitionEnd:r,...a}=e;n&amp;&amp;(o=n);</span><span class="s0">const </span><span class="s1">l=[],h=s&amp;&amp;t.animationState&amp;&amp;t.animationState.getState()[s];</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">e </span><span class="s0">in </span><span class="s1">a){</span><span class="s0">const </span><span class="s1">n=t.getValue(e,t.latestValues[e]??</span><span class="s0">null</span><span class="s1">),s=a[e];</span><span class="s0">if</span><span class="s1">(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===s||h&amp;&amp;Ko(h,e))</span><span class="s0">continue</span><span class="s1">;</span><span class="s0">const </span><span class="s1">r={delay:i,...Fi(o||{},e)},u=n.get();</span><span class="s0">if</span><span class="s1">(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==u&amp;&amp;!n.isAnimating&amp;&amp;!Array.isArray(s)&amp;&amp;s===u&amp;&amp;!r.velocity)</span><span class="s0">continue</span><span class="s1">;</span><span class="s0">let </span><span class="s1">c=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(window.MotionHandoffAnimation){</span><span class="s0">const </span><span class="s1">i=fs(t);</span><span class="s0">if</span><span class="s1">(i){</span><span class="s0">const </span><span class="s1">t=window.MotionHandoffAnimation(i,e,Et);</span><span class="s0">null</span><span class="s1">!==t&amp;&amp;(r.startTime=t,c=!</span><span class="s3">0</span><span class="s1">)}}Zn(t,e),n.start(wn(e,n,s,t.shouldReduceMotion&amp;&amp;Ii.has(e)?{type:!</span><span class="s3">1</span><span class="s1">}:r,t,c));</span><span class="s0">const </span><span class="s1">d=n.animation;d&amp;&amp;l.push(d)}</span><span class="s0">return </span><span class="s1">r&amp;&amp;Promise.all(l).then(()=&gt;{Et.update(()=&gt;{r&amp;&amp;</span><span class="s0">function</span><span class="s1">(t,e){</span><span class="s0">const </span><span class="s1">i=Io(t,e);</span><span class="s0">let</span><span class="s1">{transitionEnd:n={},transition:s={},...o}=i||{};o={...o,...n};</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">e </span><span class="s0">in </span><span class="s1">o)Uo(t,e,No(o[e]))}(t,r)})}),l}</span><span class="s0">function </span><span class="s1">$o(t,e,i,n=</span><span class="s3">0</span><span class="s1">,s=</span><span class="s3">1</span><span class="s1">){</span><span class="s0">const </span><span class="s1">o=Array.from(t).sort((t,e)=&gt;t.sortNodePosition(e)).indexOf(e),r=t.size,a=(r-</span><span class="s3">1</span><span class="s1">)*n;</span><span class="s0">return</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">i?i(o,r):</span><span class="s3">1</span><span class="s1">===s?o*n:a-o*n}</span><span class="s0">function </span><span class="s1">zo(t,e,i={}){</span><span class="s0">const </span><span class="s1">n=Io(t,e,</span><span class="s2">&quot;exit&quot;</span><span class="s1">===i.type?t.presenceContext?.custom:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">);</span><span class="s0">let</span><span class="s1">{transition:s=t.getDefaultTransition()||{}}=n||{};i.transitionOverride&amp;&amp;(s=i.transitionOverride);</span><span class="s0">const </span><span class="s1">o=n?()=&gt;Promise.all(Wo(t,n,i)):()=&gt;Promise.resolve(),r=t.variantChildren&amp;&amp;t.variantChildren.size?(n=</span><span class="s3">0</span><span class="s1">)=&gt;{</span><span class="s0">const</span><span class="s1">{delayChildren:o=</span><span class="s3">0</span><span class="s1">,staggerChildren:r,staggerDirection:a}=s;</span><span class="s0">return function</span><span class="s1">(t,e,i=</span><span class="s3">0</span><span class="s1">,n=</span><span class="s3">0</span><span class="s1">,s=</span><span class="s3">0</span><span class="s1">,o=</span><span class="s3">1</span><span class="s1">,r){</span><span class="s0">const </span><span class="s1">a=[];</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">l of t.variantChildren)l.notify(</span><span class="s2">&quot;AnimationStart&quot;</span><span class="s1">,e),a.push(zo(l,e,{...r,delay:i+(</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">n?</span><span class="s3">0</span><span class="s1">:n)+$o(t.variantChildren,l,n,s,o)}).then(()=&gt;l.notify(</span><span class="s2">&quot;AnimationComplete&quot;</span><span class="s1">,e)));</span><span class="s0">return </span><span class="s1">Promise.all(a)}(t,e,n,o,r,a,i)}:()=&gt;Promise.resolve(),{when:a}=s;</span><span class="s0">if</span><span class="s1">(a){</span><span class="s0">const</span><span class="s1">[t,e]=</span><span class="s2">&quot;beforeChildren&quot;</span><span class="s1">===a?[o,r]:[r,o];</span><span class="s0">return </span><span class="s1">t().then(()=&gt;e())}</span><span class="s0">return </span><span class="s1">Promise.all([o(),r(i.delay)])}</span><span class="s0">function </span><span class="s1">Yo(t,e){</span><span class="s0">if</span><span class="s1">(!Array.isArray(e))</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">const </span><span class="s1">i=e.length;</span><span class="s0">if</span><span class="s1">(i!==t.length)</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">n=</span><span class="s3">0</span><span class="s1">;n&lt;i;n++)</span><span class="s0">if</span><span class="s1">(e[n]!==t[n])</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">return</span><span class="s1">!</span><span class="s3">0</span><span class="s1">}</span><span class="s0">const </span><span class="s1">Xo=C.length;</span><span class="s0">function </span><span class="s1">Ho(t){</span><span class="s0">if</span><span class="s1">(!t)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(!t.isControllingVariants){</span><span class="s0">const </span><span class="s1">e=t.parent&amp;&amp;Ho(t.parent)||{};</span><span class="s0">return void </span><span class="s3">0</span><span class="s1">!==t.props.initial&amp;&amp;(e.initial=t.props.initial),e}</span><span class="s0">const </span><span class="s1">e={};</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">i=</span><span class="s3">0</span><span class="s1">;i&lt;Xo;i++){</span><span class="s0">const </span><span class="s1">n=C[i],s=t.props[n];(D(s)||!</span><span class="s3">1</span><span class="s1">===s)&amp;&amp;(e[n]=s)}</span><span class="s0">return </span><span class="s1">e}</span><span class="s0">const </span><span class="s1">Go=[...R].reverse(),qo=R.length;</span><span class="s0">function </span><span class="s1">_o(t){</span><span class="s0">return </span><span class="s1">e=&gt;Promise.all(e.map(({animation:e,options:i})=&gt;</span><span class="s0">function</span><span class="s1">(t,e,i={}){</span><span class="s0">let </span><span class="s1">n;</span><span class="s0">if</span><span class="s1">(t.notify(</span><span class="s2">&quot;AnimationStart&quot;</span><span class="s1">,e),Array.isArray(e)){</span><span class="s0">const </span><span class="s1">s=e.map(e=&gt;zo(t,e,i));n=Promise.all(s)}</span><span class="s0">else if</span><span class="s1">(</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e)n=zo(t,e,i);</span><span class="s0">else</span><span class="s1">{</span><span class="s0">const </span><span class="s1">s=</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e?Io(t,e,i.custom):e;n=Promise.all(Wo(t,s,i))}</span><span class="s0">return </span><span class="s1">n.then(()=&gt;{t.notify(</span><span class="s2">&quot;AnimationComplete&quot;</span><span class="s1">,e)})}(t,e,i)))}</span><span class="s0">function </span><span class="s1">Zo(t){</span><span class="s0">let </span><span class="s1">e=_o(t),i=tr(),n=!</span><span class="s3">0</span><span class="s1">;</span><span class="s0">const </span><span class="s1">s=e=&gt;(i,n)=&gt;{</span><span class="s0">const </span><span class="s1">s=Io(t,n,</span><span class="s2">&quot;exit&quot;</span><span class="s1">===e?t.presenceContext?.custom:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">);</span><span class="s0">if</span><span class="s1">(s){</span><span class="s0">const</span><span class="s1">{transition:t,transitionEnd:e,...n}=s;i={...i,...n,...e}}</span><span class="s0">return </span><span class="s1">i};</span><span class="s0">function </span><span class="s1">o(o){</span><span class="s0">const</span><span class="s1">{props:r}=t,a=Ho(t.parent)||{},l=[],h=</span><span class="s0">new </span><span class="s1">Set;</span><span class="s0">let </span><span class="s1">u={},c=</span><span class="s3">1</span><span class="s1">/</span><span class="s3">0</span><span class="s1">;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">0</span><span class="s1">;e&lt;qo;e++){</span><span class="s0">const </span><span class="s1">d=Go[e],p=i[d],m=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==r[d]?r[d]:a[d],f=D(m),y=d===o?p.isActive:</span><span class="s0">null</span><span class="s1">;!</span><span class="s3">1</span><span class="s1">===y&amp;&amp;(c=e);</span><span class="s0">let </span><span class="s1">g=m===a[d]&amp;&amp;m!==r[d]&amp;&amp;f;</span><span class="s0">if</span><span class="s1">(g&amp;&amp;n&amp;&amp;t.manuallyAnimateOnMount&amp;&amp;(g=!</span><span class="s3">1</span><span class="s1">),p.protectedKeys={...u},!p.isActive&amp;&amp;</span><span class="s0">null</span><span class="s1">===y||!m&amp;&amp;!p.prevProp||k(m)||</span><span class="s2">&quot;boolean&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">m)</span><span class="s0">continue</span><span class="s1">;</span><span class="s0">const </span><span class="s1">v=Jo(p.prevProp,m);</span><span class="s0">let </span><span class="s1">x=v||d===o&amp;&amp;p.isActive&amp;&amp;!g&amp;&amp;f||e&gt;c&amp;&amp;f,T=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">const </span><span class="s1">P=Array.isArray(m)?m:[m];</span><span class="s0">let </span><span class="s1">w=P.reduce(s(d),{});!</span><span class="s3">1</span><span class="s1">===y&amp;&amp;(w={});</span><span class="s0">const</span><span class="s1">{prevResolvedValues:S={}}=p,A={...S,...w},b=e=&gt;{x=!</span><span class="s3">0</span><span class="s1">,h.has(e)&amp;&amp;(T=!</span><span class="s3">0</span><span class="s1">,h.delete(e)),p.needsAnimating[e]=!</span><span class="s3">0</span><span class="s1">;</span><span class="s0">const </span><span class="s1">i=t.getValue(e);i&amp;&amp;(i.liveStyle=!</span><span class="s3">1</span><span class="s1">)};</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">t </span><span class="s0">in </span><span class="s1">A){</span><span class="s0">const </span><span class="s1">e=w[t],i=S[t];</span><span class="s0">if</span><span class="s1">(u.hasOwnProperty(t))</span><span class="s0">continue</span><span class="s1">;</span><span class="s0">let </span><span class="s1">n=!</span><span class="s3">1</span><span class="s1">;n=Oo(e)&amp;&amp;Oo(i)?!Yo(e,i):e!==i,n?</span><span class="s0">null</span><span class="s1">!=e?b(t):h.add(t):</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==e&amp;&amp;h.has(t)?b(t):p.protectedKeys[t]=!</span><span class="s3">0</span><span class="s1">}p.prevProp=m,p.prevResolvedValues=w,p.isActive&amp;&amp;(u={...u,...w}),n&amp;&amp;t.blockInitialAnimation&amp;&amp;(x=!</span><span class="s3">1</span><span class="s1">);</span><span class="s0">const </span><span class="s1">E=g&amp;&amp;v;x&amp;&amp;(!E||T)&amp;&amp;l.push(...P.map(e=&gt;{</span><span class="s0">const </span><span class="s1">i={type:d};</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e&amp;&amp;n&amp;&amp;!E&amp;&amp;t.manuallyAnimateOnMount&amp;&amp;t.parent){</span><span class="s0">const</span><span class="s1">{parent:n}=t,s=Io(n,e);</span><span class="s0">if</span><span class="s1">(n.enteringChildren&amp;&amp;s){</span><span class="s0">const</span><span class="s1">{delayChildren:e}=s.transition||{};i.delay=$o(n.enteringChildren,t,e)}}</span><span class="s0">return</span><span class="s1">{animation:e,options:i}}))}</span><span class="s0">if</span><span class="s1">(h.size){</span><span class="s0">const </span><span class="s1">e={};</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;boolean&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">r.initial){</span><span class="s0">const </span><span class="s1">i=Io(t,Array.isArray(r.initial)?r.initial[</span><span class="s3">0</span><span class="s1">]:r.initial);i&amp;&amp;i.transition&amp;&amp;(e.transition=i.transition)}h.forEach(i=&gt;{</span><span class="s0">const </span><span class="s1">n=t.getBaseTarget(i),s=t.getValue(i);s&amp;&amp;(s.liveStyle=!</span><span class="s3">0</span><span class="s1">),e[i]=n??</span><span class="s0">null</span><span class="s1">}),l.push({animation:e})}</span><span class="s0">let </span><span class="s1">d=Boolean(l.length);</span><span class="s0">return</span><span class="s1">!n||!</span><span class="s3">1</span><span class="s1">!==r.initial&amp;&amp;r.initial!==r.animate||t.manuallyAnimateOnMount||(d=!</span><span class="s3">1</span><span class="s1">),n=!</span><span class="s3">1</span><span class="s1">,d?e(l):Promise.resolve()}</span><span class="s0">return</span><span class="s1">{animateChanges:o,setActive:</span><span class="s0">function</span><span class="s1">(e,n){</span><span class="s0">if</span><span class="s1">(i[e].isActive===n)</span><span class="s0">return </span><span class="s1">Promise.resolve();t.variantChildren?.forEach(t=&gt;t.animationState?.setActive(e,n)),i[e].isActive=n;</span><span class="s0">const </span><span class="s1">s=o(e);</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">t </span><span class="s0">in </span><span class="s1">i)i[t].protectedKeys={};</span><span class="s0">return </span><span class="s1">s},setAnimateFunction:</span><span class="s0">function</span><span class="s1">(i){e=i(t)},getState:()=&gt;i,reset:()=&gt;{i=tr(),n=!</span><span class="s3">0</span><span class="s1">}}}</span><span class="s0">function </span><span class="s1">Jo(t,e){</span><span class="s0">return</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e?e!==t:!!Array.isArray(e)&amp;&amp;!Yo(e,t)}</span><span class="s0">function </span><span class="s1">Qo(t=!</span><span class="s3">1</span><span class="s1">){</span><span class="s0">return</span><span class="s1">{isActive:t,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}</span><span class="s0">function </span><span class="s1">tr(){</span><span class="s0">return</span><span class="s1">{animate:Qo(!</span><span class="s3">0</span><span class="s1">),whileInView:Qo(),whileHover:Qo(),whileTap:Qo(),whileDrag:Qo(),whileFocus:Qo(),exit:Qo()}}</span><span class="s0">let </span><span class="s1">er=</span><span class="s3">0</span><span class="s1">;</span><span class="s0">const </span><span class="s1">ir={animation:{Feature:</span><span class="s0">class extends </span><span class="s1">yn{constructor(t){</span><span class="s0">super</span><span class="s1">(t),t.animationState||(t.animationState=Zo(t))}updateAnimationControlsSubscription(){</span><span class="s0">const</span><span class="s1">{animate:t}=</span><span class="s0">this</span><span class="s1">.node.getProps();k(t)&amp;&amp;(</span><span class="s0">this</span><span class="s1">.unmountControls=t.subscribe(</span><span class="s0">this</span><span class="s1">.node))}mount(){</span><span class="s0">this</span><span class="s1">.updateAnimationControlsSubscription()}update(){</span><span class="s0">const</span><span class="s1">{animate:t}=</span><span class="s0">this</span><span class="s1">.node.getProps(),{animate:e}=</span><span class="s0">this</span><span class="s1">.node.prevProps||{};t!==e&amp;&amp;</span><span class="s0">this</span><span class="s1">.updateAnimationControlsSubscription()}unmount(){</span><span class="s0">this</span><span class="s1">.node.animationState.reset(),</span><span class="s0">this</span><span class="s1">.unmountControls?.()}}},exit:{Feature:</span><span class="s0">class extends </span><span class="s1">yn{constructor(){</span><span class="s0">super</span><span class="s1">(...arguments),</span><span class="s0">this</span><span class="s1">.id=er++}update(){</span><span class="s0">if</span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.node.presenceContext)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{isPresent:t,onExitComplete:e}=</span><span class="s0">this</span><span class="s1">.node.presenceContext,{isPresent:i}=</span><span class="s0">this</span><span class="s1">.node.prevPresenceContext||{};</span><span class="s0">if</span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.node.animationState||t===i)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">this</span><span class="s1">.node.animationState.setActive(</span><span class="s2">&quot;exit&quot;</span><span class="s1">,!t);e&amp;&amp;!t&amp;&amp;n.then(()=&gt;{e(</span><span class="s0">this</span><span class="s1">.id)})}mount(){</span><span class="s0">const</span><span class="s1">{register:t,onExitComplete:e}=</span><span class="s0">this</span><span class="s1">.node.presenceContext||{};e&amp;&amp;e(</span><span class="s0">this</span><span class="s1">.id),t&amp;&amp;(</span><span class="s0">this</span><span class="s1">.unmount=t(</span><span class="s0">this</span><span class="s1">.id))}unmount(){}}}};</span><span class="s0">function </span><span class="s1">nr(t,e,i){</span><span class="s0">const</span><span class="s1">{props:n}=t;t.animationState&amp;&amp;n.whileHover&amp;&amp;t.animationState.setActive(</span><span class="s2">&quot;whileHover&quot;</span><span class="s1">,</span><span class="s2">&quot;Start&quot;</span><span class="s1">===i);</span><span class="s0">const </span><span class="s1">s=n[</span><span class="s2">&quot;onHover&quot;</span><span class="s1">+i];s&amp;&amp;Et.postRender(()=&gt;s(e,An(e)))}</span><span class="s0">function </span><span class="s1">sr(t,e,i){</span><span class="s0">const</span><span class="s1">{props:n}=t;</span><span class="s0">if</span><span class="s1">(t.current </span><span class="s0">instanceof </span><span class="s1">HTMLButtonElement&amp;&amp;t.current.disabled)</span><span class="s0">return</span><span class="s1">;t.animationState&amp;&amp;n.whileTap&amp;&amp;t.animationState.setActive(</span><span class="s2">&quot;whileTap&quot;</span><span class="s1">,</span><span class="s2">&quot;Start&quot;</span><span class="s1">===i);</span><span class="s0">const </span><span class="s1">s=n[</span><span class="s2">&quot;onTap&quot;</span><span class="s1">+(</span><span class="s2">&quot;End&quot;</span><span class="s1">===i?</span><span class="s2">&quot;&quot;</span><span class="s1">:i)];s&amp;&amp;Et.postRender(()=&gt;s(e,An(e)))}</span><span class="s0">const </span><span class="s1">or=</span><span class="s0">new </span><span class="s1">WeakMap,rr=</span><span class="s0">new </span><span class="s1">WeakMap,ar=t=&gt;{</span><span class="s0">const </span><span class="s1">e=or.get(t.target);e&amp;&amp;e(t)},lr=t=&gt;{t.forEach(ar)};</span><span class="s0">function </span><span class="s1">hr(t,e,i){</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">function</span><span class="s1">({root:t,...e}){</span><span class="s0">const </span><span class="s1">i=t||document;rr.has(i)||rr.set(i,{});</span><span class="s0">const </span><span class="s1">n=rr.get(i),s=JSON.stringify(e);</span><span class="s0">return </span><span class="s1">n[s]||(n[s]=</span><span class="s0">new </span><span class="s1">IntersectionObserver(lr,{root:t,...e})),n[s]}(e);</span><span class="s0">return </span><span class="s1">or.set(t,i),n.observe(t),()=&gt;{or.delete(t),n.unobserve(t)}}</span><span class="s0">const </span><span class="s1">ur={some:</span><span class="s3">0</span><span class="s1">,all:</span><span class="s3">1</span><span class="s1">};</span><span class="s0">const </span><span class="s1">cr={inView:{Feature:</span><span class="s0">class extends </span><span class="s1">yn{constructor(){</span><span class="s0">super</span><span class="s1">(...arguments),</span><span class="s0">this</span><span class="s1">.hasEnteredView=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isInView=!</span><span class="s3">1</span><span class="s1">}startObserver(){</span><span class="s0">this</span><span class="s1">.unmount();</span><span class="s0">const</span><span class="s1">{viewport:t={}}=</span><span class="s0">this</span><span class="s1">.node.getProps(),{root:e,margin:i,amount:n=</span><span class="s2">&quot;some&quot;</span><span class="s1">,once:s}=t,o={root:e?e.current:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,rootMargin:i,threshold:</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">n?n:ur[n]};</span><span class="s0">return </span><span class="s1">hr(</span><span class="s0">this</span><span class="s1">.node.current,o,t=&gt;{</span><span class="s0">const</span><span class="s1">{isIntersecting:e}=t;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isInView===e)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isInView=e,s&amp;&amp;!e&amp;&amp;</span><span class="s0">this</span><span class="s1">.hasEnteredView)</span><span class="s0">return</span><span class="s1">;e&amp;&amp;(</span><span class="s0">this</span><span class="s1">.hasEnteredView=!</span><span class="s3">0</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.node.animationState&amp;&amp;</span><span class="s0">this</span><span class="s1">.node.animationState.setActive(</span><span class="s2">&quot;whileInView&quot;</span><span class="s1">,e);</span><span class="s0">const</span><span class="s1">{onViewportEnter:i,onViewportLeave:n}=</span><span class="s0">this</span><span class="s1">.node.getProps(),o=e?i:n;o&amp;&amp;o(t)})}mount(){</span><span class="s0">this</span><span class="s1">.startObserver()}update(){</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;undefined&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">IntersectionObserver)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{props:t,prevProps:e}=</span><span class="s0">this</span><span class="s1">.node;[</span><span class="s2">&quot;amount&quot;</span><span class="s1">,</span><span class="s2">&quot;margin&quot;</span><span class="s1">,</span><span class="s2">&quot;root&quot;</span><span class="s1">].some(</span><span class="s0">function</span><span class="s1">({viewport:t={}},{viewport:e={}}={}){</span><span class="s0">return </span><span class="s1">i=&gt;t[i]!==e[i]}(t,e))&amp;&amp;</span><span class="s0">this</span><span class="s1">.startObserver()}unmount(){}}},tap:{Feature:</span><span class="s0">class extends </span><span class="s1">yn{mount(){</span><span class="s0">const</span><span class="s1">{current:t}=</span><span class="s0">this</span><span class="s1">.node;t&amp;&amp;(</span><span class="s0">this</span><span class="s1">.unmount=pn(t,(t,e)=&gt;(sr(</span><span class="s0">this</span><span class="s1">.node,e,</span><span class="s2">&quot;Start&quot;</span><span class="s1">),(t,{success:e})=&gt;sr(</span><span class="s0">this</span><span class="s1">.node,t,e?</span><span class="s2">&quot;End&quot;</span><span class="s1">:</span><span class="s2">&quot;Cancel&quot;</span><span class="s1">)),{useGlobalTarget:</span><span class="s0">this</span><span class="s1">.node.props.globalTapTarget}))}unmount(){}}},focus:{Feature:</span><span class="s0">class extends </span><span class="s1">yn{constructor(){</span><span class="s0">super</span><span class="s1">(...arguments),</span><span class="s0">this</span><span class="s1">.isActive=!</span><span class="s3">1</span><span class="s1">}onFocus(){</span><span class="s0">let </span><span class="s1">t=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">try</span><span class="s1">{t=</span><span class="s0">this</span><span class="s1">.node.current.matches(</span><span class="s2">&quot;:focus-visible&quot;</span><span class="s1">)}</span><span class="s0">catch</span><span class="s1">(e){t=!</span><span class="s3">0</span><span class="s1">}t&amp;&amp;</span><span class="s0">this</span><span class="s1">.node.animationState&amp;&amp;(</span><span class="s0">this</span><span class="s1">.node.animationState.setActive(</span><span class="s2">&quot;whileFocus&quot;</span><span class="s1">,!</span><span class="s3">0</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.isActive=!</span><span class="s3">0</span><span class="s1">)}onBlur(){</span><span class="s0">this</span><span class="s1">.isActive&amp;&amp;</span><span class="s0">this</span><span class="s1">.node.animationState&amp;&amp;(</span><span class="s0">this</span><span class="s1">.node.animationState.setActive(</span><span class="s2">&quot;whileFocus&quot;</span><span class="s1">,!</span><span class="s3">1</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.isActive=!</span><span class="s3">1</span><span class="s1">)}mount(){</span><span class="s0">this</span><span class="s1">.unmount=tt(Sn(</span><span class="s0">this</span><span class="s1">.node.current,</span><span class="s2">&quot;focus&quot;</span><span class="s1">,()=&gt;</span><span class="s0">this</span><span class="s1">.onFocus()),Sn(</span><span class="s0">this</span><span class="s1">.node.current,</span><span class="s2">&quot;blur&quot;</span><span class="s1">,()=&gt;</span><span class="s0">this</span><span class="s1">.onBlur()))}unmount(){}}},hover:{Feature:</span><span class="s0">class extends </span><span class="s1">yn{mount(){</span><span class="s0">const</span><span class="s1">{current:t}=</span><span class="s0">this</span><span class="s1">.node;t&amp;&amp;(</span><span class="s0">this</span><span class="s1">.unmount=</span><span class="s0">function</span><span class="s1">(t,e,i={}){</span><span class="s0">const</span><span class="s1">[n,s,o]=sn(t,i),r=t=&gt;{</span><span class="s0">if</span><span class="s1">(!on(t))</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{target:i}=t,n=e(i,t);</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;function&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">n||!i)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">o=t=&gt;{on(t)&amp;&amp;(n(t),i.removeEventListener(</span><span class="s2">&quot;pointerleave&quot;</span><span class="s1">,o))};i.addEventListener(</span><span class="s2">&quot;pointerleave&quot;</span><span class="s1">,o,s)};</span><span class="s0">return </span><span class="s1">n.forEach(t=&gt;{t.addEventListener(</span><span class="s2">&quot;pointerenter&quot;</span><span class="s1">,r,s)}),o}(t,(t,e)=&gt;(nr(</span><span class="s0">this</span><span class="s1">.node,e,</span><span class="s2">&quot;Start&quot;</span><span class="s1">),t=&gt;nr(</span><span class="s0">this</span><span class="s1">.node,t,</span><span class="s2">&quot;End&quot;</span><span class="s1">))))}unmount(){}}}},dr=</span><span class="s0">new </span><span class="s1">Set([</span><span class="s2">&quot;baseFrequency&quot;</span><span class="s1">,</span><span class="s2">&quot;diffuseConstant&quot;</span><span class="s1">,</span><span class="s2">&quot;kernelMatrix&quot;</span><span class="s1">,</span><span class="s2">&quot;kernelUnitLength&quot;</span><span class="s1">,</span><span class="s2">&quot;keySplines&quot;</span><span class="s1">,</span><span class="s2">&quot;keyTimes&quot;</span><span class="s1">,</span><span class="s2">&quot;limitingConeAngle&quot;</span><span class="s1">,</span><span class="s2">&quot;markerHeight&quot;</span><span class="s1">,</span><span class="s2">&quot;markerWidth&quot;</span><span class="s1">,</span><span class="s2">&quot;numOctaves&quot;</span><span class="s1">,</span><span class="s2">&quot;targetX&quot;</span><span class="s1">,</span><span class="s2">&quot;targetY&quot;</span><span class="s1">,</span><span class="s2">&quot;surfaceScale&quot;</span><span class="s1">,</span><span class="s2">&quot;specularConstant&quot;</span><span class="s1">,</span><span class="s2">&quot;specularExponent&quot;</span><span class="s1">,</span><span class="s2">&quot;stdDeviation&quot;</span><span class="s1">,</span><span class="s2">&quot;tableValues&quot;</span><span class="s1">,</span><span class="s2">&quot;viewBox&quot;</span><span class="s1">,</span><span class="s2">&quot;gradientTransform&quot;</span><span class="s1">,</span><span class="s2">&quot;pathLength&quot;</span><span class="s1">,</span><span class="s2">&quot;startOffset&quot;</span><span class="s1">,</span><span class="s2">&quot;textLength&quot;</span><span class="s1">,</span><span class="s2">&quot;lengthAdjust&quot;</span><span class="s1">]);</span><span class="s0">class </span><span class="s1">pr </span><span class="s0">extends </span><span class="s1">Mo{constructor(){</span><span class="s0">super</span><span class="s1">(...arguments),</span><span class="s0">this</span><span class="s1">.type=</span><span class="s2">&quot;svg&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isSVGTag=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.measureInstanceViewportBox=Ln}getBaseTargetFromProps(t,e){</span><span class="s0">return </span><span class="s1">t[e]}readValueFromInstance(t,e){</span><span class="s0">if</span><span class="s1">(c.has(e)){</span><span class="s0">const </span><span class="s1">t=Hi(e);</span><span class="s0">return </span><span class="s1">t&amp;&amp;t.default||</span><span class="s3">0</span><span class="s1">}</span><span class="s0">return </span><span class="s1">e=dr.has(e)?e:L(e),t.getAttribute(e)}scrapeMotionValuesFromProps(t,e,i){</span><span class="s0">return </span><span class="s1">j(t,e,i)}build(t,e,i){B(t,e,</span><span class="s0">this</span><span class="s1">.isSVGTag,i.transformTemplate,i.style)}renderInstance(t,e,i,n){!</span><span class="s0">function</span><span class="s1">(t,e,i,n){Do(t,e,</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,n);</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">i </span><span class="s0">in </span><span class="s1">e.attrs)t.setAttribute(dr.has(i)?i:L(i),e.attrs[i])}(t,e,</span><span class="s3">0</span><span class="s1">,n)}mount(t){</span><span class="s0">this</span><span class="s1">.isSVGTag=F(t.tagName),</span><span class="s0">super</span><span class="s1">.mount(t)}}</span><span class="s0">const </span><span class="s1">mr={renderer:(t,e)=&gt;I(t)?</span><span class="s0">new </span><span class="s1">pr(e):</span><span class="s0">new </span><span class="s1">Co(e,{allowProjection:t!==z}),...ir,...cr},fr={...mr,...Bo,...Fo};</span><span class="s0">export</span><span class="s1">{fr as domMax};</span>
</pre>
</body>
</html>