<html>
<head>
<title>sorted-routes.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sorted-routes.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../../src/shared/lib/router/utils/sorted-routes.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;class UrlNode {</span><span class="s3">\n  </span><span class="s1">placeholder: boolean = true</span><span class="s3">\n  </span><span class="s1">children: Map&lt;string, UrlNode&gt; = new Map()</span><span class="s3">\n  </span><span class="s1">slugName: string | null = null</span><span class="s3">\n  </span><span class="s1">restSlugName: string | null = null</span><span class="s3">\n  </span><span class="s1">optionalRestSlugName: string | null = null</span><span class="s3">\n\n  </span><span class="s1">insert(urlPath: string): void {</span><span class="s3">\n    </span><span class="s1">this._insert(urlPath.split('/').filter(Boolean), [], false)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">smoosh(): string[] {</span><span class="s3">\n    </span><span class="s1">return this._smoosh()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private _smoosh(prefix: string = '/'): string[] {</span><span class="s3">\n    </span><span class="s1">const childrenPaths = [...this.children.keys()].sort()</span><span class="s3">\n    </span><span class="s1">if (this.slugName !== null) {</span><span class="s3">\n      </span><span class="s1">childrenPaths.splice(childrenPaths.indexOf('[]'), 1)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.restSlugName !== null) {</span><span class="s3">\n      </span><span class="s1">childrenPaths.splice(childrenPaths.indexOf('[...]'), 1)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.optionalRestSlugName !== null) {</span><span class="s3">\n      </span><span class="s1">childrenPaths.splice(childrenPaths.indexOf('[[...]]'), 1)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const routes = childrenPaths</span><span class="s3">\n      </span><span class="s1">.map((c) =&gt; this.children.get(c)!._smoosh(`${prefix}${c}/`))</span><span class="s3">\n      </span><span class="s1">.reduce((prev, curr) =&gt; [...prev, ...curr], [])</span><span class="s3">\n\n    </span><span class="s1">if (this.slugName !== null) {</span><span class="s3">\n      </span><span class="s1">routes.push(</span><span class="s3">\n        </span><span class="s1">...this.children.get('[]')!._smoosh(`${prefix}[${this.slugName}]/`)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!this.placeholder) {</span><span class="s3">\n      </span><span class="s1">const r = prefix === '/' ? '/' : prefix.slice(0, -1)</span><span class="s3">\n      </span><span class="s1">if (this.optionalRestSlugName != null) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`You cannot define a route with the same specificity as a optional catch-all route (</span><span class="s3">\&quot;</span><span class="s1">${r}</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">${r}[[...${this.optionalRestSlugName}]]</span><span class="s3">\&quot;</span><span class="s1">).`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">routes.unshift(r)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.restSlugName !== null) {</span><span class="s3">\n      </span><span class="s1">routes.push(</span><span class="s3">\n        </span><span class="s1">...this.children</span><span class="s3">\n          </span><span class="s1">.get('[...]')!</span><span class="s3">\n          </span><span class="s1">._smoosh(`${prefix}[...${this.restSlugName}]/`)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.optionalRestSlugName !== null) {</span><span class="s3">\n      </span><span class="s1">routes.push(</span><span class="s3">\n        </span><span class="s1">...this.children</span><span class="s3">\n          </span><span class="s1">.get('[[...]]')!</span><span class="s3">\n          </span><span class="s1">._smoosh(`${prefix}[[...${this.optionalRestSlugName}]]/`)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return routes</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private _insert(</span><span class="s3">\n    </span><span class="s1">urlPaths: string[],</span><span class="s3">\n    </span><span class="s1">slugNames: string[],</span><span class="s3">\n    </span><span class="s1">isCatchAll: boolean</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">if (urlPaths.length === 0) {</span><span class="s3">\n      </span><span class="s1">this.placeholder = false</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isCatchAll) {</span><span class="s3">\n      </span><span class="s1">throw new Error(`Catch-all must be the last part of the URL.`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// The next segment in the urlPaths list</span><span class="s3">\n    </span><span class="s1">let nextSegment = urlPaths[0]</span><span class="s3">\n\n    </span><span class="s1">// Check if the segment matches `[something]`</span><span class="s3">\n    </span><span class="s1">if (nextSegment.startsWith('[') &amp;&amp; nextSegment.endsWith(']')) {</span><span class="s3">\n      </span><span class="s1">// Strip `[` and `]`, leaving only `something`</span><span class="s3">\n      </span><span class="s1">let segmentName = nextSegment.slice(1, -1)</span><span class="s3">\n\n      </span><span class="s1">let isOptional = false</span><span class="s3">\n      </span><span class="s1">if (segmentName.startsWith('[') &amp;&amp; segmentName.endsWith(']')) {</span><span class="s3">\n        </span><span class="s1">// Strip optional `[` and `]`, leaving only `something`</span><span class="s3">\n        </span><span class="s1">segmentName = segmentName.slice(1, -1)</span><span class="s3">\n        </span><span class="s1">isOptional = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (segmentName.startsWith('…')) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`Detected a three-dot character ('…') at ('${segmentName}'). Did you mean ('...')?`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (segmentName.startsWith('...')) {</span><span class="s3">\n        </span><span class="s1">// Strip `...`, leaving only `something`</span><span class="s3">\n        </span><span class="s1">segmentName = segmentName.substring(3)</span><span class="s3">\n        </span><span class="s1">isCatchAll = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (segmentName.startsWith('[') || segmentName.endsWith(']')) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`Segment names may not start or end with extra brackets ('${segmentName}').`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (segmentName.startsWith('.')) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`Segment names may not start with erroneous periods ('${segmentName}').`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">function handleSlug(previousSlug: string | null, nextSlug: string) {</span><span class="s3">\n        </span><span class="s1">if (previousSlug !== null) {</span><span class="s3">\n          </span><span class="s1">// If the specific segment already has a slug but the slug is not `something`</span><span class="s3">\n          </span><span class="s1">// This prevents collisions like:</span><span class="s3">\n          </span><span class="s1">// pages/[post]/index.js</span><span class="s3">\n          </span><span class="s1">// pages/[id]/index.js</span><span class="s3">\n          </span><span class="s1">// Because currently multiple dynamic params on the same segment level are not supported</span><span class="s3">\n          </span><span class="s1">if (previousSlug !== nextSlug) {</span><span class="s3">\n            </span><span class="s1">// TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\n              </span><span class="s1">`You cannot use different slug names for the same dynamic path ('${previousSlug}' !== '${nextSlug}').`</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">slugNames.forEach((slug) =&gt; {</span><span class="s3">\n          </span><span class="s1">if (slug === nextSlug) {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\n              </span><span class="s1">`You cannot have the same slug name </span><span class="s3">\&quot;</span><span class="s1">${nextSlug}</span><span class="s3">\&quot; </span><span class="s1">repeat within a single dynamic path`</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (slug.replace(/</span><span class="s3">\\</span><span class="s1">W/g, '') === nextSegment.replace(/</span><span class="s3">\\</span><span class="s1">W/g, '')) {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\n              </span><span class="s1">`You cannot have the slug names </span><span class="s3">\&quot;</span><span class="s1">${slug}</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">${nextSlug}</span><span class="s3">\&quot; </span><span class="s1">differ only by non-word symbols within a single dynamic path`</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">slugNames.push(nextSlug)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (isCatchAll) {</span><span class="s3">\n        </span><span class="s1">if (isOptional) {</span><span class="s3">\n          </span><span class="s1">if (this.restSlugName != null) {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\n              </span><span class="s1">`You cannot use both an required and optional catch-all route at the same level (</span><span class="s3">\&quot;</span><span class="s1">[...${this.restSlugName}]</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">${urlPaths[0]}</span><span class="s3">\&quot; </span><span class="s1">).`</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">handleSlug(this.optionalRestSlugName, segmentName)</span><span class="s3">\n          </span><span class="s1">// slugName is kept as it can only be one particular slugName</span><span class="s3">\n          </span><span class="s1">this.optionalRestSlugName = segmentName</span><span class="s3">\n          </span><span class="s1">// nextSegment is overwritten to [[...]] so that it can later be sorted specifically</span><span class="s3">\n          </span><span class="s1">nextSegment = '[[...]]'</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">if (this.optionalRestSlugName != null) {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\n              </span><span class="s1">`You cannot use both an optional and required catch-all route at the same level (</span><span class="s3">\&quot;</span><span class="s1">[[...${this.optionalRestSlugName}]]</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">${urlPaths[0]}</span><span class="s3">\&quot;</span><span class="s1">).`</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">handleSlug(this.restSlugName, segmentName)</span><span class="s3">\n          </span><span class="s1">// slugName is kept as it can only be one particular slugName</span><span class="s3">\n          </span><span class="s1">this.restSlugName = segmentName</span><span class="s3">\n          </span><span class="s1">// nextSegment is overwritten to [...] so that it can later be sorted specifically</span><span class="s3">\n          </span><span class="s1">nextSegment = '[...]'</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (isOptional) {</span><span class="s3">\n          </span><span class="s1">throw new Error(</span><span class="s3">\n            </span><span class="s1">`Optional route parameters are not yet supported (</span><span class="s3">\&quot;</span><span class="s1">${urlPaths[0]}</span><span class="s3">\&quot;</span><span class="s1">).`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">handleSlug(this.slugName, segmentName)</span><span class="s3">\n        </span><span class="s1">// slugName is kept as it can only be one particular slugName</span><span class="s3">\n        </span><span class="s1">this.slugName = segmentName</span><span class="s3">\n        </span><span class="s1">// nextSegment is overwritten to [] so that it can later be sorted specifically</span><span class="s3">\n        </span><span class="s1">nextSegment = '[]'</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode</span><span class="s3">\n    </span><span class="s1">if (!this.children.has(nextSegment)) {</span><span class="s3">\n      </span><span class="s1">this.children.set(nextSegment, new UrlNode())</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.children</span><span class="s3">\n      </span><span class="s1">.get(nextSegment)!</span><span class="s3">\n      </span><span class="s1">._insert(urlPaths.slice(1), slugNames, isCatchAll)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @deprecated Use `sortSortableRoutes` or `sortPages` instead.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getSortedRoutes(</span><span class="s3">\n  </span><span class="s1">normalizedPages: ReadonlyArray&lt;string&gt;</span><span class="s3">\n</span><span class="s1">): string[] {</span><span class="s3">\n  </span><span class="s1">// First the UrlNode is created, and every UrlNode can have only 1 dynamic segment</span><span class="s3">\n  </span><span class="s1">// Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js</span><span class="s3">\n  </span><span class="s1">// Only 1 dynamic segment per nesting level</span><span class="s3">\n\n  </span><span class="s1">// So in the case that is test/integration/dynamic-routing it'll be this:</span><span class="s3">\n  </span><span class="s1">// pages/[post]/comments.js</span><span class="s3">\n  </span><span class="s1">// pages/blog/[post]/comment/[id].js</span><span class="s3">\n  </span><span class="s1">// Both are fine because `pages/[post]` and `pages/blog` are on the same level</span><span class="s3">\n  </span><span class="s1">// So in this case `UrlNode` created here has `this.slugName === 'post'`</span><span class="s3">\n  </span><span class="s1">// And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities</span><span class="s3">\n  </span><span class="s1">// Instead what has to be passed through is the upwards path's dynamic names</span><span class="s3">\n  </span><span class="s1">const root = new UrlNode()</span><span class="s3">\n\n  </span><span class="s1">// Here the `root` gets injected multiple paths, and insert will break them up into sublevels</span><span class="s3">\n  </span><span class="s1">normalizedPages.forEach((pagePath) =&gt; root.insert(pagePath))</span><span class="s3">\n  </span><span class="s1">// Smoosh will then sort those sublevels up to the point where you get the correct route definition priority</span><span class="s3">\n  </span><span class="s1">return root.smoosh()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @deprecated Use `sortSortableRouteObjects` or `sortPageObjects` instead.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getSortedRouteObjects&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">objects: T[],</span><span class="s3">\n  </span><span class="s1">getter: (obj: T) =&gt; string</span><span class="s3">\n</span><span class="s1">): T[] {</span><span class="s3">\n  </span><span class="s1">// We're assuming here that all the pathnames are unique, that way we can</span><span class="s3">\n  </span><span class="s1">// sort the list and use the index as the key.</span><span class="s3">\n  </span><span class="s1">const indexes: Record&lt;string, number&gt; = {}</span><span class="s3">\n  </span><span class="s1">const pathnames: string[] = []</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; objects.length; i++) {</span><span class="s3">\n    </span><span class="s1">const pathname = getter(objects[i])</span><span class="s3">\n    </span><span class="s1">indexes[pathname] = i</span><span class="s3">\n    </span><span class="s1">pathnames[i] = pathname</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Sort the pathnames.</span><span class="s3">\n  </span><span class="s1">const sorted = getSortedRoutes(pathnames)</span><span class="s3">\n\n  </span><span class="s1">// Map the sorted pathnames back to the original objects using the new sorted</span><span class="s3">\n  </span><span class="s1">// index.</span><span class="s3">\n  </span><span class="s1">return sorted.map((pathname) =&gt; objects[indexes[pathname]])</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;getSortedRouteObjects&quot;</span><span class="s0">,</span><span class="s1">&quot;getSortedRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;UrlNode&quot;</span><span class="s0">,</span><span class="s1">&quot;insert&quot;</span><span class="s0">,</span><span class="s1">&quot;urlPath&quot;</span><span class="s0">,</span><span class="s1">&quot;_insert&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">,</span><span class="s1">&quot;smoosh&quot;</span><span class="s0">,</span><span class="s1">&quot;_smoosh&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">,</span><span class="s1">&quot;childrenPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;sort&quot;</span><span class="s0">,</span><span class="s1">&quot;slugName&quot;</span><span class="s0">,</span><span class="s1">&quot;splice&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;restSlugName&quot;</span><span class="s0">,</span><span class="s1">&quot;optionalRestSlugName&quot;</span><span class="s0">,</span><span class="s1">&quot;routes&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;c&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;reduce&quot;</span><span class="s0">,</span><span class="s1">&quot;prev&quot;</span><span class="s0">,</span><span class="s1">&quot;curr&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;placeholder&quot;</span><span class="s0">,</span><span class="s1">&quot;r&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;urlPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;slugNames&quot;</span><span class="s0">,</span><span class="s1">&quot;isCatchAll&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;nextSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentName&quot;</span><span class="s0">,</span><span class="s1">&quot;isOptional&quot;</span><span class="s0">,</span><span class="s1">&quot;substring&quot;</span><span class="s0">,</span><span class="s1">&quot;handleSlug&quot;</span><span class="s0">,</span><span class="s1">&quot;previousSlug&quot;</span><span class="s0">,</span><span class="s1">&quot;nextSlug&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;slug&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedPages&quot;</span><span class="s0">,</span><span class="s1">&quot;root&quot;</span><span class="s0">,</span><span class="s1">&quot;pagePath&quot;</span><span class="s0">,</span><span class="s1">&quot;objects&quot;</span><span class="s0">,</span><span class="s1">&quot;getter&quot;</span><span class="s0">,</span><span class="s1">&quot;indexes&quot;</span><span class="s0">,</span><span class="s1">&quot;pathnames&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;sorted&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>