<html>
<head>
<title>AsYouType.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #264eff;}
.s6 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
AsYouType.js</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">Metadata from </span><span class="s2">'./metadata.js'</span>
<span class="s0">import </span><span class="s1">PhoneNumber from </span><span class="s2">'./PhoneNumber.js'</span>
<span class="s0">import </span><span class="s1">AsYouTypeState from </span><span class="s2">'./AsYouTypeState.js'</span>
<span class="s0">import </span><span class="s1">AsYouTypeFormatter, { DIGIT_PLACEHOLDER } from </span><span class="s2">'./AsYouTypeFormatter.js'</span>
<span class="s0">import </span><span class="s1">AsYouTypeParser, { extractFormattedDigitsAndPlus } from </span><span class="s2">'./AsYouTypeParser.js'</span>
<span class="s0">import </span><span class="s1">getCountryByCallingCode from </span><span class="s2">'./helpers/getCountryByCallingCode.js'</span>
<span class="s0">import </span><span class="s1">getCountryByNationalNumber from </span><span class="s2">'./helpers/getCountryByNationalNumber.js'</span>
<span class="s0">import </span><span class="s1">isObject from </span><span class="s2">'./helpers/isObject.js'</span>

<span class="s0">const </span><span class="s1">USE_NON_GEOGRAPHIC_COUNTRY_CODE = </span><span class="s0">false</span>

<span class="s0">export default class </span><span class="s1">AsYouType {</span>
	<span class="s3">/**</span>
	 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{(string|object)?} [optionsOrDefaultCountry] - The default country used for parsing non-international phone numbers. Can also be an `options` object.</span>
	 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} metadata</span>
	 <span class="s3">*/</span>
	<span class="s1">constructor(optionsOrDefaultCountry, metadata) {</span>
		<span class="s0">this</span><span class="s1">.metadata = </span><span class="s0">new </span><span class="s1">Metadata(metadata)</span>
		<span class="s0">const </span><span class="s1">[defaultCountry, defaultCallingCode] = </span><span class="s0">this</span><span class="s1">.getCountryAndCallingCode(optionsOrDefaultCountry)</span>
		<span class="s3">// `this.defaultCountry` and `this.defaultCallingCode` aren't required to be in sync.</span>
		<span class="s3">// For example, `this.defaultCountry` could be `&quot;AR&quot;` and `this.defaultCallingCode` could be `undefined`.</span>
		<span class="s3">// So `this.defaultCountry` and `this.defaultCallingCode` are totally independent.</span>
		<span class="s0">this</span><span class="s1">.defaultCountry = defaultCountry</span>
		<span class="s0">this</span><span class="s1">.defaultCallingCode = defaultCallingCode</span>
		<span class="s0">this</span><span class="s1">.reset()</span>
	<span class="s1">}</span>

	<span class="s1">getCountryAndCallingCode(optionsOrDefaultCountry) {</span>
		<span class="s3">// Set `defaultCountry` and `defaultCallingCode` options.</span>
		<span class="s0">let </span><span class="s1">defaultCountry</span>
		<span class="s0">let </span><span class="s1">defaultCallingCode</span>
		<span class="s3">// Turns out `null` also has type &quot;object&quot;. Weird.</span>
		<span class="s0">if </span><span class="s1">(optionsOrDefaultCountry) {</span>
			<span class="s0">if </span><span class="s1">(isObject(optionsOrDefaultCountry)) {</span>
				<span class="s1">defaultCountry = optionsOrDefaultCountry.defaultCountry</span>
				<span class="s1">defaultCallingCode = optionsOrDefaultCountry.defaultCallingCode</span>
			<span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
				<span class="s1">defaultCountry = optionsOrDefaultCountry</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s0">if </span><span class="s1">(defaultCountry &amp;&amp; !</span><span class="s0">this</span><span class="s1">.metadata.hasCountry(defaultCountry)) {</span>
			<span class="s1">defaultCountry = undefined</span>
		<span class="s1">}</span>
		<span class="s0">if </span><span class="s1">(defaultCallingCode) {</span>
			<span class="s3">/* istanbul ignore if */</span>
			<span class="s0">if </span><span class="s1">(USE_NON_GEOGRAPHIC_COUNTRY_CODE) {</span>
				<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.metadata.isNonGeographicCallingCode(defaultCallingCode)) {</span>
					<span class="s1">defaultCountry = </span><span class="s2">'001'</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s0">return </span><span class="s1">[defaultCountry, defaultCallingCode]</span>
	<span class="s1">}</span>

	<span class="s3">/**</span>
	 <span class="s3">* Inputs &quot;next&quot; phone number characters.</span>
	 <span class="s3">* </span><span class="s4">@param  </span><span class="s3">{string} text</span>
	 <span class="s3">* </span><span class="s4">@return </span><span class="s3">{string} Formatted phone number characters that have been input so far.</span>
	 <span class="s3">*/</span>
	<span class="s1">input(text) {</span>
		<span class="s0">const </span><span class="s1">{</span>
			<span class="s1">digits,</span>
			<span class="s1">justLeadingPlus</span>
		<span class="s1">} = </span><span class="s0">this</span><span class="s1">.parser.input(text, </span><span class="s0">this</span><span class="s1">.state)</span>
		<span class="s0">if </span><span class="s1">(justLeadingPlus) {</span>
			<span class="s0">this</span><span class="s1">.formattedOutput = </span><span class="s2">'+'</span>
		<span class="s1">} </span><span class="s0">else if </span><span class="s1">(digits) {</span>
			<span class="s0">this</span><span class="s1">.determineTheCountryIfNeeded()</span>
			<span class="s3">// Match the available formats by the currently available leading digits.</span>
			<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.state.nationalSignificantNumber) {</span>
				<span class="s0">this</span><span class="s1">.formatter.narrowDownMatchingFormats(</span><span class="s0">this</span><span class="s1">.state)</span>
			<span class="s1">}</span>
			<span class="s0">let </span><span class="s1">formattedNationalNumber</span>
			<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.metadata.hasSelectedNumberingPlan()) {</span>
				<span class="s1">formattedNationalNumber = </span><span class="s0">this</span><span class="s1">.formatter.format(digits, </span><span class="s0">this</span><span class="s1">.state)</span>
			<span class="s1">}</span>
			<span class="s0">if </span><span class="s1">(formattedNationalNumber === undefined) {</span>
				<span class="s3">// See if another national (significant) number could be re-extracted.</span>
				<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.parser.reExtractNationalSignificantNumber(</span><span class="s0">this</span><span class="s1">.state)) {</span>
					<span class="s0">this</span><span class="s1">.determineTheCountryIfNeeded()</span>
					<span class="s3">// If it could, then re-try formatting the new national (significant) number.</span>
					<span class="s0">const </span><span class="s1">nationalDigits = </span><span class="s0">this</span><span class="s1">.state.getNationalDigits()</span>
					<span class="s0">if </span><span class="s1">(nationalDigits) {</span>
						<span class="s1">formattedNationalNumber = </span><span class="s0">this</span><span class="s1">.formatter.format(nationalDigits, </span><span class="s0">this</span><span class="s1">.state)</span>
					<span class="s1">}</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s0">this</span><span class="s1">.formattedOutput = formattedNationalNumber</span>
				<span class="s1">? </span><span class="s0">this</span><span class="s1">.getFullNumber(formattedNationalNumber)</span>
				<span class="s1">: </span><span class="s0">this</span><span class="s1">.getNonFormattedNumber()</span>
		<span class="s1">}</span>
		<span class="s0">return this</span><span class="s1">.formattedOutput</span>
	<span class="s1">}</span>

	<span class="s1">reset() {</span>
		<span class="s0">this</span><span class="s1">.state = </span><span class="s0">new </span><span class="s1">AsYouTypeState({</span>
			<span class="s1">onCountryChange: (country) =&gt; {</span>
				<span class="s3">// Before version `1.6.0`, the official `AsYouType` formatter API</span>
				<span class="s3">// included a `.country` property on an `AsYouType` instance.</span>
				<span class="s3">// Since that property (along with the others) have been moved to</span>
				<span class="s3">// `this.state`, `this.country` property is emulated for compatibility</span>
				<span class="s3">// with the old versions.</span>
				<span class="s0">this</span><span class="s1">.country = country</span>
			<span class="s1">},</span>
			<span class="s1">onCallingCodeChange: (callingCode, country) =&gt; {</span>
				<span class="s0">this</span><span class="s1">.metadata.selectNumberingPlan(country, callingCode)</span>
				<span class="s0">this</span><span class="s1">.formatter.reset(</span><span class="s0">this</span><span class="s1">.metadata.numberingPlan, </span><span class="s0">this</span><span class="s1">.state)</span>
				<span class="s0">this</span><span class="s1">.parser.reset(</span><span class="s0">this</span><span class="s1">.metadata.numberingPlan)</span>
			<span class="s1">}</span>
		<span class="s1">})</span>
		<span class="s0">this</span><span class="s1">.formatter = </span><span class="s0">new </span><span class="s1">AsYouTypeFormatter({</span>
			<span class="s1">state: </span><span class="s0">this</span><span class="s1">.state,</span>
			<span class="s1">metadata: </span><span class="s0">this</span><span class="s1">.metadata</span>
		<span class="s1">})</span>
		<span class="s0">this</span><span class="s1">.parser = </span><span class="s0">new </span><span class="s1">AsYouTypeParser({</span>
			<span class="s1">defaultCountry: </span><span class="s0">this</span><span class="s1">.defaultCountry,</span>
			<span class="s1">defaultCallingCode: </span><span class="s0">this</span><span class="s1">.defaultCallingCode,</span>
			<span class="s1">metadata: </span><span class="s0">this</span><span class="s1">.metadata,</span>
			<span class="s1">state: </span><span class="s0">this</span><span class="s1">.state,</span>
			<span class="s1">onNationalSignificantNumberChange: () =&gt; {</span>
				<span class="s0">this</span><span class="s1">.determineTheCountryIfNeeded()</span>
				<span class="s0">this</span><span class="s1">.formatter.reset(</span><span class="s0">this</span><span class="s1">.metadata.numberingPlan, </span><span class="s0">this</span><span class="s1">.state)</span>
			<span class="s1">}</span>
		<span class="s1">})</span>
		<span class="s0">this</span><span class="s1">.state.reset({</span>
			<span class="s1">country: </span><span class="s0">this</span><span class="s1">.defaultCountry,</span>
			<span class="s1">callingCode: </span><span class="s0">this</span><span class="s1">.defaultCallingCode</span>
		<span class="s1">})</span>
		<span class="s0">this</span><span class="s1">.formattedOutput = </span><span class="s2">''</span>
		<span class="s0">return this</span>
	<span class="s1">}</span>

	<span class="s3">/**</span>
	 <span class="s3">* Returns `true` if the phone number is being input in international format.</span>
	 <span class="s3">* In other words, returns `true` if and only if the parsed phone number starts with a `&quot;+&quot;`.</span>
	 <span class="s3">* </span><span class="s4">@return </span><span class="s3">{boolean}</span>
	 <span class="s3">*/</span>
	<span class="s1">isInternational() {</span>
		<span class="s0">return this</span><span class="s1">.state.international</span>
	<span class="s1">}</span>

	<span class="s3">/**</span>
	 <span class="s3">* Returns the &quot;calling code&quot; part of the phone number when it's being input</span>
	 <span class="s3">* in an international format.</span>
	 <span class="s3">* If no valid calling code has been entered so far, returns `undefined`.</span>
	 <span class="s3">* </span><span class="s4">@return </span><span class="s3">{string} [callingCode]</span>
	 <span class="s3">*/</span>
	<span class="s1">getCallingCode() {</span>
		 <span class="s3">// If the number is being input in national format and some &quot;default calling code&quot;</span>
		 <span class="s3">// has been passed to `AsYouType` constructor, then `this.state.callingCode`</span>
		 <span class="s3">// is equal to that &quot;default calling code&quot;.</span>
		 <span class="s3">//</span>
		 <span class="s3">// If the number is being input in national format and no &quot;default calling code&quot;</span>
		 <span class="s3">// has been passed to `AsYouType` constructor, then returns `undefined`,</span>
		 <span class="s3">// even if a &quot;default country&quot; has been passed to `AsYouType` constructor.</span>
		 <span class="s3">//</span>
		<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isInternational()) {</span>
			<span class="s0">return this</span><span class="s1">.state.callingCode</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s3">// A legacy alias.</span>
	<span class="s1">getCountryCallingCode() {</span>
		<span class="s0">return this</span><span class="s1">.getCallingCode()</span>
	<span class="s1">}</span>

	<span class="s3">/**</span>
	 <span class="s3">* Returns a two-letter country code of the phone number.</span>
	 <span class="s3">* Returns `undefined` for &quot;non-geographic&quot; phone numbering plans.</span>
	 <span class="s3">* Returns `undefined` if no phone number has been input yet.</span>
	 <span class="s3">* </span><span class="s4">@return </span><span class="s3">{string} [country]</span>
	 <span class="s3">*/</span>
	<span class="s1">getCountry() {</span>
		<span class="s0">const </span><span class="s1">{ digits } = </span><span class="s0">this</span><span class="s1">.state</span>
		<span class="s3">// Return `undefined` if no digits have been input yet.</span>
		<span class="s0">if </span><span class="s1">(digits) {</span>
			<span class="s0">return this</span><span class="s1">._getCountry()</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s3">/**</span>
	 <span class="s3">* Returns a two-letter country code of the phone number.</span>
	 <span class="s3">* Returns `undefined` for &quot;non-geographic&quot; phone numbering plans.</span>
	 <span class="s3">* </span><span class="s4">@return </span><span class="s3">{string} [country]</span>
	 <span class="s3">*/</span>
	<span class="s1">_getCountry() {</span>
		<span class="s0">const </span><span class="s1">{ country } = </span><span class="s0">this</span><span class="s1">.state</span>
		<span class="s3">/* istanbul ignore if */</span>
		<span class="s0">if </span><span class="s1">(USE_NON_GEOGRAPHIC_COUNTRY_CODE) {</span>
			<span class="s3">// `AsYouType.getCountry()` returns `undefined`</span>
			<span class="s3">// for &quot;non-geographic&quot; phone numbering plans.</span>
			<span class="s0">if </span><span class="s1">(country === </span><span class="s2">'001'</span><span class="s1">) {</span>
				<span class="s0">return</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s0">return </span><span class="s1">country</span>
	<span class="s1">}</span>

	<span class="s1">determineTheCountryIfNeeded() {</span>
		<span class="s3">// Suppose a user enters a phone number in international format,</span>
		<span class="s3">// and there're several countries corresponding to that country calling code,</span>
		<span class="s3">// and a country has been derived from the number, and then</span>
		<span class="s3">// a user enters one more digit and the number is no longer</span>
		<span class="s3">// valid for the derived country, so the country should be re-derived</span>
		<span class="s3">// on every new digit in those cases.</span>
		<span class="s3">//</span>
		<span class="s3">// If the phone number is being input in national format,</span>
		<span class="s3">// then it could be a case when `defaultCountry` wasn't specified</span>
		<span class="s3">// when creating `AsYouType` instance, and just `defaultCallingCode` was specified,</span>
		<span class="s3">// and that &quot;calling code&quot; could correspond to a &quot;non-geographic entity&quot;,</span>
		<span class="s3">// or there could be several countries corresponding to that country calling code.</span>
		<span class="s3">// In those cases, `this.country` is `undefined` and should be derived</span>
		<span class="s3">// from the number. Again, if country calling code is ambiguous, then</span>
		<span class="s3">// `this.country` should be re-derived with each new digit.</span>
		<span class="s3">//</span>
		<span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.state.country || </span><span class="s0">this</span><span class="s1">.isCountryCallingCodeAmbiguous()) {</span>
			<span class="s0">this</span><span class="s1">.determineTheCountry()</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s3">// Prepends `+CountryCode ` in case of an international phone number</span>
	<span class="s1">getFullNumber(formattedNationalNumber) {</span>
		<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isInternational()) {</span>
			<span class="s0">const </span><span class="s1">prefix = (text) =&gt; </span><span class="s0">this</span><span class="s1">.formatter.getInternationalPrefixBeforeCountryCallingCode(</span><span class="s0">this</span><span class="s1">.state, {</span>
				<span class="s1">spacing: text ? </span><span class="s0">true </span><span class="s1">: </span><span class="s0">false</span>
			<span class="s1">}) + text</span>
			<span class="s0">const </span><span class="s1">{ callingCode } = </span><span class="s0">this</span><span class="s1">.state</span>
			<span class="s0">if </span><span class="s1">(!callingCode) {</span>
				<span class="s0">return </span><span class="s1">prefix(</span><span class="s2">`</span><span class="s1">${</span><span class="s0">this</span><span class="s1">.state.getDigitsWithoutInternationalPrefix()}</span><span class="s2">`</span><span class="s1">)</span>
			<span class="s1">}</span>
			<span class="s0">if </span><span class="s1">(!formattedNationalNumber) {</span>
				<span class="s0">return </span><span class="s1">prefix(callingCode)</span>
			<span class="s1">}</span>
			<span class="s0">return </span><span class="s1">prefix(</span><span class="s2">`</span><span class="s1">${callingCode} ${formattedNationalNumber}</span><span class="s2">`</span><span class="s1">)</span>
		<span class="s1">}</span>
		<span class="s0">return </span><span class="s1">formattedNationalNumber</span>
	<span class="s1">}</span>

	<span class="s1">getNonFormattedNationalNumberWithPrefix() {</span>
		<span class="s0">const </span><span class="s1">{</span>
			<span class="s1">nationalSignificantNumber,</span>
			<span class="s1">prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix,</span>
			<span class="s1">nationalPrefix</span>
		<span class="s1">} = </span><span class="s0">this</span><span class="s1">.state</span>
		<span class="s0">let </span><span class="s1">number = nationalSignificantNumber</span>
		<span class="s0">const </span><span class="s1">prefix = prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix || nationalPrefix</span>
		<span class="s0">if </span><span class="s1">(prefix) {</span>
			<span class="s1">number = prefix + number</span>
		<span class="s1">}</span>
		<span class="s0">return </span><span class="s1">number</span>
	<span class="s1">}</span>

	<span class="s1">getNonFormattedNumber() {</span>
		<span class="s0">const </span><span class="s1">{ nationalSignificantNumberIsModified } = </span><span class="s0">this</span><span class="s1">.state</span>
		<span class="s0">return this</span><span class="s1">.getFullNumber(</span>
			<span class="s1">nationalSignificantNumberIsModified</span>
				<span class="s1">? </span><span class="s0">this</span><span class="s1">.state.getNationalDigits()</span>
				<span class="s1">: </span><span class="s0">this</span><span class="s1">.getNonFormattedNationalNumberWithPrefix()</span>
		<span class="s1">)</span>
	<span class="s1">}</span>

	<span class="s1">getNonFormattedTemplate() {</span>
		<span class="s0">const </span><span class="s1">number = </span><span class="s0">this</span><span class="s1">.getNonFormattedNumber()</span>
		<span class="s0">if </span><span class="s1">(number) {</span>
			<span class="s0">return </span><span class="s1">number.replace(</span><span class="s5">/[\+\d]/g</span><span class="s1">, DIGIT_PLACEHOLDER)</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">isCountryCallingCodeAmbiguous() {</span>
		<span class="s0">const </span><span class="s1">{ callingCode } = </span><span class="s0">this</span><span class="s1">.state</span>
		<span class="s0">const </span><span class="s1">countryCodes = </span><span class="s0">this</span><span class="s1">.metadata.getCountryCodesForCallingCode(callingCode)</span>
		<span class="s0">return </span><span class="s1">countryCodes &amp;&amp; countryCodes.length &gt; </span><span class="s6">1</span>
	<span class="s1">}</span>

	<span class="s3">// Determines the exact country of the phone number</span>
	<span class="s3">// entered so far based on the country phone code</span>
	<span class="s3">// and the national phone number.</span>
	<span class="s1">determineTheCountry() {</span>
		<span class="s0">this</span><span class="s1">.state.setCountry(getCountryByCallingCode(</span>
			<span class="s0">this</span><span class="s1">.isInternational() ? </span><span class="s0">this</span><span class="s1">.state.callingCode : </span><span class="s0">this</span><span class="s1">.defaultCallingCode,</span>
			<span class="s1">{</span>
				<span class="s1">nationalNumber: </span><span class="s0">this</span><span class="s1">.state.nationalSignificantNumber,</span>
				<span class="s1">metadata: </span><span class="s0">this</span><span class="s1">.metadata</span>
			<span class="s1">}</span>
		<span class="s1">))</span>
	<span class="s1">}</span>

	<span class="s3">/**</span>
	 <span class="s3">* Returns a E.164 phone number value for the user's input.</span>
	 <span class="s3">*</span>
	 <span class="s3">* For example, for country `&quot;US&quot;` and input `&quot;(222) 333-4444&quot;`</span>
	 <span class="s3">* it will return `&quot;+12223334444&quot;`.</span>
	 <span class="s3">*</span>
	 <span class="s3">* For international phone number input, it will also auto-correct</span>
	 <span class="s3">* some minor errors such as using a national prefix when writing</span>
	 <span class="s3">* an international phone number. For example, if the user inputs</span>
	 <span class="s3">* `&quot;+44 0 7400 000000&quot;` then it will return an auto-corrected</span>
	 <span class="s3">* `&quot;+447400000000&quot;` phone number value.</span>
	 <span class="s3">*</span>
	 <span class="s3">* Will return `undefined` if no digits have been input,</span>
	 <span class="s3">* or when inputting a phone number in national format and no</span>
	 <span class="s3">* default country or default &quot;country calling code&quot; have been set.</span>
	 <span class="s3">*</span>
	 <span class="s3">* </span><span class="s4">@return </span><span class="s3">{string} [value]</span>
	 <span class="s3">*/</span>
	<span class="s1">getNumberValue() {</span>
		<span class="s0">const </span><span class="s1">{</span>
			<span class="s1">digits,</span>
			<span class="s1">callingCode,</span>
			<span class="s1">country,</span>
			<span class="s1">nationalSignificantNumber</span>
		<span class="s1">} = </span><span class="s0">this</span><span class="s1">.state</span>

	 	<span class="s3">// Will return `undefined` if no digits have been input.</span>
		<span class="s0">if </span><span class="s1">(!digits) {</span>
			<span class="s0">return</span>
		<span class="s1">}</span>

		<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isInternational()) {</span>
			<span class="s0">if </span><span class="s1">(callingCode) {</span>
				<span class="s0">return </span><span class="s2">'+' </span><span class="s1">+ callingCode + nationalSignificantNumber</span>
			<span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
				<span class="s0">return </span><span class="s2">'+' </span><span class="s1">+ digits</span>
			<span class="s1">}</span>
		<span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
			<span class="s0">if </span><span class="s1">(country || callingCode) {</span>
				<span class="s0">const </span><span class="s1">callingCode_ = country ? </span><span class="s0">this</span><span class="s1">.metadata.countryCallingCode() : callingCode</span>
				<span class="s0">return </span><span class="s2">'+' </span><span class="s1">+ callingCode_ + nationalSignificantNumber</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s3">/**</span>
	 <span class="s3">* Returns an instance of `PhoneNumber` class.</span>
	 <span class="s3">* Will return `undefined` if no national (significant) number</span>
	 <span class="s3">* digits have been entered so far, or if no `defaultCountry` has been</span>
	 <span class="s3">* set and the user enters a phone number not in international format.</span>
	 <span class="s3">*/</span>
	<span class="s1">getNumber() {</span>
		<span class="s0">const </span><span class="s1">{</span>
			<span class="s1">nationalSignificantNumber,</span>
			<span class="s1">carrierCode,</span>
			<span class="s1">callingCode</span>
		<span class="s1">} = </span><span class="s0">this</span><span class="s1">.state</span>

		<span class="s3">// `this._getCountry()` is basically same as `this.state.country`</span>
		<span class="s3">// with the only change that it return `undefined` in case of a</span>
		<span class="s3">// &quot;non-geographic&quot; numbering plan instead of `&quot;001&quot;` &quot;internal use&quot; value.</span>
		<span class="s0">let </span><span class="s1">country = </span><span class="s0">this</span><span class="s1">._getCountry()</span>

		<span class="s0">if </span><span class="s1">(!nationalSignificantNumber) {</span>
			<span class="s0">return</span>
		<span class="s1">}</span>

		<span class="s3">// `state.country` and `state.callingCode` aren't required to be in sync.</span>
		<span class="s3">// For example, `country` could be `&quot;AR&quot;` and `callingCode` could be `undefined`.</span>
		<span class="s3">// So `country` and `callingCode` are totally independent.</span>

		<span class="s0">if </span><span class="s1">(!country &amp;&amp; !callingCode) {</span>
			<span class="s0">return</span>
		<span class="s1">}</span>

		<span class="s3">// By default, if `defaultCountry` parameter was passed when</span>
		<span class="s3">// creating `AsYouType` instance, `state.country` is gonna be</span>
		<span class="s3">// that `defaultCountry`, which doesn't entirely conform with</span>
		<span class="s3">// `parsePhoneNumber()`'s behavior where it attempts to determine</span>
		<span class="s3">// the country more precisely in cases when multiple countries</span>
		<span class="s3">// could correspond to the same `countryCallingCode`.</span>
		<span class="s3">// https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/103#note_1417192969</span>
		<span class="s3">//</span>
		<span class="s3">// Because `AsYouType.getNumber()` method is supposed to be a 1:1</span>
		<span class="s3">// equivalent for `parsePhoneNumber(AsYouType.getNumberValue())`,</span>
		<span class="s3">// then it should also behave accordingly in cases of `country` ambiguity.</span>
		<span class="s3">// That's how users of this library would expect it to behave anyway.</span>
		<span class="s3">//</span>
		<span class="s0">if </span><span class="s1">(country) {</span>
			<span class="s0">if </span><span class="s1">(country === </span><span class="s0">this</span><span class="s1">.defaultCountry) {</span>
				<span class="s3">// `state.country` and `state.callingCode` aren't required to be in sync.</span>
				<span class="s3">// For example, `state.country` could be `&quot;AR&quot;` and `state.callingCode` could be `undefined`.</span>
				<span class="s3">// So `state.country` and `state.callingCode` are totally independent.</span>
				<span class="s0">const </span><span class="s1">metadata = </span><span class="s0">new </span><span class="s1">Metadata(</span><span class="s0">this</span><span class="s1">.metadata.metadata)</span>
				<span class="s1">metadata.selectNumberingPlan(country)</span>
				<span class="s0">const </span><span class="s1">callingCode = metadata.numberingPlan.callingCode()</span>
				<span class="s0">const </span><span class="s1">ambiguousCountries = </span><span class="s0">this</span><span class="s1">.metadata.getCountryCodesForCallingCode(callingCode)</span>
				<span class="s0">if </span><span class="s1">(ambiguousCountries.length &gt; </span><span class="s6">1</span><span class="s1">) {</span>
					<span class="s0">const </span><span class="s1">exactCountry = getCountryByNationalNumber(nationalSignificantNumber, {</span>
						<span class="s1">countries: ambiguousCountries,</span>
						<span class="s1">metadata: </span><span class="s0">this</span><span class="s1">.metadata.metadata</span>
					<span class="s1">})</span>
					<span class="s0">if </span><span class="s1">(exactCountry) {</span>
						<span class="s1">country = exactCountry</span>
					<span class="s1">}</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s0">const </span><span class="s1">phoneNumber = </span><span class="s0">new </span><span class="s1">PhoneNumber(</span>
			<span class="s1">country || callingCode,</span>
			<span class="s1">nationalSignificantNumber,</span>
			<span class="s0">this</span><span class="s1">.metadata.metadata</span>
		<span class="s1">)</span>
		<span class="s0">if </span><span class="s1">(carrierCode) {</span>
			<span class="s1">phoneNumber.carrierCode = carrierCode</span>
		<span class="s1">}</span>
		<span class="s3">// Phone number extensions are not supported by &quot;As You Type&quot; formatter.</span>
		<span class="s0">return </span><span class="s1">phoneNumber</span>
	<span class="s1">}</span>

	<span class="s3">/**</span>
	 <span class="s3">* Returns `true` if the phone number is &quot;possible&quot;.</span>
	 <span class="s3">* Is just a shortcut for `PhoneNumber.isPossible()`.</span>
	 <span class="s3">* </span><span class="s4">@return </span><span class="s3">{boolean}</span>
	 <span class="s3">*/</span>
	<span class="s1">isPossible() {</span>
		<span class="s0">const </span><span class="s1">phoneNumber = </span><span class="s0">this</span><span class="s1">.getNumber()</span>
		<span class="s0">if </span><span class="s1">(!phoneNumber) {</span>
			<span class="s0">return false</span>
		<span class="s1">}</span>
		<span class="s0">return </span><span class="s1">phoneNumber.isPossible()</span>
	<span class="s1">}</span>

	<span class="s3">/**</span>
	 <span class="s3">* Returns `true` if the phone number is &quot;valid&quot;.</span>
	 <span class="s3">* Is just a shortcut for `PhoneNumber.isValid()`.</span>
	 <span class="s3">* </span><span class="s4">@return </span><span class="s3">{boolean}</span>
	 <span class="s3">*/</span>
	<span class="s1">isValid() {</span>
		<span class="s0">const </span><span class="s1">phoneNumber = </span><span class="s0">this</span><span class="s1">.getNumber()</span>
		<span class="s0">if </span><span class="s1">(!phoneNumber) {</span>
			<span class="s0">return false</span>
		<span class="s1">}</span>
		<span class="s0">return </span><span class="s1">phoneNumber.isValid()</span>
	<span class="s1">}</span>

	<span class="s3">/**</span>
	 <span class="s3">* </span><span class="s4">@deprecated</span>
	 <span class="s3">* This method is used in `react-phone-number-input/source/input-control.js`</span>
	 <span class="s3">* in versions before `3.0.16`.</span>
	 <span class="s3">*/</span>
	<span class="s1">getNationalNumber() {</span>
		<span class="s0">return this</span><span class="s1">.state.nationalSignificantNumber</span>
	<span class="s1">}</span>

	<span class="s3">/**</span>
	 <span class="s3">* Returns the phone number characters entered by the user.</span>
	 <span class="s3">* </span><span class="s4">@return </span><span class="s3">{string}</span>
	 <span class="s3">*/</span>
	<span class="s1">getChars() {</span>
		<span class="s0">return </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.state.international ? </span><span class="s2">'+' </span><span class="s1">: </span><span class="s2">''</span><span class="s1">) + </span><span class="s0">this</span><span class="s1">.state.digits</span>
	<span class="s1">}</span>

	<span class="s3">/**</span>
	 <span class="s3">* Returns the template for the formatted phone number.</span>
	 <span class="s3">* </span><span class="s4">@return </span><span class="s3">{string}</span>
	 <span class="s3">*/</span>
	<span class="s1">getTemplate() {</span>
		<span class="s0">return this</span><span class="s1">.formatter.getTemplate(</span><span class="s0">this</span><span class="s1">.state) || </span><span class="s0">this</span><span class="s1">.getNonFormattedTemplate() || </span><span class="s2">''</span>
	<span class="s1">}</span>
<span class="s1">}</span></pre>
</body>
</html>