<html>
<head>
<title>server-utils.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
server-utils.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">getPreviouslyRevalidatedTags: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getServerUtils: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">interpolateDynamicPath: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">normalizeCdnUrl: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">normalizeDynamicRouteParams: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">getPreviouslyRevalidatedTags: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getPreviouslyRevalidatedTags;</span>
    <span class="s1">},</span>
    <span class="s1">getServerUtils: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getServerUtils;</span>
    <span class="s1">},</span>
    <span class="s1">interpolateDynamicPath: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">interpolateDynamicPath;</span>
    <span class="s1">},</span>
    <span class="s1">normalizeCdnUrl: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">normalizeCdnUrl;</span>
    <span class="s1">},</span>
    <span class="s1">normalizeDynamicRouteParams: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">normalizeDynamicRouteParams;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_normalizelocalepath = require(</span><span class="s0">&quot;../shared/lib/i18n/normalize-locale-path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_pathmatch = require(</span><span class="s0">&quot;../shared/lib/router/utils/path-match&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_routeregex = require(</span><span class="s0">&quot;../shared/lib/router/utils/route-regex&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_routematcher = require(</span><span class="s0">&quot;../shared/lib/router/utils/route-matcher&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_preparedestination = require(</span><span class="s0">&quot;../shared/lib/router/utils/prepare-destination&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_removetrailingslash = require(</span><span class="s0">&quot;../shared/lib/router/utils/remove-trailing-slash&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_apppaths = require(</span><span class="s0">&quot;../shared/lib/router/utils/app-paths&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants = require(</span><span class="s0">&quot;../lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils = require(</span><span class="s0">&quot;./web/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_decodequerypathparameter = require(</span><span class="s0">&quot;./lib/decode-query-path-parameter&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_url = require(</span><span class="s0">&quot;../lib/url&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_formaturl = require(</span><span class="s0">&quot;../shared/lib/router/utils/format-url&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_parseandvalidateflightrouterstate = require(</span><span class="s0">&quot;./app-render/parse-and-validate-flight-router-state&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_generateinterceptionroutesrewrites = require(</span><span class="s0">&quot;../lib/generate-interception-routes-rewrites&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_approuterheaders = require(</span><span class="s0">&quot;../client/components/app-router-headers&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_computechangedpath = require(</span><span class="s0">&quot;../client/components/router-reducer/compute-changed-path&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">filterInternalQuery(query, paramKeys) {</span>
    <span class="s4">// this is used to pass query information in rewrites</span>
    <span class="s4">// but should not be exposed in final query</span>
    <span class="s2">delete </span><span class="s1">query[</span><span class="s0">'nextInternalLocale'</span><span class="s1">];</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">query){</span>
        <span class="s2">const </span><span class="s1">isNextQueryPrefix = key !== _constants.NEXT_QUERY_PARAM_PREFIX &amp;&amp; key.startsWith(_constants.NEXT_QUERY_PARAM_PREFIX);</span>
        <span class="s2">const </span><span class="s1">isNextInterceptionMarkerPrefix = key !== _constants.NEXT_INTERCEPTION_MARKER_PREFIX &amp;&amp; key.startsWith(_constants.NEXT_INTERCEPTION_MARKER_PREFIX);</span>
        <span class="s2">if </span><span class="s1">(isNextQueryPrefix || isNextInterceptionMarkerPrefix || paramKeys.includes(key)) {</span>
            <span class="s2">delete </span><span class="s1">query[key];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeCdnUrl(req, paramKeys) {</span>
    <span class="s4">// make sure to normalize req.url from CDNs to strip dynamic and rewrite</span>
    <span class="s4">// params from the query which are added during routing</span>
    <span class="s2">const </span><span class="s1">_parsedUrl = (</span><span class="s3">0</span><span class="s1">, _url.parseReqUrl)(req.url);</span>
    <span class="s4">// we can't normalize if we can't parse</span>
    <span class="s2">if </span><span class="s1">(!_parsedUrl) {</span>
        <span class="s2">return </span><span class="s1">req.url;</span>
    <span class="s1">}</span>
    <span class="s2">delete </span><span class="s1">_parsedUrl.search;</span>
    <span class="s1">filterInternalQuery(_parsedUrl.query, paramKeys);</span>
    <span class="s1">req.url = (</span><span class="s3">0</span><span class="s1">, _formaturl.formatUrl)(_parsedUrl);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">interpolateDynamicPath(pathname, params, defaultRouteRegex) {</span>
    <span class="s2">if </span><span class="s1">(!defaultRouteRegex) </span><span class="s2">return </span><span class="s1">pathname;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">param of Object.keys(defaultRouteRegex.groups)){</span>
        <span class="s2">const </span><span class="s1">{ optional, repeat } = defaultRouteRegex.groups[param];</span>
        <span class="s2">let </span><span class="s1">builtParam = </span><span class="s0">`[</span><span class="s1">${repeat ? </span><span class="s0">'...' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">}${param}</span><span class="s0">]`</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(optional) {</span>
            <span class="s1">builtParam = </span><span class="s0">`[</span><span class="s1">${builtParam}</span><span class="s0">]`</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">paramValue;</span>
        <span class="s2">const </span><span class="s1">value = params[param];</span>
        <span class="s2">if </span><span class="s1">(Array.isArray(value)) {</span>
            <span class="s1">paramValue = value.map((v)=&gt;v &amp;&amp; encodeURIComponent(v)).join(</span><span class="s0">'/'</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(value) {</span>
            <span class="s1">paramValue = encodeURIComponent(value);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">paramValue = </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(paramValue || optional) {</span>
            <span class="s1">pathname = pathname.replaceAll(builtParam, paramValue);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">pathname;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeDynamicRouteParams(query, defaultRouteRegex, defaultRouteMatches, ignoreMissingOptional) {</span>
    <span class="s2">let </span><span class="s1">hasValidParams = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">params = {};</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of Object.keys(defaultRouteRegex.groups)){</span>
        <span class="s2">let </span><span class="s1">value = query[key];</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value === </span><span class="s0">'string'</span><span class="s1">) {</span>
            <span class="s1">value = (</span><span class="s3">0</span><span class="s1">, _apppaths.normalizeRscURL)(value);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(Array.isArray(value)) {</span>
            <span class="s1">value = value.map(_apppaths.normalizeRscURL);</span>
        <span class="s1">}</span>
        <span class="s4">// if the value matches the default value we can't rely</span>
        <span class="s4">// on the parsed params, this is used to signal if we need</span>
        <span class="s4">// to parse x-now-route-matches or not</span>
        <span class="s2">const </span><span class="s1">defaultValue = defaultRouteMatches[key];</span>
        <span class="s2">const </span><span class="s1">isOptional = defaultRouteRegex.groups[key].optional;</span>
        <span class="s2">const </span><span class="s1">isDefaultValue = Array.isArray(defaultValue) ? defaultValue.some((defaultVal)=&gt;{</span>
            <span class="s2">return </span><span class="s1">Array.isArray(value) ? value.some((val)=&gt;val.includes(defaultVal)) : value == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: value.includes(defaultVal);</span>
        <span class="s1">}) : value == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: value.includes(defaultValue);</span>
        <span class="s2">if </span><span class="s1">(isDefaultValue || </span><span class="s2">typeof </span><span class="s1">value === </span><span class="s0">'undefined' </span><span class="s1">&amp;&amp; !(isOptional &amp;&amp; ignoreMissingOptional)) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">params: {},</span>
                <span class="s1">hasValidParams: </span><span class="s2">false</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s4">// non-provided optional values should be undefined so normalize</span>
        <span class="s4">// them to undefined</span>
        <span class="s2">if </span><span class="s1">(isOptional &amp;&amp; (!value || Array.isArray(value) &amp;&amp; value.length === </span><span class="s3">1 </span><span class="s1">&amp;&amp; </span><span class="s4">// fallback optional catch-all SSG pages have</span>
        <span class="s4">// [[...paramName]] for the root path on Vercel</span>
        <span class="s1">(value[</span><span class="s3">0</span><span class="s1">] === </span><span class="s0">'index' </span><span class="s1">|| value[</span><span class="s3">0</span><span class="s1">] === </span><span class="s0">`[[...</span><span class="s1">${key}</span><span class="s0">]]`</span><span class="s1">))) {</span>
            <span class="s1">value = undefined;</span>
            <span class="s2">delete </span><span class="s1">query[key];</span>
        <span class="s1">}</span>
        <span class="s4">// query values from the proxy aren't already split into arrays</span>
        <span class="s4">// so make sure to normalize catch-all values</span>
        <span class="s2">if </span><span class="s1">(value &amp;&amp; </span><span class="s2">typeof </span><span class="s1">value === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; defaultRouteRegex.groups[key].repeat) {</span>
            <span class="s1">value = value.split(</span><span class="s0">'/'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(value) {</span>
            <span class="s1">params[key] = value;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">params,</span>
        <span class="s1">hasValidParams</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getServerUtils({ page, i18n, basePath, rewrites, pageIsDynamic, trailingSlash, caseSensitive }) {</span>
    <span class="s2">let </span><span class="s1">defaultRouteRegex;</span>
    <span class="s2">let </span><span class="s1">dynamicRouteMatcher;</span>
    <span class="s2">let </span><span class="s1">defaultRouteMatches;</span>
    <span class="s2">if </span><span class="s1">(pageIsDynamic) {</span>
        <span class="s1">defaultRouteRegex = (</span><span class="s3">0</span><span class="s1">, _routeregex.getNamedRouteRegex)(page, {</span>
            <span class="s1">prefixRouteKeys: </span><span class="s2">false</span>
        <span class="s1">});</span>
        <span class="s1">dynamicRouteMatcher = (</span><span class="s3">0</span><span class="s1">, _routematcher.getRouteMatcher)(defaultRouteRegex);</span>
        <span class="s1">defaultRouteMatches = dynamicRouteMatcher(page);</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">handleRewrites(req, parsedUrl) {</span>
        <span class="s2">const </span><span class="s1">rewriteParams = {};</span>
        <span class="s2">let </span><span class="s1">fsPathname = parsedUrl.pathname;</span>
        <span class="s2">const </span><span class="s1">matchesPage = ()=&gt;{</span>
            <span class="s2">const </span><span class="s1">fsPathnameNoSlash = (</span><span class="s3">0</span><span class="s1">, _removetrailingslash.removeTrailingSlash)(fsPathname || </span><span class="s0">''</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">fsPathnameNoSlash === (</span><span class="s3">0</span><span class="s1">, _removetrailingslash.removeTrailingSlash)(page) || (dynamicRouteMatcher == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: dynamicRouteMatcher(fsPathnameNoSlash));</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">checkRewrite = (rewrite)=&gt;{</span>
            <span class="s2">const </span><span class="s1">matcher = (</span><span class="s3">0</span><span class="s1">, _pathmatch.getPathMatch)(rewrite.source + (trailingSlash ? </span><span class="s0">'(/)?' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">), {</span>
                <span class="s1">removeUnnamedParams: </span><span class="s2">true</span><span class="s1">,</span>
                <span class="s1">strict: </span><span class="s2">true</span><span class="s1">,</span>
                <span class="s1">sensitive: !!caseSensitive</span>
            <span class="s1">});</span>
            <span class="s2">if </span><span class="s1">(!parsedUrl.pathname) </span><span class="s2">return false</span><span class="s1">;</span>
            <span class="s2">let </span><span class="s1">params = matcher(parsedUrl.pathname);</span>
            <span class="s2">if </span><span class="s1">((rewrite.has || rewrite.missing) &amp;&amp; params) {</span>
                <span class="s2">const </span><span class="s1">hasParams = (</span><span class="s3">0</span><span class="s1">, _preparedestination.matchHas)(req, parsedUrl.query, rewrite.has, rewrite.missing);</span>
                <span class="s2">if </span><span class="s1">(hasParams) {</span>
                    <span class="s1">Object.assign(params, hasParams);</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">params = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(params) {</span>
                <span class="s2">try </span><span class="s1">{</span>
                    <span class="s4">// An interception rewrite might reference a dynamic param for a route the user</span>
                    <span class="s4">// is currently on, which wouldn't be extractable from the matched route params.</span>
                    <span class="s4">// This attempts to extract the dynamic params from the provided router state.</span>
                    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _generateinterceptionroutesrewrites.isInterceptionRouteRewrite)(rewrite)) {</span>
                        <span class="s2">const </span><span class="s1">stateHeader = req.headers[_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER];</span>
                        <span class="s2">if </span><span class="s1">(stateHeader) {</span>
                            <span class="s1">params = {</span>
                                <span class="s1">...(</span><span class="s3">0</span><span class="s1">, _computechangedpath.getSelectedParams)((</span><span class="s3">0</span><span class="s1">, _parseandvalidateflightrouterstate.parseAndValidateFlightRouterState)(stateHeader)),</span>
                                <span class="s1">...params</span>
                            <span class="s1">};</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
                <span class="s4">// this is a no-op -- we couldn't extract dynamic params from the provided router state,</span>
                <span class="s4">// so we'll just use the params from the route matcher</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">{ parsedDestination, destQuery } = (</span><span class="s3">0</span><span class="s1">, _preparedestination.prepareDestination)({</span>
                    <span class="s1">appendParamsToQuery: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">destination: rewrite.destination,</span>
                    <span class="s1">params: params,</span>
                    <span class="s1">query: parsedUrl.query</span>
                <span class="s1">});</span>
                <span class="s4">// if the rewrite destination is external break rewrite chain</span>
                <span class="s2">if </span><span class="s1">(parsedDestination.protocol) {</span>
                    <span class="s2">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">Object.assign(rewriteParams, destQuery, params);</span>
                <span class="s1">Object.assign(parsedUrl.query, parsedDestination.query);</span>
                <span class="s2">delete </span><span class="s1">parsedDestination.query;</span>
                <span class="s4">// for each property in parsedUrl.query, if the value is parametrized (eg :foo), look up the value</span>
                <span class="s4">// in rewriteParams and replace the parametrized value with the actual value</span>
                <span class="s4">// this is used when the rewrite destination does not contain the original source param</span>
                <span class="s4">// and so the value is still parametrized and needs to be replaced with the actual rewrite param</span>
                <span class="s1">Object.entries(parsedUrl.query).forEach(([key, value])=&gt;{</span>
                    <span class="s2">if </span><span class="s1">(value &amp;&amp; </span><span class="s2">typeof </span><span class="s1">value === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; value.startsWith(</span><span class="s0">':'</span><span class="s1">)) {</span>
                        <span class="s2">const </span><span class="s1">paramName = value.slice(</span><span class="s3">1</span><span class="s1">);</span>
                        <span class="s2">const </span><span class="s1">actualValue = rewriteParams[paramName];</span>
                        <span class="s2">if </span><span class="s1">(actualValue) {</span>
                            <span class="s1">parsedUrl.query[key] = actualValue;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
                <span class="s1">Object.assign(parsedUrl, parsedDestination);</span>
                <span class="s1">fsPathname = parsedUrl.pathname;</span>
                <span class="s2">if </span><span class="s1">(!fsPathname) </span><span class="s2">return false</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(basePath) {</span>
                    <span class="s1">fsPathname = fsPathname.replace(</span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s0">`^</span><span class="s1">${basePath}</span><span class="s0">`</span><span class="s1">), </span><span class="s0">''</span><span class="s1">) || </span><span class="s0">'/'</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(i18n) {</span>
                    <span class="s2">const </span><span class="s1">result = (</span><span class="s3">0</span><span class="s1">, _normalizelocalepath.normalizeLocalePath)(fsPathname, i18n.locales);</span>
                    <span class="s1">fsPathname = result.pathname;</span>
                    <span class="s1">parsedUrl.query.nextInternalLocale = result.detectedLocale || params.nextInternalLocale;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(fsPathname === page) {</span>
                    <span class="s2">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(pageIsDynamic &amp;&amp; dynamicRouteMatcher) {</span>
                    <span class="s2">const </span><span class="s1">dynamicParams = dynamicRouteMatcher(fsPathname);</span>
                    <span class="s2">if </span><span class="s1">(dynamicParams) {</span>
                        <span class="s1">parsedUrl.query = {</span>
                            <span class="s1">...parsedUrl.query,</span>
                            <span class="s1">...dynamicParams</span>
                        <span class="s1">};</span>
                        <span class="s2">return true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">};</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">rewrite of rewrites.beforeFiles || []){</span>
            <span class="s1">checkRewrite(rewrite);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(fsPathname !== page) {</span>
            <span class="s2">let </span><span class="s1">finished = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">rewrite of rewrites.afterFiles || []){</span>
                <span class="s1">finished = checkRewrite(rewrite);</span>
                <span class="s2">if </span><span class="s1">(finished) </span><span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!finished &amp;&amp; !matchesPage()) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">rewrite of rewrites.fallback || []){</span>
                    <span class="s1">finished = checkRewrite(rewrite);</span>
                    <span class="s2">if </span><span class="s1">(finished) </span><span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">rewriteParams;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">getParamsFromRouteMatches(routeMatchesHeader) {</span>
        <span class="s4">// If we don't have a default route regex, we can't get params from route</span>
        <span class="s4">// matches</span>
        <span class="s2">if </span><span class="s1">(!defaultRouteRegex) </span><span class="s2">return null</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">{ groups, routeKeys } = defaultRouteRegex;</span>
        <span class="s2">const </span><span class="s1">matcher = (</span><span class="s3">0</span><span class="s1">, _routematcher.getRouteMatcher)({</span>
            <span class="s1">re: {</span>
                <span class="s4">// Simulate a RegExp match from the \`req.url\` input</span>
                <span class="s1">exec: (str)=&gt;{</span>
                    <span class="s4">// Normalize all the prefixed query params.</span>
                    <span class="s2">const </span><span class="s1">obj = Object.fromEntries(</span><span class="s2">new </span><span class="s1">URLSearchParams(str));</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[key, value] of Object.entries(obj)){</span>
                        <span class="s2">const </span><span class="s1">normalizedKey = (</span><span class="s3">0</span><span class="s1">, _utils.normalizeNextQueryParam)(key);</span>
                        <span class="s2">if </span><span class="s1">(!normalizedKey) </span><span class="s2">continue</span><span class="s1">;</span>
                        <span class="s1">obj[normalizedKey] = value;</span>
                        <span class="s2">delete </span><span class="s1">obj[key];</span>
                    <span class="s1">}</span>
                    <span class="s4">// Use all the named route keys.</span>
                    <span class="s2">const </span><span class="s1">result = {};</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">keyName of Object.keys(routeKeys)){</span>
                        <span class="s2">const </span><span class="s1">paramName = routeKeys[keyName];</span>
                        <span class="s4">// If this param name is not a valid parameter name, then skip it.</span>
                        <span class="s2">if </span><span class="s1">(!paramName) </span><span class="s2">continue</span><span class="s1">;</span>
                        <span class="s2">const </span><span class="s1">group = groups[paramName];</span>
                        <span class="s2">const </span><span class="s1">value = obj[keyName];</span>
                        <span class="s4">// When we're missing a required param, we can't match the route.</span>
                        <span class="s2">if </span><span class="s1">(!group.optional &amp;&amp; !value) </span><span class="s2">return null</span><span class="s1">;</span>
                        <span class="s1">result[group.pos] = value;</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">result;</span>
                <span class="s1">}</span>
            <span class="s1">},</span>
            <span class="s1">groups</span>
        <span class="s1">});</span>
        <span class="s2">const </span><span class="s1">routeMatches = matcher(routeMatchesHeader);</span>
        <span class="s2">if </span><span class="s1">(!routeMatches) </span><span class="s2">return null</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s1">routeMatches;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">normalizeQueryParams(query, routeParamKeys) {</span>
        <span class="s4">// this is used to pass query information in rewrites</span>
        <span class="s4">// but should not be exposed in final query</span>
        <span class="s2">delete </span><span class="s1">query[</span><span class="s0">'nextInternalLocale'</span><span class="s1">];</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[key, value] of Object.entries(query)){</span>
            <span class="s2">const </span><span class="s1">normalizedKey = (</span><span class="s3">0</span><span class="s1">, _utils.normalizeNextQueryParam)(key);</span>
            <span class="s2">if </span><span class="s1">(!normalizedKey) </span><span class="s2">continue</span><span class="s1">;</span>
            <span class="s4">// Remove the prefixed key from the query params because we want</span>
            <span class="s4">// to consume it for the dynamic route matcher.</span>
            <span class="s2">delete </span><span class="s1">query[key];</span>
            <span class="s1">routeParamKeys.add(normalizedKey);</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value === </span><span class="s0">'undefined'</span><span class="s1">) </span><span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">query[normalizedKey] = Array.isArray(value) ? value.map((v)=&gt;(</span><span class="s3">0</span><span class="s1">, _decodequerypathparameter.decodeQueryPathParameter)(v)) : (</span><span class="s3">0</span><span class="s1">, _decodequerypathparameter.decodeQueryPathParameter)(value);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">handleRewrites,</span>
        <span class="s1">defaultRouteRegex,</span>
        <span class="s1">dynamicRouteMatcher,</span>
        <span class="s1">defaultRouteMatches,</span>
        <span class="s1">normalizeQueryParams,</span>
        <span class="s1">getParamsFromRouteMatches,</span>
        <span class="s4">/**</span>
     <span class="s4">* Normalize dynamic route params.</span>
     <span class="s4">*</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">query - The query params to normalize.</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">ignoreMissingOptional - Whether to ignore missing optional params.</span>
     <span class="s4">* </span><span class="s5">@returns </span><span class="s4">The normalized params and whether they are valid.</span>
     <span class="s4">*/ </span><span class="s1">normalizeDynamicRouteParams: (query, ignoreMissingOptional)=&gt;{</span>
            <span class="s2">if </span><span class="s1">(!defaultRouteRegex || !defaultRouteMatches) {</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">params: {},</span>
                    <span class="s1">hasValidParams: </span><span class="s2">false</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">normalizeDynamicRouteParams(query, defaultRouteRegex, defaultRouteMatches, ignoreMissingOptional);</span>
        <span class="s1">},</span>
        <span class="s1">normalizeCdnUrl: (req, paramKeys)=&gt;normalizeCdnUrl(req, paramKeys),</span>
        <span class="s1">interpolateDynamicPath: (pathname, params)=&gt;interpolateDynamicPath(pathname, params, defaultRouteRegex),</span>
        <span class="s1">filterInternalQuery: (query, paramKeys)=&gt;filterInternalQuery(query, paramKeys)</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getPreviouslyRevalidatedTags(headers, previewModeId) {</span>
    <span class="s2">return typeof </span><span class="s1">headers[_constants.NEXT_CACHE_REVALIDATED_TAGS_HEADER] === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; headers[_constants.NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER] === previewModeId ? headers[_constants.NEXT_CACHE_REVALIDATED_TAGS_HEADER].split(</span><span class="s0">','</span><span class="s1">) : [];</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=server-utils.js.map</span></pre>
</body>
</html>