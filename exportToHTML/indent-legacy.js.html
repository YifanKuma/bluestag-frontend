<html>
<head>
<title>indent-legacy.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #1750eb;}
.s6 { color: #0037a6;}
.s7 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
indent-legacy.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">This option sets a specific tab width for your code</span>
 <span class="s0">*</span>
 <span class="s0">* This rule has been ported and modified from nodeca.</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Vitaly Puzrin</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Gyandeep Singh</span>
 <span class="s0">* </span><span class="s1">@deprecated </span><span class="s0">in ESLint v4.0.0</span>
 <span class="s0">*/</span>

<span class="s3">&quot;use strict&quot;</span><span class="s2">;</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Requirements</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s4">const </span><span class="s2">astUtils = require(</span><span class="s3">&quot;./utils/ast-utils&quot;</span><span class="s2">);</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Rule Definition</span>
<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// this rule has known coverage issues, but it's deprecated and shouldn't be updated in the future anyway.</span>
<span class="s0">/* c8 ignore next */</span>
<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{import('../types').Rule.RuleModule} */</span>
<span class="s2">module.exports = {</span>
	<span class="s2">meta: {</span>
		<span class="s2">type: </span><span class="s3">&quot;layout&quot;</span><span class="s2">,</span>

		<span class="s2">docs: {</span>
			<span class="s2">description: </span><span class="s3">&quot;Enforce consistent indentation&quot;</span><span class="s2">,</span>
			<span class="s2">recommended: </span><span class="s4">false</span><span class="s2">,</span>
			<span class="s2">url: </span><span class="s3">&quot;https://eslint.org/docs/latest/rules/indent-legacy&quot;</span><span class="s2">,</span>
		<span class="s2">},</span>

		<span class="s2">deprecated: {</span>
			<span class="s2">message: </span><span class="s3">&quot;Formatting rules are being moved out of ESLint core.&quot;</span><span class="s2">,</span>
			<span class="s2">url: </span><span class="s3">&quot;https://eslint.org/blog/2023/10/deprecating-formatting-rules/&quot;</span><span class="s2">,</span>
			<span class="s2">deprecatedSince: </span><span class="s3">&quot;4.0.0&quot;</span><span class="s2">,</span>
			<span class="s2">replacedBy: [</span>
				<span class="s2">{</span>
					<span class="s2">message:</span>
						<span class="s3">&quot;ESLint Stylistic now maintains deprecated stylistic core rules.&quot;</span><span class="s2">,</span>
					<span class="s2">url: </span><span class="s3">&quot;https://eslint.style/guide/migration&quot;</span><span class="s2">,</span>
					<span class="s2">plugin: {</span>
						<span class="s2">name: </span><span class="s3">&quot;@stylistic/eslint-plugin&quot;</span><span class="s2">,</span>
						<span class="s2">url: </span><span class="s3">&quot;https://eslint.style&quot;</span><span class="s2">,</span>
					<span class="s2">},</span>
					<span class="s2">rule: {</span>
						<span class="s2">name: </span><span class="s3">&quot;indent&quot;</span><span class="s2">,</span>
						<span class="s2">url: </span><span class="s3">&quot;https://eslint.style/rules/indent&quot;</span><span class="s2">,</span>
					<span class="s2">},</span>
				<span class="s2">},</span>
			<span class="s2">],</span>
		<span class="s2">},</span>

		<span class="s2">fixable: </span><span class="s3">&quot;whitespace&quot;</span><span class="s2">,</span>

		<span class="s2">schema: [</span>
			<span class="s2">{</span>
				<span class="s2">oneOf: [</span>
					<span class="s2">{</span>
						<span class="s4">enum</span><span class="s2">: [</span><span class="s3">&quot;tab&quot;</span><span class="s2">],</span>
					<span class="s2">},</span>
					<span class="s2">{</span>
						<span class="s2">type: </span><span class="s3">&quot;integer&quot;</span><span class="s2">,</span>
						<span class="s2">minimum: </span><span class="s5">0</span><span class="s2">,</span>
					<span class="s2">},</span>
				<span class="s2">],</span>
			<span class="s2">},</span>
			<span class="s2">{</span>
				<span class="s2">type: </span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
				<span class="s2">properties: {</span>
					<span class="s2">SwitchCase: {</span>
						<span class="s2">type: </span><span class="s3">&quot;integer&quot;</span><span class="s2">,</span>
						<span class="s2">minimum: </span><span class="s5">0</span><span class="s2">,</span>
					<span class="s2">},</span>
					<span class="s2">VariableDeclarator: {</span>
						<span class="s2">oneOf: [</span>
							<span class="s2">{</span>
								<span class="s2">type: </span><span class="s3">&quot;integer&quot;</span><span class="s2">,</span>
								<span class="s2">minimum: </span><span class="s5">0</span><span class="s2">,</span>
							<span class="s2">},</span>
							<span class="s2">{</span>
								<span class="s2">type: </span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
								<span class="s2">properties: {</span>
									<span class="s4">var</span><span class="s2">: {</span>
										<span class="s2">type: </span><span class="s3">&quot;integer&quot;</span><span class="s2">,</span>
										<span class="s2">minimum: </span><span class="s5">0</span><span class="s2">,</span>
									<span class="s2">},</span>
									<span class="s4">let</span><span class="s2">: {</span>
										<span class="s2">type: </span><span class="s3">&quot;integer&quot;</span><span class="s2">,</span>
										<span class="s2">minimum: </span><span class="s5">0</span><span class="s2">,</span>
									<span class="s2">},</span>
									<span class="s4">const</span><span class="s2">: {</span>
										<span class="s2">type: </span><span class="s3">&quot;integer&quot;</span><span class="s2">,</span>
										<span class="s2">minimum: </span><span class="s5">0</span><span class="s2">,</span>
									<span class="s2">},</span>
								<span class="s2">},</span>
							<span class="s2">},</span>
						<span class="s2">],</span>
					<span class="s2">},</span>
					<span class="s2">outerIIFEBody: {</span>
						<span class="s2">type: </span><span class="s3">&quot;integer&quot;</span><span class="s2">,</span>
						<span class="s2">minimum: </span><span class="s5">0</span><span class="s2">,</span>
					<span class="s2">},</span>
					<span class="s2">MemberExpression: {</span>
						<span class="s2">type: </span><span class="s3">&quot;integer&quot;</span><span class="s2">,</span>
						<span class="s2">minimum: </span><span class="s5">0</span><span class="s2">,</span>
					<span class="s2">},</span>
					<span class="s2">FunctionDeclaration: {</span>
						<span class="s2">type: </span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
						<span class="s2">properties: {</span>
							<span class="s2">parameters: {</span>
								<span class="s2">oneOf: [</span>
									<span class="s2">{</span>
										<span class="s2">type: </span><span class="s3">&quot;integer&quot;</span><span class="s2">,</span>
										<span class="s2">minimum: </span><span class="s5">0</span><span class="s2">,</span>
									<span class="s2">},</span>
									<span class="s2">{</span>
										<span class="s4">enum</span><span class="s2">: [</span><span class="s3">&quot;first&quot;</span><span class="s2">],</span>
									<span class="s2">},</span>
								<span class="s2">],</span>
							<span class="s2">},</span>
							<span class="s2">body: {</span>
								<span class="s2">type: </span><span class="s3">&quot;integer&quot;</span><span class="s2">,</span>
								<span class="s2">minimum: </span><span class="s5">0</span><span class="s2">,</span>
							<span class="s2">},</span>
						<span class="s2">},</span>
					<span class="s2">},</span>
					<span class="s2">FunctionExpression: {</span>
						<span class="s2">type: </span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
						<span class="s2">properties: {</span>
							<span class="s2">parameters: {</span>
								<span class="s2">oneOf: [</span>
									<span class="s2">{</span>
										<span class="s2">type: </span><span class="s3">&quot;integer&quot;</span><span class="s2">,</span>
										<span class="s2">minimum: </span><span class="s5">0</span><span class="s2">,</span>
									<span class="s2">},</span>
									<span class="s2">{</span>
										<span class="s4">enum</span><span class="s2">: [</span><span class="s3">&quot;first&quot;</span><span class="s2">],</span>
									<span class="s2">},</span>
								<span class="s2">],</span>
							<span class="s2">},</span>
							<span class="s2">body: {</span>
								<span class="s2">type: </span><span class="s3">&quot;integer&quot;</span><span class="s2">,</span>
								<span class="s2">minimum: </span><span class="s5">0</span><span class="s2">,</span>
							<span class="s2">},</span>
						<span class="s2">},</span>
					<span class="s2">},</span>
					<span class="s2">CallExpression: {</span>
						<span class="s2">type: </span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
						<span class="s2">properties: {</span>
							<span class="s2">parameters: {</span>
								<span class="s2">oneOf: [</span>
									<span class="s2">{</span>
										<span class="s2">type: </span><span class="s3">&quot;integer&quot;</span><span class="s2">,</span>
										<span class="s2">minimum: </span><span class="s5">0</span><span class="s2">,</span>
									<span class="s2">},</span>
									<span class="s2">{</span>
										<span class="s4">enum</span><span class="s2">: [</span><span class="s3">&quot;first&quot;</span><span class="s2">],</span>
									<span class="s2">},</span>
								<span class="s2">],</span>
							<span class="s2">},</span>
						<span class="s2">},</span>
					<span class="s2">},</span>
					<span class="s2">ArrayExpression: {</span>
						<span class="s2">oneOf: [</span>
							<span class="s2">{</span>
								<span class="s2">type: </span><span class="s3">&quot;integer&quot;</span><span class="s2">,</span>
								<span class="s2">minimum: </span><span class="s5">0</span><span class="s2">,</span>
							<span class="s2">},</span>
							<span class="s2">{</span>
								<span class="s4">enum</span><span class="s2">: [</span><span class="s3">&quot;first&quot;</span><span class="s2">],</span>
							<span class="s2">},</span>
						<span class="s2">],</span>
					<span class="s2">},</span>
					<span class="s2">ObjectExpression: {</span>
						<span class="s2">oneOf: [</span>
							<span class="s2">{</span>
								<span class="s2">type: </span><span class="s3">&quot;integer&quot;</span><span class="s2">,</span>
								<span class="s2">minimum: </span><span class="s5">0</span><span class="s2">,</span>
							<span class="s2">},</span>
							<span class="s2">{</span>
								<span class="s4">enum</span><span class="s2">: [</span><span class="s3">&quot;first&quot;</span><span class="s2">],</span>
							<span class="s2">},</span>
						<span class="s2">],</span>
					<span class="s2">},</span>
				<span class="s2">},</span>
				<span class="s2">additionalProperties: </span><span class="s4">false</span><span class="s2">,</span>
			<span class="s2">},</span>
		<span class="s2">],</span>
		<span class="s2">messages: {</span>
			<span class="s2">expected:</span>
				<span class="s3">&quot;Expected indentation of {{expected}} but found {{actual}}.&quot;</span><span class="s2">,</span>
		<span class="s2">},</span>
	<span class="s2">},</span>

	<span class="s2">create(context) {</span>
		<span class="s4">const </span><span class="s2">DEFAULT_VARIABLE_INDENT = </span><span class="s5">1</span><span class="s2">;</span>
		<span class="s4">const </span><span class="s2">DEFAULT_PARAMETER_INDENT = </span><span class="s4">null</span><span class="s2">; </span><span class="s0">// For backwards compatibility, don't check parameter indentation unless specified in the config</span>
		<span class="s4">const </span><span class="s2">DEFAULT_FUNCTION_BODY_INDENT = </span><span class="s5">1</span><span class="s2">;</span>

		<span class="s4">let </span><span class="s2">indentType = </span><span class="s3">&quot;space&quot;</span><span class="s2">;</span>
		<span class="s4">let </span><span class="s2">indentSize = </span><span class="s5">4</span><span class="s2">;</span>
		<span class="s4">const </span><span class="s2">options = {</span>
			<span class="s2">SwitchCase: </span><span class="s5">0</span><span class="s2">,</span>
			<span class="s2">VariableDeclarator: {</span>
				<span class="s4">var</span><span class="s2">: DEFAULT_VARIABLE_INDENT,</span>
				<span class="s4">let</span><span class="s2">: DEFAULT_VARIABLE_INDENT,</span>
				<span class="s4">const</span><span class="s2">: DEFAULT_VARIABLE_INDENT,</span>
			<span class="s2">},</span>
			<span class="s2">outerIIFEBody: </span><span class="s4">null</span><span class="s2">,</span>
			<span class="s2">FunctionDeclaration: {</span>
				<span class="s2">parameters: DEFAULT_PARAMETER_INDENT,</span>
				<span class="s2">body: DEFAULT_FUNCTION_BODY_INDENT,</span>
			<span class="s2">},</span>
			<span class="s2">FunctionExpression: {</span>
				<span class="s2">parameters: DEFAULT_PARAMETER_INDENT,</span>
				<span class="s2">body: DEFAULT_FUNCTION_BODY_INDENT,</span>
			<span class="s2">},</span>
			<span class="s2">CallExpression: {</span>
				<span class="s2">arguments: DEFAULT_PARAMETER_INDENT,</span>
			<span class="s2">},</span>
			<span class="s2">ArrayExpression: </span><span class="s5">1</span><span class="s2">,</span>
			<span class="s2">ObjectExpression: </span><span class="s5">1</span><span class="s2">,</span>
		<span class="s2">};</span>

		<span class="s4">const </span><span class="s2">sourceCode = context.sourceCode;</span>

		<span class="s4">if </span><span class="s2">(context.options.length) {</span>
			<span class="s4">if </span><span class="s2">(context.options[</span><span class="s5">0</span><span class="s2">] === </span><span class="s3">&quot;tab&quot;</span><span class="s2">) {</span>
				<span class="s2">indentSize = </span><span class="s5">1</span><span class="s2">;</span>
				<span class="s2">indentType = </span><span class="s3">&quot;tab&quot;</span><span class="s2">;</span>
			<span class="s2">} </span><span class="s0">/* c8 ignore start */ </span><span class="s4">else if </span><span class="s2">(</span>
				<span class="s4">typeof </span><span class="s2">context.options[</span><span class="s5">0</span><span class="s2">] === </span><span class="s3">&quot;number&quot;</span>
			<span class="s2">) {</span>
				<span class="s2">indentSize = context.options[</span><span class="s5">0</span><span class="s2">];</span>
				<span class="s2">indentType = </span><span class="s3">&quot;space&quot;</span><span class="s2">;</span>
			<span class="s2">} </span><span class="s0">/* c8 ignore stop */</span>

			<span class="s4">if </span><span class="s2">(context.options[</span><span class="s5">1</span><span class="s2">]) {</span>
				<span class="s4">const </span><span class="s2">opts = context.options[</span><span class="s5">1</span><span class="s2">];</span>

				<span class="s2">options.SwitchCase = opts.SwitchCase || </span><span class="s5">0</span><span class="s2">;</span>
				<span class="s4">const </span><span class="s2">variableDeclaratorRules = opts.VariableDeclarator;</span>

				<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">variableDeclaratorRules === </span><span class="s3">&quot;number&quot;</span><span class="s2">) {</span>
					<span class="s2">options.VariableDeclarator = {</span>
						<span class="s4">var</span><span class="s2">: variableDeclaratorRules,</span>
						<span class="s4">let</span><span class="s2">: variableDeclaratorRules,</span>
						<span class="s4">const</span><span class="s2">: variableDeclaratorRules,</span>
					<span class="s2">};</span>
				<span class="s2">} </span><span class="s4">else if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">variableDeclaratorRules === </span><span class="s3">&quot;object&quot;</span><span class="s2">) {</span>
					<span class="s2">Object.assign(</span>
						<span class="s2">options.VariableDeclarator,</span>
						<span class="s2">variableDeclaratorRules,</span>
					<span class="s2">);</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">opts.outerIIFEBody === </span><span class="s3">&quot;number&quot;</span><span class="s2">) {</span>
					<span class="s2">options.outerIIFEBody = opts.outerIIFEBody;</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">opts.MemberExpression === </span><span class="s3">&quot;number&quot;</span><span class="s2">) {</span>
					<span class="s2">options.MemberExpression = opts.MemberExpression;</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">opts.FunctionDeclaration === </span><span class="s3">&quot;object&quot;</span><span class="s2">) {</span>
					<span class="s2">Object.assign(</span>
						<span class="s2">options.FunctionDeclaration,</span>
						<span class="s2">opts.FunctionDeclaration,</span>
					<span class="s2">);</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">opts.FunctionExpression === </span><span class="s3">&quot;object&quot;</span><span class="s2">) {</span>
					<span class="s2">Object.assign(</span>
						<span class="s2">options.FunctionExpression,</span>
						<span class="s2">opts.FunctionExpression,</span>
					<span class="s2">);</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">opts.CallExpression === </span><span class="s3">&quot;object&quot;</span><span class="s2">) {</span>
					<span class="s2">Object.assign(options.CallExpression, opts.CallExpression);</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(</span>
					<span class="s4">typeof </span><span class="s2">opts.ArrayExpression === </span><span class="s3">&quot;number&quot; </span><span class="s2">||</span>
					<span class="s4">typeof </span><span class="s2">opts.ArrayExpression === </span><span class="s3">&quot;string&quot;</span>
				<span class="s2">) {</span>
					<span class="s2">options.ArrayExpression = opts.ArrayExpression;</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(</span>
					<span class="s4">typeof </span><span class="s2">opts.ObjectExpression === </span><span class="s3">&quot;number&quot; </span><span class="s2">||</span>
					<span class="s4">typeof </span><span class="s2">opts.ObjectExpression === </span><span class="s3">&quot;string&quot;</span>
				<span class="s2">) {</span>
					<span class="s2">options.ObjectExpression = opts.ObjectExpression;</span>
				<span class="s2">}</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s4">const </span><span class="s2">caseIndentStore = {};</span>

		<span class="s0">/**</span>
		 <span class="s0">* Creates an error message for a line, given the expected/actual indentation.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} expectedAmount The expected amount of indentation characters for this line</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} actualSpaces The actual number of indentation spaces that were found on this line</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} actualTabs The actual number of indentation tabs that were found on this line</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string} An error message for this line</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">createErrorMessageData(</span>
			<span class="s2">expectedAmount,</span>
			<span class="s2">actualSpaces,</span>
			<span class="s2">actualTabs,</span>
		<span class="s2">) {</span>
			<span class="s4">const </span><span class="s2">expectedStatement = </span><span class="s3">`</span><span class="s2">${expectedAmount} ${indentType}${expectedAmount === </span><span class="s5">1 </span><span class="s2">? </span><span class="s3">&quot;&quot; </span><span class="s2">: </span><span class="s3">&quot;s&quot;</span><span class="s2">}</span><span class="s3">`</span><span class="s2">; </span><span class="s0">// e.g. &quot;2 tabs&quot;</span>
			<span class="s4">const </span><span class="s2">foundSpacesWord = </span><span class="s3">`space</span><span class="s2">${actualSpaces === </span><span class="s5">1 </span><span class="s2">? </span><span class="s3">&quot;&quot; </span><span class="s2">: </span><span class="s3">&quot;s&quot;</span><span class="s2">}</span><span class="s3">`</span><span class="s2">; </span><span class="s0">// e.g. &quot;space&quot;</span>
			<span class="s4">const </span><span class="s2">foundTabsWord = </span><span class="s3">`tab</span><span class="s2">${actualTabs === </span><span class="s5">1 </span><span class="s2">? </span><span class="s3">&quot;&quot; </span><span class="s2">: </span><span class="s3">&quot;s&quot;</span><span class="s2">}</span><span class="s3">`</span><span class="s2">; </span><span class="s0">// e.g. &quot;tabs&quot;</span>
			<span class="s4">let </span><span class="s2">foundStatement;</span>

			<span class="s4">if </span><span class="s2">(actualSpaces &gt; </span><span class="s5">0 </span><span class="s2">&amp;&amp; actualTabs &gt; </span><span class="s5">0</span><span class="s2">) {</span>
				<span class="s2">foundStatement = </span><span class="s3">`</span><span class="s2">${actualSpaces} ${foundSpacesWord} </span><span class="s3">and </span><span class="s2">${actualTabs} ${foundTabsWord}</span><span class="s3">`</span><span class="s2">; </span><span class="s0">// e.g. &quot;1 space and 2 tabs&quot;</span>
			<span class="s2">} </span><span class="s4">else if </span><span class="s2">(actualSpaces &gt; </span><span class="s5">0</span><span class="s2">) {</span>
				<span class="s0">/* 
                 * Abbreviate the message if the expected indentation is also spaces. 
                 * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces' 
                 */</span>
				<span class="s2">foundStatement =</span>
					<span class="s2">indentType === </span><span class="s3">&quot;space&quot;</span>
						<span class="s2">? actualSpaces</span>
						<span class="s2">: </span><span class="s3">`</span><span class="s2">${actualSpaces} ${foundSpacesWord}</span><span class="s3">`</span><span class="s2">;</span>
			<span class="s2">} </span><span class="s4">else if </span><span class="s2">(actualTabs &gt; </span><span class="s5">0</span><span class="s2">) {</span>
				<span class="s2">foundStatement =</span>
					<span class="s2">indentType === </span><span class="s3">&quot;tab&quot;</span>
						<span class="s2">? actualTabs</span>
						<span class="s2">: </span><span class="s3">`</span><span class="s2">${actualTabs} ${foundTabsWord}</span><span class="s3">`</span><span class="s2">;</span>
			<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
				<span class="s2">foundStatement = </span><span class="s3">&quot;0&quot;</span><span class="s2">;</span>
			<span class="s2">}</span>
			<span class="s4">return </span><span class="s2">{</span>
				<span class="s2">expected: expectedStatement,</span>
				<span class="s2">actual: foundStatement,</span>
			<span class="s2">};</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports a given indent violation</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node Node violating the indent rule</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} needed Expected indentation character count</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} gottenSpaces Indentation space count in the actual node/code</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} gottenTabs Indentation tab count in the actual node/code</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} [loc] Error line and column location</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} isLastNodeCheck Is the error for last node check</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">report(</span>
			<span class="s2">node,</span>
			<span class="s2">needed,</span>
			<span class="s2">gottenSpaces,</span>
			<span class="s2">gottenTabs,</span>
			<span class="s2">loc,</span>
			<span class="s2">isLastNodeCheck,</span>
		<span class="s2">) {</span>
			<span class="s4">if </span><span class="s2">(gottenSpaces &amp;&amp; gottenTabs) {</span>
				<span class="s0">// To avoid conflicts with `no-mixed-spaces-and-tabs`, don't report lines that have both spaces and tabs.</span>
				<span class="s4">return</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s4">const </span><span class="s2">desiredIndent = (indentType === </span><span class="s3">&quot;space&quot; </span><span class="s2">? </span><span class="s3">&quot; &quot; </span><span class="s2">: </span><span class="s3">&quot;</span><span class="s6">\t</span><span class="s3">&quot;</span><span class="s2">).repeat(</span>
				<span class="s2">needed,</span>
			<span class="s2">);</span>

			<span class="s4">const </span><span class="s2">textRange = isLastNodeCheck</span>
				<span class="s2">? [</span>
						<span class="s2">node.range[</span><span class="s5">1</span><span class="s2">] - node.loc.end.column,</span>
						<span class="s2">node.range[</span><span class="s5">1</span><span class="s2">] -</span>
							<span class="s2">node.loc.end.column +</span>
							<span class="s2">gottenSpaces +</span>
							<span class="s2">gottenTabs,</span>
					<span class="s2">]</span>
				<span class="s2">: [</span>
						<span class="s2">node.range[</span><span class="s5">0</span><span class="s2">] - node.loc.start.column,</span>
						<span class="s2">node.range[</span><span class="s5">0</span><span class="s2">] -</span>
							<span class="s2">node.loc.start.column +</span>
							<span class="s2">gottenSpaces +</span>
							<span class="s2">gottenTabs,</span>
					<span class="s2">];</span>

			<span class="s2">context.report({</span>
				<span class="s2">node,</span>
				<span class="s2">loc,</span>
				<span class="s2">messageId: </span><span class="s3">&quot;expected&quot;</span><span class="s2">,</span>
				<span class="s2">data: createErrorMessageData(needed, gottenSpaces, gottenTabs),</span>
				<span class="s2">fix: fixer =&gt; fixer.replaceTextRange(textRange, desiredIndent),</span>
			<span class="s2">});</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Get the actual indent of node</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode|Token} node Node to examine</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} [byLastLine=false] get indent of node's last line</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Object} The node's indent. Contains keys `space` and `tab`, representing the indent of each character. Also</span>
		 <span class="s0">* contains keys `goodChar` and `badChar`, where `goodChar` is the amount of the user's desired indentation character, and</span>
		 <span class="s0">* `badChar` is the amount of the other indentation character.</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">getNodeIndent(node, byLastLine) {</span>
			<span class="s4">const </span><span class="s2">token = byLastLine</span>
				<span class="s2">? sourceCode.getLastToken(node)</span>
				<span class="s2">: sourceCode.getFirstToken(node);</span>
			<span class="s4">const </span><span class="s2">srcCharsBeforeNode = sourceCode</span>
				<span class="s2">.getText(token, token.loc.start.column)</span>
				<span class="s2">.split(</span><span class="s3">&quot;&quot;</span><span class="s2">);</span>
			<span class="s4">const </span><span class="s2">indentChars = srcCharsBeforeNode.slice(</span>
				<span class="s5">0</span><span class="s2">,</span>
				<span class="s2">srcCharsBeforeNode.findIndex(</span>
					<span class="s2">char =&gt; char !== </span><span class="s3">&quot; &quot; </span><span class="s2">&amp;&amp; char !== </span><span class="s3">&quot;</span><span class="s6">\t</span><span class="s3">&quot;</span><span class="s2">,</span>
				<span class="s2">),</span>
			<span class="s2">);</span>
			<span class="s4">const </span><span class="s2">spaces = indentChars.filter(char =&gt; char === </span><span class="s3">&quot; &quot;</span><span class="s2">).length;</span>
			<span class="s4">const </span><span class="s2">tabs = indentChars.filter(char =&gt; char === </span><span class="s3">&quot;</span><span class="s6">\t</span><span class="s3">&quot;</span><span class="s2">).length;</span>

			<span class="s4">return </span><span class="s2">{</span>
				<span class="s2">space: spaces,</span>
				<span class="s2">tab: tabs,</span>
				<span class="s2">goodChar: indentType === </span><span class="s3">&quot;space&quot; </span><span class="s2">? spaces : tabs,</span>
				<span class="s2">badChar: indentType === </span><span class="s3">&quot;space&quot; </span><span class="s2">? tabs : spaces,</span>
			<span class="s2">};</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Checks node is the first in its own start line. By default it looks by start line.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to check</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} [byEndLocation=false] Lookup based on start position or end</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} true if its the first in the its start line</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">isNodeFirstInLine(node, byEndLocation) {</span>
			<span class="s4">const </span><span class="s2">firstToken =</span>
					<span class="s2">byEndLocation === </span><span class="s4">true</span>
						<span class="s2">? sourceCode.getLastToken(node, </span><span class="s5">1</span><span class="s2">)</span>
						<span class="s2">: sourceCode.getTokenBefore(node),</span>
				<span class="s2">startLine =</span>
					<span class="s2">byEndLocation === </span><span class="s4">true</span>
						<span class="s2">? node.loc.end.line</span>
						<span class="s2">: node.loc.start.line,</span>
				<span class="s2">endLine = firstToken ? firstToken.loc.end.line : -</span><span class="s5">1</span><span class="s2">;</span>

			<span class="s4">return </span><span class="s2">startLine !== endLine;</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Check indent for node</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node Node to check</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} neededIndent needed indent</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkNodeIndent(node, neededIndent) {</span>
			<span class="s4">const </span><span class="s2">actualIndent = getNodeIndent(node, </span><span class="s4">false</span><span class="s2">);</span>

			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">node.type !== </span><span class="s3">&quot;ArrayExpression&quot; </span><span class="s2">&amp;&amp;</span>
				<span class="s2">node.type !== </span><span class="s3">&quot;ObjectExpression&quot; </span><span class="s2">&amp;&amp;</span>
				<span class="s2">(actualIndent.goodChar !== neededIndent ||</span>
					<span class="s2">actualIndent.badChar !== </span><span class="s5">0</span><span class="s2">) &amp;&amp;</span>
				<span class="s2">isNodeFirstInLine(node)</span>
			<span class="s2">) {</span>
				<span class="s2">report(</span>
					<span class="s2">node,</span>
					<span class="s2">neededIndent,</span>
					<span class="s2">actualIndent.space,</span>
					<span class="s2">actualIndent.tab,</span>
				<span class="s2">);</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">&quot;IfStatement&quot; </span><span class="s2">&amp;&amp; node.alternate) {</span>
				<span class="s4">const </span><span class="s2">elseToken = sourceCode.getTokenBefore(node.alternate);</span>

				<span class="s2">checkNodeIndent(elseToken, neededIndent);</span>

				<span class="s4">if </span><span class="s2">(!isNodeFirstInLine(node.alternate)) {</span>
					<span class="s2">checkNodeIndent(node.alternate, neededIndent);</span>
				<span class="s2">}</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">&quot;TryStatement&quot; </span><span class="s2">&amp;&amp; node.handler) {</span>
				<span class="s4">const </span><span class="s2">catchToken = sourceCode.getFirstToken(node.handler);</span>

				<span class="s2">checkNodeIndent(catchToken, neededIndent);</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">&quot;TryStatement&quot; </span><span class="s2">&amp;&amp; node.finalizer) {</span>
				<span class="s4">const </span><span class="s2">finallyToken = sourceCode.getTokenBefore(node.finalizer);</span>

				<span class="s2">checkNodeIndent(finallyToken, neededIndent);</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">&quot;DoWhileStatement&quot;</span><span class="s2">) {</span>
				<span class="s4">const </span><span class="s2">whileToken = sourceCode.getTokenAfter(node.body);</span>

				<span class="s2">checkNodeIndent(whileToken, neededIndent);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Check indent for nodes list</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode[]} nodes list of node objects</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} indent needed indent</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkNodesIndent(nodes, indent) {</span>
			<span class="s2">nodes.forEach(node =&gt; checkNodeIndent(node, indent));</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Check last node line indent this detects, that block closed correctly</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node Node to examine</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} lastLineIndent needed indent</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkLastNodeLineIndent(node, lastLineIndent) {</span>
			<span class="s4">const </span><span class="s2">lastToken = sourceCode.getLastToken(node);</span>
			<span class="s4">const </span><span class="s2">endIndent = getNodeIndent(lastToken, </span><span class="s4">true</span><span class="s2">);</span>

			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">(endIndent.goodChar !== lastLineIndent ||</span>
					<span class="s2">endIndent.badChar !== </span><span class="s5">0</span><span class="s2">) &amp;&amp;</span>
				<span class="s2">isNodeFirstInLine(node, </span><span class="s4">true</span><span class="s2">)</span>
			<span class="s2">) {</span>
				<span class="s2">report(</span>
					<span class="s2">node,</span>
					<span class="s2">lastLineIndent,</span>
					<span class="s2">endIndent.space,</span>
					<span class="s2">endIndent.tab,</span>
					<span class="s2">{</span>
						<span class="s2">line: lastToken.loc.start.line,</span>
						<span class="s2">column: lastToken.loc.start.column,</span>
					<span class="s2">},</span>
					<span class="s4">true</span><span class="s2">,</span>
				<span class="s2">);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Check last node line indent this detects, that block closed correctly</span>
		 <span class="s0">* This function for more complicated return statement case, where closing parenthesis may be followed by ';'</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node Node to examine</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} firstLineIndent first line needed indent</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkLastReturnStatementLineIndent(node, firstLineIndent) {</span>
			<span class="s0">/* 
             * in case if return statement ends with ');' we have traverse back to ')' 
             * otherwise we'll measure indent for ';' and replace ')' 
             */</span>
			<span class="s4">const </span><span class="s2">lastToken = sourceCode.getLastToken(</span>
				<span class="s2">node,</span>
				<span class="s2">astUtils.isClosingParenToken,</span>
			<span class="s2">);</span>
			<span class="s4">const </span><span class="s2">textBeforeClosingParenthesis = sourceCode</span>
				<span class="s2">.getText(lastToken, lastToken.loc.start.column)</span>
				<span class="s2">.slice(</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">);</span>

			<span class="s4">if </span><span class="s2">(textBeforeClosingParenthesis.trim()) {</span>
				<span class="s0">// There are tokens before the closing paren, don't report this case</span>
				<span class="s4">return</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s4">const </span><span class="s2">endIndent = getNodeIndent(lastToken, </span><span class="s4">true</span><span class="s2">);</span>

			<span class="s4">if </span><span class="s2">(endIndent.goodChar !== firstLineIndent) {</span>
				<span class="s2">report(</span>
					<span class="s2">node,</span>
					<span class="s2">firstLineIndent,</span>
					<span class="s2">endIndent.space,</span>
					<span class="s2">endIndent.tab,</span>
					<span class="s2">{</span>
						<span class="s2">line: lastToken.loc.start.line,</span>
						<span class="s2">column: lastToken.loc.start.column,</span>
					<span class="s2">},</span>
					<span class="s4">true</span><span class="s2">,</span>
				<span class="s2">);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Check first node line indent is correct</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node Node to examine</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} firstLineIndent needed indent</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkFirstNodeLineIndent(node, firstLineIndent) {</span>
			<span class="s4">const </span><span class="s2">startIndent = getNodeIndent(node, </span><span class="s4">false</span><span class="s2">);</span>

			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">(startIndent.goodChar !== firstLineIndent ||</span>
					<span class="s2">startIndent.badChar !== </span><span class="s5">0</span><span class="s2">) &amp;&amp;</span>
				<span class="s2">isNodeFirstInLine(node)</span>
			<span class="s2">) {</span>
				<span class="s2">report(</span>
					<span class="s2">node,</span>
					<span class="s2">firstLineIndent,</span>
					<span class="s2">startIndent.space,</span>
					<span class="s2">startIndent.tab,</span>
					<span class="s2">{</span>
						<span class="s2">line: node.loc.start.line,</span>
						<span class="s2">column: node.loc.start.column,</span>
					<span class="s2">},</span>
				<span class="s2">);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Returns a parent node of given node based on a specified type</span>
		 <span class="s0">* if not present then return null</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node node to examine</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} type type that is being looked for</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} stopAtList end points for the evaluating code</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ASTNode|void} if found then node otherwise null</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">getParentNodeByType(node, type, stopAtList) {</span>
			<span class="s4">let </span><span class="s2">parent = node.parent;</span>
			<span class="s4">const </span><span class="s2">stopAtSet = </span><span class="s4">new </span><span class="s2">Set(stopAtList || [</span><span class="s3">&quot;Program&quot;</span><span class="s2">]);</span>

			<span class="s4">while </span><span class="s2">(</span>
				<span class="s2">parent.type !== type &amp;&amp;</span>
				<span class="s2">!stopAtSet.has(parent.type) &amp;&amp;</span>
				<span class="s2">parent.type !== </span><span class="s3">&quot;Program&quot;</span>
			<span class="s2">) {</span>
				<span class="s2">parent = parent.parent;</span>
			<span class="s2">}</span>

			<span class="s4">return </span><span class="s2">parent.type === type ? parent : </span><span class="s4">null</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Returns the VariableDeclarator based on the current node</span>
		 <span class="s0">* if not present then return null</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node node to examine</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ASTNode|void} if found then node otherwise null</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">getVariableDeclaratorNode(node) {</span>
			<span class="s4">return </span><span class="s2">getParentNodeByType(node, </span><span class="s3">&quot;VariableDeclarator&quot;</span><span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Check to see if the node is part of the multi-line variable declaration.</span>
		 <span class="s0">* Also if its on the same line as the varNode</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node node to check</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} varNode variable declaration node to check against</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if all the above condition satisfy</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">isNodeInVarOnTop(node, varNode) {</span>
			<span class="s4">return </span><span class="s2">(</span>
				<span class="s2">varNode &amp;&amp;</span>
				<span class="s2">varNode.parent.loc.start.line === node.loc.start.line &amp;&amp;</span>
				<span class="s2">varNode.parent.declarations.length &gt; </span><span class="s5">1</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Check to see if the argument before the callee node is multi-line and</span>
		 <span class="s0">* there should only be 1 argument before the callee node</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node node to check</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if arguments are multi-line</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">isArgBeforeCalleeNodeMultiline(node) {</span>
			<span class="s4">const </span><span class="s2">parent = node.parent;</span>

			<span class="s4">if </span><span class="s2">(parent.arguments.length &gt;= </span><span class="s5">2 </span><span class="s2">&amp;&amp; parent.arguments[</span><span class="s5">1</span><span class="s2">] === node) {</span>
				<span class="s4">return </span><span class="s2">(</span>
					<span class="s2">parent.arguments[</span><span class="s5">0</span><span class="s2">].loc.end.line &gt;</span>
					<span class="s2">parent.arguments[</span><span class="s5">0</span><span class="s2">].loc.start.line</span>
				<span class="s2">);</span>
			<span class="s2">}</span>

			<span class="s4">return false</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Check to see if the node is a file level IIFE</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The function node to check.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the node is the outer IIFE</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">isOuterIIFE(node) {</span>
			<span class="s4">const </span><span class="s2">parent = node.parent;</span>
			<span class="s4">let </span><span class="s2">stmt = parent.parent;</span>

			<span class="s0">/* 
             * Verify that the node is an IIEF 
             */</span>
			<span class="s4">if </span><span class="s2">(parent.type !== </span><span class="s3">&quot;CallExpression&quot; </span><span class="s2">|| parent.callee !== node) {</span>
				<span class="s4">return false</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s0">/* 
             * Navigate legal ancestors to determine whether this IIEF is outer 
             */</span>
			<span class="s4">while </span><span class="s2">(</span>
				<span class="s2">(stmt.type === </span><span class="s3">&quot;UnaryExpression&quot; </span><span class="s2">&amp;&amp;</span>
					<span class="s2">(stmt.operator === </span><span class="s3">&quot;!&quot; </span><span class="s2">||</span>
						<span class="s2">stmt.operator === </span><span class="s3">&quot;~&quot; </span><span class="s2">||</span>
						<span class="s2">stmt.operator === </span><span class="s3">&quot;+&quot; </span><span class="s2">||</span>
						<span class="s2">stmt.operator === </span><span class="s3">&quot;-&quot;</span><span class="s2">)) ||</span>
				<span class="s2">stmt.type === </span><span class="s3">&quot;AssignmentExpression&quot; </span><span class="s2">||</span>
				<span class="s2">stmt.type === </span><span class="s3">&quot;LogicalExpression&quot; </span><span class="s2">||</span>
				<span class="s2">stmt.type === </span><span class="s3">&quot;SequenceExpression&quot; </span><span class="s2">||</span>
				<span class="s2">stmt.type === </span><span class="s3">&quot;VariableDeclarator&quot;</span>
			<span class="s2">) {</span>
				<span class="s2">stmt = stmt.parent;</span>
			<span class="s2">}</span>

			<span class="s4">return </span><span class="s2">(</span>
				<span class="s2">(stmt.type === </span><span class="s3">&quot;ExpressionStatement&quot; </span><span class="s2">||</span>
					<span class="s2">stmt.type === </span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s2">) &amp;&amp;</span>
				<span class="s2">stmt.parent &amp;&amp;</span>
				<span class="s2">stmt.parent.type === </span><span class="s3">&quot;Program&quot;</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Check indent for function block content</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node A BlockStatement node that is inside of a function.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkIndentInFunctionBlock(node) {</span>
			<span class="s0">/* 
             * Search first caller in chain. 
             * Ex.: 
             * 
             * Models &lt;- Identifier 
             *   .User 
             *   .find() 
             *   .exec(function() { 
             *   // function body 
             * }); 
             * 
             * Looks for 'Models' 
             */</span>
			<span class="s4">const </span><span class="s2">calleeNode = node.parent; </span><span class="s0">// FunctionExpression</span>
			<span class="s4">let </span><span class="s2">indent;</span>

			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">calleeNode.parent &amp;&amp;</span>
				<span class="s2">(calleeNode.parent.type === </span><span class="s3">&quot;Property&quot; </span><span class="s2">||</span>
					<span class="s2">calleeNode.parent.type === </span><span class="s3">&quot;ArrayExpression&quot;</span><span class="s2">)</span>
			<span class="s2">) {</span>
				<span class="s0">// If function is part of array or object, comma can be put at left</span>
				<span class="s2">indent = getNodeIndent(calleeNode, </span><span class="s4">false</span><span class="s2">).goodChar;</span>
			<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
				<span class="s0">// If function is standalone, simple calculate indent</span>
				<span class="s2">indent = getNodeIndent(calleeNode).goodChar;</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(calleeNode.parent.type === </span><span class="s3">&quot;CallExpression&quot;</span><span class="s2">) {</span>
				<span class="s4">const </span><span class="s2">calleeParent = calleeNode.parent;</span>

				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">calleeNode.type !== </span><span class="s3">&quot;FunctionExpression&quot; </span><span class="s2">&amp;&amp;</span>
					<span class="s2">calleeNode.type !== </span><span class="s3">&quot;ArrowFunctionExpression&quot;</span>
				<span class="s2">) {</span>
					<span class="s4">if </span><span class="s2">(</span>
						<span class="s2">calleeParent &amp;&amp;</span>
						<span class="s2">calleeParent.loc.start.line &lt; node.loc.start.line</span>
					<span class="s2">) {</span>
						<span class="s2">indent = getNodeIndent(calleeParent).goodChar;</span>
					<span class="s2">}</span>
				<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
					<span class="s4">if </span><span class="s2">(</span>
						<span class="s2">isArgBeforeCalleeNodeMultiline(calleeNode) &amp;&amp;</span>
						<span class="s2">calleeParent.callee.loc.start.line ===</span>
							<span class="s2">calleeParent.callee.loc.end.line &amp;&amp;</span>
						<span class="s2">!isNodeFirstInLine(calleeNode)</span>
					<span class="s2">) {</span>
						<span class="s2">indent = getNodeIndent(calleeParent).goodChar;</span>
					<span class="s2">}</span>
				<span class="s2">}</span>
			<span class="s2">}</span>

			<span class="s0">/* 
             * function body indent should be indent + indent size, unless this 
             * is a FunctionDeclaration, FunctionExpression, or outer IIFE and the corresponding options are enabled. 
             */</span>
			<span class="s4">let </span><span class="s2">functionOffset = indentSize;</span>

			<span class="s4">if </span><span class="s2">(options.outerIIFEBody !== </span><span class="s4">null </span><span class="s2">&amp;&amp; isOuterIIFE(calleeNode)) {</span>
				<span class="s2">functionOffset = options.outerIIFEBody * indentSize;</span>
			<span class="s2">} </span><span class="s4">else if </span><span class="s2">(calleeNode.type === </span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s2">) {</span>
				<span class="s2">functionOffset = options.FunctionExpression.body * indentSize;</span>
			<span class="s2">} </span><span class="s4">else if </span><span class="s2">(calleeNode.type === </span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s2">) {</span>
				<span class="s2">functionOffset = options.FunctionDeclaration.body * indentSize;</span>
			<span class="s2">}</span>
			<span class="s2">indent += functionOffset;</span>

			<span class="s0">// check if the node is inside a variable</span>
			<span class="s4">const </span><span class="s2">parentVarNode = getVariableDeclaratorNode(node);</span>

			<span class="s4">if </span><span class="s2">(parentVarNode &amp;&amp; isNodeInVarOnTop(node, parentVarNode)) {</span>
				<span class="s2">indent +=</span>
					<span class="s2">indentSize *</span>
					<span class="s2">options.VariableDeclarator[parentVarNode.parent.kind];</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(node.body.length &gt; </span><span class="s5">0</span><span class="s2">) {</span>
				<span class="s2">checkNodesIndent(node.body, indent);</span>
			<span class="s2">}</span>

			<span class="s2">checkLastNodeLineIndent(node, indent - functionOffset);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Checks if the given node starts and ends on the same line</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to check</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} Whether or not the block starts and ends on the same line.</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">isSingleLineNode(node) {</span>
			<span class="s4">const </span><span class="s2">lastToken = sourceCode.getLastToken(node),</span>
				<span class="s2">startLine = node.loc.start.line,</span>
				<span class="s2">endLine = lastToken.loc.end.line;</span>

			<span class="s4">return </span><span class="s2">startLine === endLine;</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Check indent for array block content or object block content</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node node to examine</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkIndentInArrayOrObjectBlock(node) {</span>
			<span class="s0">// Skip inline</span>
			<span class="s4">if </span><span class="s2">(isSingleLineNode(node)) {</span>
				<span class="s4">return</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s4">let </span><span class="s2">elements =</span>
				<span class="s2">node.type === </span><span class="s3">&quot;ArrayExpression&quot;</span>
					<span class="s2">? node.elements</span>
					<span class="s2">: node.properties;</span>

			<span class="s0">// filter out empty elements example would be [ , 2] so remove first element as espree considers it as null</span>
			<span class="s2">elements = elements.filter(elem =&gt; elem !== </span><span class="s4">null</span><span class="s2">);</span>

			<span class="s4">let </span><span class="s2">nodeIndent;</span>
			<span class="s4">let </span><span class="s2">elementsIndent;</span>
			<span class="s4">const </span><span class="s2">parentVarNode = getVariableDeclaratorNode(node);</span>

			<span class="s0">// TODO - come up with a better strategy in future</span>
			<span class="s4">if </span><span class="s2">(isNodeFirstInLine(node)) {</span>
				<span class="s4">const </span><span class="s2">parent = node.parent;</span>

				<span class="s2">nodeIndent = getNodeIndent(parent).goodChar;</span>
				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">!parentVarNode ||</span>
					<span class="s2">parentVarNode.loc.start.line !== node.loc.start.line</span>
				<span class="s2">) {</span>
					<span class="s4">if </span><span class="s2">(</span>
						<span class="s2">parent.type !== </span><span class="s3">&quot;VariableDeclarator&quot; </span><span class="s2">||</span>
						<span class="s2">parentVarNode === parentVarNode.parent.declarations[</span><span class="s5">0</span><span class="s2">]</span>
					<span class="s2">) {</span>
						<span class="s4">if </span><span class="s2">(</span>
							<span class="s2">parent.type === </span><span class="s3">&quot;VariableDeclarator&quot; </span><span class="s2">&amp;&amp;</span>
							<span class="s2">parentVarNode.loc.start.line ===</span>
								<span class="s2">parent.loc.start.line</span>
						<span class="s2">) {</span>
							<span class="s2">nodeIndent +=</span>
								<span class="s2">indentSize *</span>
								<span class="s2">options.VariableDeclarator[</span>
									<span class="s2">parentVarNode.parent.kind</span>
								<span class="s2">];</span>
						<span class="s2">} </span><span class="s4">else if </span><span class="s2">(</span>
							<span class="s2">parent.type === </span><span class="s3">&quot;ObjectExpression&quot; </span><span class="s2">||</span>
							<span class="s2">parent.type === </span><span class="s3">&quot;ArrayExpression&quot;</span>
						<span class="s2">) {</span>
							<span class="s4">const </span><span class="s2">parentElements =</span>
								<span class="s2">node.parent.type === </span><span class="s3">&quot;ObjectExpression&quot;</span>
									<span class="s2">? node.parent.properties</span>
									<span class="s2">: node.parent.elements;</span>

							<span class="s4">if </span><span class="s2">(</span>
								<span class="s2">parentElements[</span><span class="s5">0</span><span class="s2">] &amp;&amp;</span>
								<span class="s2">parentElements[</span><span class="s5">0</span><span class="s2">].loc.start.line ===</span>
									<span class="s2">parent.loc.start.line &amp;&amp;</span>
								<span class="s2">parentElements[</span><span class="s5">0</span><span class="s2">].loc.end.line !==</span>
									<span class="s2">parent.loc.start.line</span>
							<span class="s2">) {</span>
								<span class="s0">/* 
                                 * If the first element of the array spans multiple lines, don't increase the expected indentation of the rest. 
                                 * e.g. [{ 
                                 *        foo: 1 
                                 *      }, 
                                 *      { 
                                 *        bar: 1 
                                 *      }] 
                                 * the second object is not indented. 
                                 */</span>
							<span class="s2">} </span><span class="s4">else if </span><span class="s2">(</span>
								<span class="s4">typeof </span><span class="s2">options[parent.type] === </span><span class="s3">&quot;number&quot;</span>
							<span class="s2">) {</span>
								<span class="s2">nodeIndent += options[parent.type] * indentSize;</span>
							<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
								<span class="s2">nodeIndent = parentElements[</span><span class="s5">0</span><span class="s2">].loc.start.column;</span>
							<span class="s2">}</span>
						<span class="s2">} </span><span class="s4">else if </span><span class="s2">(</span>
							<span class="s2">parent.type === </span><span class="s3">&quot;CallExpression&quot; </span><span class="s2">||</span>
							<span class="s2">parent.type === </span><span class="s3">&quot;NewExpression&quot;</span>
						<span class="s2">) {</span>
							<span class="s4">if </span><span class="s2">(</span>
								<span class="s4">typeof </span><span class="s2">options.CallExpression.arguments ===</span>
								<span class="s3">&quot;number&quot;</span>
							<span class="s2">) {</span>
								<span class="s2">nodeIndent +=</span>
									<span class="s2">options.CallExpression.arguments *</span>
									<span class="s2">indentSize;</span>
							<span class="s2">} </span><span class="s4">else if </span><span class="s2">(</span>
								<span class="s2">options.CallExpression.arguments === </span><span class="s3">&quot;first&quot;</span>
							<span class="s2">) {</span>
								<span class="s4">if </span><span class="s2">(parent.arguments.includes(node)) {</span>
									<span class="s2">nodeIndent =</span>
										<span class="s2">parent.arguments[</span><span class="s5">0</span><span class="s2">].loc.start.column;</span>
								<span class="s2">}</span>
							<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
								<span class="s2">nodeIndent += indentSize;</span>
							<span class="s2">}</span>
						<span class="s2">} </span><span class="s4">else if </span><span class="s2">(</span>
							<span class="s2">parent.type === </span><span class="s3">&quot;LogicalExpression&quot; </span><span class="s2">||</span>
							<span class="s2">parent.type === </span><span class="s3">&quot;ArrowFunctionExpression&quot;</span>
						<span class="s2">) {</span>
							<span class="s2">nodeIndent += indentSize;</span>
						<span class="s2">}</span>
					<span class="s2">}</span>
				<span class="s2">}</span>

				<span class="s2">checkFirstNodeLineIndent(node, nodeIndent);</span>
			<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
				<span class="s2">nodeIndent = getNodeIndent(node).goodChar;</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(options[node.type] === </span><span class="s3">&quot;first&quot;</span><span class="s2">) {</span>
				<span class="s2">elementsIndent = elements.length</span>
					<span class="s2">? elements[</span><span class="s5">0</span><span class="s2">].loc.start.column</span>
					<span class="s2">: </span><span class="s5">0</span><span class="s2">; </span><span class="s0">// If there are no elements, elementsIndent doesn't matter.</span>
			<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
				<span class="s2">elementsIndent = nodeIndent + indentSize * options[node.type];</span>
			<span class="s2">}</span>

			<span class="s0">/* 
             * Check if the node is a multiple variable declaration; if so, then 
             * make sure indentation takes that into account. 
             */</span>
			<span class="s4">if </span><span class="s2">(isNodeInVarOnTop(node, parentVarNode)) {</span>
				<span class="s2">elementsIndent +=</span>
					<span class="s2">indentSize *</span>
					<span class="s2">options.VariableDeclarator[parentVarNode.parent.kind];</span>
			<span class="s2">}</span>

			<span class="s2">checkNodesIndent(elements, elementsIndent);</span>

			<span class="s4">if </span><span class="s2">(elements.length &gt; </span><span class="s5">0</span><span class="s2">) {</span>
				<span class="s0">// Skip last block line check if last item in same line</span>
				<span class="s4">if </span><span class="s2">(elements.at(-</span><span class="s5">1</span><span class="s2">).loc.end.line === node.loc.end.line) {</span>
					<span class="s4">return</span><span class="s2">;</span>
				<span class="s2">}</span>
			<span class="s2">}</span>

			<span class="s2">checkLastNodeLineIndent(</span>
				<span class="s2">node,</span>
				<span class="s2">nodeIndent +</span>
					<span class="s2">(isNodeInVarOnTop(node, parentVarNode)</span>
						<span class="s2">? options.VariableDeclarator[</span>
								<span class="s2">parentVarNode.parent.kind</span>
							<span class="s2">] * indentSize</span>
						<span class="s2">: </span><span class="s5">0</span><span class="s2">),</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Check if the node or node body is a BlockStatement or not</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node node to test</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if it or its body is a block statement</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">isNodeBodyBlock(node) {</span>
			<span class="s4">return </span><span class="s2">(</span>
				<span class="s2">node.type === </span><span class="s3">&quot;BlockStatement&quot; </span><span class="s2">||</span>
				<span class="s2">node.type === </span><span class="s3">&quot;ClassBody&quot; </span><span class="s2">||</span>
				<span class="s2">(node.body &amp;&amp; node.body.type === </span><span class="s3">&quot;BlockStatement&quot;</span><span class="s2">) ||</span>
				<span class="s2">(node.consequent &amp;&amp; node.consequent.type === </span><span class="s3">&quot;BlockStatement&quot;</span><span class="s2">)</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Check indentation for blocks</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node node to check</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">blockIndentationCheck(node) {</span>
			<span class="s0">// Skip inline blocks</span>
			<span class="s4">if </span><span class="s2">(isSingleLineNode(node)) {</span>
				<span class="s4">return</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">node.parent &amp;&amp;</span>
				<span class="s2">(node.parent.type === </span><span class="s3">&quot;FunctionExpression&quot; </span><span class="s2">||</span>
					<span class="s2">node.parent.type === </span><span class="s3">&quot;FunctionDeclaration&quot; </span><span class="s2">||</span>
					<span class="s2">node.parent.type === </span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s2">)</span>
			<span class="s2">) {</span>
				<span class="s2">checkIndentInFunctionBlock(node);</span>
				<span class="s4">return</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s4">let </span><span class="s2">indent;</span>
			<span class="s4">let </span><span class="s2">nodesToCheck;</span>

			<span class="s0">/* 
             * For this statements we should check indent from statement beginning, 
             * not from the beginning of the block. 
             */</span>
			<span class="s4">const </span><span class="s2">statementsWithProperties = [</span>
				<span class="s3">&quot;IfStatement&quot;</span><span class="s2">,</span>
				<span class="s3">&quot;WhileStatement&quot;</span><span class="s2">,</span>
				<span class="s3">&quot;ForStatement&quot;</span><span class="s2">,</span>
				<span class="s3">&quot;ForInStatement&quot;</span><span class="s2">,</span>
				<span class="s3">&quot;ForOfStatement&quot;</span><span class="s2">,</span>
				<span class="s3">&quot;DoWhileStatement&quot;</span><span class="s2">,</span>
				<span class="s3">&quot;ClassDeclaration&quot;</span><span class="s2">,</span>
				<span class="s3">&quot;TryStatement&quot;</span><span class="s2">,</span>
			<span class="s2">];</span>

			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">node.parent &amp;&amp;</span>
				<span class="s2">statementsWithProperties.includes(node.parent.type) &amp;&amp;</span>
				<span class="s2">isNodeBodyBlock(node)</span>
			<span class="s2">) {</span>
				<span class="s2">indent = getNodeIndent(node.parent).goodChar;</span>
			<span class="s2">} </span><span class="s4">else if </span><span class="s2">(node.parent &amp;&amp; node.parent.type === </span><span class="s3">&quot;CatchClause&quot;</span><span class="s2">) {</span>
				<span class="s2">indent = getNodeIndent(node.parent.parent).goodChar;</span>
			<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
				<span class="s2">indent = getNodeIndent(node).goodChar;</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">node.type === </span><span class="s3">&quot;IfStatement&quot; </span><span class="s2">&amp;&amp;</span>
				<span class="s2">node.consequent.type !== </span><span class="s3">&quot;BlockStatement&quot;</span>
			<span class="s2">) {</span>
				<span class="s2">nodesToCheck = [node.consequent];</span>
			<span class="s2">} </span><span class="s4">else if </span><span class="s2">(Array.isArray(node.body)) {</span>
				<span class="s2">nodesToCheck = node.body;</span>
			<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
				<span class="s2">nodesToCheck = [node.body];</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(nodesToCheck.length &gt; </span><span class="s5">0</span><span class="s2">) {</span>
				<span class="s2">checkNodesIndent(nodesToCheck, indent + indentSize);</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">&quot;BlockStatement&quot;</span><span class="s2">) {</span>
				<span class="s2">checkLastNodeLineIndent(node, indent);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Filter out the elements which are on the same line of each other or the node.</span>
		 <span class="s0">* basically have only 1 elements from each line except the variable declaration line.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node Variable declaration node</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ASTNode[]} Filtered elements</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">filterOutSameLineVars(node) {</span>
			<span class="s4">return </span><span class="s2">node.declarations.reduce((finalCollection, elem) =&gt; {</span>
				<span class="s4">const </span><span class="s2">lastElem = finalCollection.at(-</span><span class="s5">1</span><span class="s2">);</span>

				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">(elem.loc.start.line !== node.loc.start.line &amp;&amp;</span>
						<span class="s2">!lastElem) ||</span>
					<span class="s2">(lastElem &amp;&amp;</span>
						<span class="s2">lastElem.loc.start.line !== elem.loc.start.line)</span>
				<span class="s2">) {</span>
					<span class="s2">finalCollection.push(elem);</span>
				<span class="s2">}</span>

				<span class="s4">return </span><span class="s2">finalCollection;</span>
			<span class="s2">}, []);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Check indentation for variable declarations</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node node to examine</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkIndentInVariableDeclarations(node) {</span>
			<span class="s4">const </span><span class="s2">elements = filterOutSameLineVars(node);</span>
			<span class="s4">const </span><span class="s2">nodeIndent = getNodeIndent(node).goodChar;</span>
			<span class="s4">const </span><span class="s2">lastElement = elements.at(-</span><span class="s5">1</span><span class="s2">);</span>

			<span class="s4">const </span><span class="s2">elementsIndent =</span>
				<span class="s2">nodeIndent + indentSize * options.VariableDeclarator[node.kind];</span>

			<span class="s2">checkNodesIndent(elements, elementsIndent);</span>

			<span class="s0">// Only check the last line if there is any token after the last item</span>
			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">sourceCode.getLastToken(node).loc.end.line &lt;=</span>
				<span class="s2">lastElement.loc.end.line</span>
			<span class="s2">) {</span>
				<span class="s4">return</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s4">const </span><span class="s2">tokenBeforeLastElement =</span>
				<span class="s2">sourceCode.getTokenBefore(lastElement);</span>

			<span class="s4">if </span><span class="s2">(tokenBeforeLastElement.value === </span><span class="s3">&quot;,&quot;</span><span class="s2">) {</span>
				<span class="s0">// Special case for comma-first syntax where the semicolon is indented</span>
				<span class="s2">checkLastNodeLineIndent(</span>
					<span class="s2">node,</span>
					<span class="s2">getNodeIndent(tokenBeforeLastElement).goodChar,</span>
				<span class="s2">);</span>
			<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
				<span class="s2">checkLastNodeLineIndent(node, elementsIndent - indentSize);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Check and decide whether to check for indentation for blockless nodes</span>
		 <span class="s0">* Scenarios are for or while statements without braces around them</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node node to examine</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">blockLessNodes(node) {</span>
			<span class="s4">if </span><span class="s2">(node.body.type !== </span><span class="s3">&quot;BlockStatement&quot;</span><span class="s2">) {</span>
				<span class="s2">blockIndentationCheck(node);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Returns the expected indentation for the case statement</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node node to examine</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} [providedSwitchIndent] indent for switch statement</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{number} indent size</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">expectedCaseIndent(node, providedSwitchIndent) {</span>
			<span class="s4">const </span><span class="s2">switchNode =</span>
				<span class="s2">node.type === </span><span class="s3">&quot;SwitchStatement&quot; </span><span class="s2">? node : node.parent;</span>
			<span class="s4">const </span><span class="s2">switchIndent =</span>
				<span class="s4">typeof </span><span class="s2">providedSwitchIndent === </span><span class="s3">&quot;undefined&quot;</span>
					<span class="s2">? getNodeIndent(switchNode).goodChar</span>
					<span class="s2">: providedSwitchIndent;</span>
			<span class="s4">let </span><span class="s2">caseIndent;</span>

			<span class="s4">if </span><span class="s2">(caseIndentStore[switchNode.loc.start.line]) {</span>
				<span class="s4">return </span><span class="s2">caseIndentStore[switchNode.loc.start.line];</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(switchNode.cases.length &gt; </span><span class="s5">0 </span><span class="s2">&amp;&amp; options.SwitchCase === </span><span class="s5">0</span><span class="s2">) {</span>
				<span class="s2">caseIndent = switchIndent;</span>
			<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
				<span class="s2">caseIndent = switchIndent + indentSize * options.SwitchCase;</span>
			<span class="s2">}</span>

			<span class="s2">caseIndentStore[switchNode.loc.start.line] = caseIndent;</span>
			<span class="s4">return </span><span class="s2">caseIndent;</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Checks whether a return statement is wrapped in ()</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node node to examine</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} the result</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">isWrappedInParenthesis(node) {</span>
			<span class="s4">const </span><span class="s2">regex = </span><span class="s7">/^return\s*\(\s*\)/u</span><span class="s2">;</span>

			<span class="s4">const </span><span class="s2">statementWithoutArgument = sourceCode</span>
				<span class="s2">.getText(node)</span>
				<span class="s2">.replace(sourceCode.getText(node.argument), </span><span class="s3">&quot;&quot;</span><span class="s2">);</span>

			<span class="s4">return </span><span class="s2">regex.test(statementWithoutArgument);</span>
		<span class="s2">}</span>

		<span class="s4">return </span><span class="s2">{</span>
			<span class="s2">Program(node) {</span>
				<span class="s4">if </span><span class="s2">(node.body.length &gt; </span><span class="s5">0</span><span class="s2">) {</span>
					<span class="s0">// Root nodes should have no indent</span>
					<span class="s2">checkNodesIndent(node.body, getNodeIndent(node).goodChar);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">ClassBody: blockIndentationCheck,</span>

			<span class="s2">BlockStatement: blockIndentationCheck,</span>

			<span class="s2">WhileStatement: blockLessNodes,</span>

			<span class="s2">ForStatement: blockLessNodes,</span>

			<span class="s2">ForInStatement: blockLessNodes,</span>

			<span class="s2">ForOfStatement: blockLessNodes,</span>

			<span class="s2">DoWhileStatement: blockLessNodes,</span>

			<span class="s2">IfStatement(node) {</span>
				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">node.consequent.type !== </span><span class="s3">&quot;BlockStatement&quot; </span><span class="s2">&amp;&amp;</span>
					<span class="s2">node.consequent.loc.start.line &gt; node.loc.start.line</span>
				<span class="s2">) {</span>
					<span class="s2">blockIndentationCheck(node);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">VariableDeclaration(node) {</span>
				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">node.declarations.at(-</span><span class="s5">1</span><span class="s2">).loc.start.line &gt;</span>
					<span class="s2">node.declarations[</span><span class="s5">0</span><span class="s2">].loc.start.line</span>
				<span class="s2">) {</span>
					<span class="s2">checkIndentInVariableDeclarations(node);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">ObjectExpression(node) {</span>
				<span class="s2">checkIndentInArrayOrObjectBlock(node);</span>
			<span class="s2">},</span>

			<span class="s2">ArrayExpression(node) {</span>
				<span class="s2">checkIndentInArrayOrObjectBlock(node);</span>
			<span class="s2">},</span>

			<span class="s2">MemberExpression(node) {</span>
				<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">options.MemberExpression === </span><span class="s3">&quot;undefined&quot;</span><span class="s2">) {</span>
					<span class="s4">return</span><span class="s2">;</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(isSingleLineNode(node)) {</span>
					<span class="s4">return</span><span class="s2">;</span>
				<span class="s2">}</span>

				<span class="s0">/* 
                 * The typical layout of variable declarations and assignments 
                 * alter the expectation of correct indentation. Skip them. 
                 * TODO: Add appropriate configuration options for variable 
                 * declarations and assignments. 
                 */</span>
				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">getParentNodeByType(node, </span><span class="s3">&quot;VariableDeclarator&quot;</span><span class="s2">, [</span>
						<span class="s3">&quot;FunctionExpression&quot;</span><span class="s2">,</span>
						<span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s2">,</span>
					<span class="s2">])</span>
				<span class="s2">) {</span>
					<span class="s4">return</span><span class="s2">;</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">getParentNodeByType(node, </span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s2">, [</span>
						<span class="s3">&quot;FunctionExpression&quot;</span><span class="s2">,</span>
					<span class="s2">])</span>
				<span class="s2">) {</span>
					<span class="s4">return</span><span class="s2">;</span>
				<span class="s2">}</span>

				<span class="s4">const </span><span class="s2">propertyIndent =</span>
					<span class="s2">getNodeIndent(node).goodChar +</span>
					<span class="s2">indentSize * options.MemberExpression;</span>

				<span class="s4">const </span><span class="s2">checkNodes = [node.property];</span>

				<span class="s4">const </span><span class="s2">dot = sourceCode.getTokenBefore(node.property);</span>

				<span class="s4">if </span><span class="s2">(dot.type === </span><span class="s3">&quot;Punctuator&quot; </span><span class="s2">&amp;&amp; dot.value === </span><span class="s3">&quot;.&quot;</span><span class="s2">) {</span>
					<span class="s2">checkNodes.push(dot);</span>
				<span class="s2">}</span>

				<span class="s2">checkNodesIndent(checkNodes, propertyIndent);</span>
			<span class="s2">},</span>

			<span class="s2">SwitchStatement(node) {</span>
				<span class="s0">// Switch is not a 'BlockStatement'</span>
				<span class="s4">const </span><span class="s2">switchIndent = getNodeIndent(node).goodChar;</span>
				<span class="s4">const </span><span class="s2">caseIndent = expectedCaseIndent(node, switchIndent);</span>

				<span class="s2">checkNodesIndent(node.cases, caseIndent);</span>

				<span class="s2">checkLastNodeLineIndent(node, switchIndent);</span>
			<span class="s2">},</span>

			<span class="s2">SwitchCase(node) {</span>
				<span class="s0">// Skip inline cases</span>
				<span class="s4">if </span><span class="s2">(isSingleLineNode(node)) {</span>
					<span class="s4">return</span><span class="s2">;</span>
				<span class="s2">}</span>
				<span class="s4">const </span><span class="s2">caseIndent = expectedCaseIndent(node);</span>

				<span class="s2">checkNodesIndent(node.consequent, caseIndent + indentSize);</span>
			<span class="s2">},</span>

			<span class="s2">FunctionDeclaration(node) {</span>
				<span class="s4">if </span><span class="s2">(isSingleLineNode(node)) {</span>
					<span class="s4">return</span><span class="s2">;</span>
				<span class="s2">}</span>
				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">options.FunctionDeclaration.parameters === </span><span class="s3">&quot;first&quot; </span><span class="s2">&amp;&amp;</span>
					<span class="s2">node.params.length</span>
				<span class="s2">) {</span>
					<span class="s2">checkNodesIndent(</span>
						<span class="s2">node.params.slice(</span><span class="s5">1</span><span class="s2">),</span>
						<span class="s2">node.params[</span><span class="s5">0</span><span class="s2">].loc.start.column,</span>
					<span class="s2">);</span>
				<span class="s2">} </span><span class="s4">else if </span><span class="s2">(options.FunctionDeclaration.parameters !== </span><span class="s4">null</span><span class="s2">) {</span>
					<span class="s2">checkNodesIndent(</span>
						<span class="s2">node.params,</span>
						<span class="s2">getNodeIndent(node).goodChar +</span>
							<span class="s2">indentSize * options.FunctionDeclaration.parameters,</span>
					<span class="s2">);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">FunctionExpression(node) {</span>
				<span class="s4">if </span><span class="s2">(isSingleLineNode(node)) {</span>
					<span class="s4">return</span><span class="s2">;</span>
				<span class="s2">}</span>
				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">options.FunctionExpression.parameters === </span><span class="s3">&quot;first&quot; </span><span class="s2">&amp;&amp;</span>
					<span class="s2">node.params.length</span>
				<span class="s2">) {</span>
					<span class="s2">checkNodesIndent(</span>
						<span class="s2">node.params.slice(</span><span class="s5">1</span><span class="s2">),</span>
						<span class="s2">node.params[</span><span class="s5">0</span><span class="s2">].loc.start.column,</span>
					<span class="s2">);</span>
				<span class="s2">} </span><span class="s4">else if </span><span class="s2">(options.FunctionExpression.parameters !== </span><span class="s4">null</span><span class="s2">) {</span>
					<span class="s2">checkNodesIndent(</span>
						<span class="s2">node.params,</span>
						<span class="s2">getNodeIndent(node).goodChar +</span>
							<span class="s2">indentSize * options.FunctionExpression.parameters,</span>
					<span class="s2">);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">ReturnStatement(node) {</span>
				<span class="s4">if </span><span class="s2">(isSingleLineNode(node)) {</span>
					<span class="s4">return</span><span class="s2">;</span>
				<span class="s2">}</span>

				<span class="s4">const </span><span class="s2">firstLineIndent = getNodeIndent(node).goodChar;</span>

				<span class="s0">// in case if return statement is wrapped in parenthesis</span>
				<span class="s4">if </span><span class="s2">(isWrappedInParenthesis(node)) {</span>
					<span class="s2">checkLastReturnStatementLineIndent(node, firstLineIndent);</span>
				<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
					<span class="s2">checkNodeIndent(node, firstLineIndent);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">CallExpression(node) {</span>
				<span class="s4">if </span><span class="s2">(isSingleLineNode(node)) {</span>
					<span class="s4">return</span><span class="s2">;</span>
				<span class="s2">}</span>
				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">options.CallExpression.arguments === </span><span class="s3">&quot;first&quot; </span><span class="s2">&amp;&amp;</span>
					<span class="s2">node.arguments.length</span>
				<span class="s2">) {</span>
					<span class="s2">checkNodesIndent(</span>
						<span class="s2">node.arguments.slice(</span><span class="s5">1</span><span class="s2">),</span>
						<span class="s2">node.arguments[</span><span class="s5">0</span><span class="s2">].loc.start.column,</span>
					<span class="s2">);</span>
				<span class="s2">} </span><span class="s4">else if </span><span class="s2">(options.CallExpression.arguments !== </span><span class="s4">null</span><span class="s2">) {</span>
					<span class="s2">checkNodesIndent(</span>
						<span class="s2">node.arguments,</span>
						<span class="s2">getNodeIndent(node).goodChar +</span>
							<span class="s2">indentSize * options.CallExpression.arguments,</span>
					<span class="s2">);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>
		<span class="s2">};</span>
	<span class="s2">},</span>
<span class="s2">};</span>
</pre>
</body>
</html>