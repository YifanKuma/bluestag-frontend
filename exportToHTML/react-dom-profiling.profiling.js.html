<html>
<head>
<title>react-dom-profiling.profiling.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #1750eb;}
.s6 { color: #0037a6;}
.s7 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
react-dom-profiling.profiling.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@license </span><span class="s0">React</span>
 <span class="s0">* react-dom-profiling.profiling.js</span>
 <span class="s0">*</span>
 <span class="s0">* Copyright (c) Meta Platforms, Inc. and affiliates.</span>
 <span class="s0">*</span>
 <span class="s0">* This source code is licensed under the MIT license found in the</span>
 <span class="s0">* LICENSE file in the root directory of this source tree.</span>
 <span class="s0">*/</span>

<span class="s0">/* 
 Modernizr 3.0.0pre (Custom Build) | MIT 
*/</span>
<span class="s3">&quot;use strict&quot;</span><span class="s2">;</span>
<span class="s3">&quot;undefined&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">__REACT_DEVTOOLS_GLOBAL_HOOK__ &amp;&amp;</span>
  <span class="s3">&quot;function&quot; </span><span class="s2">===</span>
    <span class="s4">typeof </span><span class="s2">__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &amp;&amp;</span>
  <span class="s2">__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());</span>
<span class="s4">var </span><span class="s2">Scheduler = require(</span><span class="s3">&quot;scheduler&quot;</span><span class="s2">),</span>
  <span class="s2">React = require(</span><span class="s3">&quot;react&quot;</span><span class="s2">),</span>
  <span class="s2">ReactDOM = require(</span><span class="s3">&quot;react-dom&quot;</span><span class="s2">);</span>
<span class="s4">function </span><span class="s2">formatProdErrorMessage(code) {</span>
  <span class="s4">var </span><span class="s2">url = </span><span class="s3">&quot;https://react.dev/errors/&quot; </span><span class="s2">+ code;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">1 </span><span class="s2">&lt; arguments.length) {</span>
    <span class="s2">url += </span><span class="s3">&quot;?args[]=&quot; </span><span class="s2">+ encodeURIComponent(arguments[</span><span class="s5">1</span><span class="s2">]);</span>
    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">2</span><span class="s2">; i &lt; arguments.length; i++)</span>
      <span class="s2">url += </span><span class="s3">&quot;&amp;args[]=&quot; </span><span class="s2">+ encodeURIComponent(arguments[i]);</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">(</span>
    <span class="s3">&quot;Minified React error #&quot; </span><span class="s2">+</span>
    <span class="s2">code +</span>
    <span class="s3">&quot;; visit &quot; </span><span class="s2">+</span>
    <span class="s2">url +</span>
    <span class="s3">&quot; for the full message or use the non-minified dev environment for full errors and additional helpful warnings.&quot;</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">isValidContainer(node) {</span>
  <span class="s4">return </span><span class="s2">!(</span>
    <span class="s2">!node ||</span>
    <span class="s2">(</span><span class="s5">1 </span><span class="s2">!== node.nodeType &amp;&amp; </span><span class="s5">9 </span><span class="s2">!== node.nodeType &amp;&amp; </span><span class="s5">11 </span><span class="s2">!== node.nodeType)</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getNearestMountedFiber(fiber) {</span>
  <span class="s4">var </span><span class="s2">node = fiber,</span>
    <span class="s2">nearestMounted = fiber;</span>
  <span class="s4">if </span><span class="s2">(fiber.alternate) </span><span class="s4">for </span><span class="s2">(; node.return; ) node = node.return;</span>
  <span class="s4">else </span><span class="s2">{</span>
    <span class="s2">fiber = node;</span>
    <span class="s4">do</span>
      <span class="s2">(node = fiber),</span>
        <span class="s5">0 </span><span class="s2">!== (node.flags &amp; </span><span class="s5">4098</span><span class="s2">) &amp;&amp; (nearestMounted = node.return),</span>
        <span class="s2">(fiber = node.return);</span>
    <span class="s4">while </span><span class="s2">(fiber);</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s5">3 </span><span class="s2">=== node.tag ? nearestMounted : </span><span class="s4">null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getSuspenseInstanceFromFiber(fiber) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">13 </span><span class="s2">=== fiber.tag) {</span>
    <span class="s4">var </span><span class="s2">suspenseState = fiber.memoizedState;</span>
    <span class="s4">null </span><span class="s2">=== suspenseState &amp;&amp;</span>
      <span class="s2">((fiber = fiber.alternate),</span>
      <span class="s4">null </span><span class="s2">!== fiber &amp;&amp; (suspenseState = fiber.memoizedState));</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== suspenseState) </span><span class="s4">return </span><span class="s2">suspenseState.dehydrated;</span>
  <span class="s2">}</span>
  <span class="s4">return null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">assertIsMounted(fiber) {</span>
  <span class="s4">if </span><span class="s2">(getNearestMountedFiber(fiber) !== fiber)</span>
    <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">188</span><span class="s2">));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">findCurrentFiberUsingSlowPath(fiber) {</span>
  <span class="s4">var </span><span class="s2">alternate = fiber.alternate;</span>
  <span class="s4">if </span><span class="s2">(!alternate) {</span>
    <span class="s2">alternate = getNearestMountedFiber(fiber);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== alternate) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">188</span><span class="s2">));</span>
    <span class="s4">return </span><span class="s2">alternate !== fiber ? </span><span class="s4">null </span><span class="s2">: fiber;</span>
  <span class="s2">}</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">a = fiber, b = alternate; ; ) {</span>
    <span class="s4">var </span><span class="s2">parentA = a.return;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== parentA) </span><span class="s4">break</span><span class="s2">;</span>
    <span class="s4">var </span><span class="s2">parentB = parentA.alternate;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== parentB) {</span>
      <span class="s2">b = parentA.return;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== b) {</span>
        <span class="s2">a = b;</span>
        <span class="s4">continue</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">if </span><span class="s2">(parentA.child === parentB.child) {</span>
      <span class="s4">for </span><span class="s2">(parentB = parentA.child; parentB; ) {</span>
        <span class="s4">if </span><span class="s2">(parentB === a) </span><span class="s4">return </span><span class="s2">assertIsMounted(parentA), fiber;</span>
        <span class="s4">if </span><span class="s2">(parentB === b) </span><span class="s4">return </span><span class="s2">assertIsMounted(parentA), alternate;</span>
        <span class="s2">parentB = parentB.sibling;</span>
      <span class="s2">}</span>
      <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">188</span><span class="s2">));</span>
    <span class="s2">}</span>
    <span class="s4">if </span><span class="s2">(a.return !== b.return) (a = parentA), (b = parentB);</span>
    <span class="s4">else </span><span class="s2">{</span>
      <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">didFindChild = !</span><span class="s5">1</span><span class="s2">, child$0 = parentA.child; child$0; ) {</span>
        <span class="s4">if </span><span class="s2">(child$0 === a) {</span>
          <span class="s2">didFindChild = !</span><span class="s5">0</span><span class="s2">;</span>
          <span class="s2">a = parentA;</span>
          <span class="s2">b = parentB;</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s4">if </span><span class="s2">(child$0 === b) {</span>
          <span class="s2">didFindChild = !</span><span class="s5">0</span><span class="s2">;</span>
          <span class="s2">b = parentA;</span>
          <span class="s2">a = parentB;</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s2">child$0 = child$0.sibling;</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(!didFindChild) {</span>
        <span class="s4">for </span><span class="s2">(child$0 = parentB.child; child$0; ) {</span>
          <span class="s4">if </span><span class="s2">(child$0 === a) {</span>
            <span class="s2">didFindChild = !</span><span class="s5">0</span><span class="s2">;</span>
            <span class="s2">a = parentB;</span>
            <span class="s2">b = parentA;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s2">}</span>
          <span class="s4">if </span><span class="s2">(child$0 === b) {</span>
            <span class="s2">didFindChild = !</span><span class="s5">0</span><span class="s2">;</span>
            <span class="s2">b = parentB;</span>
            <span class="s2">a = parentA;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s2">}</span>
          <span class="s2">child$0 = child$0.sibling;</span>
        <span class="s2">}</span>
        <span class="s4">if </span><span class="s2">(!didFindChild) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">189</span><span class="s2">));</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">if </span><span class="s2">(a.alternate !== b) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">190</span><span class="s2">));</span>
  <span class="s2">}</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">3 </span><span class="s2">!== a.tag) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">188</span><span class="s2">));</span>
  <span class="s4">return </span><span class="s2">a.stateNode.current === a ? fiber : alternate;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">findCurrentHostFiberImpl(node) {</span>
  <span class="s4">var </span><span class="s2">tag = node.tag;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">5 </span><span class="s2">=== tag || </span><span class="s5">26 </span><span class="s2">=== tag || </span><span class="s5">27 </span><span class="s2">=== tag || </span><span class="s5">6 </span><span class="s2">=== tag) </span><span class="s4">return </span><span class="s2">node;</span>
  <span class="s4">for </span><span class="s2">(node = node.child; </span><span class="s4">null </span><span class="s2">!== node; ) {</span>
    <span class="s2">tag = findCurrentHostFiberImpl(node);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== tag) </span><span class="s4">return </span><span class="s2">tag;</span>
    <span class="s2">node = node.sibling;</span>
  <span class="s2">}</span>
  <span class="s4">return null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">assign = Object.assign,</span>
  <span class="s2">REACT_LEGACY_ELEMENT_TYPE = Symbol.for(</span><span class="s3">&quot;react.element&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_ELEMENT_TYPE = Symbol.for(</span><span class="s3">&quot;react.transitional.element&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_PORTAL_TYPE = Symbol.for(</span><span class="s3">&quot;react.portal&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_FRAGMENT_TYPE = Symbol.for(</span><span class="s3">&quot;react.fragment&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_STRICT_MODE_TYPE = Symbol.for(</span><span class="s3">&quot;react.strict_mode&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_PROFILER_TYPE = Symbol.for(</span><span class="s3">&quot;react.profiler&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_PROVIDER_TYPE = Symbol.for(</span><span class="s3">&quot;react.provider&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_CONSUMER_TYPE = Symbol.for(</span><span class="s3">&quot;react.consumer&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_CONTEXT_TYPE = Symbol.for(</span><span class="s3">&quot;react.context&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_FORWARD_REF_TYPE = Symbol.for(</span><span class="s3">&quot;react.forward_ref&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_SUSPENSE_TYPE = Symbol.for(</span><span class="s3">&quot;react.suspense&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_SUSPENSE_LIST_TYPE = Symbol.for(</span><span class="s3">&quot;react.suspense_list&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_MEMO_TYPE = Symbol.for(</span><span class="s3">&quot;react.memo&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_LAZY_TYPE = Symbol.for(</span><span class="s3">&quot;react.lazy&quot;</span><span class="s2">);</span>
<span class="s2">Symbol.for(</span><span class="s3">&quot;react.scope&quot;</span><span class="s2">);</span>
<span class="s4">var </span><span class="s2">REACT_ACTIVITY_TYPE = Symbol.for(</span><span class="s3">&quot;react.activity&quot;</span><span class="s2">);</span>
<span class="s2">Symbol.for(</span><span class="s3">&quot;react.legacy_hidden&quot;</span><span class="s2">);</span>
<span class="s2">Symbol.for(</span><span class="s3">&quot;react.tracing_marker&quot;</span><span class="s2">);</span>
<span class="s4">var </span><span class="s2">REACT_MEMO_CACHE_SENTINEL = Symbol.for(</span><span class="s3">&quot;react.memo_cache_sentinel&quot;</span><span class="s2">);</span>
<span class="s2">Symbol.for(</span><span class="s3">&quot;react.view_transition&quot;</span><span class="s2">);</span>
<span class="s4">var </span><span class="s2">MAYBE_ITERATOR_SYMBOL = Symbol.iterator;</span>
<span class="s4">function </span><span class="s2">getIteratorFn(maybeIterable) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== maybeIterable || </span><span class="s3">&quot;object&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">maybeIterable) </span><span class="s4">return null</span><span class="s2">;</span>
  <span class="s2">maybeIterable =</span>
    <span class="s2">(MAYBE_ITERATOR_SYMBOL &amp;&amp; maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||</span>
    <span class="s2">maybeIterable[</span><span class="s3">&quot;@@iterator&quot;</span><span class="s2">];</span>
  <span class="s4">return </span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">maybeIterable ? maybeIterable : </span><span class="s4">null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">REACT_CLIENT_REFERENCE = Symbol.for(</span><span class="s3">&quot;react.client.reference&quot;</span><span class="s2">);</span>
<span class="s4">function </span><span class="s2">getComponentNameFromType(type) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">== type) </span><span class="s4">return null</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">type)</span>
    <span class="s4">return </span><span class="s2">type.$$typeof === REACT_CLIENT_REFERENCE</span>
      <span class="s2">? </span><span class="s4">null</span>
      <span class="s2">: type.displayName || type.name || </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">type) </span><span class="s4">return </span><span class="s2">type;</span>
  <span class="s4">switch </span><span class="s2">(type) {</span>
    <span class="s4">case </span><span class="s2">REACT_FRAGMENT_TYPE:</span>
      <span class="s4">return </span><span class="s3">&quot;Fragment&quot;</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s2">REACT_PROFILER_TYPE:</span>
      <span class="s4">return </span><span class="s3">&quot;Profiler&quot;</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s2">REACT_STRICT_MODE_TYPE:</span>
      <span class="s4">return </span><span class="s3">&quot;StrictMode&quot;</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s2">REACT_SUSPENSE_TYPE:</span>
      <span class="s4">return </span><span class="s3">&quot;Suspense&quot;</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s2">REACT_SUSPENSE_LIST_TYPE:</span>
      <span class="s4">return </span><span class="s3">&quot;SuspenseList&quot;</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s2">REACT_ACTIVITY_TYPE:</span>
      <span class="s4">return </span><span class="s3">&quot;Activity&quot;</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">type)</span>
    <span class="s4">switch </span><span class="s2">(type.$$typeof) {</span>
      <span class="s4">case </span><span class="s2">REACT_PORTAL_TYPE:</span>
        <span class="s4">return </span><span class="s3">&quot;Portal&quot;</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s2">REACT_CONTEXT_TYPE:</span>
        <span class="s4">return </span><span class="s2">(type.displayName || </span><span class="s3">&quot;Context&quot;</span><span class="s2">) + </span><span class="s3">&quot;.Provider&quot;</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s2">REACT_CONSUMER_TYPE:</span>
        <span class="s4">return </span><span class="s2">(type._context.displayName || </span><span class="s3">&quot;Context&quot;</span><span class="s2">) + </span><span class="s3">&quot;.Consumer&quot;</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s2">REACT_FORWARD_REF_TYPE:</span>
        <span class="s4">var </span><span class="s2">innerType = type.render;</span>
        <span class="s2">type = type.displayName;</span>
        <span class="s2">type ||</span>
          <span class="s2">((type = innerType.displayName || innerType.name || </span><span class="s3">&quot;&quot;</span><span class="s2">),</span>
          <span class="s2">(type = </span><span class="s3">&quot;&quot; </span><span class="s2">!== type ? </span><span class="s3">&quot;ForwardRef(&quot; </span><span class="s2">+ type + </span><span class="s3">&quot;)&quot; </span><span class="s2">: </span><span class="s3">&quot;ForwardRef&quot;</span><span class="s2">));</span>
        <span class="s4">return </span><span class="s2">type;</span>
      <span class="s4">case </span><span class="s2">REACT_MEMO_TYPE:</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(innerType = type.displayName || </span><span class="s4">null</span><span class="s2">),</span>
          <span class="s4">null </span><span class="s2">!== innerType</span>
            <span class="s2">? innerType</span>
            <span class="s2">: getComponentNameFromType(type.type) || </span><span class="s3">&quot;Memo&quot;</span>
        <span class="s2">);</span>
      <span class="s4">case </span><span class="s2">REACT_LAZY_TYPE:</span>
        <span class="s2">innerType = type._payload;</span>
        <span class="s2">type = type._init;</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s4">return </span><span class="s2">getComponentNameFromType(type(innerType));</span>
        <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {}</span>
    <span class="s2">}</span>
  <span class="s4">return null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">isArrayImpl = Array.isArray,</span>
  <span class="s2">ReactSharedInternals =</span>
    <span class="s2">React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,</span>
  <span class="s2">ReactDOMSharedInternals =</span>
    <span class="s2">ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,</span>
  <span class="s2">sharedNotPendingObject = {</span>
    <span class="s2">pending: !</span><span class="s5">1</span><span class="s2">,</span>
    <span class="s2">data: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">method: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">action: </span><span class="s4">null</span>
  <span class="s2">},</span>
  <span class="s2">valueStack = [],</span>
  <span class="s2">index = -</span><span class="s5">1</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">createCursor(defaultValue) {</span>
  <span class="s4">return </span><span class="s2">{ current: defaultValue };</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">pop(cursor) {</span>
  <span class="s5">0 </span><span class="s2">&gt; index ||</span>
    <span class="s2">((cursor.current = valueStack[index]), (valueStack[index] = </span><span class="s4">null</span><span class="s2">), index--);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">push(cursor, value) {</span>
  <span class="s2">index++;</span>
  <span class="s2">valueStack[index] = cursor.current;</span>
  <span class="s2">cursor.current = value;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">contextStackCursor = createCursor(</span><span class="s4">null</span><span class="s2">),</span>
  <span class="s2">contextFiberStackCursor = createCursor(</span><span class="s4">null</span><span class="s2">),</span>
  <span class="s2">rootInstanceStackCursor = createCursor(</span><span class="s4">null</span><span class="s2">),</span>
  <span class="s2">hostTransitionProviderCursor = createCursor(</span><span class="s4">null</span><span class="s2">);</span>
<span class="s4">function </span><span class="s2">pushHostContainer(fiber, nextRootInstance) {</span>
  <span class="s2">push(rootInstanceStackCursor, nextRootInstance);</span>
  <span class="s2">push(contextFiberStackCursor, fiber);</span>
  <span class="s2">push(contextStackCursor, </span><span class="s4">null</span><span class="s2">);</span>
  <span class="s4">switch </span><span class="s2">(nextRootInstance.nodeType) {</span>
    <span class="s4">case </span><span class="s5">9</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">11</span><span class="s2">:</span>
      <span class="s2">fiber = (fiber = nextRootInstance.documentElement)</span>
        <span class="s2">? (fiber = fiber.namespaceURI)</span>
          <span class="s2">? getOwnHostContext(fiber)</span>
          <span class="s2">: </span><span class="s5">0</span>
        <span class="s2">: </span><span class="s5">0</span><span class="s2">;</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">((fiber = nextRootInstance.tagName),</span>
        <span class="s2">(nextRootInstance = nextRootInstance.namespaceURI))</span>
      <span class="s2">)</span>
        <span class="s2">(nextRootInstance = getOwnHostContext(nextRootInstance)),</span>
          <span class="s2">(fiber = getChildHostContextProd(nextRootInstance, fiber));</span>
      <span class="s4">else</span>
        <span class="s4">switch </span><span class="s2">(fiber) {</span>
          <span class="s4">case </span><span class="s3">&quot;svg&quot;</span><span class="s2">:</span>
            <span class="s2">fiber = </span><span class="s5">1</span><span class="s2">;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s3">&quot;math&quot;</span><span class="s2">:</span>
            <span class="s2">fiber = </span><span class="s5">2</span><span class="s2">;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">default</span><span class="s2">:</span>
            <span class="s2">fiber = </span><span class="s5">0</span><span class="s2">;</span>
        <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s2">pop(contextStackCursor);</span>
  <span class="s2">push(contextStackCursor, fiber);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">popHostContainer() {</span>
  <span class="s2">pop(contextStackCursor);</span>
  <span class="s2">pop(contextFiberStackCursor);</span>
  <span class="s2">pop(rootInstanceStackCursor);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">pushHostContext(fiber) {</span>
  <span class="s4">null </span><span class="s2">!== fiber.memoizedState &amp;&amp; push(hostTransitionProviderCursor, fiber);</span>
  <span class="s4">var </span><span class="s2">context = contextStackCursor.current;</span>
  <span class="s4">var </span><span class="s2">JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);</span>
  <span class="s2">context !== JSCompiler_inline_result &amp;&amp;</span>
    <span class="s2">(push(contextFiberStackCursor, fiber),</span>
    <span class="s2">push(contextStackCursor, JSCompiler_inline_result));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">popHostContext(fiber) {</span>
  <span class="s2">contextFiberStackCursor.current === fiber &amp;&amp;</span>
    <span class="s2">(pop(contextStackCursor), pop(contextFiberStackCursor));</span>
  <span class="s2">hostTransitionProviderCursor.current === fiber &amp;&amp;</span>
    <span class="s2">(pop(hostTransitionProviderCursor),</span>
    <span class="s2">(HostTransitionContext._currentValue = sharedNotPendingObject));</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">hasOwnProperty = Object.prototype.hasOwnProperty,</span>
  <span class="s2">scheduleCallback$3 = Scheduler.unstable_scheduleCallback,</span>
  <span class="s2">cancelCallback$1 = Scheduler.unstable_cancelCallback,</span>
  <span class="s2">shouldYield = Scheduler.unstable_shouldYield,</span>
  <span class="s2">requestPaint = Scheduler.unstable_requestPaint,</span>
  <span class="s2">now$1 = Scheduler.unstable_now,</span>
  <span class="s2">getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,</span>
  <span class="s2">ImmediatePriority = Scheduler.unstable_ImmediatePriority,</span>
  <span class="s2">UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,</span>
  <span class="s2">NormalPriority$1 = Scheduler.unstable_NormalPriority,</span>
  <span class="s2">LowPriority = Scheduler.unstable_LowPriority,</span>
  <span class="s2">IdlePriority = Scheduler.unstable_IdlePriority,</span>
  <span class="s2">log$1 = Scheduler.log,</span>
  <span class="s2">unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,</span>
  <span class="s2">rendererID = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">injectedHook = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">injectedProfilingHooks = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">isDevToolsPresent = </span><span class="s3">&quot;undefined&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">__REACT_DEVTOOLS_GLOBAL_HOOK__;</span>
<span class="s4">function </span><span class="s2">setIsStrictModeForDevtools(newIsStrictMode) {</span>
  <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">log$1 &amp;&amp; unstable_setDisableYieldValue(newIsStrictMode);</span>
  <span class="s4">if </span><span class="s2">(injectedHook &amp;&amp; </span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">injectedHook.setStrictMode)</span>
    <span class="s4">try </span><span class="s2">{</span>
      <span class="s2">injectedHook.setStrictMode(rendererID, newIsStrictMode);</span>
    <span class="s2">} </span><span class="s4">catch </span><span class="s2">(err) {}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">markCommitStopped() {</span>
  <span class="s4">null </span><span class="s2">!== injectedProfilingHooks &amp;&amp;</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">injectedProfilingHooks.markCommitStopped &amp;&amp;</span>
    <span class="s2">injectedProfilingHooks.markCommitStopped();</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">markComponentRenderStarted(fiber) {</span>
  <span class="s4">null </span><span class="s2">!== injectedProfilingHooks &amp;&amp;</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">injectedProfilingHooks.markComponentRenderStarted &amp;&amp;</span>
    <span class="s2">injectedProfilingHooks.markComponentRenderStarted(fiber);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">markComponentRenderStopped() {</span>
  <span class="s4">null </span><span class="s2">!== injectedProfilingHooks &amp;&amp;</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">injectedProfilingHooks.markComponentRenderStopped &amp;&amp;</span>
    <span class="s2">injectedProfilingHooks.markComponentRenderStopped();</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">markRenderStarted(lanes) {</span>
  <span class="s4">null </span><span class="s2">!== injectedProfilingHooks &amp;&amp;</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">injectedProfilingHooks.markRenderStarted &amp;&amp;</span>
    <span class="s2">injectedProfilingHooks.markRenderStarted(lanes);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">markRenderStopped() {</span>
  <span class="s4">null </span><span class="s2">!== injectedProfilingHooks &amp;&amp;</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">injectedProfilingHooks.markRenderStopped &amp;&amp;</span>
    <span class="s2">injectedProfilingHooks.markRenderStopped();</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">markStateUpdateScheduled(fiber, lane) {</span>
  <span class="s4">null </span><span class="s2">!== injectedProfilingHooks &amp;&amp;</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">injectedProfilingHooks.markStateUpdateScheduled &amp;&amp;</span>
    <span class="s2">injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,</span>
  <span class="s2">log = Math.log,</span>
  <span class="s2">LN2 = Math.LN2;</span>
<span class="s4">function </span><span class="s2">clz32Fallback(x) {</span>
  <span class="s2">x &gt;&gt;&gt;= </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">return </span><span class="s5">0 </span><span class="s2">=== x ? </span><span class="s5">32 </span><span class="s2">: (</span><span class="s5">31 </span><span class="s2">- ((log(x) / LN2) | </span><span class="s5">0</span><span class="s2">)) | </span><span class="s5">0</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getLabelForLane(lane) {</span>
  <span class="s4">if </span><span class="s2">(lane &amp; </span><span class="s5">1</span><span class="s2">) </span><span class="s4">return </span><span class="s3">&quot;SyncHydrationLane&quot;</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(lane &amp; </span><span class="s5">2</span><span class="s2">) </span><span class="s4">return </span><span class="s3">&quot;Sync&quot;</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(lane &amp; </span><span class="s5">4</span><span class="s2">) </span><span class="s4">return </span><span class="s3">&quot;InputContinuousHydration&quot;</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(lane &amp; </span><span class="s5">8</span><span class="s2">) </span><span class="s4">return </span><span class="s3">&quot;InputContinuous&quot;</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(lane &amp; </span><span class="s5">16</span><span class="s2">) </span><span class="s4">return </span><span class="s3">&quot;DefaultHydration&quot;</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(lane &amp; </span><span class="s5">32</span><span class="s2">) </span><span class="s4">return </span><span class="s3">&quot;Default&quot;</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(lane &amp; </span><span class="s5">128</span><span class="s2">) </span><span class="s4">return </span><span class="s3">&quot;TransitionHydration&quot;</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(lane &amp; </span><span class="s5">4194048</span><span class="s2">) </span><span class="s4">return </span><span class="s3">&quot;Transition&quot;</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(lane &amp; </span><span class="s5">62914560</span><span class="s2">) </span><span class="s4">return </span><span class="s3">&quot;Retry&quot;</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(lane &amp; </span><span class="s5">67108864</span><span class="s2">) </span><span class="s4">return </span><span class="s3">&quot;SelectiveHydration&quot;</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(lane &amp; </span><span class="s5">134217728</span><span class="s2">) </span><span class="s4">return </span><span class="s3">&quot;IdleHydration&quot;</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(lane &amp; </span><span class="s5">268435456</span><span class="s2">) </span><span class="s4">return </span><span class="s3">&quot;Idle&quot;</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(lane &amp; </span><span class="s5">536870912</span><span class="s2">) </span><span class="s4">return </span><span class="s3">&quot;Offscreen&quot;</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(lane &amp; </span><span class="s5">1073741824</span><span class="s2">) </span><span class="s4">return </span><span class="s3">&quot;Deferred&quot;</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">nextTransitionLane = </span><span class="s5">256</span><span class="s2">,</span>
  <span class="s2">nextRetryLane = </span><span class="s5">4194304</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">getHighestPriorityLanes(lanes) {</span>
  <span class="s4">var </span><span class="s2">pendingSyncLanes = lanes &amp; </span><span class="s5">42</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== pendingSyncLanes) </span><span class="s4">return </span><span class="s2">pendingSyncLanes;</span>
  <span class="s4">switch </span><span class="s2">(lanes &amp; -lanes) {</span>
    <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s5">1</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">2</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s5">2</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">4</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s5">4</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">8</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s5">8</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">16</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s5">16</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">32</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s5">32</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">64</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s5">64</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">128</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s5">128</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">256</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">512</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">1024</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">2048</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">4096</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">8192</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">16384</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">32768</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">65536</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">131072</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">262144</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">524288</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">1048576</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">2097152</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">lanes &amp; </span><span class="s5">4194048</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">4194304</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">8388608</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">16777216</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">33554432</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">lanes &amp; </span><span class="s5">62914560</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">67108864</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s5">67108864</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">134217728</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s5">134217728</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">268435456</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s5">268435456</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">536870912</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s5">536870912</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">1073741824</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">lanes;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getNextLanes(root, wipLanes, rootHasPendingCommit) {</span>
  <span class="s4">var </span><span class="s2">pendingLanes = root.pendingLanes;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== pendingLanes) </span><span class="s4">return </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">nextLanes = </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">suspendedLanes = root.suspendedLanes,</span>
    <span class="s2">pingedLanes = root.pingedLanes;</span>
  <span class="s2">root = root.warmLanes;</span>
  <span class="s4">var </span><span class="s2">nonIdlePendingLanes = pendingLanes &amp; </span><span class="s5">134217727</span><span class="s2">;</span>
  <span class="s5">0 </span><span class="s2">!== nonIdlePendingLanes</span>
    <span class="s2">? ((pendingLanes = nonIdlePendingLanes &amp; ~suspendedLanes),</span>
      <span class="s5">0 </span><span class="s2">!== pendingLanes</span>
        <span class="s2">? (nextLanes = getHighestPriorityLanes(pendingLanes))</span>
        <span class="s2">: ((pingedLanes &amp;= nonIdlePendingLanes),</span>
          <span class="s5">0 </span><span class="s2">!== pingedLanes</span>
            <span class="s2">? (nextLanes = getHighestPriorityLanes(pingedLanes))</span>
            <span class="s2">: rootHasPendingCommit ||</span>
              <span class="s2">((rootHasPendingCommit = nonIdlePendingLanes &amp; ~root),</span>
              <span class="s5">0 </span><span class="s2">!== rootHasPendingCommit &amp;&amp;</span>
                <span class="s2">(nextLanes = getHighestPriorityLanes(rootHasPendingCommit)))))</span>
    <span class="s2">: ((nonIdlePendingLanes = pendingLanes &amp; ~suspendedLanes),</span>
      <span class="s5">0 </span><span class="s2">!== nonIdlePendingLanes</span>
        <span class="s2">? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))</span>
        <span class="s2">: </span><span class="s5">0 </span><span class="s2">!== pingedLanes</span>
          <span class="s2">? (nextLanes = getHighestPriorityLanes(pingedLanes))</span>
          <span class="s2">: rootHasPendingCommit ||</span>
            <span class="s2">((rootHasPendingCommit = pendingLanes &amp; ~root),</span>
            <span class="s5">0 </span><span class="s2">!== rootHasPendingCommit &amp;&amp;</span>
              <span class="s2">(nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));</span>
  <span class="s4">return </span><span class="s5">0 </span><span class="s2">=== nextLanes</span>
    <span class="s2">? </span><span class="s5">0</span>
    <span class="s2">: </span><span class="s5">0 </span><span class="s2">!== wipLanes &amp;&amp;</span>
        <span class="s2">wipLanes !== nextLanes &amp;&amp;</span>
        <span class="s5">0 </span><span class="s2">=== (wipLanes &amp; suspendedLanes) &amp;&amp;</span>
        <span class="s2">((suspendedLanes = nextLanes &amp; -nextLanes),</span>
        <span class="s2">(rootHasPendingCommit = wipLanes &amp; -wipLanes),</span>
        <span class="s2">suspendedLanes &gt;= rootHasPendingCommit ||</span>
          <span class="s2">(</span><span class="s5">32 </span><span class="s2">=== suspendedLanes &amp;&amp; </span><span class="s5">0 </span><span class="s2">!== (rootHasPendingCommit &amp; </span><span class="s5">4194048</span><span class="s2">)))</span>
      <span class="s2">? wipLanes</span>
      <span class="s2">: nextLanes;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">checkIfRootIsPrerendering(root, renderLanes) {</span>
  <span class="s4">return </span><span class="s2">(</span>
    <span class="s5">0 </span><span class="s2">===</span>
    <span class="s2">(root.pendingLanes &amp;</span>
      <span class="s2">~(root.suspendedLanes &amp; ~root.pingedLanes) &amp;</span>
      <span class="s2">renderLanes)</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">computeExpirationTime(lane, currentTime) {</span>
  <span class="s4">switch </span><span class="s2">(lane) {</span>
    <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">2</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">4</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">8</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">64</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">currentTime + </span><span class="s5">250</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">16</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">32</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">128</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">256</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">512</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">1024</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">2048</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">4096</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">8192</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">16384</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">32768</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">65536</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">131072</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">262144</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">524288</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">1048576</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">2097152</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">currentTime + </span><span class="s5">5e3</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">4194304</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">8388608</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">16777216</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">33554432</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">-</span><span class="s5">1</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">67108864</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">134217728</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">268435456</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">536870912</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">1073741824</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">-</span><span class="s5">1</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">-</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">claimNextTransitionLane() {</span>
  <span class="s4">var </span><span class="s2">lane = nextTransitionLane;</span>
  <span class="s2">nextTransitionLane &lt;&lt;= </span><span class="s5">1</span><span class="s2">;</span>
  <span class="s5">0 </span><span class="s2">=== (nextTransitionLane &amp; </span><span class="s5">4194048</span><span class="s2">) &amp;&amp; (nextTransitionLane = </span><span class="s5">256</span><span class="s2">);</span>
  <span class="s4">return </span><span class="s2">lane;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">claimNextRetryLane() {</span>
  <span class="s4">var </span><span class="s2">lane = nextRetryLane;</span>
  <span class="s2">nextRetryLane &lt;&lt;= </span><span class="s5">1</span><span class="s2">;</span>
  <span class="s5">0 </span><span class="s2">=== (nextRetryLane &amp; </span><span class="s5">62914560</span><span class="s2">) &amp;&amp; (nextRetryLane = </span><span class="s5">4194304</span><span class="s2">);</span>
  <span class="s4">return </span><span class="s2">lane;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createLaneMap(initial) {</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">laneMap = [], i = </span><span class="s5">0</span><span class="s2">; </span><span class="s5">31 </span><span class="s2">&gt; i; i++) laneMap.push(initial);</span>
  <span class="s4">return </span><span class="s2">laneMap;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">markRootUpdated$1(root, updateLane) {</span>
  <span class="s2">root.pendingLanes |= updateLane;</span>
  <span class="s5">268435456 </span><span class="s2">!== updateLane &amp;&amp;</span>
    <span class="s2">((root.suspendedLanes = </span><span class="s5">0</span><span class="s2">), (root.pingedLanes = </span><span class="s5">0</span><span class="s2">), (root.warmLanes = </span><span class="s5">0</span><span class="s2">));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">markRootFinished(</span>
  <span class="s2">root,</span>
  <span class="s2">finishedLanes,</span>
  <span class="s2">remainingLanes,</span>
  <span class="s2">spawnedLane,</span>
  <span class="s2">updatedLanes,</span>
  <span class="s2">suspendedRetryLanes</span>
<span class="s2">) {</span>
  <span class="s4">var </span><span class="s2">previouslyPendingLanes = root.pendingLanes;</span>
  <span class="s2">root.pendingLanes = remainingLanes;</span>
  <span class="s2">root.suspendedLanes = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">root.pingedLanes = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">root.warmLanes = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">root.expiredLanes &amp;= remainingLanes;</span>
  <span class="s2">root.entangledLanes &amp;= remainingLanes;</span>
  <span class="s2">root.errorRecoveryDisabledLanes &amp;= remainingLanes;</span>
  <span class="s2">root.shellSuspendCounter = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">entanglements = root.entanglements,</span>
    <span class="s2">expirationTimes = root.expirationTimes,</span>
    <span class="s2">hiddenUpdates = root.hiddenUpdates;</span>
  <span class="s4">for </span><span class="s2">(</span>
    <span class="s2">remainingLanes = previouslyPendingLanes &amp; ~remainingLanes;</span>
    <span class="s5">0 </span><span class="s2">&lt; remainingLanes;</span>

  <span class="s2">) {</span>
    <span class="s4">var </span><span class="s2">index$5 = </span><span class="s5">31 </span><span class="s2">- clz32(remainingLanes),</span>
      <span class="s2">lane = </span><span class="s5">1 </span><span class="s2">&lt;&lt; index$5;</span>
    <span class="s2">entanglements[index$5] = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">expirationTimes[index$5] = -</span><span class="s5">1</span><span class="s2">;</span>
    <span class="s4">var </span><span class="s2">hiddenUpdatesForLane = hiddenUpdates[index$5];</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== hiddenUpdatesForLane)</span>
      <span class="s4">for </span><span class="s2">(</span>
        <span class="s2">hiddenUpdates[index$5] = </span><span class="s4">null</span><span class="s2">, index$5 = </span><span class="s5">0</span><span class="s2">;</span>
        <span class="s2">index$5 &lt; hiddenUpdatesForLane.length;</span>
        <span class="s2">index$5++</span>
      <span class="s2">) {</span>
        <span class="s4">var </span><span class="s2">update = hiddenUpdatesForLane[index$5];</span>
        <span class="s4">null </span><span class="s2">!== update &amp;&amp; (update.lane &amp;= -</span><span class="s5">536870913</span><span class="s2">);</span>
      <span class="s2">}</span>
    <span class="s2">remainingLanes &amp;= ~lane;</span>
  <span class="s2">}</span>
  <span class="s5">0 </span><span class="s2">!== spawnedLane &amp;&amp; markSpawnedDeferredLane(root, spawnedLane, </span><span class="s5">0</span><span class="s2">);</span>
  <span class="s5">0 </span><span class="s2">!== suspendedRetryLanes &amp;&amp;</span>
    <span class="s5">0 </span><span class="s2">=== updatedLanes &amp;&amp;</span>
    <span class="s5">0 </span><span class="s2">!== root.tag &amp;&amp;</span>
    <span class="s2">(root.suspendedLanes |=</span>
      <span class="s2">suspendedRetryLanes &amp; ~(previouslyPendingLanes &amp; ~finishedLanes));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {</span>
  <span class="s2">root.pendingLanes |= spawnedLane;</span>
  <span class="s2">root.suspendedLanes &amp;= ~spawnedLane;</span>
  <span class="s4">var </span><span class="s2">spawnedLaneIndex = </span><span class="s5">31 </span><span class="s2">- clz32(spawnedLane);</span>
  <span class="s2">root.entangledLanes |= spawnedLane;</span>
  <span class="s2">root.entanglements[spawnedLaneIndex] =</span>
    <span class="s2">root.entanglements[spawnedLaneIndex] |</span>
    <span class="s5">1073741824 </span><span class="s2">|</span>
    <span class="s2">(entangledLanes &amp; </span><span class="s5">4194090</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">markRootEntangled(root, entangledLanes) {</span>
  <span class="s4">var </span><span class="s2">rootEntangledLanes = (root.entangledLanes |= entangledLanes);</span>
  <span class="s4">for </span><span class="s2">(root = root.entanglements; rootEntangledLanes; ) {</span>
    <span class="s4">var </span><span class="s2">index$6 = </span><span class="s5">31 </span><span class="s2">- clz32(rootEntangledLanes),</span>
      <span class="s2">lane = </span><span class="s5">1 </span><span class="s2">&lt;&lt; index$6;</span>
    <span class="s2">(lane &amp; entangledLanes) | (root[index$6] &amp; entangledLanes) &amp;&amp;</span>
      <span class="s2">(root[index$6] |= entangledLanes);</span>
    <span class="s2">rootEntangledLanes &amp;= ~lane;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getBumpedLaneForHydrationByLane(lane) {</span>
  <span class="s4">switch </span><span class="s2">(lane) {</span>
    <span class="s4">case </span><span class="s5">2</span><span class="s2">:</span>
      <span class="s2">lane = </span><span class="s5">1</span><span class="s2">;</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">8</span><span class="s2">:</span>
      <span class="s2">lane = </span><span class="s5">4</span><span class="s2">;</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">32</span><span class="s2">:</span>
      <span class="s2">lane = </span><span class="s5">16</span><span class="s2">;</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">256</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">512</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">1024</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">2048</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">4096</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">8192</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">16384</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">32768</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">65536</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">131072</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">262144</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">524288</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">1048576</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">2097152</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">4194304</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">8388608</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">16777216</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">33554432</span><span class="s2">:</span>
      <span class="s2">lane = </span><span class="s5">128</span><span class="s2">;</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">268435456</span><span class="s2">:</span>
      <span class="s2">lane = </span><span class="s5">134217728</span><span class="s2">;</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s2">lane = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">lane;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">addFiberToLanesMap(root, fiber, lanes) {</span>
  <span class="s4">if </span><span class="s2">(isDevToolsPresent)</span>
    <span class="s4">for </span><span class="s2">(root = root.pendingUpdatersLaneMap; </span><span class="s5">0 </span><span class="s2">&lt; lanes; ) {</span>
      <span class="s4">var </span><span class="s2">index$8 = </span><span class="s5">31 </span><span class="s2">- clz32(lanes),</span>
        <span class="s2">lane = </span><span class="s5">1 </span><span class="s2">&lt;&lt; index$8;</span>
      <span class="s2">root[index$8].add(fiber);</span>
      <span class="s2">lanes &amp;= ~lane;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">movePendingFibersToMemoized(root, lanes) {</span>
  <span class="s4">if </span><span class="s2">(isDevToolsPresent)</span>
    <span class="s4">for </span><span class="s2">(</span>
      <span class="s4">var </span><span class="s2">pendingUpdatersLaneMap = root.pendingUpdatersLaneMap,</span>
        <span class="s2">memoizedUpdaters = root.memoizedUpdaters;</span>
      <span class="s5">0 </span><span class="s2">&lt; lanes;</span>

    <span class="s2">) {</span>
      <span class="s4">var </span><span class="s2">index$9 = </span><span class="s5">31 </span><span class="s2">- clz32(lanes);</span>
      <span class="s2">root = </span><span class="s5">1 </span><span class="s2">&lt;&lt; index$9;</span>
      <span class="s2">index$9 = pendingUpdatersLaneMap[index$9];</span>
      <span class="s5">0 </span><span class="s2">&lt; index$9.size &amp;&amp;</span>
        <span class="s2">(index$9.forEach(</span><span class="s4">function </span><span class="s2">(fiber) {</span>
          <span class="s4">var </span><span class="s2">alternate = fiber.alternate;</span>
          <span class="s2">(</span><span class="s4">null </span><span class="s2">!== alternate &amp;&amp; memoizedUpdaters.has(alternate)) ||</span>
            <span class="s2">memoizedUpdaters.add(fiber);</span>
        <span class="s2">}),</span>
        <span class="s2">index$9.clear());</span>
      <span class="s2">lanes &amp;= ~root;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">lanesToEventPriority(lanes) {</span>
  <span class="s2">lanes &amp;= -lanes;</span>
  <span class="s4">return </span><span class="s5">2 </span><span class="s2">&lt; lanes</span>
    <span class="s2">? </span><span class="s5">8 </span><span class="s2">&lt; lanes</span>
      <span class="s2">? </span><span class="s5">0 </span><span class="s2">!== (lanes &amp; </span><span class="s5">134217727</span><span class="s2">)</span>
        <span class="s2">? </span><span class="s5">32</span>
        <span class="s2">: </span><span class="s5">268435456</span>
      <span class="s2">: </span><span class="s5">8</span>
    <span class="s2">: </span><span class="s5">2</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">resolveUpdatePriority() {</span>
  <span class="s4">var </span><span class="s2">updatePriority = ReactDOMSharedInternals.p;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== updatePriority) </span><span class="s4">return </span><span class="s2">updatePriority;</span>
  <span class="s2">updatePriority = window.event;</span>
  <span class="s4">return void </span><span class="s5">0 </span><span class="s2">=== updatePriority ? </span><span class="s5">32 </span><span class="s2">: getEventPriority(updatePriority.type);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">runWithPriority(priority, fn) {</span>
  <span class="s4">var </span><span class="s2">previousPriority = ReactDOMSharedInternals.p;</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s4">return </span><span class="s2">(ReactDOMSharedInternals.p = priority), fn();</span>
  <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
    <span class="s2">ReactDOMSharedInternals.p = previousPriority;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">randomKey = Math.random().toString(</span><span class="s5">36</span><span class="s2">).slice(</span><span class="s5">2</span><span class="s2">),</span>
  <span class="s2">internalInstanceKey = </span><span class="s3">&quot;__reactFiber$&quot; </span><span class="s2">+ randomKey,</span>
  <span class="s2">internalPropsKey = </span><span class="s3">&quot;__reactProps$&quot; </span><span class="s2">+ randomKey,</span>
  <span class="s2">internalContainerInstanceKey = </span><span class="s3">&quot;__reactContainer$&quot; </span><span class="s2">+ randomKey,</span>
  <span class="s2">internalEventHandlersKey = </span><span class="s3">&quot;__reactEvents$&quot; </span><span class="s2">+ randomKey,</span>
  <span class="s2">internalEventHandlerListenersKey = </span><span class="s3">&quot;__reactListeners$&quot; </span><span class="s2">+ randomKey,</span>
  <span class="s2">internalEventHandlesSetKey = </span><span class="s3">&quot;__reactHandles$&quot; </span><span class="s2">+ randomKey,</span>
  <span class="s2">internalRootNodeResourcesKey = </span><span class="s3">&quot;__reactResources$&quot; </span><span class="s2">+ randomKey,</span>
  <span class="s2">internalHoistableMarker = </span><span class="s3">&quot;__reactMarker$&quot; </span><span class="s2">+ randomKey;</span>
<span class="s4">function </span><span class="s2">detachDeletedInstance(node) {</span>
  <span class="s4">delete </span><span class="s2">node[internalInstanceKey];</span>
  <span class="s4">delete </span><span class="s2">node[internalPropsKey];</span>
  <span class="s4">delete </span><span class="s2">node[internalEventHandlersKey];</span>
  <span class="s4">delete </span><span class="s2">node[internalEventHandlerListenersKey];</span>
  <span class="s4">delete </span><span class="s2">node[internalEventHandlesSetKey];</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getClosestInstanceFromNode(targetNode) {</span>
  <span class="s4">var </span><span class="s2">targetInst = targetNode[internalInstanceKey];</span>
  <span class="s4">if </span><span class="s2">(targetInst) </span><span class="s4">return </span><span class="s2">targetInst;</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">parentNode = targetNode.parentNode; parentNode; ) {</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">(targetInst =</span>
        <span class="s2">parentNode[internalContainerInstanceKey] ||</span>
        <span class="s2">parentNode[internalInstanceKey])</span>
    <span class="s2">) {</span>
      <span class="s2">parentNode = targetInst.alternate;</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s4">null </span><span class="s2">!== targetInst.child ||</span>
        <span class="s2">(</span><span class="s4">null </span><span class="s2">!== parentNode &amp;&amp; </span><span class="s4">null </span><span class="s2">!== parentNode.child)</span>
      <span class="s2">)</span>
        <span class="s4">for </span><span class="s2">(</span>
          <span class="s2">targetNode = getParentSuspenseInstance(targetNode);</span>
          <span class="s4">null </span><span class="s2">!== targetNode;</span>

        <span class="s2">) {</span>
          <span class="s4">if </span><span class="s2">((parentNode = targetNode[internalInstanceKey])) </span><span class="s4">return </span><span class="s2">parentNode;</span>
          <span class="s2">targetNode = getParentSuspenseInstance(targetNode);</span>
        <span class="s2">}</span>
      <span class="s4">return </span><span class="s2">targetInst;</span>
    <span class="s2">}</span>
    <span class="s2">targetNode = parentNode;</span>
    <span class="s2">parentNode = targetNode.parentNode;</span>
  <span class="s2">}</span>
  <span class="s4">return null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getInstanceFromNode(node) {</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s2">(node = node[internalInstanceKey] || node[internalContainerInstanceKey])</span>
  <span class="s2">) {</span>
    <span class="s4">var </span><span class="s2">tag = node.tag;</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s5">5 </span><span class="s2">=== tag ||</span>
      <span class="s5">6 </span><span class="s2">=== tag ||</span>
      <span class="s5">13 </span><span class="s2">=== tag ||</span>
      <span class="s5">26 </span><span class="s2">=== tag ||</span>
      <span class="s5">27 </span><span class="s2">=== tag ||</span>
      <span class="s5">3 </span><span class="s2">=== tag</span>
    <span class="s2">)</span>
      <span class="s4">return </span><span class="s2">node;</span>
  <span class="s2">}</span>
  <span class="s4">return null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getNodeFromInstance(inst) {</span>
  <span class="s4">var </span><span class="s2">tag = inst.tag;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">5 </span><span class="s2">=== tag || </span><span class="s5">26 </span><span class="s2">=== tag || </span><span class="s5">27 </span><span class="s2">=== tag || </span><span class="s5">6 </span><span class="s2">=== tag) </span><span class="s4">return </span><span class="s2">inst.stateNode;</span>
  <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">33</span><span class="s2">));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getResourcesFromRoot(root) {</span>
  <span class="s4">var </span><span class="s2">resources = root[internalRootNodeResourcesKey];</span>
  <span class="s2">resources ||</span>
    <span class="s2">(resources = root[internalRootNodeResourcesKey] =</span>
      <span class="s2">{ hoistableStyles: </span><span class="s4">new </span><span class="s2">Map(), hoistableScripts: </span><span class="s4">new </span><span class="s2">Map() });</span>
  <span class="s4">return </span><span class="s2">resources;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">markNodeAsHoistable(node) {</span>
  <span class="s2">node[internalHoistableMarker] = !</span><span class="s5">0</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">allNativeEvents = </span><span class="s4">new </span><span class="s2">Set(),</span>
  <span class="s2">registrationNameDependencies = {};</span>
<span class="s4">function </span><span class="s2">registerTwoPhaseEvent(registrationName, dependencies) {</span>
  <span class="s2">registerDirectEvent(registrationName, dependencies);</span>
  <span class="s2">registerDirectEvent(registrationName + </span><span class="s3">&quot;Capture&quot;</span><span class="s2">, dependencies);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">registerDirectEvent(registrationName, dependencies) {</span>
  <span class="s2">registrationNameDependencies[registrationName] = dependencies;</span>
  <span class="s4">for </span><span class="s2">(</span>
    <span class="s2">registrationName = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">registrationName &lt; dependencies.length;</span>
    <span class="s2">registrationName++</span>
  <span class="s2">)</span>
    <span class="s2">allNativeEvents.add(dependencies[registrationName]);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">VALID_ATTRIBUTE_NAME_REGEX = RegExp(</span>
    <span class="s3">&quot;^[:A-Z_a-z</span><span class="s6">\\</span><span class="s3">u00C0-</span><span class="s6">\\</span><span class="s3">u00D6</span><span class="s6">\\</span><span class="s3">u00D8-</span><span class="s6">\\</span><span class="s3">u00F6</span><span class="s6">\\</span><span class="s3">u00F8-</span><span class="s6">\\</span><span class="s3">u02FF</span><span class="s6">\\</span><span class="s3">u0370-</span><span class="s6">\\</span><span class="s3">u037D</span><span class="s6">\\</span><span class="s3">u037F-</span><span class="s6">\\</span><span class="s3">u1FFF</span><span class="s6">\\</span><span class="s3">u200C-</span><span class="s6">\\</span><span class="s3">u200D</span><span class="s6">\\</span><span class="s3">u2070-</span><span class="s6">\\</span><span class="s3">u218F</span><span class="s6">\\</span><span class="s3">u2C00-</span><span class="s6">\\</span><span class="s3">u2FEF</span><span class="s6">\\</span><span class="s3">u3001-</span><span class="s6">\\</span><span class="s3">uD7FF</span><span class="s6">\\</span><span class="s3">uF900-</span><span class="s6">\\</span><span class="s3">uFDCF</span><span class="s6">\\</span><span class="s3">uFDF0-</span><span class="s6">\\</span><span class="s3">uFFFD][:A-Z_a-z</span><span class="s6">\\</span><span class="s3">u00C0-</span><span class="s6">\\</span><span class="s3">u00D6</span><span class="s6">\\</span><span class="s3">u00D8-</span><span class="s6">\\</span><span class="s3">u00F6</span><span class="s6">\\</span><span class="s3">u00F8-</span><span class="s6">\\</span><span class="s3">u02FF</span><span class="s6">\\</span><span class="s3">u0370-</span><span class="s6">\\</span><span class="s3">u037D</span><span class="s6">\\</span><span class="s3">u037F-</span><span class="s6">\\</span><span class="s3">u1FFF</span><span class="s6">\\</span><span class="s3">u200C-</span><span class="s6">\\</span><span class="s3">u200D</span><span class="s6">\\</span><span class="s3">u2070-</span><span class="s6">\\</span><span class="s3">u218F</span><span class="s6">\\</span><span class="s3">u2C00-</span><span class="s6">\\</span><span class="s3">u2FEF</span><span class="s6">\\</span><span class="s3">u3001-</span><span class="s6">\\</span><span class="s3">uD7FF</span><span class="s6">\\</span><span class="s3">uF900-</span><span class="s6">\\</span><span class="s3">uFDCF</span><span class="s6">\\</span><span class="s3">uFDF0-</span><span class="s6">\\</span><span class="s3">uFFFD</span><span class="s6">\\</span><span class="s3">-.0-9</span><span class="s6">\\</span><span class="s3">u00B7</span><span class="s6">\\</span><span class="s3">u0300-</span><span class="s6">\\</span><span class="s3">u036F</span><span class="s6">\\</span><span class="s3">u203F-</span><span class="s6">\\</span><span class="s3">u2040]*$&quot;</span>
  <span class="s2">),</span>
  <span class="s2">illegalAttributeNameCache = {},</span>
  <span class="s2">validatedAttributeNameCache = {};</span>
<span class="s4">function </span><span class="s2">isAttributeNameSafe(attributeName) {</span>
  <span class="s4">if </span><span class="s2">(hasOwnProperty.call(validatedAttributeNameCache, attributeName))</span>
    <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(hasOwnProperty.call(illegalAttributeNameCache, attributeName)) </span><span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))</span>
    <span class="s4">return </span><span class="s2">(validatedAttributeNameCache[attributeName] = !</span><span class="s5">0</span><span class="s2">);</span>
  <span class="s2">illegalAttributeNameCache[attributeName] = !</span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">setValueForAttribute(node, name, value) {</span>
  <span class="s4">if </span><span class="s2">(isAttributeNameSafe(name))</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== value) node.removeAttribute(name);</span>
    <span class="s4">else </span><span class="s2">{</span>
      <span class="s4">switch </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">value) {</span>
        <span class="s4">case </span><span class="s3">&quot;undefined&quot;</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s3">&quot;function&quot;</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s3">&quot;symbol&quot;</span><span class="s2">:</span>
          <span class="s2">node.removeAttribute(name);</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;boolean&quot;</span><span class="s2">:</span>
          <span class="s4">var </span><span class="s2">prefix$10 = name.toLowerCase().slice(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">5</span><span class="s2">);</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;data-&quot; </span><span class="s2">!== prefix$10 &amp;&amp; </span><span class="s3">&quot;aria-&quot; </span><span class="s2">!== prefix$10) {</span>
            <span class="s2">node.removeAttribute(name);</span>
            <span class="s4">return</span><span class="s2">;</span>
          <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s2">node.setAttribute(name, </span><span class="s3">&quot;&quot; </span><span class="s2">+ value);</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">setValueForKnownAttribute(node, name, value) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== value) node.removeAttribute(name);</span>
  <span class="s4">else </span><span class="s2">{</span>
    <span class="s4">switch </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">value) {</span>
      <span class="s4">case </span><span class="s3">&quot;undefined&quot;</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">&quot;function&quot;</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">&quot;symbol&quot;</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">&quot;boolean&quot;</span><span class="s2">:</span>
        <span class="s2">node.removeAttribute(name);</span>
        <span class="s4">return</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s2">node.setAttribute(name, </span><span class="s3">&quot;&quot; </span><span class="s2">+ value);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">setValueForNamespacedAttribute(node, namespace, name, value) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== value) node.removeAttribute(name);</span>
  <span class="s4">else </span><span class="s2">{</span>
    <span class="s4">switch </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">value) {</span>
      <span class="s4">case </span><span class="s3">&quot;undefined&quot;</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">&quot;function&quot;</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">&quot;symbol&quot;</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">&quot;boolean&quot;</span><span class="s2">:</span>
        <span class="s2">node.removeAttribute(name);</span>
        <span class="s4">return</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s2">node.setAttributeNS(namespace, name, </span><span class="s3">&quot;&quot; </span><span class="s2">+ value);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">prefix, suffix;</span>
<span class="s4">function </span><span class="s2">describeBuiltInComponentFrame(name) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== prefix)</span>
    <span class="s4">try </span><span class="s2">{</span>
      <span class="s4">throw </span><span class="s2">Error();</span>
    <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
      <span class="s4">var </span><span class="s2">match = x.stack.trim().match(</span><span class="s7">/\n( *(at )?)/</span><span class="s2">);</span>
      <span class="s2">prefix = (match &amp;&amp; match[</span><span class="s5">1</span><span class="s2">]) || </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
      <span class="s2">suffix =</span>
        <span class="s2">-</span><span class="s5">1 </span><span class="s2">&lt; x.stack.indexOf(</span><span class="s3">&quot;</span><span class="s6">\n    </span><span class="s3">at&quot;</span><span class="s2">)</span>
          <span class="s2">? </span><span class="s3">&quot; (&lt;anonymous&gt;)&quot;</span>
          <span class="s2">: -</span><span class="s5">1 </span><span class="s2">&lt; x.stack.indexOf(</span><span class="s3">&quot;@&quot;</span><span class="s2">)</span>
            <span class="s2">? </span><span class="s3">&quot;@unknown:0:0&quot;</span>
            <span class="s2">: </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s4">return </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot; </span><span class="s2">+ prefix + name + suffix;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">reentry = !</span><span class="s5">1</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">describeNativeComponentFrame(fn, construct) {</span>
  <span class="s4">if </span><span class="s2">(!fn || reentry) </span><span class="s4">return </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
  <span class="s2">reentry = !</span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">previousPrepareStackTrace = Error.prepareStackTrace;</span>
  <span class="s2">Error.prepareStackTrace = </span><span class="s4">void </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">RunInRootFrame = {</span>
      <span class="s2">DetermineComponentFrameRoot: </span><span class="s4">function </span><span class="s2">() {</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s4">if </span><span class="s2">(construct) {</span>
            <span class="s4">var </span><span class="s2">Fake = </span><span class="s4">function </span><span class="s2">() {</span>
              <span class="s4">throw </span><span class="s2">Error();</span>
            <span class="s2">};</span>
            <span class="s2">Object.defineProperty(Fake.prototype, </span><span class="s3">&quot;props&quot;</span><span class="s2">, {</span>
              <span class="s2">set: </span><span class="s4">function </span><span class="s2">() {</span>
                <span class="s4">throw </span><span class="s2">Error();</span>
              <span class="s2">}</span>
            <span class="s2">});</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">Reflect &amp;&amp; Reflect.construct) {</span>
              <span class="s4">try </span><span class="s2">{</span>
                <span class="s2">Reflect.construct(Fake, []);</span>
              <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
                <span class="s4">var </span><span class="s2">control = x;</span>
              <span class="s2">}</span>
              <span class="s2">Reflect.construct(fn, [], Fake);</span>
            <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
              <span class="s4">try </span><span class="s2">{</span>
                <span class="s2">Fake.call();</span>
              <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x$11) {</span>
                <span class="s2">control = x$11;</span>
              <span class="s2">}</span>
              <span class="s2">fn.call(Fake.prototype);</span>
            <span class="s2">}</span>
          <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
            <span class="s4">try </span><span class="s2">{</span>
              <span class="s4">throw </span><span class="s2">Error();</span>
            <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x$12) {</span>
              <span class="s2">control = x$12;</span>
            <span class="s2">}</span>
            <span class="s2">(Fake = fn()) &amp;&amp;</span>
              <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">Fake.catch &amp;&amp;</span>
              <span class="s2">Fake.catch(</span><span class="s4">function </span><span class="s2">() {});</span>
          <span class="s2">}</span>
        <span class="s2">} </span><span class="s4">catch </span><span class="s2">(sample) {</span>
          <span class="s4">if </span><span class="s2">(sample &amp;&amp; control &amp;&amp; </span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">sample.stack)</span>
            <span class="s4">return </span><span class="s2">[sample.stack, control.stack];</span>
        <span class="s2">}</span>
        <span class="s4">return </span><span class="s2">[</span><span class="s4">null</span><span class="s2">, </span><span class="s4">null</span><span class="s2">];</span>
      <span class="s2">}</span>
    <span class="s2">};</span>
    <span class="s2">RunInRootFrame.DetermineComponentFrameRoot.displayName =</span>
      <span class="s3">&quot;DetermineComponentFrameRoot&quot;</span><span class="s2">;</span>
    <span class="s4">var </span><span class="s2">namePropDescriptor = Object.getOwnPropertyDescriptor(</span>
      <span class="s2">RunInRootFrame.DetermineComponentFrameRoot,</span>
      <span class="s3">&quot;name&quot;</span>
    <span class="s2">);</span>
    <span class="s2">namePropDescriptor &amp;&amp;</span>
      <span class="s2">namePropDescriptor.configurable &amp;&amp;</span>
      <span class="s2">Object.defineProperty(</span>
        <span class="s2">RunInRootFrame.DetermineComponentFrameRoot,</span>
        <span class="s3">&quot;name&quot;</span><span class="s2">,</span>
        <span class="s2">{ value: </span><span class="s3">&quot;DetermineComponentFrameRoot&quot; </span><span class="s2">}</span>
      <span class="s2">);</span>
    <span class="s4">var </span><span class="s2">_RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),</span>
      <span class="s2">sampleStack = _RunInRootFrame$Deter[</span><span class="s5">0</span><span class="s2">],</span>
      <span class="s2">controlStack = _RunInRootFrame$Deter[</span><span class="s5">1</span><span class="s2">];</span>
    <span class="s4">if </span><span class="s2">(sampleStack &amp;&amp; controlStack) {</span>
      <span class="s4">var </span><span class="s2">sampleLines = sampleStack.split(</span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">),</span>
        <span class="s2">controlLines = controlStack.split(</span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">);</span>
      <span class="s4">for </span><span class="s2">(</span>
        <span class="s2">namePropDescriptor = RunInRootFrame = </span><span class="s5">0</span><span class="s2">;</span>
        <span class="s2">RunInRootFrame &lt; sampleLines.length &amp;&amp;</span>
        <span class="s2">!sampleLines[RunInRootFrame].includes(</span><span class="s3">&quot;DetermineComponentFrameRoot&quot;</span><span class="s2">);</span>

      <span class="s2">)</span>
        <span class="s2">RunInRootFrame++;</span>
      <span class="s4">for </span><span class="s2">(</span>
        <span class="s2">;</span>
        <span class="s2">namePropDescriptor &lt; controlLines.length &amp;&amp;</span>
        <span class="s2">!controlLines[namePropDescriptor].includes(</span>
          <span class="s3">&quot;DetermineComponentFrameRoot&quot;</span>
        <span class="s2">);</span>

      <span class="s2">)</span>
        <span class="s2">namePropDescriptor++;</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">RunInRootFrame === sampleLines.length ||</span>
        <span class="s2">namePropDescriptor === controlLines.length</span>
      <span class="s2">)</span>
        <span class="s4">for </span><span class="s2">(</span>
          <span class="s2">RunInRootFrame = sampleLines.length - </span><span class="s5">1</span><span class="s2">,</span>
            <span class="s2">namePropDescriptor = controlLines.length - </span><span class="s5">1</span><span class="s2">;</span>
          <span class="s5">1 </span><span class="s2">&lt;= RunInRootFrame &amp;&amp;</span>
          <span class="s5">0 </span><span class="s2">&lt;= namePropDescriptor &amp;&amp;</span>
          <span class="s2">sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];</span>

        <span class="s2">)</span>
          <span class="s2">namePropDescriptor--;</span>
      <span class="s4">for </span><span class="s2">(</span>
        <span class="s2">;</span>
        <span class="s5">1 </span><span class="s2">&lt;= RunInRootFrame &amp;&amp; </span><span class="s5">0 </span><span class="s2">&lt;= namePropDescriptor;</span>
        <span class="s2">RunInRootFrame--, namePropDescriptor--</span>
      <span class="s2">)</span>
        <span class="s4">if </span><span class="s2">(sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s5">1 </span><span class="s2">!== RunInRootFrame || </span><span class="s5">1 </span><span class="s2">!== namePropDescriptor) {</span>
            <span class="s4">do</span>
              <span class="s4">if </span><span class="s2">(</span>
                <span class="s2">(RunInRootFrame--,</span>
                <span class="s2">namePropDescriptor--,</span>
                <span class="s5">0 </span><span class="s2">&gt; namePropDescriptor ||</span>
                  <span class="s2">sampleLines[RunInRootFrame] !==</span>
                    <span class="s2">controlLines[namePropDescriptor])</span>
              <span class="s2">) {</span>
                <span class="s4">var </span><span class="s2">frame =</span>
                  <span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot; </span><span class="s2">+</span>
                  <span class="s2">sampleLines[RunInRootFrame].replace(</span><span class="s3">&quot; at new &quot;</span><span class="s2">, </span><span class="s3">&quot; at &quot;</span><span class="s2">);</span>
                <span class="s2">fn.displayName &amp;&amp;</span>
                  <span class="s2">frame.includes(</span><span class="s3">&quot;&lt;anonymous&gt;&quot;</span><span class="s2">) &amp;&amp;</span>
                  <span class="s2">(frame = frame.replace(</span><span class="s3">&quot;&lt;anonymous&gt;&quot;</span><span class="s2">, fn.displayName));</span>
                <span class="s4">return </span><span class="s2">frame;</span>
              <span class="s2">}</span>
            <span class="s4">while </span><span class="s2">(</span><span class="s5">1 </span><span class="s2">&lt;= RunInRootFrame &amp;&amp; </span><span class="s5">0 </span><span class="s2">&lt;= namePropDescriptor);</span>
          <span class="s2">}</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
  <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
    <span class="s2">(reentry = !</span><span class="s5">1</span><span class="s2">), (Error.prepareStackTrace = previousPrepareStackTrace);</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">(previousPrepareStackTrace = fn ? fn.displayName || fn.name : </span><span class="s3">&quot;&quot;</span><span class="s2">)</span>
    <span class="s2">? describeBuiltInComponentFrame(previousPrepareStackTrace)</span>
    <span class="s2">: </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">describeFiber(fiber) {</span>
  <span class="s4">switch </span><span class="s2">(fiber.tag) {</span>
    <span class="s4">case </span><span class="s5">26</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">27</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">describeBuiltInComponentFrame(fiber.type);</span>
    <span class="s4">case </span><span class="s5">16</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">describeBuiltInComponentFrame(</span><span class="s3">&quot;Lazy&quot;</span><span class="s2">);</span>
    <span class="s4">case </span><span class="s5">13</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">describeBuiltInComponentFrame(</span><span class="s3">&quot;Suspense&quot;</span><span class="s2">);</span>
    <span class="s4">case </span><span class="s5">19</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">describeBuiltInComponentFrame(</span><span class="s3">&quot;SuspenseList&quot;</span><span class="s2">);</span>
    <span class="s4">case </span><span class="s5">0</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">15</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">describeNativeComponentFrame(fiber.type, !</span><span class="s5">1</span><span class="s2">);</span>
    <span class="s4">case </span><span class="s5">11</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">describeNativeComponentFrame(fiber.type.render, !</span><span class="s5">1</span><span class="s2">);</span>
    <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">describeNativeComponentFrame(fiber.type, !</span><span class="s5">0</span><span class="s2">);</span>
    <span class="s4">case </span><span class="s5">31</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">describeBuiltInComponentFrame(</span><span class="s3">&quot;Activity&quot;</span><span class="s2">);</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getStackByFiberInDevAndProd(workInProgress) {</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">info = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
    <span class="s4">do</span>
      <span class="s2">(info += describeFiber(workInProgress)),</span>
        <span class="s2">(workInProgress = workInProgress.return);</span>
    <span class="s4">while </span><span class="s2">(workInProgress);</span>
    <span class="s4">return </span><span class="s2">info;</span>
  <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
    <span class="s4">return </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">Error generating stack: &quot; </span><span class="s2">+ x.message + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot; </span><span class="s2">+ x.stack;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getToStringValue(value) {</span>
  <span class="s4">switch </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">value) {</span>
    <span class="s4">case </span><span class="s3">&quot;bigint&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;boolean&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;number&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;string&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;undefined&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">value;</span>
    <span class="s4">case </span><span class="s3">&quot;object&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">value;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">isCheckable(elem) {</span>
  <span class="s4">var </span><span class="s2">type = elem.type;</span>
  <span class="s4">return </span><span class="s2">(</span>
    <span class="s2">(elem = elem.nodeName) &amp;&amp;</span>
    <span class="s3">&quot;input&quot; </span><span class="s2">=== elem.toLowerCase() &amp;&amp;</span>
    <span class="s2">(</span><span class="s3">&quot;checkbox&quot; </span><span class="s2">=== type || </span><span class="s3">&quot;radio&quot; </span><span class="s2">=== type)</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">trackValueOnNode(node) {</span>
  <span class="s4">var </span><span class="s2">valueField = isCheckable(node) ? </span><span class="s3">&quot;checked&quot; </span><span class="s2">: </span><span class="s3">&quot;value&quot;</span><span class="s2">,</span>
    <span class="s2">descriptor = Object.getOwnPropertyDescriptor(</span>
      <span class="s2">node.constructor.prototype,</span>
      <span class="s2">valueField</span>
    <span class="s2">),</span>
    <span class="s2">currentValue = </span><span class="s3">&quot;&quot; </span><span class="s2">+ node[valueField];</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s2">!node.hasOwnProperty(valueField) &amp;&amp;</span>
    <span class="s3">&quot;undefined&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">descriptor &amp;&amp;</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">descriptor.get &amp;&amp;</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">descriptor.set</span>
  <span class="s2">) {</span>
    <span class="s4">var </span><span class="s2">get = descriptor.get,</span>
      <span class="s2">set = descriptor.set;</span>
    <span class="s2">Object.defineProperty(node, valueField, {</span>
      <span class="s2">configurable: !</span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">get: </span><span class="s4">function </span><span class="s2">() {</span>
        <span class="s4">return </span><span class="s2">get.call(</span><span class="s4">this</span><span class="s2">);</span>
      <span class="s2">},</span>
      <span class="s2">set: </span><span class="s4">function </span><span class="s2">(value) {</span>
        <span class="s2">currentValue = </span><span class="s3">&quot;&quot; </span><span class="s2">+ value;</span>
        <span class="s2">set.call(</span><span class="s4">this</span><span class="s2">, value);</span>
      <span class="s2">}</span>
    <span class="s2">});</span>
    <span class="s2">Object.defineProperty(node, valueField, {</span>
      <span class="s2">enumerable: descriptor.enumerable</span>
    <span class="s2">});</span>
    <span class="s4">return </span><span class="s2">{</span>
      <span class="s2">getValue: </span><span class="s4">function </span><span class="s2">() {</span>
        <span class="s4">return </span><span class="s2">currentValue;</span>
      <span class="s2">},</span>
      <span class="s2">setValue: </span><span class="s4">function </span><span class="s2">(value) {</span>
        <span class="s2">currentValue = </span><span class="s3">&quot;&quot; </span><span class="s2">+ value;</span>
      <span class="s2">},</span>
      <span class="s2">stopTracking: </span><span class="s4">function </span><span class="s2">() {</span>
        <span class="s2">node._valueTracker = </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s4">delete </span><span class="s2">node[valueField];</span>
      <span class="s2">}</span>
    <span class="s2">};</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">track(node) {</span>
  <span class="s2">node._valueTracker || (node._valueTracker = trackValueOnNode(node));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateValueIfChanged(node) {</span>
  <span class="s4">if </span><span class="s2">(!node) </span><span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">tracker = node._valueTracker;</span>
  <span class="s4">if </span><span class="s2">(!tracker) </span><span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">lastValue = tracker.getValue();</span>
  <span class="s4">var </span><span class="s2">value = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
  <span class="s2">node &amp;&amp;</span>
    <span class="s2">(value = isCheckable(node)</span>
      <span class="s2">? node.checked</span>
        <span class="s2">? </span><span class="s3">&quot;true&quot;</span>
        <span class="s2">: </span><span class="s3">&quot;false&quot;</span>
      <span class="s2">: node.value);</span>
  <span class="s2">node = value;</span>
  <span class="s4">return </span><span class="s2">node !== lastValue ? (tracker.setValue(node), !</span><span class="s5">0</span><span class="s2">) : !</span><span class="s5">1</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getActiveElement(doc) {</span>
  <span class="s2">doc = doc || (</span><span class="s3">&quot;undefined&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">document ? document : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">);</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;undefined&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">doc) </span><span class="s4">return null</span><span class="s2">;</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s4">return </span><span class="s2">doc.activeElement || doc.body;</span>
  <span class="s2">} </span><span class="s4">catch </span><span class="s2">(e) {</span>
    <span class="s4">return </span><span class="s2">doc.body;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">escapeSelectorAttributeValueInsideDoubleQuotesRegex = </span><span class="s7">/[\n&quot;\\]/g</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">escapeSelectorAttributeValueInsideDoubleQuotes(value) {</span>
  <span class="s4">return </span><span class="s2">value.replace(</span>
    <span class="s2">escapeSelectorAttributeValueInsideDoubleQuotesRegex,</span>
    <span class="s4">function </span><span class="s2">(ch) {</span>
      <span class="s4">return </span><span class="s3">&quot;</span><span class="s6">\\</span><span class="s3">&quot; </span><span class="s2">+ ch.charCodeAt(</span><span class="s5">0</span><span class="s2">).toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot; &quot;</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateInput(</span>
  <span class="s2">element,</span>
  <span class="s2">value,</span>
  <span class="s2">defaultValue,</span>
  <span class="s2">lastDefaultValue,</span>
  <span class="s2">checked,</span>
  <span class="s2">defaultChecked,</span>
  <span class="s2">type,</span>
  <span class="s2">name</span>
<span class="s2">) {</span>
  <span class="s2">element.name = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
  <span class="s4">null </span><span class="s2">!= type &amp;&amp;</span>
  <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">type &amp;&amp;</span>
  <span class="s3">&quot;symbol&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">type &amp;&amp;</span>
  <span class="s3">&quot;boolean&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">type</span>
    <span class="s2">? (element.type = type)</span>
    <span class="s2">: element.removeAttribute(</span><span class="s3">&quot;type&quot;</span><span class="s2">);</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= value)</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;number&quot; </span><span class="s2">=== type) {</span>
      <span class="s4">if </span><span class="s2">((</span><span class="s5">0 </span><span class="s2">=== value &amp;&amp; </span><span class="s3">&quot;&quot; </span><span class="s2">=== element.value) || element.value != value)</span>
        <span class="s2">element.value = </span><span class="s3">&quot;&quot; </span><span class="s2">+ getToStringValue(value);</span>
    <span class="s2">} </span><span class="s4">else</span>
      <span class="s2">element.value !== </span><span class="s3">&quot;&quot; </span><span class="s2">+ getToStringValue(value) &amp;&amp;</span>
        <span class="s2">(element.value = </span><span class="s3">&quot;&quot; </span><span class="s2">+ getToStringValue(value));</span>
  <span class="s4">else</span>
    <span class="s2">(</span><span class="s3">&quot;submit&quot; </span><span class="s2">!== type &amp;&amp; </span><span class="s3">&quot;reset&quot; </span><span class="s2">!== type) || element.removeAttribute(</span><span class="s3">&quot;value&quot;</span><span class="s2">);</span>
  <span class="s4">null </span><span class="s2">!= value</span>
    <span class="s2">? setDefaultValue(element, type, getToStringValue(value))</span>
    <span class="s2">: </span><span class="s4">null </span><span class="s2">!= defaultValue</span>
      <span class="s2">? setDefaultValue(element, type, getToStringValue(defaultValue))</span>
      <span class="s2">: </span><span class="s4">null </span><span class="s2">!= lastDefaultValue &amp;&amp; element.removeAttribute(</span><span class="s3">&quot;value&quot;</span><span class="s2">);</span>
  <span class="s4">null </span><span class="s2">== checked &amp;&amp;</span>
    <span class="s4">null </span><span class="s2">!= defaultChecked &amp;&amp;</span>
    <span class="s2">(element.defaultChecked = !!defaultChecked);</span>
  <span class="s4">null </span><span class="s2">!= checked &amp;&amp;</span>
    <span class="s2">(element.checked =</span>
      <span class="s2">checked &amp;&amp; </span><span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">checked &amp;&amp; </span><span class="s3">&quot;symbol&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">checked);</span>
  <span class="s4">null </span><span class="s2">!= name &amp;&amp;</span>
  <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">name &amp;&amp;</span>
  <span class="s3">&quot;symbol&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">name &amp;&amp;</span>
  <span class="s3">&quot;boolean&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">name</span>
    <span class="s2">? (element.name = </span><span class="s3">&quot;&quot; </span><span class="s2">+ getToStringValue(name))</span>
    <span class="s2">: element.removeAttribute(</span><span class="s3">&quot;name&quot;</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">initInput(</span>
  <span class="s2">element,</span>
  <span class="s2">value,</span>
  <span class="s2">defaultValue,</span>
  <span class="s2">checked,</span>
  <span class="s2">defaultChecked,</span>
  <span class="s2">type,</span>
  <span class="s2">name,</span>
  <span class="s2">isHydrating</span>
<span class="s2">) {</span>
  <span class="s4">null </span><span class="s2">!= type &amp;&amp;</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">type &amp;&amp;</span>
    <span class="s3">&quot;symbol&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">type &amp;&amp;</span>
    <span class="s3">&quot;boolean&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">type &amp;&amp;</span>
    <span class="s2">(element.type = type);</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= value || </span><span class="s4">null </span><span class="s2">!= defaultValue) {</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">!(</span>
        <span class="s2">(</span><span class="s3">&quot;submit&quot; </span><span class="s2">!== type &amp;&amp; </span><span class="s3">&quot;reset&quot; </span><span class="s2">!== type) ||</span>
        <span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== value &amp;&amp; </span><span class="s4">null </span><span class="s2">!== value)</span>
      <span class="s2">)</span>
    <span class="s2">)</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s2">defaultValue =</span>
      <span class="s4">null </span><span class="s2">!= defaultValue ? </span><span class="s3">&quot;&quot; </span><span class="s2">+ getToStringValue(defaultValue) : </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
    <span class="s2">value = </span><span class="s4">null </span><span class="s2">!= value ? </span><span class="s3">&quot;&quot; </span><span class="s2">+ getToStringValue(value) : defaultValue;</span>
    <span class="s2">isHydrating || value === element.value || (element.value = value);</span>
    <span class="s2">element.defaultValue = value;</span>
  <span class="s2">}</span>
  <span class="s2">checked = </span><span class="s4">null </span><span class="s2">!= checked ? checked : defaultChecked;</span>
  <span class="s2">checked =</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">checked &amp;&amp; </span><span class="s3">&quot;symbol&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">checked &amp;&amp; !!checked;</span>
  <span class="s2">element.checked = isHydrating ? element.checked : !!checked;</span>
  <span class="s2">element.defaultChecked = !!checked;</span>
  <span class="s4">null </span><span class="s2">!= name &amp;&amp;</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">name &amp;&amp;</span>
    <span class="s3">&quot;symbol&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">name &amp;&amp;</span>
    <span class="s3">&quot;boolean&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">name &amp;&amp;</span>
    <span class="s2">(element.name = name);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">setDefaultValue(node, type, value) {</span>
  <span class="s2">(</span><span class="s3">&quot;number&quot; </span><span class="s2">=== type &amp;&amp; getActiveElement(node.ownerDocument) === node) ||</span>
    <span class="s2">node.defaultValue === </span><span class="s3">&quot;&quot; </span><span class="s2">+ value ||</span>
    <span class="s2">(node.defaultValue = </span><span class="s3">&quot;&quot; </span><span class="s2">+ value);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateOptions(node, multiple, propValue, setDefaultSelected) {</span>
  <span class="s2">node = node.options;</span>
  <span class="s4">if </span><span class="s2">(multiple) {</span>
    <span class="s2">multiple = {};</span>
    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; propValue.length; i++)</span>
      <span class="s2">multiple[</span><span class="s3">&quot;$&quot; </span><span class="s2">+ propValue[i]] = !</span><span class="s5">0</span><span class="s2">;</span>
    <span class="s4">for </span><span class="s2">(propValue = </span><span class="s5">0</span><span class="s2">; propValue &lt; node.length; propValue++)</span>
      <span class="s2">(i = multiple.hasOwnProperty(</span><span class="s3">&quot;$&quot; </span><span class="s2">+ node[propValue].value)),</span>
        <span class="s2">node[propValue].selected !== i &amp;&amp; (node[propValue].selected = i),</span>
        <span class="s2">i &amp;&amp; setDefaultSelected &amp;&amp; (node[propValue].defaultSelected = !</span><span class="s5">0</span><span class="s2">);</span>
  <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
    <span class="s2">propValue = </span><span class="s3">&quot;&quot; </span><span class="s2">+ getToStringValue(propValue);</span>
    <span class="s2">multiple = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">for </span><span class="s2">(i = </span><span class="s5">0</span><span class="s2">; i &lt; node.length; i++) {</span>
      <span class="s4">if </span><span class="s2">(node[i].value === propValue) {</span>
        <span class="s2">node[i].selected = !</span><span class="s5">0</span><span class="s2">;</span>
        <span class="s2">setDefaultSelected &amp;&amp; (node[i].defaultSelected = !</span><span class="s5">0</span><span class="s2">);</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s4">null </span><span class="s2">!== multiple || node[i].disabled || (multiple = node[i]);</span>
    <span class="s2">}</span>
    <span class="s4">null </span><span class="s2">!== multiple &amp;&amp; (multiple.selected = !</span><span class="s5">0</span><span class="s2">);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateTextarea(element, value, defaultValue) {</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s4">null </span><span class="s2">!= value &amp;&amp;</span>
    <span class="s2">((value = </span><span class="s3">&quot;&quot; </span><span class="s2">+ getToStringValue(value)),</span>
    <span class="s2">value !== element.value &amp;&amp; (element.value = value),</span>
    <span class="s4">null </span><span class="s2">== defaultValue)</span>
  <span class="s2">) {</span>
    <span class="s2">element.defaultValue !== value &amp;&amp; (element.defaultValue = value);</span>
    <span class="s4">return</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s2">element.defaultValue =</span>
    <span class="s4">null </span><span class="s2">!= defaultValue ? </span><span class="s3">&quot;&quot; </span><span class="s2">+ getToStringValue(defaultValue) : </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">initTextarea(element, value, defaultValue, children) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">== value) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= children) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= defaultValue) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">92</span><span class="s2">));</span>
      <span class="s4">if </span><span class="s2">(isArrayImpl(children)) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s5">1 </span><span class="s2">&lt; children.length) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">93</span><span class="s2">));</span>
        <span class="s2">children = children[</span><span class="s5">0</span><span class="s2">];</span>
      <span class="s2">}</span>
      <span class="s2">defaultValue = children;</span>
    <span class="s2">}</span>
    <span class="s4">null </span><span class="s2">== defaultValue &amp;&amp; (defaultValue = </span><span class="s3">&quot;&quot;</span><span class="s2">);</span>
    <span class="s2">value = defaultValue;</span>
  <span class="s2">}</span>
  <span class="s2">defaultValue = getToStringValue(value);</span>
  <span class="s2">element.defaultValue = defaultValue;</span>
  <span class="s2">children = element.textContent;</span>
  <span class="s2">children === defaultValue &amp;&amp;</span>
    <span class="s3">&quot;&quot; </span><span class="s2">!== children &amp;&amp;</span>
    <span class="s4">null </span><span class="s2">!== children &amp;&amp;</span>
    <span class="s2">(element.value = children);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">setTextContent(node, text) {</span>
  <span class="s4">if </span><span class="s2">(text) {</span>
    <span class="s4">var </span><span class="s2">firstChild = node.firstChild;</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">firstChild &amp;&amp;</span>
      <span class="s2">firstChild === node.lastChild &amp;&amp;</span>
      <span class="s5">3 </span><span class="s2">=== firstChild.nodeType</span>
    <span class="s2">) {</span>
      <span class="s2">firstChild.nodeValue = text;</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s2">node.textContent = text;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">unitlessNumbers = </span><span class="s4">new </span><span class="s2">Set(</span>
  <span class="s3">&quot;animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp&quot;</span><span class="s2">.split(</span>
    <span class="s3">&quot; &quot;</span>
  <span class="s2">)</span>
<span class="s2">);</span>
<span class="s4">function </span><span class="s2">setValueForStyle(style, styleName, value) {</span>
  <span class="s4">var </span><span class="s2">isCustomProperty = </span><span class="s5">0 </span><span class="s2">=== styleName.indexOf(</span><span class="s3">&quot;--&quot;</span><span class="s2">);</span>
  <span class="s4">null </span><span class="s2">== value || </span><span class="s3">&quot;boolean&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value || </span><span class="s3">&quot;&quot; </span><span class="s2">=== value</span>
    <span class="s2">? isCustomProperty</span>
      <span class="s2">? style.setProperty(styleName, </span><span class="s3">&quot;&quot;</span><span class="s2">)</span>
      <span class="s2">: </span><span class="s3">&quot;float&quot; </span><span class="s2">=== styleName</span>
        <span class="s2">? (style.cssFloat = </span><span class="s3">&quot;&quot;</span><span class="s2">)</span>
        <span class="s2">: (style[styleName] = </span><span class="s3">&quot;&quot;</span><span class="s2">)</span>
    <span class="s2">: isCustomProperty</span>
      <span class="s2">? style.setProperty(styleName, value)</span>
      <span class="s2">: </span><span class="s3">&quot;number&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">value ||</span>
          <span class="s5">0 </span><span class="s2">=== value ||</span>
          <span class="s2">unitlessNumbers.has(styleName)</span>
        <span class="s2">? </span><span class="s3">&quot;float&quot; </span><span class="s2">=== styleName</span>
          <span class="s2">? (style.cssFloat = value)</span>
          <span class="s2">: (style[styleName] = (</span><span class="s3">&quot;&quot; </span><span class="s2">+ value).trim())</span>
        <span class="s2">: (style[styleName] = value + </span><span class="s3">&quot;px&quot;</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">setValueForStyles(node, styles, prevStyles) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= styles &amp;&amp; </span><span class="s3">&quot;object&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">styles)</span>
    <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">62</span><span class="s2">));</span>
  <span class="s2">node = node.style;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= prevStyles) {</span>
    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">styleName </span><span class="s4">in </span><span class="s2">prevStyles)</span>
      <span class="s2">!prevStyles.hasOwnProperty(styleName) ||</span>
        <span class="s2">(</span><span class="s4">null </span><span class="s2">!= styles &amp;&amp; styles.hasOwnProperty(styleName)) ||</span>
        <span class="s2">(</span><span class="s5">0 </span><span class="s2">=== styleName.indexOf(</span><span class="s3">&quot;--&quot;</span><span class="s2">)</span>
          <span class="s2">? node.setProperty(styleName, </span><span class="s3">&quot;&quot;</span><span class="s2">)</span>
          <span class="s2">: </span><span class="s3">&quot;float&quot; </span><span class="s2">=== styleName</span>
            <span class="s2">? (node.cssFloat = </span><span class="s3">&quot;&quot;</span><span class="s2">)</span>
            <span class="s2">: (node[styleName] = </span><span class="s3">&quot;&quot;</span><span class="s2">));</span>
    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">styleName$18 </span><span class="s4">in </span><span class="s2">styles)</span>
      <span class="s2">(styleName = styles[styleName$18]),</span>
        <span class="s2">styles.hasOwnProperty(styleName$18) &amp;&amp;</span>
          <span class="s2">prevStyles[styleName$18] !== styleName &amp;&amp;</span>
          <span class="s2">setValueForStyle(node, styleName$18, styleName);</span>
  <span class="s2">} </span><span class="s4">else</span>
    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">styleName$19 </span><span class="s4">in </span><span class="s2">styles)</span>
      <span class="s2">styles.hasOwnProperty(styleName$19) &amp;&amp;</span>
        <span class="s2">setValueForStyle(node, styleName$19, styles[styleName$19]);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">isCustomElement(tagName) {</span>
  <span class="s4">if </span><span class="s2">(-</span><span class="s5">1 </span><span class="s2">=== tagName.indexOf(</span><span class="s3">&quot;-&quot;</span><span class="s2">)) </span><span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">switch </span><span class="s2">(tagName) {</span>
    <span class="s4">case </span><span class="s3">&quot;annotation-xml&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;color-profile&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;font-face&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;font-face-src&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;font-face-uri&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;font-face-format&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;font-face-name&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;missing-glyph&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">aliases = </span><span class="s4">new </span><span class="s2">Map([</span>
    <span class="s2">[</span><span class="s3">&quot;acceptCharset&quot;</span><span class="s2">, </span><span class="s3">&quot;accept-charset&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;htmlFor&quot;</span><span class="s2">, </span><span class="s3">&quot;for&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;httpEquiv&quot;</span><span class="s2">, </span><span class="s3">&quot;http-equiv&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;crossOrigin&quot;</span><span class="s2">, </span><span class="s3">&quot;crossorigin&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;accentHeight&quot;</span><span class="s2">, </span><span class="s3">&quot;accent-height&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;alignmentBaseline&quot;</span><span class="s2">, </span><span class="s3">&quot;alignment-baseline&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;arabicForm&quot;</span><span class="s2">, </span><span class="s3">&quot;arabic-form&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;baselineShift&quot;</span><span class="s2">, </span><span class="s3">&quot;baseline-shift&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;capHeight&quot;</span><span class="s2">, </span><span class="s3">&quot;cap-height&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;clipPath&quot;</span><span class="s2">, </span><span class="s3">&quot;clip-path&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;clipRule&quot;</span><span class="s2">, </span><span class="s3">&quot;clip-rule&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;colorInterpolation&quot;</span><span class="s2">, </span><span class="s3">&quot;color-interpolation&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;colorInterpolationFilters&quot;</span><span class="s2">, </span><span class="s3">&quot;color-interpolation-filters&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;colorProfile&quot;</span><span class="s2">, </span><span class="s3">&quot;color-profile&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;colorRendering&quot;</span><span class="s2">, </span><span class="s3">&quot;color-rendering&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;dominantBaseline&quot;</span><span class="s2">, </span><span class="s3">&quot;dominant-baseline&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;enableBackground&quot;</span><span class="s2">, </span><span class="s3">&quot;enable-background&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;fillOpacity&quot;</span><span class="s2">, </span><span class="s3">&quot;fill-opacity&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;fillRule&quot;</span><span class="s2">, </span><span class="s3">&quot;fill-rule&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;floodColor&quot;</span><span class="s2">, </span><span class="s3">&quot;flood-color&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;floodOpacity&quot;</span><span class="s2">, </span><span class="s3">&quot;flood-opacity&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;fontFamily&quot;</span><span class="s2">, </span><span class="s3">&quot;font-family&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;fontSize&quot;</span><span class="s2">, </span><span class="s3">&quot;font-size&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;fontSizeAdjust&quot;</span><span class="s2">, </span><span class="s3">&quot;font-size-adjust&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;fontStretch&quot;</span><span class="s2">, </span><span class="s3">&quot;font-stretch&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;fontStyle&quot;</span><span class="s2">, </span><span class="s3">&quot;font-style&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;fontVariant&quot;</span><span class="s2">, </span><span class="s3">&quot;font-variant&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;fontWeight&quot;</span><span class="s2">, </span><span class="s3">&quot;font-weight&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;glyphName&quot;</span><span class="s2">, </span><span class="s3">&quot;glyph-name&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;glyphOrientationHorizontal&quot;</span><span class="s2">, </span><span class="s3">&quot;glyph-orientation-horizontal&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;glyphOrientationVertical&quot;</span><span class="s2">, </span><span class="s3">&quot;glyph-orientation-vertical&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;horizAdvX&quot;</span><span class="s2">, </span><span class="s3">&quot;horiz-adv-x&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;horizOriginX&quot;</span><span class="s2">, </span><span class="s3">&quot;horiz-origin-x&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;imageRendering&quot;</span><span class="s2">, </span><span class="s3">&quot;image-rendering&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;letterSpacing&quot;</span><span class="s2">, </span><span class="s3">&quot;letter-spacing&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;lightingColor&quot;</span><span class="s2">, </span><span class="s3">&quot;lighting-color&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;markerEnd&quot;</span><span class="s2">, </span><span class="s3">&quot;marker-end&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;markerMid&quot;</span><span class="s2">, </span><span class="s3">&quot;marker-mid&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;markerStart&quot;</span><span class="s2">, </span><span class="s3">&quot;marker-start&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;overlinePosition&quot;</span><span class="s2">, </span><span class="s3">&quot;overline-position&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;overlineThickness&quot;</span><span class="s2">, </span><span class="s3">&quot;overline-thickness&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;paintOrder&quot;</span><span class="s2">, </span><span class="s3">&quot;paint-order&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;panose-1&quot;</span><span class="s2">, </span><span class="s3">&quot;panose-1&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;pointerEvents&quot;</span><span class="s2">, </span><span class="s3">&quot;pointer-events&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;renderingIntent&quot;</span><span class="s2">, </span><span class="s3">&quot;rendering-intent&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;shapeRendering&quot;</span><span class="s2">, </span><span class="s3">&quot;shape-rendering&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;stopColor&quot;</span><span class="s2">, </span><span class="s3">&quot;stop-color&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;stopOpacity&quot;</span><span class="s2">, </span><span class="s3">&quot;stop-opacity&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;strikethroughPosition&quot;</span><span class="s2">, </span><span class="s3">&quot;strikethrough-position&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;strikethroughThickness&quot;</span><span class="s2">, </span><span class="s3">&quot;strikethrough-thickness&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;strokeDasharray&quot;</span><span class="s2">, </span><span class="s3">&quot;stroke-dasharray&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;strokeDashoffset&quot;</span><span class="s2">, </span><span class="s3">&quot;stroke-dashoffset&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;strokeLinecap&quot;</span><span class="s2">, </span><span class="s3">&quot;stroke-linecap&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;strokeLinejoin&quot;</span><span class="s2">, </span><span class="s3">&quot;stroke-linejoin&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;strokeMiterlimit&quot;</span><span class="s2">, </span><span class="s3">&quot;stroke-miterlimit&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;strokeOpacity&quot;</span><span class="s2">, </span><span class="s3">&quot;stroke-opacity&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;strokeWidth&quot;</span><span class="s2">, </span><span class="s3">&quot;stroke-width&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;textAnchor&quot;</span><span class="s2">, </span><span class="s3">&quot;text-anchor&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;textDecoration&quot;</span><span class="s2">, </span><span class="s3">&quot;text-decoration&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;textRendering&quot;</span><span class="s2">, </span><span class="s3">&quot;text-rendering&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;transformOrigin&quot;</span><span class="s2">, </span><span class="s3">&quot;transform-origin&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;underlinePosition&quot;</span><span class="s2">, </span><span class="s3">&quot;underline-position&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;underlineThickness&quot;</span><span class="s2">, </span><span class="s3">&quot;underline-thickness&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;unicodeBidi&quot;</span><span class="s2">, </span><span class="s3">&quot;unicode-bidi&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;unicodeRange&quot;</span><span class="s2">, </span><span class="s3">&quot;unicode-range&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;unitsPerEm&quot;</span><span class="s2">, </span><span class="s3">&quot;units-per-em&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;vAlphabetic&quot;</span><span class="s2">, </span><span class="s3">&quot;v-alphabetic&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;vHanging&quot;</span><span class="s2">, </span><span class="s3">&quot;v-hanging&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;vIdeographic&quot;</span><span class="s2">, </span><span class="s3">&quot;v-ideographic&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;vMathematical&quot;</span><span class="s2">, </span><span class="s3">&quot;v-mathematical&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;vectorEffect&quot;</span><span class="s2">, </span><span class="s3">&quot;vector-effect&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;vertAdvY&quot;</span><span class="s2">, </span><span class="s3">&quot;vert-adv-y&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;vertOriginX&quot;</span><span class="s2">, </span><span class="s3">&quot;vert-origin-x&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;vertOriginY&quot;</span><span class="s2">, </span><span class="s3">&quot;vert-origin-y&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;wordSpacing&quot;</span><span class="s2">, </span><span class="s3">&quot;word-spacing&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;writingMode&quot;</span><span class="s2">, </span><span class="s3">&quot;writing-mode&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;xmlnsXlink&quot;</span><span class="s2">, </span><span class="s3">&quot;xmlns:xlink&quot;</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">&quot;xHeight&quot;</span><span class="s2">, </span><span class="s3">&quot;x-height&quot;</span><span class="s2">]</span>
  <span class="s2">]),</span>
  <span class="s2">isJavaScriptProtocol =</span>
    <span class="s7">/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">sanitizeURL(url) {</span>
  <span class="s4">return </span><span class="s2">isJavaScriptProtocol.test(</span><span class="s3">&quot;&quot; </span><span class="s2">+ url)</span>
    <span class="s2">? </span><span class="s3">&quot;javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')&quot;</span>
    <span class="s2">: url;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">currentReplayingEvent = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">getEventTarget(nativeEvent) {</span>
  <span class="s2">nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;</span>
  <span class="s2">nativeEvent.correspondingUseElement &amp;&amp;</span>
    <span class="s2">(nativeEvent = nativeEvent.correspondingUseElement);</span>
  <span class="s4">return </span><span class="s5">3 </span><span class="s2">=== nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">restoreTarget = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">restoreQueue = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">restoreStateOfTarget(target) {</span>
  <span class="s4">var </span><span class="s2">internalInstance = getInstanceFromNode(target);</span>
  <span class="s4">if </span><span class="s2">(internalInstance &amp;&amp; (target = internalInstance.stateNode)) {</span>
    <span class="s4">var </span><span class="s2">props = target[internalPropsKey] || </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s2">a: </span><span class="s4">switch </span><span class="s2">(((target = internalInstance.stateNode), internalInstance.type)) {</span>
      <span class="s4">case </span><span class="s3">&quot;input&quot;</span><span class="s2">:</span>
        <span class="s2">updateInput(</span>
          <span class="s2">target,</span>
          <span class="s2">props.value,</span>
          <span class="s2">props.defaultValue,</span>
          <span class="s2">props.defaultValue,</span>
          <span class="s2">props.checked,</span>
          <span class="s2">props.defaultChecked,</span>
          <span class="s2">props.type,</span>
          <span class="s2">props.name</span>
        <span class="s2">);</span>
        <span class="s2">internalInstance = props.name;</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;radio&quot; </span><span class="s2">=== props.type &amp;&amp; </span><span class="s4">null </span><span class="s2">!= internalInstance) {</span>
          <span class="s4">for </span><span class="s2">(props = target; props.parentNode; ) props = props.parentNode;</span>
          <span class="s2">props = props.querySelectorAll(</span>
            <span class="s3">'input[name=&quot;' </span><span class="s2">+</span>
              <span class="s2">escapeSelectorAttributeValueInsideDoubleQuotes(</span>
                <span class="s3">&quot;&quot; </span><span class="s2">+ internalInstance</span>
              <span class="s2">) +</span>
              <span class="s3">'&quot;][type=&quot;radio&quot;]'</span>
          <span class="s2">);</span>
          <span class="s4">for </span><span class="s2">(</span>
            <span class="s2">internalInstance = </span><span class="s5">0</span><span class="s2">;</span>
            <span class="s2">internalInstance &lt; props.length;</span>
            <span class="s2">internalInstance++</span>
          <span class="s2">) {</span>
            <span class="s4">var </span><span class="s2">otherNode = props[internalInstance];</span>
            <span class="s4">if </span><span class="s2">(otherNode !== target &amp;&amp; otherNode.form === target.form) {</span>
              <span class="s4">var </span><span class="s2">otherProps = otherNode[internalPropsKey] || </span><span class="s4">null</span><span class="s2">;</span>
              <span class="s4">if </span><span class="s2">(!otherProps) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">90</span><span class="s2">));</span>
              <span class="s2">updateInput(</span>
                <span class="s2">otherNode,</span>
                <span class="s2">otherProps.value,</span>
                <span class="s2">otherProps.defaultValue,</span>
                <span class="s2">otherProps.defaultValue,</span>
                <span class="s2">otherProps.checked,</span>
                <span class="s2">otherProps.defaultChecked,</span>
                <span class="s2">otherProps.type,</span>
                <span class="s2">otherProps.name</span>
              <span class="s2">);</span>
            <span class="s2">}</span>
          <span class="s2">}</span>
          <span class="s4">for </span><span class="s2">(</span>
            <span class="s2">internalInstance = </span><span class="s5">0</span><span class="s2">;</span>
            <span class="s2">internalInstance &lt; props.length;</span>
            <span class="s2">internalInstance++</span>
          <span class="s2">)</span>
            <span class="s2">(otherNode = props[internalInstance]),</span>
              <span class="s2">otherNode.form === target.form &amp;&amp; updateValueIfChanged(otherNode);</span>
        <span class="s2">}</span>
        <span class="s4">break </span><span class="s2">a;</span>
      <span class="s4">case </span><span class="s3">&quot;textarea&quot;</span><span class="s2">:</span>
        <span class="s2">updateTextarea(target, props.value, props.defaultValue);</span>
        <span class="s4">break </span><span class="s2">a;</span>
      <span class="s4">case </span><span class="s3">&quot;select&quot;</span><span class="s2">:</span>
        <span class="s2">(internalInstance = props.value),</span>
          <span class="s4">null </span><span class="s2">!= internalInstance &amp;&amp;</span>
            <span class="s2">updateOptions(target, !!props.multiple, internalInstance, !</span><span class="s5">1</span><span class="s2">);</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">isInsideEventHandler = !</span><span class="s5">1</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">batchedUpdates$2(fn, a, b) {</span>
  <span class="s4">if </span><span class="s2">(isInsideEventHandler) </span><span class="s4">return </span><span class="s2">fn(a, b);</span>
  <span class="s2">isInsideEventHandler = !</span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">JSCompiler_inline_result = fn(a);</span>
    <span class="s4">return </span><span class="s2">JSCompiler_inline_result;</span>
  <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">((isInsideEventHandler = !</span><span class="s5">1</span><span class="s2">),</span>
      <span class="s4">null </span><span class="s2">!== restoreTarget || </span><span class="s4">null </span><span class="s2">!== restoreQueue)</span>
    <span class="s2">)</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">(flushSyncWork$1(),</span>
        <span class="s2">restoreTarget &amp;&amp;</span>
          <span class="s2">((a = restoreTarget),</span>
          <span class="s2">(fn = restoreQueue),</span>
          <span class="s2">(restoreQueue = restoreTarget = </span><span class="s4">null</span><span class="s2">),</span>
          <span class="s2">restoreStateOfTarget(a),</span>
          <span class="s2">fn))</span>
      <span class="s2">)</span>
        <span class="s4">for </span><span class="s2">(a = </span><span class="s5">0</span><span class="s2">; a &lt; fn.length; a++) restoreStateOfTarget(fn[a]);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getListener(inst, registrationName) {</span>
  <span class="s4">var </span><span class="s2">stateNode = inst.stateNode;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== stateNode) </span><span class="s4">return null</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">props = stateNode[internalPropsKey] || </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== props) </span><span class="s4">return null</span><span class="s2">;</span>
  <span class="s2">stateNode = props[registrationName];</span>
  <span class="s2">a: </span><span class="s4">switch </span><span class="s2">(registrationName) {</span>
    <span class="s4">case </span><span class="s3">&quot;onClick&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;onClickCapture&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;onDoubleClick&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;onDoubleClickCapture&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;onMouseDown&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;onMouseDownCapture&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;onMouseMove&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;onMouseMoveCapture&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;onMouseUp&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;onMouseUpCapture&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;onMouseEnter&quot;</span><span class="s2">:</span>
      <span class="s2">(props = !props.disabled) ||</span>
        <span class="s2">((inst = inst.type),</span>
        <span class="s2">(props = !(</span>
          <span class="s3">&quot;button&quot; </span><span class="s2">=== inst ||</span>
          <span class="s3">&quot;input&quot; </span><span class="s2">=== inst ||</span>
          <span class="s3">&quot;select&quot; </span><span class="s2">=== inst ||</span>
          <span class="s3">&quot;textarea&quot; </span><span class="s2">=== inst</span>
        <span class="s2">)));</span>
      <span class="s2">inst = !props;</span>
      <span class="s4">break </span><span class="s2">a;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s2">inst = !</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s4">if </span><span class="s2">(inst) </span><span class="s4">return null</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(stateNode &amp;&amp; </span><span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">stateNode)</span>
    <span class="s4">throw </span><span class="s2">Error(</span>
      <span class="s2">formatProdErrorMessage(</span><span class="s5">231</span><span class="s2">, registrationName, </span><span class="s4">typeof </span><span class="s2">stateNode)</span>
    <span class="s2">);</span>
  <span class="s4">return </span><span class="s2">stateNode;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">canUseDOM = !(</span>
    <span class="s3">&quot;undefined&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">window ||</span>
    <span class="s3">&quot;undefined&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">window.document ||</span>
    <span class="s3">&quot;undefined&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">window.document.createElement</span>
  <span class="s2">),</span>
  <span class="s2">passiveBrowserEventsSupported = !</span><span class="s5">1</span><span class="s2">;</span>
<span class="s4">if </span><span class="s2">(canUseDOM)</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">options = {};</span>
    <span class="s2">Object.defineProperty(options, </span><span class="s3">&quot;passive&quot;</span><span class="s2">, {</span>
      <span class="s2">get: </span><span class="s4">function </span><span class="s2">() {</span>
        <span class="s2">passiveBrowserEventsSupported = !</span><span class="s5">0</span><span class="s2">;</span>
      <span class="s2">}</span>
    <span class="s2">});</span>
    <span class="s2">window.addEventListener(</span><span class="s3">&quot;test&quot;</span><span class="s2">, options, options);</span>
    <span class="s2">window.removeEventListener(</span><span class="s3">&quot;test&quot;</span><span class="s2">, options, options);</span>
  <span class="s2">} </span><span class="s4">catch </span><span class="s2">(e) {</span>
    <span class="s2">passiveBrowserEventsSupported = !</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">}</span>
<span class="s4">var </span><span class="s2">root = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">startText = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">fallbackText = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">getData() {</span>
  <span class="s4">if </span><span class="s2">(fallbackText) </span><span class="s4">return </span><span class="s2">fallbackText;</span>
  <span class="s4">var </span><span class="s2">start,</span>
    <span class="s2">startValue = startText,</span>
    <span class="s2">startLength = startValue.length,</span>
    <span class="s2">end,</span>
    <span class="s2">endValue = </span><span class="s3">&quot;value&quot; </span><span class="s4">in </span><span class="s2">root ? root.value : root.textContent,</span>
    <span class="s2">endLength = endValue.length;</span>
  <span class="s4">for </span><span class="s2">(</span>
    <span class="s2">start = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">start &lt; startLength &amp;&amp; startValue[start] === endValue[start];</span>
    <span class="s2">start++</span>
  <span class="s2">);</span>
  <span class="s4">var </span><span class="s2">minEnd = startLength - start;</span>
  <span class="s4">for </span><span class="s2">(</span>
    <span class="s2">end = </span><span class="s5">1</span><span class="s2">;</span>
    <span class="s2">end &lt;= minEnd &amp;&amp;</span>
    <span class="s2">startValue[startLength - end] === endValue[endLength - end];</span>
    <span class="s2">end++</span>
  <span class="s2">);</span>
  <span class="s4">return </span><span class="s2">(fallbackText = endValue.slice(start, </span><span class="s5">1 </span><span class="s2">&lt; end ? </span><span class="s5">1 </span><span class="s2">- end : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getEventCharCode(nativeEvent) {</span>
  <span class="s4">var </span><span class="s2">keyCode = nativeEvent.keyCode;</span>
  <span class="s3">&quot;charCode&quot; </span><span class="s4">in </span><span class="s2">nativeEvent</span>
    <span class="s2">? ((nativeEvent = nativeEvent.charCode),</span>
      <span class="s5">0 </span><span class="s2">=== nativeEvent &amp;&amp; </span><span class="s5">13 </span><span class="s2">=== keyCode &amp;&amp; (nativeEvent = </span><span class="s5">13</span><span class="s2">))</span>
    <span class="s2">: (nativeEvent = keyCode);</span>
  <span class="s5">10 </span><span class="s2">=== nativeEvent &amp;&amp; (nativeEvent = </span><span class="s5">13</span><span class="s2">);</span>
  <span class="s4">return </span><span class="s5">32 </span><span class="s2">&lt;= nativeEvent || </span><span class="s5">13 </span><span class="s2">=== nativeEvent ? nativeEvent : </span><span class="s5">0</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">functionThatReturnsTrue() {</span>
  <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">functionThatReturnsFalse() {</span>
  <span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createSyntheticEvent(Interface) {</span>
  <span class="s4">function </span><span class="s2">SyntheticBaseEvent(</span>
    <span class="s2">reactName,</span>
    <span class="s2">reactEventType,</span>
    <span class="s2">targetInst,</span>
    <span class="s2">nativeEvent,</span>
    <span class="s2">nativeEventTarget</span>
  <span class="s2">) {</span>
    <span class="s4">this</span><span class="s2">._reactName = reactName;</span>
    <span class="s4">this</span><span class="s2">._targetInst = targetInst;</span>
    <span class="s4">this</span><span class="s2">.type = reactEventType;</span>
    <span class="s4">this</span><span class="s2">.nativeEvent = nativeEvent;</span>
    <span class="s4">this</span><span class="s2">.target = nativeEventTarget;</span>
    <span class="s4">this</span><span class="s2">.currentTarget = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">propName </span><span class="s4">in </span><span class="s2">Interface)</span>
      <span class="s2">Interface.hasOwnProperty(propName) &amp;&amp;</span>
        <span class="s2">((reactName = Interface[propName]),</span>
        <span class="s2">(</span><span class="s4">this</span><span class="s2">[propName] = reactName</span>
          <span class="s2">? reactName(nativeEvent)</span>
          <span class="s2">: nativeEvent[propName]));</span>
    <span class="s4">this</span><span class="s2">.isDefaultPrevented = (</span>
      <span class="s4">null </span><span class="s2">!= nativeEvent.defaultPrevented</span>
        <span class="s2">? nativeEvent.defaultPrevented</span>
        <span class="s2">: !</span><span class="s5">1 </span><span class="s2">=== nativeEvent.returnValue</span>
    <span class="s2">)</span>
      <span class="s2">? functionThatReturnsTrue</span>
      <span class="s2">: functionThatReturnsFalse;</span>
    <span class="s4">this</span><span class="s2">.isPropagationStopped = functionThatReturnsFalse;</span>
    <span class="s4">return this</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s2">assign(SyntheticBaseEvent.prototype, {</span>
    <span class="s2">preventDefault: </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">this</span><span class="s2">.defaultPrevented = !</span><span class="s5">0</span><span class="s2">;</span>
      <span class="s4">var </span><span class="s2">event = </span><span class="s4">this</span><span class="s2">.nativeEvent;</span>
      <span class="s2">event &amp;&amp;</span>
        <span class="s2">(event.preventDefault</span>
          <span class="s2">? event.preventDefault()</span>
          <span class="s2">: </span><span class="s3">&quot;unknown&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">event.returnValue &amp;&amp; (event.returnValue = !</span><span class="s5">1</span><span class="s2">),</span>
        <span class="s2">(</span><span class="s4">this</span><span class="s2">.isDefaultPrevented = functionThatReturnsTrue));</span>
    <span class="s2">},</span>
    <span class="s2">stopPropagation: </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">var </span><span class="s2">event = </span><span class="s4">this</span><span class="s2">.nativeEvent;</span>
      <span class="s2">event &amp;&amp;</span>
        <span class="s2">(event.stopPropagation</span>
          <span class="s2">? event.stopPropagation()</span>
          <span class="s2">: </span><span class="s3">&quot;unknown&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">event.cancelBubble &amp;&amp;</span>
            <span class="s2">(event.cancelBubble = !</span><span class="s5">0</span><span class="s2">),</span>
        <span class="s2">(</span><span class="s4">this</span><span class="s2">.isPropagationStopped = functionThatReturnsTrue));</span>
    <span class="s2">},</span>
    <span class="s2">persist: </span><span class="s4">function </span><span class="s2">() {},</span>
    <span class="s2">isPersistent: functionThatReturnsTrue</span>
  <span class="s2">});</span>
  <span class="s4">return </span><span class="s2">SyntheticBaseEvent;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">EventInterface = {</span>
    <span class="s2">eventPhase: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">bubbles: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">cancelable: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">timeStamp: </span><span class="s4">function </span><span class="s2">(event) {</span>
      <span class="s4">return </span><span class="s2">event.timeStamp || Date.now();</span>
    <span class="s2">},</span>
    <span class="s2">defaultPrevented: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">isTrusted: </span><span class="s5">0</span>
  <span class="s2">},</span>
  <span class="s2">SyntheticEvent = createSyntheticEvent(EventInterface),</span>
  <span class="s2">UIEventInterface = assign({}, EventInterface, { view: </span><span class="s5">0</span><span class="s2">, detail: </span><span class="s5">0 </span><span class="s2">}),</span>
  <span class="s2">SyntheticUIEvent = createSyntheticEvent(UIEventInterface),</span>
  <span class="s2">lastMovementX,</span>
  <span class="s2">lastMovementY,</span>
  <span class="s2">lastMouseEvent,</span>
  <span class="s2">MouseEventInterface = assign({}, UIEventInterface, {</span>
    <span class="s2">screenX: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">screenY: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">clientX: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">clientY: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">pageX: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">pageY: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">ctrlKey: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">shiftKey: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">altKey: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">metaKey: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">getModifierState: getEventModifierState,</span>
    <span class="s2">button: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">buttons: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">relatedTarget: </span><span class="s4">function </span><span class="s2">(event) {</span>
      <span class="s4">return void </span><span class="s5">0 </span><span class="s2">=== event.relatedTarget</span>
        <span class="s2">? event.fromElement === event.srcElement</span>
          <span class="s2">? event.toElement</span>
          <span class="s2">: event.fromElement</span>
        <span class="s2">: event.relatedTarget;</span>
    <span class="s2">},</span>
    <span class="s2">movementX: </span><span class="s4">function </span><span class="s2">(event) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;movementX&quot; </span><span class="s4">in </span><span class="s2">event) </span><span class="s4">return </span><span class="s2">event.movementX;</span>
      <span class="s2">event !== lastMouseEvent &amp;&amp;</span>
        <span class="s2">(lastMouseEvent &amp;&amp; </span><span class="s3">&quot;mousemove&quot; </span><span class="s2">=== event.type</span>
          <span class="s2">? ((lastMovementX = event.screenX - lastMouseEvent.screenX),</span>
            <span class="s2">(lastMovementY = event.screenY - lastMouseEvent.screenY))</span>
          <span class="s2">: (lastMovementY = lastMovementX = </span><span class="s5">0</span><span class="s2">),</span>
        <span class="s2">(lastMouseEvent = event));</span>
      <span class="s4">return </span><span class="s2">lastMovementX;</span>
    <span class="s2">},</span>
    <span class="s2">movementY: </span><span class="s4">function </span><span class="s2">(event) {</span>
      <span class="s4">return </span><span class="s3">&quot;movementY&quot; </span><span class="s4">in </span><span class="s2">event ? event.movementY : lastMovementY;</span>
    <span class="s2">}</span>
  <span class="s2">}),</span>
  <span class="s2">SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),</span>
  <span class="s2">DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: </span><span class="s5">0 </span><span class="s2">}),</span>
  <span class="s2">SyntheticDragEvent = createSyntheticEvent(DragEventInterface),</span>
  <span class="s2">FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: </span><span class="s5">0 </span><span class="s2">}),</span>
  <span class="s2">SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),</span>
  <span class="s2">AnimationEventInterface = assign({}, EventInterface, {</span>
    <span class="s2">animationName: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">elapsedTime: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">pseudoElement: </span><span class="s5">0</span>
  <span class="s2">}),</span>
  <span class="s2">SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),</span>
  <span class="s2">ClipboardEventInterface = assign({}, EventInterface, {</span>
    <span class="s2">clipboardData: </span><span class="s4">function </span><span class="s2">(event) {</span>
      <span class="s4">return </span><span class="s3">&quot;clipboardData&quot; </span><span class="s4">in </span><span class="s2">event</span>
        <span class="s2">? event.clipboardData</span>
        <span class="s2">: window.clipboardData;</span>
    <span class="s2">}</span>
  <span class="s2">}),</span>
  <span class="s2">SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),</span>
  <span class="s2">CompositionEventInterface = assign({}, EventInterface, { data: </span><span class="s5">0 </span><span class="s2">}),</span>
  <span class="s2">SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface),</span>
  <span class="s2">normalizeKey = {</span>
    <span class="s2">Esc: </span><span class="s3">&quot;Escape&quot;</span><span class="s2">,</span>
    <span class="s2">Spacebar: </span><span class="s3">&quot; &quot;</span><span class="s2">,</span>
    <span class="s2">Left: </span><span class="s3">&quot;ArrowLeft&quot;</span><span class="s2">,</span>
    <span class="s2">Up: </span><span class="s3">&quot;ArrowUp&quot;</span><span class="s2">,</span>
    <span class="s2">Right: </span><span class="s3">&quot;ArrowRight&quot;</span><span class="s2">,</span>
    <span class="s2">Down: </span><span class="s3">&quot;ArrowDown&quot;</span><span class="s2">,</span>
    <span class="s2">Del: </span><span class="s3">&quot;Delete&quot;</span><span class="s2">,</span>
    <span class="s2">Win: </span><span class="s3">&quot;OS&quot;</span><span class="s2">,</span>
    <span class="s2">Menu: </span><span class="s3">&quot;ContextMenu&quot;</span><span class="s2">,</span>
    <span class="s2">Apps: </span><span class="s3">&quot;ContextMenu&quot;</span><span class="s2">,</span>
    <span class="s2">Scroll: </span><span class="s3">&quot;ScrollLock&quot;</span><span class="s2">,</span>
    <span class="s2">MozPrintableKey: </span><span class="s3">&quot;Unidentified&quot;</span>
  <span class="s2">},</span>
  <span class="s2">translateToKey = {</span>
    <span class="s5">8</span><span class="s2">: </span><span class="s3">&quot;Backspace&quot;</span><span class="s2">,</span>
    <span class="s5">9</span><span class="s2">: </span><span class="s3">&quot;Tab&quot;</span><span class="s2">,</span>
    <span class="s5">12</span><span class="s2">: </span><span class="s3">&quot;Clear&quot;</span><span class="s2">,</span>
    <span class="s5">13</span><span class="s2">: </span><span class="s3">&quot;Enter&quot;</span><span class="s2">,</span>
    <span class="s5">16</span><span class="s2">: </span><span class="s3">&quot;Shift&quot;</span><span class="s2">,</span>
    <span class="s5">17</span><span class="s2">: </span><span class="s3">&quot;Control&quot;</span><span class="s2">,</span>
    <span class="s5">18</span><span class="s2">: </span><span class="s3">&quot;Alt&quot;</span><span class="s2">,</span>
    <span class="s5">19</span><span class="s2">: </span><span class="s3">&quot;Pause&quot;</span><span class="s2">,</span>
    <span class="s5">20</span><span class="s2">: </span><span class="s3">&quot;CapsLock&quot;</span><span class="s2">,</span>
    <span class="s5">27</span><span class="s2">: </span><span class="s3">&quot;Escape&quot;</span><span class="s2">,</span>
    <span class="s5">32</span><span class="s2">: </span><span class="s3">&quot; &quot;</span><span class="s2">,</span>
    <span class="s5">33</span><span class="s2">: </span><span class="s3">&quot;PageUp&quot;</span><span class="s2">,</span>
    <span class="s5">34</span><span class="s2">: </span><span class="s3">&quot;PageDown&quot;</span><span class="s2">,</span>
    <span class="s5">35</span><span class="s2">: </span><span class="s3">&quot;End&quot;</span><span class="s2">,</span>
    <span class="s5">36</span><span class="s2">: </span><span class="s3">&quot;Home&quot;</span><span class="s2">,</span>
    <span class="s5">37</span><span class="s2">: </span><span class="s3">&quot;ArrowLeft&quot;</span><span class="s2">,</span>
    <span class="s5">38</span><span class="s2">: </span><span class="s3">&quot;ArrowUp&quot;</span><span class="s2">,</span>
    <span class="s5">39</span><span class="s2">: </span><span class="s3">&quot;ArrowRight&quot;</span><span class="s2">,</span>
    <span class="s5">40</span><span class="s2">: </span><span class="s3">&quot;ArrowDown&quot;</span><span class="s2">,</span>
    <span class="s5">45</span><span class="s2">: </span><span class="s3">&quot;Insert&quot;</span><span class="s2">,</span>
    <span class="s5">46</span><span class="s2">: </span><span class="s3">&quot;Delete&quot;</span><span class="s2">,</span>
    <span class="s5">112</span><span class="s2">: </span><span class="s3">&quot;F1&quot;</span><span class="s2">,</span>
    <span class="s5">113</span><span class="s2">: </span><span class="s3">&quot;F2&quot;</span><span class="s2">,</span>
    <span class="s5">114</span><span class="s2">: </span><span class="s3">&quot;F3&quot;</span><span class="s2">,</span>
    <span class="s5">115</span><span class="s2">: </span><span class="s3">&quot;F4&quot;</span><span class="s2">,</span>
    <span class="s5">116</span><span class="s2">: </span><span class="s3">&quot;F5&quot;</span><span class="s2">,</span>
    <span class="s5">117</span><span class="s2">: </span><span class="s3">&quot;F6&quot;</span><span class="s2">,</span>
    <span class="s5">118</span><span class="s2">: </span><span class="s3">&quot;F7&quot;</span><span class="s2">,</span>
    <span class="s5">119</span><span class="s2">: </span><span class="s3">&quot;F8&quot;</span><span class="s2">,</span>
    <span class="s5">120</span><span class="s2">: </span><span class="s3">&quot;F9&quot;</span><span class="s2">,</span>
    <span class="s5">121</span><span class="s2">: </span><span class="s3">&quot;F10&quot;</span><span class="s2">,</span>
    <span class="s5">122</span><span class="s2">: </span><span class="s3">&quot;F11&quot;</span><span class="s2">,</span>
    <span class="s5">123</span><span class="s2">: </span><span class="s3">&quot;F12&quot;</span><span class="s2">,</span>
    <span class="s5">144</span><span class="s2">: </span><span class="s3">&quot;NumLock&quot;</span><span class="s2">,</span>
    <span class="s5">145</span><span class="s2">: </span><span class="s3">&quot;ScrollLock&quot;</span><span class="s2">,</span>
    <span class="s5">224</span><span class="s2">: </span><span class="s3">&quot;Meta&quot;</span>
  <span class="s2">},</span>
  <span class="s2">modifierKeyToProp = {</span>
    <span class="s2">Alt: </span><span class="s3">&quot;altKey&quot;</span><span class="s2">,</span>
    <span class="s2">Control: </span><span class="s3">&quot;ctrlKey&quot;</span><span class="s2">,</span>
    <span class="s2">Meta: </span><span class="s3">&quot;metaKey&quot;</span><span class="s2">,</span>
    <span class="s2">Shift: </span><span class="s3">&quot;shiftKey&quot;</span>
  <span class="s2">};</span>
<span class="s4">function </span><span class="s2">modifierStateGetter(keyArg) {</span>
  <span class="s4">var </span><span class="s2">nativeEvent = </span><span class="s4">this</span><span class="s2">.nativeEvent;</span>
  <span class="s4">return </span><span class="s2">nativeEvent.getModifierState</span>
    <span class="s2">? nativeEvent.getModifierState(keyArg)</span>
    <span class="s2">: (keyArg = modifierKeyToProp[keyArg])</span>
      <span class="s2">? !!nativeEvent[keyArg]</span>
      <span class="s2">: !</span><span class="s5">1</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getEventModifierState() {</span>
  <span class="s4">return </span><span class="s2">modifierStateGetter;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">KeyboardEventInterface = assign({}, UIEventInterface, {</span>
    <span class="s2">key: </span><span class="s4">function </span><span class="s2">(nativeEvent) {</span>
      <span class="s4">if </span><span class="s2">(nativeEvent.key) {</span>
        <span class="s4">var </span><span class="s2">key = normalizeKey[nativeEvent.key] || nativeEvent.key;</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;Unidentified&quot; </span><span class="s2">!== key) </span><span class="s4">return </span><span class="s2">key;</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s3">&quot;keypress&quot; </span><span class="s2">=== nativeEvent.type</span>
        <span class="s2">? ((nativeEvent = getEventCharCode(nativeEvent)),</span>
          <span class="s5">13 </span><span class="s2">=== nativeEvent ? </span><span class="s3">&quot;Enter&quot; </span><span class="s2">: String.fromCharCode(nativeEvent))</span>
        <span class="s2">: </span><span class="s3">&quot;keydown&quot; </span><span class="s2">=== nativeEvent.type || </span><span class="s3">&quot;keyup&quot; </span><span class="s2">=== nativeEvent.type</span>
          <span class="s2">? translateToKey[nativeEvent.keyCode] || </span><span class="s3">&quot;Unidentified&quot;</span>
          <span class="s2">: </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s2">code: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">location: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">ctrlKey: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">shiftKey: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">altKey: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">metaKey: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">repeat: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">locale: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">getModifierState: getEventModifierState,</span>
    <span class="s2">charCode: </span><span class="s4">function </span><span class="s2">(event) {</span>
      <span class="s4">return </span><span class="s3">&quot;keypress&quot; </span><span class="s2">=== event.type ? getEventCharCode(event) : </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s2">keyCode: </span><span class="s4">function </span><span class="s2">(event) {</span>
      <span class="s4">return </span><span class="s3">&quot;keydown&quot; </span><span class="s2">=== event.type || </span><span class="s3">&quot;keyup&quot; </span><span class="s2">=== event.type</span>
        <span class="s2">? event.keyCode</span>
        <span class="s2">: </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s2">which: </span><span class="s4">function </span><span class="s2">(event) {</span>
      <span class="s4">return </span><span class="s3">&quot;keypress&quot; </span><span class="s2">=== event.type</span>
        <span class="s2">? getEventCharCode(event)</span>
        <span class="s2">: </span><span class="s3">&quot;keydown&quot; </span><span class="s2">=== event.type || </span><span class="s3">&quot;keyup&quot; </span><span class="s2">=== event.type</span>
          <span class="s2">? event.keyCode</span>
          <span class="s2">: </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s2">}),</span>
  <span class="s2">SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),</span>
  <span class="s2">PointerEventInterface = assign({}, MouseEventInterface, {</span>
    <span class="s2">pointerId: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">width: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">height: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">pressure: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">tangentialPressure: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">tiltX: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">tiltY: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">twist: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">pointerType: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">isPrimary: </span><span class="s5">0</span>
  <span class="s2">}),</span>
  <span class="s2">SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),</span>
  <span class="s2">TouchEventInterface = assign({}, UIEventInterface, {</span>
    <span class="s2">touches: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">targetTouches: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">changedTouches: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">altKey: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">metaKey: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">ctrlKey: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">shiftKey: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">getModifierState: getEventModifierState</span>
  <span class="s2">}),</span>
  <span class="s2">SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),</span>
  <span class="s2">TransitionEventInterface = assign({}, EventInterface, {</span>
    <span class="s2">propertyName: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">elapsedTime: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">pseudoElement: </span><span class="s5">0</span>
  <span class="s2">}),</span>
  <span class="s2">SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),</span>
  <span class="s2">WheelEventInterface = assign({}, MouseEventInterface, {</span>
    <span class="s2">deltaX: </span><span class="s4">function </span><span class="s2">(event) {</span>
      <span class="s4">return </span><span class="s3">&quot;deltaX&quot; </span><span class="s4">in </span><span class="s2">event</span>
        <span class="s2">? event.deltaX</span>
        <span class="s2">: </span><span class="s3">&quot;wheelDeltaX&quot; </span><span class="s4">in </span><span class="s2">event</span>
          <span class="s2">? -event.wheelDeltaX</span>
          <span class="s2">: </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s2">deltaY: </span><span class="s4">function </span><span class="s2">(event) {</span>
      <span class="s4">return </span><span class="s3">&quot;deltaY&quot; </span><span class="s4">in </span><span class="s2">event</span>
        <span class="s2">? event.deltaY</span>
        <span class="s2">: </span><span class="s3">&quot;wheelDeltaY&quot; </span><span class="s4">in </span><span class="s2">event</span>
          <span class="s2">? -event.wheelDeltaY</span>
          <span class="s2">: </span><span class="s3">&quot;wheelDelta&quot; </span><span class="s4">in </span><span class="s2">event</span>
            <span class="s2">? -event.wheelDelta</span>
            <span class="s2">: </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s2">deltaZ: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">deltaMode: </span><span class="s5">0</span>
  <span class="s2">}),</span>
  <span class="s2">SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),</span>
  <span class="s2">ToggleEventInterface = assign({}, EventInterface, {</span>
    <span class="s2">newState: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">oldState: </span><span class="s5">0</span>
  <span class="s2">}),</span>
  <span class="s2">SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),</span>
  <span class="s2">END_KEYCODES = [</span><span class="s5">9</span><span class="s2">, </span><span class="s5">13</span><span class="s2">, </span><span class="s5">27</span><span class="s2">, </span><span class="s5">32</span><span class="s2">],</span>
  <span class="s2">canUseCompositionEvent = canUseDOM &amp;&amp; </span><span class="s3">&quot;CompositionEvent&quot; </span><span class="s4">in </span><span class="s2">window,</span>
  <span class="s2">documentMode = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s2">canUseDOM &amp;&amp;</span>
  <span class="s3">&quot;documentMode&quot; </span><span class="s4">in </span><span class="s2">document &amp;&amp;</span>
  <span class="s2">(documentMode = document.documentMode);</span>
<span class="s4">var </span><span class="s2">canUseTextInputEvent = canUseDOM &amp;&amp; </span><span class="s3">&quot;TextEvent&quot; </span><span class="s4">in </span><span class="s2">window &amp;&amp; !documentMode,</span>
  <span class="s2">useFallbackCompositionData =</span>
    <span class="s2">canUseDOM &amp;&amp;</span>
    <span class="s2">(!canUseCompositionEvent ||</span>
      <span class="s2">(documentMode &amp;&amp; </span><span class="s5">8 </span><span class="s2">&lt; documentMode &amp;&amp; </span><span class="s5">11 </span><span class="s2">&gt;= documentMode)),</span>
  <span class="s2">SPACEBAR_CHAR = String.fromCharCode(</span><span class="s5">32</span><span class="s2">),</span>
  <span class="s2">hasSpaceKeypress = !</span><span class="s5">1</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">isFallbackCompositionEnd(domEventName, nativeEvent) {</span>
  <span class="s4">switch </span><span class="s2">(domEventName) {</span>
    <span class="s4">case </span><span class="s3">&quot;keyup&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">-</span><span class="s5">1 </span><span class="s2">!== END_KEYCODES.indexOf(nativeEvent.keyCode);</span>
    <span class="s4">case </span><span class="s3">&quot;keydown&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s5">229 </span><span class="s2">!== nativeEvent.keyCode;</span>
    <span class="s4">case </span><span class="s3">&quot;keypress&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;mousedown&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;focusout&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getDataFromCustomEvent(nativeEvent) {</span>
  <span class="s2">nativeEvent = nativeEvent.detail;</span>
  <span class="s4">return </span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">nativeEvent &amp;&amp; </span><span class="s3">&quot;data&quot; </span><span class="s4">in </span><span class="s2">nativeEvent</span>
    <span class="s2">? nativeEvent.data</span>
    <span class="s2">: </span><span class="s4">null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">isComposing = !</span><span class="s5">1</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">getNativeBeforeInputChars(domEventName, nativeEvent) {</span>
  <span class="s4">switch </span><span class="s2">(domEventName) {</span>
    <span class="s4">case </span><span class="s3">&quot;compositionend&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">getDataFromCustomEvent(nativeEvent);</span>
    <span class="s4">case </span><span class="s3">&quot;keypress&quot;</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s5">32 </span><span class="s2">!== nativeEvent.which) </span><span class="s4">return null</span><span class="s2">;</span>
      <span class="s2">hasSpaceKeypress = !</span><span class="s5">0</span><span class="s2">;</span>
      <span class="s4">return </span><span class="s2">SPACEBAR_CHAR;</span>
    <span class="s4">case </span><span class="s3">&quot;textInput&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(domEventName = nativeEvent.data),</span>
        <span class="s2">domEventName === SPACEBAR_CHAR &amp;&amp; hasSpaceKeypress ? </span><span class="s4">null </span><span class="s2">: domEventName</span>
      <span class="s2">);</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">return null</span><span class="s2">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getFallbackBeforeInputChars(domEventName, nativeEvent) {</span>
  <span class="s4">if </span><span class="s2">(isComposing)</span>
    <span class="s4">return </span><span class="s3">&quot;compositionend&quot; </span><span class="s2">=== domEventName ||</span>
      <span class="s2">(!canUseCompositionEvent &amp;&amp;</span>
        <span class="s2">isFallbackCompositionEnd(domEventName, nativeEvent))</span>
      <span class="s2">? ((domEventName = getData()),</span>
        <span class="s2">(fallbackText = startText = root = </span><span class="s4">null</span><span class="s2">),</span>
        <span class="s2">(isComposing = !</span><span class="s5">1</span><span class="s2">),</span>
        <span class="s2">domEventName)</span>
      <span class="s2">: </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">switch </span><span class="s2">(domEventName) {</span>
    <span class="s4">case </span><span class="s3">&quot;paste&quot;</span><span class="s2">:</span>
      <span class="s4">return null</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;keypress&quot;</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) ||</span>
        <span class="s2">(nativeEvent.ctrlKey &amp;&amp; nativeEvent.altKey)</span>
      <span class="s2">) {</span>
        <span class="s4">if </span><span class="s2">(nativeEvent.char &amp;&amp; </span><span class="s5">1 </span><span class="s2">&lt; nativeEvent.char.length)</span>
          <span class="s4">return </span><span class="s2">nativeEvent.char;</span>
        <span class="s4">if </span><span class="s2">(nativeEvent.which) </span><span class="s4">return </span><span class="s2">String.fromCharCode(nativeEvent.which);</span>
      <span class="s2">}</span>
      <span class="s4">return null</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;compositionend&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">useFallbackCompositionData &amp;&amp; </span><span class="s3">&quot;ko&quot; </span><span class="s2">!== nativeEvent.locale</span>
        <span class="s2">? </span><span class="s4">null</span>
        <span class="s2">: nativeEvent.data;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">return null</span><span class="s2">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">supportedInputTypes = {</span>
  <span class="s2">color: !</span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">date: !</span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">datetime: !</span><span class="s5">0</span><span class="s2">,</span>
  <span class="s3">&quot;datetime-local&quot;</span><span class="s2">: !</span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">email: !</span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">month: !</span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">number: !</span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">password: !</span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">range: !</span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">search: !</span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">tel: !</span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">text: !</span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">time: !</span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">url: !</span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">week: !</span><span class="s5">0</span>
<span class="s2">};</span>
<span class="s4">function </span><span class="s2">isTextInputElement(elem) {</span>
  <span class="s4">var </span><span class="s2">nodeName = elem &amp;&amp; elem.nodeName &amp;&amp; elem.nodeName.toLowerCase();</span>
  <span class="s4">return </span><span class="s3">&quot;input&quot; </span><span class="s2">=== nodeName</span>
    <span class="s2">? !!supportedInputTypes[elem.type]</span>
    <span class="s2">: </span><span class="s3">&quot;textarea&quot; </span><span class="s2">=== nodeName</span>
      <span class="s2">? !</span><span class="s5">0</span>
      <span class="s2">: !</span><span class="s5">1</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createAndAccumulateChangeEvent(</span>
  <span class="s2">dispatchQueue,</span>
  <span class="s2">inst,</span>
  <span class="s2">nativeEvent,</span>
  <span class="s2">target</span>
<span class="s2">) {</span>
  <span class="s2">restoreTarget</span>
    <span class="s2">? restoreQueue</span>
      <span class="s2">? restoreQueue.push(target)</span>
      <span class="s2">: (restoreQueue = [target])</span>
    <span class="s2">: (restoreTarget = target);</span>
  <span class="s2">inst = accumulateTwoPhaseListeners(inst, </span><span class="s3">&quot;onChange&quot;</span><span class="s2">);</span>
  <span class="s5">0 </span><span class="s2">&lt; inst.length &amp;&amp;</span>
    <span class="s2">((nativeEvent = </span><span class="s4">new </span><span class="s2">SyntheticEvent(</span>
      <span class="s3">&quot;onChange&quot;</span><span class="s2">,</span>
      <span class="s3">&quot;change&quot;</span><span class="s2">,</span>
      <span class="s4">null</span><span class="s2">,</span>
      <span class="s2">nativeEvent,</span>
      <span class="s2">target</span>
    <span class="s2">)),</span>
    <span class="s2">dispatchQueue.push({ event: nativeEvent, listeners: inst }));</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">activeElement$1 = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">activeElementInst$1 = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">runEventInBatch(dispatchQueue) {</span>
  <span class="s2">processDispatchQueue(dispatchQueue, </span><span class="s5">0</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getInstIfValueChanged(targetInst) {</span>
  <span class="s4">var </span><span class="s2">targetNode = getNodeFromInstance(targetInst);</span>
  <span class="s4">if </span><span class="s2">(updateValueIfChanged(targetNode)) </span><span class="s4">return </span><span class="s2">targetInst;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getTargetInstForChangeEvent(domEventName, targetInst) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;change&quot; </span><span class="s2">=== domEventName) </span><span class="s4">return </span><span class="s2">targetInst;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">isInputEventSupported = !</span><span class="s5">1</span><span class="s2">;</span>
<span class="s4">if </span><span class="s2">(canUseDOM) {</span>
  <span class="s4">var </span><span class="s2">JSCompiler_inline_result$jscomp$298;</span>
  <span class="s4">if </span><span class="s2">(canUseDOM) {</span>
    <span class="s4">var </span><span class="s2">isSupported$jscomp$inline_434 = </span><span class="s3">&quot;oninput&quot; </span><span class="s4">in </span><span class="s2">document;</span>
    <span class="s4">if </span><span class="s2">(!isSupported$jscomp$inline_434) {</span>
      <span class="s4">var </span><span class="s2">element$jscomp$inline_435 = document.createElement(</span><span class="s3">&quot;div&quot;</span><span class="s2">);</span>
      <span class="s2">element$jscomp$inline_435.setAttribute(</span><span class="s3">&quot;oninput&quot;</span><span class="s2">, </span><span class="s3">&quot;return;&quot;</span><span class="s2">);</span>
      <span class="s2">isSupported$jscomp$inline_434 =</span>
        <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">element$jscomp$inline_435.oninput;</span>
    <span class="s2">}</span>
    <span class="s2">JSCompiler_inline_result$jscomp$298 = isSupported$jscomp$inline_434;</span>
  <span class="s2">} </span><span class="s4">else </span><span class="s2">JSCompiler_inline_result$jscomp$298 = !</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">isInputEventSupported =</span>
    <span class="s2">JSCompiler_inline_result$jscomp$298 &amp;&amp;</span>
    <span class="s2">(!document.documentMode || </span><span class="s5">9 </span><span class="s2">&lt; document.documentMode);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">stopWatchingForValueChange() {</span>
  <span class="s2">activeElement$1 &amp;&amp;</span>
    <span class="s2">(activeElement$1.detachEvent(</span><span class="s3">&quot;onpropertychange&quot;</span><span class="s2">, handlePropertyChange),</span>
    <span class="s2">(activeElementInst$1 = activeElement$1 = </span><span class="s4">null</span><span class="s2">));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">handlePropertyChange(nativeEvent) {</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s3">&quot;value&quot; </span><span class="s2">=== nativeEvent.propertyName &amp;&amp;</span>
    <span class="s2">getInstIfValueChanged(activeElementInst$1)</span>
  <span class="s2">) {</span>
    <span class="s4">var </span><span class="s2">dispatchQueue = [];</span>
    <span class="s2">createAndAccumulateChangeEvent(</span>
      <span class="s2">dispatchQueue,</span>
      <span class="s2">activeElementInst$1,</span>
      <span class="s2">nativeEvent,</span>
      <span class="s2">getEventTarget(nativeEvent)</span>
    <span class="s2">);</span>
    <span class="s2">batchedUpdates$2(runEventInBatch, dispatchQueue);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">handleEventsForInputEventPolyfill(domEventName, target, targetInst) {</span>
  <span class="s3">&quot;focusin&quot; </span><span class="s2">=== domEventName</span>
    <span class="s2">? (stopWatchingForValueChange(),</span>
      <span class="s2">(activeElement$1 = target),</span>
      <span class="s2">(activeElementInst$1 = targetInst),</span>
      <span class="s2">activeElement$1.attachEvent(</span><span class="s3">&quot;onpropertychange&quot;</span><span class="s2">, handlePropertyChange))</span>
    <span class="s2">: </span><span class="s3">&quot;focusout&quot; </span><span class="s2">=== domEventName &amp;&amp; stopWatchingForValueChange();</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getTargetInstForInputEventPolyfill(domEventName) {</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s3">&quot;selectionchange&quot; </span><span class="s2">=== domEventName ||</span>
    <span class="s3">&quot;keyup&quot; </span><span class="s2">=== domEventName ||</span>
    <span class="s3">&quot;keydown&quot; </span><span class="s2">=== domEventName</span>
  <span class="s2">)</span>
    <span class="s4">return </span><span class="s2">getInstIfValueChanged(activeElementInst$1);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getTargetInstForClickEvent(domEventName, targetInst) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;click&quot; </span><span class="s2">=== domEventName) </span><span class="s4">return </span><span class="s2">getInstIfValueChanged(targetInst);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getTargetInstForInputOrChangeEvent(domEventName, targetInst) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;input&quot; </span><span class="s2">=== domEventName || </span><span class="s3">&quot;change&quot; </span><span class="s2">=== domEventName)</span>
    <span class="s4">return </span><span class="s2">getInstIfValueChanged(targetInst);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">is(x, y) {</span>
  <span class="s4">return </span><span class="s2">(x === y &amp;&amp; (</span><span class="s5">0 </span><span class="s2">!== x || </span><span class="s5">1 </span><span class="s2">/ x === </span><span class="s5">1 </span><span class="s2">/ y)) || (x !== x &amp;&amp; y !== y);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">objectIs = </span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">Object.is ? Object.is : is;</span>
<span class="s4">function </span><span class="s2">shallowEqual(objA, objB) {</span>
  <span class="s4">if </span><span class="s2">(objectIs(objA, objB)) </span><span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s3">&quot;object&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">objA ||</span>
    <span class="s4">null </span><span class="s2">=== objA ||</span>
    <span class="s3">&quot;object&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">objB ||</span>
    <span class="s4">null </span><span class="s2">=== objB</span>
  <span class="s2">)</span>
    <span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">keysA = Object.keys(objA),</span>
    <span class="s2">keysB = Object.keys(objB);</span>
  <span class="s4">if </span><span class="s2">(keysA.length !== keysB.length) </span><span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">for </span><span class="s2">(keysB = </span><span class="s5">0</span><span class="s2">; keysB &lt; keysA.length; keysB++) {</span>
    <span class="s4">var </span><span class="s2">currentKey = keysA[keysB];</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">!hasOwnProperty.call(objB, currentKey) ||</span>
      <span class="s2">!objectIs(objA[currentKey], objB[currentKey])</span>
    <span class="s2">)</span>
      <span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getLeafNode(node) {</span>
  <span class="s4">for </span><span class="s2">(; node &amp;&amp; node.firstChild; ) node = node.firstChild;</span>
  <span class="s4">return </span><span class="s2">node;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getNodeForCharacterOffset(root, offset) {</span>
  <span class="s4">var </span><span class="s2">node = getLeafNode(root);</span>
  <span class="s2">root = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">nodeEnd; node; ) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">3 </span><span class="s2">=== node.nodeType) {</span>
      <span class="s2">nodeEnd = root + node.textContent.length;</span>
      <span class="s4">if </span><span class="s2">(root &lt;= offset &amp;&amp; nodeEnd &gt;= offset)</span>
        <span class="s4">return </span><span class="s2">{ node: node, offset: offset - root };</span>
      <span class="s2">root = nodeEnd;</span>
    <span class="s2">}</span>
    <span class="s2">a: {</span>
      <span class="s4">for </span><span class="s2">(; node; ) {</span>
        <span class="s4">if </span><span class="s2">(node.nextSibling) {</span>
          <span class="s2">node = node.nextSibling;</span>
          <span class="s4">break </span><span class="s2">a;</span>
        <span class="s2">}</span>
        <span class="s2">node = node.parentNode;</span>
      <span class="s2">}</span>
      <span class="s2">node = </span><span class="s4">void </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s2">node = getLeafNode(node);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">containsNode(outerNode, innerNode) {</span>
  <span class="s4">return </span><span class="s2">outerNode &amp;&amp; innerNode</span>
    <span class="s2">? outerNode === innerNode</span>
      <span class="s2">? !</span><span class="s5">0</span>
      <span class="s2">: outerNode &amp;&amp; </span><span class="s5">3 </span><span class="s2">=== outerNode.nodeType</span>
        <span class="s2">? !</span><span class="s5">1</span>
        <span class="s2">: innerNode &amp;&amp; </span><span class="s5">3 </span><span class="s2">=== innerNode.nodeType</span>
          <span class="s2">? containsNode(outerNode, innerNode.parentNode)</span>
          <span class="s2">: </span><span class="s3">&quot;contains&quot; </span><span class="s4">in </span><span class="s2">outerNode</span>
            <span class="s2">? outerNode.contains(innerNode)</span>
            <span class="s2">: outerNode.compareDocumentPosition</span>
              <span class="s2">? !!(outerNode.compareDocumentPosition(innerNode) &amp; </span><span class="s5">16</span><span class="s2">)</span>
              <span class="s2">: !</span><span class="s5">1</span>
    <span class="s2">: !</span><span class="s5">1</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getActiveElementDeep(containerInfo) {</span>
  <span class="s2">containerInfo =</span>
    <span class="s4">null </span><span class="s2">!= containerInfo &amp;&amp;</span>
    <span class="s4">null </span><span class="s2">!= containerInfo.ownerDocument &amp;&amp;</span>
    <span class="s4">null </span><span class="s2">!= containerInfo.ownerDocument.defaultView</span>
      <span class="s2">? containerInfo.ownerDocument.defaultView</span>
      <span class="s2">: window;</span>
  <span class="s4">for </span><span class="s2">(</span>
    <span class="s4">var </span><span class="s2">element = getActiveElement(containerInfo.document);</span>
    <span class="s2">element </span><span class="s4">instanceof </span><span class="s2">containerInfo.HTMLIFrameElement;</span>

  <span class="s2">) {</span>
    <span class="s4">try </span><span class="s2">{</span>
      <span class="s4">var </span><span class="s2">JSCompiler_inline_result =</span>
        <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">element.contentWindow.location.href;</span>
    <span class="s2">} </span><span class="s4">catch </span><span class="s2">(err) {</span>
      <span class="s2">JSCompiler_inline_result = !</span><span class="s5">1</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">if </span><span class="s2">(JSCompiler_inline_result) containerInfo = element.contentWindow;</span>
    <span class="s4">else break</span><span class="s2">;</span>
    <span class="s2">element = getActiveElement(containerInfo.document);</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">element;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">hasSelectionCapabilities(elem) {</span>
  <span class="s4">var </span><span class="s2">nodeName = elem &amp;&amp; elem.nodeName &amp;&amp; elem.nodeName.toLowerCase();</span>
  <span class="s4">return </span><span class="s2">(</span>
    <span class="s2">nodeName &amp;&amp;</span>
    <span class="s2">((</span><span class="s3">&quot;input&quot; </span><span class="s2">=== nodeName &amp;&amp;</span>
      <span class="s2">(</span><span class="s3">&quot;text&quot; </span><span class="s2">=== elem.type ||</span>
        <span class="s3">&quot;search&quot; </span><span class="s2">=== elem.type ||</span>
        <span class="s3">&quot;tel&quot; </span><span class="s2">=== elem.type ||</span>
        <span class="s3">&quot;url&quot; </span><span class="s2">=== elem.type ||</span>
        <span class="s3">&quot;password&quot; </span><span class="s2">=== elem.type)) ||</span>
      <span class="s3">&quot;textarea&quot; </span><span class="s2">=== nodeName ||</span>
      <span class="s3">&quot;true&quot; </span><span class="s2">=== elem.contentEditable)</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">skipSelectionChangeEvent =</span>
    <span class="s2">canUseDOM &amp;&amp; </span><span class="s3">&quot;documentMode&quot; </span><span class="s4">in </span><span class="s2">document &amp;&amp; </span><span class="s5">11 </span><span class="s2">&gt;= document.documentMode,</span>
  <span class="s2">activeElement = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">activeElementInst = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">lastSelection = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">mouseDown = !</span><span class="s5">1</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {</span>
  <span class="s4">var </span><span class="s2">doc =</span>
    <span class="s2">nativeEventTarget.window === nativeEventTarget</span>
      <span class="s2">? nativeEventTarget.document</span>
      <span class="s2">: </span><span class="s5">9 </span><span class="s2">=== nativeEventTarget.nodeType</span>
        <span class="s2">? nativeEventTarget</span>
        <span class="s2">: nativeEventTarget.ownerDocument;</span>
  <span class="s2">mouseDown ||</span>
    <span class="s4">null </span><span class="s2">== activeElement ||</span>
    <span class="s2">activeElement !== getActiveElement(doc) ||</span>
    <span class="s2">((doc = activeElement),</span>
    <span class="s3">&quot;selectionStart&quot; </span><span class="s4">in </span><span class="s2">doc &amp;&amp; hasSelectionCapabilities(doc)</span>
      <span class="s2">? (doc = { start: doc.selectionStart, end: doc.selectionEnd })</span>
      <span class="s2">: ((doc = (</span>
          <span class="s2">(doc.ownerDocument &amp;&amp; doc.ownerDocument.defaultView) ||</span>
          <span class="s2">window</span>
        <span class="s2">).getSelection()),</span>
        <span class="s2">(doc = {</span>
          <span class="s2">anchorNode: doc.anchorNode,</span>
          <span class="s2">anchorOffset: doc.anchorOffset,</span>
          <span class="s2">focusNode: doc.focusNode,</span>
          <span class="s2">focusOffset: doc.focusOffset</span>
        <span class="s2">})),</span>
    <span class="s2">(lastSelection &amp;&amp; shallowEqual(lastSelection, doc)) ||</span>
      <span class="s2">((lastSelection = doc),</span>
      <span class="s2">(doc = accumulateTwoPhaseListeners(activeElementInst, </span><span class="s3">&quot;onSelect&quot;</span><span class="s2">)),</span>
      <span class="s5">0 </span><span class="s2">&lt; doc.length &amp;&amp;</span>
        <span class="s2">((nativeEvent = </span><span class="s4">new </span><span class="s2">SyntheticEvent(</span>
          <span class="s3">&quot;onSelect&quot;</span><span class="s2">,</span>
          <span class="s3">&quot;select&quot;</span><span class="s2">,</span>
          <span class="s4">null</span><span class="s2">,</span>
          <span class="s2">nativeEvent,</span>
          <span class="s2">nativeEventTarget</span>
        <span class="s2">)),</span>
        <span class="s2">dispatchQueue.push({ event: nativeEvent, listeners: doc }),</span>
        <span class="s2">(nativeEvent.target = activeElement))));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">makePrefixMap(styleProp, eventName) {</span>
  <span class="s4">var </span><span class="s2">prefixes = {};</span>
  <span class="s2">prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();</span>
  <span class="s2">prefixes[</span><span class="s3">&quot;Webkit&quot; </span><span class="s2">+ styleProp] = </span><span class="s3">&quot;webkit&quot; </span><span class="s2">+ eventName;</span>
  <span class="s2">prefixes[</span><span class="s3">&quot;Moz&quot; </span><span class="s2">+ styleProp] = </span><span class="s3">&quot;moz&quot; </span><span class="s2">+ eventName;</span>
  <span class="s4">return </span><span class="s2">prefixes;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">vendorPrefixes = {</span>
    <span class="s2">animationend: makePrefixMap(</span><span class="s3">&quot;Animation&quot;</span><span class="s2">, </span><span class="s3">&quot;AnimationEnd&quot;</span><span class="s2">),</span>
    <span class="s2">animationiteration: makePrefixMap(</span><span class="s3">&quot;Animation&quot;</span><span class="s2">, </span><span class="s3">&quot;AnimationIteration&quot;</span><span class="s2">),</span>
    <span class="s2">animationstart: makePrefixMap(</span><span class="s3">&quot;Animation&quot;</span><span class="s2">, </span><span class="s3">&quot;AnimationStart&quot;</span><span class="s2">),</span>
    <span class="s2">transitionrun: makePrefixMap(</span><span class="s3">&quot;Transition&quot;</span><span class="s2">, </span><span class="s3">&quot;TransitionRun&quot;</span><span class="s2">),</span>
    <span class="s2">transitionstart: makePrefixMap(</span><span class="s3">&quot;Transition&quot;</span><span class="s2">, </span><span class="s3">&quot;TransitionStart&quot;</span><span class="s2">),</span>
    <span class="s2">transitioncancel: makePrefixMap(</span><span class="s3">&quot;Transition&quot;</span><span class="s2">, </span><span class="s3">&quot;TransitionCancel&quot;</span><span class="s2">),</span>
    <span class="s2">transitionend: makePrefixMap(</span><span class="s3">&quot;Transition&quot;</span><span class="s2">, </span><span class="s3">&quot;TransitionEnd&quot;</span><span class="s2">)</span>
  <span class="s2">},</span>
  <span class="s2">prefixedEventNames = {},</span>
  <span class="s2">style = {};</span>
<span class="s2">canUseDOM &amp;&amp;</span>
  <span class="s2">((style = document.createElement(</span><span class="s3">&quot;div&quot;</span><span class="s2">).style),</span>
  <span class="s3">&quot;AnimationEvent&quot; </span><span class="s4">in </span><span class="s2">window ||</span>
    <span class="s2">(</span><span class="s4">delete </span><span class="s2">vendorPrefixes.animationend.animation,</span>
    <span class="s4">delete </span><span class="s2">vendorPrefixes.animationiteration.animation,</span>
    <span class="s4">delete </span><span class="s2">vendorPrefixes.animationstart.animation),</span>
  <span class="s3">&quot;TransitionEvent&quot; </span><span class="s4">in </span><span class="s2">window ||</span>
    <span class="s4">delete </span><span class="s2">vendorPrefixes.transitionend.transition);</span>
<span class="s4">function </span><span class="s2">getVendorPrefixedEventName(eventName) {</span>
  <span class="s4">if </span><span class="s2">(prefixedEventNames[eventName]) </span><span class="s4">return </span><span class="s2">prefixedEventNames[eventName];</span>
  <span class="s4">if </span><span class="s2">(!vendorPrefixes[eventName]) </span><span class="s4">return </span><span class="s2">eventName;</span>
  <span class="s4">var </span><span class="s2">prefixMap = vendorPrefixes[eventName],</span>
    <span class="s2">styleProp;</span>
  <span class="s4">for </span><span class="s2">(styleProp </span><span class="s4">in </span><span class="s2">prefixMap)</span>
    <span class="s4">if </span><span class="s2">(prefixMap.hasOwnProperty(styleProp) &amp;&amp; styleProp </span><span class="s4">in </span><span class="s2">style)</span>
      <span class="s4">return </span><span class="s2">(prefixedEventNames[eventName] = prefixMap[styleProp]);</span>
  <span class="s4">return </span><span class="s2">eventName;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">ANIMATION_END = getVendorPrefixedEventName(</span><span class="s3">&quot;animationend&quot;</span><span class="s2">),</span>
  <span class="s2">ANIMATION_ITERATION = getVendorPrefixedEventName(</span><span class="s3">&quot;animationiteration&quot;</span><span class="s2">),</span>
  <span class="s2">ANIMATION_START = getVendorPrefixedEventName(</span><span class="s3">&quot;animationstart&quot;</span><span class="s2">),</span>
  <span class="s2">TRANSITION_RUN = getVendorPrefixedEventName(</span><span class="s3">&quot;transitionrun&quot;</span><span class="s2">),</span>
  <span class="s2">TRANSITION_START = getVendorPrefixedEventName(</span><span class="s3">&quot;transitionstart&quot;</span><span class="s2">),</span>
  <span class="s2">TRANSITION_CANCEL = getVendorPrefixedEventName(</span><span class="s3">&quot;transitioncancel&quot;</span><span class="s2">),</span>
  <span class="s2">TRANSITION_END = getVendorPrefixedEventName(</span><span class="s3">&quot;transitionend&quot;</span><span class="s2">),</span>
  <span class="s2">topLevelEventsToReactNames = </span><span class="s4">new </span><span class="s2">Map(),</span>
  <span class="s2">simpleEventPluginEvents =</span>
    <span class="s3">&quot;abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel&quot;</span><span class="s2">.split(</span>
      <span class="s3">&quot; &quot;</span>
    <span class="s2">);</span>
<span class="s2">simpleEventPluginEvents.push(</span><span class="s3">&quot;scrollEnd&quot;</span><span class="s2">);</span>
<span class="s4">function </span><span class="s2">registerSimpleEvent(domEventName, reactName) {</span>
  <span class="s2">topLevelEventsToReactNames.set(domEventName, reactName);</span>
  <span class="s2">registerTwoPhaseEvent(reactName, [domEventName]);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">CapturedStacks = </span><span class="s4">new </span><span class="s2">WeakMap();</span>
<span class="s4">function </span><span class="s2">createCapturedValueAtFiber(value, source) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value &amp;&amp; </span><span class="s4">null </span><span class="s2">!== value) {</span>
    <span class="s4">var </span><span class="s2">existing = CapturedStacks.get(value);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== existing) </span><span class="s4">return </span><span class="s2">existing;</span>
    <span class="s2">source = {</span>
      <span class="s2">value: value,</span>
      <span class="s2">source: source,</span>
      <span class="s2">stack: getStackByFiberInDevAndProd(source)</span>
    <span class="s2">};</span>
    <span class="s2">CapturedStacks.set(value, source);</span>
    <span class="s4">return </span><span class="s2">source;</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">{</span>
    <span class="s2">value: value,</span>
    <span class="s2">source: source,</span>
    <span class="s2">stack: getStackByFiberInDevAndProd(source)</span>
  <span class="s2">};</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">concurrentQueues = [],</span>
  <span class="s2">concurrentQueuesIndex = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">concurrentlyUpdatedLanes = </span><span class="s5">0</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">finishQueueingConcurrentUpdates() {</span>
  <span class="s4">for </span><span class="s2">(</span>
    <span class="s4">var </span><span class="s2">endIndex = concurrentQueuesIndex,</span>
      <span class="s2">i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = </span><span class="s5">0</span><span class="s2">);</span>
    <span class="s2">i &lt; endIndex;</span>

  <span class="s2">) {</span>
    <span class="s4">var </span><span class="s2">fiber = concurrentQueues[i];</span>
    <span class="s2">concurrentQueues[i++] = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">var </span><span class="s2">queue = concurrentQueues[i];</span>
    <span class="s2">concurrentQueues[i++] = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">var </span><span class="s2">update = concurrentQueues[i];</span>
    <span class="s2">concurrentQueues[i++] = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">var </span><span class="s2">lane = concurrentQueues[i];</span>
    <span class="s2">concurrentQueues[i++] = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== queue &amp;&amp; </span><span class="s4">null </span><span class="s2">!== update) {</span>
      <span class="s4">var </span><span class="s2">pending = queue.pending;</span>
      <span class="s4">null </span><span class="s2">=== pending</span>
        <span class="s2">? (update.next = update)</span>
        <span class="s2">: ((update.next = pending.next), (pending.next = update));</span>
      <span class="s2">queue.pending = update;</span>
    <span class="s2">}</span>
    <span class="s5">0 </span><span class="s2">!== lane &amp;&amp; markUpdateLaneFromFiberToRoot(fiber, update, lane);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">enqueueUpdate$1(fiber, queue, update, lane) {</span>
  <span class="s2">concurrentQueues[concurrentQueuesIndex++] = fiber;</span>
  <span class="s2">concurrentQueues[concurrentQueuesIndex++] = queue;</span>
  <span class="s2">concurrentQueues[concurrentQueuesIndex++] = update;</span>
  <span class="s2">concurrentQueues[concurrentQueuesIndex++] = lane;</span>
  <span class="s2">concurrentlyUpdatedLanes |= lane;</span>
  <span class="s2">fiber.lanes |= lane;</span>
  <span class="s2">fiber = fiber.alternate;</span>
  <span class="s4">null </span><span class="s2">!== fiber &amp;&amp; (fiber.lanes |= lane);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">enqueueConcurrentHookUpdate(fiber, queue, update, lane) {</span>
  <span class="s2">enqueueUpdate$1(fiber, queue, update, lane);</span>
  <span class="s4">return </span><span class="s2">getRootForUpdatedFiber(fiber);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">enqueueConcurrentRenderForLane(fiber, lane) {</span>
  <span class="s2">enqueueUpdate$1(fiber, </span><span class="s4">null</span><span class="s2">, </span><span class="s4">null</span><span class="s2">, lane);</span>
  <span class="s4">return </span><span class="s2">getRootForUpdatedFiber(fiber);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {</span>
  <span class="s2">sourceFiber.lanes |= lane;</span>
  <span class="s4">var </span><span class="s2">alternate = sourceFiber.alternate;</span>
  <span class="s4">null </span><span class="s2">!== alternate &amp;&amp; (alternate.lanes |= lane);</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">isHidden = !</span><span class="s5">1</span><span class="s2">, parent = sourceFiber.return; </span><span class="s4">null </span><span class="s2">!== parent; )</span>
    <span class="s2">(parent.childLanes |= lane),</span>
      <span class="s2">(alternate = parent.alternate),</span>
      <span class="s4">null </span><span class="s2">!== alternate &amp;&amp; (alternate.childLanes |= lane),</span>
      <span class="s5">22 </span><span class="s2">=== parent.tag &amp;&amp;</span>
        <span class="s2">((sourceFiber = parent.stateNode),</span>
        <span class="s4">null </span><span class="s2">=== sourceFiber || sourceFiber._visibility &amp; </span><span class="s5">1 </span><span class="s2">|| (isHidden = !</span><span class="s5">0</span><span class="s2">)),</span>
      <span class="s2">(sourceFiber = parent),</span>
      <span class="s2">(parent = parent.return);</span>
  <span class="s4">return </span><span class="s5">3 </span><span class="s2">=== sourceFiber.tag</span>
    <span class="s2">? ((parent = sourceFiber.stateNode),</span>
      <span class="s2">isHidden &amp;&amp;</span>
        <span class="s4">null </span><span class="s2">!== update &amp;&amp;</span>
        <span class="s2">((isHidden = </span><span class="s5">31 </span><span class="s2">- clz32(lane)),</span>
        <span class="s2">(sourceFiber = parent.hiddenUpdates),</span>
        <span class="s2">(alternate = sourceFiber[isHidden]),</span>
        <span class="s4">null </span><span class="s2">=== alternate</span>
          <span class="s2">? (sourceFiber[isHidden] = [update])</span>
          <span class="s2">: alternate.push(update),</span>
        <span class="s2">(update.lane = lane | </span><span class="s5">536870912</span><span class="s2">)),</span>
      <span class="s2">parent)</span>
    <span class="s2">: </span><span class="s4">null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getRootForUpdatedFiber(sourceFiber) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">50 </span><span class="s2">&lt; nestedUpdateCount)</span>
    <span class="s4">throw </span><span class="s2">(</span>
      <span class="s2">((nestedUpdateCount = </span><span class="s5">0</span><span class="s2">),</span>
      <span class="s2">(rootWithNestedUpdates = </span><span class="s4">null</span><span class="s2">),</span>
      <span class="s2">Error(formatProdErrorMessage(</span><span class="s5">185</span><span class="s2">)))</span>
    <span class="s2">);</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">parent = sourceFiber.return; </span><span class="s4">null </span><span class="s2">!== parent; )</span>
    <span class="s2">(sourceFiber = parent), (parent = sourceFiber.return);</span>
  <span class="s4">return </span><span class="s5">3 </span><span class="s2">=== sourceFiber.tag ? sourceFiber.stateNode : </span><span class="s4">null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">emptyContextObject = {};</span>
<span class="s4">function </span><span class="s2">FiberNode(tag, pendingProps, key, mode) {</span>
  <span class="s4">this</span><span class="s2">.tag = tag;</span>
  <span class="s4">this</span><span class="s2">.key = key;</span>
  <span class="s4">this</span><span class="s2">.sibling =</span>
    <span class="s4">this</span><span class="s2">.child =</span>
    <span class="s4">this</span><span class="s2">.return =</span>
    <span class="s4">this</span><span class="s2">.stateNode =</span>
    <span class="s4">this</span><span class="s2">.type =</span>
    <span class="s4">this</span><span class="s2">.elementType =</span>
      <span class="s4">null</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.index = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.refCleanup = </span><span class="s4">this</span><span class="s2">.ref = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.pendingProps = pendingProps;</span>
  <span class="s4">this</span><span class="s2">.dependencies =</span>
    <span class="s4">this</span><span class="s2">.memoizedState =</span>
    <span class="s4">this</span><span class="s2">.updateQueue =</span>
    <span class="s4">this</span><span class="s2">.memoizedProps =</span>
      <span class="s4">null</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.mode = mode;</span>
  <span class="s4">this</span><span class="s2">.subtreeFlags = </span><span class="s4">this</span><span class="s2">.flags = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.deletions = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.childLanes = </span><span class="s4">this</span><span class="s2">.lanes = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.alternate = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.actualDuration = -</span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.actualStartTime = -</span><span class="s5">1.1</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.treeBaseDuration = </span><span class="s4">this</span><span class="s2">.selfBaseDuration = -</span><span class="s5">0</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createFiberImplClass(tag, pendingProps, key, mode) {</span>
  <span class="s4">return new </span><span class="s2">FiberNode(tag, pendingProps, key, mode);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">shouldConstruct(Component) {</span>
  <span class="s2">Component = Component.prototype;</span>
  <span class="s4">return </span><span class="s2">!(!Component || !Component.isReactComponent);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createWorkInProgress(current, pendingProps) {</span>
  <span class="s4">var </span><span class="s2">workInProgress = current.alternate;</span>
  <span class="s4">null </span><span class="s2">=== workInProgress</span>
    <span class="s2">? ((workInProgress = createFiberImplClass(</span>
        <span class="s2">current.tag,</span>
        <span class="s2">pendingProps,</span>
        <span class="s2">current.key,</span>
        <span class="s2">current.mode</span>
      <span class="s2">)),</span>
      <span class="s2">(workInProgress.elementType = current.elementType),</span>
      <span class="s2">(workInProgress.type = current.type),</span>
      <span class="s2">(workInProgress.stateNode = current.stateNode),</span>
      <span class="s2">(workInProgress.alternate = current),</span>
      <span class="s2">(current.alternate = workInProgress))</span>
    <span class="s2">: ((workInProgress.pendingProps = pendingProps),</span>
      <span class="s2">(workInProgress.type = current.type),</span>
      <span class="s2">(workInProgress.flags = </span><span class="s5">0</span><span class="s2">),</span>
      <span class="s2">(workInProgress.subtreeFlags = </span><span class="s5">0</span><span class="s2">),</span>
      <span class="s2">(workInProgress.deletions = </span><span class="s4">null</span><span class="s2">),</span>
      <span class="s2">(workInProgress.actualDuration = -</span><span class="s5">0</span><span class="s2">),</span>
      <span class="s2">(workInProgress.actualStartTime = -</span><span class="s5">1.1</span><span class="s2">));</span>
  <span class="s2">workInProgress.flags = current.flags &amp; </span><span class="s5">65011712</span><span class="s2">;</span>
  <span class="s2">workInProgress.childLanes = current.childLanes;</span>
  <span class="s2">workInProgress.lanes = current.lanes;</span>
  <span class="s2">workInProgress.child = current.child;</span>
  <span class="s2">workInProgress.memoizedProps = current.memoizedProps;</span>
  <span class="s2">workInProgress.memoizedState = current.memoizedState;</span>
  <span class="s2">workInProgress.updateQueue = current.updateQueue;</span>
  <span class="s2">pendingProps = current.dependencies;</span>
  <span class="s2">workInProgress.dependencies =</span>
    <span class="s4">null </span><span class="s2">=== pendingProps</span>
      <span class="s2">? </span><span class="s4">null</span>
      <span class="s2">: { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };</span>
  <span class="s2">workInProgress.sibling = current.sibling;</span>
  <span class="s2">workInProgress.index = current.index;</span>
  <span class="s2">workInProgress.ref = current.ref;</span>
  <span class="s2">workInProgress.refCleanup = current.refCleanup;</span>
  <span class="s2">workInProgress.selfBaseDuration = current.selfBaseDuration;</span>
  <span class="s2">workInProgress.treeBaseDuration = current.treeBaseDuration;</span>
  <span class="s4">return </span><span class="s2">workInProgress;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">resetWorkInProgress(workInProgress, renderLanes) {</span>
  <span class="s2">workInProgress.flags &amp;= </span><span class="s5">65011714</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">current = workInProgress.alternate;</span>
  <span class="s4">null </span><span class="s2">=== current</span>
    <span class="s2">? ((workInProgress.childLanes = </span><span class="s5">0</span><span class="s2">),</span>
      <span class="s2">(workInProgress.lanes = renderLanes),</span>
      <span class="s2">(workInProgress.child = </span><span class="s4">null</span><span class="s2">),</span>
      <span class="s2">(workInProgress.subtreeFlags = </span><span class="s5">0</span><span class="s2">),</span>
      <span class="s2">(workInProgress.memoizedProps = </span><span class="s4">null</span><span class="s2">),</span>
      <span class="s2">(workInProgress.memoizedState = </span><span class="s4">null</span><span class="s2">),</span>
      <span class="s2">(workInProgress.updateQueue = </span><span class="s4">null</span><span class="s2">),</span>
      <span class="s2">(workInProgress.dependencies = </span><span class="s4">null</span><span class="s2">),</span>
      <span class="s2">(workInProgress.stateNode = </span><span class="s4">null</span><span class="s2">),</span>
      <span class="s2">(workInProgress.selfBaseDuration = </span><span class="s5">0</span><span class="s2">),</span>
      <span class="s2">(workInProgress.treeBaseDuration = </span><span class="s5">0</span><span class="s2">))</span>
    <span class="s2">: ((workInProgress.childLanes = current.childLanes),</span>
      <span class="s2">(workInProgress.lanes = current.lanes),</span>
      <span class="s2">(workInProgress.child = current.child),</span>
      <span class="s2">(workInProgress.subtreeFlags = </span><span class="s5">0</span><span class="s2">),</span>
      <span class="s2">(workInProgress.deletions = </span><span class="s4">null</span><span class="s2">),</span>
      <span class="s2">(workInProgress.memoizedProps = current.memoizedProps),</span>
      <span class="s2">(workInProgress.memoizedState = current.memoizedState),</span>
      <span class="s2">(workInProgress.updateQueue = current.updateQueue),</span>
      <span class="s2">(workInProgress.type = current.type),</span>
      <span class="s2">(renderLanes = current.dependencies),</span>
      <span class="s2">(workInProgress.dependencies =</span>
        <span class="s4">null </span><span class="s2">=== renderLanes</span>
          <span class="s2">? </span><span class="s4">null</span>
          <span class="s2">: {</span>
              <span class="s2">lanes: renderLanes.lanes,</span>
              <span class="s2">firstContext: renderLanes.firstContext</span>
            <span class="s2">}),</span>
      <span class="s2">(workInProgress.selfBaseDuration = current.selfBaseDuration),</span>
      <span class="s2">(workInProgress.treeBaseDuration = current.treeBaseDuration));</span>
  <span class="s4">return </span><span class="s2">workInProgress;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createFiberFromTypeAndProps(</span>
  <span class="s2">type,</span>
  <span class="s2">key,</span>
  <span class="s2">pendingProps,</span>
  <span class="s2">owner,</span>
  <span class="s2">mode,</span>
  <span class="s2">lanes</span>
<span class="s2">) {</span>
  <span class="s4">var </span><span class="s2">fiberTag = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">owner = type;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">type) shouldConstruct(type) &amp;&amp; (fiberTag = </span><span class="s5">1</span><span class="s2">);</span>
  <span class="s4">else if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">type)</span>
    <span class="s2">fiberTag = isHostHoistableType(</span>
      <span class="s2">type,</span>
      <span class="s2">pendingProps,</span>
      <span class="s2">contextStackCursor.current</span>
    <span class="s2">)</span>
      <span class="s2">? </span><span class="s5">26</span>
      <span class="s2">: </span><span class="s3">&quot;html&quot; </span><span class="s2">=== type || </span><span class="s3">&quot;head&quot; </span><span class="s2">=== type || </span><span class="s3">&quot;body&quot; </span><span class="s2">=== type</span>
        <span class="s2">? </span><span class="s5">27</span>
        <span class="s2">: </span><span class="s5">5</span><span class="s2">;</span>
  <span class="s4">else</span>
    <span class="s2">a: </span><span class="s4">switch </span><span class="s2">(type) {</span>
      <span class="s4">case </span><span class="s2">REACT_ACTIVITY_TYPE:</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(type = createFiberImplClass(</span><span class="s5">31</span><span class="s2">, pendingProps, key, mode)),</span>
          <span class="s2">(type.elementType = REACT_ACTIVITY_TYPE),</span>
          <span class="s2">(type.lanes = lanes),</span>
          <span class="s2">type</span>
        <span class="s2">);</span>
      <span class="s4">case </span><span class="s2">REACT_FRAGMENT_TYPE:</span>
        <span class="s4">return </span><span class="s2">createFiberFromFragment(pendingProps.children, mode, lanes, key);</span>
      <span class="s4">case </span><span class="s2">REACT_STRICT_MODE_TYPE:</span>
        <span class="s2">fiberTag = </span><span class="s5">8</span><span class="s2">;</span>
        <span class="s2">mode |= </span><span class="s5">24</span><span class="s2">;</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s2">REACT_PROFILER_TYPE:</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(type = createFiberImplClass(</span><span class="s5">12</span><span class="s2">, pendingProps, key, mode | </span><span class="s5">2</span><span class="s2">)),</span>
          <span class="s2">(type.elementType = REACT_PROFILER_TYPE),</span>
          <span class="s2">(type.lanes = lanes),</span>
          <span class="s2">(type.stateNode = { effectDuration: </span><span class="s5">0</span><span class="s2">, passiveEffectDuration: </span><span class="s5">0 </span><span class="s2">}),</span>
          <span class="s2">type</span>
        <span class="s2">);</span>
      <span class="s4">case </span><span class="s2">REACT_SUSPENSE_TYPE:</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(type = createFiberImplClass(</span><span class="s5">13</span><span class="s2">, pendingProps, key, mode)),</span>
          <span class="s2">(type.elementType = REACT_SUSPENSE_TYPE),</span>
          <span class="s2">(type.lanes = lanes),</span>
          <span class="s2">type</span>
        <span class="s2">);</span>
      <span class="s4">case </span><span class="s2">REACT_SUSPENSE_LIST_TYPE:</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(type = createFiberImplClass(</span><span class="s5">19</span><span class="s2">, pendingProps, key, mode)),</span>
          <span class="s2">(type.elementType = REACT_SUSPENSE_LIST_TYPE),</span>
          <span class="s2">(type.lanes = lanes),</span>
          <span class="s2">type</span>
        <span class="s2">);</span>
      <span class="s4">default</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">type &amp;&amp; </span><span class="s4">null </span><span class="s2">!== type)</span>
          <span class="s4">switch </span><span class="s2">(type.$$typeof) {</span>
            <span class="s4">case </span><span class="s2">REACT_PROVIDER_TYPE:</span>
            <span class="s4">case </span><span class="s2">REACT_CONTEXT_TYPE:</span>
              <span class="s2">fiberTag = </span><span class="s5">10</span><span class="s2">;</span>
              <span class="s4">break </span><span class="s2">a;</span>
            <span class="s4">case </span><span class="s2">REACT_CONSUMER_TYPE:</span>
              <span class="s2">fiberTag = </span><span class="s5">9</span><span class="s2">;</span>
              <span class="s4">break </span><span class="s2">a;</span>
            <span class="s4">case </span><span class="s2">REACT_FORWARD_REF_TYPE:</span>
              <span class="s2">fiberTag = </span><span class="s5">11</span><span class="s2">;</span>
              <span class="s4">break </span><span class="s2">a;</span>
            <span class="s4">case </span><span class="s2">REACT_MEMO_TYPE:</span>
              <span class="s2">fiberTag = </span><span class="s5">14</span><span class="s2">;</span>
              <span class="s4">break </span><span class="s2">a;</span>
            <span class="s4">case </span><span class="s2">REACT_LAZY_TYPE:</span>
              <span class="s2">fiberTag = </span><span class="s5">16</span><span class="s2">;</span>
              <span class="s2">owner = </span><span class="s4">null</span><span class="s2">;</span>
              <span class="s4">break </span><span class="s2">a;</span>
          <span class="s2">}</span>
        <span class="s2">fiberTag = </span><span class="s5">29</span><span class="s2">;</span>
        <span class="s2">pendingProps = Error(</span>
          <span class="s2">formatProdErrorMessage(</span><span class="s5">130</span><span class="s2">, </span><span class="s4">null </span><span class="s2">=== type ? </span><span class="s3">&quot;null&quot; </span><span class="s2">: </span><span class="s4">typeof </span><span class="s2">type, </span><span class="s3">&quot;&quot;</span><span class="s2">)</span>
        <span class="s2">);</span>
        <span class="s2">owner = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s2">key = createFiberImplClass(fiberTag, pendingProps, key, mode);</span>
  <span class="s2">key.elementType = type;</span>
  <span class="s2">key.type = owner;</span>
  <span class="s2">key.lanes = lanes;</span>
  <span class="s4">return </span><span class="s2">key;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createFiberFromFragment(elements, mode, lanes, key) {</span>
  <span class="s2">elements = createFiberImplClass(</span><span class="s5">7</span><span class="s2">, elements, key, mode);</span>
  <span class="s2">elements.lanes = lanes;</span>
  <span class="s4">return </span><span class="s2">elements;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createFiberFromText(content, mode, lanes) {</span>
  <span class="s2">content = createFiberImplClass(</span><span class="s5">6</span><span class="s2">, content, </span><span class="s4">null</span><span class="s2">, mode);</span>
  <span class="s2">content.lanes = lanes;</span>
  <span class="s4">return </span><span class="s2">content;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createFiberFromPortal(portal, mode, lanes) {</span>
  <span class="s2">mode = createFiberImplClass(</span>
    <span class="s5">4</span><span class="s2">,</span>
    <span class="s4">null </span><span class="s2">!== portal.children ? portal.children : [],</span>
    <span class="s2">portal.key,</span>
    <span class="s2">mode</span>
  <span class="s2">);</span>
  <span class="s2">mode.lanes = lanes;</span>
  <span class="s2">mode.stateNode = {</span>
    <span class="s2">containerInfo: portal.containerInfo,</span>
    <span class="s2">pendingChildren: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">implementation: portal.implementation</span>
  <span class="s2">};</span>
  <span class="s4">return </span><span class="s2">mode;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">forkStack = [],</span>
  <span class="s2">forkStackIndex = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">treeForkProvider = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">treeForkCount = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">idStack = [],</span>
  <span class="s2">idStackIndex = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">treeContextProvider = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">treeContextId = </span><span class="s5">1</span><span class="s2">,</span>
  <span class="s2">treeContextOverflow = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">pushTreeFork(workInProgress, totalChildren) {</span>
  <span class="s2">forkStack[forkStackIndex++] = treeForkCount;</span>
  <span class="s2">forkStack[forkStackIndex++] = treeForkProvider;</span>
  <span class="s2">treeForkProvider = workInProgress;</span>
  <span class="s2">treeForkCount = totalChildren;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">pushTreeId(workInProgress, totalChildren, index) {</span>
  <span class="s2">idStack[idStackIndex++] = treeContextId;</span>
  <span class="s2">idStack[idStackIndex++] = treeContextOverflow;</span>
  <span class="s2">idStack[idStackIndex++] = treeContextProvider;</span>
  <span class="s2">treeContextProvider = workInProgress;</span>
  <span class="s4">var </span><span class="s2">baseIdWithLeadingBit = treeContextId;</span>
  <span class="s2">workInProgress = treeContextOverflow;</span>
  <span class="s4">var </span><span class="s2">baseLength = </span><span class="s5">32 </span><span class="s2">- clz32(baseIdWithLeadingBit) - </span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">baseIdWithLeadingBit &amp;= ~(</span><span class="s5">1 </span><span class="s2">&lt;&lt; baseLength);</span>
  <span class="s2">index += </span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">length = </span><span class="s5">32 </span><span class="s2">- clz32(totalChildren) + baseLength;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">30 </span><span class="s2">&lt; length) {</span>
    <span class="s4">var </span><span class="s2">numberOfOverflowBits = baseLength - (baseLength % </span><span class="s5">5</span><span class="s2">);</span>
    <span class="s2">length = (</span>
      <span class="s2">baseIdWithLeadingBit &amp;</span>
      <span class="s2">((</span><span class="s5">1 </span><span class="s2">&lt;&lt; numberOfOverflowBits) - </span><span class="s5">1</span><span class="s2">)</span>
    <span class="s2">).toString(</span><span class="s5">32</span><span class="s2">);</span>
    <span class="s2">baseIdWithLeadingBit &gt;&gt;= numberOfOverflowBits;</span>
    <span class="s2">baseLength -= numberOfOverflowBits;</span>
    <span class="s2">treeContextId =</span>
      <span class="s2">(</span><span class="s5">1 </span><span class="s2">&lt;&lt; (</span><span class="s5">32 </span><span class="s2">- clz32(totalChildren) + baseLength)) |</span>
      <span class="s2">(index &lt;&lt; baseLength) |</span>
      <span class="s2">baseIdWithLeadingBit;</span>
    <span class="s2">treeContextOverflow = length + workInProgress;</span>
  <span class="s2">} </span><span class="s4">else</span>
    <span class="s2">(treeContextId =</span>
      <span class="s2">(</span><span class="s5">1 </span><span class="s2">&lt;&lt; length) | (index &lt;&lt; baseLength) | baseIdWithLeadingBit),</span>
      <span class="s2">(treeContextOverflow = workInProgress);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">pushMaterializedTreeId(workInProgress) {</span>
  <span class="s4">null </span><span class="s2">!== workInProgress.return &amp;&amp;</span>
    <span class="s2">(pushTreeFork(workInProgress, </span><span class="s5">1</span><span class="s2">), pushTreeId(workInProgress, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">popTreeContext(workInProgress) {</span>
  <span class="s4">for </span><span class="s2">(; workInProgress === treeForkProvider; )</span>
    <span class="s2">(treeForkProvider = forkStack[--forkStackIndex]),</span>
      <span class="s2">(forkStack[forkStackIndex] = </span><span class="s4">null</span><span class="s2">),</span>
      <span class="s2">(treeForkCount = forkStack[--forkStackIndex]),</span>
      <span class="s2">(forkStack[forkStackIndex] = </span><span class="s4">null</span><span class="s2">);</span>
  <span class="s4">for </span><span class="s2">(; workInProgress === treeContextProvider; )</span>
    <span class="s2">(treeContextProvider = idStack[--idStackIndex]),</span>
      <span class="s2">(idStack[idStackIndex] = </span><span class="s4">null</span><span class="s2">),</span>
      <span class="s2">(treeContextOverflow = idStack[--idStackIndex]),</span>
      <span class="s2">(idStack[idStackIndex] = </span><span class="s4">null</span><span class="s2">),</span>
      <span class="s2">(treeContextId = idStack[--idStackIndex]),</span>
      <span class="s2">(idStack[idStackIndex] = </span><span class="s4">null</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">hydrationParentFiber = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">nextHydratableInstance = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">isHydrating = !</span><span class="s5">1</span><span class="s2">,</span>
  <span class="s2">hydrationErrors = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">rootOrSingletonContext = !</span><span class="s5">1</span><span class="s2">,</span>
  <span class="s2">HydrationMismatchException = Error(formatProdErrorMessage(</span><span class="s5">519</span><span class="s2">));</span>
<span class="s4">function </span><span class="s2">throwOnHydrationMismatch(fiber) {</span>
  <span class="s4">var </span><span class="s2">error = Error(formatProdErrorMessage(</span><span class="s5">418</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s2">));</span>
  <span class="s2">queueHydrationError(createCapturedValueAtFiber(error, fiber));</span>
  <span class="s4">throw </span><span class="s2">HydrationMismatchException;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">prepareToHydrateHostInstance(fiber) {</span>
  <span class="s4">var </span><span class="s2">instance = fiber.stateNode,</span>
    <span class="s2">type = fiber.type,</span>
    <span class="s2">props = fiber.memoizedProps;</span>
  <span class="s2">instance[internalInstanceKey] = fiber;</span>
  <span class="s2">instance[internalPropsKey] = props;</span>
  <span class="s4">switch </span><span class="s2">(type) {</span>
    <span class="s4">case </span><span class="s3">&quot;dialog&quot;</span><span class="s2">:</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;cancel&quot;</span><span class="s2">, instance);</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;close&quot;</span><span class="s2">, instance);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;iframe&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;object&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;embed&quot;</span><span class="s2">:</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;load&quot;</span><span class="s2">, instance);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;video&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;audio&quot;</span><span class="s2">:</span>
      <span class="s4">for </span><span class="s2">(type = </span><span class="s5">0</span><span class="s2">; type &lt; mediaEventTypes.length; type++)</span>
        <span class="s2">listenToNonDelegatedEvent(mediaEventTypes[type], instance);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;source&quot;</span><span class="s2">:</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;error&quot;</span><span class="s2">, instance);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;img&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;image&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;link&quot;</span><span class="s2">:</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;error&quot;</span><span class="s2">, instance);</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;load&quot;</span><span class="s2">, instance);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;details&quot;</span><span class="s2">:</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;toggle&quot;</span><span class="s2">, instance);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;input&quot;</span><span class="s2">:</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;invalid&quot;</span><span class="s2">, instance);</span>
      <span class="s2">initInput(</span>
        <span class="s2">instance,</span>
        <span class="s2">props.value,</span>
        <span class="s2">props.defaultValue,</span>
        <span class="s2">props.checked,</span>
        <span class="s2">props.defaultChecked,</span>
        <span class="s2">props.type,</span>
        <span class="s2">props.name,</span>
        <span class="s2">!</span><span class="s5">0</span>
      <span class="s2">);</span>
      <span class="s2">track(instance);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;select&quot;</span><span class="s2">:</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;invalid&quot;</span><span class="s2">, instance);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;textarea&quot;</span><span class="s2">:</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;invalid&quot;</span><span class="s2">, instance),</span>
        <span class="s2">initTextarea(instance, props.value, props.defaultValue, props.children),</span>
        <span class="s2">track(instance);</span>
  <span class="s2">}</span>
  <span class="s2">type = props.children;</span>
  <span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">type &amp;&amp;</span>
    <span class="s3">&quot;number&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">type &amp;&amp;</span>
    <span class="s3">&quot;bigint&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">type) ||</span>
  <span class="s2">instance.textContent === </span><span class="s3">&quot;&quot; </span><span class="s2">+ type ||</span>
  <span class="s2">!</span><span class="s5">0 </span><span class="s2">=== props.suppressHydrationWarning ||</span>
  <span class="s2">checkForUnmatchedText(instance.textContent, type)</span>
    <span class="s2">? (</span><span class="s4">null </span><span class="s2">!= props.popover &amp;&amp;</span>
        <span class="s2">(listenToNonDelegatedEvent(</span><span class="s3">&quot;beforetoggle&quot;</span><span class="s2">, instance),</span>
        <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;toggle&quot;</span><span class="s2">, instance)),</span>
      <span class="s4">null </span><span class="s2">!= props.onScroll &amp;&amp; listenToNonDelegatedEvent(</span><span class="s3">&quot;scroll&quot;</span><span class="s2">, instance),</span>
      <span class="s4">null </span><span class="s2">!= props.onScrollEnd &amp;&amp;</span>
        <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;scrollend&quot;</span><span class="s2">, instance),</span>
      <span class="s4">null </span><span class="s2">!= props.onClick &amp;&amp; (instance.onclick = noop$2),</span>
      <span class="s2">(instance = !</span><span class="s5">0</span><span class="s2">))</span>
    <span class="s2">: (instance = !</span><span class="s5">1</span><span class="s2">);</span>
  <span class="s2">instance || throwOnHydrationMismatch(fiber);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">popToNextHostParent(fiber) {</span>
  <span class="s4">for </span><span class="s2">(hydrationParentFiber = fiber.return; hydrationParentFiber; )</span>
    <span class="s4">switch </span><span class="s2">(hydrationParentFiber.tag) {</span>
      <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s5">13</span><span class="s2">:</span>
        <span class="s2">rootOrSingletonContext = !</span><span class="s5">1</span><span class="s2">;</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s5">27</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
        <span class="s2">rootOrSingletonContext = !</span><span class="s5">0</span><span class="s2">;</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s4">default</span><span class="s2">:</span>
        <span class="s2">hydrationParentFiber = hydrationParentFiber.return;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">popHydrationState(fiber) {</span>
  <span class="s4">if </span><span class="s2">(fiber !== hydrationParentFiber) </span><span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(!isHydrating) </span><span class="s4">return </span><span class="s2">popToNextHostParent(fiber), (isHydrating = !</span><span class="s5">0</span><span class="s2">), !</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">tag = fiber.tag,</span>
    <span class="s2">JSCompiler_temp;</span>
  <span class="s4">if </span><span class="s2">((JSCompiler_temp = </span><span class="s5">3 </span><span class="s2">!== tag &amp;&amp; </span><span class="s5">27 </span><span class="s2">!== tag)) {</span>
    <span class="s4">if </span><span class="s2">((JSCompiler_temp = </span><span class="s5">5 </span><span class="s2">=== tag))</span>
      <span class="s2">(JSCompiler_temp = fiber.type),</span>
        <span class="s2">(JSCompiler_temp =</span>
          <span class="s2">!(</span><span class="s3">&quot;form&quot; </span><span class="s2">!== JSCompiler_temp &amp;&amp; </span><span class="s3">&quot;button&quot; </span><span class="s2">!== JSCompiler_temp) ||</span>
          <span class="s2">shouldSetTextContent(fiber.type, fiber.memoizedProps));</span>
    <span class="s2">JSCompiler_temp = !JSCompiler_temp;</span>
  <span class="s2">}</span>
  <span class="s2">JSCompiler_temp &amp;&amp; nextHydratableInstance &amp;&amp; throwOnHydrationMismatch(fiber);</span>
  <span class="s2">popToNextHostParent(fiber);</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">13 </span><span class="s2">=== tag) {</span>
    <span class="s2">fiber = fiber.memoizedState;</span>
    <span class="s2">fiber = </span><span class="s4">null </span><span class="s2">!== fiber ? fiber.dehydrated : </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">if </span><span class="s2">(!fiber) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">317</span><span class="s2">));</span>
    <span class="s2">a: {</span>
      <span class="s2">fiber = fiber.nextSibling;</span>
      <span class="s4">for </span><span class="s2">(tag = </span><span class="s5">0</span><span class="s2">; fiber; ) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s5">8 </span><span class="s2">=== fiber.nodeType)</span>
          <span class="s4">if </span><span class="s2">(((JSCompiler_temp = fiber.data), </span><span class="s3">&quot;/$&quot; </span><span class="s2">=== JSCompiler_temp)) {</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== tag) {</span>
              <span class="s2">nextHydratableInstance = getNextHydratable(fiber.nextSibling);</span>
              <span class="s4">break </span><span class="s2">a;</span>
            <span class="s2">}</span>
            <span class="s2">tag--;</span>
          <span class="s2">} </span><span class="s4">else</span>
            <span class="s2">(</span><span class="s3">&quot;$&quot; </span><span class="s2">!== JSCompiler_temp &amp;&amp;</span>
              <span class="s3">&quot;$!&quot; </span><span class="s2">!== JSCompiler_temp &amp;&amp;</span>
              <span class="s3">&quot;$?&quot; </span><span class="s2">!== JSCompiler_temp) ||</span>
              <span class="s2">tag++;</span>
        <span class="s2">fiber = fiber.nextSibling;</span>
      <span class="s2">}</span>
      <span class="s2">nextHydratableInstance = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s2">} </span><span class="s4">else</span>
    <span class="s5">27 </span><span class="s2">=== tag</span>
      <span class="s2">? ((tag = nextHydratableInstance),</span>
        <span class="s2">isSingletonScope(fiber.type)</span>
          <span class="s2">? ((fiber = previousHydratableOnEnteringScopedSingleton),</span>
            <span class="s2">(previousHydratableOnEnteringScopedSingleton = </span><span class="s4">null</span><span class="s2">),</span>
            <span class="s2">(nextHydratableInstance = fiber))</span>
          <span class="s2">: (nextHydratableInstance = tag))</span>
      <span class="s2">: (nextHydratableInstance = hydrationParentFiber</span>
          <span class="s2">? getNextHydratable(fiber.stateNode.nextSibling)</span>
          <span class="s2">: </span><span class="s4">null</span><span class="s2">);</span>
  <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">resetHydrationState() {</span>
  <span class="s2">nextHydratableInstance = hydrationParentFiber = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">isHydrating = !</span><span class="s5">1</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">upgradeHydrationErrorsToRecoverable() {</span>
  <span class="s4">var </span><span class="s2">queuedErrors = hydrationErrors;</span>
  <span class="s4">null </span><span class="s2">!== queuedErrors &amp;&amp;</span>
    <span class="s2">(</span><span class="s4">null </span><span class="s2">=== workInProgressRootRecoverableErrors</span>
      <span class="s2">? (workInProgressRootRecoverableErrors = queuedErrors)</span>
      <span class="s2">: workInProgressRootRecoverableErrors.push.apply(</span>
          <span class="s2">workInProgressRootRecoverableErrors,</span>
          <span class="s2">queuedErrors</span>
        <span class="s2">),</span>
    <span class="s2">(hydrationErrors = </span><span class="s4">null</span><span class="s2">));</span>
  <span class="s4">return </span><span class="s2">queuedErrors;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">queueHydrationError(error) {</span>
  <span class="s4">null </span><span class="s2">=== hydrationErrors</span>
    <span class="s2">? (hydrationErrors = [error])</span>
    <span class="s2">: hydrationErrors.push(error);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">valueCursor = createCursor(</span><span class="s4">null</span><span class="s2">),</span>
  <span class="s2">currentlyRenderingFiber$1 = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">lastContextDependency = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">pushProvider(providerFiber, context, nextValue) {</span>
  <span class="s2">push(valueCursor, context._currentValue);</span>
  <span class="s2">context._currentValue = nextValue;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">popProvider(context) {</span>
  <span class="s2">context._currentValue = valueCursor.current;</span>
  <span class="s2">pop(valueCursor);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {</span>
  <span class="s4">for </span><span class="s2">(; </span><span class="s4">null </span><span class="s2">!== parent; ) {</span>
    <span class="s4">var </span><span class="s2">alternate = parent.alternate;</span>
    <span class="s2">(parent.childLanes &amp; renderLanes) !== renderLanes</span>
      <span class="s2">? ((parent.childLanes |= renderLanes),</span>
        <span class="s4">null </span><span class="s2">!== alternate &amp;&amp; (alternate.childLanes |= renderLanes))</span>
      <span class="s2">: </span><span class="s4">null </span><span class="s2">!== alternate &amp;&amp;</span>
        <span class="s2">(alternate.childLanes &amp; renderLanes) !== renderLanes &amp;&amp;</span>
        <span class="s2">(alternate.childLanes |= renderLanes);</span>
    <span class="s4">if </span><span class="s2">(parent === propagationRoot) </span><span class="s4">break</span><span class="s2">;</span>
    <span class="s2">parent = parent.return;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">propagateContextChanges(</span>
  <span class="s2">workInProgress,</span>
  <span class="s2">contexts,</span>
  <span class="s2">renderLanes,</span>
  <span class="s2">forcePropagateEntireTree</span>
<span class="s2">) {</span>
  <span class="s4">var </span><span class="s2">fiber = workInProgress.child;</span>
  <span class="s4">null </span><span class="s2">!== fiber &amp;&amp; (fiber.return = workInProgress);</span>
  <span class="s4">for </span><span class="s2">(; </span><span class="s4">null </span><span class="s2">!== fiber; ) {</span>
    <span class="s4">var </span><span class="s2">list = fiber.dependencies;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== list) {</span>
      <span class="s4">var </span><span class="s2">nextFiber = fiber.child;</span>
      <span class="s2">list = list.firstContext;</span>
      <span class="s2">a: </span><span class="s4">for </span><span class="s2">(; </span><span class="s4">null </span><span class="s2">!== list; ) {</span>
        <span class="s4">var </span><span class="s2">dependency = list;</span>
        <span class="s2">list = fiber;</span>
        <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; contexts.length; i++)</span>
          <span class="s4">if </span><span class="s2">(dependency.context === contexts[i]) {</span>
            <span class="s2">list.lanes |= renderLanes;</span>
            <span class="s2">dependency = list.alternate;</span>
            <span class="s4">null </span><span class="s2">!== dependency &amp;&amp; (dependency.lanes |= renderLanes);</span>
            <span class="s2">scheduleContextWorkOnParentPath(</span>
              <span class="s2">list.return,</span>
              <span class="s2">renderLanes,</span>
              <span class="s2">workInProgress</span>
            <span class="s2">);</span>
            <span class="s2">forcePropagateEntireTree || (nextFiber = </span><span class="s4">null</span><span class="s2">);</span>
            <span class="s4">break </span><span class="s2">a;</span>
          <span class="s2">}</span>
        <span class="s2">list = dependency.next;</span>
      <span class="s2">}</span>
    <span class="s2">} </span><span class="s4">else if </span><span class="s2">(</span><span class="s5">18 </span><span class="s2">=== fiber.tag) {</span>
      <span class="s2">nextFiber = fiber.return;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== nextFiber) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">341</span><span class="s2">));</span>
      <span class="s2">nextFiber.lanes |= renderLanes;</span>
      <span class="s2">list = nextFiber.alternate;</span>
      <span class="s4">null </span><span class="s2">!== list &amp;&amp; (list.lanes |= renderLanes);</span>
      <span class="s2">scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);</span>
      <span class="s2">nextFiber = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s2">} </span><span class="s4">else </span><span class="s2">nextFiber = fiber.child;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== nextFiber) nextFiber.return = fiber;</span>
    <span class="s4">else</span>
      <span class="s4">for </span><span class="s2">(nextFiber = fiber; </span><span class="s4">null </span><span class="s2">!== nextFiber; ) {</span>
        <span class="s4">if </span><span class="s2">(nextFiber === workInProgress) {</span>
          <span class="s2">nextFiber = </span><span class="s4">null</span><span class="s2">;</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s2">fiber = nextFiber.sibling;</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== fiber) {</span>
          <span class="s2">fiber.return = nextFiber.return;</span>
          <span class="s2">nextFiber = fiber;</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s2">nextFiber = nextFiber.return;</span>
      <span class="s2">}</span>
    <span class="s2">fiber = nextFiber;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">propagateParentContextChanges(</span>
  <span class="s2">current,</span>
  <span class="s2">workInProgress,</span>
  <span class="s2">renderLanes,</span>
  <span class="s2">forcePropagateEntireTree</span>
<span class="s2">) {</span>
  <span class="s2">current = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">for </span><span class="s2">(</span>
    <span class="s4">var </span><span class="s2">parent = workInProgress, isInsidePropagationBailout = !</span><span class="s5">1</span><span class="s2">;</span>
    <span class="s4">null </span><span class="s2">!== parent;</span>

  <span class="s2">) {</span>
    <span class="s4">if </span><span class="s2">(!isInsidePropagationBailout)</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (parent.flags &amp; </span><span class="s5">524288</span><span class="s2">)) isInsidePropagationBailout = !</span><span class="s5">0</span><span class="s2">;</span>
      <span class="s4">else if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (parent.flags &amp; </span><span class="s5">262144</span><span class="s2">)) </span><span class="s4">break</span><span class="s2">;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">10 </span><span class="s2">=== parent.tag) {</span>
      <span class="s4">var </span><span class="s2">currentParent = parent.alternate;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== currentParent) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">387</span><span class="s2">));</span>
      <span class="s2">currentParent = currentParent.memoizedProps;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== currentParent) {</span>
        <span class="s4">var </span><span class="s2">context = parent.type;</span>
        <span class="s2">objectIs(parent.pendingProps.value, currentParent.value) ||</span>
          <span class="s2">(</span><span class="s4">null </span><span class="s2">!== current ? current.push(context) : (current = [context]));</span>
      <span class="s2">}</span>
    <span class="s2">} </span><span class="s4">else if </span><span class="s2">(parent === hostTransitionProviderCursor.current) {</span>
      <span class="s2">currentParent = parent.alternate;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== currentParent) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">387</span><span class="s2">));</span>
      <span class="s2">currentParent.memoizedState.memoizedState !==</span>
        <span class="s2">parent.memoizedState.memoizedState &amp;&amp;</span>
        <span class="s2">(</span><span class="s4">null </span><span class="s2">!== current</span>
          <span class="s2">? current.push(HostTransitionContext)</span>
          <span class="s2">: (current = [HostTransitionContext]));</span>
    <span class="s2">}</span>
    <span class="s2">parent = parent.return;</span>
  <span class="s2">}</span>
  <span class="s4">null </span><span class="s2">!== current &amp;&amp;</span>
    <span class="s2">propagateContextChanges(</span>
      <span class="s2">workInProgress,</span>
      <span class="s2">current,</span>
      <span class="s2">renderLanes,</span>
      <span class="s2">forcePropagateEntireTree</span>
    <span class="s2">);</span>
  <span class="s2">workInProgress.flags |= </span><span class="s5">262144</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">checkIfContextChanged(currentDependencies) {</span>
  <span class="s4">for </span><span class="s2">(</span>
    <span class="s2">currentDependencies = currentDependencies.firstContext;</span>
    <span class="s4">null </span><span class="s2">!== currentDependencies;</span>

  <span class="s2">) {</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">!objectIs(</span>
        <span class="s2">currentDependencies.context._currentValue,</span>
        <span class="s2">currentDependencies.memoizedValue</span>
      <span class="s2">)</span>
    <span class="s2">)</span>
      <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">currentDependencies = currentDependencies.next;</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">prepareToReadContext(workInProgress) {</span>
  <span class="s2">currentlyRenderingFiber$1 = workInProgress;</span>
  <span class="s2">lastContextDependency = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">workInProgress = workInProgress.dependencies;</span>
  <span class="s4">null </span><span class="s2">!== workInProgress &amp;&amp; (workInProgress.firstContext = </span><span class="s4">null</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">readContext(context) {</span>
  <span class="s4">return </span><span class="s2">readContextForConsumer(currentlyRenderingFiber$1, context);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">readContextDuringReconciliation(consumer, context) {</span>
  <span class="s4">null </span><span class="s2">=== currentlyRenderingFiber$1 &amp;&amp; prepareToReadContext(consumer);</span>
  <span class="s4">return </span><span class="s2">readContextForConsumer(consumer, context);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">readContextForConsumer(consumer, context) {</span>
  <span class="s4">var </span><span class="s2">value = context._currentValue;</span>
  <span class="s2">context = { context: context, memoizedValue: value, next: </span><span class="s4">null </span><span class="s2">};</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== lastContextDependency) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== consumer) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">308</span><span class="s2">));</span>
    <span class="s2">lastContextDependency = context;</span>
    <span class="s2">consumer.dependencies = { lanes: </span><span class="s5">0</span><span class="s2">, firstContext: context };</span>
    <span class="s2">consumer.flags |= </span><span class="s5">524288</span><span class="s2">;</span>
  <span class="s2">} </span><span class="s4">else </span><span class="s2">lastContextDependency = lastContextDependency.next = context;</span>
  <span class="s4">return </span><span class="s2">value;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">AbortControllerLocal =</span>
    <span class="s3">&quot;undefined&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">AbortController</span>
      <span class="s2">? AbortController</span>
      <span class="s2">: </span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">var </span><span class="s2">listeners = [],</span>
            <span class="s2">signal = (</span><span class="s4">this</span><span class="s2">.signal = {</span>
              <span class="s2">aborted: !</span><span class="s5">1</span><span class="s2">,</span>
              <span class="s2">addEventListener: </span><span class="s4">function </span><span class="s2">(type, listener) {</span>
                <span class="s2">listeners.push(listener);</span>
              <span class="s2">}</span>
            <span class="s2">});</span>
          <span class="s4">this</span><span class="s2">.abort = </span><span class="s4">function </span><span class="s2">() {</span>
            <span class="s2">signal.aborted = !</span><span class="s5">0</span><span class="s2">;</span>
            <span class="s2">listeners.forEach(</span><span class="s4">function </span><span class="s2">(listener) {</span>
              <span class="s4">return </span><span class="s2">listener();</span>
            <span class="s2">});</span>
          <span class="s2">};</span>
        <span class="s2">},</span>
  <span class="s2">scheduleCallback$2 = Scheduler.unstable_scheduleCallback,</span>
  <span class="s2">NormalPriority = Scheduler.unstable_NormalPriority,</span>
  <span class="s2">CacheContext = {</span>
    <span class="s2">$$typeof: REACT_CONTEXT_TYPE,</span>
    <span class="s2">Consumer: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">Provider: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">_currentValue: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">_currentValue2: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">_threadCount: </span><span class="s5">0</span>
  <span class="s2">};</span>
<span class="s4">function </span><span class="s2">createCache() {</span>
  <span class="s4">return </span><span class="s2">{</span>
    <span class="s2">controller: </span><span class="s4">new </span><span class="s2">AbortControllerLocal(),</span>
    <span class="s2">data: </span><span class="s4">new </span><span class="s2">Map(),</span>
    <span class="s2">refCount: </span><span class="s5">0</span>
  <span class="s2">};</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">releaseCache(cache) {</span>
  <span class="s2">cache.refCount--;</span>
  <span class="s5">0 </span><span class="s2">=== cache.refCount &amp;&amp;</span>
    <span class="s2">scheduleCallback$2(NormalPriority, </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s2">cache.controller.abort();</span>
    <span class="s2">});</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">now = Scheduler.unstable_now,</span>
  <span class="s2">commitStartTime = -</span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">profilerStartTime = -</span><span class="s5">1.1</span><span class="s2">,</span>
  <span class="s2">profilerEffectDuration = -</span><span class="s5">0</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">pushNestedEffectDurations() {</span>
  <span class="s4">var </span><span class="s2">prevEffectDuration = profilerEffectDuration;</span>
  <span class="s2">profilerEffectDuration = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">return </span><span class="s2">prevEffectDuration;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">popNestedEffectDurations(prevEffectDuration) {</span>
  <span class="s4">var </span><span class="s2">elapsedTime = profilerEffectDuration;</span>
  <span class="s2">profilerEffectDuration = prevEffectDuration;</span>
  <span class="s4">return </span><span class="s2">elapsedTime;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">bubbleNestedEffectDurations(prevEffectDuration) {</span>
  <span class="s4">var </span><span class="s2">elapsedTime = profilerEffectDuration;</span>
  <span class="s2">profilerEffectDuration += prevEffectDuration;</span>
  <span class="s4">return </span><span class="s2">elapsedTime;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">currentUpdateIsNested = !</span><span class="s5">1</span><span class="s2">,</span>
  <span class="s2">nestedUpdateScheduled = !</span><span class="s5">1</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">startProfilerTimer(fiber) {</span>
  <span class="s2">profilerStartTime = now();</span>
  <span class="s5">0 </span><span class="s2">&gt; fiber.actualStartTime &amp;&amp; (fiber.actualStartTime = profilerStartTime);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">stopProfilerTimerIfRunningAndRecordDuration(fiber) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">&lt;= profilerStartTime) {</span>
    <span class="s4">var </span><span class="s2">elapsedTime = now() - profilerStartTime;</span>
    <span class="s2">fiber.actualDuration += elapsedTime;</span>
    <span class="s2">fiber.selfBaseDuration = elapsedTime;</span>
    <span class="s2">profilerStartTime = -</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">&lt;= profilerStartTime) {</span>
    <span class="s4">var </span><span class="s2">elapsedTime = now() - profilerStartTime;</span>
    <span class="s2">fiber.actualDuration += elapsedTime;</span>
    <span class="s2">profilerStartTime = -</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">recordEffectDuration() {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">&lt;= profilerStartTime) {</span>
    <span class="s4">var </span><span class="s2">elapsedTime = now() - profilerStartTime;</span>
    <span class="s2">profilerStartTime = -</span><span class="s5">1</span><span class="s2">;</span>
    <span class="s2">profilerEffectDuration += elapsedTime;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">startEffectTimer() {</span>
  <span class="s2">profilerStartTime = now();</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">transferActualDuration(fiber) {</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">child = fiber.child; child; )</span>
    <span class="s2">(fiber.actualDuration += child.actualDuration), (child = child.sibling);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">currentEntangledListeners = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">currentEntangledPendingCount = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">currentEntangledLane = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">currentEntangledActionThenable = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">entangleAsyncAction(transition, thenable) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== currentEntangledListeners) {</span>
    <span class="s4">var </span><span class="s2">entangledListeners = (currentEntangledListeners = []);</span>
    <span class="s2">currentEntangledPendingCount = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">currentEntangledLane = requestTransitionLane();</span>
    <span class="s2">currentEntangledActionThenable = {</span>
      <span class="s2">status: </span><span class="s3">&quot;pending&quot;</span><span class="s2">,</span>
      <span class="s2">value: </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">then: </span><span class="s4">function </span><span class="s2">(resolve) {</span>
        <span class="s2">entangledListeners.push(resolve);</span>
      <span class="s2">}</span>
    <span class="s2">};</span>
  <span class="s2">}</span>
  <span class="s2">currentEntangledPendingCount++;</span>
  <span class="s2">thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);</span>
  <span class="s4">return </span><span class="s2">thenable;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">pingEngtangledActionScope() {</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s5">0 </span><span class="s2">=== --currentEntangledPendingCount &amp;&amp;</span>
    <span class="s4">null </span><span class="s2">!== currentEntangledListeners</span>
  <span class="s2">) {</span>
    <span class="s4">null </span><span class="s2">!== currentEntangledActionThenable &amp;&amp;</span>
      <span class="s2">(currentEntangledActionThenable.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">);</span>
    <span class="s4">var </span><span class="s2">listeners = currentEntangledListeners;</span>
    <span class="s2">currentEntangledListeners = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s2">currentEntangledLane = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">currentEntangledActionThenable = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; listeners.length; i++) (</span><span class="s5">0</span><span class="s2">, listeners[i])();</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">chainThenableValue(thenable, result) {</span>
  <span class="s4">var </span><span class="s2">listeners = [],</span>
    <span class="s2">thenableWithOverride = {</span>
      <span class="s2">status: </span><span class="s3">&quot;pending&quot;</span><span class="s2">,</span>
      <span class="s2">value: </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">reason: </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">then: </span><span class="s4">function </span><span class="s2">(resolve) {</span>
        <span class="s2">listeners.push(resolve);</span>
      <span class="s2">}</span>
    <span class="s2">};</span>
  <span class="s2">thenable.then(</span>
    <span class="s4">function </span><span class="s2">() {</span>
      <span class="s2">thenableWithOverride.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">;</span>
      <span class="s2">thenableWithOverride.value = result;</span>
      <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; listeners.length; i++) (</span><span class="s5">0</span><span class="s2">, listeners[i])(result);</span>
    <span class="s2">},</span>
    <span class="s4">function </span><span class="s2">(error) {</span>
      <span class="s2">thenableWithOverride.status = </span><span class="s3">&quot;rejected&quot;</span><span class="s2">;</span>
      <span class="s2">thenableWithOverride.reason = error;</span>
      <span class="s4">for </span><span class="s2">(error = </span><span class="s5">0</span><span class="s2">; error &lt; listeners.length; error++)</span>
        <span class="s2">(</span><span class="s5">0</span><span class="s2">, listeners[error])(</span><span class="s4">void </span><span class="s5">0</span><span class="s2">);</span>
    <span class="s2">}</span>
  <span class="s2">);</span>
  <span class="s4">return </span><span class="s2">thenableWithOverride;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">prevOnStartTransitionFinish = ReactSharedInternals.S;</span>
<span class="s2">ReactSharedInternals.S = </span><span class="s4">function </span><span class="s2">(transition, returnValue) {</span>
  <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">returnValue &amp;&amp;</span>
    <span class="s4">null </span><span class="s2">!== returnValue &amp;&amp;</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">returnValue.then &amp;&amp;</span>
    <span class="s2">entangleAsyncAction(transition, returnValue);</span>
  <span class="s4">null </span><span class="s2">!== prevOnStartTransitionFinish &amp;&amp;</span>
    <span class="s2">prevOnStartTransitionFinish(transition, returnValue);</span>
<span class="s2">};</span>
<span class="s4">var </span><span class="s2">resumedCache = createCursor(</span><span class="s4">null</span><span class="s2">);</span>
<span class="s4">function </span><span class="s2">peekCacheFromPool() {</span>
  <span class="s4">var </span><span class="s2">cacheResumedFromPreviousRender = resumedCache.current;</span>
  <span class="s4">return null </span><span class="s2">!== cacheResumedFromPreviousRender</span>
    <span class="s2">? cacheResumedFromPreviousRender</span>
    <span class="s2">: workInProgressRoot.pooledCache;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">pushTransition(offscreenWorkInProgress, prevCachePool) {</span>
  <span class="s4">null </span><span class="s2">=== prevCachePool</span>
    <span class="s2">? push(resumedCache, resumedCache.current)</span>
    <span class="s2">: push(resumedCache, prevCachePool.pool);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getSuspendedCache() {</span>
  <span class="s4">var </span><span class="s2">cacheFromPool = peekCacheFromPool();</span>
  <span class="s4">return null </span><span class="s2">=== cacheFromPool</span>
    <span class="s2">? </span><span class="s4">null</span>
    <span class="s2">: { parent: CacheContext._currentValue, pool: cacheFromPool };</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">SuspenseException = Error(formatProdErrorMessage(</span><span class="s5">460</span><span class="s2">)),</span>
  <span class="s2">SuspenseyCommitException = Error(formatProdErrorMessage(</span><span class="s5">474</span><span class="s2">)),</span>
  <span class="s2">SuspenseActionException = Error(formatProdErrorMessage(</span><span class="s5">542</span><span class="s2">)),</span>
  <span class="s2">noopSuspenseyCommitThenable = { then: </span><span class="s4">function </span><span class="s2">() {} };</span>
<span class="s4">function </span><span class="s2">isThenableResolved(thenable) {</span>
  <span class="s2">thenable = thenable.status;</span>
  <span class="s4">return </span><span class="s3">&quot;fulfilled&quot; </span><span class="s2">=== thenable || </span><span class="s3">&quot;rejected&quot; </span><span class="s2">=== thenable;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">noop$4() {}</span>
<span class="s4">function </span><span class="s2">trackUsedThenable(thenableState, thenable, index) {</span>
  <span class="s2">index = thenableState[index];</span>
  <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== index</span>
    <span class="s2">? thenableState.push(thenable)</span>
    <span class="s2">: index !== thenable &amp;&amp; (thenable.then(noop$4, noop$4), (thenable = index));</span>
  <span class="s4">switch </span><span class="s2">(thenable.status) {</span>
    <span class="s4">case </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">thenable.value;</span>
    <span class="s4">case </span><span class="s3">&quot;rejected&quot;</span><span class="s2">:</span>
      <span class="s4">throw </span><span class="s2">(</span>
        <span class="s2">((thenableState = thenable.reason),</span>
        <span class="s2">checkIfUseWrappedInAsyncCatch(thenableState),</span>
        <span class="s2">thenableState)</span>
      <span class="s2">);</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">thenable.status) thenable.then(noop$4, noop$4);</span>
      <span class="s4">else </span><span class="s2">{</span>
        <span class="s2">thenableState = workInProgressRoot;</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== thenableState &amp;&amp; </span><span class="s5">100 </span><span class="s2">&lt; thenableState.shellSuspendCounter)</span>
          <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">482</span><span class="s2">));</span>
        <span class="s2">thenableState = thenable;</span>
        <span class="s2">thenableState.status = </span><span class="s3">&quot;pending&quot;</span><span class="s2">;</span>
        <span class="s2">thenableState.then(</span>
          <span class="s4">function </span><span class="s2">(fulfilledValue) {</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;pending&quot; </span><span class="s2">=== thenable.status) {</span>
              <span class="s4">var </span><span class="s2">fulfilledThenable = thenable;</span>
              <span class="s2">fulfilledThenable.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">;</span>
              <span class="s2">fulfilledThenable.value = fulfilledValue;</span>
            <span class="s2">}</span>
          <span class="s2">},</span>
          <span class="s4">function </span><span class="s2">(error) {</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;pending&quot; </span><span class="s2">=== thenable.status) {</span>
              <span class="s4">var </span><span class="s2">rejectedThenable = thenable;</span>
              <span class="s2">rejectedThenable.status = </span><span class="s3">&quot;rejected&quot;</span><span class="s2">;</span>
              <span class="s2">rejectedThenable.reason = error;</span>
            <span class="s2">}</span>
          <span class="s2">}</span>
        <span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s4">switch </span><span class="s2">(thenable.status) {</span>
        <span class="s4">case </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">thenable.value;</span>
        <span class="s4">case </span><span class="s3">&quot;rejected&quot;</span><span class="s2">:</span>
          <span class="s4">throw </span><span class="s2">(</span>
            <span class="s2">((thenableState = thenable.reason),</span>
            <span class="s2">checkIfUseWrappedInAsyncCatch(thenableState),</span>
            <span class="s2">thenableState)</span>
          <span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s2">suspendedThenable = thenable;</span>
      <span class="s4">throw </span><span class="s2">SuspenseException;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">suspendedThenable = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">getSuspendedThenable() {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== suspendedThenable) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">459</span><span class="s2">));</span>
  <span class="s4">var </span><span class="s2">thenable = suspendedThenable;</span>
  <span class="s2">suspendedThenable = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">return </span><span class="s2">thenable;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">checkIfUseWrappedInAsyncCatch(rejectedReason) {</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s2">rejectedReason === SuspenseException ||</span>
    <span class="s2">rejectedReason === SuspenseActionException</span>
  <span class="s2">)</span>
    <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">483</span><span class="s2">));</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">hasForceUpdate = !</span><span class="s5">1</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">initializeUpdateQueue(fiber) {</span>
  <span class="s2">fiber.updateQueue = {</span>
    <span class="s2">baseState: fiber.memoizedState,</span>
    <span class="s2">firstBaseUpdate: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">lastBaseUpdate: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">shared: { pending: </span><span class="s4">null</span><span class="s2">, lanes: </span><span class="s5">0</span><span class="s2">, hiddenCallbacks: </span><span class="s4">null </span><span class="s2">},</span>
    <span class="s2">callbacks: </span><span class="s4">null</span>
  <span class="s2">};</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">cloneUpdateQueue(current, workInProgress) {</span>
  <span class="s2">current = current.updateQueue;</span>
  <span class="s2">workInProgress.updateQueue === current &amp;&amp;</span>
    <span class="s2">(workInProgress.updateQueue = {</span>
      <span class="s2">baseState: current.baseState,</span>
      <span class="s2">firstBaseUpdate: current.firstBaseUpdate,</span>
      <span class="s2">lastBaseUpdate: current.lastBaseUpdate,</span>
      <span class="s2">shared: current.shared,</span>
      <span class="s2">callbacks: </span><span class="s4">null</span>
    <span class="s2">});</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createUpdate(lane) {</span>
  <span class="s4">return </span><span class="s2">{ lane: lane, tag: </span><span class="s5">0</span><span class="s2">, payload: </span><span class="s4">null</span><span class="s2">, callback: </span><span class="s4">null</span><span class="s2">, next: </span><span class="s4">null </span><span class="s2">};</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">enqueueUpdate(fiber, update, lane) {</span>
  <span class="s4">var </span><span class="s2">updateQueue = fiber.updateQueue;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== updateQueue) </span><span class="s4">return null</span><span class="s2">;</span>
  <span class="s2">updateQueue = updateQueue.shared;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (executionContext &amp; </span><span class="s5">2</span><span class="s2">)) {</span>
    <span class="s4">var </span><span class="s2">pending = updateQueue.pending;</span>
    <span class="s4">null </span><span class="s2">=== pending</span>
      <span class="s2">? (update.next = update)</span>
      <span class="s2">: ((update.next = pending.next), (pending.next = update));</span>
    <span class="s2">updateQueue.pending = update;</span>
    <span class="s2">update = getRootForUpdatedFiber(fiber);</span>
    <span class="s2">markUpdateLaneFromFiberToRoot(fiber, </span><span class="s4">null</span><span class="s2">, lane);</span>
    <span class="s4">return </span><span class="s2">update;</span>
  <span class="s2">}</span>
  <span class="s2">enqueueUpdate$1(fiber, updateQueue, update, lane);</span>
  <span class="s4">return </span><span class="s2">getRootForUpdatedFiber(fiber);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">entangleTransitions(root, fiber, lane) {</span>
  <span class="s2">fiber = fiber.updateQueue;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== fiber &amp;&amp; ((fiber = fiber.shared), </span><span class="s5">0 </span><span class="s2">!== (lane &amp; </span><span class="s5">4194048</span><span class="s2">))) {</span>
    <span class="s4">var </span><span class="s2">queueLanes = fiber.lanes;</span>
    <span class="s2">queueLanes &amp;= root.pendingLanes;</span>
    <span class="s2">lane |= queueLanes;</span>
    <span class="s2">fiber.lanes = lane;</span>
    <span class="s2">markRootEntangled(root, lane);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">enqueueCapturedUpdate(workInProgress, capturedUpdate) {</span>
  <span class="s4">var </span><span class="s2">queue = workInProgress.updateQueue,</span>
    <span class="s2">current = workInProgress.alternate;</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s4">null </span><span class="s2">!== current &amp;&amp;</span>
    <span class="s2">((current = current.updateQueue), queue === current)</span>
  <span class="s2">) {</span>
    <span class="s4">var </span><span class="s2">newFirst = </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">newLast = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s2">queue = queue.firstBaseUpdate;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== queue) {</span>
      <span class="s4">do </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">clone = {</span>
          <span class="s2">lane: queue.lane,</span>
          <span class="s2">tag: queue.tag,</span>
          <span class="s2">payload: queue.payload,</span>
          <span class="s2">callback: </span><span class="s4">null</span><span class="s2">,</span>
          <span class="s2">next: </span><span class="s4">null</span>
        <span class="s2">};</span>
        <span class="s4">null </span><span class="s2">=== newLast</span>
          <span class="s2">? (newFirst = newLast = clone)</span>
          <span class="s2">: (newLast = newLast.next = clone);</span>
        <span class="s2">queue = queue.next;</span>
      <span class="s2">} </span><span class="s4">while </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== queue);</span>
      <span class="s4">null </span><span class="s2">=== newLast</span>
        <span class="s2">? (newFirst = newLast = capturedUpdate)</span>
        <span class="s2">: (newLast = newLast.next = capturedUpdate);</span>
    <span class="s2">} </span><span class="s4">else </span><span class="s2">newFirst = newLast = capturedUpdate;</span>
    <span class="s2">queue = {</span>
      <span class="s2">baseState: current.baseState,</span>
      <span class="s2">firstBaseUpdate: newFirst,</span>
      <span class="s2">lastBaseUpdate: newLast,</span>
      <span class="s2">shared: current.shared,</span>
      <span class="s2">callbacks: current.callbacks</span>
    <span class="s2">};</span>
    <span class="s2">workInProgress.updateQueue = queue;</span>
    <span class="s4">return</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s2">workInProgress = queue.lastBaseUpdate;</span>
  <span class="s4">null </span><span class="s2">=== workInProgress</span>
    <span class="s2">? (queue.firstBaseUpdate = capturedUpdate)</span>
    <span class="s2">: (workInProgress.next = capturedUpdate);</span>
  <span class="s2">queue.lastBaseUpdate = capturedUpdate;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">didReadFromEntangledAsyncAction = !</span><span class="s5">1</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">suspendIfUpdateReadFromEntangledAsyncAction() {</span>
  <span class="s4">if </span><span class="s2">(didReadFromEntangledAsyncAction) {</span>
    <span class="s4">var </span><span class="s2">entangledActionThenable = currentEntangledActionThenable;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== entangledActionThenable) </span><span class="s4">throw </span><span class="s2">entangledActionThenable;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">processUpdateQueue(</span>
  <span class="s2">workInProgress$jscomp$0,</span>
  <span class="s2">props,</span>
  <span class="s2">instance$jscomp$0,</span>
  <span class="s2">renderLanes</span>
<span class="s2">) {</span>
  <span class="s2">didReadFromEntangledAsyncAction = !</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">queue = workInProgress$jscomp$0.updateQueue;</span>
  <span class="s2">hasForceUpdate = !</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">firstBaseUpdate = queue.firstBaseUpdate,</span>
    <span class="s2">lastBaseUpdate = queue.lastBaseUpdate,</span>
    <span class="s2">pendingQueue = queue.shared.pending;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== pendingQueue) {</span>
    <span class="s2">queue.shared.pending = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">var </span><span class="s2">lastPendingUpdate = pendingQueue,</span>
      <span class="s2">firstPendingUpdate = lastPendingUpdate.next;</span>
    <span class="s2">lastPendingUpdate.next = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">null </span><span class="s2">=== lastBaseUpdate</span>
      <span class="s2">? (firstBaseUpdate = firstPendingUpdate)</span>
      <span class="s2">: (lastBaseUpdate.next = firstPendingUpdate);</span>
    <span class="s2">lastBaseUpdate = lastPendingUpdate;</span>
    <span class="s4">var </span><span class="s2">current = workInProgress$jscomp$0.alternate;</span>
    <span class="s4">null </span><span class="s2">!== current &amp;&amp;</span>
      <span class="s2">((current = current.updateQueue),</span>
      <span class="s2">(pendingQueue = current.lastBaseUpdate),</span>
      <span class="s2">pendingQueue !== lastBaseUpdate &amp;&amp;</span>
        <span class="s2">(</span><span class="s4">null </span><span class="s2">=== pendingQueue</span>
          <span class="s2">? (current.firstBaseUpdate = firstPendingUpdate)</span>
          <span class="s2">: (pendingQueue.next = firstPendingUpdate),</span>
        <span class="s2">(current.lastBaseUpdate = lastPendingUpdate)));</span>
  <span class="s2">}</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== firstBaseUpdate) {</span>
    <span class="s4">var </span><span class="s2">newState = queue.baseState;</span>
    <span class="s2">lastBaseUpdate = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">current = firstPendingUpdate = lastPendingUpdate = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s2">pendingQueue = firstBaseUpdate;</span>
    <span class="s4">do </span><span class="s2">{</span>
      <span class="s4">var </span><span class="s2">updateLane = pendingQueue.lane &amp; -</span><span class="s5">536870913</span><span class="s2">,</span>
        <span class="s2">isHiddenUpdate = updateLane !== pendingQueue.lane;</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">isHiddenUpdate</span>
          <span class="s2">? (workInProgressRootRenderLanes &amp; updateLane) === updateLane</span>
          <span class="s2">: (renderLanes &amp; updateLane) === updateLane</span>
      <span class="s2">) {</span>
        <span class="s5">0 </span><span class="s2">!== updateLane &amp;&amp;</span>
          <span class="s2">updateLane === currentEntangledLane &amp;&amp;</span>
          <span class="s2">(didReadFromEntangledAsyncAction = !</span><span class="s5">0</span><span class="s2">);</span>
        <span class="s4">null </span><span class="s2">!== current &amp;&amp;</span>
          <span class="s2">(current = current.next =</span>
            <span class="s2">{</span>
              <span class="s2">lane: </span><span class="s5">0</span><span class="s2">,</span>
              <span class="s2">tag: pendingQueue.tag,</span>
              <span class="s2">payload: pendingQueue.payload,</span>
              <span class="s2">callback: </span><span class="s4">null</span><span class="s2">,</span>
              <span class="s2">next: </span><span class="s4">null</span>
            <span class="s2">});</span>
        <span class="s2">a: {</span>
          <span class="s4">var </span><span class="s2">workInProgress = workInProgress$jscomp$0,</span>
            <span class="s2">update = pendingQueue;</span>
          <span class="s2">updateLane = props;</span>
          <span class="s4">var </span><span class="s2">instance = instance$jscomp$0;</span>
          <span class="s4">switch </span><span class="s2">(update.tag) {</span>
            <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
              <span class="s2">workInProgress = update.payload;</span>
              <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">workInProgress) {</span>
                <span class="s2">newState = workInProgress.call(instance, newState, updateLane);</span>
                <span class="s4">break </span><span class="s2">a;</span>
              <span class="s2">}</span>
              <span class="s2">newState = workInProgress;</span>
              <span class="s4">break </span><span class="s2">a;</span>
            <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
              <span class="s2">workInProgress.flags = (workInProgress.flags &amp; -</span><span class="s5">65537</span><span class="s2">) | </span><span class="s5">128</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s5">0</span><span class="s2">:</span>
              <span class="s2">workInProgress = update.payload;</span>
              <span class="s2">updateLane =</span>
                <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">workInProgress</span>
                  <span class="s2">? workInProgress.call(instance, newState, updateLane)</span>
                  <span class="s2">: workInProgress;</span>
              <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== updateLane || </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== updateLane) </span><span class="s4">break </span><span class="s2">a;</span>
              <span class="s2">newState = assign({}, newState, updateLane);</span>
              <span class="s4">break </span><span class="s2">a;</span>
            <span class="s4">case </span><span class="s5">2</span><span class="s2">:</span>
              <span class="s2">hasForceUpdate = !</span><span class="s5">0</span><span class="s2">;</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s2">updateLane = pendingQueue.callback;</span>
        <span class="s4">null </span><span class="s2">!== updateLane &amp;&amp;</span>
          <span class="s2">((workInProgress$jscomp$0.flags |= </span><span class="s5">64</span><span class="s2">),</span>
          <span class="s2">isHiddenUpdate &amp;&amp; (workInProgress$jscomp$0.flags |= </span><span class="s5">8192</span><span class="s2">),</span>
          <span class="s2">(isHiddenUpdate = queue.callbacks),</span>
          <span class="s4">null </span><span class="s2">=== isHiddenUpdate</span>
            <span class="s2">? (queue.callbacks = [updateLane])</span>
            <span class="s2">: isHiddenUpdate.push(updateLane));</span>
      <span class="s2">} </span><span class="s4">else</span>
        <span class="s2">(isHiddenUpdate = {</span>
          <span class="s2">lane: updateLane,</span>
          <span class="s2">tag: pendingQueue.tag,</span>
          <span class="s2">payload: pendingQueue.payload,</span>
          <span class="s2">callback: pendingQueue.callback,</span>
          <span class="s2">next: </span><span class="s4">null</span>
        <span class="s2">}),</span>
          <span class="s4">null </span><span class="s2">=== current</span>
            <span class="s2">? ((firstPendingUpdate = current = isHiddenUpdate),</span>
              <span class="s2">(lastPendingUpdate = newState))</span>
            <span class="s2">: (current = current.next = isHiddenUpdate),</span>
          <span class="s2">(lastBaseUpdate |= updateLane);</span>
      <span class="s2">pendingQueue = pendingQueue.next;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== pendingQueue)</span>
        <span class="s4">if </span><span class="s2">(((pendingQueue = queue.shared.pending), </span><span class="s4">null </span><span class="s2">=== pendingQueue))</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">else</span>
          <span class="s2">(isHiddenUpdate = pendingQueue),</span>
            <span class="s2">(pendingQueue = isHiddenUpdate.next),</span>
            <span class="s2">(isHiddenUpdate.next = </span><span class="s4">null</span><span class="s2">),</span>
            <span class="s2">(queue.lastBaseUpdate = isHiddenUpdate),</span>
            <span class="s2">(queue.shared.pending = </span><span class="s4">null</span><span class="s2">);</span>
    <span class="s2">} </span><span class="s4">while </span><span class="s2">(</span><span class="s5">1</span><span class="s2">);</span>
    <span class="s4">null </span><span class="s2">=== current &amp;&amp; (lastPendingUpdate = newState);</span>
    <span class="s2">queue.baseState = lastPendingUpdate;</span>
    <span class="s2">queue.firstBaseUpdate = firstPendingUpdate;</span>
    <span class="s2">queue.lastBaseUpdate = current;</span>
    <span class="s4">null </span><span class="s2">=== firstBaseUpdate &amp;&amp; (queue.shared.lanes = </span><span class="s5">0</span><span class="s2">);</span>
    <span class="s2">workInProgressRootSkippedLanes |= lastBaseUpdate;</span>
    <span class="s2">workInProgress$jscomp$0.lanes = lastBaseUpdate;</span>
    <span class="s2">workInProgress$jscomp$0.memoizedState = newState;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">callCallback(callback, context) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">callback)</span>
    <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">191</span><span class="s2">, callback));</span>
  <span class="s2">callback.call(context);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">commitCallbacks(updateQueue, context) {</span>
  <span class="s4">var </span><span class="s2">callbacks = updateQueue.callbacks;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== callbacks)</span>
    <span class="s4">for </span><span class="s2">(</span>
      <span class="s2">updateQueue.callbacks = </span><span class="s4">null</span><span class="s2">, updateQueue = </span><span class="s5">0</span><span class="s2">;</span>
      <span class="s2">updateQueue &lt; callbacks.length;</span>
      <span class="s2">updateQueue++</span>
    <span class="s2">)</span>
      <span class="s2">callCallback(callbacks[updateQueue], context);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">currentTreeHiddenStackCursor = createCursor(</span><span class="s4">null</span><span class="s2">),</span>
  <span class="s2">prevEntangledRenderLanesCursor = createCursor(</span><span class="s5">0</span><span class="s2">);</span>
<span class="s4">function </span><span class="s2">pushHiddenContext(fiber, context) {</span>
  <span class="s2">fiber = entangledRenderLanes;</span>
  <span class="s2">push(prevEntangledRenderLanesCursor, fiber);</span>
  <span class="s2">push(currentTreeHiddenStackCursor, context);</span>
  <span class="s2">entangledRenderLanes = fiber | context.baseLanes;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">reuseHiddenContextOnStack() {</span>
  <span class="s2">push(prevEntangledRenderLanesCursor, entangledRenderLanes);</span>
  <span class="s2">push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">popHiddenContext() {</span>
  <span class="s2">entangledRenderLanes = prevEntangledRenderLanesCursor.current;</span>
  <span class="s2">pop(currentTreeHiddenStackCursor);</span>
  <span class="s2">pop(prevEntangledRenderLanesCursor);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">renderLanes = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">currentlyRenderingFiber = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">currentHook = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">workInProgressHook = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">didScheduleRenderPhaseUpdate = !</span><span class="s5">1</span><span class="s2">,</span>
  <span class="s2">didScheduleRenderPhaseUpdateDuringThisPass = !</span><span class="s5">1</span><span class="s2">,</span>
  <span class="s2">shouldDoubleInvokeUserFnsInHooksDEV = !</span><span class="s5">1</span><span class="s2">,</span>
  <span class="s2">localIdCounter = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">thenableIndexCounter$1 = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">thenableState$1 = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">globalClientIdCounter = </span><span class="s5">0</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">throwInvalidHookError() {</span>
  <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">321</span><span class="s2">));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">areHookInputsEqual(nextDeps, prevDeps) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== prevDeps) </span><span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++)</span>
    <span class="s4">if </span><span class="s2">(!objectIs(nextDeps[i], prevDeps[i])) </span><span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">renderWithHooks(</span>
  <span class="s2">current,</span>
  <span class="s2">workInProgress,</span>
  <span class="s2">Component,</span>
  <span class="s2">props,</span>
  <span class="s2">secondArg,</span>
  <span class="s2">nextRenderLanes</span>
<span class="s2">) {</span>
  <span class="s2">renderLanes = nextRenderLanes;</span>
  <span class="s2">currentlyRenderingFiber = workInProgress;</span>
  <span class="s2">workInProgress.memoizedState = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">workInProgress.updateQueue = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">workInProgress.lanes = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">ReactSharedInternals.H =</span>
    <span class="s4">null </span><span class="s2">=== current || </span><span class="s4">null </span><span class="s2">=== current.memoizedState</span>
      <span class="s2">? HooksDispatcherOnMount</span>
      <span class="s2">: HooksDispatcherOnUpdate;</span>
  <span class="s2">shouldDoubleInvokeUserFnsInHooksDEV = !</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">nextRenderLanes = Component(props, secondArg);</span>
  <span class="s2">shouldDoubleInvokeUserFnsInHooksDEV = !</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">didScheduleRenderPhaseUpdateDuringThisPass &amp;&amp;</span>
    <span class="s2">(nextRenderLanes = renderWithHooksAgain(</span>
      <span class="s2">workInProgress,</span>
      <span class="s2">Component,</span>
      <span class="s2">props,</span>
      <span class="s2">secondArg</span>
    <span class="s2">));</span>
  <span class="s2">finishRenderingHooks(current);</span>
  <span class="s4">return </span><span class="s2">nextRenderLanes;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">finishRenderingHooks(current) {</span>
  <span class="s2">ReactSharedInternals.H = ContextOnlyDispatcher;</span>
  <span class="s4">var </span><span class="s2">didRenderTooFewHooks = </span><span class="s4">null </span><span class="s2">!== currentHook &amp;&amp; </span><span class="s4">null </span><span class="s2">!== currentHook.next;</span>
  <span class="s2">renderLanes = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">workInProgressHook = currentHook = currentlyRenderingFiber = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">didScheduleRenderPhaseUpdate = !</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">thenableIndexCounter$1 = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">thenableState$1 = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(didRenderTooFewHooks) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">300</span><span class="s2">));</span>
  <span class="s4">null </span><span class="s2">=== current ||</span>
    <span class="s2">didReceiveUpdate ||</span>
    <span class="s2">((current = current.dependencies),</span>
    <span class="s4">null </span><span class="s2">!== current &amp;&amp;</span>
      <span class="s2">checkIfContextChanged(current) &amp;&amp;</span>
      <span class="s2">(didReceiveUpdate = !</span><span class="s5">0</span><span class="s2">));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">renderWithHooksAgain(workInProgress, Component, props, secondArg) {</span>
  <span class="s2">currentlyRenderingFiber = workInProgress;</span>
  <span class="s4">var </span><span class="s2">numberOfReRenders = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">do </span><span class="s2">{</span>
    <span class="s2">didScheduleRenderPhaseUpdateDuringThisPass &amp;&amp; (thenableState$1 = </span><span class="s4">null</span><span class="s2">);</span>
    <span class="s2">thenableIndexCounter$1 = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">didScheduleRenderPhaseUpdateDuringThisPass = !</span><span class="s5">1</span><span class="s2">;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">25 </span><span class="s2">&lt;= numberOfReRenders) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">301</span><span class="s2">));</span>
    <span class="s2">numberOfReRenders += </span><span class="s5">1</span><span class="s2">;</span>
    <span class="s2">workInProgressHook = currentHook = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= workInProgress.updateQueue) {</span>
      <span class="s4">var </span><span class="s2">children = workInProgress.updateQueue;</span>
      <span class="s2">children.lastEffect = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">children.events = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">children.stores = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">null </span><span class="s2">!= children.memoCache &amp;&amp; (children.memoCache.index = </span><span class="s5">0</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s2">ReactSharedInternals.H = HooksDispatcherOnRerender;</span>
    <span class="s2">children = Component(props, secondArg);</span>
  <span class="s2">} </span><span class="s4">while </span><span class="s2">(didScheduleRenderPhaseUpdateDuringThisPass);</span>
  <span class="s4">return </span><span class="s2">children;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">TransitionAwareHostComponent() {</span>
  <span class="s4">var </span><span class="s2">dispatcher = ReactSharedInternals.H,</span>
    <span class="s2">maybeThenable = dispatcher.useState()[</span><span class="s5">0</span><span class="s2">];</span>
  <span class="s2">maybeThenable =</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">maybeThenable.then</span>
      <span class="s2">? useThenable(maybeThenable)</span>
      <span class="s2">: maybeThenable;</span>
  <span class="s2">dispatcher = dispatcher.useState()[</span><span class="s5">0</span><span class="s2">];</span>
  <span class="s2">(</span><span class="s4">null </span><span class="s2">!== currentHook ? currentHook.memoizedState : </span><span class="s4">null</span><span class="s2">) !== dispatcher &amp;&amp;</span>
    <span class="s2">(currentlyRenderingFiber.flags |= </span><span class="s5">1024</span><span class="s2">);</span>
  <span class="s4">return </span><span class="s2">maybeThenable;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">checkDidRenderIdHook() {</span>
  <span class="s4">var </span><span class="s2">didRenderIdHook = </span><span class="s5">0 </span><span class="s2">!== localIdCounter;</span>
  <span class="s2">localIdCounter = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">return </span><span class="s2">didRenderIdHook;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">bailoutHooks(current, workInProgress, lanes) {</span>
  <span class="s2">workInProgress.updateQueue = current.updateQueue;</span>
  <span class="s2">workInProgress.flags &amp;= -</span><span class="s5">2053</span><span class="s2">;</span>
  <span class="s2">current.lanes &amp;= ~lanes;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">resetHooksOnUnwind(workInProgress) {</span>
  <span class="s4">if </span><span class="s2">(didScheduleRenderPhaseUpdate) {</span>
    <span class="s4">for </span><span class="s2">(</span>
      <span class="s2">workInProgress = workInProgress.memoizedState;</span>
      <span class="s4">null </span><span class="s2">!== workInProgress;</span>

    <span class="s2">) {</span>
      <span class="s4">var </span><span class="s2">queue = workInProgress.queue;</span>
      <span class="s4">null </span><span class="s2">!== queue &amp;&amp; (queue.pending = </span><span class="s4">null</span><span class="s2">);</span>
      <span class="s2">workInProgress = workInProgress.next;</span>
    <span class="s2">}</span>
    <span class="s2">didScheduleRenderPhaseUpdate = !</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s2">renderLanes = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">workInProgressHook = currentHook = currentlyRenderingFiber = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">didScheduleRenderPhaseUpdateDuringThisPass = !</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">thenableIndexCounter$1 = localIdCounter = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">thenableState$1 = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">mountWorkInProgressHook() {</span>
  <span class="s4">var </span><span class="s2">hook = {</span>
    <span class="s2">memoizedState: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">baseState: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">baseQueue: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">queue: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">next: </span><span class="s4">null</span>
  <span class="s2">};</span>
  <span class="s4">null </span><span class="s2">=== workInProgressHook</span>
    <span class="s2">? (currentlyRenderingFiber.memoizedState = workInProgressHook = hook)</span>
    <span class="s2">: (workInProgressHook = workInProgressHook.next = hook);</span>
  <span class="s4">return </span><span class="s2">workInProgressHook;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateWorkInProgressHook() {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== currentHook) {</span>
    <span class="s4">var </span><span class="s2">nextCurrentHook = currentlyRenderingFiber.alternate;</span>
    <span class="s2">nextCurrentHook =</span>
      <span class="s4">null </span><span class="s2">!== nextCurrentHook ? nextCurrentHook.memoizedState : </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">} </span><span class="s4">else </span><span class="s2">nextCurrentHook = currentHook.next;</span>
  <span class="s4">var </span><span class="s2">nextWorkInProgressHook =</span>
    <span class="s4">null </span><span class="s2">=== workInProgressHook</span>
      <span class="s2">? currentlyRenderingFiber.memoizedState</span>
      <span class="s2">: workInProgressHook.next;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== nextWorkInProgressHook)</span>
    <span class="s2">(workInProgressHook = nextWorkInProgressHook),</span>
      <span class="s2">(currentHook = nextCurrentHook);</span>
  <span class="s4">else </span><span class="s2">{</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== nextCurrentHook) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== currentlyRenderingFiber.alternate)</span>
        <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">467</span><span class="s2">));</span>
      <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">310</span><span class="s2">));</span>
    <span class="s2">}</span>
    <span class="s2">currentHook = nextCurrentHook;</span>
    <span class="s2">nextCurrentHook = {</span>
      <span class="s2">memoizedState: currentHook.memoizedState,</span>
      <span class="s2">baseState: currentHook.baseState,</span>
      <span class="s2">baseQueue: currentHook.baseQueue,</span>
      <span class="s2">queue: currentHook.queue,</span>
      <span class="s2">next: </span><span class="s4">null</span>
    <span class="s2">};</span>
    <span class="s4">null </span><span class="s2">=== workInProgressHook</span>
      <span class="s2">? (currentlyRenderingFiber.memoizedState = workInProgressHook =</span>
          <span class="s2">nextCurrentHook)</span>
      <span class="s2">: (workInProgressHook = workInProgressHook.next = nextCurrentHook);</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">workInProgressHook;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createFunctionComponentUpdateQueue() {</span>
  <span class="s4">return </span><span class="s2">{ lastEffect: </span><span class="s4">null</span><span class="s2">, events: </span><span class="s4">null</span><span class="s2">, stores: </span><span class="s4">null</span><span class="s2">, memoCache: </span><span class="s4">null </span><span class="s2">};</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">useThenable(thenable) {</span>
  <span class="s4">var </span><span class="s2">index = thenableIndexCounter$1;</span>
  <span class="s2">thenableIndexCounter$1 += </span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">null </span><span class="s2">=== thenableState$1 &amp;&amp; (thenableState$1 = []);</span>
  <span class="s2">thenable = trackUsedThenable(thenableState$1, thenable, index);</span>
  <span class="s2">index = currentlyRenderingFiber;</span>
  <span class="s4">null </span><span class="s2">===</span>
    <span class="s2">(</span><span class="s4">null </span><span class="s2">=== workInProgressHook</span>
      <span class="s2">? index.memoizedState</span>
      <span class="s2">: workInProgressHook.next) &amp;&amp;</span>
    <span class="s2">((index = index.alternate),</span>
    <span class="s2">(ReactSharedInternals.H =</span>
      <span class="s4">null </span><span class="s2">=== index || </span><span class="s4">null </span><span class="s2">=== index.memoizedState</span>
        <span class="s2">? HooksDispatcherOnMount</span>
        <span class="s2">: HooksDispatcherOnUpdate));</span>
  <span class="s4">return </span><span class="s2">thenable;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">use(usable) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== usable &amp;&amp; </span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">usable) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">usable.then) </span><span class="s4">return </span><span class="s2">useThenable(usable);</span>
    <span class="s4">if </span><span class="s2">(usable.$$typeof === REACT_CONTEXT_TYPE) </span><span class="s4">return </span><span class="s2">readContext(usable);</span>
  <span class="s2">}</span>
  <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">438</span><span class="s2">, String(usable)));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">useMemoCache(size) {</span>
  <span class="s4">var </span><span class="s2">memoCache = </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">updateQueue = currentlyRenderingFiber.updateQueue;</span>
  <span class="s4">null </span><span class="s2">!== updateQueue &amp;&amp; (memoCache = updateQueue.memoCache);</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">== memoCache) {</span>
    <span class="s4">var </span><span class="s2">current = currentlyRenderingFiber.alternate;</span>
    <span class="s4">null </span><span class="s2">!== current &amp;&amp;</span>
      <span class="s2">((current = current.updateQueue),</span>
      <span class="s4">null </span><span class="s2">!== current &amp;&amp;</span>
        <span class="s2">((current = current.memoCache),</span>
        <span class="s4">null </span><span class="s2">!= current &amp;&amp;</span>
          <span class="s2">(memoCache = {</span>
            <span class="s2">data: current.data.map(</span><span class="s4">function </span><span class="s2">(array) {</span>
              <span class="s4">return </span><span class="s2">array.slice();</span>
            <span class="s2">}),</span>
            <span class="s2">index: </span><span class="s5">0</span>
          <span class="s2">})));</span>
  <span class="s2">}</span>
  <span class="s4">null </span><span class="s2">== memoCache &amp;&amp; (memoCache = { data: [], index: </span><span class="s5">0 </span><span class="s2">});</span>
  <span class="s4">null </span><span class="s2">=== updateQueue &amp;&amp;</span>
    <span class="s2">((updateQueue = createFunctionComponentUpdateQueue()),</span>
    <span class="s2">(currentlyRenderingFiber.updateQueue = updateQueue));</span>
  <span class="s2">updateQueue.memoCache = memoCache;</span>
  <span class="s2">updateQueue = memoCache.data[memoCache.index];</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== updateQueue)</span>
    <span class="s4">for </span><span class="s2">(</span>
      <span class="s2">updateQueue = memoCache.data[memoCache.index] = Array(size), current = </span><span class="s5">0</span><span class="s2">;</span>
      <span class="s2">current &lt; size;</span>
      <span class="s2">current++</span>
    <span class="s2">)</span>
      <span class="s2">updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;</span>
  <span class="s2">memoCache.index++;</span>
  <span class="s4">return </span><span class="s2">updateQueue;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">basicStateReducer(state, action) {</span>
  <span class="s4">return </span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">action ? action(state) : action;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateReducer(reducer) {</span>
  <span class="s4">var </span><span class="s2">hook = updateWorkInProgressHook();</span>
  <span class="s4">return </span><span class="s2">updateReducerImpl(hook, currentHook, reducer);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateReducerImpl(hook, current, reducer) {</span>
  <span class="s4">var </span><span class="s2">queue = hook.queue;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== queue) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">311</span><span class="s2">));</span>
  <span class="s2">queue.lastRenderedReducer = reducer;</span>
  <span class="s4">var </span><span class="s2">baseQueue = hook.baseQueue,</span>
    <span class="s2">pendingQueue = queue.pending;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== pendingQueue) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== baseQueue) {</span>
      <span class="s4">var </span><span class="s2">baseFirst = baseQueue.next;</span>
      <span class="s2">baseQueue.next = pendingQueue.next;</span>
      <span class="s2">pendingQueue.next = baseFirst;</span>
    <span class="s2">}</span>
    <span class="s2">current.baseQueue = baseQueue = pendingQueue;</span>
    <span class="s2">queue.pending = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s2">pendingQueue = hook.baseState;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== baseQueue) hook.memoizedState = pendingQueue;</span>
  <span class="s4">else </span><span class="s2">{</span>
    <span class="s2">current = baseQueue.next;</span>
    <span class="s4">var </span><span class="s2">newBaseQueueFirst = (baseFirst = </span><span class="s4">null</span><span class="s2">),</span>
      <span class="s2">newBaseQueueLast = </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">update = current,</span>
      <span class="s2">didReadFromEntangledAsyncAction$34 = !</span><span class="s5">1</span><span class="s2">;</span>
    <span class="s4">do </span><span class="s2">{</span>
      <span class="s4">var </span><span class="s2">updateLane = update.lane &amp; -</span><span class="s5">536870913</span><span class="s2">;</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">updateLane !== update.lane</span>
          <span class="s2">? (workInProgressRootRenderLanes &amp; updateLane) === updateLane</span>
          <span class="s2">: (renderLanes &amp; updateLane) === updateLane</span>
      <span class="s2">) {</span>
        <span class="s4">var </span><span class="s2">revertLane = update.revertLane;</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== revertLane)</span>
          <span class="s4">null </span><span class="s2">!== newBaseQueueLast &amp;&amp;</span>
            <span class="s2">(newBaseQueueLast = newBaseQueueLast.next =</span>
              <span class="s2">{</span>
                <span class="s2">lane: </span><span class="s5">0</span><span class="s2">,</span>
                <span class="s2">revertLane: </span><span class="s5">0</span><span class="s2">,</span>
                <span class="s2">action: update.action,</span>
                <span class="s2">hasEagerState: update.hasEagerState,</span>
                <span class="s2">eagerState: update.eagerState,</span>
                <span class="s2">next: </span><span class="s4">null</span>
              <span class="s2">}),</span>
            <span class="s2">updateLane === currentEntangledLane &amp;&amp;</span>
              <span class="s2">(didReadFromEntangledAsyncAction$34 = !</span><span class="s5">0</span><span class="s2">);</span>
        <span class="s4">else if </span><span class="s2">((renderLanes &amp; revertLane) === revertLane) {</span>
          <span class="s2">update = update.next;</span>
          <span class="s2">revertLane === currentEntangledLane &amp;&amp;</span>
            <span class="s2">(didReadFromEntangledAsyncAction$34 = !</span><span class="s5">0</span><span class="s2">);</span>
          <span class="s4">continue</span><span class="s2">;</span>
        <span class="s2">} </span><span class="s4">else</span>
          <span class="s2">(updateLane = {</span>
            <span class="s2">lane: </span><span class="s5">0</span><span class="s2">,</span>
            <span class="s2">revertLane: update.revertLane,</span>
            <span class="s2">action: update.action,</span>
            <span class="s2">hasEagerState: update.hasEagerState,</span>
            <span class="s2">eagerState: update.eagerState,</span>
            <span class="s2">next: </span><span class="s4">null</span>
          <span class="s2">}),</span>
            <span class="s4">null </span><span class="s2">=== newBaseQueueLast</span>
              <span class="s2">? ((newBaseQueueFirst = newBaseQueueLast = updateLane),</span>
                <span class="s2">(baseFirst = pendingQueue))</span>
              <span class="s2">: (newBaseQueueLast = newBaseQueueLast.next = updateLane),</span>
            <span class="s2">(currentlyRenderingFiber.lanes |= revertLane),</span>
            <span class="s2">(workInProgressRootSkippedLanes |= revertLane);</span>
        <span class="s2">updateLane = update.action;</span>
        <span class="s2">shouldDoubleInvokeUserFnsInHooksDEV &amp;&amp;</span>
          <span class="s2">reducer(pendingQueue, updateLane);</span>
        <span class="s2">pendingQueue = update.hasEagerState</span>
          <span class="s2">? update.eagerState</span>
          <span class="s2">: reducer(pendingQueue, updateLane);</span>
      <span class="s2">} </span><span class="s4">else</span>
        <span class="s2">(revertLane = {</span>
          <span class="s2">lane: updateLane,</span>
          <span class="s2">revertLane: update.revertLane,</span>
          <span class="s2">action: update.action,</span>
          <span class="s2">hasEagerState: update.hasEagerState,</span>
          <span class="s2">eagerState: update.eagerState,</span>
          <span class="s2">next: </span><span class="s4">null</span>
        <span class="s2">}),</span>
          <span class="s4">null </span><span class="s2">=== newBaseQueueLast</span>
            <span class="s2">? ((newBaseQueueFirst = newBaseQueueLast = revertLane),</span>
              <span class="s2">(baseFirst = pendingQueue))</span>
            <span class="s2">: (newBaseQueueLast = newBaseQueueLast.next = revertLane),</span>
          <span class="s2">(currentlyRenderingFiber.lanes |= updateLane),</span>
          <span class="s2">(workInProgressRootSkippedLanes |= updateLane);</span>
      <span class="s2">update = update.next;</span>
    <span class="s2">} </span><span class="s4">while </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== update &amp;&amp; update !== current);</span>
    <span class="s4">null </span><span class="s2">=== newBaseQueueLast</span>
      <span class="s2">? (baseFirst = pendingQueue)</span>
      <span class="s2">: (newBaseQueueLast.next = newBaseQueueFirst);</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">!objectIs(pendingQueue, hook.memoizedState) &amp;&amp;</span>
      <span class="s2">((didReceiveUpdate = !</span><span class="s5">0</span><span class="s2">),</span>
      <span class="s2">didReadFromEntangledAsyncAction$34 &amp;&amp;</span>
        <span class="s2">((reducer = currentEntangledActionThenable), </span><span class="s4">null </span><span class="s2">!== reducer))</span>
    <span class="s2">)</span>
      <span class="s4">throw </span><span class="s2">reducer;</span>
    <span class="s2">hook.memoizedState = pendingQueue;</span>
    <span class="s2">hook.baseState = baseFirst;</span>
    <span class="s2">hook.baseQueue = newBaseQueueLast;</span>
    <span class="s2">queue.lastRenderedState = pendingQueue;</span>
  <span class="s2">}</span>
  <span class="s4">null </span><span class="s2">=== baseQueue &amp;&amp; (queue.lanes = </span><span class="s5">0</span><span class="s2">);</span>
  <span class="s4">return </span><span class="s2">[hook.memoizedState, queue.dispatch];</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">rerenderReducer(reducer) {</span>
  <span class="s4">var </span><span class="s2">hook = updateWorkInProgressHook(),</span>
    <span class="s2">queue = hook.queue;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== queue) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">311</span><span class="s2">));</span>
  <span class="s2">queue.lastRenderedReducer = reducer;</span>
  <span class="s4">var </span><span class="s2">dispatch = queue.dispatch,</span>
    <span class="s2">lastRenderPhaseUpdate = queue.pending,</span>
    <span class="s2">newState = hook.memoizedState;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== lastRenderPhaseUpdate) {</span>
    <span class="s2">queue.pending = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">var </span><span class="s2">update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);</span>
    <span class="s4">do </span><span class="s2">(newState = reducer(newState, update.action)), (update = update.next);</span>
    <span class="s4">while </span><span class="s2">(update !== lastRenderPhaseUpdate);</span>
    <span class="s2">objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !</span><span class="s5">0</span><span class="s2">);</span>
    <span class="s2">hook.memoizedState = newState;</span>
    <span class="s4">null </span><span class="s2">=== hook.baseQueue &amp;&amp; (hook.baseState = newState);</span>
    <span class="s2">queue.lastRenderedState = newState;</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">[newState, dispatch];</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {</span>
  <span class="s4">var </span><span class="s2">fiber = currentlyRenderingFiber,</span>
    <span class="s2">hook = updateWorkInProgressHook(),</span>
    <span class="s2">isHydrating$jscomp$0 = isHydrating;</span>
  <span class="s4">if </span><span class="s2">(isHydrating$jscomp$0) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== getServerSnapshot) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">407</span><span class="s2">));</span>
    <span class="s2">getServerSnapshot = getServerSnapshot();</span>
  <span class="s2">} </span><span class="s4">else </span><span class="s2">getServerSnapshot = getSnapshot();</span>
  <span class="s4">var </span><span class="s2">snapshotChanged = !objectIs(</span>
    <span class="s2">(currentHook || hook).memoizedState,</span>
    <span class="s2">getServerSnapshot</span>
  <span class="s2">);</span>
  <span class="s2">snapshotChanged &amp;&amp;</span>
    <span class="s2">((hook.memoizedState = getServerSnapshot), (didReceiveUpdate = !</span><span class="s5">0</span><span class="s2">));</span>
  <span class="s2">hook = hook.queue;</span>
  <span class="s4">var </span><span class="s2">create = subscribeToStore.bind(</span><span class="s4">null</span><span class="s2">, fiber, hook, subscribe);</span>
  <span class="s2">updateEffectImpl(</span><span class="s5">2048</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, create, [subscribe]);</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s2">hook.getSnapshot !== getSnapshot ||</span>
    <span class="s2">snapshotChanged ||</span>
    <span class="s2">(</span><span class="s4">null </span><span class="s2">!== workInProgressHook &amp;&amp; workInProgressHook.memoizedState.tag &amp; </span><span class="s5">1</span><span class="s2">)</span>
  <span class="s2">) {</span>
    <span class="s2">fiber.flags |= </span><span class="s5">2048</span><span class="s2">;</span>
    <span class="s2">pushSimpleEffect(</span>
      <span class="s5">9</span><span class="s2">,</span>
      <span class="s2">createEffectInstance(),</span>
      <span class="s2">updateStoreInstance.bind(</span>
        <span class="s4">null</span><span class="s2">,</span>
        <span class="s2">fiber,</span>
        <span class="s2">hook,</span>
        <span class="s2">getServerSnapshot,</span>
        <span class="s2">getSnapshot</span>
      <span class="s2">),</span>
      <span class="s4">null</span>
    <span class="s2">);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== workInProgressRoot) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">349</span><span class="s2">));</span>
    <span class="s2">isHydrating$jscomp$0 ||</span>
      <span class="s5">0 </span><span class="s2">!== (renderLanes &amp; </span><span class="s5">124</span><span class="s2">) ||</span>
      <span class="s2">pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">getServerSnapshot;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {</span>
  <span class="s2">fiber.flags |= </span><span class="s5">16384</span><span class="s2">;</span>
  <span class="s2">fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };</span>
  <span class="s2">getSnapshot = currentlyRenderingFiber.updateQueue;</span>
  <span class="s4">null </span><span class="s2">=== getSnapshot</span>
    <span class="s2">? ((getSnapshot = createFunctionComponentUpdateQueue()),</span>
      <span class="s2">(currentlyRenderingFiber.updateQueue = getSnapshot),</span>
      <span class="s2">(getSnapshot.stores = [fiber]))</span>
    <span class="s2">: ((renderedSnapshot = getSnapshot.stores),</span>
      <span class="s4">null </span><span class="s2">=== renderedSnapshot</span>
        <span class="s2">? (getSnapshot.stores = [fiber])</span>
        <span class="s2">: renderedSnapshot.push(fiber));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {</span>
  <span class="s2">inst.value = nextSnapshot;</span>
  <span class="s2">inst.getSnapshot = getSnapshot;</span>
  <span class="s2">checkIfSnapshotChanged(inst) &amp;&amp; forceStoreRerender(fiber);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">subscribeToStore(fiber, inst, subscribe) {</span>
  <span class="s4">return </span><span class="s2">subscribe(</span><span class="s4">function </span><span class="s2">() {</span>
    <span class="s2">checkIfSnapshotChanged(inst) &amp;&amp; forceStoreRerender(fiber);</span>
  <span class="s2">});</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">checkIfSnapshotChanged(inst) {</span>
  <span class="s4">var </span><span class="s2">latestGetSnapshot = inst.getSnapshot;</span>
  <span class="s2">inst = inst.value;</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">nextValue = latestGetSnapshot();</span>
    <span class="s4">return </span><span class="s2">!objectIs(inst, nextValue);</span>
  <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
    <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">forceStoreRerender(fiber) {</span>
  <span class="s4">var </span><span class="s2">root = enqueueConcurrentRenderForLane(fiber, </span><span class="s5">2</span><span class="s2">);</span>
  <span class="s4">null </span><span class="s2">!== root &amp;&amp; scheduleUpdateOnFiber(root, fiber, </span><span class="s5">2</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">mountStateImpl(initialState) {</span>
  <span class="s4">var </span><span class="s2">hook = mountWorkInProgressHook();</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">initialState) {</span>
    <span class="s4">var </span><span class="s2">initialStateInitializer = initialState;</span>
    <span class="s2">initialState = initialStateInitializer();</span>
    <span class="s4">if </span><span class="s2">(shouldDoubleInvokeUserFnsInHooksDEV) {</span>
      <span class="s2">setIsStrictModeForDevtools(!</span><span class="s5">0</span><span class="s2">);</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s2">initialStateInitializer();</span>
      <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
        <span class="s2">setIsStrictModeForDevtools(!</span><span class="s5">1</span><span class="s2">);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s2">hook.memoizedState = hook.baseState = initialState;</span>
  <span class="s2">hook.queue = {</span>
    <span class="s2">pending: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">lanes: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">dispatch: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">lastRenderedReducer: basicStateReducer,</span>
    <span class="s2">lastRenderedState: initialState</span>
  <span class="s2">};</span>
  <span class="s4">return </span><span class="s2">hook;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateOptimisticImpl(hook, current, passthrough, reducer) {</span>
  <span class="s2">hook.baseState = passthrough;</span>
  <span class="s4">return </span><span class="s2">updateReducerImpl(</span>
    <span class="s2">hook,</span>
    <span class="s2">currentHook,</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">reducer ? reducer : basicStateReducer</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">dispatchActionState(</span>
  <span class="s2">fiber,</span>
  <span class="s2">actionQueue,</span>
  <span class="s2">setPendingState,</span>
  <span class="s2">setState,</span>
  <span class="s2">payload</span>
<span class="s2">) {</span>
  <span class="s4">if </span><span class="s2">(isRenderPhaseUpdate(fiber)) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">485</span><span class="s2">));</span>
  <span class="s2">fiber = actionQueue.action;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== fiber) {</span>
    <span class="s4">var </span><span class="s2">actionNode = {</span>
      <span class="s2">payload: payload,</span>
      <span class="s2">action: fiber,</span>
      <span class="s2">next: </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">isTransition: !</span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">status: </span><span class="s3">&quot;pending&quot;</span><span class="s2">,</span>
      <span class="s2">value: </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">reason: </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">listeners: [],</span>
      <span class="s2">then: </span><span class="s4">function </span><span class="s2">(listener) {</span>
        <span class="s2">actionNode.listeners.push(listener);</span>
      <span class="s2">}</span>
    <span class="s2">};</span>
    <span class="s4">null </span><span class="s2">!== ReactSharedInternals.T</span>
      <span class="s2">? setPendingState(!</span><span class="s5">0</span><span class="s2">)</span>
      <span class="s2">: (actionNode.isTransition = !</span><span class="s5">1</span><span class="s2">);</span>
    <span class="s2">setState(actionNode);</span>
    <span class="s2">setPendingState = actionQueue.pending;</span>
    <span class="s4">null </span><span class="s2">=== setPendingState</span>
      <span class="s2">? ((actionNode.next = actionQueue.pending = actionNode),</span>
        <span class="s2">runActionStateAction(actionQueue, actionNode))</span>
      <span class="s2">: ((actionNode.next = setPendingState.next),</span>
        <span class="s2">(actionQueue.pending = setPendingState.next = actionNode));</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">runActionStateAction(actionQueue, node) {</span>
  <span class="s4">var </span><span class="s2">action = node.action,</span>
    <span class="s2">payload = node.payload,</span>
    <span class="s2">prevState = actionQueue.state;</span>
  <span class="s4">if </span><span class="s2">(node.isTransition) {</span>
    <span class="s4">var </span><span class="s2">prevTransition = ReactSharedInternals.T,</span>
      <span class="s2">currentTransition = {};</span>
    <span class="s2">ReactSharedInternals.T = currentTransition;</span>
    <span class="s4">try </span><span class="s2">{</span>
      <span class="s4">var </span><span class="s2">returnValue = action(prevState, payload),</span>
        <span class="s2">onStartTransitionFinish = ReactSharedInternals.S;</span>
      <span class="s4">null </span><span class="s2">!== onStartTransitionFinish &amp;&amp;</span>
        <span class="s2">onStartTransitionFinish(currentTransition, returnValue);</span>
      <span class="s2">handleActionReturnValue(actionQueue, node, returnValue);</span>
    <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
      <span class="s2">onActionError(actionQueue, node, error);</span>
    <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
      <span class="s2">ReactSharedInternals.T = prevTransition;</span>
    <span class="s2">}</span>
  <span class="s2">} </span><span class="s4">else</span>
    <span class="s4">try </span><span class="s2">{</span>
      <span class="s2">(prevTransition = action(prevState, payload)),</span>
        <span class="s2">handleActionReturnValue(actionQueue, node, prevTransition);</span>
    <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error$40) {</span>
      <span class="s2">onActionError(actionQueue, node, error$40);</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">handleActionReturnValue(actionQueue, node, returnValue) {</span>
  <span class="s4">null </span><span class="s2">!== returnValue &amp;&amp;</span>
  <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">returnValue &amp;&amp;</span>
  <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">returnValue.then</span>
    <span class="s2">? returnValue.then(</span>
        <span class="s4">function </span><span class="s2">(nextState) {</span>
          <span class="s2">onActionSuccess(actionQueue, node, nextState);</span>
        <span class="s2">},</span>
        <span class="s4">function </span><span class="s2">(error) {</span>
          <span class="s4">return </span><span class="s2">onActionError(actionQueue, node, error);</span>
        <span class="s2">}</span>
      <span class="s2">)</span>
    <span class="s2">: onActionSuccess(actionQueue, node, returnValue);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">onActionSuccess(actionQueue, actionNode, nextState) {</span>
  <span class="s2">actionNode.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">;</span>
  <span class="s2">actionNode.value = nextState;</span>
  <span class="s2">notifyActionListeners(actionNode);</span>
  <span class="s2">actionQueue.state = nextState;</span>
  <span class="s2">actionNode = actionQueue.pending;</span>
  <span class="s4">null </span><span class="s2">!== actionNode &amp;&amp;</span>
    <span class="s2">((nextState = actionNode.next),</span>
    <span class="s2">nextState === actionNode</span>
      <span class="s2">? (actionQueue.pending = </span><span class="s4">null</span><span class="s2">)</span>
      <span class="s2">: ((nextState = nextState.next),</span>
        <span class="s2">(actionNode.next = nextState),</span>
        <span class="s2">runActionStateAction(actionQueue, nextState)));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">onActionError(actionQueue, actionNode, error) {</span>
  <span class="s4">var </span><span class="s2">last = actionQueue.pending;</span>
  <span class="s2">actionQueue.pending = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== last) {</span>
    <span class="s2">last = last.next;</span>
    <span class="s4">do</span>
      <span class="s2">(actionNode.status = </span><span class="s3">&quot;rejected&quot;</span><span class="s2">),</span>
        <span class="s2">(actionNode.reason = error),</span>
        <span class="s2">notifyActionListeners(actionNode),</span>
        <span class="s2">(actionNode = actionNode.next);</span>
    <span class="s4">while </span><span class="s2">(actionNode !== last);</span>
  <span class="s2">}</span>
  <span class="s2">actionQueue.action = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">notifyActionListeners(actionNode) {</span>
  <span class="s2">actionNode = actionNode.listeners;</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; actionNode.length; i++) (</span><span class="s5">0</span><span class="s2">, actionNode[i])();</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">actionStateReducer(oldState, newState) {</span>
  <span class="s4">return </span><span class="s2">newState;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">mountActionState(action, initialStateProp) {</span>
  <span class="s4">if </span><span class="s2">(isHydrating) {</span>
    <span class="s4">var </span><span class="s2">ssrFormState = workInProgressRoot.formState;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== ssrFormState) {</span>
      <span class="s2">a: {</span>
        <span class="s4">var </span><span class="s2">JSCompiler_inline_result = currentlyRenderingFiber;</span>
        <span class="s4">if </span><span class="s2">(isHydrating) {</span>
          <span class="s4">if </span><span class="s2">(nextHydratableInstance) {</span>
            <span class="s2">b: {</span>
              <span class="s4">var </span><span class="s2">JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;</span>
              <span class="s4">for </span><span class="s2">(</span>
                <span class="s4">var </span><span class="s2">inRootOrSingleton = rootOrSingletonContext;</span>
                <span class="s5">8 </span><span class="s2">!== JSCompiler_inline_result$jscomp$0.nodeType;</span>

              <span class="s2">) {</span>
                <span class="s4">if </span><span class="s2">(!inRootOrSingleton) {</span>
                  <span class="s2">JSCompiler_inline_result$jscomp$0 = </span><span class="s4">null</span><span class="s2">;</span>
                  <span class="s4">break </span><span class="s2">b;</span>
                <span class="s2">}</span>
                <span class="s2">JSCompiler_inline_result$jscomp$0 = getNextHydratable(</span>
                  <span class="s2">JSCompiler_inline_result$jscomp$0.nextSibling</span>
                <span class="s2">);</span>
                <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== JSCompiler_inline_result$jscomp$0) {</span>
                  <span class="s2">JSCompiler_inline_result$jscomp$0 = </span><span class="s4">null</span><span class="s2">;</span>
                  <span class="s4">break </span><span class="s2">b;</span>
                <span class="s2">}</span>
              <span class="s2">}</span>
              <span class="s2">inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;</span>
              <span class="s2">JSCompiler_inline_result$jscomp$0 =</span>
                <span class="s3">&quot;F!&quot; </span><span class="s2">=== inRootOrSingleton || </span><span class="s3">&quot;F&quot; </span><span class="s2">=== inRootOrSingleton</span>
                  <span class="s2">? JSCompiler_inline_result$jscomp$0</span>
                  <span class="s2">: </span><span class="s4">null</span><span class="s2">;</span>
            <span class="s2">}</span>
            <span class="s4">if </span><span class="s2">(JSCompiler_inline_result$jscomp$0) {</span>
              <span class="s2">nextHydratableInstance = getNextHydratable(</span>
                <span class="s2">JSCompiler_inline_result$jscomp$0.nextSibling</span>
              <span class="s2">);</span>
              <span class="s2">JSCompiler_inline_result =</span>
                <span class="s3">&quot;F!&quot; </span><span class="s2">=== JSCompiler_inline_result$jscomp$0.data;</span>
              <span class="s4">break </span><span class="s2">a;</span>
            <span class="s2">}</span>
          <span class="s2">}</span>
          <span class="s2">throwOnHydrationMismatch(JSCompiler_inline_result);</span>
        <span class="s2">}</span>
        <span class="s2">JSCompiler_inline_result = !</span><span class="s5">1</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s2">JSCompiler_inline_result &amp;&amp; (initialStateProp = ssrFormState[</span><span class="s5">0</span><span class="s2">]);</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s2">ssrFormState = mountWorkInProgressHook();</span>
  <span class="s2">ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;</span>
  <span class="s2">JSCompiler_inline_result = {</span>
    <span class="s2">pending: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">lanes: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">dispatch: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">lastRenderedReducer: actionStateReducer,</span>
    <span class="s2">lastRenderedState: initialStateProp</span>
  <span class="s2">};</span>
  <span class="s2">ssrFormState.queue = JSCompiler_inline_result;</span>
  <span class="s2">ssrFormState = dispatchSetState.bind(</span>
    <span class="s4">null</span><span class="s2">,</span>
    <span class="s2">currentlyRenderingFiber,</span>
    <span class="s2">JSCompiler_inline_result</span>
  <span class="s2">);</span>
  <span class="s2">JSCompiler_inline_result.dispatch = ssrFormState;</span>
  <span class="s2">JSCompiler_inline_result = mountStateImpl(!</span><span class="s5">1</span><span class="s2">);</span>
  <span class="s2">inRootOrSingleton = dispatchOptimisticSetState.bind(</span>
    <span class="s4">null</span><span class="s2">,</span>
    <span class="s2">currentlyRenderingFiber,</span>
    <span class="s2">!</span><span class="s5">1</span><span class="s2">,</span>
    <span class="s2">JSCompiler_inline_result.queue</span>
  <span class="s2">);</span>
  <span class="s2">JSCompiler_inline_result = mountWorkInProgressHook();</span>
  <span class="s2">JSCompiler_inline_result$jscomp$0 = {</span>
    <span class="s2">state: initialStateProp,</span>
    <span class="s2">dispatch: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">action: action,</span>
    <span class="s2">pending: </span><span class="s4">null</span>
  <span class="s2">};</span>
  <span class="s2">JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;</span>
  <span class="s2">ssrFormState = dispatchActionState.bind(</span>
    <span class="s4">null</span><span class="s2">,</span>
    <span class="s2">currentlyRenderingFiber,</span>
    <span class="s2">JSCompiler_inline_result$jscomp$0,</span>
    <span class="s2">inRootOrSingleton,</span>
    <span class="s2">ssrFormState</span>
  <span class="s2">);</span>
  <span class="s2">JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;</span>
  <span class="s2">JSCompiler_inline_result.memoizedState = action;</span>
  <span class="s4">return </span><span class="s2">[initialStateProp, ssrFormState, !</span><span class="s5">1</span><span class="s2">];</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateActionState(action) {</span>
  <span class="s4">var </span><span class="s2">stateHook = updateWorkInProgressHook();</span>
  <span class="s4">return </span><span class="s2">updateActionStateImpl(stateHook, currentHook, action);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateActionStateImpl(stateHook, currentStateHook, action) {</span>
  <span class="s2">currentStateHook = updateReducerImpl(</span>
    <span class="s2">stateHook,</span>
    <span class="s2">currentStateHook,</span>
    <span class="s2">actionStateReducer</span>
  <span class="s2">)[</span><span class="s5">0</span><span class="s2">];</span>
  <span class="s2">stateHook = updateReducer(basicStateReducer)[</span><span class="s5">0</span><span class="s2">];</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">currentStateHook &amp;&amp;</span>
    <span class="s4">null </span><span class="s2">!== currentStateHook &amp;&amp;</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">currentStateHook.then</span>
  <span class="s2">)</span>
    <span class="s4">try </span><span class="s2">{</span>
      <span class="s4">var </span><span class="s2">state = useThenable(currentStateHook);</span>
    <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
      <span class="s4">if </span><span class="s2">(x === SuspenseException) </span><span class="s4">throw </span><span class="s2">SuspenseActionException;</span>
      <span class="s4">throw </span><span class="s2">x;</span>
    <span class="s2">}</span>
  <span class="s4">else </span><span class="s2">state = currentStateHook;</span>
  <span class="s2">currentStateHook = updateWorkInProgressHook();</span>
  <span class="s4">var </span><span class="s2">actionQueue = currentStateHook.queue,</span>
    <span class="s2">dispatch = actionQueue.dispatch;</span>
  <span class="s2">action !== currentStateHook.memoizedState &amp;&amp;</span>
    <span class="s2">((currentlyRenderingFiber.flags |= </span><span class="s5">2048</span><span class="s2">),</span>
    <span class="s2">pushSimpleEffect(</span>
      <span class="s5">9</span><span class="s2">,</span>
      <span class="s2">createEffectInstance(),</span>
      <span class="s2">actionStateActionEffect.bind(</span><span class="s4">null</span><span class="s2">, actionQueue, action),</span>
      <span class="s4">null</span>
    <span class="s2">));</span>
  <span class="s4">return </span><span class="s2">[state, dispatch, stateHook];</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">actionStateActionEffect(actionQueue, action) {</span>
  <span class="s2">actionQueue.action = action;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">rerenderActionState(action) {</span>
  <span class="s4">var </span><span class="s2">stateHook = updateWorkInProgressHook(),</span>
    <span class="s2">currentStateHook = currentHook;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== currentStateHook)</span>
    <span class="s4">return </span><span class="s2">updateActionStateImpl(stateHook, currentStateHook, action);</span>
  <span class="s2">updateWorkInProgressHook();</span>
  <span class="s2">stateHook = stateHook.memoizedState;</span>
  <span class="s2">currentStateHook = updateWorkInProgressHook();</span>
  <span class="s4">var </span><span class="s2">dispatch = currentStateHook.queue.dispatch;</span>
  <span class="s2">currentStateHook.memoizedState = action;</span>
  <span class="s4">return </span><span class="s2">[stateHook, dispatch, !</span><span class="s5">1</span><span class="s2">];</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">pushSimpleEffect(tag, inst, create, createDeps) {</span>
  <span class="s2">tag = { tag: tag, create: create, deps: createDeps, inst: inst, next: </span><span class="s4">null </span><span class="s2">};</span>
  <span class="s2">inst = currentlyRenderingFiber.updateQueue;</span>
  <span class="s4">null </span><span class="s2">=== inst &amp;&amp;</span>
    <span class="s2">((inst = createFunctionComponentUpdateQueue()),</span>
    <span class="s2">(currentlyRenderingFiber.updateQueue = inst));</span>
  <span class="s2">create = inst.lastEffect;</span>
  <span class="s4">null </span><span class="s2">=== create</span>
    <span class="s2">? (inst.lastEffect = tag.next = tag)</span>
    <span class="s2">: ((createDeps = create.next),</span>
      <span class="s2">(create.next = tag),</span>
      <span class="s2">(tag.next = createDeps),</span>
      <span class="s2">(inst.lastEffect = tag));</span>
  <span class="s4">return </span><span class="s2">tag;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createEffectInstance() {</span>
  <span class="s4">return </span><span class="s2">{ destroy: </span><span class="s4">void </span><span class="s5">0</span><span class="s2">, resource: </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">};</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateRef() {</span>
  <span class="s4">return </span><span class="s2">updateWorkInProgressHook().memoizedState;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {</span>
  <span class="s4">var </span><span class="s2">hook = mountWorkInProgressHook();</span>
  <span class="s2">createDeps = </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== createDeps ? </span><span class="s4">null </span><span class="s2">: createDeps;</span>
  <span class="s2">currentlyRenderingFiber.flags |= fiberFlags;</span>
  <span class="s2">hook.memoizedState = pushSimpleEffect(</span>
    <span class="s5">1 </span><span class="s2">| hookFlags,</span>
    <span class="s2">createEffectInstance(),</span>
    <span class="s2">create,</span>
    <span class="s2">createDeps</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateEffectImpl(fiberFlags, hookFlags, create, deps) {</span>
  <span class="s4">var </span><span class="s2">hook = updateWorkInProgressHook();</span>
  <span class="s2">deps = </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== deps ? </span><span class="s4">null </span><span class="s2">: deps;</span>
  <span class="s4">var </span><span class="s2">inst = hook.memoizedState.inst;</span>
  <span class="s4">null </span><span class="s2">!== currentHook &amp;&amp;</span>
  <span class="s4">null </span><span class="s2">!== deps &amp;&amp;</span>
  <span class="s2">areHookInputsEqual(deps, currentHook.memoizedState.deps)</span>
    <span class="s2">? (hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps))</span>
    <span class="s2">: ((currentlyRenderingFiber.flags |= fiberFlags),</span>
      <span class="s2">(hook.memoizedState = pushSimpleEffect(</span>
        <span class="s5">1 </span><span class="s2">| hookFlags,</span>
        <span class="s2">inst,</span>
        <span class="s2">create,</span>
        <span class="s2">deps</span>
      <span class="s2">)));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">mountEffect(create, createDeps) {</span>
  <span class="s2">mountEffectImpl(</span><span class="s5">8390656</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, create, createDeps);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateEffect(create, createDeps) {</span>
  <span class="s2">updateEffectImpl(</span><span class="s5">2048</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, create, createDeps);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateInsertionEffect(create, deps) {</span>
  <span class="s4">return </span><span class="s2">updateEffectImpl(</span><span class="s5">4</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, create, deps);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateLayoutEffect(create, deps) {</span>
  <span class="s4">return </span><span class="s2">updateEffectImpl(</span><span class="s5">4</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, create, deps);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">imperativeHandleEffect(create, ref) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">ref) {</span>
    <span class="s2">create = create();</span>
    <span class="s4">var </span><span class="s2">refCleanup = ref(create);</span>
    <span class="s4">return function </span><span class="s2">() {</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">refCleanup ? refCleanup() : ref(</span><span class="s4">null</span><span class="s2">);</span>
    <span class="s2">};</span>
  <span class="s2">}</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== ref &amp;&amp; </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== ref)</span>
    <span class="s4">return </span><span class="s2">(</span>
      <span class="s2">(create = create()),</span>
      <span class="s2">(ref.current = create),</span>
      <span class="s4">function </span><span class="s2">() {</span>
        <span class="s2">ref.current = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">}</span>
    <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateImperativeHandle(ref, create, deps) {</span>
  <span class="s2">deps = </span><span class="s4">null </span><span class="s2">!== deps &amp;&amp; </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== deps ? deps.concat([ref]) : </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">updateEffectImpl(</span><span class="s5">4</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, imperativeHandleEffect.bind(</span><span class="s4">null</span><span class="s2">, create, ref), deps);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">mountDebugValue() {}</span>
<span class="s4">function </span><span class="s2">updateCallback(callback, deps) {</span>
  <span class="s4">var </span><span class="s2">hook = updateWorkInProgressHook();</span>
  <span class="s2">deps = </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== deps ? </span><span class="s4">null </span><span class="s2">: deps;</span>
  <span class="s4">var </span><span class="s2">prevState = hook.memoizedState;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== deps &amp;&amp; areHookInputsEqual(deps, prevState[</span><span class="s5">1</span><span class="s2">]))</span>
    <span class="s4">return </span><span class="s2">prevState[</span><span class="s5">0</span><span class="s2">];</span>
  <span class="s2">hook.memoizedState = [callback, deps];</span>
  <span class="s4">return </span><span class="s2">callback;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateMemo(nextCreate, deps) {</span>
  <span class="s4">var </span><span class="s2">hook = updateWorkInProgressHook();</span>
  <span class="s2">deps = </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== deps ? </span><span class="s4">null </span><span class="s2">: deps;</span>
  <span class="s4">var </span><span class="s2">prevState = hook.memoizedState;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== deps &amp;&amp; areHookInputsEqual(deps, prevState[</span><span class="s5">1</span><span class="s2">]))</span>
    <span class="s4">return </span><span class="s2">prevState[</span><span class="s5">0</span><span class="s2">];</span>
  <span class="s2">prevState = nextCreate();</span>
  <span class="s4">if </span><span class="s2">(shouldDoubleInvokeUserFnsInHooksDEV) {</span>
    <span class="s2">setIsStrictModeForDevtools(!</span><span class="s5">0</span><span class="s2">);</span>
    <span class="s4">try </span><span class="s2">{</span>
      <span class="s2">nextCreate();</span>
    <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
      <span class="s2">setIsStrictModeForDevtools(!</span><span class="s5">1</span><span class="s2">);</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s2">hook.memoizedState = [prevState, deps];</span>
  <span class="s4">return </span><span class="s2">prevState;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">mountDeferredValueImpl(hook, value, initialValue) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== initialValue || </span><span class="s5">0 </span><span class="s2">!== (renderLanes &amp; </span><span class="s5">1073741824</span><span class="s2">))</span>
    <span class="s4">return </span><span class="s2">(hook.memoizedState = value);</span>
  <span class="s2">hook.memoizedState = initialValue;</span>
  <span class="s2">hook = requestDeferredLane();</span>
  <span class="s2">currentlyRenderingFiber.lanes |= hook;</span>
  <span class="s2">workInProgressRootSkippedLanes |= hook;</span>
  <span class="s4">return </span><span class="s2">initialValue;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateDeferredValueImpl(hook, prevValue, value, initialValue) {</span>
  <span class="s4">if </span><span class="s2">(objectIs(value, prevValue)) </span><span class="s4">return </span><span class="s2">value;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== currentTreeHiddenStackCursor.current)</span>
    <span class="s4">return </span><span class="s2">(</span>
      <span class="s2">(hook = mountDeferredValueImpl(hook, value, initialValue)),</span>
      <span class="s2">objectIs(hook, prevValue) || (didReceiveUpdate = !</span><span class="s5">0</span><span class="s2">),</span>
      <span class="s2">hook</span>
    <span class="s2">);</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== (renderLanes &amp; </span><span class="s5">42</span><span class="s2">))</span>
    <span class="s4">return </span><span class="s2">(didReceiveUpdate = !</span><span class="s5">0</span><span class="s2">), (hook.memoizedState = value);</span>
  <span class="s2">hook = requestDeferredLane();</span>
  <span class="s2">currentlyRenderingFiber.lanes |= hook;</span>
  <span class="s2">workInProgressRootSkippedLanes |= hook;</span>
  <span class="s4">return </span><span class="s2">prevValue;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">startTransition(fiber, queue, pendingState, finishedState, callback) {</span>
  <span class="s4">var </span><span class="s2">previousPriority = ReactDOMSharedInternals.p;</span>
  <span class="s2">ReactDOMSharedInternals.p =</span>
    <span class="s5">0 </span><span class="s2">!== previousPriority &amp;&amp; </span><span class="s5">8 </span><span class="s2">&gt; previousPriority ? previousPriority : </span><span class="s5">8</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">prevTransition = ReactSharedInternals.T,</span>
    <span class="s2">currentTransition = {};</span>
  <span class="s2">ReactSharedInternals.T = currentTransition;</span>
  <span class="s2">dispatchOptimisticSetState(fiber, !</span><span class="s5">1</span><span class="s2">, queue, pendingState);</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">returnValue = callback(),</span>
      <span class="s2">onStartTransitionFinish = ReactSharedInternals.S;</span>
    <span class="s4">null </span><span class="s2">!== onStartTransitionFinish &amp;&amp;</span>
      <span class="s2">onStartTransitionFinish(currentTransition, returnValue);</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s4">null </span><span class="s2">!== returnValue &amp;&amp;</span>
      <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">returnValue &amp;&amp;</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">returnValue.then</span>
    <span class="s2">) {</span>
      <span class="s4">var </span><span class="s2">thenableForFinishedState = chainThenableValue(</span>
        <span class="s2">returnValue,</span>
        <span class="s2">finishedState</span>
      <span class="s2">);</span>
      <span class="s2">dispatchSetStateInternal(</span>
        <span class="s2">fiber,</span>
        <span class="s2">queue,</span>
        <span class="s2">thenableForFinishedState,</span>
        <span class="s2">requestUpdateLane(fiber)</span>
      <span class="s2">);</span>
    <span class="s2">} </span><span class="s4">else</span>
      <span class="s2">dispatchSetStateInternal(</span>
        <span class="s2">fiber,</span>
        <span class="s2">queue,</span>
        <span class="s2">finishedState,</span>
        <span class="s2">requestUpdateLane(fiber)</span>
      <span class="s2">);</span>
  <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
    <span class="s2">dispatchSetStateInternal(</span>
      <span class="s2">fiber,</span>
      <span class="s2">queue,</span>
      <span class="s2">{ then: </span><span class="s4">function </span><span class="s2">() {}, status: </span><span class="s3">&quot;rejected&quot;</span><span class="s2">, reason: error },</span>
      <span class="s2">requestUpdateLane()</span>
    <span class="s2">);</span>
  <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
    <span class="s2">(ReactDOMSharedInternals.p = previousPriority),</span>
      <span class="s2">(ReactSharedInternals.T = prevTransition);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">noop$3() {}</span>
<span class="s4">function </span><span class="s2">startHostTransition(formFiber, pendingState, action, formData) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">5 </span><span class="s2">!== formFiber.tag) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">476</span><span class="s2">));</span>
  <span class="s4">var </span><span class="s2">queue = ensureFormComponentIsStateful(formFiber).queue;</span>
  <span class="s2">startTransition(</span>
    <span class="s2">formFiber,</span>
    <span class="s2">queue,</span>
    <span class="s2">pendingState,</span>
    <span class="s2">sharedNotPendingObject,</span>
    <span class="s4">null </span><span class="s2">=== action</span>
      <span class="s2">? noop$3</span>
      <span class="s2">: </span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s2">requestFormReset$2(formFiber);</span>
          <span class="s4">return </span><span class="s2">action(formData);</span>
        <span class="s2">}</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">ensureFormComponentIsStateful(formFiber) {</span>
  <span class="s4">var </span><span class="s2">existingStateHook = formFiber.memoizedState;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== existingStateHook) </span><span class="s4">return </span><span class="s2">existingStateHook;</span>
  <span class="s2">existingStateHook = {</span>
    <span class="s2">memoizedState: sharedNotPendingObject,</span>
    <span class="s2">baseState: sharedNotPendingObject,</span>
    <span class="s2">baseQueue: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">queue: {</span>
      <span class="s2">pending: </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">lanes: </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">dispatch: </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">lastRenderedReducer: basicStateReducer,</span>
      <span class="s2">lastRenderedState: sharedNotPendingObject</span>
    <span class="s2">},</span>
    <span class="s2">next: </span><span class="s4">null</span>
  <span class="s2">};</span>
  <span class="s4">var </span><span class="s2">initialResetState = {};</span>
  <span class="s2">existingStateHook.next = {</span>
    <span class="s2">memoizedState: initialResetState,</span>
    <span class="s2">baseState: initialResetState,</span>
    <span class="s2">baseQueue: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">queue: {</span>
      <span class="s2">pending: </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">lanes: </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">dispatch: </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">lastRenderedReducer: basicStateReducer,</span>
      <span class="s2">lastRenderedState: initialResetState</span>
    <span class="s2">},</span>
    <span class="s2">next: </span><span class="s4">null</span>
  <span class="s2">};</span>
  <span class="s2">formFiber.memoizedState = existingStateHook;</span>
  <span class="s2">formFiber = formFiber.alternate;</span>
  <span class="s4">null </span><span class="s2">!== formFiber &amp;&amp; (formFiber.memoizedState = existingStateHook);</span>
  <span class="s4">return </span><span class="s2">existingStateHook;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">requestFormReset$2(formFiber) {</span>
  <span class="s4">var </span><span class="s2">resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;</span>
  <span class="s2">dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">useHostTransitionStatus() {</span>
  <span class="s4">return </span><span class="s2">readContext(HostTransitionContext);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateId() {</span>
  <span class="s4">return </span><span class="s2">updateWorkInProgressHook().memoizedState;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateRefresh() {</span>
  <span class="s4">return </span><span class="s2">updateWorkInProgressHook().memoizedState;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">refreshCache(fiber) {</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">provider = fiber.return; </span><span class="s4">null </span><span class="s2">!== provider; ) {</span>
    <span class="s4">switch </span><span class="s2">(provider.tag) {</span>
      <span class="s4">case </span><span class="s5">24</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
        <span class="s4">var </span><span class="s2">lane = requestUpdateLane();</span>
        <span class="s2">fiber = createUpdate(lane);</span>
        <span class="s4">var </span><span class="s2">root$43 = enqueueUpdate(provider, fiber, lane);</span>
        <span class="s4">null </span><span class="s2">!== root$43 &amp;&amp;</span>
          <span class="s2">(scheduleUpdateOnFiber(root$43, provider, lane),</span>
          <span class="s2">entangleTransitions(root$43, provider, lane));</span>
        <span class="s2">provider = { cache: createCache() };</span>
        <span class="s2">fiber.payload = provider;</span>
        <span class="s4">return</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s2">provider = provider.return;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">dispatchReducerAction(fiber, queue, action) {</span>
  <span class="s4">var </span><span class="s2">lane = requestUpdateLane();</span>
  <span class="s2">action = {</span>
    <span class="s2">lane: lane,</span>
    <span class="s2">revertLane: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">action: action,</span>
    <span class="s2">hasEagerState: !</span><span class="s5">1</span><span class="s2">,</span>
    <span class="s2">eagerState: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">next: </span><span class="s4">null</span>
  <span class="s2">};</span>
  <span class="s2">isRenderPhaseUpdate(fiber)</span>
    <span class="s2">? enqueueRenderPhaseUpdate(queue, action)</span>
    <span class="s2">: ((action = enqueueConcurrentHookUpdate(fiber, queue, action, lane)),</span>
      <span class="s4">null </span><span class="s2">!== action &amp;&amp;</span>
        <span class="s2">(scheduleUpdateOnFiber(action, fiber, lane),</span>
        <span class="s2">entangleTransitionUpdate(action, queue, lane)));</span>
  <span class="s2">markStateUpdateScheduled(fiber, lane);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">dispatchSetState(fiber, queue, action) {</span>
  <span class="s4">var </span><span class="s2">lane = requestUpdateLane();</span>
  <span class="s2">dispatchSetStateInternal(fiber, queue, action, lane);</span>
  <span class="s2">markStateUpdateScheduled(fiber, lane);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">dispatchSetStateInternal(fiber, queue, action, lane) {</span>
  <span class="s4">var </span><span class="s2">update = {</span>
    <span class="s2">lane: lane,</span>
    <span class="s2">revertLane: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">action: action,</span>
    <span class="s2">hasEagerState: !</span><span class="s5">1</span><span class="s2">,</span>
    <span class="s2">eagerState: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">next: </span><span class="s4">null</span>
  <span class="s2">};</span>
  <span class="s4">if </span><span class="s2">(isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);</span>
  <span class="s4">else </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">alternate = fiber.alternate;</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s5">0 </span><span class="s2">=== fiber.lanes &amp;&amp;</span>
      <span class="s2">(</span><span class="s4">null </span><span class="s2">=== alternate || </span><span class="s5">0 </span><span class="s2">=== alternate.lanes) &amp;&amp;</span>
      <span class="s2">((alternate = queue.lastRenderedReducer), </span><span class="s4">null </span><span class="s2">!== alternate)</span>
    <span class="s2">)</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">currentState = queue.lastRenderedState,</span>
          <span class="s2">eagerState = alternate(currentState, action);</span>
        <span class="s2">update.hasEagerState = !</span><span class="s5">0</span><span class="s2">;</span>
        <span class="s2">update.eagerState = eagerState;</span>
        <span class="s4">if </span><span class="s2">(objectIs(eagerState, currentState))</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s2">enqueueUpdate$1(fiber, queue, update, </span><span class="s5">0</span><span class="s2">),</span>
            <span class="s4">null </span><span class="s2">=== workInProgressRoot &amp;&amp; finishQueueingConcurrentUpdates(),</span>
            <span class="s2">!</span><span class="s5">1</span>
          <span class="s2">);</span>
      <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
      <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
      <span class="s2">}</span>
    <span class="s2">action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== action)</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">scheduleUpdateOnFiber(action, fiber, lane),</span>
        <span class="s2">entangleTransitionUpdate(action, queue, lane),</span>
        <span class="s2">!</span><span class="s5">0</span>
      <span class="s2">);</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {</span>
  <span class="s2">action = {</span>
    <span class="s2">lane: </span><span class="s5">2</span><span class="s2">,</span>
    <span class="s2">revertLane: requestTransitionLane(),</span>
    <span class="s2">action: action,</span>
    <span class="s2">hasEagerState: !</span><span class="s5">1</span><span class="s2">,</span>
    <span class="s2">eagerState: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">next: </span><span class="s4">null</span>
  <span class="s2">};</span>
  <span class="s4">if </span><span class="s2">(isRenderPhaseUpdate(fiber)) {</span>
    <span class="s4">if </span><span class="s2">(throwIfDuringRender) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">479</span><span class="s2">));</span>
  <span class="s2">} </span><span class="s4">else</span>
    <span class="s2">(throwIfDuringRender = enqueueConcurrentHookUpdate(</span>
      <span class="s2">fiber,</span>
      <span class="s2">queue,</span>
      <span class="s2">action,</span>
      <span class="s5">2</span>
    <span class="s2">)),</span>
      <span class="s4">null </span><span class="s2">!== throwIfDuringRender &amp;&amp;</span>
        <span class="s2">scheduleUpdateOnFiber(throwIfDuringRender, fiber, </span><span class="s5">2</span><span class="s2">);</span>
  <span class="s2">markStateUpdateScheduled(fiber, </span><span class="s5">2</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">isRenderPhaseUpdate(fiber) {</span>
  <span class="s4">var </span><span class="s2">alternate = fiber.alternate;</span>
  <span class="s4">return </span><span class="s2">(</span>
    <span class="s2">fiber === currentlyRenderingFiber ||</span>
    <span class="s2">(</span><span class="s4">null </span><span class="s2">!== alternate &amp;&amp; alternate === currentlyRenderingFiber)</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">enqueueRenderPhaseUpdate(queue, update) {</span>
  <span class="s2">didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate =</span>
    <span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">pending = queue.pending;</span>
  <span class="s4">null </span><span class="s2">=== pending</span>
    <span class="s2">? (update.next = update)</span>
    <span class="s2">: ((update.next = pending.next), (pending.next = update));</span>
  <span class="s2">queue.pending = update;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">entangleTransitionUpdate(root, queue, lane) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (lane &amp; </span><span class="s5">4194048</span><span class="s2">)) {</span>
    <span class="s4">var </span><span class="s2">queueLanes = queue.lanes;</span>
    <span class="s2">queueLanes &amp;= root.pendingLanes;</span>
    <span class="s2">lane |= queueLanes;</span>
    <span class="s2">queue.lanes = lane;</span>
    <span class="s2">markRootEntangled(root, lane);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">ContextOnlyDispatcher = {</span>
    <span class="s2">readContext: readContext,</span>
    <span class="s2">use: use,</span>
    <span class="s2">useCallback: throwInvalidHookError,</span>
    <span class="s2">useContext: throwInvalidHookError,</span>
    <span class="s2">useEffect: throwInvalidHookError,</span>
    <span class="s2">useImperativeHandle: throwInvalidHookError,</span>
    <span class="s2">useLayoutEffect: throwInvalidHookError,</span>
    <span class="s2">useInsertionEffect: throwInvalidHookError,</span>
    <span class="s2">useMemo: throwInvalidHookError,</span>
    <span class="s2">useReducer: throwInvalidHookError,</span>
    <span class="s2">useRef: throwInvalidHookError,</span>
    <span class="s2">useState: throwInvalidHookError,</span>
    <span class="s2">useDebugValue: throwInvalidHookError,</span>
    <span class="s2">useDeferredValue: throwInvalidHookError,</span>
    <span class="s2">useTransition: throwInvalidHookError,</span>
    <span class="s2">useSyncExternalStore: throwInvalidHookError,</span>
    <span class="s2">useId: throwInvalidHookError,</span>
    <span class="s2">useHostTransitionStatus: throwInvalidHookError,</span>
    <span class="s2">useFormState: throwInvalidHookError,</span>
    <span class="s2">useActionState: throwInvalidHookError,</span>
    <span class="s2">useOptimistic: throwInvalidHookError,</span>
    <span class="s2">useMemoCache: throwInvalidHookError,</span>
    <span class="s2">useCacheRefresh: throwInvalidHookError</span>
  <span class="s2">},</span>
  <span class="s2">HooksDispatcherOnMount = {</span>
    <span class="s2">readContext: readContext,</span>
    <span class="s2">use: use,</span>
    <span class="s2">useCallback: </span><span class="s4">function </span><span class="s2">(callback, deps) {</span>
      <span class="s2">mountWorkInProgressHook().memoizedState = [</span>
        <span class="s2">callback,</span>
        <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== deps ? </span><span class="s4">null </span><span class="s2">: deps</span>
      <span class="s2">];</span>
      <span class="s4">return </span><span class="s2">callback;</span>
    <span class="s2">},</span>
    <span class="s2">useContext: readContext,</span>
    <span class="s2">useEffect: mountEffect,</span>
    <span class="s2">useImperativeHandle: </span><span class="s4">function </span><span class="s2">(ref, create, deps) {</span>
      <span class="s2">deps = </span><span class="s4">null </span><span class="s2">!== deps &amp;&amp; </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== deps ? deps.concat([ref]) : </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">mountEffectImpl(</span>
        <span class="s5">4194308</span><span class="s2">,</span>
        <span class="s5">4</span><span class="s2">,</span>
        <span class="s2">imperativeHandleEffect.bind(</span><span class="s4">null</span><span class="s2">, create, ref),</span>
        <span class="s2">deps</span>
      <span class="s2">);</span>
    <span class="s2">},</span>
    <span class="s2">useLayoutEffect: </span><span class="s4">function </span><span class="s2">(create, deps) {</span>
      <span class="s4">return </span><span class="s2">mountEffectImpl(</span><span class="s5">4194308</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, create, deps);</span>
    <span class="s2">},</span>
    <span class="s2">useInsertionEffect: </span><span class="s4">function </span><span class="s2">(create, deps) {</span>
      <span class="s2">mountEffectImpl(</span><span class="s5">4</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, create, deps);</span>
    <span class="s2">},</span>
    <span class="s2">useMemo: </span><span class="s4">function </span><span class="s2">(nextCreate, deps) {</span>
      <span class="s4">var </span><span class="s2">hook = mountWorkInProgressHook();</span>
      <span class="s2">deps = </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== deps ? </span><span class="s4">null </span><span class="s2">: deps;</span>
      <span class="s4">var </span><span class="s2">nextValue = nextCreate();</span>
      <span class="s4">if </span><span class="s2">(shouldDoubleInvokeUserFnsInHooksDEV) {</span>
        <span class="s2">setIsStrictModeForDevtools(!</span><span class="s5">0</span><span class="s2">);</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s2">nextCreate();</span>
        <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
          <span class="s2">setIsStrictModeForDevtools(!</span><span class="s5">1</span><span class="s2">);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s2">hook.memoizedState = [nextValue, deps];</span>
      <span class="s4">return </span><span class="s2">nextValue;</span>
    <span class="s2">},</span>
    <span class="s2">useReducer: </span><span class="s4">function </span><span class="s2">(reducer, initialArg, init) {</span>
      <span class="s4">var </span><span class="s2">hook = mountWorkInProgressHook();</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== init) {</span>
        <span class="s4">var </span><span class="s2">initialState = init(initialArg);</span>
        <span class="s4">if </span><span class="s2">(shouldDoubleInvokeUserFnsInHooksDEV) {</span>
          <span class="s2">setIsStrictModeForDevtools(!</span><span class="s5">0</span><span class="s2">);</span>
          <span class="s4">try </span><span class="s2">{</span>
            <span class="s2">init(initialArg);</span>
          <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
            <span class="s2">setIsStrictModeForDevtools(!</span><span class="s5">1</span><span class="s2">);</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
      <span class="s2">} </span><span class="s4">else </span><span class="s2">initialState = initialArg;</span>
      <span class="s2">hook.memoizedState = hook.baseState = initialState;</span>
      <span class="s2">reducer = {</span>
        <span class="s2">pending: </span><span class="s4">null</span><span class="s2">,</span>
        <span class="s2">lanes: </span><span class="s5">0</span><span class="s2">,</span>
        <span class="s2">dispatch: </span><span class="s4">null</span><span class="s2">,</span>
        <span class="s2">lastRenderedReducer: reducer,</span>
        <span class="s2">lastRenderedState: initialState</span>
      <span class="s2">};</span>
      <span class="s2">hook.queue = reducer;</span>
      <span class="s2">reducer = reducer.dispatch = dispatchReducerAction.bind(</span>
        <span class="s4">null</span><span class="s2">,</span>
        <span class="s2">currentlyRenderingFiber,</span>
        <span class="s2">reducer</span>
      <span class="s2">);</span>
      <span class="s4">return </span><span class="s2">[hook.memoizedState, reducer];</span>
    <span class="s2">},</span>
    <span class="s2">useRef: </span><span class="s4">function </span><span class="s2">(initialValue) {</span>
      <span class="s4">var </span><span class="s2">hook = mountWorkInProgressHook();</span>
      <span class="s2">initialValue = { current: initialValue };</span>
      <span class="s4">return </span><span class="s2">(hook.memoizedState = initialValue);</span>
    <span class="s2">},</span>
    <span class="s2">useState: </span><span class="s4">function </span><span class="s2">(initialState) {</span>
      <span class="s2">initialState = mountStateImpl(initialState);</span>
      <span class="s4">var </span><span class="s2">queue = initialState.queue,</span>
        <span class="s2">dispatch = dispatchSetState.bind(</span><span class="s4">null</span><span class="s2">, currentlyRenderingFiber, queue);</span>
      <span class="s2">queue.dispatch = dispatch;</span>
      <span class="s4">return </span><span class="s2">[initialState.memoizedState, dispatch];</span>
    <span class="s2">},</span>
    <span class="s2">useDebugValue: mountDebugValue,</span>
    <span class="s2">useDeferredValue: </span><span class="s4">function </span><span class="s2">(value, initialValue) {</span>
      <span class="s4">var </span><span class="s2">hook = mountWorkInProgressHook();</span>
      <span class="s4">return </span><span class="s2">mountDeferredValueImpl(hook, value, initialValue);</span>
    <span class="s2">},</span>
    <span class="s2">useTransition: </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">var </span><span class="s2">stateHook = mountStateImpl(!</span><span class="s5">1</span><span class="s2">);</span>
      <span class="s2">stateHook = startTransition.bind(</span>
        <span class="s4">null</span><span class="s2">,</span>
        <span class="s2">currentlyRenderingFiber,</span>
        <span class="s2">stateHook.queue,</span>
        <span class="s2">!</span><span class="s5">0</span><span class="s2">,</span>
        <span class="s2">!</span><span class="s5">1</span>
      <span class="s2">);</span>
      <span class="s2">mountWorkInProgressHook().memoizedState = stateHook;</span>
      <span class="s4">return </span><span class="s2">[!</span><span class="s5">1</span><span class="s2">, stateHook];</span>
    <span class="s2">},</span>
    <span class="s2">useSyncExternalStore: </span><span class="s4">function </span><span class="s2">(subscribe, getSnapshot, getServerSnapshot) {</span>
      <span class="s4">var </span><span class="s2">fiber = currentlyRenderingFiber,</span>
        <span class="s2">hook = mountWorkInProgressHook();</span>
      <span class="s4">if </span><span class="s2">(isHydrating) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== getServerSnapshot)</span>
          <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">407</span><span class="s2">));</span>
        <span class="s2">getServerSnapshot = getServerSnapshot();</span>
      <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
        <span class="s2">getServerSnapshot = getSnapshot();</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== workInProgressRoot)</span>
          <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">349</span><span class="s2">));</span>
        <span class="s5">0 </span><span class="s2">!== (workInProgressRootRenderLanes &amp; </span><span class="s5">124</span><span class="s2">) ||</span>
          <span class="s2">pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);</span>
      <span class="s2">}</span>
      <span class="s2">hook.memoizedState = getServerSnapshot;</span>
      <span class="s4">var </span><span class="s2">inst = { value: getServerSnapshot, getSnapshot: getSnapshot };</span>
      <span class="s2">hook.queue = inst;</span>
      <span class="s2">mountEffect(subscribeToStore.bind(</span><span class="s4">null</span><span class="s2">, fiber, inst, subscribe), [</span>
        <span class="s2">subscribe</span>
      <span class="s2">]);</span>
      <span class="s2">fiber.flags |= </span><span class="s5">2048</span><span class="s2">;</span>
      <span class="s2">pushSimpleEffect(</span>
        <span class="s5">9</span><span class="s2">,</span>
        <span class="s2">createEffectInstance(),</span>
        <span class="s2">updateStoreInstance.bind(</span>
          <span class="s4">null</span><span class="s2">,</span>
          <span class="s2">fiber,</span>
          <span class="s2">inst,</span>
          <span class="s2">getServerSnapshot,</span>
          <span class="s2">getSnapshot</span>
        <span class="s2">),</span>
        <span class="s4">null</span>
      <span class="s2">);</span>
      <span class="s4">return </span><span class="s2">getServerSnapshot;</span>
    <span class="s2">},</span>
    <span class="s2">useId: </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">var </span><span class="s2">hook = mountWorkInProgressHook(),</span>
        <span class="s2">identifierPrefix = workInProgressRoot.identifierPrefix;</span>
      <span class="s4">if </span><span class="s2">(isHydrating) {</span>
        <span class="s4">var </span><span class="s2">JSCompiler_inline_result = treeContextOverflow;</span>
        <span class="s4">var </span><span class="s2">idWithLeadingBit = treeContextId;</span>
        <span class="s2">JSCompiler_inline_result =</span>
          <span class="s2">(</span>
            <span class="s2">idWithLeadingBit &amp; ~(</span><span class="s5">1 </span><span class="s2">&lt;&lt; (</span><span class="s5">32 </span><span class="s2">- clz32(idWithLeadingBit) - </span><span class="s5">1</span><span class="s2">))</span>
          <span class="s2">).toString(</span><span class="s5">32</span><span class="s2">) + JSCompiler_inline_result;</span>
        <span class="s2">identifierPrefix =</span>
          <span class="s3">&quot;</span><span class="s6">\u00ab</span><span class="s3">&quot; </span><span class="s2">+ identifierPrefix + </span><span class="s3">&quot;R&quot; </span><span class="s2">+ JSCompiler_inline_result;</span>
        <span class="s2">JSCompiler_inline_result = localIdCounter++;</span>
        <span class="s5">0 </span><span class="s2">&lt; JSCompiler_inline_result &amp;&amp;</span>
          <span class="s2">(identifierPrefix += </span><span class="s3">&quot;H&quot; </span><span class="s2">+ JSCompiler_inline_result.toString(</span><span class="s5">32</span><span class="s2">));</span>
        <span class="s2">identifierPrefix += </span><span class="s3">&quot;</span><span class="s6">\u00bb</span><span class="s3">&quot;</span><span class="s2">;</span>
      <span class="s2">} </span><span class="s4">else</span>
        <span class="s2">(JSCompiler_inline_result = globalClientIdCounter++),</span>
          <span class="s2">(identifierPrefix =</span>
            <span class="s3">&quot;</span><span class="s6">\u00ab</span><span class="s3">&quot; </span><span class="s2">+</span>
            <span class="s2">identifierPrefix +</span>
            <span class="s3">&quot;r&quot; </span><span class="s2">+</span>
            <span class="s2">JSCompiler_inline_result.toString(</span><span class="s5">32</span><span class="s2">) +</span>
            <span class="s3">&quot;</span><span class="s6">\u00bb</span><span class="s3">&quot;</span><span class="s2">);</span>
      <span class="s4">return </span><span class="s2">(hook.memoizedState = identifierPrefix);</span>
    <span class="s2">},</span>
    <span class="s2">useHostTransitionStatus: useHostTransitionStatus,</span>
    <span class="s2">useFormState: mountActionState,</span>
    <span class="s2">useActionState: mountActionState,</span>
    <span class="s2">useOptimistic: </span><span class="s4">function </span><span class="s2">(passthrough) {</span>
      <span class="s4">var </span><span class="s2">hook = mountWorkInProgressHook();</span>
      <span class="s2">hook.memoizedState = hook.baseState = passthrough;</span>
      <span class="s4">var </span><span class="s2">queue = {</span>
        <span class="s2">pending: </span><span class="s4">null</span><span class="s2">,</span>
        <span class="s2">lanes: </span><span class="s5">0</span><span class="s2">,</span>
        <span class="s2">dispatch: </span><span class="s4">null</span><span class="s2">,</span>
        <span class="s2">lastRenderedReducer: </span><span class="s4">null</span><span class="s2">,</span>
        <span class="s2">lastRenderedState: </span><span class="s4">null</span>
      <span class="s2">};</span>
      <span class="s2">hook.queue = queue;</span>
      <span class="s2">hook = dispatchOptimisticSetState.bind(</span>
        <span class="s4">null</span><span class="s2">,</span>
        <span class="s2">currentlyRenderingFiber,</span>
        <span class="s2">!</span><span class="s5">0</span><span class="s2">,</span>
        <span class="s2">queue</span>
      <span class="s2">);</span>
      <span class="s2">queue.dispatch = hook;</span>
      <span class="s4">return </span><span class="s2">[passthrough, hook];</span>
    <span class="s2">},</span>
    <span class="s2">useMemoCache: useMemoCache,</span>
    <span class="s2">useCacheRefresh: </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">return </span><span class="s2">(mountWorkInProgressHook().memoizedState = refreshCache.bind(</span>
        <span class="s4">null</span><span class="s2">,</span>
        <span class="s2">currentlyRenderingFiber</span>
      <span class="s2">));</span>
    <span class="s2">}</span>
  <span class="s2">},</span>
  <span class="s2">HooksDispatcherOnUpdate = {</span>
    <span class="s2">readContext: readContext,</span>
    <span class="s2">use: use,</span>
    <span class="s2">useCallback: updateCallback,</span>
    <span class="s2">useContext: readContext,</span>
    <span class="s2">useEffect: updateEffect,</span>
    <span class="s2">useImperativeHandle: updateImperativeHandle,</span>
    <span class="s2">useInsertionEffect: updateInsertionEffect,</span>
    <span class="s2">useLayoutEffect: updateLayoutEffect,</span>
    <span class="s2">useMemo: updateMemo,</span>
    <span class="s2">useReducer: updateReducer,</span>
    <span class="s2">useRef: updateRef,</span>
    <span class="s2">useState: </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">return </span><span class="s2">updateReducer(basicStateReducer);</span>
    <span class="s2">},</span>
    <span class="s2">useDebugValue: mountDebugValue,</span>
    <span class="s2">useDeferredValue: </span><span class="s4">function </span><span class="s2">(value, initialValue) {</span>
      <span class="s4">var </span><span class="s2">hook = updateWorkInProgressHook();</span>
      <span class="s4">return </span><span class="s2">updateDeferredValueImpl(</span>
        <span class="s2">hook,</span>
        <span class="s2">currentHook.memoizedState,</span>
        <span class="s2">value,</span>
        <span class="s2">initialValue</span>
      <span class="s2">);</span>
    <span class="s2">},</span>
    <span class="s2">useTransition: </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">var </span><span class="s2">booleanOrThenable = updateReducer(basicStateReducer)[</span><span class="s5">0</span><span class="s2">],</span>
        <span class="s2">start = updateWorkInProgressHook().memoizedState;</span>
      <span class="s4">return </span><span class="s2">[</span>
        <span class="s3">&quot;boolean&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">booleanOrThenable</span>
          <span class="s2">? booleanOrThenable</span>
          <span class="s2">: useThenable(booleanOrThenable),</span>
        <span class="s2">start</span>
      <span class="s2">];</span>
    <span class="s2">},</span>
    <span class="s2">useSyncExternalStore: updateSyncExternalStore,</span>
    <span class="s2">useId: updateId,</span>
    <span class="s2">useHostTransitionStatus: useHostTransitionStatus,</span>
    <span class="s2">useFormState: updateActionState,</span>
    <span class="s2">useActionState: updateActionState,</span>
    <span class="s2">useOptimistic: </span><span class="s4">function </span><span class="s2">(passthrough, reducer) {</span>
      <span class="s4">var </span><span class="s2">hook = updateWorkInProgressHook();</span>
      <span class="s4">return </span><span class="s2">updateOptimisticImpl(hook, currentHook, passthrough, reducer);</span>
    <span class="s2">},</span>
    <span class="s2">useMemoCache: useMemoCache,</span>
    <span class="s2">useCacheRefresh: updateRefresh</span>
  <span class="s2">},</span>
  <span class="s2">HooksDispatcherOnRerender = {</span>
    <span class="s2">readContext: readContext,</span>
    <span class="s2">use: use,</span>
    <span class="s2">useCallback: updateCallback,</span>
    <span class="s2">useContext: readContext,</span>
    <span class="s2">useEffect: updateEffect,</span>
    <span class="s2">useImperativeHandle: updateImperativeHandle,</span>
    <span class="s2">useInsertionEffect: updateInsertionEffect,</span>
    <span class="s2">useLayoutEffect: updateLayoutEffect,</span>
    <span class="s2">useMemo: updateMemo,</span>
    <span class="s2">useReducer: rerenderReducer,</span>
    <span class="s2">useRef: updateRef,</span>
    <span class="s2">useState: </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">return </span><span class="s2">rerenderReducer(basicStateReducer);</span>
    <span class="s2">},</span>
    <span class="s2">useDebugValue: mountDebugValue,</span>
    <span class="s2">useDeferredValue: </span><span class="s4">function </span><span class="s2">(value, initialValue) {</span>
      <span class="s4">var </span><span class="s2">hook = updateWorkInProgressHook();</span>
      <span class="s4">return null </span><span class="s2">=== currentHook</span>
        <span class="s2">? mountDeferredValueImpl(hook, value, initialValue)</span>
        <span class="s2">: updateDeferredValueImpl(</span>
            <span class="s2">hook,</span>
            <span class="s2">currentHook.memoizedState,</span>
            <span class="s2">value,</span>
            <span class="s2">initialValue</span>
          <span class="s2">);</span>
    <span class="s2">},</span>
    <span class="s2">useTransition: </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">var </span><span class="s2">booleanOrThenable = rerenderReducer(basicStateReducer)[</span><span class="s5">0</span><span class="s2">],</span>
        <span class="s2">start = updateWorkInProgressHook().memoizedState;</span>
      <span class="s4">return </span><span class="s2">[</span>
        <span class="s3">&quot;boolean&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">booleanOrThenable</span>
          <span class="s2">? booleanOrThenable</span>
          <span class="s2">: useThenable(booleanOrThenable),</span>
        <span class="s2">start</span>
      <span class="s2">];</span>
    <span class="s2">},</span>
    <span class="s2">useSyncExternalStore: updateSyncExternalStore,</span>
    <span class="s2">useId: updateId,</span>
    <span class="s2">useHostTransitionStatus: useHostTransitionStatus,</span>
    <span class="s2">useFormState: rerenderActionState,</span>
    <span class="s2">useActionState: rerenderActionState,</span>
    <span class="s2">useOptimistic: </span><span class="s4">function </span><span class="s2">(passthrough, reducer) {</span>
      <span class="s4">var </span><span class="s2">hook = updateWorkInProgressHook();</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== currentHook)</span>
        <span class="s4">return </span><span class="s2">updateOptimisticImpl(hook, currentHook, passthrough, reducer);</span>
      <span class="s2">hook.baseState = passthrough;</span>
      <span class="s4">return </span><span class="s2">[passthrough, hook.queue.dispatch];</span>
    <span class="s2">},</span>
    <span class="s2">useMemoCache: useMemoCache,</span>
    <span class="s2">useCacheRefresh: updateRefresh</span>
  <span class="s2">},</span>
  <span class="s2">thenableState = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">thenableIndexCounter = </span><span class="s5">0</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">unwrapThenable(thenable) {</span>
  <span class="s4">var </span><span class="s2">index = thenableIndexCounter;</span>
  <span class="s2">thenableIndexCounter += </span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">null </span><span class="s2">=== thenableState &amp;&amp; (thenableState = []);</span>
  <span class="s4">return </span><span class="s2">trackUsedThenable(thenableState, thenable, index);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">coerceRef(workInProgress, element) {</span>
  <span class="s2">element = element.props.ref;</span>
  <span class="s2">workInProgress.ref = </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== element ? element : </span><span class="s4">null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">throwOnInvalidObjectType(returnFiber, newChild) {</span>
  <span class="s4">if </span><span class="s2">(newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)</span>
    <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">525</span><span class="s2">));</span>
  <span class="s2">returnFiber = Object.prototype.toString.call(newChild);</span>
  <span class="s4">throw </span><span class="s2">Error(</span>
    <span class="s2">formatProdErrorMessage(</span>
      <span class="s5">31</span><span class="s2">,</span>
      <span class="s3">&quot;[object Object]&quot; </span><span class="s2">=== returnFiber</span>
        <span class="s2">? </span><span class="s3">&quot;object with keys {&quot; </span><span class="s2">+ Object.keys(newChild).join(</span><span class="s3">&quot;, &quot;</span><span class="s2">) + </span><span class="s3">&quot;}&quot;</span>
        <span class="s2">: returnFiber</span>
    <span class="s2">)</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">resolveLazy(lazyType) {</span>
  <span class="s4">var </span><span class="s2">init = lazyType._init;</span>
  <span class="s4">return </span><span class="s2">init(lazyType._payload);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createChildReconciler(shouldTrackSideEffects) {</span>
  <span class="s4">function </span><span class="s2">deleteChild(returnFiber, childToDelete) {</span>
    <span class="s4">if </span><span class="s2">(shouldTrackSideEffects) {</span>
      <span class="s4">var </span><span class="s2">deletions = returnFiber.deletions;</span>
      <span class="s4">null </span><span class="s2">=== deletions</span>
        <span class="s2">? ((returnFiber.deletions = [childToDelete]), (returnFiber.flags |= </span><span class="s5">16</span><span class="s2">))</span>
        <span class="s2">: deletions.push(childToDelete);</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">deleteRemainingChildren(returnFiber, currentFirstChild) {</span>
    <span class="s4">if </span><span class="s2">(!shouldTrackSideEffects) </span><span class="s4">return null</span><span class="s2">;</span>
    <span class="s4">for </span><span class="s2">(; </span><span class="s4">null </span><span class="s2">!== currentFirstChild; )</span>
      <span class="s2">deleteChild(returnFiber, currentFirstChild),</span>
        <span class="s2">(currentFirstChild = currentFirstChild.sibling);</span>
    <span class="s4">return null</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">mapRemainingChildren(currentFirstChild) {</span>
    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">existingChildren = </span><span class="s4">new </span><span class="s2">Map(); </span><span class="s4">null </span><span class="s2">!== currentFirstChild; )</span>
      <span class="s4">null </span><span class="s2">!== currentFirstChild.key</span>
        <span class="s2">? existingChildren.set(currentFirstChild.key, currentFirstChild)</span>
        <span class="s2">: existingChildren.set(currentFirstChild.index, currentFirstChild),</span>
        <span class="s2">(currentFirstChild = currentFirstChild.sibling);</span>
    <span class="s4">return </span><span class="s2">existingChildren;</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">useFiber(fiber, pendingProps) {</span>
    <span class="s2">fiber = createWorkInProgress(fiber, pendingProps);</span>
    <span class="s2">fiber.index = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">fiber.sibling = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">return </span><span class="s2">fiber;</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">placeChild(newFiber, lastPlacedIndex, newIndex) {</span>
    <span class="s2">newFiber.index = newIndex;</span>
    <span class="s4">if </span><span class="s2">(!shouldTrackSideEffects)</span>
      <span class="s4">return </span><span class="s2">(newFiber.flags |= </span><span class="s5">1048576</span><span class="s2">), lastPlacedIndex;</span>
    <span class="s2">newIndex = newFiber.alternate;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== newIndex)</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(newIndex = newIndex.index),</span>
        <span class="s2">newIndex &lt; lastPlacedIndex</span>
          <span class="s2">? ((newFiber.flags |= </span><span class="s5">67108866</span><span class="s2">), lastPlacedIndex)</span>
          <span class="s2">: newIndex</span>
      <span class="s2">);</span>
    <span class="s2">newFiber.flags |= </span><span class="s5">67108866</span><span class="s2">;</span>
    <span class="s4">return </span><span class="s2">lastPlacedIndex;</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">placeSingleChild(newFiber) {</span>
    <span class="s2">shouldTrackSideEffects &amp;&amp;</span>
      <span class="s4">null </span><span class="s2">=== newFiber.alternate &amp;&amp;</span>
      <span class="s2">(newFiber.flags |= </span><span class="s5">67108866</span><span class="s2">);</span>
    <span class="s4">return </span><span class="s2">newFiber;</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">updateTextNode(returnFiber, current, textContent, lanes) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== current || </span><span class="s5">6 </span><span class="s2">!== current.tag)</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(current = createFiberFromText(textContent, returnFiber.mode, lanes)),</span>
        <span class="s2">(current.return = returnFiber),</span>
        <span class="s2">current</span>
      <span class="s2">);</span>
    <span class="s2">current = useFiber(current, textContent);</span>
    <span class="s2">current.return = returnFiber;</span>
    <span class="s4">return </span><span class="s2">current;</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">updateElement(returnFiber, current, element, lanes) {</span>
    <span class="s4">var </span><span class="s2">elementType = element.type;</span>
    <span class="s4">if </span><span class="s2">(elementType === REACT_FRAGMENT_TYPE)</span>
      <span class="s4">return </span><span class="s2">updateFragment(</span>
        <span class="s2">returnFiber,</span>
        <span class="s2">current,</span>
        <span class="s2">element.props.children,</span>
        <span class="s2">lanes,</span>
        <span class="s2">element.key</span>
      <span class="s2">);</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s4">null </span><span class="s2">!== current &amp;&amp;</span>
      <span class="s2">(current.elementType === elementType ||</span>
        <span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">elementType &amp;&amp;</span>
          <span class="s4">null </span><span class="s2">!== elementType &amp;&amp;</span>
          <span class="s2">elementType.$$typeof === REACT_LAZY_TYPE &amp;&amp;</span>
          <span class="s2">resolveLazy(elementType) === current.type))</span>
    <span class="s2">)</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(current = useFiber(current, element.props)),</span>
        <span class="s2">coerceRef(current, element),</span>
        <span class="s2">(current.return = returnFiber),</span>
        <span class="s2">current</span>
      <span class="s2">);</span>
    <span class="s2">current = createFiberFromTypeAndProps(</span>
      <span class="s2">element.type,</span>
      <span class="s2">element.key,</span>
      <span class="s2">element.props,</span>
      <span class="s4">null</span><span class="s2">,</span>
      <span class="s2">returnFiber.mode,</span>
      <span class="s2">lanes</span>
    <span class="s2">);</span>
    <span class="s2">coerceRef(current, element);</span>
    <span class="s2">current.return = returnFiber;</span>
    <span class="s4">return </span><span class="s2">current;</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">updatePortal(returnFiber, current, portal, lanes) {</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s4">null </span><span class="s2">=== current ||</span>
      <span class="s5">4 </span><span class="s2">!== current.tag ||</span>
      <span class="s2">current.stateNode.containerInfo !== portal.containerInfo ||</span>
      <span class="s2">current.stateNode.implementation !== portal.implementation</span>
    <span class="s2">)</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(current = createFiberFromPortal(portal, returnFiber.mode, lanes)),</span>
        <span class="s2">(current.return = returnFiber),</span>
        <span class="s2">current</span>
      <span class="s2">);</span>
    <span class="s2">current = useFiber(current, portal.children || []);</span>
    <span class="s2">current.return = returnFiber;</span>
    <span class="s4">return </span><span class="s2">current;</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">updateFragment(returnFiber, current, fragment, lanes, key) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== current || </span><span class="s5">7 </span><span class="s2">!== current.tag)</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(current = createFiberFromFragment(</span>
          <span class="s2">fragment,</span>
          <span class="s2">returnFiber.mode,</span>
          <span class="s2">lanes,</span>
          <span class="s2">key</span>
        <span class="s2">)),</span>
        <span class="s2">(current.return = returnFiber),</span>
        <span class="s2">current</span>
      <span class="s2">);</span>
    <span class="s2">current = useFiber(current, fragment);</span>
    <span class="s2">current.return = returnFiber;</span>
    <span class="s4">return </span><span class="s2">current;</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">createChild(returnFiber, newChild, lanes) {</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">newChild &amp;&amp; </span><span class="s3">&quot;&quot; </span><span class="s2">!== newChild) ||</span>
      <span class="s3">&quot;number&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">newChild ||</span>
      <span class="s3">&quot;bigint&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">newChild</span>
    <span class="s2">)</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(newChild = createFiberFromText(</span>
          <span class="s3">&quot;&quot; </span><span class="s2">+ newChild,</span>
          <span class="s2">returnFiber.mode,</span>
          <span class="s2">lanes</span>
        <span class="s2">)),</span>
        <span class="s2">(newChild.return = returnFiber),</span>
        <span class="s2">newChild</span>
      <span class="s2">);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">newChild &amp;&amp; </span><span class="s4">null </span><span class="s2">!== newChild) {</span>
      <span class="s4">switch </span><span class="s2">(newChild.$$typeof) {</span>
        <span class="s4">case </span><span class="s2">REACT_ELEMENT_TYPE:</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s2">(lanes = createFiberFromTypeAndProps(</span>
              <span class="s2">newChild.type,</span>
              <span class="s2">newChild.key,</span>
              <span class="s2">newChild.props,</span>
              <span class="s4">null</span><span class="s2">,</span>
              <span class="s2">returnFiber.mode,</span>
              <span class="s2">lanes</span>
            <span class="s2">)),</span>
            <span class="s2">coerceRef(lanes, newChild),</span>
            <span class="s2">(lanes.return = returnFiber),</span>
            <span class="s2">lanes</span>
          <span class="s2">);</span>
        <span class="s4">case </span><span class="s2">REACT_PORTAL_TYPE:</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s2">(newChild = createFiberFromPortal(</span>
              <span class="s2">newChild,</span>
              <span class="s2">returnFiber.mode,</span>
              <span class="s2">lanes</span>
            <span class="s2">)),</span>
            <span class="s2">(newChild.return = returnFiber),</span>
            <span class="s2">newChild</span>
          <span class="s2">);</span>
        <span class="s4">case </span><span class="s2">REACT_LAZY_TYPE:</span>
          <span class="s4">var </span><span class="s2">init = newChild._init;</span>
          <span class="s2">newChild = init(newChild._payload);</span>
          <span class="s4">return </span><span class="s2">createChild(returnFiber, newChild, lanes);</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(isArrayImpl(newChild) || getIteratorFn(newChild))</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(newChild = createFiberFromFragment(</span>
            <span class="s2">newChild,</span>
            <span class="s2">returnFiber.mode,</span>
            <span class="s2">lanes,</span>
            <span class="s4">null</span>
          <span class="s2">)),</span>
          <span class="s2">(newChild.return = returnFiber),</span>
          <span class="s2">newChild</span>
        <span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">newChild.then)</span>
        <span class="s4">return </span><span class="s2">createChild(returnFiber, unwrapThenable(newChild), lanes);</span>
      <span class="s4">if </span><span class="s2">(newChild.$$typeof === REACT_CONTEXT_TYPE)</span>
        <span class="s4">return </span><span class="s2">createChild(</span>
          <span class="s2">returnFiber,</span>
          <span class="s2">readContextDuringReconciliation(returnFiber, newChild),</span>
          <span class="s2">lanes</span>
        <span class="s2">);</span>
      <span class="s2">throwOnInvalidObjectType(returnFiber, newChild);</span>
    <span class="s2">}</span>
    <span class="s4">return null</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">updateSlot(returnFiber, oldFiber, newChild, lanes) {</span>
    <span class="s4">var </span><span class="s2">key = </span><span class="s4">null </span><span class="s2">!== oldFiber ? oldFiber.key : </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">newChild &amp;&amp; </span><span class="s3">&quot;&quot; </span><span class="s2">!== newChild) ||</span>
      <span class="s3">&quot;number&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">newChild ||</span>
      <span class="s3">&quot;bigint&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">newChild</span>
    <span class="s2">)</span>
      <span class="s4">return null </span><span class="s2">!== key</span>
        <span class="s2">? </span><span class="s4">null</span>
        <span class="s2">: updateTextNode(returnFiber, oldFiber, </span><span class="s3">&quot;&quot; </span><span class="s2">+ newChild, lanes);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">newChild &amp;&amp; </span><span class="s4">null </span><span class="s2">!== newChild) {</span>
      <span class="s4">switch </span><span class="s2">(newChild.$$typeof) {</span>
        <span class="s4">case </span><span class="s2">REACT_ELEMENT_TYPE:</span>
          <span class="s4">return </span><span class="s2">newChild.key === key</span>
            <span class="s2">? updateElement(returnFiber, oldFiber, newChild, lanes)</span>
            <span class="s2">: </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s2">REACT_PORTAL_TYPE:</span>
          <span class="s4">return </span><span class="s2">newChild.key === key</span>
            <span class="s2">? updatePortal(returnFiber, oldFiber, newChild, lanes)</span>
            <span class="s2">: </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s2">REACT_LAZY_TYPE:</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s2">(key = newChild._init),</span>
            <span class="s2">(newChild = key(newChild._payload)),</span>
            <span class="s2">updateSlot(returnFiber, oldFiber, newChild, lanes)</span>
          <span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(isArrayImpl(newChild) || getIteratorFn(newChild))</span>
        <span class="s4">return null </span><span class="s2">!== key</span>
          <span class="s2">? </span><span class="s4">null</span>
          <span class="s2">: updateFragment(returnFiber, oldFiber, newChild, lanes, </span><span class="s4">null</span><span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">newChild.then)</span>
        <span class="s4">return </span><span class="s2">updateSlot(</span>
          <span class="s2">returnFiber,</span>
          <span class="s2">oldFiber,</span>
          <span class="s2">unwrapThenable(newChild),</span>
          <span class="s2">lanes</span>
        <span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(newChild.$$typeof === REACT_CONTEXT_TYPE)</span>
        <span class="s4">return </span><span class="s2">updateSlot(</span>
          <span class="s2">returnFiber,</span>
          <span class="s2">oldFiber,</span>
          <span class="s2">readContextDuringReconciliation(returnFiber, newChild),</span>
          <span class="s2">lanes</span>
        <span class="s2">);</span>
      <span class="s2">throwOnInvalidObjectType(returnFiber, newChild);</span>
    <span class="s2">}</span>
    <span class="s4">return null</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">updateFromMap(</span>
    <span class="s2">existingChildren,</span>
    <span class="s2">returnFiber,</span>
    <span class="s2">newIdx,</span>
    <span class="s2">newChild,</span>
    <span class="s2">lanes</span>
  <span class="s2">) {</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">newChild &amp;&amp; </span><span class="s3">&quot;&quot; </span><span class="s2">!== newChild) ||</span>
      <span class="s3">&quot;number&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">newChild ||</span>
      <span class="s3">&quot;bigint&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">newChild</span>
    <span class="s2">)</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(existingChildren = existingChildren.get(newIdx) || </span><span class="s4">null</span><span class="s2">),</span>
        <span class="s2">updateTextNode(returnFiber, existingChildren, </span><span class="s3">&quot;&quot; </span><span class="s2">+ newChild, lanes)</span>
      <span class="s2">);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">newChild &amp;&amp; </span><span class="s4">null </span><span class="s2">!== newChild) {</span>
      <span class="s4">switch </span><span class="s2">(newChild.$$typeof) {</span>
        <span class="s4">case </span><span class="s2">REACT_ELEMENT_TYPE:</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s2">(existingChildren =</span>
              <span class="s2">existingChildren.get(</span>
                <span class="s4">null </span><span class="s2">=== newChild.key ? newIdx : newChild.key</span>
              <span class="s2">) || </span><span class="s4">null</span><span class="s2">),</span>
            <span class="s2">updateElement(returnFiber, existingChildren, newChild, lanes)</span>
          <span class="s2">);</span>
        <span class="s4">case </span><span class="s2">REACT_PORTAL_TYPE:</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s2">(existingChildren =</span>
              <span class="s2">existingChildren.get(</span>
                <span class="s4">null </span><span class="s2">=== newChild.key ? newIdx : newChild.key</span>
              <span class="s2">) || </span><span class="s4">null</span><span class="s2">),</span>
            <span class="s2">updatePortal(returnFiber, existingChildren, newChild, lanes)</span>
          <span class="s2">);</span>
        <span class="s4">case </span><span class="s2">REACT_LAZY_TYPE:</span>
          <span class="s4">var </span><span class="s2">init = newChild._init;</span>
          <span class="s2">newChild = init(newChild._payload);</span>
          <span class="s4">return </span><span class="s2">updateFromMap(</span>
            <span class="s2">existingChildren,</span>
            <span class="s2">returnFiber,</span>
            <span class="s2">newIdx,</span>
            <span class="s2">newChild,</span>
            <span class="s2">lanes</span>
          <span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(isArrayImpl(newChild) || getIteratorFn(newChild))</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(existingChildren = existingChildren.get(newIdx) || </span><span class="s4">null</span><span class="s2">),</span>
          <span class="s2">updateFragment(returnFiber, existingChildren, newChild, lanes, </span><span class="s4">null</span><span class="s2">)</span>
        <span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">newChild.then)</span>
        <span class="s4">return </span><span class="s2">updateFromMap(</span>
          <span class="s2">existingChildren,</span>
          <span class="s2">returnFiber,</span>
          <span class="s2">newIdx,</span>
          <span class="s2">unwrapThenable(newChild),</span>
          <span class="s2">lanes</span>
        <span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(newChild.$$typeof === REACT_CONTEXT_TYPE)</span>
        <span class="s4">return </span><span class="s2">updateFromMap(</span>
          <span class="s2">existingChildren,</span>
          <span class="s2">returnFiber,</span>
          <span class="s2">newIdx,</span>
          <span class="s2">readContextDuringReconciliation(returnFiber, newChild),</span>
          <span class="s2">lanes</span>
        <span class="s2">);</span>
      <span class="s2">throwOnInvalidObjectType(returnFiber, newChild);</span>
    <span class="s2">}</span>
    <span class="s4">return null</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">reconcileChildrenArray(</span>
    <span class="s2">returnFiber,</span>
    <span class="s2">currentFirstChild,</span>
    <span class="s2">newChildren,</span>
    <span class="s2">lanes</span>
  <span class="s2">) {</span>
    <span class="s4">for </span><span class="s2">(</span>
      <span class="s4">var </span><span class="s2">resultingFirstChild = </span><span class="s4">null</span><span class="s2">,</span>
        <span class="s2">previousNewFiber = </span><span class="s4">null</span><span class="s2">,</span>
        <span class="s2">oldFiber = currentFirstChild,</span>
        <span class="s2">newIdx = (currentFirstChild = </span><span class="s5">0</span><span class="s2">),</span>
        <span class="s2">nextOldFiber = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">null </span><span class="s2">!== oldFiber &amp;&amp; newIdx &lt; newChildren.length;</span>
      <span class="s2">newIdx++</span>
    <span class="s2">) {</span>
      <span class="s2">oldFiber.index &gt; newIdx</span>
        <span class="s2">? ((nextOldFiber = oldFiber), (oldFiber = </span><span class="s4">null</span><span class="s2">))</span>
        <span class="s2">: (nextOldFiber = oldFiber.sibling);</span>
      <span class="s4">var </span><span class="s2">newFiber = updateSlot(</span>
        <span class="s2">returnFiber,</span>
        <span class="s2">oldFiber,</span>
        <span class="s2">newChildren[newIdx],</span>
        <span class="s2">lanes</span>
      <span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== newFiber) {</span>
        <span class="s4">null </span><span class="s2">=== oldFiber &amp;&amp; (oldFiber = nextOldFiber);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s2">shouldTrackSideEffects &amp;&amp;</span>
        <span class="s2">oldFiber &amp;&amp;</span>
        <span class="s4">null </span><span class="s2">=== newFiber.alternate &amp;&amp;</span>
        <span class="s2">deleteChild(returnFiber, oldFiber);</span>
      <span class="s2">currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);</span>
      <span class="s4">null </span><span class="s2">=== previousNewFiber</span>
        <span class="s2">? (resultingFirstChild = newFiber)</span>
        <span class="s2">: (previousNewFiber.sibling = newFiber);</span>
      <span class="s2">previousNewFiber = newFiber;</span>
      <span class="s2">oldFiber = nextOldFiber;</span>
    <span class="s2">}</span>
    <span class="s4">if </span><span class="s2">(newIdx === newChildren.length)</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">deleteRemainingChildren(returnFiber, oldFiber),</span>
        <span class="s2">isHydrating &amp;&amp; pushTreeFork(returnFiber, newIdx),</span>
        <span class="s2">resultingFirstChild</span>
      <span class="s2">);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== oldFiber) {</span>
      <span class="s4">for </span><span class="s2">(; newIdx &lt; newChildren.length; newIdx++)</span>
        <span class="s2">(oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),</span>
          <span class="s4">null </span><span class="s2">!== oldFiber &amp;&amp;</span>
            <span class="s2">((currentFirstChild = placeChild(</span>
              <span class="s2">oldFiber,</span>
              <span class="s2">currentFirstChild,</span>
              <span class="s2">newIdx</span>
            <span class="s2">)),</span>
            <span class="s4">null </span><span class="s2">=== previousNewFiber</span>
              <span class="s2">? (resultingFirstChild = oldFiber)</span>
              <span class="s2">: (previousNewFiber.sibling = oldFiber),</span>
            <span class="s2">(previousNewFiber = oldFiber));</span>
      <span class="s2">isHydrating &amp;&amp; pushTreeFork(returnFiber, newIdx);</span>
      <span class="s4">return </span><span class="s2">resultingFirstChild;</span>
    <span class="s2">}</span>
    <span class="s4">for </span><span class="s2">(</span>
      <span class="s2">oldFiber = mapRemainingChildren(oldFiber);</span>
      <span class="s2">newIdx &lt; newChildren.length;</span>
      <span class="s2">newIdx++</span>
    <span class="s2">)</span>
      <span class="s2">(nextOldFiber = updateFromMap(</span>
        <span class="s2">oldFiber,</span>
        <span class="s2">returnFiber,</span>
        <span class="s2">newIdx,</span>
        <span class="s2">newChildren[newIdx],</span>
        <span class="s2">lanes</span>
      <span class="s2">)),</span>
        <span class="s4">null </span><span class="s2">!== nextOldFiber &amp;&amp;</span>
          <span class="s2">(shouldTrackSideEffects &amp;&amp;</span>
            <span class="s4">null </span><span class="s2">!== nextOldFiber.alternate &amp;&amp;</span>
            <span class="s2">oldFiber.delete(</span>
              <span class="s4">null </span><span class="s2">=== nextOldFiber.key ? newIdx : nextOldFiber.key</span>
            <span class="s2">),</span>
          <span class="s2">(currentFirstChild = placeChild(</span>
            <span class="s2">nextOldFiber,</span>
            <span class="s2">currentFirstChild,</span>
            <span class="s2">newIdx</span>
          <span class="s2">)),</span>
          <span class="s4">null </span><span class="s2">=== previousNewFiber</span>
            <span class="s2">? (resultingFirstChild = nextOldFiber)</span>
            <span class="s2">: (previousNewFiber.sibling = nextOldFiber),</span>
          <span class="s2">(previousNewFiber = nextOldFiber));</span>
    <span class="s2">shouldTrackSideEffects &amp;&amp;</span>
      <span class="s2">oldFiber.forEach(</span><span class="s4">function </span><span class="s2">(child) {</span>
        <span class="s4">return </span><span class="s2">deleteChild(returnFiber, child);</span>
      <span class="s2">});</span>
    <span class="s2">isHydrating &amp;&amp; pushTreeFork(returnFiber, newIdx);</span>
    <span class="s4">return </span><span class="s2">resultingFirstChild;</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">reconcileChildrenIterator(</span>
    <span class="s2">returnFiber,</span>
    <span class="s2">currentFirstChild,</span>
    <span class="s2">newChildren,</span>
    <span class="s2">lanes</span>
  <span class="s2">) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">== newChildren) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">151</span><span class="s2">));</span>
    <span class="s4">for </span><span class="s2">(</span>
      <span class="s4">var </span><span class="s2">resultingFirstChild = </span><span class="s4">null</span><span class="s2">,</span>
        <span class="s2">previousNewFiber = </span><span class="s4">null</span><span class="s2">,</span>
        <span class="s2">oldFiber = currentFirstChild,</span>
        <span class="s2">newIdx = (currentFirstChild = </span><span class="s5">0</span><span class="s2">),</span>
        <span class="s2">nextOldFiber = </span><span class="s4">null</span><span class="s2">,</span>
        <span class="s2">step = newChildren.next();</span>
      <span class="s4">null </span><span class="s2">!== oldFiber &amp;&amp; !step.done;</span>
      <span class="s2">newIdx++, step = newChildren.next()</span>
    <span class="s2">) {</span>
      <span class="s2">oldFiber.index &gt; newIdx</span>
        <span class="s2">? ((nextOldFiber = oldFiber), (oldFiber = </span><span class="s4">null</span><span class="s2">))</span>
        <span class="s2">: (nextOldFiber = oldFiber.sibling);</span>
      <span class="s4">var </span><span class="s2">newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== newFiber) {</span>
        <span class="s4">null </span><span class="s2">=== oldFiber &amp;&amp; (oldFiber = nextOldFiber);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s2">shouldTrackSideEffects &amp;&amp;</span>
        <span class="s2">oldFiber &amp;&amp;</span>
        <span class="s4">null </span><span class="s2">=== newFiber.alternate &amp;&amp;</span>
        <span class="s2">deleteChild(returnFiber, oldFiber);</span>
      <span class="s2">currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);</span>
      <span class="s4">null </span><span class="s2">=== previousNewFiber</span>
        <span class="s2">? (resultingFirstChild = newFiber)</span>
        <span class="s2">: (previousNewFiber.sibling = newFiber);</span>
      <span class="s2">previousNewFiber = newFiber;</span>
      <span class="s2">oldFiber = nextOldFiber;</span>
    <span class="s2">}</span>
    <span class="s4">if </span><span class="s2">(step.done)</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">deleteRemainingChildren(returnFiber, oldFiber),</span>
        <span class="s2">isHydrating &amp;&amp; pushTreeFork(returnFiber, newIdx),</span>
        <span class="s2">resultingFirstChild</span>
      <span class="s2">);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== oldFiber) {</span>
      <span class="s4">for </span><span class="s2">(; !step.done; newIdx++, step = newChildren.next())</span>
        <span class="s2">(step = createChild(returnFiber, step.value, lanes)),</span>
          <span class="s4">null </span><span class="s2">!== step &amp;&amp;</span>
            <span class="s2">((currentFirstChild = placeChild(step, currentFirstChild, newIdx)),</span>
            <span class="s4">null </span><span class="s2">=== previousNewFiber</span>
              <span class="s2">? (resultingFirstChild = step)</span>
              <span class="s2">: (previousNewFiber.sibling = step),</span>
            <span class="s2">(previousNewFiber = step));</span>
      <span class="s2">isHydrating &amp;&amp; pushTreeFork(returnFiber, newIdx);</span>
      <span class="s4">return </span><span class="s2">resultingFirstChild;</span>
    <span class="s2">}</span>
    <span class="s4">for </span><span class="s2">(</span>
      <span class="s2">oldFiber = mapRemainingChildren(oldFiber);</span>
      <span class="s2">!step.done;</span>
      <span class="s2">newIdx++, step = newChildren.next()</span>
    <span class="s2">)</span>
      <span class="s2">(step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes)),</span>
        <span class="s4">null </span><span class="s2">!== step &amp;&amp;</span>
          <span class="s2">(shouldTrackSideEffects &amp;&amp;</span>
            <span class="s4">null </span><span class="s2">!== step.alternate &amp;&amp;</span>
            <span class="s2">oldFiber.delete(</span><span class="s4">null </span><span class="s2">=== step.key ? newIdx : step.key),</span>
          <span class="s2">(currentFirstChild = placeChild(step, currentFirstChild, newIdx)),</span>
          <span class="s4">null </span><span class="s2">=== previousNewFiber</span>
            <span class="s2">? (resultingFirstChild = step)</span>
            <span class="s2">: (previousNewFiber.sibling = step),</span>
          <span class="s2">(previousNewFiber = step));</span>
    <span class="s2">shouldTrackSideEffects &amp;&amp;</span>
      <span class="s2">oldFiber.forEach(</span><span class="s4">function </span><span class="s2">(child) {</span>
        <span class="s4">return </span><span class="s2">deleteChild(returnFiber, child);</span>
      <span class="s2">});</span>
    <span class="s2">isHydrating &amp;&amp; pushTreeFork(returnFiber, newIdx);</span>
    <span class="s4">return </span><span class="s2">resultingFirstChild;</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">reconcileChildFibersImpl(</span>
    <span class="s2">returnFiber,</span>
    <span class="s2">currentFirstChild,</span>
    <span class="s2">newChild,</span>
    <span class="s2">lanes</span>
  <span class="s2">) {</span>
    <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">newChild &amp;&amp;</span>
      <span class="s4">null </span><span class="s2">!== newChild &amp;&amp;</span>
      <span class="s2">newChild.type === REACT_FRAGMENT_TYPE &amp;&amp;</span>
      <span class="s4">null </span><span class="s2">=== newChild.key &amp;&amp;</span>
      <span class="s2">(newChild = newChild.props.children);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">newChild &amp;&amp; </span><span class="s4">null </span><span class="s2">!== newChild) {</span>
      <span class="s4">switch </span><span class="s2">(newChild.$$typeof) {</span>
        <span class="s4">case </span><span class="s2">REACT_ELEMENT_TYPE:</span>
          <span class="s2">a: {</span>
            <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">key = newChild.key; </span><span class="s4">null </span><span class="s2">!== currentFirstChild; ) {</span>
              <span class="s4">if </span><span class="s2">(currentFirstChild.key === key) {</span>
                <span class="s2">key = newChild.type;</span>
                <span class="s4">if </span><span class="s2">(key === REACT_FRAGMENT_TYPE) {</span>
                  <span class="s4">if </span><span class="s2">(</span><span class="s5">7 </span><span class="s2">=== currentFirstChild.tag) {</span>
                    <span class="s2">deleteRemainingChildren(</span>
                      <span class="s2">returnFiber,</span>
                      <span class="s2">currentFirstChild.sibling</span>
                    <span class="s2">);</span>
                    <span class="s2">lanes = useFiber(</span>
                      <span class="s2">currentFirstChild,</span>
                      <span class="s2">newChild.props.children</span>
                    <span class="s2">);</span>
                    <span class="s2">lanes.return = returnFiber;</span>
                    <span class="s2">returnFiber = lanes;</span>
                    <span class="s4">break </span><span class="s2">a;</span>
                  <span class="s2">}</span>
                <span class="s2">} </span><span class="s4">else if </span><span class="s2">(</span>
                  <span class="s2">currentFirstChild.elementType === key ||</span>
                  <span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">key &amp;&amp;</span>
                    <span class="s4">null </span><span class="s2">!== key &amp;&amp;</span>
                    <span class="s2">key.$$typeof === REACT_LAZY_TYPE &amp;&amp;</span>
                    <span class="s2">resolveLazy(key) === currentFirstChild.type)</span>
                <span class="s2">) {</span>
                  <span class="s2">deleteRemainingChildren(</span>
                    <span class="s2">returnFiber,</span>
                    <span class="s2">currentFirstChild.sibling</span>
                  <span class="s2">);</span>
                  <span class="s2">lanes = useFiber(currentFirstChild, newChild.props);</span>
                  <span class="s2">coerceRef(lanes, newChild);</span>
                  <span class="s2">lanes.return = returnFiber;</span>
                  <span class="s2">returnFiber = lanes;</span>
                  <span class="s4">break </span><span class="s2">a;</span>
                <span class="s2">}</span>
                <span class="s2">deleteRemainingChildren(returnFiber, currentFirstChild);</span>
                <span class="s4">break</span><span class="s2">;</span>
              <span class="s2">} </span><span class="s4">else </span><span class="s2">deleteChild(returnFiber, currentFirstChild);</span>
              <span class="s2">currentFirstChild = currentFirstChild.sibling;</span>
            <span class="s2">}</span>
            <span class="s2">newChild.type === REACT_FRAGMENT_TYPE</span>
              <span class="s2">? ((lanes = createFiberFromFragment(</span>
                  <span class="s2">newChild.props.children,</span>
                  <span class="s2">returnFiber.mode,</span>
                  <span class="s2">lanes,</span>
                  <span class="s2">newChild.key</span>
                <span class="s2">)),</span>
                <span class="s2">(lanes.return = returnFiber),</span>
                <span class="s2">(returnFiber = lanes))</span>
              <span class="s2">: ((lanes = createFiberFromTypeAndProps(</span>
                  <span class="s2">newChild.type,</span>
                  <span class="s2">newChild.key,</span>
                  <span class="s2">newChild.props,</span>
                  <span class="s4">null</span><span class="s2">,</span>
                  <span class="s2">returnFiber.mode,</span>
                  <span class="s2">lanes</span>
                <span class="s2">)),</span>
                <span class="s2">coerceRef(lanes, newChild),</span>
                <span class="s2">(lanes.return = returnFiber),</span>
                <span class="s2">(returnFiber = lanes));</span>
          <span class="s2">}</span>
          <span class="s4">return </span><span class="s2">placeSingleChild(returnFiber);</span>
        <span class="s4">case </span><span class="s2">REACT_PORTAL_TYPE:</span>
          <span class="s2">a: {</span>
            <span class="s4">for </span><span class="s2">(key = newChild.key; </span><span class="s4">null </span><span class="s2">!== currentFirstChild; ) {</span>
              <span class="s4">if </span><span class="s2">(currentFirstChild.key === key)</span>
                <span class="s4">if </span><span class="s2">(</span>
                  <span class="s5">4 </span><span class="s2">=== currentFirstChild.tag &amp;&amp;</span>
                  <span class="s2">currentFirstChild.stateNode.containerInfo ===</span>
                    <span class="s2">newChild.containerInfo &amp;&amp;</span>
                  <span class="s2">currentFirstChild.stateNode.implementation ===</span>
                    <span class="s2">newChild.implementation</span>
                <span class="s2">) {</span>
                  <span class="s2">deleteRemainingChildren(</span>
                    <span class="s2">returnFiber,</span>
                    <span class="s2">currentFirstChild.sibling</span>
                  <span class="s2">);</span>
                  <span class="s2">lanes = useFiber(currentFirstChild, newChild.children || []);</span>
                  <span class="s2">lanes.return = returnFiber;</span>
                  <span class="s2">returnFiber = lanes;</span>
                  <span class="s4">break </span><span class="s2">a;</span>
                <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
                  <span class="s2">deleteRemainingChildren(returnFiber, currentFirstChild);</span>
                  <span class="s4">break</span><span class="s2">;</span>
                <span class="s2">}</span>
              <span class="s4">else </span><span class="s2">deleteChild(returnFiber, currentFirstChild);</span>
              <span class="s2">currentFirstChild = currentFirstChild.sibling;</span>
            <span class="s2">}</span>
            <span class="s2">lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);</span>
            <span class="s2">lanes.return = returnFiber;</span>
            <span class="s2">returnFiber = lanes;</span>
          <span class="s2">}</span>
          <span class="s4">return </span><span class="s2">placeSingleChild(returnFiber);</span>
        <span class="s4">case </span><span class="s2">REACT_LAZY_TYPE:</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s2">(key = newChild._init),</span>
            <span class="s2">(newChild = key(newChild._payload)),</span>
            <span class="s2">reconcileChildFibersImpl(</span>
              <span class="s2">returnFiber,</span>
              <span class="s2">currentFirstChild,</span>
              <span class="s2">newChild,</span>
              <span class="s2">lanes</span>
            <span class="s2">)</span>
          <span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(isArrayImpl(newChild))</span>
        <span class="s4">return </span><span class="s2">reconcileChildrenArray(</span>
          <span class="s2">returnFiber,</span>
          <span class="s2">currentFirstChild,</span>
          <span class="s2">newChild,</span>
          <span class="s2">lanes</span>
        <span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(getIteratorFn(newChild)) {</span>
        <span class="s2">key = getIteratorFn(newChild);</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">key) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">150</span><span class="s2">));</span>
        <span class="s2">newChild = key.call(newChild);</span>
        <span class="s4">return </span><span class="s2">reconcileChildrenIterator(</span>
          <span class="s2">returnFiber,</span>
          <span class="s2">currentFirstChild,</span>
          <span class="s2">newChild,</span>
          <span class="s2">lanes</span>
        <span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">newChild.then)</span>
        <span class="s4">return </span><span class="s2">reconcileChildFibersImpl(</span>
          <span class="s2">returnFiber,</span>
          <span class="s2">currentFirstChild,</span>
          <span class="s2">unwrapThenable(newChild),</span>
          <span class="s2">lanes</span>
        <span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(newChild.$$typeof === REACT_CONTEXT_TYPE)</span>
        <span class="s4">return </span><span class="s2">reconcileChildFibersImpl(</span>
          <span class="s2">returnFiber,</span>
          <span class="s2">currentFirstChild,</span>
          <span class="s2">readContextDuringReconciliation(returnFiber, newChild),</span>
          <span class="s2">lanes</span>
        <span class="s2">);</span>
      <span class="s2">throwOnInvalidObjectType(returnFiber, newChild);</span>
    <span class="s2">}</span>
    <span class="s4">return </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">newChild &amp;&amp; </span><span class="s3">&quot;&quot; </span><span class="s2">!== newChild) ||</span>
      <span class="s3">&quot;number&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">newChild ||</span>
      <span class="s3">&quot;bigint&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">newChild</span>
      <span class="s2">? ((newChild = </span><span class="s3">&quot;&quot; </span><span class="s2">+ newChild),</span>
        <span class="s4">null </span><span class="s2">!== currentFirstChild &amp;&amp; </span><span class="s5">6 </span><span class="s2">=== currentFirstChild.tag</span>
          <span class="s2">? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),</span>
            <span class="s2">(lanes = useFiber(currentFirstChild, newChild)),</span>
            <span class="s2">(lanes.return = returnFiber),</span>
            <span class="s2">(returnFiber = lanes))</span>
          <span class="s2">: (deleteRemainingChildren(returnFiber, currentFirstChild),</span>
            <span class="s2">(lanes = createFiberFromText(newChild, returnFiber.mode, lanes)),</span>
            <span class="s2">(lanes.return = returnFiber),</span>
            <span class="s2">(returnFiber = lanes)),</span>
        <span class="s2">placeSingleChild(returnFiber))</span>
      <span class="s2">: deleteRemainingChildren(returnFiber, currentFirstChild);</span>
  <span class="s2">}</span>
  <span class="s4">return function </span><span class="s2">(returnFiber, currentFirstChild, newChild, lanes) {</span>
    <span class="s4">try </span><span class="s2">{</span>
      <span class="s2">thenableIndexCounter = </span><span class="s5">0</span><span class="s2">;</span>
      <span class="s4">var </span><span class="s2">firstChildFiber = reconcileChildFibersImpl(</span>
        <span class="s2">returnFiber,</span>
        <span class="s2">currentFirstChild,</span>
        <span class="s2">newChild,</span>
        <span class="s2">lanes</span>
      <span class="s2">);</span>
      <span class="s2">thenableState = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">return </span><span class="s2">firstChildFiber;</span>
    <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
      <span class="s4">if </span><span class="s2">(x === SuspenseException || x === SuspenseActionException) </span><span class="s4">throw </span><span class="s2">x;</span>
      <span class="s4">var </span><span class="s2">fiber = createFiberImplClass(</span><span class="s5">29</span><span class="s2">, x, </span><span class="s4">null</span><span class="s2">, returnFiber.mode);</span>
      <span class="s2">fiber.lanes = lanes;</span>
      <span class="s2">fiber.return = returnFiber;</span>
      <span class="s4">return </span><span class="s2">fiber;</span>
    <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
    <span class="s2">}</span>
  <span class="s2">};</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">reconcileChildFibers = createChildReconciler(!</span><span class="s5">0</span><span class="s2">),</span>
  <span class="s2">mountChildFibers = createChildReconciler(!</span><span class="s5">1</span><span class="s2">),</span>
  <span class="s2">suspenseHandlerStackCursor = createCursor(</span><span class="s4">null</span><span class="s2">),</span>
  <span class="s2">shellBoundary = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">pushPrimaryTreeSuspenseHandler(handler) {</span>
  <span class="s4">var </span><span class="s2">current = handler.alternate;</span>
  <span class="s2">push(suspenseStackCursor, suspenseStackCursor.current &amp; </span><span class="s5">1</span><span class="s2">);</span>
  <span class="s2">push(suspenseHandlerStackCursor, handler);</span>
  <span class="s4">null </span><span class="s2">=== shellBoundary &amp;&amp;</span>
    <span class="s2">(</span><span class="s4">null </span><span class="s2">=== current || </span><span class="s4">null </span><span class="s2">!== currentTreeHiddenStackCursor.current</span>
      <span class="s2">? (shellBoundary = handler)</span>
      <span class="s2">: </span><span class="s4">null </span><span class="s2">!== current.memoizedState &amp;&amp; (shellBoundary = handler));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">pushOffscreenSuspenseHandler(fiber) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">22 </span><span class="s2">=== fiber.tag) {</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">(push(suspenseStackCursor, suspenseStackCursor.current),</span>
      <span class="s2">push(suspenseHandlerStackCursor, fiber),</span>
      <span class="s4">null </span><span class="s2">=== shellBoundary)</span>
    <span class="s2">) {</span>
      <span class="s4">var </span><span class="s2">current = fiber.alternate;</span>
      <span class="s4">null </span><span class="s2">!== current &amp;&amp;</span>
        <span class="s4">null </span><span class="s2">!== current.memoizedState &amp;&amp;</span>
        <span class="s2">(shellBoundary = fiber);</span>
    <span class="s2">}</span>
  <span class="s2">} </span><span class="s4">else </span><span class="s2">reuseSuspenseHandlerOnStack(fiber);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">reuseSuspenseHandlerOnStack() {</span>
  <span class="s2">push(suspenseStackCursor, suspenseStackCursor.current);</span>
  <span class="s2">push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">popSuspenseHandler(fiber) {</span>
  <span class="s2">pop(suspenseHandlerStackCursor);</span>
  <span class="s2">shellBoundary === fiber &amp;&amp; (shellBoundary = </span><span class="s4">null</span><span class="s2">);</span>
  <span class="s2">pop(suspenseStackCursor);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">suspenseStackCursor = createCursor(</span><span class="s5">0</span><span class="s2">);</span>
<span class="s4">function </span><span class="s2">findFirstSuspended(row) {</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">node = row; </span><span class="s4">null </span><span class="s2">!== node; ) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">13 </span><span class="s2">=== node.tag) {</span>
      <span class="s4">var </span><span class="s2">state = node.memoizedState;</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s4">null </span><span class="s2">!== state &amp;&amp;</span>
        <span class="s2">((state = state.dehydrated),</span>
        <span class="s4">null </span><span class="s2">=== state ||</span>
          <span class="s3">&quot;$?&quot; </span><span class="s2">=== state.data ||</span>
          <span class="s2">isSuspenseInstanceFallback(state))</span>
      <span class="s2">)</span>
        <span class="s4">return </span><span class="s2">node;</span>
    <span class="s2">} </span><span class="s4">else if </span><span class="s2">(</span><span class="s5">19 </span><span class="s2">=== node.tag &amp;&amp; </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== node.memoizedProps.revealOrder) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (node.flags &amp; </span><span class="s5">128</span><span class="s2">)) </span><span class="s4">return </span><span class="s2">node;</span>
    <span class="s2">} </span><span class="s4">else if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== node.child) {</span>
      <span class="s2">node.child.return = node;</span>
      <span class="s2">node = node.child;</span>
      <span class="s4">continue</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">if </span><span class="s2">(node === row) </span><span class="s4">break</span><span class="s2">;</span>
    <span class="s4">for </span><span class="s2">(; </span><span class="s4">null </span><span class="s2">=== node.sibling; ) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== node.return || node.return === row) </span><span class="s4">return null</span><span class="s2">;</span>
      <span class="s2">node = node.return;</span>
    <span class="s2">}</span>
    <span class="s2">node.sibling.return = node.return;</span>
    <span class="s2">node = node.sibling;</span>
  <span class="s2">}</span>
  <span class="s4">return null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">applyDerivedStateFromProps(</span>
  <span class="s2">workInProgress,</span>
  <span class="s2">ctor,</span>
  <span class="s2">getDerivedStateFromProps,</span>
  <span class="s2">nextProps</span>
<span class="s2">) {</span>
  <span class="s2">ctor = workInProgress.memoizedState;</span>
  <span class="s2">getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);</span>
  <span class="s2">getDerivedStateFromProps =</span>
    <span class="s4">null </span><span class="s2">=== getDerivedStateFromProps || </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== getDerivedStateFromProps</span>
      <span class="s2">? ctor</span>
      <span class="s2">: assign({}, ctor, getDerivedStateFromProps);</span>
  <span class="s2">workInProgress.memoizedState = getDerivedStateFromProps;</span>
  <span class="s5">0 </span><span class="s2">=== workInProgress.lanes &amp;&amp;</span>
    <span class="s2">(workInProgress.updateQueue.baseState = getDerivedStateFromProps);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">classComponentUpdater = {</span>
  <span class="s2">enqueueSetState: </span><span class="s4">function </span><span class="s2">(inst, payload, callback) {</span>
    <span class="s2">inst = inst._reactInternals;</span>
    <span class="s4">var </span><span class="s2">lane = requestUpdateLane(),</span>
      <span class="s2">update = createUpdate(lane);</span>
    <span class="s2">update.payload = payload;</span>
    <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== callback &amp;&amp; </span><span class="s4">null </span><span class="s2">!== callback &amp;&amp; (update.callback = callback);</span>
    <span class="s2">payload = enqueueUpdate(inst, update, lane);</span>
    <span class="s4">null </span><span class="s2">!== payload &amp;&amp;</span>
      <span class="s2">(scheduleUpdateOnFiber(payload, inst, lane),</span>
      <span class="s2">entangleTransitions(payload, inst, lane));</span>
    <span class="s2">markStateUpdateScheduled(inst, lane);</span>
  <span class="s2">},</span>
  <span class="s2">enqueueReplaceState: </span><span class="s4">function </span><span class="s2">(inst, payload, callback) {</span>
    <span class="s2">inst = inst._reactInternals;</span>
    <span class="s4">var </span><span class="s2">lane = requestUpdateLane(),</span>
      <span class="s2">update = createUpdate(lane);</span>
    <span class="s2">update.tag = </span><span class="s5">1</span><span class="s2">;</span>
    <span class="s2">update.payload = payload;</span>
    <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== callback &amp;&amp; </span><span class="s4">null </span><span class="s2">!== callback &amp;&amp; (update.callback = callback);</span>
    <span class="s2">payload = enqueueUpdate(inst, update, lane);</span>
    <span class="s4">null </span><span class="s2">!== payload &amp;&amp;</span>
      <span class="s2">(scheduleUpdateOnFiber(payload, inst, lane),</span>
      <span class="s2">entangleTransitions(payload, inst, lane));</span>
    <span class="s2">markStateUpdateScheduled(inst, lane);</span>
  <span class="s2">},</span>
  <span class="s2">enqueueForceUpdate: </span><span class="s4">function </span><span class="s2">(inst, callback) {</span>
    <span class="s2">inst = inst._reactInternals;</span>
    <span class="s4">var </span><span class="s2">lane = requestUpdateLane(),</span>
      <span class="s2">update = createUpdate(lane);</span>
    <span class="s2">update.tag = </span><span class="s5">2</span><span class="s2">;</span>
    <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== callback &amp;&amp; </span><span class="s4">null </span><span class="s2">!== callback &amp;&amp; (update.callback = callback);</span>
    <span class="s2">callback = enqueueUpdate(inst, update, lane);</span>
    <span class="s4">null </span><span class="s2">!== callback &amp;&amp;</span>
      <span class="s2">(scheduleUpdateOnFiber(callback, inst, lane),</span>
      <span class="s2">entangleTransitions(callback, inst, lane));</span>
    <span class="s4">null </span><span class="s2">!== injectedProfilingHooks &amp;&amp;</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">injectedProfilingHooks.markForceUpdateScheduled &amp;&amp;</span>
      <span class="s2">injectedProfilingHooks.markForceUpdateScheduled(inst, lane);</span>
  <span class="s2">}</span>
<span class="s2">};</span>
<span class="s4">function </span><span class="s2">checkShouldComponentUpdate(</span>
  <span class="s2">workInProgress,</span>
  <span class="s2">ctor,</span>
  <span class="s2">oldProps,</span>
  <span class="s2">newProps,</span>
  <span class="s2">oldState,</span>
  <span class="s2">newState,</span>
  <span class="s2">nextContext</span>
<span class="s2">) {</span>
  <span class="s2">workInProgress = workInProgress.stateNode;</span>
  <span class="s4">return </span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">workInProgress.shouldComponentUpdate</span>
    <span class="s2">? workInProgress.shouldComponentUpdate(newProps, newState, nextContext)</span>
    <span class="s2">: ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent</span>
      <span class="s2">? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)</span>
      <span class="s2">: !</span><span class="s5">0</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">callComponentWillReceiveProps(</span>
  <span class="s2">workInProgress,</span>
  <span class="s2">instance,</span>
  <span class="s2">newProps,</span>
  <span class="s2">nextContext</span>
<span class="s2">) {</span>
  <span class="s2">workInProgress = instance.state;</span>
  <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">instance.componentWillReceiveProps &amp;&amp;</span>
    <span class="s2">instance.componentWillReceiveProps(newProps, nextContext);</span>
  <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">instance.UNSAFE_componentWillReceiveProps &amp;&amp;</span>
    <span class="s2">instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);</span>
  <span class="s2">instance.state !== workInProgress &amp;&amp;</span>
    <span class="s2">classComponentUpdater.enqueueReplaceState(instance, instance.state, </span><span class="s4">null</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">resolveClassComponentProps(Component, baseProps) {</span>
  <span class="s4">var </span><span class="s2">newProps = baseProps;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;ref&quot; </span><span class="s4">in </span><span class="s2">baseProps) {</span>
    <span class="s2">newProps = {};</span>
    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">propName </span><span class="s4">in </span><span class="s2">baseProps)</span>
      <span class="s3">&quot;ref&quot; </span><span class="s2">!== propName &amp;&amp; (newProps[propName] = baseProps[propName]);</span>
  <span class="s2">}</span>
  <span class="s4">if </span><span class="s2">((Component = Component.defaultProps)) {</span>
    <span class="s2">newProps === baseProps &amp;&amp; (newProps = assign({}, newProps));</span>
    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">propName$75 </span><span class="s4">in </span><span class="s2">Component)</span>
      <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== newProps[propName$75] &amp;&amp;</span>
        <span class="s2">(newProps[propName$75] = Component[propName$75]);</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">newProps;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">reportGlobalError =</span>
  <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">reportError</span>
    <span class="s2">? reportError</span>
    <span class="s2">: </span><span class="s4">function </span><span class="s2">(error) {</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">window &amp;&amp;</span>
          <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">window.ErrorEvent</span>
        <span class="s2">) {</span>
          <span class="s4">var </span><span class="s2">event = </span><span class="s4">new </span><span class="s2">window.ErrorEvent(</span><span class="s3">&quot;error&quot;</span><span class="s2">, {</span>
            <span class="s2">bubbles: !</span><span class="s5">0</span><span class="s2">,</span>
            <span class="s2">cancelable: !</span><span class="s5">0</span><span class="s2">,</span>
            <span class="s2">message:</span>
              <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">error &amp;&amp;</span>
              <span class="s4">null </span><span class="s2">!== error &amp;&amp;</span>
              <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">error.message</span>
                <span class="s2">? String(error.message)</span>
                <span class="s2">: String(error),</span>
            <span class="s2">error: error</span>
          <span class="s2">});</span>
          <span class="s4">if </span><span class="s2">(!window.dispatchEvent(event)) </span><span class="s4">return</span><span class="s2">;</span>
        <span class="s2">} </span><span class="s4">else if </span><span class="s2">(</span>
          <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">process &amp;&amp;</span>
          <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">process.emit</span>
        <span class="s2">) {</span>
          <span class="s2">process.emit(</span><span class="s3">&quot;uncaughtException&quot;</span><span class="s2">, error);</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s2">console.error(error);</span>
      <span class="s2">};</span>
<span class="s4">function </span><span class="s2">defaultOnUncaughtError(error) {</span>
  <span class="s2">reportGlobalError(error);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">defaultOnCaughtError(error) {</span>
  <span class="s2">console.error(error);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">defaultOnRecoverableError(error) {</span>
  <span class="s2">reportGlobalError(error);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">logUncaughtError(root, errorInfo) {</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">onUncaughtError = root.onUncaughtError;</span>
    <span class="s2">onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });</span>
  <span class="s2">} </span><span class="s4">catch </span><span class="s2">(e$76) {</span>
    <span class="s2">setTimeout(</span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">throw </span><span class="s2">e$76;</span>
    <span class="s2">});</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">logCaughtError(root, boundary, errorInfo) {</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">onCaughtError = root.onCaughtError;</span>
    <span class="s2">onCaughtError(errorInfo.value, {</span>
      <span class="s2">componentStack: errorInfo.stack,</span>
      <span class="s2">errorBoundary: </span><span class="s5">1 </span><span class="s2">=== boundary.tag ? boundary.stateNode : </span><span class="s4">null</span>
    <span class="s2">});</span>
  <span class="s2">} </span><span class="s4">catch </span><span class="s2">(e$77) {</span>
    <span class="s2">setTimeout(</span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">throw </span><span class="s2">e$77;</span>
    <span class="s2">});</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createRootErrorUpdate(root, errorInfo, lane) {</span>
  <span class="s2">lane = createUpdate(lane);</span>
  <span class="s2">lane.tag = </span><span class="s5">3</span><span class="s2">;</span>
  <span class="s2">lane.payload = { element: </span><span class="s4">null </span><span class="s2">};</span>
  <span class="s2">lane.callback = </span><span class="s4">function </span><span class="s2">() {</span>
    <span class="s2">logUncaughtError(root, errorInfo);</span>
  <span class="s2">};</span>
  <span class="s4">return </span><span class="s2">lane;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createClassErrorUpdate(lane) {</span>
  <span class="s2">lane = createUpdate(lane);</span>
  <span class="s2">lane.tag = </span><span class="s5">3</span><span class="s2">;</span>
  <span class="s4">return </span><span class="s2">lane;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">initializeClassErrorUpdate(update, root, fiber, errorInfo) {</span>
  <span class="s4">var </span><span class="s2">getDerivedStateFromError = fiber.type.getDerivedStateFromError;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">getDerivedStateFromError) {</span>
    <span class="s4">var </span><span class="s2">error = errorInfo.value;</span>
    <span class="s2">update.payload = </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">return </span><span class="s2">getDerivedStateFromError(error);</span>
    <span class="s2">};</span>
    <span class="s2">update.callback = </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s2">logCaughtError(root, fiber, errorInfo);</span>
    <span class="s2">};</span>
  <span class="s2">}</span>
  <span class="s4">var </span><span class="s2">inst = fiber.stateNode;</span>
  <span class="s4">null </span><span class="s2">!== inst &amp;&amp;</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">inst.componentDidCatch &amp;&amp;</span>
    <span class="s2">(update.callback = </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s2">logCaughtError(root, fiber, errorInfo);</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">getDerivedStateFromError &amp;&amp;</span>
        <span class="s2">(</span><span class="s4">null </span><span class="s2">=== legacyErrorBoundariesThatAlreadyFailed</span>
          <span class="s2">? (legacyErrorBoundariesThatAlreadyFailed = </span><span class="s4">new </span><span class="s2">Set([</span><span class="s4">this</span><span class="s2">]))</span>
          <span class="s2">: legacyErrorBoundariesThatAlreadyFailed.add(</span><span class="s4">this</span><span class="s2">));</span>
      <span class="s4">var </span><span class="s2">stack = errorInfo.stack;</span>
      <span class="s4">this</span><span class="s2">.componentDidCatch(errorInfo.value, {</span>
        <span class="s2">componentStack: </span><span class="s4">null </span><span class="s2">!== stack ? stack : </span><span class="s3">&quot;&quot;</span>
      <span class="s2">});</span>
    <span class="s2">});</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">throwException(</span>
  <span class="s2">root,</span>
  <span class="s2">returnFiber,</span>
  <span class="s2">sourceFiber,</span>
  <span class="s2">value,</span>
  <span class="s2">rootRenderLanes</span>
<span class="s2">) {</span>
  <span class="s2">sourceFiber.flags |= </span><span class="s5">32768</span><span class="s2">;</span>
  <span class="s2">isDevToolsPresent &amp;&amp; restorePendingUpdaters(root, rootRenderLanes);</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s4">null </span><span class="s2">!== value &amp;&amp;</span>
    <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value &amp;&amp;</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value.then</span>
  <span class="s2">) {</span>
    <span class="s2">returnFiber = sourceFiber.alternate;</span>
    <span class="s4">null </span><span class="s2">!== returnFiber &amp;&amp;</span>
      <span class="s2">propagateParentContextChanges(</span>
        <span class="s2">returnFiber,</span>
        <span class="s2">sourceFiber,</span>
        <span class="s2">rootRenderLanes,</span>
        <span class="s2">!</span><span class="s5">0</span>
      <span class="s2">);</span>
    <span class="s2">sourceFiber = suspenseHandlerStackCursor.current;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== sourceFiber) {</span>
      <span class="s4">switch </span><span class="s2">(sourceFiber.tag) {</span>
        <span class="s4">case </span><span class="s5">13</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s4">null </span><span class="s2">=== shellBoundary</span>
              <span class="s2">? renderDidSuspendDelayIfPossible()</span>
              <span class="s2">: </span><span class="s4">null </span><span class="s2">=== sourceFiber.alternate &amp;&amp;</span>
                <span class="s5">0 </span><span class="s2">=== workInProgressRootExitStatus &amp;&amp;</span>
                <span class="s2">(workInProgressRootExitStatus = </span><span class="s5">3</span><span class="s2">),</span>
            <span class="s2">(sourceFiber.flags &amp;= -</span><span class="s5">257</span><span class="s2">),</span>
            <span class="s2">(sourceFiber.flags |= </span><span class="s5">65536</span><span class="s2">),</span>
            <span class="s2">(sourceFiber.lanes = rootRenderLanes),</span>
            <span class="s2">value === noopSuspenseyCommitThenable</span>
              <span class="s2">? (sourceFiber.flags |= </span><span class="s5">16384</span><span class="s2">)</span>
              <span class="s2">: ((returnFiber = sourceFiber.updateQueue),</span>
                <span class="s4">null </span><span class="s2">=== returnFiber</span>
                  <span class="s2">? (sourceFiber.updateQueue = </span><span class="s4">new </span><span class="s2">Set([value]))</span>
                  <span class="s2">: returnFiber.add(value),</span>
                <span class="s2">attachPingListener(root, value, rootRenderLanes)),</span>
            <span class="s2">!</span><span class="s5">1</span>
          <span class="s2">);</span>
        <span class="s4">case </span><span class="s5">22</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s2">(sourceFiber.flags |= </span><span class="s5">65536</span><span class="s2">),</span>
            <span class="s2">value === noopSuspenseyCommitThenable</span>
              <span class="s2">? (sourceFiber.flags |= </span><span class="s5">16384</span><span class="s2">)</span>
              <span class="s2">: ((returnFiber = sourceFiber.updateQueue),</span>
                <span class="s4">null </span><span class="s2">=== returnFiber</span>
                  <span class="s2">? ((returnFiber = {</span>
                      <span class="s2">transitions: </span><span class="s4">null</span><span class="s2">,</span>
                      <span class="s2">markerInstances: </span><span class="s4">null</span><span class="s2">,</span>
                      <span class="s2">retryQueue: </span><span class="s4">new </span><span class="s2">Set([value])</span>
                    <span class="s2">}),</span>
                    <span class="s2">(sourceFiber.updateQueue = returnFiber))</span>
                  <span class="s2">: ((sourceFiber = returnFiber.retryQueue),</span>
                    <span class="s4">null </span><span class="s2">=== sourceFiber</span>
                      <span class="s2">? (returnFiber.retryQueue = </span><span class="s4">new </span><span class="s2">Set([value]))</span>
                      <span class="s2">: sourceFiber.add(value)),</span>
                <span class="s2">attachPingListener(root, value, rootRenderLanes)),</span>
            <span class="s2">!</span><span class="s5">1</span>
          <span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">435</span><span class="s2">, sourceFiber.tag));</span>
    <span class="s2">}</span>
    <span class="s2">attachPingListener(root, value, rootRenderLanes);</span>
    <span class="s2">renderDidSuspendDelayIfPossible();</span>
    <span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s4">if </span><span class="s2">(isHydrating)</span>
    <span class="s4">return </span><span class="s2">(</span>
      <span class="s2">(returnFiber = suspenseHandlerStackCursor.current),</span>
      <span class="s4">null </span><span class="s2">!== returnFiber</span>
        <span class="s2">? (</span><span class="s5">0 </span><span class="s2">=== (returnFiber.flags &amp; </span><span class="s5">65536</span><span class="s2">) &amp;&amp; (returnFiber.flags |= </span><span class="s5">256</span><span class="s2">),</span>
          <span class="s2">(returnFiber.flags |= </span><span class="s5">65536</span><span class="s2">),</span>
          <span class="s2">(returnFiber.lanes = rootRenderLanes),</span>
          <span class="s2">value !== HydrationMismatchException &amp;&amp;</span>
            <span class="s2">((root = Error(formatProdErrorMessage(</span><span class="s5">422</span><span class="s2">), { cause: value })),</span>
            <span class="s2">queueHydrationError(createCapturedValueAtFiber(root, sourceFiber))))</span>
        <span class="s2">: (value !== HydrationMismatchException &amp;&amp;</span>
            <span class="s2">((returnFiber = Error(formatProdErrorMessage(</span><span class="s5">423</span><span class="s2">), {</span>
              <span class="s2">cause: value</span>
            <span class="s2">})),</span>
            <span class="s2">queueHydrationError(</span>
              <span class="s2">createCapturedValueAtFiber(returnFiber, sourceFiber)</span>
            <span class="s2">)),</span>
          <span class="s2">(root = root.current.alternate),</span>
          <span class="s2">(root.flags |= </span><span class="s5">65536</span><span class="s2">),</span>
          <span class="s2">(rootRenderLanes &amp;= -rootRenderLanes),</span>
          <span class="s2">(root.lanes |= rootRenderLanes),</span>
          <span class="s2">(value = createCapturedValueAtFiber(value, sourceFiber)),</span>
          <span class="s2">(rootRenderLanes = createRootErrorUpdate(</span>
            <span class="s2">root.stateNode,</span>
            <span class="s2">value,</span>
            <span class="s2">rootRenderLanes</span>
          <span class="s2">)),</span>
          <span class="s2">enqueueCapturedUpdate(root, rootRenderLanes),</span>
          <span class="s5">4 </span><span class="s2">!== workInProgressRootExitStatus &amp;&amp;</span>
            <span class="s2">(workInProgressRootExitStatus = </span><span class="s5">2</span><span class="s2">)),</span>
      <span class="s2">!</span><span class="s5">1</span>
    <span class="s2">);</span>
  <span class="s4">var </span><span class="s2">wrapperError = Error(formatProdErrorMessage(</span><span class="s5">520</span><span class="s2">), { cause: value });</span>
  <span class="s2">wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);</span>
  <span class="s4">null </span><span class="s2">=== workInProgressRootConcurrentErrors</span>
    <span class="s2">? (workInProgressRootConcurrentErrors = [wrapperError])</span>
    <span class="s2">: workInProgressRootConcurrentErrors.push(wrapperError);</span>
  <span class="s5">4 </span><span class="s2">!== workInProgressRootExitStatus &amp;&amp; (workInProgressRootExitStatus = </span><span class="s5">2</span><span class="s2">);</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== returnFiber) </span><span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">value = createCapturedValueAtFiber(value, sourceFiber);</span>
  <span class="s2">sourceFiber = returnFiber;</span>
  <span class="s4">do </span><span class="s2">{</span>
    <span class="s4">switch </span><span class="s2">(sourceFiber.tag) {</span>
      <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(sourceFiber.flags |= </span><span class="s5">65536</span><span class="s2">),</span>
          <span class="s2">(root = rootRenderLanes &amp; -rootRenderLanes),</span>
          <span class="s2">(sourceFiber.lanes |= root),</span>
          <span class="s2">(root = createRootErrorUpdate(sourceFiber.stateNode, value, root)),</span>
          <span class="s2">enqueueCapturedUpdate(sourceFiber, root),</span>
          <span class="s2">!</span><span class="s5">1</span>
        <span class="s2">);</span>
      <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">((returnFiber = sourceFiber.type),</span>
          <span class="s2">(wrapperError = sourceFiber.stateNode),</span>
          <span class="s5">0 </span><span class="s2">=== (sourceFiber.flags &amp; </span><span class="s5">128</span><span class="s2">) &amp;&amp;</span>
            <span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">returnFiber.getDerivedStateFromError ||</span>
              <span class="s2">(</span><span class="s4">null </span><span class="s2">!== wrapperError &amp;&amp;</span>
                <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">wrapperError.componentDidCatch &amp;&amp;</span>
                <span class="s2">(</span><span class="s4">null </span><span class="s2">=== legacyErrorBoundariesThatAlreadyFailed ||</span>
                  <span class="s2">!legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))))</span>
        <span class="s2">)</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s2">(sourceFiber.flags |= </span><span class="s5">65536</span><span class="s2">),</span>
            <span class="s2">(rootRenderLanes &amp;= -rootRenderLanes),</span>
            <span class="s2">(sourceFiber.lanes |= rootRenderLanes),</span>
            <span class="s2">(rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),</span>
            <span class="s2">initializeClassErrorUpdate(</span>
              <span class="s2">rootRenderLanes,</span>
              <span class="s2">root,</span>
              <span class="s2">sourceFiber,</span>
              <span class="s2">value</span>
            <span class="s2">),</span>
            <span class="s2">enqueueCapturedUpdate(sourceFiber, rootRenderLanes),</span>
            <span class="s2">!</span><span class="s5">1</span>
          <span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s2">sourceFiber = sourceFiber.return;</span>
  <span class="s2">} </span><span class="s4">while </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== sourceFiber);</span>
  <span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">SelectiveHydrationException = Error(formatProdErrorMessage(</span><span class="s5">461</span><span class="s2">)),</span>
  <span class="s2">didReceiveUpdate = !</span><span class="s5">1</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">reconcileChildren(current, workInProgress, nextChildren, renderLanes) {</span>
  <span class="s2">workInProgress.child =</span>
    <span class="s4">null </span><span class="s2">=== current</span>
      <span class="s2">? mountChildFibers(workInProgress, </span><span class="s4">null</span><span class="s2">, nextChildren, renderLanes)</span>
      <span class="s2">: reconcileChildFibers(</span>
          <span class="s2">workInProgress,</span>
          <span class="s2">current.child,</span>
          <span class="s2">nextChildren,</span>
          <span class="s2">renderLanes</span>
        <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateForwardRef(</span>
  <span class="s2">current,</span>
  <span class="s2">workInProgress,</span>
  <span class="s2">Component,</span>
  <span class="s2">nextProps,</span>
  <span class="s2">renderLanes</span>
<span class="s2">) {</span>
  <span class="s2">Component = Component.render;</span>
  <span class="s4">var </span><span class="s2">ref = workInProgress.ref;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;ref&quot; </span><span class="s4">in </span><span class="s2">nextProps) {</span>
    <span class="s4">var </span><span class="s2">propsWithoutRef = {};</span>
    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">key </span><span class="s4">in </span><span class="s2">nextProps)</span>
      <span class="s3">&quot;ref&quot; </span><span class="s2">!== key &amp;&amp; (propsWithoutRef[key] = nextProps[key]);</span>
  <span class="s2">} </span><span class="s4">else </span><span class="s2">propsWithoutRef = nextProps;</span>
  <span class="s2">prepareToReadContext(workInProgress);</span>
  <span class="s2">markComponentRenderStarted(workInProgress);</span>
  <span class="s2">nextProps = renderWithHooks(</span>
    <span class="s2">current,</span>
    <span class="s2">workInProgress,</span>
    <span class="s2">Component,</span>
    <span class="s2">propsWithoutRef,</span>
    <span class="s2">ref,</span>
    <span class="s2">renderLanes</span>
  <span class="s2">);</span>
  <span class="s2">key = checkDidRenderIdHook();</span>
  <span class="s2">markComponentRenderStopped();</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== current &amp;&amp; !didReceiveUpdate)</span>
    <span class="s4">return </span><span class="s2">(</span>
      <span class="s2">bailoutHooks(current, workInProgress, renderLanes),</span>
      <span class="s2">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)</span>
    <span class="s2">);</span>
  <span class="s2">isHydrating &amp;&amp; key &amp;&amp; pushMaterializedTreeId(workInProgress);</span>
  <span class="s2">workInProgress.flags |= </span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">reconcileChildren(current, workInProgress, nextProps, renderLanes);</span>
  <span class="s4">return </span><span class="s2">workInProgress.child;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateMemoComponent(</span>
  <span class="s2">current,</span>
  <span class="s2">workInProgress,</span>
  <span class="s2">Component,</span>
  <span class="s2">nextProps,</span>
  <span class="s2">renderLanes</span>
<span class="s2">) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== current) {</span>
    <span class="s4">var </span><span class="s2">type = Component.type;</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">type &amp;&amp;</span>
      <span class="s2">!shouldConstruct(type) &amp;&amp;</span>
      <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== type.defaultProps &amp;&amp;</span>
      <span class="s4">null </span><span class="s2">=== Component.compare</span>
    <span class="s2">)</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(workInProgress.tag = </span><span class="s5">15</span><span class="s2">),</span>
        <span class="s2">(workInProgress.type = type),</span>
        <span class="s2">updateSimpleMemoComponent(</span>
          <span class="s2">current,</span>
          <span class="s2">workInProgress,</span>
          <span class="s2">type,</span>
          <span class="s2">nextProps,</span>
          <span class="s2">renderLanes</span>
        <span class="s2">)</span>
      <span class="s2">);</span>
    <span class="s2">current = createFiberFromTypeAndProps(</span>
      <span class="s2">Component.type,</span>
      <span class="s4">null</span><span class="s2">,</span>
      <span class="s2">nextProps,</span>
      <span class="s2">workInProgress,</span>
      <span class="s2">workInProgress.mode,</span>
      <span class="s2">renderLanes</span>
    <span class="s2">);</span>
    <span class="s2">current.ref = workInProgress.ref;</span>
    <span class="s2">current.return = workInProgress;</span>
    <span class="s4">return </span><span class="s2">(workInProgress.child = current);</span>
  <span class="s2">}</span>
  <span class="s2">type = current.child;</span>
  <span class="s4">if </span><span class="s2">(!checkScheduledUpdateOrContext(current, renderLanes)) {</span>
    <span class="s4">var </span><span class="s2">prevProps = type.memoizedProps;</span>
    <span class="s2">Component = Component.compare;</span>
    <span class="s2">Component = </span><span class="s4">null </span><span class="s2">!== Component ? Component : shallowEqual;</span>
    <span class="s4">if </span><span class="s2">(Component(prevProps, nextProps) &amp;&amp; current.ref === workInProgress.ref)</span>
      <span class="s4">return </span><span class="s2">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span>
  <span class="s2">}</span>
  <span class="s2">workInProgress.flags |= </span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">current = createWorkInProgress(type, nextProps);</span>
  <span class="s2">current.ref = workInProgress.ref;</span>
  <span class="s2">current.return = workInProgress;</span>
  <span class="s4">return </span><span class="s2">(workInProgress.child = current);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateSimpleMemoComponent(</span>
  <span class="s2">current,</span>
  <span class="s2">workInProgress,</span>
  <span class="s2">Component,</span>
  <span class="s2">nextProps,</span>
  <span class="s2">renderLanes</span>
<span class="s2">) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== current) {</span>
    <span class="s4">var </span><span class="s2">prevProps = current.memoizedProps;</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">shallowEqual(prevProps, nextProps) &amp;&amp;</span>
      <span class="s2">current.ref === workInProgress.ref</span>
    <span class="s2">)</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">((didReceiveUpdate = !</span><span class="s5">1</span><span class="s2">),</span>
        <span class="s2">(workInProgress.pendingProps = nextProps = prevProps),</span>
        <span class="s2">checkScheduledUpdateOrContext(current, renderLanes))</span>
      <span class="s2">)</span>
        <span class="s5">0 </span><span class="s2">!== (current.flags &amp; </span><span class="s5">131072</span><span class="s2">) &amp;&amp; (didReceiveUpdate = !</span><span class="s5">0</span><span class="s2">);</span>
      <span class="s4">else</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(workInProgress.lanes = current.lanes),</span>
          <span class="s2">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)</span>
        <span class="s2">);</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">updateFunctionComponent(</span>
    <span class="s2">current,</span>
    <span class="s2">workInProgress,</span>
    <span class="s2">Component,</span>
    <span class="s2">nextProps,</span>
    <span class="s2">renderLanes</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateOffscreenComponent(current, workInProgress, renderLanes) {</span>
  <span class="s4">var </span><span class="s2">nextProps = workInProgress.pendingProps,</span>
    <span class="s2">nextChildren = nextProps.children,</span>
    <span class="s2">prevState = </span><span class="s4">null </span><span class="s2">!== current ? current.memoizedState : </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;hidden&quot; </span><span class="s2">=== nextProps.mode) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (workInProgress.flags &amp; </span><span class="s5">128</span><span class="s2">)) {</span>
      <span class="s2">nextProps =</span>
        <span class="s4">null </span><span class="s2">!== prevState ? prevState.baseLanes | renderLanes : renderLanes;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== current) {</span>
        <span class="s2">nextChildren = workInProgress.child = current.child;</span>
        <span class="s4">for </span><span class="s2">(prevState = </span><span class="s5">0</span><span class="s2">; </span><span class="s4">null </span><span class="s2">!== nextChildren; )</span>
          <span class="s2">(prevState =</span>
            <span class="s2">prevState | nextChildren.lanes | nextChildren.childLanes),</span>
            <span class="s2">(nextChildren = nextChildren.sibling);</span>
        <span class="s2">workInProgress.childLanes = prevState &amp; ~nextProps;</span>
      <span class="s2">} </span><span class="s4">else </span><span class="s2">(workInProgress.childLanes = </span><span class="s5">0</span><span class="s2">), (workInProgress.child = </span><span class="s4">null</span><span class="s2">);</span>
      <span class="s4">return </span><span class="s2">deferHiddenOffscreenComponent(</span>
        <span class="s2">current,</span>
        <span class="s2">workInProgress,</span>
        <span class="s2">nextProps,</span>
        <span class="s2">renderLanes</span>
      <span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (renderLanes &amp; </span><span class="s5">536870912</span><span class="s2">))</span>
      <span class="s2">(workInProgress.memoizedState = { baseLanes: </span><span class="s5">0</span><span class="s2">, cachePool: </span><span class="s4">null </span><span class="s2">}),</span>
        <span class="s4">null </span><span class="s2">!== current &amp;&amp;</span>
          <span class="s2">pushTransition(</span>
            <span class="s2">workInProgress,</span>
            <span class="s4">null </span><span class="s2">!== prevState ? prevState.cachePool : </span><span class="s4">null</span>
          <span class="s2">),</span>
        <span class="s4">null </span><span class="s2">!== prevState</span>
          <span class="s2">? pushHiddenContext(workInProgress, prevState)</span>
          <span class="s2">: reuseHiddenContextOnStack(),</span>
        <span class="s2">pushOffscreenSuspenseHandler(workInProgress);</span>
    <span class="s4">else</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(workInProgress.lanes = workInProgress.childLanes = </span><span class="s5">536870912</span><span class="s2">),</span>
        <span class="s2">deferHiddenOffscreenComponent(</span>
          <span class="s2">current,</span>
          <span class="s2">workInProgress,</span>
          <span class="s4">null </span><span class="s2">!== prevState ? prevState.baseLanes | renderLanes : renderLanes,</span>
          <span class="s2">renderLanes</span>
        <span class="s2">)</span>
      <span class="s2">);</span>
  <span class="s2">} </span><span class="s4">else</span>
    <span class="s4">null </span><span class="s2">!== prevState</span>
      <span class="s2">? (pushTransition(workInProgress, prevState.cachePool),</span>
        <span class="s2">pushHiddenContext(workInProgress, prevState),</span>
        <span class="s2">reuseSuspenseHandlerOnStack(workInProgress),</span>
        <span class="s2">(workInProgress.memoizedState = </span><span class="s4">null</span><span class="s2">))</span>
      <span class="s2">: (</span><span class="s4">null </span><span class="s2">!== current &amp;&amp; pushTransition(workInProgress, </span><span class="s4">null</span><span class="s2">),</span>
        <span class="s2">reuseHiddenContextOnStack(),</span>
        <span class="s2">reuseSuspenseHandlerOnStack(workInProgress));</span>
  <span class="s2">reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span>
  <span class="s4">return </span><span class="s2">workInProgress.child;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">deferHiddenOffscreenComponent(</span>
  <span class="s2">current,</span>
  <span class="s2">workInProgress,</span>
  <span class="s2">nextBaseLanes,</span>
  <span class="s2">renderLanes</span>
<span class="s2">) {</span>
  <span class="s4">var </span><span class="s2">JSCompiler_inline_result = peekCacheFromPool();</span>
  <span class="s2">JSCompiler_inline_result =</span>
    <span class="s4">null </span><span class="s2">=== JSCompiler_inline_result</span>
      <span class="s2">? </span><span class="s4">null</span>
      <span class="s2">: { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };</span>
  <span class="s2">workInProgress.memoizedState = {</span>
    <span class="s2">baseLanes: nextBaseLanes,</span>
    <span class="s2">cachePool: JSCompiler_inline_result</span>
  <span class="s2">};</span>
  <span class="s4">null </span><span class="s2">!== current &amp;&amp; pushTransition(workInProgress, </span><span class="s4">null</span><span class="s2">);</span>
  <span class="s2">reuseHiddenContextOnStack();</span>
  <span class="s2">pushOffscreenSuspenseHandler(workInProgress);</span>
  <span class="s4">null </span><span class="s2">!== current &amp;&amp;</span>
    <span class="s2">propagateParentContextChanges(current, workInProgress, renderLanes, !</span><span class="s5">0</span><span class="s2">);</span>
  <span class="s4">return null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">markRef(current, workInProgress) {</span>
  <span class="s4">var </span><span class="s2">ref = workInProgress.ref;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== ref)</span>
    <span class="s4">null </span><span class="s2">!== current &amp;&amp;</span>
      <span class="s4">null </span><span class="s2">!== current.ref &amp;&amp;</span>
      <span class="s2">(workInProgress.flags |= </span><span class="s5">4194816</span><span class="s2">);</span>
  <span class="s4">else </span><span class="s2">{</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">ref &amp;&amp; </span><span class="s3">&quot;object&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">ref)</span>
      <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">284</span><span class="s2">));</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== current || current.ref !== ref)</span>
      <span class="s2">workInProgress.flags |= </span><span class="s5">4194816</span><span class="s2">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateFunctionComponent(</span>
  <span class="s2">current,</span>
  <span class="s2">workInProgress,</span>
  <span class="s2">Component,</span>
  <span class="s2">nextProps,</span>
  <span class="s2">renderLanes</span>
<span class="s2">) {</span>
  <span class="s2">prepareToReadContext(workInProgress);</span>
  <span class="s2">markComponentRenderStarted(workInProgress);</span>
  <span class="s2">Component = renderWithHooks(</span>
    <span class="s2">current,</span>
    <span class="s2">workInProgress,</span>
    <span class="s2">Component,</span>
    <span class="s2">nextProps,</span>
    <span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">renderLanes</span>
  <span class="s2">);</span>
  <span class="s2">nextProps = checkDidRenderIdHook();</span>
  <span class="s2">markComponentRenderStopped();</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== current &amp;&amp; !didReceiveUpdate)</span>
    <span class="s4">return </span><span class="s2">(</span>
      <span class="s2">bailoutHooks(current, workInProgress, renderLanes),</span>
      <span class="s2">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)</span>
    <span class="s2">);</span>
  <span class="s2">isHydrating &amp;&amp; nextProps &amp;&amp; pushMaterializedTreeId(workInProgress);</span>
  <span class="s2">workInProgress.flags |= </span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">reconcileChildren(current, workInProgress, Component, renderLanes);</span>
  <span class="s4">return </span><span class="s2">workInProgress.child;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">replayFunctionComponent(</span>
  <span class="s2">current,</span>
  <span class="s2">workInProgress,</span>
  <span class="s2">nextProps,</span>
  <span class="s2">Component,</span>
  <span class="s2">secondArg,</span>
  <span class="s2">renderLanes</span>
<span class="s2">) {</span>
  <span class="s2">prepareToReadContext(workInProgress);</span>
  <span class="s2">markComponentRenderStarted(workInProgress);</span>
  <span class="s2">workInProgress.updateQueue = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">nextProps = renderWithHooksAgain(</span>
    <span class="s2">workInProgress,</span>
    <span class="s2">Component,</span>
    <span class="s2">nextProps,</span>
    <span class="s2">secondArg</span>
  <span class="s2">);</span>
  <span class="s2">finishRenderingHooks(current);</span>
  <span class="s2">Component = checkDidRenderIdHook();</span>
  <span class="s2">markComponentRenderStopped();</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== current &amp;&amp; !didReceiveUpdate)</span>
    <span class="s4">return </span><span class="s2">(</span>
      <span class="s2">bailoutHooks(current, workInProgress, renderLanes),</span>
      <span class="s2">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)</span>
    <span class="s2">);</span>
  <span class="s2">isHydrating &amp;&amp; Component &amp;&amp; pushMaterializedTreeId(workInProgress);</span>
  <span class="s2">workInProgress.flags |= </span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">reconcileChildren(current, workInProgress, nextProps, renderLanes);</span>
  <span class="s4">return </span><span class="s2">workInProgress.child;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateClassComponent(</span>
  <span class="s2">current,</span>
  <span class="s2">workInProgress,</span>
  <span class="s2">Component,</span>
  <span class="s2">nextProps,</span>
  <span class="s2">renderLanes</span>
<span class="s2">) {</span>
  <span class="s2">prepareToReadContext(workInProgress);</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== workInProgress.stateNode) {</span>
    <span class="s4">var </span><span class="s2">context = emptyContextObject,</span>
      <span class="s2">contextType = Component.contextType;</span>
    <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">contextType &amp;&amp;</span>
      <span class="s4">null </span><span class="s2">!== contextType &amp;&amp;</span>
      <span class="s2">(context = readContext(contextType));</span>
    <span class="s2">context = </span><span class="s4">new </span><span class="s2">Component(nextProps, context);</span>
    <span class="s2">workInProgress.memoizedState =</span>
      <span class="s4">null </span><span class="s2">!== context.state &amp;&amp; </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== context.state ? context.state : </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s2">context.updater = classComponentUpdater;</span>
    <span class="s2">workInProgress.stateNode = context;</span>
    <span class="s2">context._reactInternals = workInProgress;</span>
    <span class="s2">context = workInProgress.stateNode;</span>
    <span class="s2">context.props = nextProps;</span>
    <span class="s2">context.state = workInProgress.memoizedState;</span>
    <span class="s2">context.refs = {};</span>
    <span class="s2">initializeUpdateQueue(workInProgress);</span>
    <span class="s2">contextType = Component.contextType;</span>
    <span class="s2">context.context =</span>
      <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">contextType &amp;&amp; </span><span class="s4">null </span><span class="s2">!== contextType</span>
        <span class="s2">? readContext(contextType)</span>
        <span class="s2">: emptyContextObject;</span>
    <span class="s2">context.state = workInProgress.memoizedState;</span>
    <span class="s2">contextType = Component.getDerivedStateFromProps;</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">contextType &amp;&amp;</span>
      <span class="s2">(applyDerivedStateFromProps(</span>
        <span class="s2">workInProgress,</span>
        <span class="s2">Component,</span>
        <span class="s2">contextType,</span>
        <span class="s2">nextProps</span>
      <span class="s2">),</span>
      <span class="s2">(context.state = workInProgress.memoizedState));</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">Component.getDerivedStateFromProps ||</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">context.getSnapshotBeforeUpdate ||</span>
      <span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">context.UNSAFE_componentWillMount &amp;&amp;</span>
        <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">context.componentWillMount) ||</span>
      <span class="s2">((contextType = context.state),</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">context.componentWillMount &amp;&amp;</span>
        <span class="s2">context.componentWillMount(),</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">context.UNSAFE_componentWillMount &amp;&amp;</span>
        <span class="s2">context.UNSAFE_componentWillMount(),</span>
      <span class="s2">contextType !== context.state &amp;&amp;</span>
        <span class="s2">classComponentUpdater.enqueueReplaceState(context, context.state, </span><span class="s4">null</span><span class="s2">),</span>
      <span class="s2">processUpdateQueue(workInProgress, nextProps, context, renderLanes),</span>
      <span class="s2">suspendIfUpdateReadFromEntangledAsyncAction(),</span>
      <span class="s2">(context.state = workInProgress.memoizedState));</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">context.componentDidMount &amp;&amp;</span>
      <span class="s2">(workInProgress.flags |= </span><span class="s5">4194308</span><span class="s2">);</span>
    <span class="s2">nextProps = !</span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">} </span><span class="s4">else if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== current) {</span>
    <span class="s2">context = workInProgress.stateNode;</span>
    <span class="s4">var </span><span class="s2">unresolvedOldProps = workInProgress.memoizedProps,</span>
      <span class="s2">oldProps = resolveClassComponentProps(Component, unresolvedOldProps);</span>
    <span class="s2">context.props = oldProps;</span>
    <span class="s4">var </span><span class="s2">oldContext = context.context,</span>
      <span class="s2">contextType$jscomp$0 = Component.contextType;</span>
    <span class="s2">contextType = emptyContextObject;</span>
    <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">contextType$jscomp$0 &amp;&amp;</span>
      <span class="s4">null </span><span class="s2">!== contextType$jscomp$0 &amp;&amp;</span>
      <span class="s2">(contextType = readContext(contextType$jscomp$0));</span>
    <span class="s4">var </span><span class="s2">getDerivedStateFromProps = Component.getDerivedStateFromProps;</span>
    <span class="s2">contextType$jscomp$0 =</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">getDerivedStateFromProps ||</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">context.getSnapshotBeforeUpdate;</span>
    <span class="s2">unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;</span>
    <span class="s2">contextType$jscomp$0 ||</span>
      <span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">context.UNSAFE_componentWillReceiveProps &amp;&amp;</span>
        <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">context.componentWillReceiveProps) ||</span>
      <span class="s2">((unresolvedOldProps || oldContext !== contextType) &amp;&amp;</span>
        <span class="s2">callComponentWillReceiveProps(</span>
          <span class="s2">workInProgress,</span>
          <span class="s2">context,</span>
          <span class="s2">nextProps,</span>
          <span class="s2">contextType</span>
        <span class="s2">));</span>
    <span class="s2">hasForceUpdate = !</span><span class="s5">1</span><span class="s2">;</span>
    <span class="s4">var </span><span class="s2">oldState = workInProgress.memoizedState;</span>
    <span class="s2">context.state = oldState;</span>
    <span class="s2">processUpdateQueue(workInProgress, nextProps, context, renderLanes);</span>
    <span class="s2">suspendIfUpdateReadFromEntangledAsyncAction();</span>
    <span class="s2">oldContext = workInProgress.memoizedState;</span>
    <span class="s2">unresolvedOldProps || oldState !== oldContext || hasForceUpdate</span>
      <span class="s2">? (</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">getDerivedStateFromProps &amp;&amp;</span>
          <span class="s2">(applyDerivedStateFromProps(</span>
            <span class="s2">workInProgress,</span>
            <span class="s2">Component,</span>
            <span class="s2">getDerivedStateFromProps,</span>
            <span class="s2">nextProps</span>
          <span class="s2">),</span>
          <span class="s2">(oldContext = workInProgress.memoizedState)),</span>
        <span class="s2">(oldProps =</span>
          <span class="s2">hasForceUpdate ||</span>
          <span class="s2">checkShouldComponentUpdate(</span>
            <span class="s2">workInProgress,</span>
            <span class="s2">Component,</span>
            <span class="s2">oldProps,</span>
            <span class="s2">nextProps,</span>
            <span class="s2">oldState,</span>
            <span class="s2">oldContext,</span>
            <span class="s2">contextType</span>
          <span class="s2">))</span>
          <span class="s2">? (contextType$jscomp$0 ||</span>
              <span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">context.UNSAFE_componentWillMount &amp;&amp;</span>
                <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">context.componentWillMount) ||</span>
              <span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">context.componentWillMount &amp;&amp;</span>
                <span class="s2">context.componentWillMount(),</span>
              <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">context.UNSAFE_componentWillMount &amp;&amp;</span>
                <span class="s2">context.UNSAFE_componentWillMount()),</span>
            <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">context.componentDidMount &amp;&amp;</span>
              <span class="s2">(workInProgress.flags |= </span><span class="s5">4194308</span><span class="s2">))</span>
          <span class="s2">: (</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">context.componentDidMount &amp;&amp;</span>
              <span class="s2">(workInProgress.flags |= </span><span class="s5">4194308</span><span class="s2">),</span>
            <span class="s2">(workInProgress.memoizedProps = nextProps),</span>
            <span class="s2">(workInProgress.memoizedState = oldContext)),</span>
        <span class="s2">(context.props = nextProps),</span>
        <span class="s2">(context.state = oldContext),</span>
        <span class="s2">(context.context = contextType),</span>
        <span class="s2">(nextProps = oldProps))</span>
      <span class="s2">: (</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">context.componentDidMount &amp;&amp;</span>
          <span class="s2">(workInProgress.flags |= </span><span class="s5">4194308</span><span class="s2">),</span>
        <span class="s2">(nextProps = !</span><span class="s5">1</span><span class="s2">));</span>
  <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
    <span class="s2">context = workInProgress.stateNode;</span>
    <span class="s2">cloneUpdateQueue(current, workInProgress);</span>
    <span class="s2">contextType = workInProgress.memoizedProps;</span>
    <span class="s2">contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);</span>
    <span class="s2">context.props = contextType$jscomp$0;</span>
    <span class="s2">getDerivedStateFromProps = workInProgress.pendingProps;</span>
    <span class="s2">oldState = context.context;</span>
    <span class="s2">oldContext = Component.contextType;</span>
    <span class="s2">oldProps = emptyContextObject;</span>
    <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">oldContext &amp;&amp;</span>
      <span class="s4">null </span><span class="s2">!== oldContext &amp;&amp;</span>
      <span class="s2">(oldProps = readContext(oldContext));</span>
    <span class="s2">unresolvedOldProps = Component.getDerivedStateFromProps;</span>
    <span class="s2">(oldContext =</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">unresolvedOldProps ||</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">context.getSnapshotBeforeUpdate) ||</span>
      <span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">context.UNSAFE_componentWillReceiveProps &amp;&amp;</span>
        <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">context.componentWillReceiveProps) ||</span>
      <span class="s2">((contextType !== getDerivedStateFromProps || oldState !== oldProps) &amp;&amp;</span>
        <span class="s2">callComponentWillReceiveProps(</span>
          <span class="s2">workInProgress,</span>
          <span class="s2">context,</span>
          <span class="s2">nextProps,</span>
          <span class="s2">oldProps</span>
        <span class="s2">));</span>
    <span class="s2">hasForceUpdate = !</span><span class="s5">1</span><span class="s2">;</span>
    <span class="s2">oldState = workInProgress.memoizedState;</span>
    <span class="s2">context.state = oldState;</span>
    <span class="s2">processUpdateQueue(workInProgress, nextProps, context, renderLanes);</span>
    <span class="s2">suspendIfUpdateReadFromEntangledAsyncAction();</span>
    <span class="s4">var </span><span class="s2">newState = workInProgress.memoizedState;</span>
    <span class="s2">contextType !== getDerivedStateFromProps ||</span>
    <span class="s2">oldState !== newState ||</span>
    <span class="s2">hasForceUpdate ||</span>
    <span class="s2">(</span><span class="s4">null </span><span class="s2">!== current &amp;&amp;</span>
      <span class="s4">null </span><span class="s2">!== current.dependencies &amp;&amp;</span>
      <span class="s2">checkIfContextChanged(current.dependencies))</span>
      <span class="s2">? (</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">unresolvedOldProps &amp;&amp;</span>
          <span class="s2">(applyDerivedStateFromProps(</span>
            <span class="s2">workInProgress,</span>
            <span class="s2">Component,</span>
            <span class="s2">unresolvedOldProps,</span>
            <span class="s2">nextProps</span>
          <span class="s2">),</span>
          <span class="s2">(newState = workInProgress.memoizedState)),</span>
        <span class="s2">(contextType$jscomp$0 =</span>
          <span class="s2">hasForceUpdate ||</span>
          <span class="s2">checkShouldComponentUpdate(</span>
            <span class="s2">workInProgress,</span>
            <span class="s2">Component,</span>
            <span class="s2">contextType$jscomp$0,</span>
            <span class="s2">nextProps,</span>
            <span class="s2">oldState,</span>
            <span class="s2">newState,</span>
            <span class="s2">oldProps</span>
          <span class="s2">) ||</span>
          <span class="s2">(</span><span class="s4">null </span><span class="s2">!== current &amp;&amp;</span>
            <span class="s4">null </span><span class="s2">!== current.dependencies &amp;&amp;</span>
            <span class="s2">checkIfContextChanged(current.dependencies)))</span>
          <span class="s2">? (oldContext ||</span>
              <span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">context.UNSAFE_componentWillUpdate &amp;&amp;</span>
                <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">context.componentWillUpdate) ||</span>
              <span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">context.componentWillUpdate &amp;&amp;</span>
                <span class="s2">context.componentWillUpdate(nextProps, newState, oldProps),</span>
              <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">context.UNSAFE_componentWillUpdate &amp;&amp;</span>
                <span class="s2">context.UNSAFE_componentWillUpdate(</span>
                  <span class="s2">nextProps,</span>
                  <span class="s2">newState,</span>
                  <span class="s2">oldProps</span>
                <span class="s2">)),</span>
            <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">context.componentDidUpdate &amp;&amp;</span>
              <span class="s2">(workInProgress.flags |= </span><span class="s5">4</span><span class="s2">),</span>
            <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">context.getSnapshotBeforeUpdate &amp;&amp;</span>
              <span class="s2">(workInProgress.flags |= </span><span class="s5">1024</span><span class="s2">))</span>
          <span class="s2">: (</span><span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">context.componentDidUpdate ||</span>
              <span class="s2">(contextType === current.memoizedProps &amp;&amp;</span>
                <span class="s2">oldState === current.memoizedState) ||</span>
              <span class="s2">(workInProgress.flags |= </span><span class="s5">4</span><span class="s2">),</span>
            <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">context.getSnapshotBeforeUpdate ||</span>
              <span class="s2">(contextType === current.memoizedProps &amp;&amp;</span>
                <span class="s2">oldState === current.memoizedState) ||</span>
              <span class="s2">(workInProgress.flags |= </span><span class="s5">1024</span><span class="s2">),</span>
            <span class="s2">(workInProgress.memoizedProps = nextProps),</span>
            <span class="s2">(workInProgress.memoizedState = newState)),</span>
        <span class="s2">(context.props = nextProps),</span>
        <span class="s2">(context.state = newState),</span>
        <span class="s2">(context.context = oldProps),</span>
        <span class="s2">(nextProps = contextType$jscomp$0))</span>
      <span class="s2">: (</span><span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">context.componentDidUpdate ||</span>
          <span class="s2">(contextType === current.memoizedProps &amp;&amp;</span>
            <span class="s2">oldState === current.memoizedState) ||</span>
          <span class="s2">(workInProgress.flags |= </span><span class="s5">4</span><span class="s2">),</span>
        <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">context.getSnapshotBeforeUpdate ||</span>
          <span class="s2">(contextType === current.memoizedProps &amp;&amp;</span>
            <span class="s2">oldState === current.memoizedState) ||</span>
          <span class="s2">(workInProgress.flags |= </span><span class="s5">1024</span><span class="s2">),</span>
        <span class="s2">(nextProps = !</span><span class="s5">1</span><span class="s2">));</span>
  <span class="s2">}</span>
  <span class="s2">context = nextProps;</span>
  <span class="s2">markRef(current, workInProgress);</span>
  <span class="s2">nextProps = </span><span class="s5">0 </span><span class="s2">!== (workInProgress.flags &amp; </span><span class="s5">128</span><span class="s2">);</span>
  <span class="s2">context || nextProps</span>
    <span class="s2">? ((context = workInProgress.stateNode),</span>
      <span class="s2">nextProps &amp;&amp; </span><span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">Component.getDerivedStateFromError</span>
        <span class="s2">? ((Component = </span><span class="s4">null</span><span class="s2">), (profilerStartTime = -</span><span class="s5">1</span><span class="s2">))</span>
        <span class="s2">: (markComponentRenderStarted(workInProgress),</span>
          <span class="s2">(Component = context.render()),</span>
          <span class="s2">markComponentRenderStopped()),</span>
      <span class="s2">(workInProgress.flags |= </span><span class="s5">1</span><span class="s2">),</span>
      <span class="s4">null </span><span class="s2">!== current &amp;&amp; nextProps</span>
        <span class="s2">? ((workInProgress.child = reconcileChildFibers(</span>
            <span class="s2">workInProgress,</span>
            <span class="s2">current.child,</span>
            <span class="s4">null</span><span class="s2">,</span>
            <span class="s2">renderLanes</span>
          <span class="s2">)),</span>
          <span class="s2">(workInProgress.child = reconcileChildFibers(</span>
            <span class="s2">workInProgress,</span>
            <span class="s4">null</span><span class="s2">,</span>
            <span class="s2">Component,</span>
            <span class="s2">renderLanes</span>
          <span class="s2">)))</span>
        <span class="s2">: reconcileChildren(current, workInProgress, Component, renderLanes),</span>
      <span class="s2">(workInProgress.memoizedState = context.state),</span>
      <span class="s2">(current = workInProgress.child))</span>
    <span class="s2">: (current = bailoutOnAlreadyFinishedWork(</span>
        <span class="s2">current,</span>
        <span class="s2">workInProgress,</span>
        <span class="s2">renderLanes</span>
      <span class="s2">));</span>
  <span class="s4">return </span><span class="s2">current;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">mountHostRootWithoutHydrating(</span>
  <span class="s2">current,</span>
  <span class="s2">workInProgress,</span>
  <span class="s2">nextChildren,</span>
  <span class="s2">renderLanes</span>
<span class="s2">) {</span>
  <span class="s2">resetHydrationState();</span>
  <span class="s2">workInProgress.flags |= </span><span class="s5">256</span><span class="s2">;</span>
  <span class="s2">reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span>
  <span class="s4">return </span><span class="s2">workInProgress.child;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">SUSPENDED_MARKER = {</span>
  <span class="s2">dehydrated: </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">treeContext: </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">retryLane: </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">hydrationErrors: </span><span class="s4">null</span>
<span class="s2">};</span>
<span class="s4">function </span><span class="s2">mountSuspenseOffscreenState(renderLanes) {</span>
  <span class="s4">return </span><span class="s2">{ baseLanes: renderLanes, cachePool: getSuspendedCache() };</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getRemainingWorkInPrimaryTree(</span>
  <span class="s2">current,</span>
  <span class="s2">primaryTreeDidDefer,</span>
  <span class="s2">renderLanes</span>
<span class="s2">) {</span>
  <span class="s2">current = </span><span class="s4">null </span><span class="s2">!== current ? current.childLanes &amp; ~renderLanes : </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">primaryTreeDidDefer &amp;&amp; (current |= workInProgressDeferredLane);</span>
  <span class="s4">return </span><span class="s2">current;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateSuspenseComponent(current, workInProgress, renderLanes) {</span>
  <span class="s4">var </span><span class="s2">nextProps = workInProgress.pendingProps,</span>
    <span class="s2">showFallback = !</span><span class="s5">1</span><span class="s2">,</span>
    <span class="s2">didSuspend = </span><span class="s5">0 </span><span class="s2">!== (workInProgress.flags &amp; </span><span class="s5">128</span><span class="s2">),</span>
    <span class="s2">JSCompiler_temp;</span>
  <span class="s2">(JSCompiler_temp = didSuspend) ||</span>
    <span class="s2">(JSCompiler_temp =</span>
      <span class="s4">null </span><span class="s2">!== current &amp;&amp; </span><span class="s4">null </span><span class="s2">=== current.memoizedState</span>
        <span class="s2">? !</span><span class="s5">1</span>
        <span class="s2">: </span><span class="s5">0 </span><span class="s2">!== (suspenseStackCursor.current &amp; </span><span class="s5">2</span><span class="s2">));</span>
  <span class="s2">JSCompiler_temp &amp;&amp; ((showFallback = !</span><span class="s5">0</span><span class="s2">), (workInProgress.flags &amp;= -</span><span class="s5">129</span><span class="s2">));</span>
  <span class="s2">JSCompiler_temp = </span><span class="s5">0 </span><span class="s2">!== (workInProgress.flags &amp; </span><span class="s5">32</span><span class="s2">);</span>
  <span class="s2">workInProgress.flags &amp;= -</span><span class="s5">33</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== current) {</span>
    <span class="s4">if </span><span class="s2">(isHydrating) {</span>
      <span class="s2">showFallback</span>
        <span class="s2">? pushPrimaryTreeSuspenseHandler(workInProgress)</span>
        <span class="s2">: reuseSuspenseHandlerOnStack(workInProgress);</span>
      <span class="s4">if </span><span class="s2">(isHydrating) {</span>
        <span class="s4">var </span><span class="s2">nextInstance = nextHydratableInstance,</span>
          <span class="s2">JSCompiler_temp$jscomp$0;</span>
        <span class="s4">if </span><span class="s2">((JSCompiler_temp$jscomp$0 = nextInstance)) {</span>
          <span class="s2">c: {</span>
            <span class="s2">JSCompiler_temp$jscomp$0 = nextInstance;</span>
            <span class="s4">for </span><span class="s2">(</span>
              <span class="s2">nextInstance = rootOrSingletonContext;</span>
              <span class="s5">8 </span><span class="s2">!== JSCompiler_temp$jscomp$0.nodeType;</span>

            <span class="s2">) {</span>
              <span class="s4">if </span><span class="s2">(!nextInstance) {</span>
                <span class="s2">nextInstance = </span><span class="s4">null</span><span class="s2">;</span>
                <span class="s4">break </span><span class="s2">c;</span>
              <span class="s2">}</span>
              <span class="s2">JSCompiler_temp$jscomp$0 = getNextHydratable(</span>
                <span class="s2">JSCompiler_temp$jscomp$0.nextSibling</span>
              <span class="s2">);</span>
              <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== JSCompiler_temp$jscomp$0) {</span>
                <span class="s2">nextInstance = </span><span class="s4">null</span><span class="s2">;</span>
                <span class="s4">break </span><span class="s2">c;</span>
              <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s2">nextInstance = JSCompiler_temp$jscomp$0;</span>
          <span class="s2">}</span>
          <span class="s4">null </span><span class="s2">!== nextInstance</span>
            <span class="s2">? ((workInProgress.memoizedState = {</span>
                <span class="s2">dehydrated: nextInstance,</span>
                <span class="s2">treeContext:</span>
                  <span class="s4">null </span><span class="s2">!== treeContextProvider</span>
                    <span class="s2">? { id: treeContextId, overflow: treeContextOverflow }</span>
                    <span class="s2">: </span><span class="s4">null</span><span class="s2">,</span>
                <span class="s2">retryLane: </span><span class="s5">536870912</span><span class="s2">,</span>
                <span class="s2">hydrationErrors: </span><span class="s4">null</span>
              <span class="s2">}),</span>
              <span class="s2">(JSCompiler_temp$jscomp$0 = createFiberImplClass(</span>
                <span class="s5">18</span><span class="s2">,</span>
                <span class="s4">null</span><span class="s2">,</span>
                <span class="s4">null</span><span class="s2">,</span>
                <span class="s5">0</span>
              <span class="s2">)),</span>
              <span class="s2">(JSCompiler_temp$jscomp$0.stateNode = nextInstance),</span>
              <span class="s2">(JSCompiler_temp$jscomp$0.return = workInProgress),</span>
              <span class="s2">(workInProgress.child = JSCompiler_temp$jscomp$0),</span>
              <span class="s2">(hydrationParentFiber = workInProgress),</span>
              <span class="s2">(nextHydratableInstance = </span><span class="s4">null</span><span class="s2">),</span>
              <span class="s2">(JSCompiler_temp$jscomp$0 = !</span><span class="s5">0</span><span class="s2">))</span>
            <span class="s2">: (JSCompiler_temp$jscomp$0 = !</span><span class="s5">1</span><span class="s2">);</span>
        <span class="s2">}</span>
        <span class="s2">JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress);</span>
      <span class="s2">}</span>
      <span class="s2">nextInstance = workInProgress.memoizedState;</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s4">null </span><span class="s2">!== nextInstance &amp;&amp;</span>
        <span class="s2">((nextInstance = nextInstance.dehydrated), </span><span class="s4">null </span><span class="s2">!== nextInstance)</span>
      <span class="s2">)</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">isSuspenseInstanceFallback(nextInstance)</span>
            <span class="s2">? (workInProgress.lanes = </span><span class="s5">32</span><span class="s2">)</span>
            <span class="s2">: (workInProgress.lanes = </span><span class="s5">536870912</span><span class="s2">),</span>
          <span class="s4">null</span>
        <span class="s2">);</span>
      <span class="s2">popSuspenseHandler(workInProgress);</span>
    <span class="s2">}</span>
    <span class="s2">nextInstance = nextProps.children;</span>
    <span class="s2">nextProps = nextProps.fallback;</span>
    <span class="s4">if </span><span class="s2">(showFallback)</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">reuseSuspenseHandlerOnStack(workInProgress),</span>
        <span class="s2">(showFallback = workInProgress.mode),</span>
        <span class="s2">(nextInstance = mountWorkInProgressOffscreenFiber(</span>
          <span class="s2">{ mode: </span><span class="s3">&quot;hidden&quot;</span><span class="s2">, children: nextInstance },</span>
          <span class="s2">showFallback</span>
        <span class="s2">)),</span>
        <span class="s2">(nextProps = createFiberFromFragment(</span>
          <span class="s2">nextProps,</span>
          <span class="s2">showFallback,</span>
          <span class="s2">renderLanes,</span>
          <span class="s4">null</span>
        <span class="s2">)),</span>
        <span class="s2">(nextInstance.return = workInProgress),</span>
        <span class="s2">(nextProps.return = workInProgress),</span>
        <span class="s2">(nextInstance.sibling = nextProps),</span>
        <span class="s2">(workInProgress.child = nextInstance),</span>
        <span class="s2">(showFallback = workInProgress.child),</span>
        <span class="s2">(showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes)),</span>
        <span class="s2">(showFallback.childLanes = getRemainingWorkInPrimaryTree(</span>
          <span class="s2">current,</span>
          <span class="s2">JSCompiler_temp,</span>
          <span class="s2">renderLanes</span>
        <span class="s2">)),</span>
        <span class="s2">(workInProgress.memoizedState = SUSPENDED_MARKER),</span>
        <span class="s2">nextProps</span>
      <span class="s2">);</span>
    <span class="s2">pushPrimaryTreeSuspenseHandler(workInProgress);</span>
    <span class="s4">return </span><span class="s2">mountSuspensePrimaryChildren(workInProgress, nextInstance);</span>
  <span class="s2">}</span>
  <span class="s2">JSCompiler_temp$jscomp$0 = current.memoizedState;</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s4">null </span><span class="s2">!== JSCompiler_temp$jscomp$0 &amp;&amp;</span>
    <span class="s2">((nextInstance = JSCompiler_temp$jscomp$0.dehydrated),</span>
    <span class="s4">null </span><span class="s2">!== nextInstance)</span>
  <span class="s2">) {</span>
    <span class="s4">if </span><span class="s2">(didSuspend)</span>
      <span class="s2">workInProgress.flags &amp; </span><span class="s5">256</span>
        <span class="s2">? (pushPrimaryTreeSuspenseHandler(workInProgress),</span>
          <span class="s2">(workInProgress.flags &amp;= -</span><span class="s5">257</span><span class="s2">),</span>
          <span class="s2">(workInProgress = retrySuspenseComponentWithoutHydrating(</span>
            <span class="s2">current,</span>
            <span class="s2">workInProgress,</span>
            <span class="s2">renderLanes</span>
          <span class="s2">)))</span>
        <span class="s2">: </span><span class="s4">null </span><span class="s2">!== workInProgress.memoizedState</span>
          <span class="s2">? (reuseSuspenseHandlerOnStack(workInProgress),</span>
            <span class="s2">(workInProgress.child = current.child),</span>
            <span class="s2">(workInProgress.flags |= </span><span class="s5">128</span><span class="s2">),</span>
            <span class="s2">(workInProgress = </span><span class="s4">null</span><span class="s2">))</span>
          <span class="s2">: (reuseSuspenseHandlerOnStack(workInProgress),</span>
            <span class="s2">(showFallback = nextProps.fallback),</span>
            <span class="s2">(nextInstance = workInProgress.mode),</span>
            <span class="s2">(nextProps = mountWorkInProgressOffscreenFiber(</span>
              <span class="s2">{ mode: </span><span class="s3">&quot;visible&quot;</span><span class="s2">, children: nextProps.children },</span>
              <span class="s2">nextInstance</span>
            <span class="s2">)),</span>
            <span class="s2">(showFallback = createFiberFromFragment(</span>
              <span class="s2">showFallback,</span>
              <span class="s2">nextInstance,</span>
              <span class="s2">renderLanes,</span>
              <span class="s4">null</span>
            <span class="s2">)),</span>
            <span class="s2">(showFallback.flags |= </span><span class="s5">2</span><span class="s2">),</span>
            <span class="s2">(nextProps.return = workInProgress),</span>
            <span class="s2">(showFallback.return = workInProgress),</span>
            <span class="s2">(nextProps.sibling = showFallback),</span>
            <span class="s2">(workInProgress.child = nextProps),</span>
            <span class="s2">reconcileChildFibers(</span>
              <span class="s2">workInProgress,</span>
              <span class="s2">current.child,</span>
              <span class="s4">null</span><span class="s2">,</span>
              <span class="s2">renderLanes</span>
            <span class="s2">),</span>
            <span class="s2">(nextProps = workInProgress.child),</span>
            <span class="s2">(nextProps.memoizedState =</span>
              <span class="s2">mountSuspenseOffscreenState(renderLanes)),</span>
            <span class="s2">(nextProps.childLanes = getRemainingWorkInPrimaryTree(</span>
              <span class="s2">current,</span>
              <span class="s2">JSCompiler_temp,</span>
              <span class="s2">renderLanes</span>
            <span class="s2">)),</span>
            <span class="s2">(workInProgress.memoizedState = SUSPENDED_MARKER),</span>
            <span class="s2">(workInProgress = showFallback));</span>
    <span class="s4">else if </span><span class="s2">(</span>
      <span class="s2">(pushPrimaryTreeSuspenseHandler(workInProgress),</span>
      <span class="s2">isSuspenseInstanceFallback(nextInstance))</span>
    <span class="s2">) {</span>
      <span class="s2">JSCompiler_temp =</span>
        <span class="s2">nextInstance.nextSibling &amp;&amp; nextInstance.nextSibling.dataset;</span>
      <span class="s4">if </span><span class="s2">(JSCompiler_temp) </span><span class="s4">var </span><span class="s2">digest = JSCompiler_temp.dgst;</span>
      <span class="s2">JSCompiler_temp = digest;</span>
      <span class="s2">nextProps = Error(formatProdErrorMessage(</span><span class="s5">419</span><span class="s2">));</span>
      <span class="s2">nextProps.stack = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
      <span class="s2">nextProps.digest = JSCompiler_temp;</span>
      <span class="s2">queueHydrationError({ value: nextProps, source: </span><span class="s4">null</span><span class="s2">, stack: </span><span class="s4">null </span><span class="s2">});</span>
      <span class="s2">workInProgress = retrySuspenseComponentWithoutHydrating(</span>
        <span class="s2">current,</span>
        <span class="s2">workInProgress,</span>
        <span class="s2">renderLanes</span>
      <span class="s2">);</span>
    <span class="s2">} </span><span class="s4">else if </span><span class="s2">(</span>
      <span class="s2">(didReceiveUpdate ||</span>
        <span class="s2">propagateParentContextChanges(current, workInProgress, renderLanes, !</span><span class="s5">1</span><span class="s2">),</span>
      <span class="s2">(JSCompiler_temp = </span><span class="s5">0 </span><span class="s2">!== (renderLanes &amp; current.childLanes)),</span>
      <span class="s2">didReceiveUpdate || JSCompiler_temp)</span>
    <span class="s2">) {</span>
      <span class="s2">JSCompiler_temp = workInProgressRoot;</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s4">null </span><span class="s2">!== JSCompiler_temp &amp;&amp;</span>
        <span class="s2">((nextProps = renderLanes &amp; -renderLanes),</span>
        <span class="s2">(nextProps =</span>
          <span class="s5">0 </span><span class="s2">!== (nextProps &amp; </span><span class="s5">42</span><span class="s2">)</span>
            <span class="s2">? </span><span class="s5">1</span>
            <span class="s2">: getBumpedLaneForHydrationByLane(nextProps)),</span>
        <span class="s2">(nextProps =</span>
          <span class="s5">0 </span><span class="s2">!== (nextProps &amp; (JSCompiler_temp.suspendedLanes | renderLanes))</span>
            <span class="s2">? </span><span class="s5">0</span>
            <span class="s2">: nextProps),</span>
        <span class="s5">0 </span><span class="s2">!== nextProps &amp;&amp; nextProps !== JSCompiler_temp$jscomp$0.retryLane)</span>
      <span class="s2">)</span>
        <span class="s4">throw </span><span class="s2">(</span>
          <span class="s2">((JSCompiler_temp$jscomp$0.retryLane = nextProps),</span>
          <span class="s2">enqueueConcurrentRenderForLane(current, nextProps),</span>
          <span class="s2">scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps),</span>
          <span class="s2">SelectiveHydrationException)</span>
        <span class="s2">);</span>
      <span class="s3">&quot;$?&quot; </span><span class="s2">=== nextInstance.data || renderDidSuspendDelayIfPossible();</span>
      <span class="s2">workInProgress = retrySuspenseComponentWithoutHydrating(</span>
        <span class="s2">current,</span>
        <span class="s2">workInProgress,</span>
        <span class="s2">renderLanes</span>
      <span class="s2">);</span>
    <span class="s2">} </span><span class="s4">else</span>
      <span class="s3">&quot;$?&quot; </span><span class="s2">=== nextInstance.data</span>
        <span class="s2">? ((workInProgress.flags |= </span><span class="s5">192</span><span class="s2">),</span>
          <span class="s2">(workInProgress.child = current.child),</span>
          <span class="s2">(workInProgress = </span><span class="s4">null</span><span class="s2">))</span>
        <span class="s2">: ((current = JSCompiler_temp$jscomp$0.treeContext),</span>
          <span class="s2">(nextHydratableInstance = getNextHydratable(</span>
            <span class="s2">nextInstance.nextSibling</span>
          <span class="s2">)),</span>
          <span class="s2">(hydrationParentFiber = workInProgress),</span>
          <span class="s2">(isHydrating = !</span><span class="s5">0</span><span class="s2">),</span>
          <span class="s2">(hydrationErrors = </span><span class="s4">null</span><span class="s2">),</span>
          <span class="s2">(rootOrSingletonContext = !</span><span class="s5">1</span><span class="s2">),</span>
          <span class="s4">null </span><span class="s2">!== current &amp;&amp;</span>
            <span class="s2">((idStack[idStackIndex++] = treeContextId),</span>
            <span class="s2">(idStack[idStackIndex++] = treeContextOverflow),</span>
            <span class="s2">(idStack[idStackIndex++] = treeContextProvider),</span>
            <span class="s2">(treeContextId = current.id),</span>
            <span class="s2">(treeContextOverflow = current.overflow),</span>
            <span class="s2">(treeContextProvider = workInProgress)),</span>
          <span class="s2">(workInProgress = mountSuspensePrimaryChildren(</span>
            <span class="s2">workInProgress,</span>
            <span class="s2">nextProps.children</span>
          <span class="s2">)),</span>
          <span class="s2">(workInProgress.flags |= </span><span class="s5">4096</span><span class="s2">));</span>
    <span class="s4">return </span><span class="s2">workInProgress;</span>
  <span class="s2">}</span>
  <span class="s4">if </span><span class="s2">(showFallback)</span>
    <span class="s4">return </span><span class="s2">(</span>
      <span class="s2">reuseSuspenseHandlerOnStack(workInProgress),</span>
      <span class="s2">(showFallback = nextProps.fallback),</span>
      <span class="s2">(nextInstance = workInProgress.mode),</span>
      <span class="s2">(JSCompiler_temp$jscomp$0 = current.child),</span>
      <span class="s2">(digest = JSCompiler_temp$jscomp$0.sibling),</span>
      <span class="s2">(nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {</span>
        <span class="s2">mode: </span><span class="s3">&quot;hidden&quot;</span><span class="s2">,</span>
        <span class="s2">children: nextProps.children</span>
      <span class="s2">})),</span>
      <span class="s2">(nextProps.subtreeFlags =</span>
        <span class="s2">JSCompiler_temp$jscomp$0.subtreeFlags &amp; </span><span class="s5">65011712</span><span class="s2">),</span>
      <span class="s4">null </span><span class="s2">!== digest</span>
        <span class="s2">? (showFallback = createWorkInProgress(digest, showFallback))</span>
        <span class="s2">: ((showFallback = createFiberFromFragment(</span>
            <span class="s2">showFallback,</span>
            <span class="s2">nextInstance,</span>
            <span class="s2">renderLanes,</span>
            <span class="s4">null</span>
          <span class="s2">)),</span>
          <span class="s2">(showFallback.flags |= </span><span class="s5">2</span><span class="s2">)),</span>
      <span class="s2">(showFallback.return = workInProgress),</span>
      <span class="s2">(nextProps.return = workInProgress),</span>
      <span class="s2">(nextProps.sibling = showFallback),</span>
      <span class="s2">(workInProgress.child = nextProps),</span>
      <span class="s2">(nextProps = showFallback),</span>
      <span class="s2">(showFallback = workInProgress.child),</span>
      <span class="s2">(nextInstance = current.child.memoizedState),</span>
      <span class="s4">null </span><span class="s2">=== nextInstance</span>
        <span class="s2">? (nextInstance = mountSuspenseOffscreenState(renderLanes))</span>
        <span class="s2">: ((JSCompiler_temp$jscomp$0 = nextInstance.cachePool),</span>
          <span class="s4">null </span><span class="s2">!== JSCompiler_temp$jscomp$0</span>
            <span class="s2">? ((digest = CacheContext._currentValue),</span>
              <span class="s2">(JSCompiler_temp$jscomp$0 =</span>
                <span class="s2">JSCompiler_temp$jscomp$0.parent !== digest</span>
                  <span class="s2">? { parent: digest, pool: digest }</span>
                  <span class="s2">: JSCompiler_temp$jscomp$0))</span>
            <span class="s2">: (JSCompiler_temp$jscomp$0 = getSuspendedCache()),</span>
          <span class="s2">(nextInstance = {</span>
            <span class="s2">baseLanes: nextInstance.baseLanes | renderLanes,</span>
            <span class="s2">cachePool: JSCompiler_temp$jscomp$0</span>
          <span class="s2">})),</span>
      <span class="s2">(showFallback.memoizedState = nextInstance),</span>
      <span class="s2">(showFallback.childLanes = getRemainingWorkInPrimaryTree(</span>
        <span class="s2">current,</span>
        <span class="s2">JSCompiler_temp,</span>
        <span class="s2">renderLanes</span>
      <span class="s2">)),</span>
      <span class="s2">(workInProgress.memoizedState = SUSPENDED_MARKER),</span>
      <span class="s2">nextProps</span>
    <span class="s2">);</span>
  <span class="s2">pushPrimaryTreeSuspenseHandler(workInProgress);</span>
  <span class="s2">renderLanes = current.child;</span>
  <span class="s2">current = renderLanes.sibling;</span>
  <span class="s2">renderLanes = createWorkInProgress(renderLanes, {</span>
    <span class="s2">mode: </span><span class="s3">&quot;visible&quot;</span><span class="s2">,</span>
    <span class="s2">children: nextProps.children</span>
  <span class="s2">});</span>
  <span class="s2">renderLanes.return = workInProgress;</span>
  <span class="s2">renderLanes.sibling = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">null </span><span class="s2">!== current &amp;&amp;</span>
    <span class="s2">((JSCompiler_temp = workInProgress.deletions),</span>
    <span class="s4">null </span><span class="s2">=== JSCompiler_temp</span>
      <span class="s2">? ((workInProgress.deletions = [current]), (workInProgress.flags |= </span><span class="s5">16</span><span class="s2">))</span>
      <span class="s2">: JSCompiler_temp.push(current));</span>
  <span class="s2">workInProgress.child = renderLanes;</span>
  <span class="s2">workInProgress.memoizedState = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">return </span><span class="s2">renderLanes;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">mountSuspensePrimaryChildren(workInProgress, primaryChildren) {</span>
  <span class="s2">primaryChildren = mountWorkInProgressOffscreenFiber(</span>
    <span class="s2">{ mode: </span><span class="s3">&quot;visible&quot;</span><span class="s2">, children: primaryChildren },</span>
    <span class="s2">workInProgress.mode</span>
  <span class="s2">);</span>
  <span class="s2">primaryChildren.return = workInProgress;</span>
  <span class="s4">return </span><span class="s2">(workInProgress.child = primaryChildren);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">mountWorkInProgressOffscreenFiber(offscreenProps, mode) {</span>
  <span class="s2">offscreenProps = createFiberImplClass(</span><span class="s5">22</span><span class="s2">, offscreenProps, </span><span class="s4">null</span><span class="s2">, mode);</span>
  <span class="s2">offscreenProps.lanes = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">offscreenProps.stateNode = {</span>
    <span class="s2">_visibility: </span><span class="s5">1</span><span class="s2">,</span>
    <span class="s2">_pendingMarkers: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">_retryCache: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">_transitions: </span><span class="s4">null</span>
  <span class="s2">};</span>
  <span class="s4">return </span><span class="s2">offscreenProps;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">retrySuspenseComponentWithoutHydrating(</span>
  <span class="s2">current,</span>
  <span class="s2">workInProgress,</span>
  <span class="s2">renderLanes</span>
<span class="s2">) {</span>
  <span class="s2">reconcileChildFibers(workInProgress, current.child, </span><span class="s4">null</span><span class="s2">, renderLanes);</span>
  <span class="s2">current = mountSuspensePrimaryChildren(</span>
    <span class="s2">workInProgress,</span>
    <span class="s2">workInProgress.pendingProps.children</span>
  <span class="s2">);</span>
  <span class="s2">current.flags |= </span><span class="s5">2</span><span class="s2">;</span>
  <span class="s2">workInProgress.memoizedState = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">return </span><span class="s2">current;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {</span>
  <span class="s2">fiber.lanes |= renderLanes;</span>
  <span class="s4">var </span><span class="s2">alternate = fiber.alternate;</span>
  <span class="s4">null </span><span class="s2">!== alternate &amp;&amp; (alternate.lanes |= renderLanes);</span>
  <span class="s2">scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">initSuspenseListRenderState(</span>
  <span class="s2">workInProgress,</span>
  <span class="s2">isBackwards,</span>
  <span class="s2">tail,</span>
  <span class="s2">lastContentRow,</span>
  <span class="s2">tailMode</span>
<span class="s2">) {</span>
  <span class="s4">var </span><span class="s2">renderState = workInProgress.memoizedState;</span>
  <span class="s4">null </span><span class="s2">=== renderState</span>
    <span class="s2">? (workInProgress.memoizedState = {</span>
        <span class="s2">isBackwards: isBackwards,</span>
        <span class="s2">rendering: </span><span class="s4">null</span><span class="s2">,</span>
        <span class="s2">renderingStartTime: </span><span class="s5">0</span><span class="s2">,</span>
        <span class="s2">last: lastContentRow,</span>
        <span class="s2">tail: tail,</span>
        <span class="s2">tailMode: tailMode</span>
      <span class="s2">})</span>
    <span class="s2">: ((renderState.isBackwards = isBackwards),</span>
      <span class="s2">(renderState.rendering = </span><span class="s4">null</span><span class="s2">),</span>
      <span class="s2">(renderState.renderingStartTime = </span><span class="s5">0</span><span class="s2">),</span>
      <span class="s2">(renderState.last = lastContentRow),</span>
      <span class="s2">(renderState.tail = tail),</span>
      <span class="s2">(renderState.tailMode = tailMode));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateSuspenseListComponent(current, workInProgress, renderLanes) {</span>
  <span class="s4">var </span><span class="s2">nextProps = workInProgress.pendingProps,</span>
    <span class="s2">revealOrder = nextProps.revealOrder,</span>
    <span class="s2">tailMode = nextProps.tail;</span>
  <span class="s2">reconcileChildren(current, workInProgress, nextProps.children, renderLanes);</span>
  <span class="s2">nextProps = suspenseStackCursor.current;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (nextProps &amp; </span><span class="s5">2</span><span class="s2">))</span>
    <span class="s2">(nextProps = (nextProps &amp; </span><span class="s5">1</span><span class="s2">) | </span><span class="s5">2</span><span class="s2">), (workInProgress.flags |= </span><span class="s5">128</span><span class="s2">);</span>
  <span class="s4">else </span><span class="s2">{</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== current &amp;&amp; </span><span class="s5">0 </span><span class="s2">!== (current.flags &amp; </span><span class="s5">128</span><span class="s2">))</span>
      <span class="s2">a: </span><span class="s4">for </span><span class="s2">(current = workInProgress.child; </span><span class="s4">null </span><span class="s2">!== current; ) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s5">13 </span><span class="s2">=== current.tag)</span>
          <span class="s4">null </span><span class="s2">!== current.memoizedState &amp;&amp;</span>
            <span class="s2">scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);</span>
        <span class="s4">else if </span><span class="s2">(</span><span class="s5">19 </span><span class="s2">=== current.tag)</span>
          <span class="s2">scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);</span>
        <span class="s4">else if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== current.child) {</span>
          <span class="s2">current.child.return = current;</span>
          <span class="s2">current = current.child;</span>
          <span class="s4">continue</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s4">if </span><span class="s2">(current === workInProgress) </span><span class="s4">break </span><span class="s2">a;</span>
        <span class="s4">for </span><span class="s2">(; </span><span class="s4">null </span><span class="s2">=== current.sibling; ) {</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== current.return || current.return === workInProgress)</span>
            <span class="s4">break </span><span class="s2">a;</span>
          <span class="s2">current = current.return;</span>
        <span class="s2">}</span>
        <span class="s2">current.sibling.return = current.return;</span>
        <span class="s2">current = current.sibling;</span>
      <span class="s2">}</span>
    <span class="s2">nextProps &amp;= </span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s2">push(suspenseStackCursor, nextProps);</span>
  <span class="s4">switch </span><span class="s2">(revealOrder) {</span>
    <span class="s4">case </span><span class="s3">&quot;forwards&quot;</span><span class="s2">:</span>
      <span class="s2">renderLanes = workInProgress.child;</span>
      <span class="s4">for </span><span class="s2">(revealOrder = </span><span class="s4">null</span><span class="s2">; </span><span class="s4">null </span><span class="s2">!== renderLanes; )</span>
        <span class="s2">(current = renderLanes.alternate),</span>
          <span class="s4">null </span><span class="s2">!== current &amp;&amp;</span>
            <span class="s4">null </span><span class="s2">=== findFirstSuspended(current) &amp;&amp;</span>
            <span class="s2">(revealOrder = renderLanes),</span>
          <span class="s2">(renderLanes = renderLanes.sibling);</span>
      <span class="s2">renderLanes = revealOrder;</span>
      <span class="s4">null </span><span class="s2">=== renderLanes</span>
        <span class="s2">? ((revealOrder = workInProgress.child), (workInProgress.child = </span><span class="s4">null</span><span class="s2">))</span>
        <span class="s2">: ((revealOrder = renderLanes.sibling), (renderLanes.sibling = </span><span class="s4">null</span><span class="s2">));</span>
      <span class="s2">initSuspenseListRenderState(</span>
        <span class="s2">workInProgress,</span>
        <span class="s2">!</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s2">revealOrder,</span>
        <span class="s2">renderLanes,</span>
        <span class="s2">tailMode</span>
      <span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;backwards&quot;</span><span class="s2">:</span>
      <span class="s2">renderLanes = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">revealOrder = workInProgress.child;</span>
      <span class="s4">for </span><span class="s2">(workInProgress.child = </span><span class="s4">null</span><span class="s2">; </span><span class="s4">null </span><span class="s2">!== revealOrder; ) {</span>
        <span class="s2">current = revealOrder.alternate;</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== current &amp;&amp; </span><span class="s4">null </span><span class="s2">=== findFirstSuspended(current)) {</span>
          <span class="s2">workInProgress.child = revealOrder;</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s2">current = revealOrder.sibling;</span>
        <span class="s2">revealOrder.sibling = renderLanes;</span>
        <span class="s2">renderLanes = revealOrder;</span>
        <span class="s2">revealOrder = current;</span>
      <span class="s2">}</span>
      <span class="s2">initSuspenseListRenderState(</span>
        <span class="s2">workInProgress,</span>
        <span class="s2">!</span><span class="s5">0</span><span class="s2">,</span>
        <span class="s2">renderLanes,</span>
        <span class="s4">null</span><span class="s2">,</span>
        <span class="s2">tailMode</span>
      <span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;together&quot;</span><span class="s2">:</span>
      <span class="s2">initSuspenseListRenderState(workInProgress, !</span><span class="s5">1</span><span class="s2">, </span><span class="s4">null</span><span class="s2">, </span><span class="s4">null</span><span class="s2">, </span><span class="s4">void </span><span class="s5">0</span><span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s2">workInProgress.memoizedState = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">workInProgress.child;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {</span>
  <span class="s4">null </span><span class="s2">!== current &amp;&amp; (workInProgress.dependencies = current.dependencies);</span>
  <span class="s2">profilerStartTime = -</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">workInProgressRootSkippedLanes |= workInProgress.lanes;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== (renderLanes &amp; workInProgress.childLanes))</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== current) {</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">(propagateParentContextChanges(</span>
          <span class="s2">current,</span>
          <span class="s2">workInProgress,</span>
          <span class="s2">renderLanes,</span>
          <span class="s2">!</span><span class="s5">1</span>
        <span class="s2">),</span>
        <span class="s5">0 </span><span class="s2">=== (renderLanes &amp; workInProgress.childLanes))</span>
      <span class="s2">)</span>
        <span class="s4">return null</span><span class="s2">;</span>
    <span class="s2">} </span><span class="s4">else return null</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== current &amp;&amp; workInProgress.child !== current.child)</span>
    <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">153</span><span class="s2">));</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== workInProgress.child) {</span>
    <span class="s2">current = workInProgress.child;</span>
    <span class="s2">renderLanes = createWorkInProgress(current, current.pendingProps);</span>
    <span class="s2">workInProgress.child = renderLanes;</span>
    <span class="s4">for </span><span class="s2">(renderLanes.return = workInProgress; </span><span class="s4">null </span><span class="s2">!== current.sibling; )</span>
      <span class="s2">(current = current.sibling),</span>
        <span class="s2">(renderLanes = renderLanes.sibling =</span>
          <span class="s2">createWorkInProgress(current, current.pendingProps)),</span>
        <span class="s2">(renderLanes.return = workInProgress);</span>
    <span class="s2">renderLanes.sibling = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">workInProgress.child;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">checkScheduledUpdateOrContext(current, renderLanes) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (current.lanes &amp; renderLanes)) </span><span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">current = current.dependencies;</span>
  <span class="s4">return null </span><span class="s2">!== current &amp;&amp; checkIfContextChanged(current) ? !</span><span class="s5">0 </span><span class="s2">: !</span><span class="s5">1</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">attemptEarlyBailoutIfNoScheduledUpdate(</span>
  <span class="s2">current,</span>
  <span class="s2">workInProgress,</span>
  <span class="s2">renderLanes</span>
<span class="s2">) {</span>
  <span class="s4">switch </span><span class="s2">(workInProgress.tag) {</span>
    <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
      <span class="s2">pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);</span>
      <span class="s2">pushProvider(workInProgress, CacheContext, current.memoizedState.cache);</span>
      <span class="s2">resetHydrationState();</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">27</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
      <span class="s2">pushHostContext(workInProgress);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">4</span><span class="s2">:</span>
      <span class="s2">pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">10</span><span class="s2">:</span>
      <span class="s2">pushProvider(</span>
        <span class="s2">workInProgress,</span>
        <span class="s2">workInProgress.type,</span>
        <span class="s2">workInProgress.memoizedProps.value</span>
      <span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">12</span><span class="s2">:</span>
      <span class="s5">0 </span><span class="s2">!== (renderLanes &amp; workInProgress.childLanes) &amp;&amp;</span>
        <span class="s2">(workInProgress.flags |= </span><span class="s5">4</span><span class="s2">);</span>
      <span class="s2">workInProgress.flags |= </span><span class="s5">2048</span><span class="s2">;</span>
      <span class="s4">var </span><span class="s2">stateNode = workInProgress.stateNode;</span>
      <span class="s2">stateNode.effectDuration = -</span><span class="s5">0</span><span class="s2">;</span>
      <span class="s2">stateNode.passiveEffectDuration = -</span><span class="s5">0</span><span class="s2">;</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">13</span><span class="s2">:</span>
      <span class="s2">stateNode = workInProgress.memoizedState;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== stateNode) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== stateNode.dehydrated)</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s2">pushPrimaryTreeSuspenseHandler(workInProgress),</span>
            <span class="s2">(workInProgress.flags |= </span><span class="s5">128</span><span class="s2">),</span>
            <span class="s4">null</span>
          <span class="s2">);</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (renderLanes &amp; workInProgress.child.childLanes))</span>
          <span class="s4">return </span><span class="s2">updateSuspenseComponent(current, workInProgress, renderLanes);</span>
        <span class="s2">pushPrimaryTreeSuspenseHandler(workInProgress);</span>
        <span class="s2">current = bailoutOnAlreadyFinishedWork(</span>
          <span class="s2">current,</span>
          <span class="s2">workInProgress,</span>
          <span class="s2">renderLanes</span>
        <span class="s2">);</span>
        <span class="s4">return null </span><span class="s2">!== current ? current.sibling : </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s2">pushPrimaryTreeSuspenseHandler(workInProgress);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">19</span><span class="s2">:</span>
      <span class="s4">var </span><span class="s2">didSuspendBefore = </span><span class="s5">0 </span><span class="s2">!== (current.flags &amp; </span><span class="s5">128</span><span class="s2">);</span>
      <span class="s2">stateNode = </span><span class="s5">0 </span><span class="s2">!== (renderLanes &amp; workInProgress.childLanes);</span>
      <span class="s2">stateNode ||</span>
        <span class="s2">(propagateParentContextChanges(</span>
          <span class="s2">current,</span>
          <span class="s2">workInProgress,</span>
          <span class="s2">renderLanes,</span>
          <span class="s2">!</span><span class="s5">1</span>
        <span class="s2">),</span>
        <span class="s2">(stateNode = </span><span class="s5">0 </span><span class="s2">!== (renderLanes &amp; workInProgress.childLanes)));</span>
      <span class="s4">if </span><span class="s2">(didSuspendBefore) {</span>
        <span class="s4">if </span><span class="s2">(stateNode)</span>
          <span class="s4">return </span><span class="s2">updateSuspenseListComponent(</span>
            <span class="s2">current,</span>
            <span class="s2">workInProgress,</span>
            <span class="s2">renderLanes</span>
          <span class="s2">);</span>
        <span class="s2">workInProgress.flags |= </span><span class="s5">128</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s2">didSuspendBefore = workInProgress.memoizedState;</span>
      <span class="s4">null </span><span class="s2">!== didSuspendBefore &amp;&amp;</span>
        <span class="s2">((didSuspendBefore.rendering = </span><span class="s4">null</span><span class="s2">),</span>
        <span class="s2">(didSuspendBefore.tail = </span><span class="s4">null</span><span class="s2">),</span>
        <span class="s2">(didSuspendBefore.lastEffect = </span><span class="s4">null</span><span class="s2">));</span>
      <span class="s2">push(suspenseStackCursor, suspenseStackCursor.current);</span>
      <span class="s4">if </span><span class="s2">(stateNode) </span><span class="s4">break</span><span class="s2">;</span>
      <span class="s4">else return null</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">22</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">23</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(workInProgress.lanes = </span><span class="s5">0</span><span class="s2">),</span>
        <span class="s2">updateOffscreenComponent(current, workInProgress, renderLanes)</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">24</span><span class="s2">:</span>
      <span class="s2">pushProvider(workInProgress, CacheContext, current.memoizedState.cache);</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">beginWork(current, workInProgress, renderLanes) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== current)</span>
    <span class="s4">if </span><span class="s2">(current.memoizedProps !== workInProgress.pendingProps)</span>
      <span class="s2">didReceiveUpdate = !</span><span class="s5">0</span><span class="s2">;</span>
    <span class="s4">else </span><span class="s2">{</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">!checkScheduledUpdateOrContext(current, renderLanes) &amp;&amp;</span>
        <span class="s5">0 </span><span class="s2">=== (workInProgress.flags &amp; </span><span class="s5">128</span><span class="s2">)</span>
      <span class="s2">)</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(didReceiveUpdate = !</span><span class="s5">1</span><span class="s2">),</span>
          <span class="s2">attemptEarlyBailoutIfNoScheduledUpdate(</span>
            <span class="s2">current,</span>
            <span class="s2">workInProgress,</span>
            <span class="s2">renderLanes</span>
          <span class="s2">)</span>
        <span class="s2">);</span>
      <span class="s2">didReceiveUpdate = </span><span class="s5">0 </span><span class="s2">!== (current.flags &amp; </span><span class="s5">131072</span><span class="s2">) ? !</span><span class="s5">0 </span><span class="s2">: !</span><span class="s5">1</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s4">else</span>
    <span class="s2">(didReceiveUpdate = !</span><span class="s5">1</span><span class="s2">),</span>
      <span class="s2">isHydrating &amp;&amp;</span>
        <span class="s5">0 </span><span class="s2">!== (workInProgress.flags &amp; </span><span class="s5">1048576</span><span class="s2">) &amp;&amp;</span>
        <span class="s2">pushTreeId(workInProgress, treeForkCount, workInProgress.index);</span>
  <span class="s2">workInProgress.lanes = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">switch </span><span class="s2">(workInProgress.tag) {</span>
    <span class="s4">case </span><span class="s5">16</span><span class="s2">:</span>
      <span class="s2">a: {</span>
        <span class="s2">current = workInProgress.pendingProps;</span>
        <span class="s4">var </span><span class="s2">lazyComponent = workInProgress.elementType,</span>
          <span class="s2">init = lazyComponent._init;</span>
        <span class="s2">lazyComponent = init(lazyComponent._payload);</span>
        <span class="s2">workInProgress.type = lazyComponent;</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">lazyComponent)</span>
          <span class="s2">shouldConstruct(lazyComponent)</span>
            <span class="s2">? ((current = resolveClassComponentProps(lazyComponent, current)),</span>
              <span class="s2">(workInProgress.tag = </span><span class="s5">1</span><span class="s2">),</span>
              <span class="s2">(workInProgress = updateClassComponent(</span>
                <span class="s4">null</span><span class="s2">,</span>
                <span class="s2">workInProgress,</span>
                <span class="s2">lazyComponent,</span>
                <span class="s2">current,</span>
                <span class="s2">renderLanes</span>
              <span class="s2">)))</span>
            <span class="s2">: ((workInProgress.tag = </span><span class="s5">0</span><span class="s2">),</span>
              <span class="s2">(workInProgress = updateFunctionComponent(</span>
                <span class="s4">null</span><span class="s2">,</span>
                <span class="s2">workInProgress,</span>
                <span class="s2">lazyComponent,</span>
                <span class="s2">current,</span>
                <span class="s2">renderLanes</span>
              <span class="s2">)));</span>
        <span class="s4">else </span><span class="s2">{</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== lazyComponent &amp;&amp; </span><span class="s4">null </span><span class="s2">!== lazyComponent)</span>
            <span class="s4">if </span><span class="s2">(</span>
              <span class="s2">((init = lazyComponent.$$typeof), init === REACT_FORWARD_REF_TYPE)</span>
            <span class="s2">) {</span>
              <span class="s2">workInProgress.tag = </span><span class="s5">11</span><span class="s2">;</span>
              <span class="s2">workInProgress = updateForwardRef(</span>
                <span class="s4">null</span><span class="s2">,</span>
                <span class="s2">workInProgress,</span>
                <span class="s2">lazyComponent,</span>
                <span class="s2">current,</span>
                <span class="s2">renderLanes</span>
              <span class="s2">);</span>
              <span class="s4">break </span><span class="s2">a;</span>
            <span class="s2">} </span><span class="s4">else if </span><span class="s2">(init === REACT_MEMO_TYPE) {</span>
              <span class="s2">workInProgress.tag = </span><span class="s5">14</span><span class="s2">;</span>
              <span class="s2">workInProgress = updateMemoComponent(</span>
                <span class="s4">null</span><span class="s2">,</span>
                <span class="s2">workInProgress,</span>
                <span class="s2">lazyComponent,</span>
                <span class="s2">current,</span>
                <span class="s2">renderLanes</span>
              <span class="s2">);</span>
              <span class="s4">break </span><span class="s2">a;</span>
            <span class="s2">}</span>
          <span class="s2">workInProgress =</span>
            <span class="s2">getComponentNameFromType(lazyComponent) || lazyComponent;</span>
          <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">306</span><span class="s2">, workInProgress, </span><span class="s3">&quot;&quot;</span><span class="s2">));</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s2">workInProgress;</span>
    <span class="s4">case </span><span class="s5">0</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">updateFunctionComponent(</span>
        <span class="s2">current,</span>
        <span class="s2">workInProgress,</span>
        <span class="s2">workInProgress.type,</span>
        <span class="s2">workInProgress.pendingProps,</span>
        <span class="s2">renderLanes</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(lazyComponent = workInProgress.type),</span>
        <span class="s2">(init = resolveClassComponentProps(</span>
          <span class="s2">lazyComponent,</span>
          <span class="s2">workInProgress.pendingProps</span>
        <span class="s2">)),</span>
        <span class="s2">updateClassComponent(</span>
          <span class="s2">current,</span>
          <span class="s2">workInProgress,</span>
          <span class="s2">lazyComponent,</span>
          <span class="s2">init,</span>
          <span class="s2">renderLanes</span>
        <span class="s2">)</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
      <span class="s2">a: {</span>
        <span class="s2">pushHostContainer(</span>
          <span class="s2">workInProgress,</span>
          <span class="s2">workInProgress.stateNode.containerInfo</span>
        <span class="s2">);</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== current) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">387</span><span class="s2">));</span>
        <span class="s2">lazyComponent = workInProgress.pendingProps;</span>
        <span class="s4">var </span><span class="s2">prevState = workInProgress.memoizedState;</span>
        <span class="s2">init = prevState.element;</span>
        <span class="s2">cloneUpdateQueue(current, workInProgress);</span>
        <span class="s2">processUpdateQueue(workInProgress, lazyComponent, </span><span class="s4">null</span><span class="s2">, renderLanes);</span>
        <span class="s4">var </span><span class="s2">nextState = workInProgress.memoizedState;</span>
        <span class="s2">lazyComponent = nextState.cache;</span>
        <span class="s2">pushProvider(workInProgress, CacheContext, lazyComponent);</span>
        <span class="s2">lazyComponent !== prevState.cache &amp;&amp;</span>
          <span class="s2">propagateContextChanges(</span>
            <span class="s2">workInProgress,</span>
            <span class="s2">[CacheContext],</span>
            <span class="s2">renderLanes,</span>
            <span class="s2">!</span><span class="s5">0</span>
          <span class="s2">);</span>
        <span class="s2">suspendIfUpdateReadFromEntangledAsyncAction();</span>
        <span class="s2">lazyComponent = nextState.element;</span>
        <span class="s4">if </span><span class="s2">(prevState.isDehydrated)</span>
          <span class="s4">if </span><span class="s2">(</span>
            <span class="s2">((prevState = {</span>
              <span class="s2">element: lazyComponent,</span>
              <span class="s2">isDehydrated: !</span><span class="s5">1</span><span class="s2">,</span>
              <span class="s2">cache: nextState.cache</span>
            <span class="s2">}),</span>
            <span class="s2">(workInProgress.updateQueue.baseState = prevState),</span>
            <span class="s2">(workInProgress.memoizedState = prevState),</span>
            <span class="s2">workInProgress.flags &amp; </span><span class="s5">256</span><span class="s2">)</span>
          <span class="s2">) {</span>
            <span class="s2">workInProgress = mountHostRootWithoutHydrating(</span>
              <span class="s2">current,</span>
              <span class="s2">workInProgress,</span>
              <span class="s2">lazyComponent,</span>
              <span class="s2">renderLanes</span>
            <span class="s2">);</span>
            <span class="s4">break </span><span class="s2">a;</span>
          <span class="s2">} </span><span class="s4">else if </span><span class="s2">(lazyComponent !== init) {</span>
            <span class="s2">init = createCapturedValueAtFiber(</span>
              <span class="s2">Error(formatProdErrorMessage(</span><span class="s5">424</span><span class="s2">)),</span>
              <span class="s2">workInProgress</span>
            <span class="s2">);</span>
            <span class="s2">queueHydrationError(init);</span>
            <span class="s2">workInProgress = mountHostRootWithoutHydrating(</span>
              <span class="s2">current,</span>
              <span class="s2">workInProgress,</span>
              <span class="s2">lazyComponent,</span>
              <span class="s2">renderLanes</span>
            <span class="s2">);</span>
            <span class="s4">break </span><span class="s2">a;</span>
          <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
            <span class="s2">current = workInProgress.stateNode.containerInfo;</span>
            <span class="s4">switch </span><span class="s2">(current.nodeType) {</span>
              <span class="s4">case </span><span class="s5">9</span><span class="s2">:</span>
                <span class="s2">current = current.body;</span>
                <span class="s4">break</span><span class="s2">;</span>
              <span class="s4">default</span><span class="s2">:</span>
                <span class="s2">current =</span>
                  <span class="s3">&quot;HTML&quot; </span><span class="s2">=== current.nodeName</span>
                    <span class="s2">? current.ownerDocument.body</span>
                    <span class="s2">: current;</span>
            <span class="s2">}</span>
            <span class="s2">nextHydratableInstance = getNextHydratable(current.firstChild);</span>
            <span class="s2">hydrationParentFiber = workInProgress;</span>
            <span class="s2">isHydrating = !</span><span class="s5">0</span><span class="s2">;</span>
            <span class="s2">hydrationErrors = </span><span class="s4">null</span><span class="s2">;</span>
            <span class="s2">rootOrSingletonContext = !</span><span class="s5">0</span><span class="s2">;</span>
            <span class="s2">renderLanes = mountChildFibers(</span>
              <span class="s2">workInProgress,</span>
              <span class="s4">null</span><span class="s2">,</span>
              <span class="s2">lazyComponent,</span>
              <span class="s2">renderLanes</span>
            <span class="s2">);</span>
            <span class="s4">for </span><span class="s2">(workInProgress.child = renderLanes; renderLanes; )</span>
              <span class="s2">(renderLanes.flags = (renderLanes.flags &amp; -</span><span class="s5">3</span><span class="s2">) | </span><span class="s5">4096</span><span class="s2">),</span>
                <span class="s2">(renderLanes = renderLanes.sibling);</span>
          <span class="s2">}</span>
        <span class="s4">else </span><span class="s2">{</span>
          <span class="s2">resetHydrationState();</span>
          <span class="s4">if </span><span class="s2">(lazyComponent === init) {</span>
            <span class="s2">workInProgress = bailoutOnAlreadyFinishedWork(</span>
              <span class="s2">current,</span>
              <span class="s2">workInProgress,</span>
              <span class="s2">renderLanes</span>
            <span class="s2">);</span>
            <span class="s4">break </span><span class="s2">a;</span>
          <span class="s2">}</span>
          <span class="s2">reconcileChildren(</span>
            <span class="s2">current,</span>
            <span class="s2">workInProgress,</span>
            <span class="s2">lazyComponent,</span>
            <span class="s2">renderLanes</span>
          <span class="s2">);</span>
        <span class="s2">}</span>
        <span class="s2">workInProgress = workInProgress.child;</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s2">workInProgress;</span>
    <span class="s4">case </span><span class="s5">26</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">markRef(current, workInProgress),</span>
        <span class="s4">null </span><span class="s2">=== current</span>
          <span class="s2">? (renderLanes = getResource(</span>
              <span class="s2">workInProgress.type,</span>
              <span class="s4">null</span><span class="s2">,</span>
              <span class="s2">workInProgress.pendingProps,</span>
              <span class="s4">null</span>
            <span class="s2">))</span>
            <span class="s2">? (workInProgress.memoizedState = renderLanes)</span>
            <span class="s2">: isHydrating ||</span>
              <span class="s2">((renderLanes = workInProgress.type),</span>
              <span class="s2">(current = workInProgress.pendingProps),</span>
              <span class="s2">(lazyComponent = getOwnerDocumentFromRootContainer(</span>
                <span class="s2">rootInstanceStackCursor.current</span>
              <span class="s2">).createElement(renderLanes)),</span>
              <span class="s2">(lazyComponent[internalInstanceKey] = workInProgress),</span>
              <span class="s2">(lazyComponent[internalPropsKey] = current),</span>
              <span class="s2">setInitialProperties(lazyComponent, renderLanes, current),</span>
              <span class="s2">markNodeAsHoistable(lazyComponent),</span>
              <span class="s2">(workInProgress.stateNode = lazyComponent))</span>
          <span class="s2">: (workInProgress.memoizedState = getResource(</span>
              <span class="s2">workInProgress.type,</span>
              <span class="s2">current.memoizedProps,</span>
              <span class="s2">workInProgress.pendingProps,</span>
              <span class="s2">current.memoizedState</span>
            <span class="s2">)),</span>
        <span class="s4">null</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">27</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">pushHostContext(workInProgress),</span>
        <span class="s4">null </span><span class="s2">=== current &amp;&amp;</span>
          <span class="s2">isHydrating &amp;&amp;</span>
          <span class="s2">((lazyComponent = workInProgress.stateNode =</span>
            <span class="s2">resolveSingletonInstance(</span>
              <span class="s2">workInProgress.type,</span>
              <span class="s2">workInProgress.pendingProps,</span>
              <span class="s2">rootInstanceStackCursor.current</span>
            <span class="s2">)),</span>
          <span class="s2">(hydrationParentFiber = workInProgress),</span>
          <span class="s2">(rootOrSingletonContext = !</span><span class="s5">0</span><span class="s2">),</span>
          <span class="s2">(init = nextHydratableInstance),</span>
          <span class="s2">isSingletonScope(workInProgress.type)</span>
            <span class="s2">? ((previousHydratableOnEnteringScopedSingleton = init),</span>
              <span class="s2">(nextHydratableInstance = getNextHydratable(</span>
                <span class="s2">lazyComponent.firstChild</span>
              <span class="s2">)))</span>
            <span class="s2">: (nextHydratableInstance = init)),</span>
        <span class="s2">reconcileChildren(</span>
          <span class="s2">current,</span>
          <span class="s2">workInProgress,</span>
          <span class="s2">workInProgress.pendingProps.children,</span>
          <span class="s2">renderLanes</span>
        <span class="s2">),</span>
        <span class="s2">markRef(current, workInProgress),</span>
        <span class="s4">null </span><span class="s2">=== current &amp;&amp; (workInProgress.flags |= </span><span class="s5">4194304</span><span class="s2">),</span>
        <span class="s2">workInProgress.child</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== current &amp;&amp; isHydrating) {</span>
        <span class="s4">if </span><span class="s2">((init = lazyComponent = nextHydratableInstance))</span>
          <span class="s2">(lazyComponent = canHydrateInstance(</span>
            <span class="s2">lazyComponent,</span>
            <span class="s2">workInProgress.type,</span>
            <span class="s2">workInProgress.pendingProps,</span>
            <span class="s2">rootOrSingletonContext</span>
          <span class="s2">)),</span>
            <span class="s4">null </span><span class="s2">!== lazyComponent</span>
              <span class="s2">? ((workInProgress.stateNode = lazyComponent),</span>
                <span class="s2">(hydrationParentFiber = workInProgress),</span>
                <span class="s2">(nextHydratableInstance = getNextHydratable(</span>
                  <span class="s2">lazyComponent.firstChild</span>
                <span class="s2">)),</span>
                <span class="s2">(rootOrSingletonContext = !</span><span class="s5">1</span><span class="s2">),</span>
                <span class="s2">(init = !</span><span class="s5">0</span><span class="s2">))</span>
              <span class="s2">: (init = !</span><span class="s5">1</span><span class="s2">);</span>
        <span class="s2">init || throwOnHydrationMismatch(workInProgress);</span>
      <span class="s2">}</span>
      <span class="s2">pushHostContext(workInProgress);</span>
      <span class="s2">init = workInProgress.type;</span>
      <span class="s2">prevState = workInProgress.pendingProps;</span>
      <span class="s2">nextState = </span><span class="s4">null </span><span class="s2">!== current ? current.memoizedProps : </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">lazyComponent = prevState.children;</span>
      <span class="s2">shouldSetTextContent(init, prevState)</span>
        <span class="s2">? (lazyComponent = </span><span class="s4">null</span><span class="s2">)</span>
        <span class="s2">: </span><span class="s4">null </span><span class="s2">!== nextState &amp;&amp;</span>
          <span class="s2">shouldSetTextContent(init, nextState) &amp;&amp;</span>
          <span class="s2">(workInProgress.flags |= </span><span class="s5">32</span><span class="s2">);</span>
      <span class="s4">null </span><span class="s2">!== workInProgress.memoizedState &amp;&amp;</span>
        <span class="s2">((init = renderWithHooks(</span>
          <span class="s2">current,</span>
          <span class="s2">workInProgress,</span>
          <span class="s2">TransitionAwareHostComponent,</span>
          <span class="s4">null</span><span class="s2">,</span>
          <span class="s4">null</span><span class="s2">,</span>
          <span class="s2">renderLanes</span>
        <span class="s2">)),</span>
        <span class="s2">(HostTransitionContext._currentValue = init));</span>
      <span class="s2">markRef(current, workInProgress);</span>
      <span class="s2">reconcileChildren(current, workInProgress, lazyComponent, renderLanes);</span>
      <span class="s4">return </span><span class="s2">workInProgress.child;</span>
    <span class="s4">case </span><span class="s5">6</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== current &amp;&amp; isHydrating) {</span>
        <span class="s4">if </span><span class="s2">((current = renderLanes = nextHydratableInstance))</span>
          <span class="s2">(renderLanes = canHydrateTextInstance(</span>
            <span class="s2">renderLanes,</span>
            <span class="s2">workInProgress.pendingProps,</span>
            <span class="s2">rootOrSingletonContext</span>
          <span class="s2">)),</span>
            <span class="s4">null </span><span class="s2">!== renderLanes</span>
              <span class="s2">? ((workInProgress.stateNode = renderLanes),</span>
                <span class="s2">(hydrationParentFiber = workInProgress),</span>
                <span class="s2">(nextHydratableInstance = </span><span class="s4">null</span><span class="s2">),</span>
                <span class="s2">(current = !</span><span class="s5">0</span><span class="s2">))</span>
              <span class="s2">: (current = !</span><span class="s5">1</span><span class="s2">);</span>
        <span class="s2">current || throwOnHydrationMismatch(workInProgress);</span>
      <span class="s2">}</span>
      <span class="s4">return null</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">13</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">updateSuspenseComponent(current, workInProgress, renderLanes);</span>
    <span class="s4">case </span><span class="s5">4</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">pushHostContainer(</span>
          <span class="s2">workInProgress,</span>
          <span class="s2">workInProgress.stateNode.containerInfo</span>
        <span class="s2">),</span>
        <span class="s2">(lazyComponent = workInProgress.pendingProps),</span>
        <span class="s4">null </span><span class="s2">=== current</span>
          <span class="s2">? (workInProgress.child = reconcileChildFibers(</span>
              <span class="s2">workInProgress,</span>
              <span class="s4">null</span><span class="s2">,</span>
              <span class="s2">lazyComponent,</span>
              <span class="s2">renderLanes</span>
            <span class="s2">))</span>
          <span class="s2">: reconcileChildren(</span>
              <span class="s2">current,</span>
              <span class="s2">workInProgress,</span>
              <span class="s2">lazyComponent,</span>
              <span class="s2">renderLanes</span>
            <span class="s2">),</span>
        <span class="s2">workInProgress.child</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">11</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">updateForwardRef(</span>
        <span class="s2">current,</span>
        <span class="s2">workInProgress,</span>
        <span class="s2">workInProgress.type,</span>
        <span class="s2">workInProgress.pendingProps,</span>
        <span class="s2">renderLanes</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">7</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">reconcileChildren(</span>
          <span class="s2">current,</span>
          <span class="s2">workInProgress,</span>
          <span class="s2">workInProgress.pendingProps,</span>
          <span class="s2">renderLanes</span>
        <span class="s2">),</span>
        <span class="s2">workInProgress.child</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">8</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">reconcileChildren(</span>
          <span class="s2">current,</span>
          <span class="s2">workInProgress,</span>
          <span class="s2">workInProgress.pendingProps.children,</span>
          <span class="s2">renderLanes</span>
        <span class="s2">),</span>
        <span class="s2">workInProgress.child</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">12</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(workInProgress.flags |= </span><span class="s5">4</span><span class="s2">),</span>
        <span class="s2">(workInProgress.flags |= </span><span class="s5">2048</span><span class="s2">),</span>
        <span class="s2">(lazyComponent = workInProgress.stateNode),</span>
        <span class="s2">(lazyComponent.effectDuration = -</span><span class="s5">0</span><span class="s2">),</span>
        <span class="s2">(lazyComponent.passiveEffectDuration = -</span><span class="s5">0</span><span class="s2">),</span>
        <span class="s2">reconcileChildren(</span>
          <span class="s2">current,</span>
          <span class="s2">workInProgress,</span>
          <span class="s2">workInProgress.pendingProps.children,</span>
          <span class="s2">renderLanes</span>
        <span class="s2">),</span>
        <span class="s2">workInProgress.child</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">10</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(lazyComponent = workInProgress.pendingProps),</span>
        <span class="s2">pushProvider(workInProgress, workInProgress.type, lazyComponent.value),</span>
        <span class="s2">reconcileChildren(</span>
          <span class="s2">current,</span>
          <span class="s2">workInProgress,</span>
          <span class="s2">lazyComponent.children,</span>
          <span class="s2">renderLanes</span>
        <span class="s2">),</span>
        <span class="s2">workInProgress.child</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">9</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(init = workInProgress.type._context),</span>
        <span class="s2">(lazyComponent = workInProgress.pendingProps.children),</span>
        <span class="s2">prepareToReadContext(workInProgress),</span>
        <span class="s2">(init = readContext(init)),</span>
        <span class="s2">markComponentRenderStarted(workInProgress),</span>
        <span class="s2">(lazyComponent = lazyComponent(init)),</span>
        <span class="s2">markComponentRenderStopped(),</span>
        <span class="s2">(workInProgress.flags |= </span><span class="s5">1</span><span class="s2">),</span>
        <span class="s2">reconcileChildren(current, workInProgress, lazyComponent, renderLanes),</span>
        <span class="s2">workInProgress.child</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">14</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">updateMemoComponent(</span>
        <span class="s2">current,</span>
        <span class="s2">workInProgress,</span>
        <span class="s2">workInProgress.type,</span>
        <span class="s2">workInProgress.pendingProps,</span>
        <span class="s2">renderLanes</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">15</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">updateSimpleMemoComponent(</span>
        <span class="s2">current,</span>
        <span class="s2">workInProgress,</span>
        <span class="s2">workInProgress.type,</span>
        <span class="s2">workInProgress.pendingProps,</span>
        <span class="s2">renderLanes</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">19</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">updateSuspenseListComponent(current, workInProgress, renderLanes);</span>
    <span class="s4">case </span><span class="s5">31</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(lazyComponent = workInProgress.pendingProps),</span>
        <span class="s2">(renderLanes = workInProgress.mode),</span>
        <span class="s2">(lazyComponent = {</span>
          <span class="s2">mode: lazyComponent.mode,</span>
          <span class="s2">children: lazyComponent.children</span>
        <span class="s2">}),</span>
        <span class="s4">null </span><span class="s2">=== current</span>
          <span class="s2">? ((renderLanes = mountWorkInProgressOffscreenFiber(</span>
              <span class="s2">lazyComponent,</span>
              <span class="s2">renderLanes</span>
            <span class="s2">)),</span>
            <span class="s2">(renderLanes.ref = workInProgress.ref),</span>
            <span class="s2">(workInProgress.child = renderLanes),</span>
            <span class="s2">(renderLanes.return = workInProgress),</span>
            <span class="s2">(workInProgress = renderLanes))</span>
          <span class="s2">: ((renderLanes = createWorkInProgress(current.child, lazyComponent)),</span>
            <span class="s2">(renderLanes.ref = workInProgress.ref),</span>
            <span class="s2">(workInProgress.child = renderLanes),</span>
            <span class="s2">(renderLanes.return = workInProgress),</span>
            <span class="s2">(workInProgress = renderLanes)),</span>
        <span class="s2">workInProgress</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">22</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">updateOffscreenComponent(current, workInProgress, renderLanes);</span>
    <span class="s4">case </span><span class="s5">24</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">prepareToReadContext(workInProgress),</span>
        <span class="s2">(lazyComponent = readContext(CacheContext)),</span>
        <span class="s4">null </span><span class="s2">=== current</span>
          <span class="s2">? ((init = peekCacheFromPool()),</span>
            <span class="s4">null </span><span class="s2">=== init &amp;&amp;</span>
              <span class="s2">((init = workInProgressRoot),</span>
              <span class="s2">(prevState = createCache()),</span>
              <span class="s2">(init.pooledCache = prevState),</span>
              <span class="s2">prevState.refCount++,</span>
              <span class="s4">null </span><span class="s2">!== prevState &amp;&amp; (init.pooledCacheLanes |= renderLanes),</span>
              <span class="s2">(init = prevState)),</span>
            <span class="s2">(workInProgress.memoizedState = {</span>
              <span class="s2">parent: lazyComponent,</span>
              <span class="s2">cache: init</span>
            <span class="s2">}),</span>
            <span class="s2">initializeUpdateQueue(workInProgress),</span>
            <span class="s2">pushProvider(workInProgress, CacheContext, init))</span>
          <span class="s2">: (</span><span class="s5">0 </span><span class="s2">!== (current.lanes &amp; renderLanes) &amp;&amp;</span>
              <span class="s2">(cloneUpdateQueue(current, workInProgress),</span>
              <span class="s2">processUpdateQueue(workInProgress, </span><span class="s4">null</span><span class="s2">, </span><span class="s4">null</span><span class="s2">, renderLanes),</span>
              <span class="s2">suspendIfUpdateReadFromEntangledAsyncAction()),</span>
            <span class="s2">(init = current.memoizedState),</span>
            <span class="s2">(prevState = workInProgress.memoizedState),</span>
            <span class="s2">init.parent !== lazyComponent</span>
              <span class="s2">? ((init = { parent: lazyComponent, cache: lazyComponent }),</span>
                <span class="s2">(workInProgress.memoizedState = init),</span>
                <span class="s5">0 </span><span class="s2">=== workInProgress.lanes &amp;&amp;</span>
                  <span class="s2">(workInProgress.memoizedState =</span>
                    <span class="s2">workInProgress.updateQueue.baseState =</span>
                      <span class="s2">init),</span>
                <span class="s2">pushProvider(workInProgress, CacheContext, lazyComponent))</span>
              <span class="s2">: ((lazyComponent = prevState.cache),</span>
                <span class="s2">pushProvider(workInProgress, CacheContext, lazyComponent),</span>
                <span class="s2">lazyComponent !== init.cache &amp;&amp;</span>
                  <span class="s2">propagateContextChanges(</span>
                    <span class="s2">workInProgress,</span>
                    <span class="s2">[CacheContext],</span>
                    <span class="s2">renderLanes,</span>
                    <span class="s2">!</span><span class="s5">0</span>
                  <span class="s2">))),</span>
        <span class="s2">reconcileChildren(</span>
          <span class="s2">current,</span>
          <span class="s2">workInProgress,</span>
          <span class="s2">workInProgress.pendingProps.children,</span>
          <span class="s2">renderLanes</span>
        <span class="s2">),</span>
        <span class="s2">workInProgress.child</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">29</span><span class="s2">:</span>
      <span class="s4">throw </span><span class="s2">workInProgress.pendingProps;</span>
  <span class="s2">}</span>
  <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">156</span><span class="s2">, workInProgress.tag));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">markUpdate(workInProgress) {</span>
  <span class="s2">workInProgress.flags |= </span><span class="s5">4</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">preloadResourceAndSuspendIfNeeded(workInProgress, resource) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;stylesheet&quot; </span><span class="s2">!== resource.type || </span><span class="s5">0 </span><span class="s2">!== (resource.state.loading &amp; </span><span class="s5">4</span><span class="s2">))</span>
    <span class="s2">workInProgress.flags &amp;= -</span><span class="s5">16777217</span><span class="s2">;</span>
  <span class="s4">else if </span><span class="s2">(((workInProgress.flags |= </span><span class="s5">16777216</span><span class="s2">), !preloadResource(resource))) {</span>
    <span class="s2">resource = suspenseHandlerStackCursor.current;</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s4">null </span><span class="s2">!== resource &amp;&amp;</span>
      <span class="s2">((workInProgressRootRenderLanes &amp; </span><span class="s5">4194048</span><span class="s2">) ===</span>
      <span class="s2">workInProgressRootRenderLanes</span>
        <span class="s2">? </span><span class="s4">null </span><span class="s2">!== shellBoundary</span>
        <span class="s2">: ((workInProgressRootRenderLanes &amp; </span><span class="s5">62914560</span><span class="s2">) !==</span>
            <span class="s2">workInProgressRootRenderLanes &amp;&amp;</span>
            <span class="s5">0 </span><span class="s2">=== (workInProgressRootRenderLanes &amp; </span><span class="s5">536870912</span><span class="s2">)) ||</span>
          <span class="s2">resource !== shellBoundary)</span>
    <span class="s2">)</span>
      <span class="s4">throw </span><span class="s2">(</span>
        <span class="s2">((suspendedThenable = noopSuspenseyCommitThenable),</span>
        <span class="s2">SuspenseyCommitException)</span>
      <span class="s2">);</span>
    <span class="s2">workInProgress.flags |= </span><span class="s5">8192</span><span class="s2">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">scheduleRetryEffect(workInProgress, retryQueue) {</span>
  <span class="s4">null </span><span class="s2">!== retryQueue &amp;&amp; (workInProgress.flags |= </span><span class="s5">4</span><span class="s2">);</span>
  <span class="s2">workInProgress.flags &amp; </span><span class="s5">16384 </span><span class="s2">&amp;&amp;</span>
    <span class="s2">((retryQueue =</span>
      <span class="s5">22 </span><span class="s2">!== workInProgress.tag ? claimNextRetryLane() : </span><span class="s5">536870912</span><span class="s2">),</span>
    <span class="s2">(workInProgress.lanes |= retryQueue),</span>
    <span class="s2">(workInProgressSuspendedRetryLanes |= retryQueue));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {</span>
  <span class="s4">if </span><span class="s2">(!isHydrating)</span>
    <span class="s4">switch </span><span class="s2">(renderState.tailMode) {</span>
      <span class="s4">case </span><span class="s3">&quot;hidden&quot;</span><span class="s2">:</span>
        <span class="s2">hasRenderedATailFallback = renderState.tail;</span>
        <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">lastTailNode = </span><span class="s4">null</span><span class="s2">; </span><span class="s4">null </span><span class="s2">!== hasRenderedATailFallback; )</span>
          <span class="s4">null </span><span class="s2">!== hasRenderedATailFallback.alternate &amp;&amp;</span>
            <span class="s2">(lastTailNode = hasRenderedATailFallback),</span>
            <span class="s2">(hasRenderedATailFallback = hasRenderedATailFallback.sibling);</span>
        <span class="s4">null </span><span class="s2">=== lastTailNode</span>
          <span class="s2">? (renderState.tail = </span><span class="s4">null</span><span class="s2">)</span>
          <span class="s2">: (lastTailNode.sibling = </span><span class="s4">null</span><span class="s2">);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s3">&quot;collapsed&quot;</span><span class="s2">:</span>
        <span class="s2">lastTailNode = renderState.tail;</span>
        <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">lastTailNode$116 = </span><span class="s4">null</span><span class="s2">; </span><span class="s4">null </span><span class="s2">!== lastTailNode; )</span>
          <span class="s4">null </span><span class="s2">!== lastTailNode.alternate &amp;&amp; (lastTailNode$116 = lastTailNode),</span>
            <span class="s2">(lastTailNode = lastTailNode.sibling);</span>
        <span class="s4">null </span><span class="s2">=== lastTailNode$116</span>
          <span class="s2">? hasRenderedATailFallback || </span><span class="s4">null </span><span class="s2">=== renderState.tail</span>
            <span class="s2">? (renderState.tail = </span><span class="s4">null</span><span class="s2">)</span>
            <span class="s2">: (renderState.tail.sibling = </span><span class="s4">null</span><span class="s2">)</span>
          <span class="s2">: (lastTailNode$116.sibling = </span><span class="s4">null</span><span class="s2">);</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">bubbleProperties(completedWork) {</span>
  <span class="s4">var </span><span class="s2">didBailout =</span>
      <span class="s4">null </span><span class="s2">!== completedWork.alternate &amp;&amp;</span>
      <span class="s2">completedWork.alternate.child === completedWork.child,</span>
    <span class="s2">newChildLanes = </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">subtreeFlags = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(didBailout)</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (completedWork.mode &amp; </span><span class="s5">2</span><span class="s2">)) {</span>
      <span class="s4">for </span><span class="s2">(</span>
        <span class="s4">var </span><span class="s2">treeBaseDuration$118 = completedWork.selfBaseDuration,</span>
          <span class="s2">child$119 = completedWork.child;</span>
        <span class="s4">null </span><span class="s2">!== child$119;</span>

      <span class="s2">)</span>
        <span class="s2">(newChildLanes |= child$119.lanes | child$119.childLanes),</span>
          <span class="s2">(subtreeFlags |= child$119.subtreeFlags &amp; </span><span class="s5">65011712</span><span class="s2">),</span>
          <span class="s2">(subtreeFlags |= child$119.flags &amp; </span><span class="s5">65011712</span><span class="s2">),</span>
          <span class="s2">(treeBaseDuration$118 += child$119.treeBaseDuration),</span>
          <span class="s2">(child$119 = child$119.sibling);</span>
      <span class="s2">completedWork.treeBaseDuration = treeBaseDuration$118;</span>
    <span class="s2">} </span><span class="s4">else</span>
      <span class="s4">for </span><span class="s2">(</span>
        <span class="s2">treeBaseDuration$118 = completedWork.child;</span>
        <span class="s4">null </span><span class="s2">!== treeBaseDuration$118;</span>

      <span class="s2">)</span>
        <span class="s2">(newChildLanes |=</span>
          <span class="s2">treeBaseDuration$118.lanes | treeBaseDuration$118.childLanes),</span>
          <span class="s2">(subtreeFlags |= treeBaseDuration$118.subtreeFlags &amp; </span><span class="s5">65011712</span><span class="s2">),</span>
          <span class="s2">(subtreeFlags |= treeBaseDuration$118.flags &amp; </span><span class="s5">65011712</span><span class="s2">),</span>
          <span class="s2">(treeBaseDuration$118.return = completedWork),</span>
          <span class="s2">(treeBaseDuration$118 = treeBaseDuration$118.sibling);</span>
  <span class="s4">else if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (completedWork.mode &amp; </span><span class="s5">2</span><span class="s2">)) {</span>
    <span class="s2">treeBaseDuration$118 = completedWork.actualDuration;</span>
    <span class="s2">child$119 = completedWork.selfBaseDuration;</span>
    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">child = completedWork.child; </span><span class="s4">null </span><span class="s2">!== child; )</span>
      <span class="s2">(newChildLanes |= child.lanes | child.childLanes),</span>
        <span class="s2">(subtreeFlags |= child.subtreeFlags),</span>
        <span class="s2">(subtreeFlags |= child.flags),</span>
        <span class="s2">(treeBaseDuration$118 += child.actualDuration),</span>
        <span class="s2">(child$119 += child.treeBaseDuration),</span>
        <span class="s2">(child = child.sibling);</span>
    <span class="s2">completedWork.actualDuration = treeBaseDuration$118;</span>
    <span class="s2">completedWork.treeBaseDuration = child$119;</span>
  <span class="s2">} </span><span class="s4">else</span>
    <span class="s4">for </span><span class="s2">(</span>
      <span class="s2">treeBaseDuration$118 = completedWork.child;</span>
      <span class="s4">null </span><span class="s2">!== treeBaseDuration$118;</span>

    <span class="s2">)</span>
      <span class="s2">(newChildLanes |=</span>
        <span class="s2">treeBaseDuration$118.lanes | treeBaseDuration$118.childLanes),</span>
        <span class="s2">(subtreeFlags |= treeBaseDuration$118.subtreeFlags),</span>
        <span class="s2">(subtreeFlags |= treeBaseDuration$118.flags),</span>
        <span class="s2">(treeBaseDuration$118.return = completedWork),</span>
        <span class="s2">(treeBaseDuration$118 = treeBaseDuration$118.sibling);</span>
  <span class="s2">completedWork.subtreeFlags |= subtreeFlags;</span>
  <span class="s2">completedWork.childLanes = newChildLanes;</span>
  <span class="s4">return </span><span class="s2">didBailout;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">completeWork(current, workInProgress, renderLanes) {</span>
  <span class="s4">var </span><span class="s2">newProps = workInProgress.pendingProps;</span>
  <span class="s2">popTreeContext(workInProgress);</span>
  <span class="s4">switch </span><span class="s2">(workInProgress.tag) {</span>
    <span class="s4">case </span><span class="s5">31</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">16</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">15</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">0</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">11</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">7</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">8</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">12</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">9</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">14</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">bubbleProperties(workInProgress), </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">bubbleProperties(workInProgress), </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
      <span class="s2">renderLanes = workInProgress.stateNode;</span>
      <span class="s2">newProps = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">null </span><span class="s2">!== current &amp;&amp; (newProps = current.memoizedState.cache);</span>
      <span class="s2">workInProgress.memoizedState.cache !== newProps &amp;&amp;</span>
        <span class="s2">(workInProgress.flags |= </span><span class="s5">2048</span><span class="s2">);</span>
      <span class="s2">popProvider(CacheContext);</span>
      <span class="s2">popHostContainer();</span>
      <span class="s2">renderLanes.pendingContext &amp;&amp;</span>
        <span class="s2">((renderLanes.context = renderLanes.pendingContext),</span>
        <span class="s2">(renderLanes.pendingContext = </span><span class="s4">null</span><span class="s2">));</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== current || </span><span class="s4">null </span><span class="s2">=== current.child)</span>
        <span class="s2">popHydrationState(workInProgress)</span>
          <span class="s2">? markUpdate(workInProgress)</span>
          <span class="s2">: </span><span class="s4">null </span><span class="s2">=== current ||</span>
            <span class="s2">(current.memoizedState.isDehydrated &amp;&amp;</span>
              <span class="s5">0 </span><span class="s2">=== (workInProgress.flags &amp; </span><span class="s5">256</span><span class="s2">)) ||</span>
            <span class="s2">((workInProgress.flags |= </span><span class="s5">1024</span><span class="s2">),</span>
            <span class="s2">upgradeHydrationErrorsToRecoverable());</span>
      <span class="s2">bubbleProperties(workInProgress);</span>
      <span class="s4">return null</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">26</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(renderLanes = workInProgress.memoizedState),</span>
        <span class="s4">null </span><span class="s2">=== current</span>
          <span class="s2">? (markUpdate(workInProgress),</span>
            <span class="s4">null </span><span class="s2">!== renderLanes</span>
              <span class="s2">? (bubbleProperties(workInProgress),</span>
                <span class="s2">preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))</span>
              <span class="s2">: (bubbleProperties(workInProgress),</span>
                <span class="s2">(workInProgress.flags &amp;= -</span><span class="s5">16777217</span><span class="s2">)))</span>
          <span class="s2">: renderLanes</span>
            <span class="s2">? renderLanes !== current.memoizedState</span>
              <span class="s2">? (markUpdate(workInProgress),</span>
                <span class="s2">bubbleProperties(workInProgress),</span>
                <span class="s2">preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))</span>
              <span class="s2">: (bubbleProperties(workInProgress),</span>
                <span class="s2">(workInProgress.flags &amp;= -</span><span class="s5">16777217</span><span class="s2">))</span>
            <span class="s2">: (current.memoizedProps !== newProps &amp;&amp; markUpdate(workInProgress),</span>
              <span class="s2">bubbleProperties(workInProgress),</span>
              <span class="s2">(workInProgress.flags &amp;= -</span><span class="s5">16777217</span><span class="s2">)),</span>
        <span class="s4">null</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">27</span><span class="s2">:</span>
      <span class="s2">popHostContext(workInProgress);</span>
      <span class="s2">renderLanes = rootInstanceStackCursor.current;</span>
      <span class="s4">var </span><span class="s2">type = workInProgress.type;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== current &amp;&amp; </span><span class="s4">null </span><span class="s2">!= workInProgress.stateNode)</span>
        <span class="s2">current.memoizedProps !== newProps &amp;&amp; markUpdate(workInProgress);</span>
      <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">if </span><span class="s2">(!newProps) {</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== workInProgress.stateNode)</span>
            <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">166</span><span class="s2">));</span>
          <span class="s2">bubbleProperties(workInProgress);</span>
          <span class="s4">return null</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s2">current = contextStackCursor.current;</span>
        <span class="s2">popHydrationState(workInProgress)</span>
          <span class="s2">? prepareToHydrateHostInstance(workInProgress, current)</span>
          <span class="s2">: ((current = resolveSingletonInstance(type, newProps, renderLanes)),</span>
            <span class="s2">(workInProgress.stateNode = current),</span>
            <span class="s2">markUpdate(workInProgress));</span>
      <span class="s2">}</span>
      <span class="s2">bubbleProperties(workInProgress);</span>
      <span class="s4">return null</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
      <span class="s2">popHostContext(workInProgress);</span>
      <span class="s2">renderLanes = workInProgress.type;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== current &amp;&amp; </span><span class="s4">null </span><span class="s2">!= workInProgress.stateNode)</span>
        <span class="s2">current.memoizedProps !== newProps &amp;&amp; markUpdate(workInProgress);</span>
      <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">if </span><span class="s2">(!newProps) {</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== workInProgress.stateNode)</span>
            <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">166</span><span class="s2">));</span>
          <span class="s2">bubbleProperties(workInProgress);</span>
          <span class="s4">return null</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s2">current = contextStackCursor.current;</span>
        <span class="s4">if </span><span class="s2">(popHydrationState(workInProgress))</span>
          <span class="s2">prepareToHydrateHostInstance(workInProgress, current);</span>
        <span class="s4">else </span><span class="s2">{</span>
          <span class="s2">type = getOwnerDocumentFromRootContainer(</span>
            <span class="s2">rootInstanceStackCursor.current</span>
          <span class="s2">);</span>
          <span class="s4">switch </span><span class="s2">(current) {</span>
            <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
              <span class="s2">current = type.createElementNS(</span>
                <span class="s3">&quot;http://www.w3.org/2000/svg&quot;</span><span class="s2">,</span>
                <span class="s2">renderLanes</span>
              <span class="s2">);</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s5">2</span><span class="s2">:</span>
              <span class="s2">current = type.createElementNS(</span>
                <span class="s3">&quot;http://www.w3.org/1998/Math/MathML&quot;</span><span class="s2">,</span>
                <span class="s2">renderLanes</span>
              <span class="s2">);</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">default</span><span class="s2">:</span>
              <span class="s4">switch </span><span class="s2">(renderLanes) {</span>
                <span class="s4">case </span><span class="s3">&quot;svg&quot;</span><span class="s2">:</span>
                  <span class="s2">current = type.createElementNS(</span>
                    <span class="s3">&quot;http://www.w3.org/2000/svg&quot;</span><span class="s2">,</span>
                    <span class="s2">renderLanes</span>
                  <span class="s2">);</span>
                  <span class="s4">break</span><span class="s2">;</span>
                <span class="s4">case </span><span class="s3">&quot;math&quot;</span><span class="s2">:</span>
                  <span class="s2">current = type.createElementNS(</span>
                    <span class="s3">&quot;http://www.w3.org/1998/Math/MathML&quot;</span><span class="s2">,</span>
                    <span class="s2">renderLanes</span>
                  <span class="s2">);</span>
                  <span class="s4">break</span><span class="s2">;</span>
                <span class="s4">case </span><span class="s3">&quot;script&quot;</span><span class="s2">:</span>
                  <span class="s2">current = type.createElement(</span><span class="s3">&quot;div&quot;</span><span class="s2">);</span>
                  <span class="s2">current.innerHTML = </span><span class="s3">&quot;&lt;script&gt;</span><span class="s6">\x3c</span><span class="s3">/script&gt;&quot;</span><span class="s2">;</span>
                  <span class="s2">current = current.removeChild(current.firstChild);</span>
                  <span class="s4">break</span><span class="s2">;</span>
                <span class="s4">case </span><span class="s3">&quot;select&quot;</span><span class="s2">:</span>
                  <span class="s2">current =</span>
                    <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">newProps.is</span>
                      <span class="s2">? type.createElement(</span><span class="s3">&quot;select&quot;</span><span class="s2">, { is: newProps.is })</span>
                      <span class="s2">: type.createElement(</span><span class="s3">&quot;select&quot;</span><span class="s2">);</span>
                  <span class="s2">newProps.multiple</span>
                    <span class="s2">? (current.multiple = !</span><span class="s5">0</span><span class="s2">)</span>
                    <span class="s2">: newProps.size &amp;&amp; (current.size = newProps.size);</span>
                  <span class="s4">break</span><span class="s2">;</span>
                <span class="s4">default</span><span class="s2">:</span>
                  <span class="s2">current =</span>
                    <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">newProps.is</span>
                      <span class="s2">? type.createElement(renderLanes, { is: newProps.is })</span>
                      <span class="s2">: type.createElement(renderLanes);</span>
              <span class="s2">}</span>
          <span class="s2">}</span>
          <span class="s2">current[internalInstanceKey] = workInProgress;</span>
          <span class="s2">current[internalPropsKey] = newProps;</span>
          <span class="s2">a: </span><span class="s4">for </span><span class="s2">(type = workInProgress.child; </span><span class="s4">null </span><span class="s2">!== type; ) {</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s5">5 </span><span class="s2">=== type.tag || </span><span class="s5">6 </span><span class="s2">=== type.tag)</span>
              <span class="s2">current.appendChild(type.stateNode);</span>
            <span class="s4">else if </span><span class="s2">(</span><span class="s5">4 </span><span class="s2">!== type.tag &amp;&amp; </span><span class="s5">27 </span><span class="s2">!== type.tag &amp;&amp; </span><span class="s4">null </span><span class="s2">!== type.child) {</span>
              <span class="s2">type.child.return = type;</span>
              <span class="s2">type = type.child;</span>
              <span class="s4">continue</span><span class="s2">;</span>
            <span class="s2">}</span>
            <span class="s4">if </span><span class="s2">(type === workInProgress) </span><span class="s4">break </span><span class="s2">a;</span>
            <span class="s4">for </span><span class="s2">(; </span><span class="s4">null </span><span class="s2">=== type.sibling; ) {</span>
              <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== type.return || type.return === workInProgress)</span>
                <span class="s4">break </span><span class="s2">a;</span>
              <span class="s2">type = type.return;</span>
            <span class="s2">}</span>
            <span class="s2">type.sibling.return = type.return;</span>
            <span class="s2">type = type.sibling;</span>
          <span class="s2">}</span>
          <span class="s2">workInProgress.stateNode = current;</span>
          <span class="s2">a: </span><span class="s4">switch </span><span class="s2">(</span>
            <span class="s2">(setInitialProperties(current, renderLanes, newProps), renderLanes)</span>
          <span class="s2">) {</span>
            <span class="s4">case </span><span class="s3">&quot;button&quot;</span><span class="s2">:</span>
            <span class="s4">case </span><span class="s3">&quot;input&quot;</span><span class="s2">:</span>
            <span class="s4">case </span><span class="s3">&quot;select&quot;</span><span class="s2">:</span>
            <span class="s4">case </span><span class="s3">&quot;textarea&quot;</span><span class="s2">:</span>
              <span class="s2">current = !!newProps.autoFocus;</span>
              <span class="s4">break </span><span class="s2">a;</span>
            <span class="s4">case </span><span class="s3">&quot;img&quot;</span><span class="s2">:</span>
              <span class="s2">current = !</span><span class="s5">0</span><span class="s2">;</span>
              <span class="s4">break </span><span class="s2">a;</span>
            <span class="s4">default</span><span class="s2">:</span>
              <span class="s2">current = !</span><span class="s5">1</span><span class="s2">;</span>
          <span class="s2">}</span>
          <span class="s2">current &amp;&amp; markUpdate(workInProgress);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s2">bubbleProperties(workInProgress);</span>
      <span class="s2">workInProgress.flags &amp;= -</span><span class="s5">16777217</span><span class="s2">;</span>
      <span class="s4">return null</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">6</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(current &amp;&amp; </span><span class="s4">null </span><span class="s2">!= workInProgress.stateNode)</span>
        <span class="s2">current.memoizedProps !== newProps &amp;&amp; markUpdate(workInProgress);</span>
      <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">newProps &amp;&amp; </span><span class="s4">null </span><span class="s2">=== workInProgress.stateNode)</span>
          <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">166</span><span class="s2">));</span>
        <span class="s2">current = rootInstanceStackCursor.current;</span>
        <span class="s4">if </span><span class="s2">(popHydrationState(workInProgress)) {</span>
          <span class="s2">current = workInProgress.stateNode;</span>
          <span class="s2">renderLanes = workInProgress.memoizedProps;</span>
          <span class="s2">newProps = </span><span class="s4">null</span><span class="s2">;</span>
          <span class="s2">type = hydrationParentFiber;</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== type)</span>
            <span class="s4">switch </span><span class="s2">(type.tag) {</span>
              <span class="s4">case </span><span class="s5">27</span><span class="s2">:</span>
              <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
                <span class="s2">newProps = type.memoizedProps;</span>
            <span class="s2">}</span>
          <span class="s2">current[internalInstanceKey] = workInProgress;</span>
          <span class="s2">current =</span>
            <span class="s2">current.nodeValue === renderLanes ||</span>
            <span class="s2">(</span><span class="s4">null </span><span class="s2">!== newProps &amp;&amp; !</span><span class="s5">0 </span><span class="s2">=== newProps.suppressHydrationWarning) ||</span>
            <span class="s2">checkForUnmatchedText(current.nodeValue, renderLanes)</span>
              <span class="s2">? !</span><span class="s5">0</span>
              <span class="s2">: !</span><span class="s5">1</span><span class="s2">;</span>
          <span class="s2">current || throwOnHydrationMismatch(workInProgress);</span>
        <span class="s2">} </span><span class="s4">else</span>
          <span class="s2">(current =</span>
            <span class="s2">getOwnerDocumentFromRootContainer(current).createTextNode(</span>
              <span class="s2">newProps</span>
            <span class="s2">)),</span>
            <span class="s2">(current[internalInstanceKey] = workInProgress),</span>
            <span class="s2">(workInProgress.stateNode = current);</span>
      <span class="s2">}</span>
      <span class="s2">bubbleProperties(workInProgress);</span>
      <span class="s4">return null</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">13</span><span class="s2">:</span>
      <span class="s2">newProps = workInProgress.memoizedState;</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s4">null </span><span class="s2">=== current ||</span>
        <span class="s2">(</span><span class="s4">null </span><span class="s2">!== current.memoizedState &amp;&amp;</span>
          <span class="s4">null </span><span class="s2">!== current.memoizedState.dehydrated)</span>
      <span class="s2">) {</span>
        <span class="s2">type = popHydrationState(workInProgress);</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== newProps &amp;&amp; </span><span class="s4">null </span><span class="s2">!== newProps.dehydrated) {</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== current) {</span>
            <span class="s4">if </span><span class="s2">(!type) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">318</span><span class="s2">));</span>
            <span class="s2">type = workInProgress.memoizedState;</span>
            <span class="s2">type = </span><span class="s4">null </span><span class="s2">!== type ? type.dehydrated : </span><span class="s4">null</span><span class="s2">;</span>
            <span class="s4">if </span><span class="s2">(!type) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">317</span><span class="s2">));</span>
            <span class="s2">type[internalInstanceKey] = workInProgress;</span>
            <span class="s2">bubbleProperties(workInProgress);</span>
            <span class="s5">0 </span><span class="s2">!== (workInProgress.mode &amp; </span><span class="s5">2</span><span class="s2">) &amp;&amp;</span>
              <span class="s4">null </span><span class="s2">!== newProps &amp;&amp;</span>
              <span class="s2">((type = workInProgress.child),</span>
              <span class="s4">null </span><span class="s2">!== type &amp;&amp;</span>
                <span class="s2">(workInProgress.treeBaseDuration -= type.treeBaseDuration));</span>
          <span class="s2">} </span><span class="s4">else</span>
            <span class="s2">resetHydrationState(),</span>
              <span class="s5">0 </span><span class="s2">=== (workInProgress.flags &amp; </span><span class="s5">128</span><span class="s2">) &amp;&amp;</span>
                <span class="s2">(workInProgress.memoizedState = </span><span class="s4">null</span><span class="s2">),</span>
              <span class="s2">(workInProgress.flags |= </span><span class="s5">4</span><span class="s2">),</span>
              <span class="s2">bubbleProperties(workInProgress),</span>
              <span class="s5">0 </span><span class="s2">!== (workInProgress.mode &amp; </span><span class="s5">2</span><span class="s2">) &amp;&amp;</span>
                <span class="s4">null </span><span class="s2">!== newProps &amp;&amp;</span>
                <span class="s2">((type = workInProgress.child),</span>
                <span class="s4">null </span><span class="s2">!== type &amp;&amp;</span>
                  <span class="s2">(workInProgress.treeBaseDuration -= type.treeBaseDuration));</span>
          <span class="s2">type = !</span><span class="s5">1</span><span class="s2">;</span>
        <span class="s2">} </span><span class="s4">else</span>
          <span class="s2">(type = upgradeHydrationErrorsToRecoverable()),</span>
            <span class="s4">null </span><span class="s2">!== current &amp;&amp;</span>
              <span class="s4">null </span><span class="s2">!== current.memoizedState &amp;&amp;</span>
              <span class="s2">(current.memoizedState.hydrationErrors = type),</span>
            <span class="s2">(type = !</span><span class="s5">0</span><span class="s2">);</span>
        <span class="s4">if </span><span class="s2">(!type) {</span>
          <span class="s4">if </span><span class="s2">(workInProgress.flags &amp; </span><span class="s5">256</span><span class="s2">)</span>
            <span class="s4">return </span><span class="s2">popSuspenseHandler(workInProgress), workInProgress;</span>
          <span class="s2">popSuspenseHandler(workInProgress);</span>
          <span class="s4">return null</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s2">popSuspenseHandler(workInProgress);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (workInProgress.flags &amp; </span><span class="s5">128</span><span class="s2">))</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(workInProgress.lanes = renderLanes),</span>
          <span class="s5">0 </span><span class="s2">!== (workInProgress.mode &amp; </span><span class="s5">2</span><span class="s2">) &amp;&amp;</span>
            <span class="s2">transferActualDuration(workInProgress),</span>
          <span class="s2">workInProgress</span>
        <span class="s2">);</span>
      <span class="s2">renderLanes = </span><span class="s4">null </span><span class="s2">!== newProps;</span>
      <span class="s2">current = </span><span class="s4">null </span><span class="s2">!== current &amp;&amp; </span><span class="s4">null </span><span class="s2">!== current.memoizedState;</span>
      <span class="s4">if </span><span class="s2">(renderLanes) {</span>
        <span class="s2">newProps = workInProgress.child;</span>
        <span class="s2">type = </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s4">null </span><span class="s2">!== newProps.alternate &amp;&amp;</span>
          <span class="s4">null </span><span class="s2">!== newProps.alternate.memoizedState &amp;&amp;</span>
          <span class="s4">null </span><span class="s2">!== newProps.alternate.memoizedState.cachePool &amp;&amp;</span>
          <span class="s2">(type = newProps.alternate.memoizedState.cachePool.pool);</span>
        <span class="s4">var </span><span class="s2">cache$135 = </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s4">null </span><span class="s2">!== newProps.memoizedState &amp;&amp;</span>
          <span class="s4">null </span><span class="s2">!== newProps.memoizedState.cachePool &amp;&amp;</span>
          <span class="s2">(cache$135 = newProps.memoizedState.cachePool.pool);</span>
        <span class="s2">cache$135 !== type &amp;&amp; (newProps.flags |= </span><span class="s5">2048</span><span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s2">renderLanes !== current &amp;&amp;</span>
        <span class="s2">renderLanes &amp;&amp;</span>
        <span class="s2">(workInProgress.child.flags |= </span><span class="s5">8192</span><span class="s2">);</span>
      <span class="s2">scheduleRetryEffect(workInProgress, workInProgress.updateQueue);</span>
      <span class="s2">bubbleProperties(workInProgress);</span>
      <span class="s5">0 </span><span class="s2">!== (workInProgress.mode &amp; </span><span class="s5">2</span><span class="s2">) &amp;&amp;</span>
        <span class="s2">renderLanes &amp;&amp;</span>
        <span class="s2">((current = workInProgress.child),</span>
        <span class="s4">null </span><span class="s2">!== current &amp;&amp;</span>
          <span class="s2">(workInProgress.treeBaseDuration -= current.treeBaseDuration));</span>
      <span class="s4">return null</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">4</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">popHostContainer(),</span>
        <span class="s4">null </span><span class="s2">=== current &amp;&amp;</span>
          <span class="s2">listenToAllSupportedEvents(workInProgress.stateNode.containerInfo),</span>
        <span class="s2">bubbleProperties(workInProgress),</span>
        <span class="s4">null</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">10</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">popProvider(workInProgress.type), bubbleProperties(workInProgress), </span><span class="s4">null</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">19</span><span class="s2">:</span>
      <span class="s2">pop(suspenseStackCursor);</span>
      <span class="s2">type = workInProgress.memoizedState;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== type) </span><span class="s4">return </span><span class="s2">bubbleProperties(workInProgress), </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">newProps = </span><span class="s5">0 </span><span class="s2">!== (workInProgress.flags &amp; </span><span class="s5">128</span><span class="s2">);</span>
      <span class="s2">cache$135 = type.rendering;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== cache$135)</span>
        <span class="s4">if </span><span class="s2">(newProps) cutOffTailIfNeeded(type, !</span><span class="s5">1</span><span class="s2">);</span>
        <span class="s4">else </span><span class="s2">{</span>
          <span class="s4">if </span><span class="s2">(</span>
            <span class="s5">0 </span><span class="s2">!== workInProgressRootExitStatus ||</span>
            <span class="s2">(</span><span class="s4">null </span><span class="s2">!== current &amp;&amp; </span><span class="s5">0 </span><span class="s2">!== (current.flags &amp; </span><span class="s5">128</span><span class="s2">))</span>
          <span class="s2">)</span>
            <span class="s4">for </span><span class="s2">(current = workInProgress.child; </span><span class="s4">null </span><span class="s2">!== current; ) {</span>
              <span class="s2">cache$135 = findFirstSuspended(current);</span>
              <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== cache$135) {</span>
                <span class="s2">workInProgress.flags |= </span><span class="s5">128</span><span class="s2">;</span>
                <span class="s2">cutOffTailIfNeeded(type, !</span><span class="s5">1</span><span class="s2">);</span>
                <span class="s2">current = cache$135.updateQueue;</span>
                <span class="s2">workInProgress.updateQueue = current;</span>
                <span class="s2">scheduleRetryEffect(workInProgress, current);</span>
                <span class="s2">workInProgress.subtreeFlags = </span><span class="s5">0</span><span class="s2">;</span>
                <span class="s2">current = renderLanes;</span>
                <span class="s4">for </span><span class="s2">(renderLanes = workInProgress.child; </span><span class="s4">null </span><span class="s2">!== renderLanes; )</span>
                  <span class="s2">resetWorkInProgress(renderLanes, current),</span>
                    <span class="s2">(renderLanes = renderLanes.sibling);</span>
                <span class="s2">push(</span>
                  <span class="s2">suspenseStackCursor,</span>
                  <span class="s2">(suspenseStackCursor.current &amp; </span><span class="s5">1</span><span class="s2">) | </span><span class="s5">2</span>
                <span class="s2">);</span>
                <span class="s4">return </span><span class="s2">workInProgress.child;</span>
              <span class="s2">}</span>
              <span class="s2">current = current.sibling;</span>
            <span class="s2">}</span>
          <span class="s4">null </span><span class="s2">!== type.tail &amp;&amp;</span>
            <span class="s2">now$1() &gt; workInProgressRootRenderTargetTime &amp;&amp;</span>
            <span class="s2">((workInProgress.flags |= </span><span class="s5">128</span><span class="s2">),</span>
            <span class="s2">(newProps = !</span><span class="s5">0</span><span class="s2">),</span>
            <span class="s2">cutOffTailIfNeeded(type, !</span><span class="s5">1</span><span class="s2">),</span>
            <span class="s2">(workInProgress.lanes = </span><span class="s5">4194304</span><span class="s2">));</span>
        <span class="s2">}</span>
      <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">if </span><span class="s2">(!newProps)</span>
          <span class="s4">if </span><span class="s2">(((current = findFirstSuspended(cache$135)), </span><span class="s4">null </span><span class="s2">!== current)) {</span>
            <span class="s4">if </span><span class="s2">(</span>
              <span class="s2">((workInProgress.flags |= </span><span class="s5">128</span><span class="s2">),</span>
              <span class="s2">(newProps = !</span><span class="s5">0</span><span class="s2">),</span>
              <span class="s2">(current = current.updateQueue),</span>
              <span class="s2">(workInProgress.updateQueue = current),</span>
              <span class="s2">scheduleRetryEffect(workInProgress, current),</span>
              <span class="s2">cutOffTailIfNeeded(type, !</span><span class="s5">0</span><span class="s2">),</span>
              <span class="s4">null </span><span class="s2">=== type.tail &amp;&amp;</span>
                <span class="s3">&quot;hidden&quot; </span><span class="s2">=== type.tailMode &amp;&amp;</span>
                <span class="s2">!cache$135.alternate &amp;&amp;</span>
                <span class="s2">!isHydrating)</span>
            <span class="s2">)</span>
              <span class="s4">return </span><span class="s2">bubbleProperties(workInProgress), </span><span class="s4">null</span><span class="s2">;</span>
          <span class="s2">} </span><span class="s4">else</span>
            <span class="s5">2 </span><span class="s2">* now$1() - type.renderingStartTime &gt;</span>
              <span class="s2">workInProgressRootRenderTargetTime &amp;&amp;</span>
              <span class="s5">536870912 </span><span class="s2">!== renderLanes &amp;&amp;</span>
              <span class="s2">((workInProgress.flags |= </span><span class="s5">128</span><span class="s2">),</span>
              <span class="s2">(newProps = !</span><span class="s5">0</span><span class="s2">),</span>
              <span class="s2">cutOffTailIfNeeded(type, !</span><span class="s5">1</span><span class="s2">),</span>
              <span class="s2">(workInProgress.lanes = </span><span class="s5">4194304</span><span class="s2">));</span>
        <span class="s2">type.isBackwards</span>
          <span class="s2">? ((cache$135.sibling = workInProgress.child),</span>
            <span class="s2">(workInProgress.child = cache$135))</span>
          <span class="s2">: ((current = type.last),</span>
            <span class="s4">null </span><span class="s2">!== current</span>
              <span class="s2">? (current.sibling = cache$135)</span>
              <span class="s2">: (workInProgress.child = cache$135),</span>
            <span class="s2">(type.last = cache$135));</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== type.tail)</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(workInProgress = type.tail),</span>
          <span class="s2">(type.rendering = workInProgress),</span>
          <span class="s2">(type.tail = workInProgress.sibling),</span>
          <span class="s2">(type.renderingStartTime = now$1()),</span>
          <span class="s2">(workInProgress.sibling = </span><span class="s4">null</span><span class="s2">),</span>
          <span class="s2">(current = suspenseStackCursor.current),</span>
          <span class="s2">push(suspenseStackCursor, newProps ? (current &amp; </span><span class="s5">1</span><span class="s2">) | </span><span class="s5">2 </span><span class="s2">: current &amp; </span><span class="s5">1</span><span class="s2">),</span>
          <span class="s2">workInProgress</span>
        <span class="s2">);</span>
      <span class="s2">bubbleProperties(workInProgress);</span>
      <span class="s4">return null</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">22</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">23</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">popSuspenseHandler(workInProgress),</span>
        <span class="s2">popHiddenContext(),</span>
        <span class="s2">(newProps = </span><span class="s4">null </span><span class="s2">!== workInProgress.memoizedState),</span>
        <span class="s4">null </span><span class="s2">!== current</span>
          <span class="s2">? (</span><span class="s4">null </span><span class="s2">!== current.memoizedState) !== newProps &amp;&amp;</span>
            <span class="s2">(workInProgress.flags |= </span><span class="s5">8192</span><span class="s2">)</span>
          <span class="s2">: newProps &amp;&amp; (workInProgress.flags |= </span><span class="s5">8192</span><span class="s2">),</span>
        <span class="s2">newProps</span>
          <span class="s2">? </span><span class="s5">0 </span><span class="s2">!== (renderLanes &amp; </span><span class="s5">536870912</span><span class="s2">) &amp;&amp;</span>
            <span class="s5">0 </span><span class="s2">=== (workInProgress.flags &amp; </span><span class="s5">128</span><span class="s2">) &amp;&amp;</span>
            <span class="s2">(bubbleProperties(workInProgress),</span>
            <span class="s2">workInProgress.subtreeFlags &amp; </span><span class="s5">6 </span><span class="s2">&amp;&amp; (workInProgress.flags |= </span><span class="s5">8192</span><span class="s2">))</span>
          <span class="s2">: bubbleProperties(workInProgress),</span>
        <span class="s2">(renderLanes = workInProgress.updateQueue),</span>
        <span class="s4">null </span><span class="s2">!== renderLanes &amp;&amp;</span>
          <span class="s2">scheduleRetryEffect(workInProgress, renderLanes.retryQueue),</span>
        <span class="s2">(renderLanes = </span><span class="s4">null</span><span class="s2">),</span>
        <span class="s4">null </span><span class="s2">!== current &amp;&amp;</span>
          <span class="s4">null </span><span class="s2">!== current.memoizedState &amp;&amp;</span>
          <span class="s4">null </span><span class="s2">!== current.memoizedState.cachePool &amp;&amp;</span>
          <span class="s2">(renderLanes = current.memoizedState.cachePool.pool),</span>
        <span class="s2">(newProps = </span><span class="s4">null</span><span class="s2">),</span>
        <span class="s4">null </span><span class="s2">!== workInProgress.memoizedState &amp;&amp;</span>
          <span class="s4">null </span><span class="s2">!== workInProgress.memoizedState.cachePool &amp;&amp;</span>
          <span class="s2">(newProps = workInProgress.memoizedState.cachePool.pool),</span>
        <span class="s2">newProps !== renderLanes &amp;&amp; (workInProgress.flags |= </span><span class="s5">2048</span><span class="s2">),</span>
        <span class="s4">null </span><span class="s2">!== current &amp;&amp; pop(resumedCache),</span>
        <span class="s4">null</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">24</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(renderLanes = </span><span class="s4">null</span><span class="s2">),</span>
        <span class="s4">null </span><span class="s2">!== current &amp;&amp; (renderLanes = current.memoizedState.cache),</span>
        <span class="s2">workInProgress.memoizedState.cache !== renderLanes &amp;&amp;</span>
          <span class="s2">(workInProgress.flags |= </span><span class="s5">2048</span><span class="s2">),</span>
        <span class="s2">popProvider(CacheContext),</span>
        <span class="s2">bubbleProperties(workInProgress),</span>
        <span class="s4">null</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">25</span><span class="s2">:</span>
      <span class="s4">return null</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">30</span><span class="s2">:</span>
      <span class="s4">return null</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">156</span><span class="s2">, workInProgress.tag));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">unwindWork(current, workInProgress) {</span>
  <span class="s2">popTreeContext(workInProgress);</span>
  <span class="s4">switch </span><span class="s2">(workInProgress.tag) {</span>
    <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(current = workInProgress.flags),</span>
        <span class="s2">current &amp; </span><span class="s5">65536</span>
          <span class="s2">? ((workInProgress.flags = (current &amp; -</span><span class="s5">65537</span><span class="s2">) | </span><span class="s5">128</span><span class="s2">),</span>
            <span class="s5">0 </span><span class="s2">!== (workInProgress.mode &amp; </span><span class="s5">2</span><span class="s2">) &amp;&amp;</span>
              <span class="s2">transferActualDuration(workInProgress),</span>
            <span class="s2">workInProgress)</span>
          <span class="s2">: </span><span class="s4">null</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">popProvider(CacheContext),</span>
        <span class="s2">popHostContainer(),</span>
        <span class="s2">(current = workInProgress.flags),</span>
        <span class="s5">0 </span><span class="s2">!== (current &amp; </span><span class="s5">65536</span><span class="s2">) &amp;&amp; </span><span class="s5">0 </span><span class="s2">=== (current &amp; </span><span class="s5">128</span><span class="s2">)</span>
          <span class="s2">? ((workInProgress.flags = (current &amp; -</span><span class="s5">65537</span><span class="s2">) | </span><span class="s5">128</span><span class="s2">), workInProgress)</span>
          <span class="s2">: </span><span class="s4">null</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">26</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">27</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">popHostContext(workInProgress), </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">13</span><span class="s2">:</span>
      <span class="s2">popSuspenseHandler(workInProgress);</span>
      <span class="s2">current = workInProgress.memoizedState;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== current &amp;&amp; </span><span class="s4">null </span><span class="s2">!== current.dehydrated) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== workInProgress.alternate)</span>
          <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">340</span><span class="s2">));</span>
        <span class="s2">resetHydrationState();</span>
      <span class="s2">}</span>
      <span class="s2">current = workInProgress.flags;</span>
      <span class="s4">return </span><span class="s2">current &amp; </span><span class="s5">65536</span>
        <span class="s2">? ((workInProgress.flags = (current &amp; -</span><span class="s5">65537</span><span class="s2">) | </span><span class="s5">128</span><span class="s2">),</span>
          <span class="s5">0 </span><span class="s2">!== (workInProgress.mode &amp; </span><span class="s5">2</span><span class="s2">) &amp;&amp;</span>
            <span class="s2">transferActualDuration(workInProgress),</span>
          <span class="s2">workInProgress)</span>
        <span class="s2">: </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">19</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">pop(suspenseStackCursor), </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">4</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">popHostContainer(), </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">10</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">popProvider(workInProgress.type), </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">22</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">23</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">popSuspenseHandler(workInProgress),</span>
        <span class="s2">popHiddenContext(),</span>
        <span class="s4">null </span><span class="s2">!== current &amp;&amp; pop(resumedCache),</span>
        <span class="s2">(current = workInProgress.flags),</span>
        <span class="s2">current &amp; </span><span class="s5">65536</span>
          <span class="s2">? ((workInProgress.flags = (current &amp; -</span><span class="s5">65537</span><span class="s2">) | </span><span class="s5">128</span><span class="s2">),</span>
            <span class="s5">0 </span><span class="s2">!== (workInProgress.mode &amp; </span><span class="s5">2</span><span class="s2">) &amp;&amp;</span>
              <span class="s2">transferActualDuration(workInProgress),</span>
            <span class="s2">workInProgress)</span>
          <span class="s2">: </span><span class="s4">null</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">24</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">popProvider(CacheContext), </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">25</span><span class="s2">:</span>
      <span class="s4">return null</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">return null</span><span class="s2">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">unwindInterruptedWork(current, interruptedWork) {</span>
  <span class="s2">popTreeContext(interruptedWork);</span>
  <span class="s4">switch </span><span class="s2">(interruptedWork.tag) {</span>
    <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
      <span class="s2">popProvider(CacheContext);</span>
      <span class="s2">popHostContainer();</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">26</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">27</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
      <span class="s2">popHostContext(interruptedWork);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">4</span><span class="s2">:</span>
      <span class="s2">popHostContainer();</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">13</span><span class="s2">:</span>
      <span class="s2">popSuspenseHandler(interruptedWork);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">19</span><span class="s2">:</span>
      <span class="s2">pop(suspenseStackCursor);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">10</span><span class="s2">:</span>
      <span class="s2">popProvider(interruptedWork.type);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">22</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">23</span><span class="s2">:</span>
      <span class="s2">popSuspenseHandler(interruptedWork);</span>
      <span class="s2">popHiddenContext();</span>
      <span class="s4">null </span><span class="s2">!== current &amp;&amp; pop(resumedCache);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">24</span><span class="s2">:</span>
      <span class="s2">popProvider(CacheContext);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">shouldProfile(current) {</span>
  <span class="s4">return </span><span class="s5">0 </span><span class="s2">!== (current.mode &amp; </span><span class="s5">2</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">commitHookLayoutEffects(finishedWork, hookFlags) {</span>
  <span class="s2">shouldProfile(finishedWork)</span>
    <span class="s2">? (startEffectTimer(),</span>
      <span class="s2">commitHookEffectListMount(hookFlags, finishedWork),</span>
      <span class="s2">recordEffectDuration())</span>
    <span class="s2">: commitHookEffectListMount(hookFlags, finishedWork);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">commitHookLayoutUnmountEffects(</span>
  <span class="s2">finishedWork,</span>
  <span class="s2">nearestMountedAncestor,</span>
  <span class="s2">hookFlags</span>
<span class="s2">) {</span>
  <span class="s2">shouldProfile(finishedWork)</span>
    <span class="s2">? (startEffectTimer(),</span>
      <span class="s2">commitHookEffectListUnmount(</span>
        <span class="s2">hookFlags,</span>
        <span class="s2">finishedWork,</span>
        <span class="s2">nearestMountedAncestor</span>
      <span class="s2">),</span>
      <span class="s2">recordEffectDuration())</span>
    <span class="s2">: commitHookEffectListUnmount(</span>
        <span class="s2">hookFlags,</span>
        <span class="s2">finishedWork,</span>
        <span class="s2">nearestMountedAncestor</span>
      <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">commitHookEffectListMount(flags, finishedWork) {</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">updateQueue = finishedWork.updateQueue,</span>
      <span class="s2">lastEffect = </span><span class="s4">null </span><span class="s2">!== updateQueue ? updateQueue.lastEffect : </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== lastEffect) {</span>
      <span class="s4">var </span><span class="s2">firstEffect = lastEffect.next;</span>
      <span class="s2">updateQueue = firstEffect;</span>
      <span class="s4">do </span><span class="s2">{</span>
        <span class="s4">if </span><span class="s2">((updateQueue.tag &amp; flags) === flags) {</span>
          <span class="s5">0 </span><span class="s2">!== (flags &amp; </span><span class="s5">8</span><span class="s2">)</span>
            <span class="s2">? </span><span class="s4">null </span><span class="s2">!== injectedProfilingHooks &amp;&amp;</span>
              <span class="s3">&quot;function&quot; </span><span class="s2">===</span>
                <span class="s4">typeof </span><span class="s2">injectedProfilingHooks.markComponentPassiveEffectMountStarted &amp;&amp;</span>
              <span class="s2">injectedProfilingHooks.markComponentPassiveEffectMountStarted(</span>
                <span class="s2">finishedWork</span>
              <span class="s2">)</span>
            <span class="s2">: </span><span class="s5">0 </span><span class="s2">!== (flags &amp; </span><span class="s5">4</span><span class="s2">) &amp;&amp;</span>
              <span class="s4">null </span><span class="s2">!== injectedProfilingHooks &amp;&amp;</span>
              <span class="s3">&quot;function&quot; </span><span class="s2">===</span>
                <span class="s4">typeof </span><span class="s2">injectedProfilingHooks.markComponentLayoutEffectMountStarted &amp;&amp;</span>
              <span class="s2">injectedProfilingHooks.markComponentLayoutEffectMountStarted(</span>
                <span class="s2">finishedWork</span>
              <span class="s2">);</span>
          <span class="s2">lastEffect = </span><span class="s4">void </span><span class="s5">0</span><span class="s2">;</span>
          <span class="s4">var </span><span class="s2">create = updateQueue.create,</span>
            <span class="s2">inst = updateQueue.inst;</span>
          <span class="s2">lastEffect = create();</span>
          <span class="s2">inst.destroy = lastEffect;</span>
          <span class="s5">0 </span><span class="s2">!== (flags &amp; </span><span class="s5">8</span><span class="s2">)</span>
            <span class="s2">? </span><span class="s4">null </span><span class="s2">!== injectedProfilingHooks &amp;&amp;</span>
              <span class="s3">&quot;function&quot; </span><span class="s2">===</span>
                <span class="s4">typeof </span><span class="s2">injectedProfilingHooks.markComponentPassiveEffectMountStopped &amp;&amp;</span>
              <span class="s2">injectedProfilingHooks.markComponentPassiveEffectMountStopped()</span>
            <span class="s2">: </span><span class="s5">0 </span><span class="s2">!== (flags &amp; </span><span class="s5">4</span><span class="s2">) &amp;&amp;</span>
              <span class="s4">null </span><span class="s2">!== injectedProfilingHooks &amp;&amp;</span>
              <span class="s3">&quot;function&quot; </span><span class="s2">===</span>
                <span class="s4">typeof </span><span class="s2">injectedProfilingHooks.markComponentLayoutEffectMountStopped &amp;&amp;</span>
              <span class="s2">injectedProfilingHooks.markComponentLayoutEffectMountStopped();</span>
        <span class="s2">}</span>
        <span class="s2">updateQueue = updateQueue.next;</span>
      <span class="s2">} </span><span class="s4">while </span><span class="s2">(updateQueue !== firstEffect);</span>
    <span class="s2">}</span>
  <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
    <span class="s2">captureCommitPhaseError(finishedWork, finishedWork.return, error);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">commitHookEffectListUnmount(</span>
  <span class="s2">flags,</span>
  <span class="s2">finishedWork,</span>
  <span class="s2">nearestMountedAncestor$jscomp$0</span>
<span class="s2">) {</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">updateQueue = finishedWork.updateQueue,</span>
      <span class="s2">lastEffect = </span><span class="s4">null </span><span class="s2">!== updateQueue ? updateQueue.lastEffect : </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== lastEffect) {</span>
      <span class="s4">var </span><span class="s2">firstEffect = lastEffect.next;</span>
      <span class="s2">updateQueue = firstEffect;</span>
      <span class="s4">do </span><span class="s2">{</span>
        <span class="s4">if </span><span class="s2">((updateQueue.tag &amp; flags) === flags) {</span>
          <span class="s4">var </span><span class="s2">inst = updateQueue.inst,</span>
            <span class="s2">destroy = inst.destroy;</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== destroy) {</span>
            <span class="s2">inst.destroy = </span><span class="s4">void </span><span class="s5">0</span><span class="s2">;</span>
            <span class="s5">0 </span><span class="s2">!== (flags &amp; </span><span class="s5">8</span><span class="s2">)</span>
              <span class="s2">? </span><span class="s4">null </span><span class="s2">!== injectedProfilingHooks &amp;&amp;</span>
                <span class="s3">&quot;function&quot; </span><span class="s2">===</span>
                  <span class="s4">typeof </span><span class="s2">injectedProfilingHooks.markComponentPassiveEffectUnmountStarted &amp;&amp;</span>
                <span class="s2">injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(</span>
                  <span class="s2">finishedWork</span>
                <span class="s2">)</span>
              <span class="s2">: </span><span class="s5">0 </span><span class="s2">!== (flags &amp; </span><span class="s5">4</span><span class="s2">) &amp;&amp;</span>
                <span class="s4">null </span><span class="s2">!== injectedProfilingHooks &amp;&amp;</span>
                <span class="s3">&quot;function&quot; </span><span class="s2">===</span>
                  <span class="s4">typeof </span><span class="s2">injectedProfilingHooks.markComponentLayoutEffectUnmountStarted &amp;&amp;</span>
                <span class="s2">injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(</span>
                  <span class="s2">finishedWork</span>
                <span class="s2">);</span>
            <span class="s2">lastEffect = finishedWork;</span>
            <span class="s4">var </span><span class="s2">nearestMountedAncestor = nearestMountedAncestor$jscomp$0,</span>
              <span class="s2">destroy_ = destroy;</span>
            <span class="s4">try </span><span class="s2">{</span>
              <span class="s2">destroy_();</span>
            <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
              <span class="s2">captureCommitPhaseError(</span>
                <span class="s2">lastEffect,</span>
                <span class="s2">nearestMountedAncestor,</span>
                <span class="s2">error</span>
              <span class="s2">);</span>
            <span class="s2">}</span>
            <span class="s5">0 </span><span class="s2">!== (flags &amp; </span><span class="s5">8</span><span class="s2">)</span>
              <span class="s2">? </span><span class="s4">null </span><span class="s2">!== injectedProfilingHooks &amp;&amp;</span>
                <span class="s3">&quot;function&quot; </span><span class="s2">===</span>
                  <span class="s4">typeof </span><span class="s2">injectedProfilingHooks.markComponentPassiveEffectUnmountStopped &amp;&amp;</span>
                <span class="s2">injectedProfilingHooks.markComponentPassiveEffectUnmountStopped()</span>
              <span class="s2">: </span><span class="s5">0 </span><span class="s2">!== (flags &amp; </span><span class="s5">4</span><span class="s2">) &amp;&amp;</span>
                <span class="s4">null </span><span class="s2">!== injectedProfilingHooks &amp;&amp;</span>
                <span class="s3">&quot;function&quot; </span><span class="s2">===</span>
                  <span class="s4">typeof </span><span class="s2">injectedProfilingHooks.markComponentLayoutEffectUnmountStopped &amp;&amp;</span>
                <span class="s2">injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s2">updateQueue = updateQueue.next;</span>
      <span class="s2">} </span><span class="s4">while </span><span class="s2">(updateQueue !== firstEffect);</span>
    <span class="s2">}</span>
  <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
    <span class="s2">captureCommitPhaseError(finishedWork, finishedWork.return, error);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">commitHookPassiveMountEffects(finishedWork, hookFlags) {</span>
  <span class="s2">shouldProfile(finishedWork)</span>
    <span class="s2">? (startEffectTimer(),</span>
      <span class="s2">commitHookEffectListMount(hookFlags, finishedWork),</span>
      <span class="s2">recordEffectDuration())</span>
    <span class="s2">: commitHookEffectListMount(hookFlags, finishedWork);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">commitHookPassiveUnmountEffects(</span>
  <span class="s2">finishedWork,</span>
  <span class="s2">nearestMountedAncestor,</span>
  <span class="s2">hookFlags</span>
<span class="s2">) {</span>
  <span class="s2">shouldProfile(finishedWork)</span>
    <span class="s2">? (startEffectTimer(),</span>
      <span class="s2">commitHookEffectListUnmount(</span>
        <span class="s2">hookFlags,</span>
        <span class="s2">finishedWork,</span>
        <span class="s2">nearestMountedAncestor</span>
      <span class="s2">),</span>
      <span class="s2">recordEffectDuration())</span>
    <span class="s2">: commitHookEffectListUnmount(</span>
        <span class="s2">hookFlags,</span>
        <span class="s2">finishedWork,</span>
        <span class="s2">nearestMountedAncestor</span>
      <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">commitClassCallbacks(finishedWork) {</span>
  <span class="s4">var </span><span class="s2">updateQueue = finishedWork.updateQueue;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== updateQueue) {</span>
    <span class="s4">var </span><span class="s2">instance = finishedWork.stateNode;</span>
    <span class="s4">try </span><span class="s2">{</span>
      <span class="s2">commitCallbacks(updateQueue, instance);</span>
    <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
      <span class="s2">captureCommitPhaseError(finishedWork, finishedWork.return, error);</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">safelyCallComponentWillUnmount(</span>
  <span class="s2">current,</span>
  <span class="s2">nearestMountedAncestor,</span>
  <span class="s2">instance</span>
<span class="s2">) {</span>
  <span class="s2">instance.props = resolveClassComponentProps(</span>
    <span class="s2">current.type,</span>
    <span class="s2">current.memoizedProps</span>
  <span class="s2">);</span>
  <span class="s2">instance.state = current.memoizedState;</span>
  <span class="s4">if </span><span class="s2">(shouldProfile(current)) {</span>
    <span class="s2">startEffectTimer();</span>
    <span class="s4">try </span><span class="s2">{</span>
      <span class="s2">instance.componentWillUnmount();</span>
    <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
      <span class="s2">captureCommitPhaseError(current, nearestMountedAncestor, error);</span>
    <span class="s2">}</span>
    <span class="s2">recordEffectDuration();</span>
  <span class="s2">} </span><span class="s4">else</span>
    <span class="s4">try </span><span class="s2">{</span>
      <span class="s2">instance.componentWillUnmount();</span>
    <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error$153) {</span>
      <span class="s2">captureCommitPhaseError(current, nearestMountedAncestor, error$153);</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">safelyAttachRef(current, nearestMountedAncestor) {</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">ref = current.ref;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== ref) {</span>
      <span class="s4">switch </span><span class="s2">(current.tag) {</span>
        <span class="s4">case </span><span class="s5">26</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s5">27</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
          <span class="s4">var </span><span class="s2">instanceToUse = current.stateNode;</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s5">30</span><span class="s2">:</span>
          <span class="s2">instanceToUse = current.stateNode;</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">default</span><span class="s2">:</span>
          <span class="s2">instanceToUse = current.stateNode;</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">ref)</span>
        <span class="s4">if </span><span class="s2">(shouldProfile(current))</span>
          <span class="s4">try </span><span class="s2">{</span>
            <span class="s2">startEffectTimer(), (current.refCleanup = ref(instanceToUse));</span>
          <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
            <span class="s2">recordEffectDuration();</span>
          <span class="s2">}</span>
        <span class="s4">else </span><span class="s2">current.refCleanup = ref(instanceToUse);</span>
      <span class="s4">else </span><span class="s2">ref.current = instanceToUse;</span>
    <span class="s2">}</span>
  <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
    <span class="s2">captureCommitPhaseError(current, nearestMountedAncestor, error);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">safelyDetachRef(current, nearestMountedAncestor) {</span>
  <span class="s4">var </span><span class="s2">ref = current.ref,</span>
    <span class="s2">refCleanup = current.refCleanup;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== ref)</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">refCleanup)</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s4">if </span><span class="s2">(shouldProfile(current))</span>
          <span class="s4">try </span><span class="s2">{</span>
            <span class="s2">startEffectTimer(), refCleanup();</span>
          <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
            <span class="s2">recordEffectDuration(current);</span>
          <span class="s2">}</span>
        <span class="s4">else </span><span class="s2">refCleanup();</span>
      <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
        <span class="s2">captureCommitPhaseError(current, nearestMountedAncestor, error);</span>
      <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
        <span class="s2">(current.refCleanup = </span><span class="s4">null</span><span class="s2">),</span>
          <span class="s2">(current = current.alternate),</span>
          <span class="s4">null </span><span class="s2">!= current &amp;&amp; (current.refCleanup = </span><span class="s4">null</span><span class="s2">);</span>
      <span class="s2">}</span>
    <span class="s4">else if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">ref)</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s4">if </span><span class="s2">(shouldProfile(current))</span>
          <span class="s4">try </span><span class="s2">{</span>
            <span class="s2">startEffectTimer(), ref(</span><span class="s4">null</span><span class="s2">);</span>
          <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
            <span class="s2">recordEffectDuration(current);</span>
          <span class="s2">}</span>
        <span class="s4">else </span><span class="s2">ref(</span><span class="s4">null</span><span class="s2">);</span>
      <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error$154) {</span>
        <span class="s2">captureCommitPhaseError(current, nearestMountedAncestor, error$154);</span>
      <span class="s2">}</span>
    <span class="s4">else </span><span class="s2">ref.current = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">commitProfilerUpdate(</span>
  <span class="s2">finishedWork,</span>
  <span class="s2">current,</span>
  <span class="s2">commitStartTime,</span>
  <span class="s2">effectDuration</span>
<span class="s2">) {</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">_finishedWork$memoize = finishedWork.memoizedProps,</span>
      <span class="s2">id = _finishedWork$memoize.id,</span>
      <span class="s2">onCommit = _finishedWork$memoize.onCommit,</span>
      <span class="s2">onRender = _finishedWork$memoize.onRender;</span>
    <span class="s2">current = </span><span class="s4">null </span><span class="s2">=== current ? </span><span class="s3">&quot;mount&quot; </span><span class="s2">: </span><span class="s3">&quot;update&quot;</span><span class="s2">;</span>
    <span class="s2">currentUpdateIsNested &amp;&amp; (current = </span><span class="s3">&quot;nested-update&quot;</span><span class="s2">);</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">onRender &amp;&amp;</span>
      <span class="s2">onRender(</span>
        <span class="s2">id,</span>
        <span class="s2">current,</span>
        <span class="s2">finishedWork.actualDuration,</span>
        <span class="s2">finishedWork.treeBaseDuration,</span>
        <span class="s2">finishedWork.actualStartTime,</span>
        <span class="s2">commitStartTime</span>
      <span class="s2">);</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">onCommit &amp;&amp;</span>
      <span class="s2">onCommit(</span>
        <span class="s2">finishedWork.memoizedProps.id,</span>
        <span class="s2">current,</span>
        <span class="s2">effectDuration,</span>
        <span class="s2">commitStartTime</span>
      <span class="s2">);</span>
  <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
    <span class="s2">captureCommitPhaseError(finishedWork, finishedWork.return, error);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">commitHostMount(finishedWork) {</span>
  <span class="s4">var </span><span class="s2">type = finishedWork.type,</span>
    <span class="s2">props = finishedWork.memoizedProps,</span>
    <span class="s2">instance = finishedWork.stateNode;</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s2">a: </span><span class="s4">switch </span><span class="s2">(type) {</span>
      <span class="s4">case </span><span class="s3">&quot;button&quot;</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">&quot;input&quot;</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">&quot;select&quot;</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">&quot;textarea&quot;</span><span class="s2">:</span>
        <span class="s2">props.autoFocus &amp;&amp; instance.focus();</span>
        <span class="s4">break </span><span class="s2">a;</span>
      <span class="s4">case </span><span class="s3">&quot;img&quot;</span><span class="s2">:</span>
        <span class="s2">props.src</span>
          <span class="s2">? (instance.src = props.src)</span>
          <span class="s2">: props.srcSet &amp;&amp; (instance.srcset = props.srcSet);</span>
    <span class="s2">}</span>
  <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
    <span class="s2">captureCommitPhaseError(finishedWork, finishedWork.return, error);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">commitHostUpdate(finishedWork, newProps, oldProps) {</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">domElement = finishedWork.stateNode;</span>
    <span class="s2">updateProperties(domElement, finishedWork.type, oldProps, newProps);</span>
    <span class="s2">domElement[internalPropsKey] = newProps;</span>
  <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
    <span class="s2">captureCommitPhaseError(finishedWork, finishedWork.return, error);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">isHostParent(fiber) {</span>
  <span class="s4">return </span><span class="s2">(</span>
    <span class="s5">5 </span><span class="s2">=== fiber.tag ||</span>
    <span class="s5">3 </span><span class="s2">=== fiber.tag ||</span>
    <span class="s5">26 </span><span class="s2">=== fiber.tag ||</span>
    <span class="s2">(</span><span class="s5">27 </span><span class="s2">=== fiber.tag &amp;&amp; isSingletonScope(fiber.type)) ||</span>
    <span class="s5">4 </span><span class="s2">=== fiber.tag</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getHostSibling(fiber) {</span>
  <span class="s2">a: </span><span class="s4">for </span><span class="s2">(;;) {</span>
    <span class="s4">for </span><span class="s2">(; </span><span class="s4">null </span><span class="s2">=== fiber.sibling; ) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== fiber.return || isHostParent(fiber.return)) </span><span class="s4">return null</span><span class="s2">;</span>
      <span class="s2">fiber = fiber.return;</span>
    <span class="s2">}</span>
    <span class="s2">fiber.sibling.return = fiber.return;</span>
    <span class="s4">for </span><span class="s2">(</span>
      <span class="s2">fiber = fiber.sibling;</span>
      <span class="s5">5 </span><span class="s2">!== fiber.tag &amp;&amp; </span><span class="s5">6 </span><span class="s2">!== fiber.tag &amp;&amp; </span><span class="s5">18 </span><span class="s2">!== fiber.tag;</span>

    <span class="s2">) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s5">27 </span><span class="s2">=== fiber.tag &amp;&amp; isSingletonScope(fiber.type)) </span><span class="s4">continue </span><span class="s2">a;</span>
      <span class="s4">if </span><span class="s2">(fiber.flags &amp; </span><span class="s5">2</span><span class="s2">) </span><span class="s4">continue </span><span class="s2">a;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== fiber.child || </span><span class="s5">4 </span><span class="s2">=== fiber.tag) </span><span class="s4">continue </span><span class="s2">a;</span>
      <span class="s4">else </span><span class="s2">(fiber.child.return = fiber), (fiber = fiber.child);</span>
    <span class="s2">}</span>
    <span class="s4">if </span><span class="s2">(!(fiber.flags &amp; </span><span class="s5">2</span><span class="s2">)) </span><span class="s4">return </span><span class="s2">fiber.stateNode;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">insertOrAppendPlacementNodeIntoContainer(node, before, parent) {</span>
  <span class="s4">var </span><span class="s2">tag = node.tag;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">5 </span><span class="s2">=== tag || </span><span class="s5">6 </span><span class="s2">=== tag)</span>
    <span class="s2">(node = node.stateNode),</span>
      <span class="s2">before</span>
        <span class="s2">? (</span><span class="s5">9 </span><span class="s2">=== parent.nodeType</span>
            <span class="s2">? parent.body</span>
            <span class="s2">: </span><span class="s3">&quot;HTML&quot; </span><span class="s2">=== parent.nodeName</span>
              <span class="s2">? parent.ownerDocument.body</span>
              <span class="s2">: parent</span>
          <span class="s2">).insertBefore(node, before)</span>
        <span class="s2">: ((before =</span>
            <span class="s5">9 </span><span class="s2">=== parent.nodeType</span>
              <span class="s2">? parent.body</span>
              <span class="s2">: </span><span class="s3">&quot;HTML&quot; </span><span class="s2">=== parent.nodeName</span>
                <span class="s2">? parent.ownerDocument.body</span>
                <span class="s2">: parent),</span>
          <span class="s2">before.appendChild(node),</span>
          <span class="s2">(parent = parent._reactRootContainer),</span>
          <span class="s2">(</span><span class="s4">null </span><span class="s2">!== parent &amp;&amp; </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== parent) ||</span>
            <span class="s4">null </span><span class="s2">!== before.onclick ||</span>
            <span class="s2">(before.onclick = noop$2));</span>
  <span class="s4">else if </span><span class="s2">(</span>
    <span class="s5">4 </span><span class="s2">!== tag &amp;&amp;</span>
    <span class="s2">(</span><span class="s5">27 </span><span class="s2">=== tag &amp;&amp;</span>
      <span class="s2">isSingletonScope(node.type) &amp;&amp;</span>
      <span class="s2">((parent = node.stateNode), (before = </span><span class="s4">null</span><span class="s2">)),</span>
    <span class="s2">(node = node.child),</span>
    <span class="s4">null </span><span class="s2">!== node)</span>
  <span class="s2">)</span>
    <span class="s4">for </span><span class="s2">(</span>
      <span class="s2">insertOrAppendPlacementNodeIntoContainer(node, before, parent),</span>
        <span class="s2">node = node.sibling;</span>
      <span class="s4">null </span><span class="s2">!== node;</span>

    <span class="s2">)</span>
      <span class="s2">insertOrAppendPlacementNodeIntoContainer(node, before, parent),</span>
        <span class="s2">(node = node.sibling);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">insertOrAppendPlacementNode(node, before, parent) {</span>
  <span class="s4">var </span><span class="s2">tag = node.tag;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">5 </span><span class="s2">=== tag || </span><span class="s5">6 </span><span class="s2">=== tag)</span>
    <span class="s2">(node = node.stateNode),</span>
      <span class="s2">before ? parent.insertBefore(node, before) : parent.appendChild(node);</span>
  <span class="s4">else if </span><span class="s2">(</span>
    <span class="s5">4 </span><span class="s2">!== tag &amp;&amp;</span>
    <span class="s2">(</span><span class="s5">27 </span><span class="s2">=== tag &amp;&amp; isSingletonScope(node.type) &amp;&amp; (parent = node.stateNode),</span>
    <span class="s2">(node = node.child),</span>
    <span class="s4">null </span><span class="s2">!== node)</span>
  <span class="s2">)</span>
    <span class="s4">for </span><span class="s2">(</span>
      <span class="s2">insertOrAppendPlacementNode(node, before, parent), node = node.sibling;</span>
      <span class="s4">null </span><span class="s2">!== node;</span>

    <span class="s2">)</span>
      <span class="s2">insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">commitHostSingletonAcquisition(finishedWork) {</span>
  <span class="s4">var </span><span class="s2">singleton = finishedWork.stateNode,</span>
    <span class="s2">props = finishedWork.memoizedProps;</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s4">for </span><span class="s2">(</span>
      <span class="s4">var </span><span class="s2">type = finishedWork.type, attributes = singleton.attributes;</span>
      <span class="s2">attributes.length;</span>

    <span class="s2">)</span>
      <span class="s2">singleton.removeAttributeNode(attributes[</span><span class="s5">0</span><span class="s2">]);</span>
    <span class="s2">setInitialProperties(singleton, type, props);</span>
    <span class="s2">singleton[internalInstanceKey] = finishedWork;</span>
    <span class="s2">singleton[internalPropsKey] = props;</span>
  <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
    <span class="s2">captureCommitPhaseError(finishedWork, finishedWork.return, error);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">offscreenSubtreeIsHidden = !</span><span class="s5">1</span><span class="s2">,</span>
  <span class="s2">offscreenSubtreeWasHidden = !</span><span class="s5">1</span><span class="s2">,</span>
  <span class="s2">needsFormReset = !</span><span class="s5">1</span><span class="s2">,</span>
  <span class="s2">PossiblyWeakSet = </span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">WeakSet ? WeakSet : Set,</span>
  <span class="s2">nextEffect = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">inProgressLanes = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">inProgressRoot = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">commitBeforeMutationEffects(root, firstChild) {</span>
  <span class="s2">root = root.containerInfo;</span>
  <span class="s2">eventsEnabled = _enabled;</span>
  <span class="s2">root = getActiveElementDeep(root);</span>
  <span class="s4">if </span><span class="s2">(hasSelectionCapabilities(root)) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;selectionStart&quot; </span><span class="s4">in </span><span class="s2">root)</span>
      <span class="s4">var </span><span class="s2">JSCompiler_temp = {</span>
        <span class="s2">start: root.selectionStart,</span>
        <span class="s2">end: root.selectionEnd</span>
      <span class="s2">};</span>
    <span class="s4">else</span>
      <span class="s2">a: {</span>
        <span class="s2">JSCompiler_temp =</span>
          <span class="s2">((JSCompiler_temp = root.ownerDocument) &amp;&amp;</span>
            <span class="s2">JSCompiler_temp.defaultView) ||</span>
          <span class="s2">window;</span>
        <span class="s4">var </span><span class="s2">selection =</span>
          <span class="s2">JSCompiler_temp.getSelection &amp;&amp; JSCompiler_temp.getSelection();</span>
        <span class="s4">if </span><span class="s2">(selection &amp;&amp; </span><span class="s5">0 </span><span class="s2">!== selection.rangeCount) {</span>
          <span class="s2">JSCompiler_temp = selection.anchorNode;</span>
          <span class="s4">var </span><span class="s2">anchorOffset = selection.anchorOffset,</span>
            <span class="s2">focusNode = selection.focusNode;</span>
          <span class="s2">selection = selection.focusOffset;</span>
          <span class="s4">try </span><span class="s2">{</span>
            <span class="s2">JSCompiler_temp.nodeType, focusNode.nodeType;</span>
          <span class="s2">} </span><span class="s4">catch </span><span class="s2">(e$22) {</span>
            <span class="s2">JSCompiler_temp = </span><span class="s4">null</span><span class="s2">;</span>
            <span class="s4">break </span><span class="s2">a;</span>
          <span class="s2">}</span>
          <span class="s4">var </span><span class="s2">length = </span><span class="s5">0</span><span class="s2">,</span>
            <span class="s2">start = -</span><span class="s5">1</span><span class="s2">,</span>
            <span class="s2">end = -</span><span class="s5">1</span><span class="s2">,</span>
            <span class="s2">indexWithinAnchor = </span><span class="s5">0</span><span class="s2">,</span>
            <span class="s2">indexWithinFocus = </span><span class="s5">0</span><span class="s2">,</span>
            <span class="s2">node = root,</span>
            <span class="s2">parentNode = </span><span class="s4">null</span><span class="s2">;</span>
          <span class="s2">b: </span><span class="s4">for </span><span class="s2">(;;) {</span>
            <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">next; ; ) {</span>
              <span class="s2">node !== JSCompiler_temp ||</span>
                <span class="s2">(</span><span class="s5">0 </span><span class="s2">!== anchorOffset &amp;&amp; </span><span class="s5">3 </span><span class="s2">!== node.nodeType) ||</span>
                <span class="s2">(start = length + anchorOffset);</span>
              <span class="s2">node !== focusNode ||</span>
                <span class="s2">(</span><span class="s5">0 </span><span class="s2">!== selection &amp;&amp; </span><span class="s5">3 </span><span class="s2">!== node.nodeType) ||</span>
                <span class="s2">(end = length + selection);</span>
              <span class="s5">3 </span><span class="s2">=== node.nodeType &amp;&amp; (length += node.nodeValue.length);</span>
              <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== (next = node.firstChild)) </span><span class="s4">break</span><span class="s2">;</span>
              <span class="s2">parentNode = node;</span>
              <span class="s2">node = next;</span>
            <span class="s2">}</span>
            <span class="s4">for </span><span class="s2">(;;) {</span>
              <span class="s4">if </span><span class="s2">(node === root) </span><span class="s4">break </span><span class="s2">b;</span>
              <span class="s2">parentNode === JSCompiler_temp &amp;&amp;</span>
                <span class="s2">++indexWithinAnchor === anchorOffset &amp;&amp;</span>
                <span class="s2">(start = length);</span>
              <span class="s2">parentNode === focusNode &amp;&amp;</span>
                <span class="s2">++indexWithinFocus === selection &amp;&amp;</span>
                <span class="s2">(end = length);</span>
              <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== (next = node.nextSibling)) </span><span class="s4">break</span><span class="s2">;</span>
              <span class="s2">node = parentNode;</span>
              <span class="s2">parentNode = node.parentNode;</span>
            <span class="s2">}</span>
            <span class="s2">node = next;</span>
          <span class="s2">}</span>
          <span class="s2">JSCompiler_temp =</span>
            <span class="s2">-</span><span class="s5">1 </span><span class="s2">=== start || -</span><span class="s5">1 </span><span class="s2">=== end ? </span><span class="s4">null </span><span class="s2">: { start: start, end: end };</span>
        <span class="s2">} </span><span class="s4">else </span><span class="s2">JSCompiler_temp = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">}</span>
    <span class="s2">JSCompiler_temp = JSCompiler_temp || { start: </span><span class="s5">0</span><span class="s2">, end: </span><span class="s5">0 </span><span class="s2">};</span>
  <span class="s2">} </span><span class="s4">else </span><span class="s2">JSCompiler_temp = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">selectionInformation = { focusedElem: root, selectionRange: JSCompiler_temp };</span>
  <span class="s2">_enabled = !</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">for </span><span class="s2">(nextEffect = firstChild; </span><span class="s4">null </span><span class="s2">!== nextEffect; )</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">((firstChild = nextEffect),</span>
      <span class="s2">(root = firstChild.child),</span>
      <span class="s5">0 </span><span class="s2">!== (firstChild.subtreeFlags &amp; </span><span class="s5">1024</span><span class="s2">) &amp;&amp; </span><span class="s4">null </span><span class="s2">!== root)</span>
    <span class="s2">)</span>
      <span class="s2">(root.return = firstChild), (nextEffect = root);</span>
    <span class="s4">else</span>
      <span class="s4">for </span><span class="s2">(; </span><span class="s4">null </span><span class="s2">!== nextEffect; ) {</span>
        <span class="s2">firstChild = nextEffect;</span>
        <span class="s2">focusNode = firstChild.alternate;</span>
        <span class="s2">root = firstChild.flags;</span>
        <span class="s4">switch </span><span class="s2">(firstChild.tag) {</span>
          <span class="s4">case </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s5">11</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s5">15</span><span class="s2">:</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (root &amp; </span><span class="s5">1024</span><span class="s2">) &amp;&amp; </span><span class="s4">null </span><span class="s2">!== focusNode) {</span>
              <span class="s2">root = </span><span class="s4">void </span><span class="s5">0</span><span class="s2">;</span>
              <span class="s2">JSCompiler_temp = firstChild;</span>
              <span class="s2">anchorOffset = focusNode.memoizedProps;</span>
              <span class="s2">focusNode = focusNode.memoizedState;</span>
              <span class="s2">selection = JSCompiler_temp.stateNode;</span>
              <span class="s4">try </span><span class="s2">{</span>
                <span class="s4">var </span><span class="s2">resolvedPrevProps = resolveClassComponentProps(</span>
                  <span class="s2">JSCompiler_temp.type,</span>
                  <span class="s2">anchorOffset,</span>
                  <span class="s2">JSCompiler_temp.elementType === JSCompiler_temp.type</span>
                <span class="s2">);</span>
                <span class="s2">root = selection.getSnapshotBeforeUpdate(</span>
                  <span class="s2">resolvedPrevProps,</span>
                  <span class="s2">focusNode</span>
                <span class="s2">);</span>
                <span class="s2">selection.__reactInternalSnapshotBeforeUpdate = root;</span>
              <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
                <span class="s2">captureCommitPhaseError(</span>
                  <span class="s2">JSCompiler_temp,</span>
                  <span class="s2">JSCompiler_temp.return,</span>
                  <span class="s2">error</span>
                <span class="s2">);</span>
              <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (root &amp; </span><span class="s5">1024</span><span class="s2">))</span>
              <span class="s4">if </span><span class="s2">(</span>
                <span class="s2">((root = firstChild.stateNode.containerInfo),</span>
                <span class="s2">(JSCompiler_temp = root.nodeType),</span>
                <span class="s5">9 </span><span class="s2">=== JSCompiler_temp)</span>
              <span class="s2">)</span>
                <span class="s2">clearContainerSparingly(root);</span>
              <span class="s4">else if </span><span class="s2">(</span><span class="s5">1 </span><span class="s2">=== JSCompiler_temp)</span>
                <span class="s4">switch </span><span class="s2">(root.nodeName) {</span>
                  <span class="s4">case </span><span class="s3">&quot;HEAD&quot;</span><span class="s2">:</span>
                  <span class="s4">case </span><span class="s3">&quot;HTML&quot;</span><span class="s2">:</span>
                  <span class="s4">case </span><span class="s3">&quot;BODY&quot;</span><span class="s2">:</span>
                    <span class="s2">clearContainerSparingly(root);</span>
                    <span class="s4">break</span><span class="s2">;</span>
                  <span class="s4">default</span><span class="s2">:</span>
                    <span class="s2">root.textContent = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
                <span class="s2">}</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s5">26</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s5">27</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s5">6</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s5">4</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s5">17</span><span class="s2">:</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">default</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (root &amp; </span><span class="s5">1024</span><span class="s2">)) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">163</span><span class="s2">));</span>
        <span class="s2">}</span>
        <span class="s2">root = firstChild.sibling;</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== root) {</span>
          <span class="s2">root.return = firstChild.return;</span>
          <span class="s2">nextEffect = root;</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s2">nextEffect = firstChild.return;</span>
      <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {</span>
  <span class="s4">var </span><span class="s2">flags = finishedWork.flags;</span>
  <span class="s4">switch </span><span class="s2">(finishedWork.tag) {</span>
    <span class="s4">case </span><span class="s5">0</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">11</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">15</span><span class="s2">:</span>
      <span class="s2">recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);</span>
      <span class="s2">flags &amp; </span><span class="s5">4 </span><span class="s2">&amp;&amp; commitHookLayoutEffects(finishedWork, </span><span class="s5">5</span><span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
      <span class="s2">recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);</span>
      <span class="s4">if </span><span class="s2">(flags &amp; </span><span class="s5">4</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s2">(((finishedRoot = finishedWork.stateNode), </span><span class="s4">null </span><span class="s2">=== current))</span>
          <span class="s4">if </span><span class="s2">(shouldProfile(finishedWork)) {</span>
            <span class="s2">startEffectTimer();</span>
            <span class="s4">try </span><span class="s2">{</span>
              <span class="s2">finishedRoot.componentDidMount();</span>
            <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
              <span class="s2">captureCommitPhaseError(finishedWork, finishedWork.return, error);</span>
            <span class="s2">}</span>
            <span class="s2">recordEffectDuration();</span>
          <span class="s2">} </span><span class="s4">else</span>
            <span class="s4">try </span><span class="s2">{</span>
              <span class="s2">finishedRoot.componentDidMount();</span>
            <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error$150) {</span>
              <span class="s2">captureCommitPhaseError(</span>
                <span class="s2">finishedWork,</span>
                <span class="s2">finishedWork.return,</span>
                <span class="s2">error$150</span>
              <span class="s2">);</span>
            <span class="s2">}</span>
        <span class="s4">else </span><span class="s2">{</span>
          <span class="s4">var </span><span class="s2">prevProps = resolveClassComponentProps(</span>
            <span class="s2">finishedWork.type,</span>
            <span class="s2">current.memoizedProps</span>
          <span class="s2">);</span>
          <span class="s2">current = current.memoizedState;</span>
          <span class="s4">if </span><span class="s2">(shouldProfile(finishedWork)) {</span>
            <span class="s2">startEffectTimer();</span>
            <span class="s4">try </span><span class="s2">{</span>
              <span class="s2">finishedRoot.componentDidUpdate(</span>
                <span class="s2">prevProps,</span>
                <span class="s2">current,</span>
                <span class="s2">finishedRoot.__reactInternalSnapshotBeforeUpdate</span>
              <span class="s2">);</span>
            <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error$151) {</span>
              <span class="s2">captureCommitPhaseError(</span>
                <span class="s2">finishedWork,</span>
                <span class="s2">finishedWork.return,</span>
                <span class="s2">error$151</span>
              <span class="s2">);</span>
            <span class="s2">}</span>
            <span class="s2">recordEffectDuration();</span>
          <span class="s2">} </span><span class="s4">else</span>
            <span class="s4">try </span><span class="s2">{</span>
              <span class="s2">finishedRoot.componentDidUpdate(</span>
                <span class="s2">prevProps,</span>
                <span class="s2">current,</span>
                <span class="s2">finishedRoot.__reactInternalSnapshotBeforeUpdate</span>
              <span class="s2">);</span>
            <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error$152) {</span>
              <span class="s2">captureCommitPhaseError(</span>
                <span class="s2">finishedWork,</span>
                <span class="s2">finishedWork.return,</span>
                <span class="s2">error$152</span>
              <span class="s2">);</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
      <span class="s2">flags &amp; </span><span class="s5">64 </span><span class="s2">&amp;&amp; commitClassCallbacks(finishedWork);</span>
      <span class="s2">flags &amp; </span><span class="s5">512 </span><span class="s2">&amp;&amp; safelyAttachRef(finishedWork, finishedWork.return);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
      <span class="s2">current = pushNestedEffectDurations();</span>
      <span class="s2">recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);</span>
      <span class="s4">if </span><span class="s2">(flags &amp; </span><span class="s5">64 </span><span class="s2">&amp;&amp; ((flags = finishedWork.updateQueue), </span><span class="s4">null </span><span class="s2">!== flags)) {</span>
        <span class="s2">prevProps = </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== finishedWork.child)</span>
          <span class="s4">switch </span><span class="s2">(finishedWork.child.tag) {</span>
            <span class="s4">case </span><span class="s5">27</span><span class="s2">:</span>
            <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
              <span class="s2">prevProps = finishedWork.child.stateNode;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
              <span class="s2">prevProps = finishedWork.child.stateNode;</span>
          <span class="s2">}</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s2">commitCallbacks(flags, prevProps);</span>
        <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
          <span class="s2">captureCommitPhaseError(finishedWork, finishedWork.return, error);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s2">finishedRoot.effectDuration += popNestedEffectDurations(current);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">27</span><span class="s2">:</span>
      <span class="s4">null </span><span class="s2">=== current &amp;&amp;</span>
        <span class="s2">flags &amp; </span><span class="s5">4 </span><span class="s2">&amp;&amp;</span>
        <span class="s2">commitHostSingletonAcquisition(finishedWork);</span>
    <span class="s4">case </span><span class="s5">26</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
      <span class="s2">recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);</span>
      <span class="s4">null </span><span class="s2">=== current &amp;&amp; flags &amp; </span><span class="s5">4 </span><span class="s2">&amp;&amp; commitHostMount(finishedWork);</span>
      <span class="s2">flags &amp; </span><span class="s5">512 </span><span class="s2">&amp;&amp; safelyAttachRef(finishedWork, finishedWork.return);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">12</span><span class="s2">:</span>
      <span class="s2">flags &amp; </span><span class="s5">4</span>
        <span class="s2">? ((flags = pushNestedEffectDurations()),</span>
          <span class="s2">recursivelyTraverseLayoutEffects(finishedRoot, finishedWork),</span>
          <span class="s2">(finishedRoot = finishedWork.stateNode),</span>
          <span class="s2">(finishedRoot.effectDuration += bubbleNestedEffectDurations(flags)),</span>
          <span class="s2">commitProfilerUpdate(</span>
            <span class="s2">finishedWork,</span>
            <span class="s2">current,</span>
            <span class="s2">commitStartTime,</span>
            <span class="s2">finishedRoot.effectDuration</span>
          <span class="s2">))</span>
        <span class="s2">: recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">13</span><span class="s2">:</span>
      <span class="s2">recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);</span>
      <span class="s2">flags &amp; </span><span class="s5">4 </span><span class="s2">&amp;&amp; commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);</span>
      <span class="s2">flags &amp; </span><span class="s5">64 </span><span class="s2">&amp;&amp;</span>
        <span class="s2">((finishedRoot = finishedWork.memoizedState),</span>
        <span class="s4">null </span><span class="s2">!== finishedRoot &amp;&amp;</span>
          <span class="s2">((finishedRoot = finishedRoot.dehydrated),</span>
          <span class="s4">null </span><span class="s2">!== finishedRoot &amp;&amp;</span>
            <span class="s2">((finishedWork = retryDehydratedSuspenseBoundary.bind(</span>
              <span class="s4">null</span><span class="s2">,</span>
              <span class="s2">finishedWork</span>
            <span class="s2">)),</span>
            <span class="s2">registerSuspenseInstanceRetry(finishedRoot, finishedWork))));</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">22</span><span class="s2">:</span>
      <span class="s2">flags = </span><span class="s4">null </span><span class="s2">!== finishedWork.memoizedState || offscreenSubtreeIsHidden;</span>
      <span class="s4">if </span><span class="s2">(!flags) {</span>
        <span class="s2">current =</span>
          <span class="s2">(</span><span class="s4">null </span><span class="s2">!== current &amp;&amp; </span><span class="s4">null </span><span class="s2">!== current.memoizedState) ||</span>
          <span class="s2">offscreenSubtreeWasHidden;</span>
        <span class="s2">prevProps = offscreenSubtreeIsHidden;</span>
        <span class="s4">var </span><span class="s2">prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;</span>
        <span class="s2">offscreenSubtreeIsHidden = flags;</span>
        <span class="s2">(offscreenSubtreeWasHidden = current) &amp;&amp; !prevOffscreenSubtreeWasHidden</span>
          <span class="s2">? recursivelyTraverseReappearLayoutEffects(</span>
              <span class="s2">finishedRoot,</span>
              <span class="s2">finishedWork,</span>
              <span class="s5">0 </span><span class="s2">!== (finishedWork.subtreeFlags &amp; </span><span class="s5">8772</span><span class="s2">)</span>
            <span class="s2">)</span>
          <span class="s2">: recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);</span>
        <span class="s2">offscreenSubtreeIsHidden = prevProps;</span>
        <span class="s2">offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;</span>
      <span class="s2">}</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">30</span><span class="s2">:</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s2">recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">detachFiberAfterEffects(fiber) {</span>
  <span class="s4">var </span><span class="s2">alternate = fiber.alternate;</span>
  <span class="s4">null </span><span class="s2">!== alternate &amp;&amp;</span>
    <span class="s2">((fiber.alternate = </span><span class="s4">null</span><span class="s2">), detachFiberAfterEffects(alternate));</span>
  <span class="s2">fiber.child = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">fiber.deletions = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">fiber.sibling = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s5">5 </span><span class="s2">=== fiber.tag &amp;&amp;</span>
    <span class="s2">((alternate = fiber.stateNode),</span>
    <span class="s4">null </span><span class="s2">!== alternate &amp;&amp; detachDeletedInstance(alternate));</span>
  <span class="s2">fiber.stateNode = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">fiber.return = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">fiber.dependencies = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">fiber.memoizedProps = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">fiber.memoizedState = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">fiber.pendingProps = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">fiber.stateNode = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">fiber.updateQueue = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">hostParent = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">hostParentIsContainer = !</span><span class="s5">1</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">recursivelyTraverseDeletionEffects(</span>
  <span class="s2">finishedRoot,</span>
  <span class="s2">nearestMountedAncestor,</span>
  <span class="s2">parent</span>
<span class="s2">) {</span>
  <span class="s4">for </span><span class="s2">(parent = parent.child; </span><span class="s4">null </span><span class="s2">!== parent; )</span>
    <span class="s2">commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),</span>
      <span class="s2">(parent = parent.sibling);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">commitDeletionEffectsOnFiber(</span>
  <span class="s2">finishedRoot,</span>
  <span class="s2">nearestMountedAncestor,</span>
  <span class="s2">deletedFiber</span>
<span class="s2">) {</span>
  <span class="s4">if </span><span class="s2">(injectedHook &amp;&amp; </span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">injectedHook.onCommitFiberUnmount)</span>
    <span class="s4">try </span><span class="s2">{</span>
      <span class="s2">injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);</span>
    <span class="s2">} </span><span class="s4">catch </span><span class="s2">(err) {}</span>
  <span class="s4">switch </span><span class="s2">(deletedFiber.tag) {</span>
    <span class="s4">case </span><span class="s5">26</span><span class="s2">:</span>
      <span class="s2">offscreenSubtreeWasHidden ||</span>
        <span class="s2">safelyDetachRef(deletedFiber, nearestMountedAncestor);</span>
      <span class="s2">recursivelyTraverseDeletionEffects(</span>
        <span class="s2">finishedRoot,</span>
        <span class="s2">nearestMountedAncestor,</span>
        <span class="s2">deletedFiber</span>
      <span class="s2">);</span>
      <span class="s2">deletedFiber.memoizedState</span>
        <span class="s2">? deletedFiber.memoizedState.count--</span>
        <span class="s2">: deletedFiber.stateNode &amp;&amp;</span>
          <span class="s2">((deletedFiber = deletedFiber.stateNode),</span>
          <span class="s2">deletedFiber.parentNode.removeChild(deletedFiber));</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">27</span><span class="s2">:</span>
      <span class="s2">offscreenSubtreeWasHidden ||</span>
        <span class="s2">safelyDetachRef(deletedFiber, nearestMountedAncestor);</span>
      <span class="s4">var </span><span class="s2">prevHostParent = hostParent,</span>
        <span class="s2">prevHostParentIsContainer = hostParentIsContainer;</span>
      <span class="s2">isSingletonScope(deletedFiber.type) &amp;&amp;</span>
        <span class="s2">((hostParent = deletedFiber.stateNode), (hostParentIsContainer = !</span><span class="s5">1</span><span class="s2">));</span>
      <span class="s2">recursivelyTraverseDeletionEffects(</span>
        <span class="s2">finishedRoot,</span>
        <span class="s2">nearestMountedAncestor,</span>
        <span class="s2">deletedFiber</span>
      <span class="s2">);</span>
      <span class="s2">releaseSingletonInstance(deletedFiber.stateNode);</span>
      <span class="s2">hostParent = prevHostParent;</span>
      <span class="s2">hostParentIsContainer = prevHostParentIsContainer;</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
      <span class="s2">offscreenSubtreeWasHidden ||</span>
        <span class="s2">safelyDetachRef(deletedFiber, nearestMountedAncestor);</span>
    <span class="s4">case </span><span class="s5">6</span><span class="s2">:</span>
      <span class="s2">prevHostParent = hostParent;</span>
      <span class="s2">prevHostParentIsContainer = hostParentIsContainer;</span>
      <span class="s2">hostParent = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">recursivelyTraverseDeletionEffects(</span>
        <span class="s2">finishedRoot,</span>
        <span class="s2">nearestMountedAncestor,</span>
        <span class="s2">deletedFiber</span>
      <span class="s2">);</span>
      <span class="s2">hostParent = prevHostParent;</span>
      <span class="s2">hostParentIsContainer = prevHostParentIsContainer;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== hostParent)</span>
        <span class="s4">if </span><span class="s2">(hostParentIsContainer)</span>
          <span class="s4">try </span><span class="s2">{</span>
            <span class="s2">(</span><span class="s5">9 </span><span class="s2">=== hostParent.nodeType</span>
              <span class="s2">? hostParent.body</span>
              <span class="s2">: </span><span class="s3">&quot;HTML&quot; </span><span class="s2">=== hostParent.nodeName</span>
                <span class="s2">? hostParent.ownerDocument.body</span>
                <span class="s2">: hostParent</span>
            <span class="s2">).removeChild(deletedFiber.stateNode);</span>
          <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
            <span class="s2">captureCommitPhaseError(</span>
              <span class="s2">deletedFiber,</span>
              <span class="s2">nearestMountedAncestor,</span>
              <span class="s2">error</span>
            <span class="s2">);</span>
          <span class="s2">}</span>
        <span class="s4">else</span>
          <span class="s4">try </span><span class="s2">{</span>
            <span class="s2">hostParent.removeChild(deletedFiber.stateNode);</span>
          <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
            <span class="s2">captureCommitPhaseError(</span>
              <span class="s2">deletedFiber,</span>
              <span class="s2">nearestMountedAncestor,</span>
              <span class="s2">error</span>
            <span class="s2">);</span>
          <span class="s2">}</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">18</span><span class="s2">:</span>
      <span class="s4">null </span><span class="s2">!== hostParent &amp;&amp;</span>
        <span class="s2">(hostParentIsContainer</span>
          <span class="s2">? ((finishedRoot = hostParent),</span>
            <span class="s2">clearSuspenseBoundary(</span>
              <span class="s5">9 </span><span class="s2">=== finishedRoot.nodeType</span>
                <span class="s2">? finishedRoot.body</span>
                <span class="s2">: </span><span class="s3">&quot;HTML&quot; </span><span class="s2">=== finishedRoot.nodeName</span>
                  <span class="s2">? finishedRoot.ownerDocument.body</span>
                  <span class="s2">: finishedRoot,</span>
              <span class="s2">deletedFiber.stateNode</span>
            <span class="s2">),</span>
            <span class="s2">retryIfBlockedOn(finishedRoot))</span>
          <span class="s2">: clearSuspenseBoundary(hostParent, deletedFiber.stateNode));</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">4</span><span class="s2">:</span>
      <span class="s2">prevHostParent = hostParent;</span>
      <span class="s2">prevHostParentIsContainer = hostParentIsContainer;</span>
      <span class="s2">hostParent = deletedFiber.stateNode.containerInfo;</span>
      <span class="s2">hostParentIsContainer = !</span><span class="s5">0</span><span class="s2">;</span>
      <span class="s2">recursivelyTraverseDeletionEffects(</span>
        <span class="s2">finishedRoot,</span>
        <span class="s2">nearestMountedAncestor,</span>
        <span class="s2">deletedFiber</span>
      <span class="s2">);</span>
      <span class="s2">hostParent = prevHostParent;</span>
      <span class="s2">hostParentIsContainer = prevHostParentIsContainer;</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">0</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">11</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">14</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">15</span><span class="s2">:</span>
      <span class="s2">offscreenSubtreeWasHidden ||</span>
        <span class="s2">commitHookEffectListUnmount(</span><span class="s5">2</span><span class="s2">, deletedFiber, nearestMountedAncestor);</span>
      <span class="s2">offscreenSubtreeWasHidden ||</span>
        <span class="s2">commitHookLayoutUnmountEffects(deletedFiber, nearestMountedAncestor, </span><span class="s5">4</span><span class="s2">);</span>
      <span class="s2">recursivelyTraverseDeletionEffects(</span>
        <span class="s2">finishedRoot,</span>
        <span class="s2">nearestMountedAncestor,</span>
        <span class="s2">deletedFiber</span>
      <span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
      <span class="s2">offscreenSubtreeWasHidden ||</span>
        <span class="s2">(safelyDetachRef(deletedFiber, nearestMountedAncestor),</span>
        <span class="s2">(prevHostParent = deletedFiber.stateNode),</span>
        <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">prevHostParent.componentWillUnmount &amp;&amp;</span>
          <span class="s2">safelyCallComponentWillUnmount(</span>
            <span class="s2">deletedFiber,</span>
            <span class="s2">nearestMountedAncestor,</span>
            <span class="s2">prevHostParent</span>
          <span class="s2">));</span>
      <span class="s2">recursivelyTraverseDeletionEffects(</span>
        <span class="s2">finishedRoot,</span>
        <span class="s2">nearestMountedAncestor,</span>
        <span class="s2">deletedFiber</span>
      <span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">21</span><span class="s2">:</span>
      <span class="s2">recursivelyTraverseDeletionEffects(</span>
        <span class="s2">finishedRoot,</span>
        <span class="s2">nearestMountedAncestor,</span>
        <span class="s2">deletedFiber</span>
      <span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">22</span><span class="s2">:</span>
      <span class="s2">offscreenSubtreeWasHidden =</span>
        <span class="s2">(prevHostParent = offscreenSubtreeWasHidden) ||</span>
        <span class="s4">null </span><span class="s2">!== deletedFiber.memoizedState;</span>
      <span class="s2">recursivelyTraverseDeletionEffects(</span>
        <span class="s2">finishedRoot,</span>
        <span class="s2">nearestMountedAncestor,</span>
        <span class="s2">deletedFiber</span>
      <span class="s2">);</span>
      <span class="s2">offscreenSubtreeWasHidden = prevHostParent;</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s2">recursivelyTraverseDeletionEffects(</span>
        <span class="s2">finishedRoot,</span>
        <span class="s2">nearestMountedAncestor,</span>
        <span class="s2">deletedFiber</span>
      <span class="s2">);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s4">null </span><span class="s2">=== finishedWork.memoizedState &amp;&amp;</span>
    <span class="s2">((finishedRoot = finishedWork.alternate),</span>
    <span class="s4">null </span><span class="s2">!== finishedRoot &amp;&amp;</span>
      <span class="s2">((finishedRoot = finishedRoot.memoizedState),</span>
      <span class="s4">null </span><span class="s2">!== finishedRoot &amp;&amp;</span>
        <span class="s2">((finishedRoot = finishedRoot.dehydrated), </span><span class="s4">null </span><span class="s2">!== finishedRoot)))</span>
  <span class="s2">)</span>
    <span class="s4">try </span><span class="s2">{</span>
      <span class="s2">retryIfBlockedOn(finishedRoot);</span>
    <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
      <span class="s2">captureCommitPhaseError(finishedWork, finishedWork.return, error);</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getRetryCache(finishedWork) {</span>
  <span class="s4">switch </span><span class="s2">(finishedWork.tag) {</span>
    <span class="s4">case </span><span class="s5">13</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">19</span><span class="s2">:</span>
      <span class="s4">var </span><span class="s2">retryCache = finishedWork.stateNode;</span>
      <span class="s4">null </span><span class="s2">=== retryCache &amp;&amp;</span>
        <span class="s2">(retryCache = finishedWork.stateNode = </span><span class="s4">new </span><span class="s2">PossiblyWeakSet());</span>
      <span class="s4">return </span><span class="s2">retryCache;</span>
    <span class="s4">case </span><span class="s5">22</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(finishedWork = finishedWork.stateNode),</span>
        <span class="s2">(retryCache = finishedWork._retryCache),</span>
        <span class="s4">null </span><span class="s2">=== retryCache &amp;&amp;</span>
          <span class="s2">(retryCache = finishedWork._retryCache = </span><span class="s4">new </span><span class="s2">PossiblyWeakSet()),</span>
        <span class="s2">retryCache</span>
      <span class="s2">);</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">435</span><span class="s2">, finishedWork.tag));</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">attachSuspenseRetryListeners(finishedWork, wakeables) {</span>
  <span class="s4">var </span><span class="s2">retryCache = getRetryCache(finishedWork);</span>
  <span class="s2">wakeables.forEach(</span><span class="s4">function </span><span class="s2">(wakeable) {</span>
    <span class="s4">var </span><span class="s2">retry = resolveRetryWakeable.bind(</span><span class="s4">null</span><span class="s2">, finishedWork, wakeable);</span>
    <span class="s4">if </span><span class="s2">(!retryCache.has(wakeable)) {</span>
      <span class="s2">retryCache.add(wakeable);</span>
      <span class="s4">if </span><span class="s2">(isDevToolsPresent)</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== inProgressLanes &amp;&amp; </span><span class="s4">null </span><span class="s2">!== inProgressRoot)</span>
          <span class="s2">restorePendingUpdaters(inProgressRoot, inProgressLanes);</span>
        <span class="s4">else throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">413</span><span class="s2">));</span>
      <span class="s2">wakeable.then(retry, retry);</span>
    <span class="s2">}</span>
  <span class="s2">});</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {</span>
  <span class="s4">var </span><span class="s2">deletions = parentFiber.deletions;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== deletions)</span>
    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; deletions.length; i++) {</span>
      <span class="s4">var </span><span class="s2">childToDelete = deletions[i],</span>
        <span class="s2">root = root$jscomp$0,</span>
        <span class="s2">returnFiber = parentFiber,</span>
        <span class="s2">parent = returnFiber;</span>
      <span class="s2">a: </span><span class="s4">for </span><span class="s2">(; </span><span class="s4">null </span><span class="s2">!== parent; ) {</span>
        <span class="s4">switch </span><span class="s2">(parent.tag) {</span>
          <span class="s4">case </span><span class="s5">27</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s2">(isSingletonScope(parent.type)) {</span>
              <span class="s2">hostParent = parent.stateNode;</span>
              <span class="s2">hostParentIsContainer = !</span><span class="s5">1</span><span class="s2">;</span>
              <span class="s4">break </span><span class="s2">a;</span>
            <span class="s2">}</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
            <span class="s2">hostParent = parent.stateNode;</span>
            <span class="s2">hostParentIsContainer = !</span><span class="s5">1</span><span class="s2">;</span>
            <span class="s4">break </span><span class="s2">a;</span>
          <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s5">4</span><span class="s2">:</span>
            <span class="s2">hostParent = parent.stateNode.containerInfo;</span>
            <span class="s2">hostParentIsContainer = !</span><span class="s5">0</span><span class="s2">;</span>
            <span class="s4">break </span><span class="s2">a;</span>
        <span class="s2">}</span>
        <span class="s2">parent = parent.return;</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== hostParent) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">160</span><span class="s2">));</span>
      <span class="s2">commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);</span>
      <span class="s2">hostParent = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">hostParentIsContainer = !</span><span class="s5">1</span><span class="s2">;</span>
      <span class="s2">root = childToDelete.alternate;</span>
      <span class="s4">null </span><span class="s2">!== root &amp;&amp; (root.return = </span><span class="s4">null</span><span class="s2">);</span>
      <span class="s2">childToDelete.return = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s4">if </span><span class="s2">(parentFiber.subtreeFlags &amp; </span><span class="s5">13878</span><span class="s2">)</span>
    <span class="s4">for </span><span class="s2">(parentFiber = parentFiber.child; </span><span class="s4">null </span><span class="s2">!== parentFiber; )</span>
      <span class="s2">commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),</span>
        <span class="s2">(parentFiber = parentFiber.sibling);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">currentHoistableRoot = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">commitMutationEffectsOnFiber(finishedWork, root) {</span>
  <span class="s4">var </span><span class="s2">current = finishedWork.alternate,</span>
    <span class="s2">flags = finishedWork.flags;</span>
  <span class="s4">switch </span><span class="s2">(finishedWork.tag) {</span>
    <span class="s4">case </span><span class="s5">0</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">11</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">14</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">15</span><span class="s2">:</span>
      <span class="s2">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s2">commitReconciliationEffects(finishedWork);</span>
      <span class="s2">flags &amp; </span><span class="s5">4 </span><span class="s2">&amp;&amp;</span>
        <span class="s2">(commitHookEffectListUnmount(</span><span class="s5">3</span><span class="s2">, finishedWork, finishedWork.return),</span>
        <span class="s2">commitHookEffectListMount(</span><span class="s5">3</span><span class="s2">, finishedWork),</span>
        <span class="s2">commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, </span><span class="s5">5</span><span class="s2">));</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
      <span class="s2">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s2">commitReconciliationEffects(finishedWork);</span>
      <span class="s2">flags &amp; </span><span class="s5">512 </span><span class="s2">&amp;&amp;</span>
        <span class="s2">(offscreenSubtreeWasHidden ||</span>
          <span class="s4">null </span><span class="s2">=== current ||</span>
          <span class="s2">safelyDetachRef(current, current.return));</span>
      <span class="s2">flags &amp; </span><span class="s5">64 </span><span class="s2">&amp;&amp;</span>
        <span class="s2">offscreenSubtreeIsHidden &amp;&amp;</span>
        <span class="s2">((finishedWork = finishedWork.updateQueue),</span>
        <span class="s4">null </span><span class="s2">!== finishedWork &amp;&amp;</span>
          <span class="s2">((flags = finishedWork.callbacks),</span>
          <span class="s4">null </span><span class="s2">!== flags &amp;&amp;</span>
            <span class="s2">((current = finishedWork.shared.hiddenCallbacks),</span>
            <span class="s2">(finishedWork.shared.hiddenCallbacks =</span>
              <span class="s4">null </span><span class="s2">=== current ? flags : current.concat(flags)))));</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">26</span><span class="s2">:</span>
      <span class="s4">var </span><span class="s2">hoistableRoot = currentHoistableRoot;</span>
      <span class="s2">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s2">commitReconciliationEffects(finishedWork);</span>
      <span class="s2">flags &amp; </span><span class="s5">512 </span><span class="s2">&amp;&amp;</span>
        <span class="s2">(offscreenSubtreeWasHidden ||</span>
          <span class="s4">null </span><span class="s2">=== current ||</span>
          <span class="s2">safelyDetachRef(current, current.return));</span>
      <span class="s4">if </span><span class="s2">(flags &amp; </span><span class="s5">4</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">((root = </span><span class="s4">null </span><span class="s2">!== current ? current.memoizedState : </span><span class="s4">null</span><span class="s2">),</span>
          <span class="s2">(flags = finishedWork.memoizedState),</span>
          <span class="s4">null </span><span class="s2">=== current)</span>
        <span class="s2">)</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== flags)</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== finishedWork.stateNode) {</span>
              <span class="s2">a: {</span>
                <span class="s2">flags = finishedWork.type;</span>
                <span class="s2">current = finishedWork.memoizedProps;</span>
                <span class="s2">root = hoistableRoot.ownerDocument || hoistableRoot;</span>
                <span class="s2">b: </span><span class="s4">switch </span><span class="s2">(flags) {</span>
                  <span class="s4">case </span><span class="s3">&quot;title&quot;</span><span class="s2">:</span>
                    <span class="s2">hoistableRoot = root.getElementsByTagName(</span><span class="s3">&quot;title&quot;</span><span class="s2">)[</span><span class="s5">0</span><span class="s2">];</span>
                    <span class="s4">if </span><span class="s2">(</span>
                      <span class="s2">!hoistableRoot ||</span>
                      <span class="s2">hoistableRoot[internalHoistableMarker] ||</span>
                      <span class="s2">hoistableRoot[internalInstanceKey] ||</span>
                      <span class="s3">&quot;http://www.w3.org/2000/svg&quot; </span><span class="s2">===</span>
                        <span class="s2">hoistableRoot.namespaceURI ||</span>
                      <span class="s2">hoistableRoot.hasAttribute(</span><span class="s3">&quot;itemprop&quot;</span><span class="s2">)</span>
                    <span class="s2">)</span>
                      <span class="s2">(hoistableRoot = root.createElement(flags)),</span>
                        <span class="s2">root.head.insertBefore(</span>
                          <span class="s2">hoistableRoot,</span>
                          <span class="s2">root.querySelector(</span><span class="s3">&quot;head &gt; title&quot;</span><span class="s2">)</span>
                        <span class="s2">);</span>
                    <span class="s2">setInitialProperties(hoistableRoot, flags, current);</span>
                    <span class="s2">hoistableRoot[internalInstanceKey] = finishedWork;</span>
                    <span class="s2">markNodeAsHoistable(hoistableRoot);</span>
                    <span class="s2">flags = hoistableRoot;</span>
                    <span class="s4">break </span><span class="s2">a;</span>
                  <span class="s4">case </span><span class="s3">&quot;link&quot;</span><span class="s2">:</span>
                    <span class="s4">var </span><span class="s2">maybeNodes = getHydratableHoistableCache(</span>
                      <span class="s3">&quot;link&quot;</span><span class="s2">,</span>
                      <span class="s3">&quot;href&quot;</span><span class="s2">,</span>
                      <span class="s2">root</span>
                    <span class="s2">).get(flags + (current.href || </span><span class="s3">&quot;&quot;</span><span class="s2">));</span>
                    <span class="s4">if </span><span class="s2">(maybeNodes)</span>
                      <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; maybeNodes.length; i++)</span>
                        <span class="s4">if </span><span class="s2">(</span>
                          <span class="s2">((hoistableRoot = maybeNodes[i]),</span>
                          <span class="s2">hoistableRoot.getAttribute(</span><span class="s3">&quot;href&quot;</span><span class="s2">) ===</span>
                            <span class="s2">(</span><span class="s4">null </span><span class="s2">== current.href || </span><span class="s3">&quot;&quot; </span><span class="s2">=== current.href</span>
                              <span class="s2">? </span><span class="s4">null</span>
                              <span class="s2">: current.href) &amp;&amp;</span>
                            <span class="s2">hoistableRoot.getAttribute(</span><span class="s3">&quot;rel&quot;</span><span class="s2">) ===</span>
                              <span class="s2">(</span><span class="s4">null </span><span class="s2">== current.rel ? </span><span class="s4">null </span><span class="s2">: current.rel) &amp;&amp;</span>
                            <span class="s2">hoistableRoot.getAttribute(</span><span class="s3">&quot;title&quot;</span><span class="s2">) ===</span>
                              <span class="s2">(</span><span class="s4">null </span><span class="s2">== current.title ? </span><span class="s4">null </span><span class="s2">: current.title) &amp;&amp;</span>
                            <span class="s2">hoistableRoot.getAttribute(</span><span class="s3">&quot;crossorigin&quot;</span><span class="s2">) ===</span>
                              <span class="s2">(</span><span class="s4">null </span><span class="s2">== current.crossOrigin</span>
                                <span class="s2">? </span><span class="s4">null</span>
                                <span class="s2">: current.crossOrigin))</span>
                        <span class="s2">) {</span>
                          <span class="s2">maybeNodes.splice(i, </span><span class="s5">1</span><span class="s2">);</span>
                          <span class="s4">break </span><span class="s2">b;</span>
                        <span class="s2">}</span>
                    <span class="s2">hoistableRoot = root.createElement(flags);</span>
                    <span class="s2">setInitialProperties(hoistableRoot, flags, current);</span>
                    <span class="s2">root.head.appendChild(hoistableRoot);</span>
                    <span class="s4">break</span><span class="s2">;</span>
                  <span class="s4">case </span><span class="s3">&quot;meta&quot;</span><span class="s2">:</span>
                    <span class="s4">if </span><span class="s2">(</span>
                      <span class="s2">(maybeNodes = getHydratableHoistableCache(</span>
                        <span class="s3">&quot;meta&quot;</span><span class="s2">,</span>
                        <span class="s3">&quot;content&quot;</span><span class="s2">,</span>
                        <span class="s2">root</span>
                      <span class="s2">).get(flags + (current.content || </span><span class="s3">&quot;&quot;</span><span class="s2">)))</span>
                    <span class="s2">)</span>
                      <span class="s4">for </span><span class="s2">(i = </span><span class="s5">0</span><span class="s2">; i &lt; maybeNodes.length; i++)</span>
                        <span class="s4">if </span><span class="s2">(</span>
                          <span class="s2">((hoistableRoot = maybeNodes[i]),</span>
                          <span class="s2">hoistableRoot.getAttribute(</span><span class="s3">&quot;content&quot;</span><span class="s2">) ===</span>
                            <span class="s2">(</span><span class="s4">null </span><span class="s2">== current.content</span>
                              <span class="s2">? </span><span class="s4">null</span>
                              <span class="s2">: </span><span class="s3">&quot;&quot; </span><span class="s2">+ current.content) &amp;&amp;</span>
                            <span class="s2">hoistableRoot.getAttribute(</span><span class="s3">&quot;name&quot;</span><span class="s2">) ===</span>
                              <span class="s2">(</span><span class="s4">null </span><span class="s2">== current.name ? </span><span class="s4">null </span><span class="s2">: current.name) &amp;&amp;</span>
                            <span class="s2">hoistableRoot.getAttribute(</span><span class="s3">&quot;property&quot;</span><span class="s2">) ===</span>
                              <span class="s2">(</span><span class="s4">null </span><span class="s2">== current.property</span>
                                <span class="s2">? </span><span class="s4">null</span>
                                <span class="s2">: current.property) &amp;&amp;</span>
                            <span class="s2">hoistableRoot.getAttribute(</span><span class="s3">&quot;http-equiv&quot;</span><span class="s2">) ===</span>
                              <span class="s2">(</span><span class="s4">null </span><span class="s2">== current.httpEquiv</span>
                                <span class="s2">? </span><span class="s4">null</span>
                                <span class="s2">: current.httpEquiv) &amp;&amp;</span>
                            <span class="s2">hoistableRoot.getAttribute(</span><span class="s3">&quot;charset&quot;</span><span class="s2">) ===</span>
                              <span class="s2">(</span><span class="s4">null </span><span class="s2">== current.charSet</span>
                                <span class="s2">? </span><span class="s4">null</span>
                                <span class="s2">: current.charSet))</span>
                        <span class="s2">) {</span>
                          <span class="s2">maybeNodes.splice(i, </span><span class="s5">1</span><span class="s2">);</span>
                          <span class="s4">break </span><span class="s2">b;</span>
                        <span class="s2">}</span>
                    <span class="s2">hoistableRoot = root.createElement(flags);</span>
                    <span class="s2">setInitialProperties(hoistableRoot, flags, current);</span>
                    <span class="s2">root.head.appendChild(hoistableRoot);</span>
                    <span class="s4">break</span><span class="s2">;</span>
                  <span class="s4">default</span><span class="s2">:</span>
                    <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">468</span><span class="s2">, flags));</span>
                <span class="s2">}</span>
                <span class="s2">hoistableRoot[internalInstanceKey] = finishedWork;</span>
                <span class="s2">markNodeAsHoistable(hoistableRoot);</span>
                <span class="s2">flags = hoistableRoot;</span>
              <span class="s2">}</span>
              <span class="s2">finishedWork.stateNode = flags;</span>
            <span class="s2">} </span><span class="s4">else</span>
              <span class="s2">mountHoistable(</span>
                <span class="s2">hoistableRoot,</span>
                <span class="s2">finishedWork.type,</span>
                <span class="s2">finishedWork.stateNode</span>
              <span class="s2">);</span>
          <span class="s4">else</span>
            <span class="s2">finishedWork.stateNode = acquireResource(</span>
              <span class="s2">hoistableRoot,</span>
              <span class="s2">flags,</span>
              <span class="s2">finishedWork.memoizedProps</span>
            <span class="s2">);</span>
        <span class="s4">else</span>
          <span class="s2">root !== flags</span>
            <span class="s2">? (</span><span class="s4">null </span><span class="s2">=== root</span>
                <span class="s2">? </span><span class="s4">null </span><span class="s2">!== current.stateNode &amp;&amp;</span>
                  <span class="s2">((current = current.stateNode),</span>
                  <span class="s2">current.parentNode.removeChild(current))</span>
                <span class="s2">: root.count--,</span>
              <span class="s4">null </span><span class="s2">=== flags</span>
                <span class="s2">? mountHoistable(</span>
                    <span class="s2">hoistableRoot,</span>
                    <span class="s2">finishedWork.type,</span>
                    <span class="s2">finishedWork.stateNode</span>
                  <span class="s2">)</span>
                <span class="s2">: acquireResource(</span>
                    <span class="s2">hoistableRoot,</span>
                    <span class="s2">flags,</span>
                    <span class="s2">finishedWork.memoizedProps</span>
                  <span class="s2">))</span>
            <span class="s2">: </span><span class="s4">null </span><span class="s2">=== flags &amp;&amp;</span>
              <span class="s4">null </span><span class="s2">!== finishedWork.stateNode &amp;&amp;</span>
              <span class="s2">commitHostUpdate(</span>
                <span class="s2">finishedWork,</span>
                <span class="s2">finishedWork.memoizedProps,</span>
                <span class="s2">current.memoizedProps</span>
              <span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">27</span><span class="s2">:</span>
      <span class="s2">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s2">commitReconciliationEffects(finishedWork);</span>
      <span class="s2">flags &amp; </span><span class="s5">512 </span><span class="s2">&amp;&amp;</span>
        <span class="s2">(offscreenSubtreeWasHidden ||</span>
          <span class="s4">null </span><span class="s2">=== current ||</span>
          <span class="s2">safelyDetachRef(current, current.return));</span>
      <span class="s4">null </span><span class="s2">!== current &amp;&amp;</span>
        <span class="s2">flags &amp; </span><span class="s5">4 </span><span class="s2">&amp;&amp;</span>
        <span class="s2">commitHostUpdate(</span>
          <span class="s2">finishedWork,</span>
          <span class="s2">finishedWork.memoizedProps,</span>
          <span class="s2">current.memoizedProps</span>
        <span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
      <span class="s2">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s2">commitReconciliationEffects(finishedWork);</span>
      <span class="s2">flags &amp; </span><span class="s5">512 </span><span class="s2">&amp;&amp;</span>
        <span class="s2">(offscreenSubtreeWasHidden ||</span>
          <span class="s4">null </span><span class="s2">=== current ||</span>
          <span class="s2">safelyDetachRef(current, current.return));</span>
      <span class="s4">if </span><span class="s2">(finishedWork.flags &amp; </span><span class="s5">32</span><span class="s2">) {</span>
        <span class="s2">root = finishedWork.stateNode;</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s2">setTextContent(root, </span><span class="s3">&quot;&quot;</span><span class="s2">);</span>
        <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
          <span class="s2">captureCommitPhaseError(finishedWork, finishedWork.return, error);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s2">flags &amp; </span><span class="s5">4 </span><span class="s2">&amp;&amp;</span>
        <span class="s4">null </span><span class="s2">!= finishedWork.stateNode &amp;&amp;</span>
        <span class="s2">((root = finishedWork.memoizedProps),</span>
        <span class="s2">commitHostUpdate(</span>
          <span class="s2">finishedWork,</span>
          <span class="s2">root,</span>
          <span class="s4">null </span><span class="s2">!== current ? current.memoizedProps : root</span>
        <span class="s2">));</span>
      <span class="s2">flags &amp; </span><span class="s5">1024 </span><span class="s2">&amp;&amp; (needsFormReset = !</span><span class="s5">0</span><span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">6</span><span class="s2">:</span>
      <span class="s2">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s2">commitReconciliationEffects(finishedWork);</span>
      <span class="s4">if </span><span class="s2">(flags &amp; </span><span class="s5">4</span><span class="s2">) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== finishedWork.stateNode)</span>
          <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">162</span><span class="s2">));</span>
        <span class="s2">flags = finishedWork.memoizedProps;</span>
        <span class="s2">current = finishedWork.stateNode;</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s2">current.nodeValue = flags;</span>
        <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
          <span class="s2">captureCommitPhaseError(finishedWork, finishedWork.return, error);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
      <span class="s2">hoistableRoot = pushNestedEffectDurations();</span>
      <span class="s2">tagCaches = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">maybeNodes = currentHoistableRoot;</span>
      <span class="s2">currentHoistableRoot = getHoistableRoot(root.containerInfo);</span>
      <span class="s2">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s2">currentHoistableRoot = maybeNodes;</span>
      <span class="s2">commitReconciliationEffects(finishedWork);</span>
      <span class="s4">if </span><span class="s2">(flags &amp; </span><span class="s5">4 </span><span class="s2">&amp;&amp; </span><span class="s4">null </span><span class="s2">!== current &amp;&amp; current.memoizedState.isDehydrated)</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s2">retryIfBlockedOn(root.containerInfo);</span>
        <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
          <span class="s2">captureCommitPhaseError(finishedWork, finishedWork.return, error);</span>
        <span class="s2">}</span>
      <span class="s2">needsFormReset &amp;&amp;</span>
        <span class="s2">((needsFormReset = !</span><span class="s5">1</span><span class="s2">), recursivelyResetForms(finishedWork));</span>
      <span class="s2">root.effectDuration += popNestedEffectDurations(hoistableRoot);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">4</span><span class="s2">:</span>
      <span class="s2">flags = currentHoistableRoot;</span>
      <span class="s2">currentHoistableRoot = getHoistableRoot(</span>
        <span class="s2">finishedWork.stateNode.containerInfo</span>
      <span class="s2">);</span>
      <span class="s2">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s2">commitReconciliationEffects(finishedWork);</span>
      <span class="s2">currentHoistableRoot = flags;</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">12</span><span class="s2">:</span>
      <span class="s2">flags = pushNestedEffectDurations();</span>
      <span class="s2">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s2">commitReconciliationEffects(finishedWork);</span>
      <span class="s2">finishedWork.stateNode.effectDuration +=</span>
        <span class="s2">bubbleNestedEffectDurations(flags);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">13</span><span class="s2">:</span>
      <span class="s2">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s2">commitReconciliationEffects(finishedWork);</span>
      <span class="s2">finishedWork.child.flags &amp; </span><span class="s5">8192 </span><span class="s2">&amp;&amp;</span>
        <span class="s2">(</span><span class="s4">null </span><span class="s2">!== finishedWork.memoizedState) !==</span>
          <span class="s2">(</span><span class="s4">null </span><span class="s2">!== current &amp;&amp; </span><span class="s4">null </span><span class="s2">!== current.memoizedState) &amp;&amp;</span>
        <span class="s2">(globalMostRecentFallbackTime = now$1());</span>
      <span class="s2">flags &amp; </span><span class="s5">4 </span><span class="s2">&amp;&amp;</span>
        <span class="s2">((flags = finishedWork.updateQueue),</span>
        <span class="s4">null </span><span class="s2">!== flags &amp;&amp;</span>
          <span class="s2">((finishedWork.updateQueue = </span><span class="s4">null</span><span class="s2">),</span>
          <span class="s2">attachSuspenseRetryListeners(finishedWork, flags)));</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">22</span><span class="s2">:</span>
      <span class="s2">hoistableRoot = </span><span class="s4">null </span><span class="s2">!== finishedWork.memoizedState;</span>
      <span class="s4">var </span><span class="s2">wasHidden = </span><span class="s4">null </span><span class="s2">!== current &amp;&amp; </span><span class="s4">null </span><span class="s2">!== current.memoizedState,</span>
        <span class="s2">prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,</span>
        <span class="s2">prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;</span>
      <span class="s2">offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;</span>
      <span class="s2">offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;</span>
      <span class="s2">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s2">offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;</span>
      <span class="s2">offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;</span>
      <span class="s2">commitReconciliationEffects(finishedWork);</span>
      <span class="s4">if </span><span class="s2">(flags &amp; </span><span class="s5">8192</span><span class="s2">)</span>
        <span class="s2">a: </span><span class="s4">for </span><span class="s2">(</span>
          <span class="s2">root = finishedWork.stateNode,</span>
            <span class="s2">root._visibility = hoistableRoot</span>
              <span class="s2">? root._visibility &amp; -</span><span class="s5">2</span>
              <span class="s2">: root._visibility | </span><span class="s5">1</span><span class="s2">,</span>
            <span class="s2">hoistableRoot &amp;&amp;</span>
              <span class="s2">(</span><span class="s4">null </span><span class="s2">=== current ||</span>
                <span class="s2">wasHidden ||</span>
                <span class="s2">offscreenSubtreeIsHidden ||</span>
                <span class="s2">offscreenSubtreeWasHidden ||</span>
                <span class="s2">recursivelyTraverseDisappearLayoutEffects(finishedWork)),</span>
            <span class="s2">current = </span><span class="s4">null</span><span class="s2">,</span>
            <span class="s2">root = finishedWork;</span>
          <span class="s2">;</span>

        <span class="s2">) {</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s5">5 </span><span class="s2">=== root.tag || </span><span class="s5">26 </span><span class="s2">=== root.tag) {</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== current) {</span>
              <span class="s2">wasHidden = current = root;</span>
              <span class="s4">try </span><span class="s2">{</span>
                <span class="s4">if </span><span class="s2">(((maybeNodes = wasHidden.stateNode), hoistableRoot))</span>
                  <span class="s2">(i = maybeNodes.style),</span>
                    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">i.setProperty</span>
                      <span class="s2">? i.setProperty(</span><span class="s3">&quot;display&quot;</span><span class="s2">, </span><span class="s3">&quot;none&quot;</span><span class="s2">, </span><span class="s3">&quot;important&quot;</span><span class="s2">)</span>
                      <span class="s2">: (i.display = </span><span class="s3">&quot;none&quot;</span><span class="s2">);</span>
                <span class="s4">else </span><span class="s2">{</span>
                  <span class="s4">var </span><span class="s2">instance = wasHidden.stateNode,</span>
                    <span class="s2">styleProp = wasHidden.memoizedProps.style,</span>
                    <span class="s2">display =</span>
                      <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== styleProp &amp;&amp;</span>
                      <span class="s4">null </span><span class="s2">!== styleProp &amp;&amp;</span>
                      <span class="s2">styleProp.hasOwnProperty(</span><span class="s3">&quot;display&quot;</span><span class="s2">)</span>
                        <span class="s2">? styleProp.display</span>
                        <span class="s2">: </span><span class="s4">null</span><span class="s2">;</span>
                  <span class="s2">instance.style.display =</span>
                    <span class="s4">null </span><span class="s2">== display || </span><span class="s3">&quot;boolean&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">display</span>
                      <span class="s2">? </span><span class="s3">&quot;&quot;</span>
                      <span class="s2">: (</span><span class="s3">&quot;&quot; </span><span class="s2">+ display).trim();</span>
                <span class="s2">}</span>
              <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
                <span class="s2">captureCommitPhaseError(wasHidden, wasHidden.return, error);</span>
              <span class="s2">}</span>
            <span class="s2">}</span>
          <span class="s2">} </span><span class="s4">else if </span><span class="s2">(</span><span class="s5">6 </span><span class="s2">=== root.tag) {</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== current) {</span>
              <span class="s2">wasHidden = root;</span>
              <span class="s4">try </span><span class="s2">{</span>
                <span class="s2">wasHidden.stateNode.nodeValue = hoistableRoot</span>
                  <span class="s2">? </span><span class="s3">&quot;&quot;</span>
                  <span class="s2">: wasHidden.memoizedProps;</span>
              <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
                <span class="s2">captureCommitPhaseError(wasHidden, wasHidden.return, error);</span>
              <span class="s2">}</span>
            <span class="s2">}</span>
          <span class="s2">} </span><span class="s4">else if </span><span class="s2">(</span>
            <span class="s2">((</span><span class="s5">22 </span><span class="s2">!== root.tag &amp;&amp; </span><span class="s5">23 </span><span class="s2">!== root.tag) ||</span>
              <span class="s4">null </span><span class="s2">=== root.memoizedState ||</span>
              <span class="s2">root === finishedWork) &amp;&amp;</span>
            <span class="s4">null </span><span class="s2">!== root.child</span>
          <span class="s2">) {</span>
            <span class="s2">root.child.return = root;</span>
            <span class="s2">root = root.child;</span>
            <span class="s4">continue</span><span class="s2">;</span>
          <span class="s2">}</span>
          <span class="s4">if </span><span class="s2">(root === finishedWork) </span><span class="s4">break </span><span class="s2">a;</span>
          <span class="s4">for </span><span class="s2">(; </span><span class="s4">null </span><span class="s2">=== root.sibling; ) {</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== root.return || root.return === finishedWork) </span><span class="s4">break </span><span class="s2">a;</span>
            <span class="s2">current === root &amp;&amp; (current = </span><span class="s4">null</span><span class="s2">);</span>
            <span class="s2">root = root.return;</span>
          <span class="s2">}</span>
          <span class="s2">current === root &amp;&amp; (current = </span><span class="s4">null</span><span class="s2">);</span>
          <span class="s2">root.sibling.return = root.return;</span>
          <span class="s2">root = root.sibling;</span>
        <span class="s2">}</span>
      <span class="s2">flags &amp; </span><span class="s5">4 </span><span class="s2">&amp;&amp;</span>
        <span class="s2">((flags = finishedWork.updateQueue),</span>
        <span class="s4">null </span><span class="s2">!== flags &amp;&amp;</span>
          <span class="s2">((current = flags.retryQueue),</span>
          <span class="s4">null </span><span class="s2">!== current &amp;&amp;</span>
            <span class="s2">((flags.retryQueue = </span><span class="s4">null</span><span class="s2">),</span>
            <span class="s2">attachSuspenseRetryListeners(finishedWork, current))));</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">19</span><span class="s2">:</span>
      <span class="s2">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s2">commitReconciliationEffects(finishedWork);</span>
      <span class="s2">flags &amp; </span><span class="s5">4 </span><span class="s2">&amp;&amp;</span>
        <span class="s2">((flags = finishedWork.updateQueue),</span>
        <span class="s4">null </span><span class="s2">!== flags &amp;&amp;</span>
          <span class="s2">((finishedWork.updateQueue = </span><span class="s4">null</span><span class="s2">),</span>
          <span class="s2">attachSuspenseRetryListeners(finishedWork, flags)));</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">30</span><span class="s2">:</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">21</span><span class="s2">:</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s2">recursivelyTraverseMutationEffects(root, finishedWork),</span>
        <span class="s2">commitReconciliationEffects(finishedWork);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">commitReconciliationEffects(finishedWork) {</span>
  <span class="s4">var </span><span class="s2">flags = finishedWork.flags;</span>
  <span class="s4">if </span><span class="s2">(flags &amp; </span><span class="s5">2</span><span class="s2">) {</span>
    <span class="s4">try </span><span class="s2">{</span>
      <span class="s4">for </span><span class="s2">(</span>
        <span class="s4">var </span><span class="s2">hostParentFiber, parentFiber = finishedWork.return;</span>
        <span class="s4">null </span><span class="s2">!== parentFiber;</span>

      <span class="s2">) {</span>
        <span class="s4">if </span><span class="s2">(isHostParent(parentFiber)) {</span>
          <span class="s2">hostParentFiber = parentFiber;</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s2">parentFiber = parentFiber.return;</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">== hostParentFiber) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">160</span><span class="s2">));</span>
      <span class="s4">switch </span><span class="s2">(hostParentFiber.tag) {</span>
        <span class="s4">case </span><span class="s5">27</span><span class="s2">:</span>
          <span class="s4">var </span><span class="s2">parent = hostParentFiber.stateNode,</span>
            <span class="s2">before = getHostSibling(finishedWork);</span>
          <span class="s2">insertOrAppendPlacementNode(finishedWork, before, parent);</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
          <span class="s4">var </span><span class="s2">parent$155 = hostParentFiber.stateNode;</span>
          <span class="s2">hostParentFiber.flags &amp; </span><span class="s5">32 </span><span class="s2">&amp;&amp;</span>
            <span class="s2">(setTextContent(parent$155, </span><span class="s3">&quot;&quot;</span><span class="s2">), (hostParentFiber.flags &amp;= -</span><span class="s5">33</span><span class="s2">));</span>
          <span class="s4">var </span><span class="s2">before$156 = getHostSibling(finishedWork);</span>
          <span class="s2">insertOrAppendPlacementNode(finishedWork, before$156, parent$155);</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s5">4</span><span class="s2">:</span>
          <span class="s4">var </span><span class="s2">parent$157 = hostParentFiber.stateNode.containerInfo,</span>
            <span class="s2">before$158 = getHostSibling(finishedWork);</span>
          <span class="s2">insertOrAppendPlacementNodeIntoContainer(</span>
            <span class="s2">finishedWork,</span>
            <span class="s2">before$158,</span>
            <span class="s2">parent$157</span>
          <span class="s2">);</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">default</span><span class="s2">:</span>
          <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">161</span><span class="s2">));</span>
      <span class="s2">}</span>
    <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
      <span class="s2">captureCommitPhaseError(finishedWork, finishedWork.return, error);</span>
    <span class="s2">}</span>
    <span class="s2">finishedWork.flags &amp;= -</span><span class="s5">3</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s2">flags &amp; </span><span class="s5">4096 </span><span class="s2">&amp;&amp; (finishedWork.flags &amp;= -</span><span class="s5">4097</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">recursivelyResetForms(parentFiber) {</span>
  <span class="s4">if </span><span class="s2">(parentFiber.subtreeFlags &amp; </span><span class="s5">1024</span><span class="s2">)</span>
    <span class="s4">for </span><span class="s2">(parentFiber = parentFiber.child; </span><span class="s4">null </span><span class="s2">!== parentFiber; ) {</span>
      <span class="s4">var </span><span class="s2">fiber = parentFiber;</span>
      <span class="s2">recursivelyResetForms(fiber);</span>
      <span class="s5">5 </span><span class="s2">=== fiber.tag &amp;&amp; fiber.flags &amp; </span><span class="s5">1024 </span><span class="s2">&amp;&amp; fiber.stateNode.reset();</span>
      <span class="s2">parentFiber = parentFiber.sibling;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">recursivelyTraverseLayoutEffects(root, parentFiber) {</span>
  <span class="s4">if </span><span class="s2">(parentFiber.subtreeFlags &amp; </span><span class="s5">8772</span><span class="s2">)</span>
    <span class="s4">for </span><span class="s2">(parentFiber = parentFiber.child; </span><span class="s4">null </span><span class="s2">!== parentFiber; )</span>
      <span class="s2">commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),</span>
        <span class="s2">(parentFiber = parentFiber.sibling);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">recursivelyTraverseDisappearLayoutEffects(parentFiber) {</span>
  <span class="s4">for </span><span class="s2">(parentFiber = parentFiber.child; </span><span class="s4">null </span><span class="s2">!== parentFiber; ) {</span>
    <span class="s4">var </span><span class="s2">finishedWork = parentFiber;</span>
    <span class="s4">switch </span><span class="s2">(finishedWork.tag) {</span>
      <span class="s4">case </span><span class="s5">0</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s5">11</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s5">14</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s5">15</span><span class="s2">:</span>
        <span class="s2">commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, </span><span class="s5">4</span><span class="s2">);</span>
        <span class="s2">recursivelyTraverseDisappearLayoutEffects(finishedWork);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s2">safelyDetachRef(finishedWork, finishedWork.return);</span>
        <span class="s4">var </span><span class="s2">instance = finishedWork.stateNode;</span>
        <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">instance.componentWillUnmount &amp;&amp;</span>
          <span class="s2">safelyCallComponentWillUnmount(</span>
            <span class="s2">finishedWork,</span>
            <span class="s2">finishedWork.return,</span>
            <span class="s2">instance</span>
          <span class="s2">);</span>
        <span class="s2">recursivelyTraverseDisappearLayoutEffects(finishedWork);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s5">27</span><span class="s2">:</span>
        <span class="s2">releaseSingletonInstance(finishedWork.stateNode);</span>
      <span class="s4">case </span><span class="s5">26</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
        <span class="s2">safelyDetachRef(finishedWork, finishedWork.return);</span>
        <span class="s2">recursivelyTraverseDisappearLayoutEffects(finishedWork);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s5">22</span><span class="s2">:</span>
        <span class="s4">null </span><span class="s2">=== finishedWork.memoizedState &amp;&amp;</span>
          <span class="s2">recursivelyTraverseDisappearLayoutEffects(finishedWork);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s5">30</span><span class="s2">:</span>
        <span class="s2">recursivelyTraverseDisappearLayoutEffects(finishedWork);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">default</span><span class="s2">:</span>
        <span class="s2">recursivelyTraverseDisappearLayoutEffects(finishedWork);</span>
    <span class="s2">}</span>
    <span class="s2">parentFiber = parentFiber.sibling;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">recursivelyTraverseReappearLayoutEffects(</span>
  <span class="s2">finishedRoot$jscomp$0,</span>
  <span class="s2">parentFiber,</span>
  <span class="s2">includeWorkInProgressEffects</span>
<span class="s2">) {</span>
  <span class="s2">includeWorkInProgressEffects =</span>
    <span class="s2">includeWorkInProgressEffects &amp;&amp; </span><span class="s5">0 </span><span class="s2">!== (parentFiber.subtreeFlags &amp; </span><span class="s5">8772</span><span class="s2">);</span>
  <span class="s4">for </span><span class="s2">(parentFiber = parentFiber.child; </span><span class="s4">null </span><span class="s2">!== parentFiber; ) {</span>
    <span class="s4">var </span><span class="s2">current = parentFiber.alternate,</span>
      <span class="s2">finishedRoot = finishedRoot$jscomp$0,</span>
      <span class="s2">finishedWork = parentFiber,</span>
      <span class="s2">flags = finishedWork.flags;</span>
    <span class="s4">switch </span><span class="s2">(finishedWork.tag) {</span>
      <span class="s4">case </span><span class="s5">0</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s5">11</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s5">15</span><span class="s2">:</span>
        <span class="s2">recursivelyTraverseReappearLayoutEffects(</span>
          <span class="s2">finishedRoot,</span>
          <span class="s2">finishedWork,</span>
          <span class="s2">includeWorkInProgressEffects</span>
        <span class="s2">);</span>
        <span class="s2">commitHookLayoutEffects(finishedWork, </span><span class="s5">4</span><span class="s2">);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s2">recursivelyTraverseReappearLayoutEffects(</span>
          <span class="s2">finishedRoot,</span>
          <span class="s2">finishedWork,</span>
          <span class="s2">includeWorkInProgressEffects</span>
        <span class="s2">);</span>
        <span class="s2">current = finishedWork;</span>
        <span class="s2">finishedRoot = current.stateNode;</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">finishedRoot.componentDidMount)</span>
          <span class="s4">try </span><span class="s2">{</span>
            <span class="s2">finishedRoot.componentDidMount();</span>
          <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
            <span class="s2">captureCommitPhaseError(current, current.return, error);</span>
          <span class="s2">}</span>
        <span class="s2">current = finishedWork;</span>
        <span class="s2">finishedRoot = current.updateQueue;</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== finishedRoot) {</span>
          <span class="s4">var </span><span class="s2">instance = current.stateNode;</span>
          <span class="s4">try </span><span class="s2">{</span>
            <span class="s4">var </span><span class="s2">hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== hiddenCallbacks)</span>
              <span class="s4">for </span><span class="s2">(</span>
                <span class="s2">finishedRoot.shared.hiddenCallbacks = </span><span class="s4">null</span><span class="s2">, finishedRoot = </span><span class="s5">0</span><span class="s2">;</span>
                <span class="s2">finishedRoot &lt; hiddenCallbacks.length;</span>
                <span class="s2">finishedRoot++</span>
              <span class="s2">)</span>
                <span class="s2">callCallback(hiddenCallbacks[finishedRoot], instance);</span>
          <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
            <span class="s2">captureCommitPhaseError(current, current.return, error);</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s2">includeWorkInProgressEffects &amp;&amp;</span>
          <span class="s2">flags &amp; </span><span class="s5">64 </span><span class="s2">&amp;&amp;</span>
          <span class="s2">commitClassCallbacks(finishedWork);</span>
        <span class="s2">safelyAttachRef(finishedWork, finishedWork.return);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s5">27</span><span class="s2">:</span>
        <span class="s2">commitHostSingletonAcquisition(finishedWork);</span>
      <span class="s4">case </span><span class="s5">26</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
        <span class="s2">recursivelyTraverseReappearLayoutEffects(</span>
          <span class="s2">finishedRoot,</span>
          <span class="s2">finishedWork,</span>
          <span class="s2">includeWorkInProgressEffects</span>
        <span class="s2">);</span>
        <span class="s2">includeWorkInProgressEffects &amp;&amp;</span>
          <span class="s4">null </span><span class="s2">=== current &amp;&amp;</span>
          <span class="s2">flags &amp; </span><span class="s5">4 </span><span class="s2">&amp;&amp;</span>
          <span class="s2">commitHostMount(finishedWork);</span>
        <span class="s2">safelyAttachRef(finishedWork, finishedWork.return);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s5">12</span><span class="s2">:</span>
        <span class="s2">includeWorkInProgressEffects &amp;&amp; flags &amp; </span><span class="s5">4</span>
          <span class="s2">? ((flags = pushNestedEffectDurations()),</span>
            <span class="s2">recursivelyTraverseReappearLayoutEffects(</span>
              <span class="s2">finishedRoot,</span>
              <span class="s2">finishedWork,</span>
              <span class="s2">includeWorkInProgressEffects</span>
            <span class="s2">),</span>
            <span class="s2">(finishedRoot = finishedWork.stateNode),</span>
            <span class="s2">(finishedRoot.effectDuration += bubbleNestedEffectDurations(flags)),</span>
            <span class="s2">commitProfilerUpdate(</span>
              <span class="s2">finishedWork,</span>
              <span class="s2">current,</span>
              <span class="s2">commitStartTime,</span>
              <span class="s2">finishedRoot.effectDuration</span>
            <span class="s2">))</span>
          <span class="s2">: recursivelyTraverseReappearLayoutEffects(</span>
              <span class="s2">finishedRoot,</span>
              <span class="s2">finishedWork,</span>
              <span class="s2">includeWorkInProgressEffects</span>
            <span class="s2">);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s5">13</span><span class="s2">:</span>
        <span class="s2">recursivelyTraverseReappearLayoutEffects(</span>
          <span class="s2">finishedRoot,</span>
          <span class="s2">finishedWork,</span>
          <span class="s2">includeWorkInProgressEffects</span>
        <span class="s2">);</span>
        <span class="s2">includeWorkInProgressEffects &amp;&amp;</span>
          <span class="s2">flags &amp; </span><span class="s5">4 </span><span class="s2">&amp;&amp;</span>
          <span class="s2">commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s5">22</span><span class="s2">:</span>
        <span class="s4">null </span><span class="s2">=== finishedWork.memoizedState &amp;&amp;</span>
          <span class="s2">recursivelyTraverseReappearLayoutEffects(</span>
            <span class="s2">finishedRoot,</span>
            <span class="s2">finishedWork,</span>
            <span class="s2">includeWorkInProgressEffects</span>
          <span class="s2">);</span>
        <span class="s2">safelyAttachRef(finishedWork, finishedWork.return);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s5">30</span><span class="s2">:</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">default</span><span class="s2">:</span>
        <span class="s2">recursivelyTraverseReappearLayoutEffects(</span>
          <span class="s2">finishedRoot,</span>
          <span class="s2">finishedWork,</span>
          <span class="s2">includeWorkInProgressEffects</span>
        <span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s2">parentFiber = parentFiber.sibling;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">commitOffscreenPassiveMountEffects(current, finishedWork) {</span>
  <span class="s4">var </span><span class="s2">previousCache = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">null </span><span class="s2">!== current &amp;&amp;</span>
    <span class="s4">null </span><span class="s2">!== current.memoizedState &amp;&amp;</span>
    <span class="s4">null </span><span class="s2">!== current.memoizedState.cachePool &amp;&amp;</span>
    <span class="s2">(previousCache = current.memoizedState.cachePool.pool);</span>
  <span class="s2">current = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">null </span><span class="s2">!== finishedWork.memoizedState &amp;&amp;</span>
    <span class="s4">null </span><span class="s2">!== finishedWork.memoizedState.cachePool &amp;&amp;</span>
    <span class="s2">(current = finishedWork.memoizedState.cachePool.pool);</span>
  <span class="s2">current !== previousCache &amp;&amp;</span>
    <span class="s2">(</span><span class="s4">null </span><span class="s2">!= current &amp;&amp; current.refCount++,</span>
    <span class="s4">null </span><span class="s2">!= previousCache &amp;&amp; releaseCache(previousCache));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">commitCachePassiveMountEffect(current, finishedWork) {</span>
  <span class="s2">current = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">null </span><span class="s2">!== finishedWork.alternate &amp;&amp;</span>
    <span class="s2">(current = finishedWork.alternate.memoizedState.cache);</span>
  <span class="s2">finishedWork = finishedWork.memoizedState.cache;</span>
  <span class="s2">finishedWork !== current &amp;&amp;</span>
    <span class="s2">(finishedWork.refCount++, </span><span class="s4">null </span><span class="s2">!= current &amp;&amp; releaseCache(current));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">recursivelyTraversePassiveMountEffects(</span>
  <span class="s2">root,</span>
  <span class="s2">parentFiber,</span>
  <span class="s2">committedLanes,</span>
  <span class="s2">committedTransitions</span>
<span class="s2">) {</span>
  <span class="s4">if </span><span class="s2">(parentFiber.subtreeFlags &amp; </span><span class="s5">10256</span><span class="s2">)</span>
    <span class="s4">for </span><span class="s2">(parentFiber = parentFiber.child; </span><span class="s4">null </span><span class="s2">!== parentFiber; )</span>
      <span class="s2">commitPassiveMountOnFiber(</span>
        <span class="s2">root,</span>
        <span class="s2">parentFiber,</span>
        <span class="s2">committedLanes,</span>
        <span class="s2">committedTransitions</span>
      <span class="s2">),</span>
        <span class="s2">(parentFiber = parentFiber.sibling);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">commitPassiveMountOnFiber(</span>
  <span class="s2">finishedRoot,</span>
  <span class="s2">finishedWork,</span>
  <span class="s2">committedLanes,</span>
  <span class="s2">committedTransitions</span>
<span class="s2">) {</span>
  <span class="s4">var </span><span class="s2">flags = finishedWork.flags;</span>
  <span class="s4">switch </span><span class="s2">(finishedWork.tag) {</span>
    <span class="s4">case </span><span class="s5">0</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">11</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">15</span><span class="s2">:</span>
      <span class="s2">recursivelyTraversePassiveMountEffects(</span>
        <span class="s2">finishedRoot,</span>
        <span class="s2">finishedWork,</span>
        <span class="s2">committedLanes,</span>
        <span class="s2">committedTransitions</span>
      <span class="s2">);</span>
      <span class="s2">flags &amp; </span><span class="s5">2048 </span><span class="s2">&amp;&amp; commitHookPassiveMountEffects(finishedWork, </span><span class="s5">9</span><span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
      <span class="s2">recursivelyTraversePassiveMountEffects(</span>
        <span class="s2">finishedRoot,</span>
        <span class="s2">finishedWork,</span>
        <span class="s2">committedLanes,</span>
        <span class="s2">committedTransitions</span>
      <span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
      <span class="s4">var </span><span class="s2">prevEffectDuration = pushNestedEffectDurations();</span>
      <span class="s2">recursivelyTraversePassiveMountEffects(</span>
        <span class="s2">finishedRoot,</span>
        <span class="s2">finishedWork,</span>
        <span class="s2">committedLanes,</span>
        <span class="s2">committedTransitions</span>
      <span class="s2">);</span>
      <span class="s2">flags &amp; </span><span class="s5">2048 </span><span class="s2">&amp;&amp;</span>
        <span class="s2">((committedLanes = </span><span class="s4">null</span><span class="s2">),</span>
        <span class="s4">null </span><span class="s2">!== finishedWork.alternate &amp;&amp;</span>
          <span class="s2">(committedLanes = finishedWork.alternate.memoizedState.cache),</span>
        <span class="s2">(finishedWork = finishedWork.memoizedState.cache),</span>
        <span class="s2">finishedWork !== committedLanes &amp;&amp;</span>
          <span class="s2">(finishedWork.refCount++,</span>
          <span class="s4">null </span><span class="s2">!= committedLanes &amp;&amp; releaseCache(committedLanes)));</span>
      <span class="s2">finishedRoot.passiveEffectDuration +=</span>
        <span class="s2">popNestedEffectDurations(prevEffectDuration);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">12</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(flags &amp; </span><span class="s5">2048</span><span class="s2">) {</span>
        <span class="s2">flags = pushNestedEffectDurations();</span>
        <span class="s2">recursivelyTraversePassiveMountEffects(</span>
          <span class="s2">finishedRoot,</span>
          <span class="s2">finishedWork,</span>
          <span class="s2">committedLanes,</span>
          <span class="s2">committedTransitions</span>
        <span class="s2">);</span>
        <span class="s2">finishedRoot = finishedWork.stateNode;</span>
        <span class="s2">finishedRoot.passiveEffectDuration +=</span>
          <span class="s2">bubbleNestedEffectDurations(flags);</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s2">prevEffectDuration = finishedWork.memoizedProps;</span>
          <span class="s4">var </span><span class="s2">id = prevEffectDuration.id,</span>
            <span class="s2">onPostCommit = prevEffectDuration.onPostCommit,</span>
            <span class="s2">phase = </span><span class="s4">null </span><span class="s2">=== finishedWork.alternate ? </span><span class="s3">&quot;mount&quot; </span><span class="s2">: </span><span class="s3">&quot;update&quot;</span><span class="s2">;</span>
          <span class="s2">currentUpdateIsNested &amp;&amp; (phase = </span><span class="s3">&quot;nested-update&quot;</span><span class="s2">);</span>
          <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">onPostCommit &amp;&amp;</span>
            <span class="s2">onPostCommit(</span>
              <span class="s2">id,</span>
              <span class="s2">phase,</span>
              <span class="s2">finishedRoot.passiveEffectDuration,</span>
              <span class="s2">commitStartTime</span>
            <span class="s2">);</span>
        <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
          <span class="s2">captureCommitPhaseError(finishedWork, finishedWork.return, error);</span>
        <span class="s2">}</span>
      <span class="s2">} </span><span class="s4">else</span>
        <span class="s2">recursivelyTraversePassiveMountEffects(</span>
          <span class="s2">finishedRoot,</span>
          <span class="s2">finishedWork,</span>
          <span class="s2">committedLanes,</span>
          <span class="s2">committedTransitions</span>
        <span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">13</span><span class="s2">:</span>
      <span class="s2">recursivelyTraversePassiveMountEffects(</span>
        <span class="s2">finishedRoot,</span>
        <span class="s2">finishedWork,</span>
        <span class="s2">committedLanes,</span>
        <span class="s2">committedTransitions</span>
      <span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">23</span><span class="s2">:</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">22</span><span class="s2">:</span>
      <span class="s2">prevEffectDuration = finishedWork.stateNode;</span>
      <span class="s2">id = finishedWork.alternate;</span>
      <span class="s4">null </span><span class="s2">!== finishedWork.memoizedState</span>
        <span class="s2">? prevEffectDuration._visibility &amp; </span><span class="s5">2</span>
          <span class="s2">? recursivelyTraversePassiveMountEffects(</span>
              <span class="s2">finishedRoot,</span>
              <span class="s2">finishedWork,</span>
              <span class="s2">committedLanes,</span>
              <span class="s2">committedTransitions</span>
            <span class="s2">)</span>
          <span class="s2">: recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork)</span>
        <span class="s2">: prevEffectDuration._visibility &amp; </span><span class="s5">2</span>
          <span class="s2">? recursivelyTraversePassiveMountEffects(</span>
              <span class="s2">finishedRoot,</span>
              <span class="s2">finishedWork,</span>
              <span class="s2">committedLanes,</span>
              <span class="s2">committedTransitions</span>
            <span class="s2">)</span>
          <span class="s2">: ((prevEffectDuration._visibility |= </span><span class="s5">2</span><span class="s2">),</span>
            <span class="s2">recursivelyTraverseReconnectPassiveEffects(</span>
              <span class="s2">finishedRoot,</span>
              <span class="s2">finishedWork,</span>
              <span class="s2">committedLanes,</span>
              <span class="s2">committedTransitions,</span>
              <span class="s5">0 </span><span class="s2">!== (finishedWork.subtreeFlags &amp; </span><span class="s5">10256</span><span class="s2">)</span>
            <span class="s2">));</span>
      <span class="s2">flags &amp; </span><span class="s5">2048 </span><span class="s2">&amp;&amp; commitOffscreenPassiveMountEffects(id, finishedWork);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">24</span><span class="s2">:</span>
      <span class="s2">recursivelyTraversePassiveMountEffects(</span>
        <span class="s2">finishedRoot,</span>
        <span class="s2">finishedWork,</span>
        <span class="s2">committedLanes,</span>
        <span class="s2">committedTransitions</span>
      <span class="s2">);</span>
      <span class="s2">flags &amp; </span><span class="s5">2048 </span><span class="s2">&amp;&amp;</span>
        <span class="s2">commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s2">recursivelyTraversePassiveMountEffects(</span>
        <span class="s2">finishedRoot,</span>
        <span class="s2">finishedWork,</span>
        <span class="s2">committedLanes,</span>
        <span class="s2">committedTransitions</span>
      <span class="s2">);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">recursivelyTraverseReconnectPassiveEffects(</span>
  <span class="s2">finishedRoot$jscomp$0,</span>
  <span class="s2">parentFiber,</span>
  <span class="s2">committedLanes$jscomp$0,</span>
  <span class="s2">committedTransitions$jscomp$0,</span>
  <span class="s2">includeWorkInProgressEffects</span>
<span class="s2">) {</span>
  <span class="s2">includeWorkInProgressEffects =</span>
    <span class="s2">includeWorkInProgressEffects &amp;&amp; </span><span class="s5">0 </span><span class="s2">!== (parentFiber.subtreeFlags &amp; </span><span class="s5">10256</span><span class="s2">);</span>
  <span class="s4">for </span><span class="s2">(parentFiber = parentFiber.child; </span><span class="s4">null </span><span class="s2">!== parentFiber; ) {</span>
    <span class="s4">var </span><span class="s2">finishedRoot = finishedRoot$jscomp$0,</span>
      <span class="s2">finishedWork = parentFiber,</span>
      <span class="s2">committedLanes = committedLanes$jscomp$0,</span>
      <span class="s2">committedTransitions = committedTransitions$jscomp$0,</span>
      <span class="s2">flags = finishedWork.flags;</span>
    <span class="s4">switch </span><span class="s2">(finishedWork.tag) {</span>
      <span class="s4">case </span><span class="s5">0</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s5">11</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s5">15</span><span class="s2">:</span>
        <span class="s2">recursivelyTraverseReconnectPassiveEffects(</span>
          <span class="s2">finishedRoot,</span>
          <span class="s2">finishedWork,</span>
          <span class="s2">committedLanes,</span>
          <span class="s2">committedTransitions,</span>
          <span class="s2">includeWorkInProgressEffects</span>
        <span class="s2">);</span>
        <span class="s2">commitHookPassiveMountEffects(finishedWork, </span><span class="s5">8</span><span class="s2">);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s5">23</span><span class="s2">:</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s5">22</span><span class="s2">:</span>
        <span class="s4">var </span><span class="s2">instance = finishedWork.stateNode;</span>
        <span class="s4">null </span><span class="s2">!== finishedWork.memoizedState</span>
          <span class="s2">? instance._visibility &amp; </span><span class="s5">2</span>
            <span class="s2">? recursivelyTraverseReconnectPassiveEffects(</span>
                <span class="s2">finishedRoot,</span>
                <span class="s2">finishedWork,</span>
                <span class="s2">committedLanes,</span>
                <span class="s2">committedTransitions,</span>
                <span class="s2">includeWorkInProgressEffects</span>
              <span class="s2">)</span>
            <span class="s2">: recursivelyTraverseAtomicPassiveEffects(</span>
                <span class="s2">finishedRoot,</span>
                <span class="s2">finishedWork</span>
              <span class="s2">)</span>
          <span class="s2">: ((instance._visibility |= </span><span class="s5">2</span><span class="s2">),</span>
            <span class="s2">recursivelyTraverseReconnectPassiveEffects(</span>
              <span class="s2">finishedRoot,</span>
              <span class="s2">finishedWork,</span>
              <span class="s2">committedLanes,</span>
              <span class="s2">committedTransitions,</span>
              <span class="s2">includeWorkInProgressEffects</span>
            <span class="s2">));</span>
        <span class="s2">includeWorkInProgressEffects &amp;&amp;</span>
          <span class="s2">flags &amp; </span><span class="s5">2048 </span><span class="s2">&amp;&amp;</span>
          <span class="s2">commitOffscreenPassiveMountEffects(</span>
            <span class="s2">finishedWork.alternate,</span>
            <span class="s2">finishedWork</span>
          <span class="s2">);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s5">24</span><span class="s2">:</span>
        <span class="s2">recursivelyTraverseReconnectPassiveEffects(</span>
          <span class="s2">finishedRoot,</span>
          <span class="s2">finishedWork,</span>
          <span class="s2">committedLanes,</span>
          <span class="s2">committedTransitions,</span>
          <span class="s2">includeWorkInProgressEffects</span>
        <span class="s2">);</span>
        <span class="s2">includeWorkInProgressEffects &amp;&amp;</span>
          <span class="s2">flags &amp; </span><span class="s5">2048 </span><span class="s2">&amp;&amp;</span>
          <span class="s2">commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">default</span><span class="s2">:</span>
        <span class="s2">recursivelyTraverseReconnectPassiveEffects(</span>
          <span class="s2">finishedRoot,</span>
          <span class="s2">finishedWork,</span>
          <span class="s2">committedLanes,</span>
          <span class="s2">committedTransitions,</span>
          <span class="s2">includeWorkInProgressEffects</span>
        <span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s2">parentFiber = parentFiber.sibling;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">recursivelyTraverseAtomicPassiveEffects(</span>
  <span class="s2">finishedRoot$jscomp$0,</span>
  <span class="s2">parentFiber</span>
<span class="s2">) {</span>
  <span class="s4">if </span><span class="s2">(parentFiber.subtreeFlags &amp; </span><span class="s5">10256</span><span class="s2">)</span>
    <span class="s4">for </span><span class="s2">(parentFiber = parentFiber.child; </span><span class="s4">null </span><span class="s2">!== parentFiber; ) {</span>
      <span class="s4">var </span><span class="s2">finishedRoot = finishedRoot$jscomp$0,</span>
        <span class="s2">finishedWork = parentFiber,</span>
        <span class="s2">flags = finishedWork.flags;</span>
      <span class="s4">switch </span><span class="s2">(finishedWork.tag) {</span>
        <span class="s4">case </span><span class="s5">22</span><span class="s2">:</span>
          <span class="s2">recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);</span>
          <span class="s2">flags &amp; </span><span class="s5">2048 </span><span class="s2">&amp;&amp;</span>
            <span class="s2">commitOffscreenPassiveMountEffects(</span>
              <span class="s2">finishedWork.alternate,</span>
              <span class="s2">finishedWork</span>
            <span class="s2">);</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s5">24</span><span class="s2">:</span>
          <span class="s2">recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);</span>
          <span class="s2">flags &amp; </span><span class="s5">2048 </span><span class="s2">&amp;&amp;</span>
            <span class="s2">commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">default</span><span class="s2">:</span>
          <span class="s2">recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);</span>
      <span class="s2">}</span>
      <span class="s2">parentFiber = parentFiber.sibling;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">suspenseyCommitFlag = </span><span class="s5">8192</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">recursivelyAccumulateSuspenseyCommit(parentFiber) {</span>
  <span class="s4">if </span><span class="s2">(parentFiber.subtreeFlags &amp; suspenseyCommitFlag)</span>
    <span class="s4">for </span><span class="s2">(parentFiber = parentFiber.child; </span><span class="s4">null </span><span class="s2">!== parentFiber; )</span>
      <span class="s2">accumulateSuspenseyCommitOnFiber(parentFiber),</span>
        <span class="s2">(parentFiber = parentFiber.sibling);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">accumulateSuspenseyCommitOnFiber(fiber) {</span>
  <span class="s4">switch </span><span class="s2">(fiber.tag) {</span>
    <span class="s4">case </span><span class="s5">26</span><span class="s2">:</span>
      <span class="s2">recursivelyAccumulateSuspenseyCommit(fiber);</span>
      <span class="s2">fiber.flags &amp; suspenseyCommitFlag &amp;&amp;</span>
        <span class="s4">null </span><span class="s2">!== fiber.memoizedState &amp;&amp;</span>
        <span class="s2">suspendResource(</span>
          <span class="s2">currentHoistableRoot,</span>
          <span class="s2">fiber.memoizedState,</span>
          <span class="s2">fiber.memoizedProps</span>
        <span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
      <span class="s2">recursivelyAccumulateSuspenseyCommit(fiber);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">4</span><span class="s2">:</span>
      <span class="s4">var </span><span class="s2">previousHoistableRoot = currentHoistableRoot;</span>
      <span class="s2">currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);</span>
      <span class="s2">recursivelyAccumulateSuspenseyCommit(fiber);</span>
      <span class="s2">currentHoistableRoot = previousHoistableRoot;</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">22</span><span class="s2">:</span>
      <span class="s4">null </span><span class="s2">=== fiber.memoizedState &amp;&amp;</span>
        <span class="s2">((previousHoistableRoot = fiber.alternate),</span>
        <span class="s4">null </span><span class="s2">!== previousHoistableRoot &amp;&amp;</span>
        <span class="s4">null </span><span class="s2">!== previousHoistableRoot.memoizedState</span>
          <span class="s2">? ((previousHoistableRoot = suspenseyCommitFlag),</span>
            <span class="s2">(suspenseyCommitFlag = </span><span class="s5">16777216</span><span class="s2">),</span>
            <span class="s2">recursivelyAccumulateSuspenseyCommit(fiber),</span>
            <span class="s2">(suspenseyCommitFlag = previousHoistableRoot))</span>
          <span class="s2">: recursivelyAccumulateSuspenseyCommit(fiber));</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s2">recursivelyAccumulateSuspenseyCommit(fiber);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">detachAlternateSiblings(parentFiber) {</span>
  <span class="s4">var </span><span class="s2">previousFiber = parentFiber.alternate;</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s4">null </span><span class="s2">!== previousFiber &amp;&amp;</span>
    <span class="s2">((parentFiber = previousFiber.child), </span><span class="s4">null </span><span class="s2">!== parentFiber)</span>
  <span class="s2">) {</span>
    <span class="s2">previousFiber.child = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">do</span>
      <span class="s2">(previousFiber = parentFiber.sibling),</span>
        <span class="s2">(parentFiber.sibling = </span><span class="s4">null</span><span class="s2">),</span>
        <span class="s2">(parentFiber = previousFiber);</span>
    <span class="s4">while </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== parentFiber);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">recursivelyTraversePassiveUnmountEffects(parentFiber) {</span>
  <span class="s4">var </span><span class="s2">deletions = parentFiber.deletions;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (parentFiber.flags &amp; </span><span class="s5">16</span><span class="s2">)) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== deletions)</span>
      <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; deletions.length; i++) {</span>
        <span class="s4">var </span><span class="s2">childToDelete = deletions[i];</span>
        <span class="s2">nextEffect = childToDelete;</span>
        <span class="s2">commitPassiveUnmountEffectsInsideOfDeletedTree_begin(</span>
          <span class="s2">childToDelete,</span>
          <span class="s2">parentFiber</span>
        <span class="s2">);</span>
      <span class="s2">}</span>
    <span class="s2">detachAlternateSiblings(parentFiber);</span>
  <span class="s2">}</span>
  <span class="s4">if </span><span class="s2">(parentFiber.subtreeFlags &amp; </span><span class="s5">10256</span><span class="s2">)</span>
    <span class="s4">for </span><span class="s2">(parentFiber = parentFiber.child; </span><span class="s4">null </span><span class="s2">!== parentFiber; )</span>
      <span class="s2">commitPassiveUnmountOnFiber(parentFiber),</span>
        <span class="s2">(parentFiber = parentFiber.sibling);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">commitPassiveUnmountOnFiber(finishedWork) {</span>
  <span class="s4">switch </span><span class="s2">(finishedWork.tag) {</span>
    <span class="s4">case </span><span class="s5">0</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">11</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">15</span><span class="s2">:</span>
      <span class="s2">recursivelyTraversePassiveUnmountEffects(finishedWork);</span>
      <span class="s2">finishedWork.flags &amp; </span><span class="s5">2048 </span><span class="s2">&amp;&amp;</span>
        <span class="s2">commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, </span><span class="s5">9</span><span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
      <span class="s4">var </span><span class="s2">prevEffectDuration = pushNestedEffectDurations();</span>
      <span class="s2">recursivelyTraversePassiveUnmountEffects(finishedWork);</span>
      <span class="s2">finishedWork.stateNode.passiveEffectDuration +=</span>
        <span class="s2">popNestedEffectDurations(prevEffectDuration);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">12</span><span class="s2">:</span>
      <span class="s2">prevEffectDuration = pushNestedEffectDurations();</span>
      <span class="s2">recursivelyTraversePassiveUnmountEffects(finishedWork);</span>
      <span class="s2">finishedWork.stateNode.passiveEffectDuration +=</span>
        <span class="s2">bubbleNestedEffectDurations(prevEffectDuration);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">22</span><span class="s2">:</span>
      <span class="s2">prevEffectDuration = finishedWork.stateNode;</span>
      <span class="s4">null </span><span class="s2">!== finishedWork.memoizedState &amp;&amp;</span>
      <span class="s2">prevEffectDuration._visibility &amp; </span><span class="s5">2 </span><span class="s2">&amp;&amp;</span>
      <span class="s2">(</span><span class="s4">null </span><span class="s2">=== finishedWork.return || </span><span class="s5">13 </span><span class="s2">!== finishedWork.return.tag)</span>
        <span class="s2">? ((prevEffectDuration._visibility &amp;= -</span><span class="s5">3</span><span class="s2">),</span>
          <span class="s2">recursivelyTraverseDisconnectPassiveEffects(finishedWork))</span>
        <span class="s2">: recursivelyTraversePassiveUnmountEffects(finishedWork);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s2">recursivelyTraversePassiveUnmountEffects(finishedWork);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">recursivelyTraverseDisconnectPassiveEffects(parentFiber) {</span>
  <span class="s4">var </span><span class="s2">deletions = parentFiber.deletions;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (parentFiber.flags &amp; </span><span class="s5">16</span><span class="s2">)) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== deletions)</span>
      <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; deletions.length; i++) {</span>
        <span class="s4">var </span><span class="s2">childToDelete = deletions[i];</span>
        <span class="s2">nextEffect = childToDelete;</span>
        <span class="s2">commitPassiveUnmountEffectsInsideOfDeletedTree_begin(</span>
          <span class="s2">childToDelete,</span>
          <span class="s2">parentFiber</span>
        <span class="s2">);</span>
      <span class="s2">}</span>
    <span class="s2">detachAlternateSiblings(parentFiber);</span>
  <span class="s2">}</span>
  <span class="s4">for </span><span class="s2">(parentFiber = parentFiber.child; </span><span class="s4">null </span><span class="s2">!== parentFiber; ) {</span>
    <span class="s2">deletions = parentFiber;</span>
    <span class="s4">switch </span><span class="s2">(deletions.tag) {</span>
      <span class="s4">case </span><span class="s5">0</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s5">11</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s5">15</span><span class="s2">:</span>
        <span class="s2">commitHookPassiveUnmountEffects(deletions, deletions.return, </span><span class="s5">8</span><span class="s2">);</span>
        <span class="s2">recursivelyTraverseDisconnectPassiveEffects(deletions);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s5">22</span><span class="s2">:</span>
        <span class="s2">i = deletions.stateNode;</span>
        <span class="s2">i._visibility &amp; </span><span class="s5">2 </span><span class="s2">&amp;&amp;</span>
          <span class="s2">((i._visibility &amp;= -</span><span class="s5">3</span><span class="s2">),</span>
          <span class="s2">recursivelyTraverseDisconnectPassiveEffects(deletions));</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">default</span><span class="s2">:</span>
        <span class="s2">recursivelyTraverseDisconnectPassiveEffects(deletions);</span>
    <span class="s2">}</span>
    <span class="s2">parentFiber = parentFiber.sibling;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">commitPassiveUnmountEffectsInsideOfDeletedTree_begin(</span>
  <span class="s2">deletedSubtreeRoot,</span>
  <span class="s2">nearestMountedAncestor</span>
<span class="s2">) {</span>
  <span class="s4">for </span><span class="s2">(; </span><span class="s4">null </span><span class="s2">!== nextEffect; ) {</span>
    <span class="s4">var </span><span class="s2">fiber = nextEffect;</span>
    <span class="s4">switch </span><span class="s2">(fiber.tag) {</span>
      <span class="s4">case </span><span class="s5">0</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s5">11</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s5">15</span><span class="s2">:</span>
        <span class="s2">commitHookPassiveUnmountEffects(fiber, nearestMountedAncestor, </span><span class="s5">8</span><span class="s2">);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s5">23</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s5">22</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s4">null </span><span class="s2">!== fiber.memoizedState &amp;&amp;</span>
          <span class="s4">null </span><span class="s2">!== fiber.memoizedState.cachePool</span>
        <span class="s2">) {</span>
          <span class="s4">var </span><span class="s2">cache = fiber.memoizedState.cachePool.pool;</span>
          <span class="s4">null </span><span class="s2">!= cache &amp;&amp; cache.refCount++;</span>
        <span class="s2">}</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s5">24</span><span class="s2">:</span>
        <span class="s2">releaseCache(fiber.memoizedState.cache);</span>
    <span class="s2">}</span>
    <span class="s2">cache = fiber.child;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== cache) (cache.return = fiber), (nextEffect = cache);</span>
    <span class="s4">else</span>
      <span class="s2">a: </span><span class="s4">for </span><span class="s2">(fiber = deletedSubtreeRoot; </span><span class="s4">null </span><span class="s2">!== nextEffect; ) {</span>
        <span class="s2">cache = nextEffect;</span>
        <span class="s4">var </span><span class="s2">sibling = cache.sibling,</span>
          <span class="s2">returnFiber = cache.return;</span>
        <span class="s2">detachFiberAfterEffects(cache);</span>
        <span class="s4">if </span><span class="s2">(cache === fiber) {</span>
          <span class="s2">nextEffect = </span><span class="s4">null</span><span class="s2">;</span>
          <span class="s4">break </span><span class="s2">a;</span>
        <span class="s2">}</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== sibling) {</span>
          <span class="s2">sibling.return = returnFiber;</span>
          <span class="s2">nextEffect = sibling;</span>
          <span class="s4">break </span><span class="s2">a;</span>
        <span class="s2">}</span>
        <span class="s2">nextEffect = returnFiber;</span>
      <span class="s2">}</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">DefaultAsyncDispatcher = {</span>
    <span class="s2">getCacheForType: </span><span class="s4">function </span><span class="s2">(resourceType) {</span>
      <span class="s4">var </span><span class="s2">cache = readContext(CacheContext),</span>
        <span class="s2">cacheForType = cache.data.get(resourceType);</span>
      <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== cacheForType &amp;&amp;</span>
        <span class="s2">((cacheForType = resourceType()),</span>
        <span class="s2">cache.data.set(resourceType, cacheForType));</span>
      <span class="s4">return </span><span class="s2">cacheForType;</span>
    <span class="s2">}</span>
  <span class="s2">},</span>
  <span class="s2">PossiblyWeakMap = </span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">WeakMap ? WeakMap : Map,</span>
  <span class="s2">executionContext = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">workInProgressRoot = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">workInProgress = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">workInProgressRootRenderLanes = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">workInProgressSuspendedReason = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">workInProgressThrownValue = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">workInProgressRootDidSkipSuspendedSiblings = !</span><span class="s5">1</span><span class="s2">,</span>
  <span class="s2">workInProgressRootIsPrerendering = !</span><span class="s5">1</span><span class="s2">,</span>
  <span class="s2">workInProgressRootDidAttachPingListener = !</span><span class="s5">1</span><span class="s2">,</span>
  <span class="s2">entangledRenderLanes = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">workInProgressRootExitStatus = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">workInProgressRootSkippedLanes = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">workInProgressRootInterleavedUpdatedLanes = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">workInProgressRootPingedLanes = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">workInProgressDeferredLane = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">workInProgressSuspendedRetryLanes = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">workInProgressRootConcurrentErrors = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">workInProgressRootRecoverableErrors = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">workInProgressRootDidIncludeRecursiveRenderUpdate = !</span><span class="s5">1</span><span class="s2">,</span>
  <span class="s2">globalMostRecentFallbackTime = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">workInProgressRootRenderTargetTime = Infinity,</span>
  <span class="s2">workInProgressTransitions = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">legacyErrorBoundariesThatAlreadyFailed = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">pendingEffectsStatus = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">pendingEffectsRoot = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">pendingFinishedWork = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">pendingEffectsLanes = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">pendingEffectsRemainingLanes = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">pendingPassiveTransitions = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">pendingRecoverableErrors = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">nestedUpdateCount = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">rootWithNestedUpdates = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">requestUpdateLane() {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (executionContext &amp; </span><span class="s5">2</span><span class="s2">) &amp;&amp; </span><span class="s5">0 </span><span class="s2">!== workInProgressRootRenderLanes)</span>
    <span class="s4">return </span><span class="s2">workInProgressRootRenderLanes &amp; -workInProgressRootRenderLanes;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== ReactSharedInternals.T) {</span>
    <span class="s4">var </span><span class="s2">actionScopeLane = currentEntangledLane;</span>
    <span class="s4">return </span><span class="s5">0 </span><span class="s2">!== actionScopeLane ? actionScopeLane : requestTransitionLane();</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">resolveUpdatePriority();</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">requestDeferredLane() {</span>
  <span class="s5">0 </span><span class="s2">=== workInProgressDeferredLane &amp;&amp;</span>
    <span class="s2">(workInProgressDeferredLane =</span>
      <span class="s5">0 </span><span class="s2">=== (workInProgressRootRenderLanes &amp; </span><span class="s5">536870912</span><span class="s2">) || isHydrating</span>
        <span class="s2">? claimNextTransitionLane()</span>
        <span class="s2">: </span><span class="s5">536870912</span><span class="s2">);</span>
  <span class="s4">var </span><span class="s2">suspenseHandler = suspenseHandlerStackCursor.current;</span>
  <span class="s4">null </span><span class="s2">!== suspenseHandler &amp;&amp; (suspenseHandler.flags |= </span><span class="s5">32</span><span class="s2">);</span>
  <span class="s4">return </span><span class="s2">workInProgressDeferredLane;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">scheduleUpdateOnFiber(root, fiber, lane) {</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s2">(root === workInProgressRoot &amp;&amp;</span>
      <span class="s2">(</span><span class="s5">2 </span><span class="s2">=== workInProgressSuspendedReason ||</span>
        <span class="s5">9 </span><span class="s2">=== workInProgressSuspendedReason)) ||</span>
    <span class="s4">null </span><span class="s2">!== root.cancelPendingCommit</span>
  <span class="s2">)</span>
    <span class="s2">prepareFreshStack(root, </span><span class="s5">0</span><span class="s2">),</span>
      <span class="s2">markRootSuspended(</span>
        <span class="s2">root,</span>
        <span class="s2">workInProgressRootRenderLanes,</span>
        <span class="s2">workInProgressDeferredLane,</span>
        <span class="s2">!</span><span class="s5">1</span>
      <span class="s2">);</span>
  <span class="s2">markRootUpdated$1(root, lane);</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== (executionContext &amp; </span><span class="s5">2</span><span class="s2">) || root !== workInProgressRoot)</span>
    <span class="s2">isDevToolsPresent &amp;&amp; addFiberToLanesMap(root, fiber, lane),</span>
      <span class="s2">root === workInProgressRoot &amp;&amp;</span>
        <span class="s2">(</span><span class="s5">0 </span><span class="s2">=== (executionContext &amp; </span><span class="s5">2</span><span class="s2">) &amp;&amp;</span>
          <span class="s2">(workInProgressRootInterleavedUpdatedLanes |= lane),</span>
        <span class="s5">4 </span><span class="s2">=== workInProgressRootExitStatus &amp;&amp;</span>
          <span class="s2">markRootSuspended(</span>
            <span class="s2">root,</span>
            <span class="s2">workInProgressRootRenderLanes,</span>
            <span class="s2">workInProgressDeferredLane,</span>
            <span class="s2">!</span><span class="s5">1</span>
          <span class="s2">)),</span>
      <span class="s2">ensureRootIsScheduled(root);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">performWorkOnRoot(root$jscomp$0, lanes, forceSync) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (executionContext &amp; </span><span class="s5">6</span><span class="s2">)) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">327</span><span class="s2">));</span>
  <span class="s4">var </span><span class="s2">shouldTimeSlice =</span>
      <span class="s2">(!forceSync &amp;&amp;</span>
        <span class="s5">0 </span><span class="s2">=== (lanes &amp; </span><span class="s5">124</span><span class="s2">) &amp;&amp;</span>
        <span class="s5">0 </span><span class="s2">=== (lanes &amp; root$jscomp$0.expiredLanes)) ||</span>
      <span class="s2">checkIfRootIsPrerendering(root$jscomp$0, lanes),</span>
    <span class="s2">exitStatus = shouldTimeSlice</span>
      <span class="s2">? renderRootConcurrent(root$jscomp$0, lanes)</span>
      <span class="s2">: renderRootSync(root$jscomp$0, lanes, !</span><span class="s5">0</span><span class="s2">),</span>
    <span class="s2">renderWasConcurrent = shouldTimeSlice;</span>
  <span class="s4">do </span><span class="s2">{</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== exitStatus) {</span>
      <span class="s2">workInProgressRootIsPrerendering &amp;&amp;</span>
        <span class="s2">!shouldTimeSlice &amp;&amp;</span>
        <span class="s2">markRootSuspended(root$jscomp$0, lanes, </span><span class="s5">0</span><span class="s2">, !</span><span class="s5">1</span><span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
      <span class="s2">forceSync = root$jscomp$0.current.alternate;</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">renderWasConcurrent &amp;&amp;</span>
        <span class="s2">!isRenderConsistentWithExternalStores(forceSync)</span>
      <span class="s2">) {</span>
        <span class="s2">exitStatus = renderRootSync(root$jscomp$0, lanes, !</span><span class="s5">1</span><span class="s2">);</span>
        <span class="s2">renderWasConcurrent = !</span><span class="s5">1</span><span class="s2">;</span>
        <span class="s4">continue</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s5">2 </span><span class="s2">=== exitStatus) {</span>
        <span class="s2">renderWasConcurrent = lanes;</span>
        <span class="s4">if </span><span class="s2">(root$jscomp$0.errorRecoveryDisabledLanes &amp; renderWasConcurrent)</span>
          <span class="s4">var </span><span class="s2">JSCompiler_inline_result = </span><span class="s5">0</span><span class="s2">;</span>
        <span class="s4">else</span>
          <span class="s2">(JSCompiler_inline_result = root$jscomp$0.pendingLanes &amp; -</span><span class="s5">536870913</span><span class="s2">),</span>
            <span class="s2">(JSCompiler_inline_result =</span>
              <span class="s5">0 </span><span class="s2">!== JSCompiler_inline_result</span>
                <span class="s2">? JSCompiler_inline_result</span>
                <span class="s2">: JSCompiler_inline_result &amp; </span><span class="s5">536870912</span>
                  <span class="s2">? </span><span class="s5">536870912</span>
                  <span class="s2">: </span><span class="s5">0</span><span class="s2">);</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== JSCompiler_inline_result) {</span>
          <span class="s2">lanes = JSCompiler_inline_result;</span>
          <span class="s2">a: {</span>
            <span class="s4">var </span><span class="s2">root = root$jscomp$0;</span>
            <span class="s2">exitStatus = workInProgressRootConcurrentErrors;</span>
            <span class="s4">var </span><span class="s2">wasRootDehydrated = root.current.memoizedState.isDehydrated;</span>
            <span class="s2">wasRootDehydrated &amp;&amp;</span>
              <span class="s2">(prepareFreshStack(root, JSCompiler_inline_result).flags |= </span><span class="s5">256</span><span class="s2">);</span>
            <span class="s2">JSCompiler_inline_result = renderRootSync(</span>
              <span class="s2">root,</span>
              <span class="s2">JSCompiler_inline_result,</span>
              <span class="s2">!</span><span class="s5">1</span>
            <span class="s2">);</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s5">2 </span><span class="s2">!== JSCompiler_inline_result) {</span>
              <span class="s4">if </span><span class="s2">(</span>
                <span class="s2">workInProgressRootDidAttachPingListener &amp;&amp;</span>
                <span class="s2">!wasRootDehydrated</span>
              <span class="s2">) {</span>
                <span class="s2">root.errorRecoveryDisabledLanes |= renderWasConcurrent;</span>
                <span class="s2">workInProgressRootInterleavedUpdatedLanes |=</span>
                  <span class="s2">renderWasConcurrent;</span>
                <span class="s2">exitStatus = </span><span class="s5">4</span><span class="s2">;</span>
                <span class="s4">break </span><span class="s2">a;</span>
              <span class="s2">}</span>
              <span class="s2">renderWasConcurrent = workInProgressRootRecoverableErrors;</span>
              <span class="s2">workInProgressRootRecoverableErrors = exitStatus;</span>
              <span class="s4">null </span><span class="s2">!== renderWasConcurrent &amp;&amp;</span>
                <span class="s2">(</span><span class="s4">null </span><span class="s2">=== workInProgressRootRecoverableErrors</span>
                  <span class="s2">? (workInProgressRootRecoverableErrors = renderWasConcurrent)</span>
                  <span class="s2">: workInProgressRootRecoverableErrors.push.apply(</span>
                      <span class="s2">workInProgressRootRecoverableErrors,</span>
                      <span class="s2">renderWasConcurrent</span>
                    <span class="s2">));</span>
            <span class="s2">}</span>
            <span class="s2">exitStatus = JSCompiler_inline_result;</span>
          <span class="s2">}</span>
          <span class="s2">renderWasConcurrent = !</span><span class="s5">1</span><span class="s2">;</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s5">2 </span><span class="s2">!== exitStatus) </span><span class="s4">continue</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s5">1 </span><span class="s2">=== exitStatus) {</span>
        <span class="s2">prepareFreshStack(root$jscomp$0, </span><span class="s5">0</span><span class="s2">);</span>
        <span class="s2">markRootSuspended(root$jscomp$0, lanes, </span><span class="s5">0</span><span class="s2">, !</span><span class="s5">0</span><span class="s2">);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s2">a: {</span>
        <span class="s2">shouldTimeSlice = root$jscomp$0;</span>
        <span class="s2">renderWasConcurrent = exitStatus;</span>
        <span class="s4">switch </span><span class="s2">(renderWasConcurrent) {</span>
          <span class="s4">case </span><span class="s5">0</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">345</span><span class="s2">));</span>
          <span class="s4">case </span><span class="s5">4</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s2">((lanes &amp; </span><span class="s5">4194048</span><span class="s2">) !== lanes) </span><span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s5">6</span><span class="s2">:</span>
            <span class="s2">markRootSuspended(</span>
              <span class="s2">shouldTimeSlice,</span>
              <span class="s2">lanes,</span>
              <span class="s2">workInProgressDeferredLane,</span>
              <span class="s2">!workInProgressRootDidSkipSuspendedSiblings</span>
            <span class="s2">);</span>
            <span class="s4">break </span><span class="s2">a;</span>
          <span class="s4">case </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s2">workInProgressRootRecoverableErrors = </span><span class="s4">null</span><span class="s2">;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">default</span><span class="s2">:</span>
            <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">329</span><span class="s2">));</span>
        <span class="s2">}</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">(lanes &amp; </span><span class="s5">62914560</span><span class="s2">) === lanes &amp;&amp;</span>
          <span class="s2">((exitStatus = globalMostRecentFallbackTime + </span><span class="s5">300 </span><span class="s2">- now$1()),</span>
          <span class="s5">10 </span><span class="s2">&lt; exitStatus)</span>
        <span class="s2">) {</span>
          <span class="s2">markRootSuspended(</span>
            <span class="s2">shouldTimeSlice,</span>
            <span class="s2">lanes,</span>
            <span class="s2">workInProgressDeferredLane,</span>
            <span class="s2">!workInProgressRootDidSkipSuspendedSiblings</span>
          <span class="s2">);</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== getNextLanes(shouldTimeSlice, </span><span class="s5">0</span><span class="s2">, !</span><span class="s5">0</span><span class="s2">)) </span><span class="s4">break </span><span class="s2">a;</span>
          <span class="s2">shouldTimeSlice.timeoutHandle = scheduleTimeout(</span>
            <span class="s2">commitRootWhenReady.bind(</span>
              <span class="s4">null</span><span class="s2">,</span>
              <span class="s2">shouldTimeSlice,</span>
              <span class="s2">forceSync,</span>
              <span class="s2">workInProgressRootRecoverableErrors,</span>
              <span class="s2">workInProgressTransitions,</span>
              <span class="s2">workInProgressRootDidIncludeRecursiveRenderUpdate,</span>
              <span class="s2">lanes,</span>
              <span class="s2">workInProgressDeferredLane,</span>
              <span class="s2">workInProgressRootInterleavedUpdatedLanes,</span>
              <span class="s2">workInProgressSuspendedRetryLanes,</span>
              <span class="s2">workInProgressRootDidSkipSuspendedSiblings,</span>
              <span class="s2">renderWasConcurrent,</span>
              <span class="s5">2</span><span class="s2">,</span>
              <span class="s2">-</span><span class="s5">0</span><span class="s2">,</span>
              <span class="s5">0</span>
            <span class="s2">),</span>
            <span class="s2">exitStatus</span>
          <span class="s2">);</span>
          <span class="s4">break </span><span class="s2">a;</span>
        <span class="s2">}</span>
        <span class="s2">commitRootWhenReady(</span>
          <span class="s2">shouldTimeSlice,</span>
          <span class="s2">forceSync,</span>
          <span class="s2">workInProgressRootRecoverableErrors,</span>
          <span class="s2">workInProgressTransitions,</span>
          <span class="s2">workInProgressRootDidIncludeRecursiveRenderUpdate,</span>
          <span class="s2">lanes,</span>
          <span class="s2">workInProgressDeferredLane,</span>
          <span class="s2">workInProgressRootInterleavedUpdatedLanes,</span>
          <span class="s2">workInProgressSuspendedRetryLanes,</span>
          <span class="s2">workInProgressRootDidSkipSuspendedSiblings,</span>
          <span class="s2">renderWasConcurrent,</span>
          <span class="s5">0</span><span class="s2">,</span>
          <span class="s2">-</span><span class="s5">0</span><span class="s2">,</span>
          <span class="s5">0</span>
        <span class="s2">);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">break</span><span class="s2">;</span>
  <span class="s2">} </span><span class="s4">while </span><span class="s2">(</span><span class="s5">1</span><span class="s2">);</span>
  <span class="s2">ensureRootIsScheduled(root$jscomp$0);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">commitRootWhenReady(</span>
  <span class="s2">root,</span>
  <span class="s2">finishedWork,</span>
  <span class="s2">recoverableErrors,</span>
  <span class="s2">transitions,</span>
  <span class="s2">didIncludeRenderPhaseUpdate,</span>
  <span class="s2">lanes,</span>
  <span class="s2">spawnedLane,</span>
  <span class="s2">updatedLanes,</span>
  <span class="s2">suspendedRetryLanes,</span>
  <span class="s2">didSkipSuspendedSiblings,</span>
  <span class="s2">exitStatus,</span>
  <span class="s2">suspendedCommitReason,</span>
  <span class="s2">completedRenderStartTime,</span>
  <span class="s2">completedRenderEndTime</span>
<span class="s2">) {</span>
  <span class="s2">root.timeoutHandle = -</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">suspendedCommitReason = finishedWork.subtreeFlags;</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s2">suspendedCommitReason &amp; </span><span class="s5">8192 </span><span class="s2">||</span>
    <span class="s5">16785408 </span><span class="s2">=== (suspendedCommitReason &amp; </span><span class="s5">16785408</span><span class="s2">)</span>
  <span class="s2">)</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">((suspendedState = { stylesheets: </span><span class="s4">null</span><span class="s2">, count: </span><span class="s5">0</span><span class="s2">, unsuspend: noop$1 }),</span>
      <span class="s2">accumulateSuspenseyCommitOnFiber(finishedWork),</span>
      <span class="s2">(suspendedCommitReason = waitForCommitToBeReady()),</span>
      <span class="s4">null </span><span class="s2">!== suspendedCommitReason)</span>
    <span class="s2">) {</span>
      <span class="s2">root.cancelPendingCommit = suspendedCommitReason(</span>
        <span class="s2">commitRoot.bind(</span>
          <span class="s4">null</span><span class="s2">,</span>
          <span class="s2">root,</span>
          <span class="s2">finishedWork,</span>
          <span class="s2">lanes,</span>
          <span class="s2">recoverableErrors,</span>
          <span class="s2">transitions,</span>
          <span class="s2">didIncludeRenderPhaseUpdate,</span>
          <span class="s2">spawnedLane,</span>
          <span class="s2">updatedLanes,</span>
          <span class="s2">suspendedRetryLanes,</span>
          <span class="s2">exitStatus,</span>
          <span class="s5">1</span><span class="s2">,</span>
          <span class="s2">completedRenderStartTime,</span>
          <span class="s2">completedRenderEndTime</span>
        <span class="s2">)</span>
      <span class="s2">);</span>
      <span class="s2">markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s2">commitRoot(</span>
    <span class="s2">root,</span>
    <span class="s2">finishedWork,</span>
    <span class="s2">lanes,</span>
    <span class="s2">recoverableErrors,</span>
    <span class="s2">transitions,</span>
    <span class="s2">didIncludeRenderPhaseUpdate,</span>
    <span class="s2">spawnedLane,</span>
    <span class="s2">updatedLanes,</span>
    <span class="s2">suspendedRetryLanes</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">isRenderConsistentWithExternalStores(finishedWork) {</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">node = finishedWork; ; ) {</span>
    <span class="s4">var </span><span class="s2">tag = node.tag;</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">(</span><span class="s5">0 </span><span class="s2">=== tag || </span><span class="s5">11 </span><span class="s2">=== tag || </span><span class="s5">15 </span><span class="s2">=== tag) &amp;&amp;</span>
      <span class="s2">node.flags &amp; </span><span class="s5">16384 </span><span class="s2">&amp;&amp;</span>
      <span class="s2">((tag = node.updateQueue),</span>
      <span class="s4">null </span><span class="s2">!== tag &amp;&amp; ((tag = tag.stores), </span><span class="s4">null </span><span class="s2">!== tag))</span>
    <span class="s2">)</span>
      <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; tag.length; i++) {</span>
        <span class="s4">var </span><span class="s2">check = tag[i],</span>
          <span class="s2">getSnapshot = check.getSnapshot;</span>
        <span class="s2">check = check.value;</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s4">if </span><span class="s2">(!objectIs(getSnapshot(), check)) </span><span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
        <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
          <span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">tag = node.child;</span>
    <span class="s4">if </span><span class="s2">(node.subtreeFlags &amp; </span><span class="s5">16384 </span><span class="s2">&amp;&amp; </span><span class="s4">null </span><span class="s2">!== tag)</span>
      <span class="s2">(tag.return = node), (node = tag);</span>
    <span class="s4">else </span><span class="s2">{</span>
      <span class="s4">if </span><span class="s2">(node === finishedWork) </span><span class="s4">break</span><span class="s2">;</span>
      <span class="s4">for </span><span class="s2">(; </span><span class="s4">null </span><span class="s2">=== node.sibling; ) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== node.return || node.return === finishedWork) </span><span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
        <span class="s2">node = node.return;</span>
      <span class="s2">}</span>
      <span class="s2">node.sibling.return = node.return;</span>
      <span class="s2">node = node.sibling;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">markRootSuspended(</span>
  <span class="s2">root,</span>
  <span class="s2">suspendedLanes,</span>
  <span class="s2">spawnedLane,</span>
  <span class="s2">didAttemptEntireTree</span>
<span class="s2">) {</span>
  <span class="s2">suspendedLanes &amp;= ~workInProgressRootPingedLanes;</span>
  <span class="s2">suspendedLanes &amp;= ~workInProgressRootInterleavedUpdatedLanes;</span>
  <span class="s2">root.suspendedLanes |= suspendedLanes;</span>
  <span class="s2">root.pingedLanes &amp;= ~suspendedLanes;</span>
  <span class="s2">didAttemptEntireTree &amp;&amp; (root.warmLanes |= suspendedLanes);</span>
  <span class="s2">didAttemptEntireTree = root.expirationTimes;</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">lanes = suspendedLanes; </span><span class="s5">0 </span><span class="s2">&lt; lanes; ) {</span>
    <span class="s4">var </span><span class="s2">index$4 = </span><span class="s5">31 </span><span class="s2">- clz32(lanes),</span>
      <span class="s2">lane = </span><span class="s5">1 </span><span class="s2">&lt;&lt; index$4;</span>
    <span class="s2">didAttemptEntireTree[index$4] = -</span><span class="s5">1</span><span class="s2">;</span>
    <span class="s2">lanes &amp;= ~lane;</span>
  <span class="s2">}</span>
  <span class="s5">0 </span><span class="s2">!== spawnedLane &amp;&amp;</span>
    <span class="s2">markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">flushSyncWork$1() {</span>
  <span class="s4">return </span><span class="s5">0 </span><span class="s2">=== (executionContext &amp; </span><span class="s5">6</span><span class="s2">)</span>
    <span class="s2">? (flushSyncWorkAcrossRoots_impl(</span><span class="s5">0</span><span class="s2">, !</span><span class="s5">1</span><span class="s2">), !</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s2">: !</span><span class="s5">0</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">resetWorkInProgressStack() {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== workInProgress) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== workInProgressSuspendedReason)</span>
      <span class="s4">var </span><span class="s2">interruptedWork = workInProgress.return;</span>
    <span class="s4">else</span>
      <span class="s2">(interruptedWork = workInProgress),</span>
        <span class="s2">(lastContextDependency = currentlyRenderingFiber$1 = </span><span class="s4">null</span><span class="s2">),</span>
        <span class="s2">resetHooksOnUnwind(interruptedWork),</span>
        <span class="s2">(thenableState = </span><span class="s4">null</span><span class="s2">),</span>
        <span class="s2">(thenableIndexCounter = </span><span class="s5">0</span><span class="s2">),</span>
        <span class="s2">(interruptedWork = workInProgress);</span>
    <span class="s4">for </span><span class="s2">(; </span><span class="s4">null </span><span class="s2">!== interruptedWork; )</span>
      <span class="s2">unwindInterruptedWork(interruptedWork.alternate, interruptedWork),</span>
        <span class="s2">(interruptedWork = interruptedWork.return);</span>
    <span class="s2">workInProgress = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">prepareFreshStack(root, lanes) {</span>
  <span class="s4">var </span><span class="s2">timeoutHandle = root.timeoutHandle;</span>
  <span class="s2">-</span><span class="s5">1 </span><span class="s2">!== timeoutHandle &amp;&amp;</span>
    <span class="s2">((root.timeoutHandle = -</span><span class="s5">1</span><span class="s2">), cancelTimeout(timeoutHandle));</span>
  <span class="s2">timeoutHandle = root.cancelPendingCommit;</span>
  <span class="s4">null </span><span class="s2">!== timeoutHandle &amp;&amp;</span>
    <span class="s2">((root.cancelPendingCommit = </span><span class="s4">null</span><span class="s2">), timeoutHandle());</span>
  <span class="s2">resetWorkInProgressStack();</span>
  <span class="s2">workInProgressRoot = root;</span>
  <span class="s2">workInProgress = timeoutHandle = createWorkInProgress(root.current, </span><span class="s4">null</span><span class="s2">);</span>
  <span class="s2">workInProgressRootRenderLanes = lanes;</span>
  <span class="s2">workInProgressSuspendedReason = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">workInProgressThrownValue = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">workInProgressRootDidSkipSuspendedSiblings = !</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);</span>
  <span class="s2">workInProgressRootDidAttachPingListener = !</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">workInProgressSuspendedRetryLanes =</span>
    <span class="s2">workInProgressDeferredLane =</span>
    <span class="s2">workInProgressRootPingedLanes =</span>
    <span class="s2">workInProgressRootInterleavedUpdatedLanes =</span>
    <span class="s2">workInProgressRootSkippedLanes =</span>
    <span class="s2">workInProgressRootExitStatus =</span>
      <span class="s5">0</span><span class="s2">;</span>
  <span class="s2">workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =</span>
    <span class="s4">null</span><span class="s2">;</span>
  <span class="s2">workInProgressRootDidIncludeRecursiveRenderUpdate = !</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s5">0 </span><span class="s2">!== (lanes &amp; </span><span class="s5">8</span><span class="s2">) &amp;&amp; (lanes |= lanes &amp; </span><span class="s5">32</span><span class="s2">);</span>
  <span class="s4">var </span><span class="s2">allEntangledLanes = root.entangledLanes;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== allEntangledLanes)</span>
    <span class="s4">for </span><span class="s2">(</span>
      <span class="s2">root = root.entanglements, allEntangledLanes &amp;= lanes;</span>
      <span class="s5">0 </span><span class="s2">&lt; allEntangledLanes;</span>

    <span class="s2">) {</span>
      <span class="s4">var </span><span class="s2">index$2 = </span><span class="s5">31 </span><span class="s2">- clz32(allEntangledLanes),</span>
        <span class="s2">lane = </span><span class="s5">1 </span><span class="s2">&lt;&lt; index$2;</span>
      <span class="s2">lanes |= root[index$2];</span>
      <span class="s2">allEntangledLanes &amp;= ~lane;</span>
    <span class="s2">}</span>
  <span class="s2">entangledRenderLanes = lanes;</span>
  <span class="s2">finishQueueingConcurrentUpdates();</span>
  <span class="s4">return </span><span class="s2">timeoutHandle;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">handleThrow(root, thrownValue) {</span>
  <span class="s2">currentlyRenderingFiber = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">ReactSharedInternals.H = ContextOnlyDispatcher;</span>
  <span class="s2">thrownValue === SuspenseException || thrownValue === SuspenseActionException</span>
    <span class="s2">? ((thrownValue = getSuspendedThenable()),</span>
      <span class="s2">(workInProgressSuspendedReason = </span><span class="s5">3</span><span class="s2">))</span>
    <span class="s2">: thrownValue === SuspenseyCommitException</span>
      <span class="s2">? ((thrownValue = getSuspendedThenable()),</span>
        <span class="s2">(workInProgressSuspendedReason = </span><span class="s5">4</span><span class="s2">))</span>
      <span class="s2">: (workInProgressSuspendedReason =</span>
          <span class="s2">thrownValue === SelectiveHydrationException</span>
            <span class="s2">? </span><span class="s5">8</span>
            <span class="s2">: </span><span class="s4">null </span><span class="s2">!== thrownValue &amp;&amp;</span>
                <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">thrownValue &amp;&amp;</span>
                <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">thrownValue.then</span>
              <span class="s2">? </span><span class="s5">6</span>
              <span class="s2">: </span><span class="s5">1</span><span class="s2">);</span>
  <span class="s2">workInProgressThrownValue = thrownValue;</span>
  <span class="s4">var </span><span class="s2">erroredWork = workInProgress;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== erroredWork)</span>
    <span class="s2">(workInProgressRootExitStatus = </span><span class="s5">1</span><span class="s2">),</span>
      <span class="s2">logUncaughtError(</span>
        <span class="s2">root,</span>
        <span class="s2">createCapturedValueAtFiber(thrownValue, root.current)</span>
      <span class="s2">);</span>
  <span class="s4">else</span>
    <span class="s4">switch </span><span class="s2">(</span>
      <span class="s2">(erroredWork.mode &amp; </span><span class="s5">2 </span><span class="s2">&amp;&amp;</span>
        <span class="s2">stopProfilerTimerIfRunningAndRecordDuration(erroredWork),</span>
      <span class="s2">markComponentRenderStopped(),</span>
      <span class="s2">workInProgressSuspendedReason)</span>
    <span class="s2">) {</span>
      <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s4">null </span><span class="s2">!== injectedProfilingHooks &amp;&amp;</span>
          <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">injectedProfilingHooks.markComponentErrored &amp;&amp;</span>
          <span class="s2">injectedProfilingHooks.markComponentErrored(</span>
            <span class="s2">erroredWork,</span>
            <span class="s2">thrownValue,</span>
            <span class="s2">workInProgressRootRenderLanes</span>
          <span class="s2">);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s5">2</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s5">9</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s5">6</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s5">7</span><span class="s2">:</span>
        <span class="s4">null </span><span class="s2">!== injectedProfilingHooks &amp;&amp;</span>
          <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">injectedProfilingHooks.markComponentSuspended &amp;&amp;</span>
          <span class="s2">injectedProfilingHooks.markComponentSuspended(</span>
            <span class="s2">erroredWork,</span>
            <span class="s2">thrownValue,</span>
            <span class="s2">workInProgressRootRenderLanes</span>
          <span class="s2">);</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">pushDispatcher() {</span>
  <span class="s4">var </span><span class="s2">prevDispatcher = ReactSharedInternals.H;</span>
  <span class="s2">ReactSharedInternals.H = ContextOnlyDispatcher;</span>
  <span class="s4">return null </span><span class="s2">=== prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">pushAsyncDispatcher() {</span>
  <span class="s4">var </span><span class="s2">prevAsyncDispatcher = ReactSharedInternals.A;</span>
  <span class="s2">ReactSharedInternals.A = DefaultAsyncDispatcher;</span>
  <span class="s4">return </span><span class="s2">prevAsyncDispatcher;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">renderDidSuspendDelayIfPossible() {</span>
  <span class="s2">workInProgressRootExitStatus = </span><span class="s5">4</span><span class="s2">;</span>
  <span class="s2">workInProgressRootDidSkipSuspendedSiblings ||</span>
    <span class="s2">((workInProgressRootRenderLanes &amp; </span><span class="s5">4194048</span><span class="s2">) !==</span>
      <span class="s2">workInProgressRootRenderLanes &amp;&amp;</span>
      <span class="s4">null </span><span class="s2">!== suspenseHandlerStackCursor.current) ||</span>
    <span class="s2">(workInProgressRootIsPrerendering = !</span><span class="s5">0</span><span class="s2">);</span>
  <span class="s2">(</span><span class="s5">0 </span><span class="s2">=== (workInProgressRootSkippedLanes &amp; </span><span class="s5">134217727</span><span class="s2">) &amp;&amp;</span>
    <span class="s5">0 </span><span class="s2">=== (workInProgressRootInterleavedUpdatedLanes &amp; </span><span class="s5">134217727</span><span class="s2">)) ||</span>
    <span class="s4">null </span><span class="s2">=== workInProgressRoot ||</span>
    <span class="s2">markRootSuspended(</span>
      <span class="s2">workInProgressRoot,</span>
      <span class="s2">workInProgressRootRenderLanes,</span>
      <span class="s2">workInProgressDeferredLane,</span>
      <span class="s2">!</span><span class="s5">1</span>
    <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">renderRootSync(root, lanes, shouldYieldForPrerendering) {</span>
  <span class="s4">var </span><span class="s2">prevExecutionContext = executionContext;</span>
  <span class="s2">executionContext |= </span><span class="s5">2</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">prevDispatcher = pushDispatcher(),</span>
    <span class="s2">prevAsyncDispatcher = pushAsyncDispatcher();</span>
  <span class="s4">if </span><span class="s2">(workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {</span>
    <span class="s4">if </span><span class="s2">(isDevToolsPresent) {</span>
      <span class="s4">var </span><span class="s2">memoizedUpdaters = root.memoizedUpdaters;</span>
      <span class="s5">0 </span><span class="s2">&lt; memoizedUpdaters.size &amp;&amp;</span>
        <span class="s2">(restorePendingUpdaters(root, workInProgressRootRenderLanes),</span>
        <span class="s2">memoizedUpdaters.clear());</span>
      <span class="s2">movePendingFibersToMemoized(root, lanes);</span>
    <span class="s2">}</span>
    <span class="s2">workInProgressTransitions = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s2">prepareFreshStack(root, lanes);</span>
  <span class="s2">}</span>
  <span class="s2">markRenderStarted(lanes);</span>
  <span class="s2">lanes = !</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">memoizedUpdaters = workInProgressRootExitStatus;</span>
  <span class="s2">a: </span><span class="s4">do</span>
    <span class="s4">try </span><span class="s2">{</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== workInProgressSuspendedReason &amp;&amp; </span><span class="s4">null </span><span class="s2">!== workInProgress) {</span>
        <span class="s4">var </span><span class="s2">unitOfWork = workInProgress,</span>
          <span class="s2">thrownValue = workInProgressThrownValue;</span>
        <span class="s4">switch </span><span class="s2">(workInProgressSuspendedReason) {</span>
          <span class="s4">case </span><span class="s5">8</span><span class="s2">:</span>
            <span class="s2">resetWorkInProgressStack();</span>
            <span class="s2">memoizedUpdaters = </span><span class="s5">6</span><span class="s2">;</span>
            <span class="s4">break </span><span class="s2">a;</span>
          <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s5">2</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s5">9</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s5">6</span><span class="s2">:</span>
            <span class="s4">null </span><span class="s2">=== suspenseHandlerStackCursor.current &amp;&amp; (lanes = !</span><span class="s5">0</span><span class="s2">);</span>
            <span class="s4">var </span><span class="s2">reason = workInProgressSuspendedReason;</span>
            <span class="s2">workInProgressSuspendedReason = </span><span class="s5">0</span><span class="s2">;</span>
            <span class="s2">workInProgressThrownValue = </span><span class="s4">null</span><span class="s2">;</span>
            <span class="s2">throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);</span>
            <span class="s4">if </span><span class="s2">(</span>
              <span class="s2">shouldYieldForPrerendering &amp;&amp;</span>
              <span class="s2">workInProgressRootIsPrerendering</span>
            <span class="s2">) {</span>
              <span class="s2">memoizedUpdaters = </span><span class="s5">0</span><span class="s2">;</span>
              <span class="s4">break </span><span class="s2">a;</span>
            <span class="s2">}</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">default</span><span class="s2">:</span>
            <span class="s2">(reason = workInProgressSuspendedReason),</span>
              <span class="s2">(workInProgressSuspendedReason = </span><span class="s5">0</span><span class="s2">),</span>
              <span class="s2">(workInProgressThrownValue = </span><span class="s4">null</span><span class="s2">),</span>
              <span class="s2">throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s2">workLoopSync();</span>
      <span class="s2">memoizedUpdaters = workInProgressRootExitStatus;</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s2">} </span><span class="s4">catch </span><span class="s2">(thrownValue$182) {</span>
      <span class="s2">handleThrow(root, thrownValue$182);</span>
    <span class="s2">}</span>
  <span class="s4">while </span><span class="s2">(</span><span class="s5">1</span><span class="s2">);</span>
  <span class="s2">lanes &amp;&amp; root.shellSuspendCounter++;</span>
  <span class="s2">lastContextDependency = currentlyRenderingFiber$1 = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">executionContext = prevExecutionContext;</span>
  <span class="s2">ReactSharedInternals.H = prevDispatcher;</span>
  <span class="s2">ReactSharedInternals.A = prevAsyncDispatcher;</span>
  <span class="s2">markRenderStopped();</span>
  <span class="s4">null </span><span class="s2">=== workInProgress &amp;&amp;</span>
    <span class="s2">((workInProgressRoot = </span><span class="s4">null</span><span class="s2">),</span>
    <span class="s2">(workInProgressRootRenderLanes = </span><span class="s5">0</span><span class="s2">),</span>
    <span class="s2">finishQueueingConcurrentUpdates());</span>
  <span class="s4">return </span><span class="s2">memoizedUpdaters;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">workLoopSync() {</span>
  <span class="s4">for </span><span class="s2">(; </span><span class="s4">null </span><span class="s2">!== workInProgress; ) performUnitOfWork(workInProgress);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">renderRootConcurrent(root, lanes) {</span>
  <span class="s4">var </span><span class="s2">prevExecutionContext = executionContext;</span>
  <span class="s2">executionContext |= </span><span class="s5">2</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">prevDispatcher = pushDispatcher(),</span>
    <span class="s2">prevAsyncDispatcher = pushAsyncDispatcher();</span>
  <span class="s4">if </span><span class="s2">(workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {</span>
    <span class="s4">if </span><span class="s2">(isDevToolsPresent) {</span>
      <span class="s4">var </span><span class="s2">memoizedUpdaters = root.memoizedUpdaters;</span>
      <span class="s5">0 </span><span class="s2">&lt; memoizedUpdaters.size &amp;&amp;</span>
        <span class="s2">(restorePendingUpdaters(root, workInProgressRootRenderLanes),</span>
        <span class="s2">memoizedUpdaters.clear());</span>
      <span class="s2">movePendingFibersToMemoized(root, lanes);</span>
    <span class="s2">}</span>
    <span class="s2">workInProgressTransitions = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s2">workInProgressRootRenderTargetTime = now$1() + </span><span class="s5">500</span><span class="s2">;</span>
    <span class="s2">prepareFreshStack(root, lanes);</span>
  <span class="s2">} </span><span class="s4">else</span>
    <span class="s2">workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);</span>
  <span class="s2">markRenderStarted(lanes);</span>
  <span class="s2">a: </span><span class="s4">do</span>
    <span class="s4">try </span><span class="s2">{</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== workInProgressSuspendedReason &amp;&amp; </span><span class="s4">null </span><span class="s2">!== workInProgress)</span>
        <span class="s2">b: </span><span class="s4">switch </span><span class="s2">(</span>
          <span class="s2">((lanes = workInProgress),</span>
          <span class="s2">(memoizedUpdaters = workInProgressThrownValue),</span>
          <span class="s2">workInProgressSuspendedReason)</span>
        <span class="s2">) {</span>
          <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s2">workInProgressSuspendedReason = </span><span class="s5">0</span><span class="s2">;</span>
            <span class="s2">workInProgressThrownValue = </span><span class="s4">null</span><span class="s2">;</span>
            <span class="s2">throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, </span><span class="s5">1</span><span class="s2">);</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s5">2</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s5">9</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s2">(isThenableResolved(memoizedUpdaters)) {</span>
              <span class="s2">workInProgressSuspendedReason = </span><span class="s5">0</span><span class="s2">;</span>
              <span class="s2">workInProgressThrownValue = </span><span class="s4">null</span><span class="s2">;</span>
              <span class="s2">replaySuspendedUnitOfWork(lanes);</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s2">}</span>
            <span class="s2">lanes = </span><span class="s4">function </span><span class="s2">() {</span>
              <span class="s2">(</span><span class="s5">2 </span><span class="s2">!== workInProgressSuspendedReason &amp;&amp;</span>
                <span class="s5">9 </span><span class="s2">!== workInProgressSuspendedReason) ||</span>
                <span class="s2">workInProgressRoot !== root ||</span>
                <span class="s2">(workInProgressSuspendedReason = </span><span class="s5">7</span><span class="s2">);</span>
              <span class="s2">ensureRootIsScheduled(root);</span>
            <span class="s2">};</span>
            <span class="s2">memoizedUpdaters.then(lanes, lanes);</span>
            <span class="s4">break </span><span class="s2">a;</span>
          <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
            <span class="s2">workInProgressSuspendedReason = </span><span class="s5">7</span><span class="s2">;</span>
            <span class="s4">break </span><span class="s2">a;</span>
          <span class="s4">case </span><span class="s5">4</span><span class="s2">:</span>
            <span class="s2">workInProgressSuspendedReason = </span><span class="s5">5</span><span class="s2">;</span>
            <span class="s4">break </span><span class="s2">a;</span>
          <span class="s4">case </span><span class="s5">7</span><span class="s2">:</span>
            <span class="s2">isThenableResolved(memoizedUpdaters)</span>
              <span class="s2">? ((workInProgressSuspendedReason = </span><span class="s5">0</span><span class="s2">),</span>
                <span class="s2">(workInProgressThrownValue = </span><span class="s4">null</span><span class="s2">),</span>
                <span class="s2">replaySuspendedUnitOfWork(lanes))</span>
              <span class="s2">: ((workInProgressSuspendedReason = </span><span class="s5">0</span><span class="s2">),</span>
                <span class="s2">(workInProgressThrownValue = </span><span class="s4">null</span><span class="s2">),</span>
                <span class="s2">throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, </span><span class="s5">7</span><span class="s2">));</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
            <span class="s4">var </span><span class="s2">resource = </span><span class="s4">null</span><span class="s2">;</span>
            <span class="s4">switch </span><span class="s2">(workInProgress.tag) {</span>
              <span class="s4">case </span><span class="s5">26</span><span class="s2">:</span>
                <span class="s2">resource = workInProgress.memoizedState;</span>
              <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
              <span class="s4">case </span><span class="s5">27</span><span class="s2">:</span>
                <span class="s4">var </span><span class="s2">hostFiber = workInProgress;</span>
                <span class="s4">if </span><span class="s2">(resource ? preloadResource(resource) : </span><span class="s5">1</span><span class="s2">) {</span>
                  <span class="s2">workInProgressSuspendedReason = </span><span class="s5">0</span><span class="s2">;</span>
                  <span class="s2">workInProgressThrownValue = </span><span class="s4">null</span><span class="s2">;</span>
                  <span class="s4">var </span><span class="s2">sibling = hostFiber.sibling;</span>
                  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== sibling) workInProgress = sibling;</span>
                  <span class="s4">else </span><span class="s2">{</span>
                    <span class="s4">var </span><span class="s2">returnFiber = hostFiber.return;</span>
                    <span class="s4">null </span><span class="s2">!== returnFiber</span>
                      <span class="s2">? ((workInProgress = returnFiber),</span>
                        <span class="s2">completeUnitOfWork(returnFiber))</span>
                      <span class="s2">: (workInProgress = </span><span class="s4">null</span><span class="s2">);</span>
                  <span class="s2">}</span>
                  <span class="s4">break </span><span class="s2">b;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s2">workInProgressSuspendedReason = </span><span class="s5">0</span><span class="s2">;</span>
            <span class="s2">workInProgressThrownValue = </span><span class="s4">null</span><span class="s2">;</span>
            <span class="s2">throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, </span><span class="s5">5</span><span class="s2">);</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s5">6</span><span class="s2">:</span>
            <span class="s2">workInProgressSuspendedReason = </span><span class="s5">0</span><span class="s2">;</span>
            <span class="s2">workInProgressThrownValue = </span><span class="s4">null</span><span class="s2">;</span>
            <span class="s2">throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, </span><span class="s5">6</span><span class="s2">);</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s5">8</span><span class="s2">:</span>
            <span class="s2">resetWorkInProgressStack();</span>
            <span class="s2">workInProgressRootExitStatus = </span><span class="s5">6</span><span class="s2">;</span>
            <span class="s4">break </span><span class="s2">a;</span>
          <span class="s4">default</span><span class="s2">:</span>
            <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">462</span><span class="s2">));</span>
        <span class="s2">}</span>
      <span class="s2">workLoopConcurrentByScheduler();</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s2">} </span><span class="s4">catch </span><span class="s2">(thrownValue$184) {</span>
      <span class="s2">handleThrow(root, thrownValue$184);</span>
    <span class="s2">}</span>
  <span class="s4">while </span><span class="s2">(</span><span class="s5">1</span><span class="s2">);</span>
  <span class="s2">lastContextDependency = currentlyRenderingFiber$1 = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">ReactSharedInternals.H = prevDispatcher;</span>
  <span class="s2">ReactSharedInternals.A = prevAsyncDispatcher;</span>
  <span class="s2">executionContext = prevExecutionContext;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== workInProgress)</span>
    <span class="s4">return </span><span class="s2">(</span>
      <span class="s4">null </span><span class="s2">!== injectedProfilingHooks &amp;&amp;</span>
        <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">injectedProfilingHooks.markRenderYielded &amp;&amp;</span>
        <span class="s2">injectedProfilingHooks.markRenderYielded(),</span>
      <span class="s5">0</span>
    <span class="s2">);</span>
  <span class="s2">markRenderStopped();</span>
  <span class="s2">workInProgressRoot = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">workInProgressRootRenderLanes = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">finishQueueingConcurrentUpdates();</span>
  <span class="s4">return </span><span class="s2">workInProgressRootExitStatus;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">workLoopConcurrentByScheduler() {</span>
  <span class="s4">for </span><span class="s2">(; </span><span class="s4">null </span><span class="s2">!== workInProgress &amp;&amp; !shouldYield(); )</span>
    <span class="s2">performUnitOfWork(workInProgress);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">performUnitOfWork(unitOfWork) {</span>
  <span class="s4">var </span><span class="s2">current = unitOfWork.alternate;</span>
  <span class="s5">0 </span><span class="s2">!== (unitOfWork.mode &amp; </span><span class="s5">2</span><span class="s2">)</span>
    <span class="s2">? (startProfilerTimer(unitOfWork),</span>
      <span class="s2">(current = beginWork(current, unitOfWork, entangledRenderLanes)),</span>
      <span class="s2">stopProfilerTimerIfRunningAndRecordDuration(unitOfWork))</span>
    <span class="s2">: (current = beginWork(current, unitOfWork, entangledRenderLanes));</span>
  <span class="s2">unitOfWork.memoizedProps = unitOfWork.pendingProps;</span>
  <span class="s4">null </span><span class="s2">=== current</span>
    <span class="s2">? completeUnitOfWork(unitOfWork)</span>
    <span class="s2">: (workInProgress = current);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">replaySuspendedUnitOfWork(unitOfWork) {</span>
  <span class="s4">var </span><span class="s2">next = unitOfWork;</span>
  <span class="s4">var </span><span class="s2">current = next.alternate,</span>
    <span class="s2">isProfilingMode = </span><span class="s5">0 </span><span class="s2">!== (next.mode &amp; </span><span class="s5">2</span><span class="s2">);</span>
  <span class="s2">isProfilingMode &amp;&amp; startProfilerTimer(next);</span>
  <span class="s4">switch </span><span class="s2">(next.tag) {</span>
    <span class="s4">case </span><span class="s5">15</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">0</span><span class="s2">:</span>
      <span class="s2">current = replayFunctionComponent(</span>
        <span class="s2">current,</span>
        <span class="s2">next,</span>
        <span class="s2">next.pendingProps,</span>
        <span class="s2">next.type,</span>
        <span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
        <span class="s2">workInProgressRootRenderLanes</span>
      <span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">11</span><span class="s2">:</span>
      <span class="s2">current = replayFunctionComponent(</span>
        <span class="s2">current,</span>
        <span class="s2">next,</span>
        <span class="s2">next.pendingProps,</span>
        <span class="s2">next.type.render,</span>
        <span class="s2">next.ref,</span>
        <span class="s2">workInProgressRootRenderLanes</span>
      <span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
      <span class="s2">resetHooksOnUnwind(next);</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s2">unwindInterruptedWork(current, next),</span>
        <span class="s2">(next = workInProgress =</span>
          <span class="s2">resetWorkInProgress(next, entangledRenderLanes)),</span>
        <span class="s2">(current = beginWork(current, next, entangledRenderLanes));</span>
  <span class="s2">}</span>
  <span class="s2">isProfilingMode &amp;&amp; stopProfilerTimerIfRunningAndRecordDuration(next);</span>
  <span class="s2">next = current;</span>
  <span class="s2">unitOfWork.memoizedProps = unitOfWork.pendingProps;</span>
  <span class="s4">null </span><span class="s2">=== next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">throwAndUnwindWorkLoop(</span>
  <span class="s2">root,</span>
  <span class="s2">unitOfWork,</span>
  <span class="s2">thrownValue,</span>
  <span class="s2">suspendedReason</span>
<span class="s2">) {</span>
  <span class="s2">lastContextDependency = currentlyRenderingFiber$1 = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">resetHooksOnUnwind(unitOfWork);</span>
  <span class="s2">thenableState = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">thenableIndexCounter = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">returnFiber = unitOfWork.return;</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">throwException(</span>
        <span class="s2">root,</span>
        <span class="s2">returnFiber,</span>
        <span class="s2">unitOfWork,</span>
        <span class="s2">thrownValue,</span>
        <span class="s2">workInProgressRootRenderLanes</span>
      <span class="s2">)</span>
    <span class="s2">) {</span>
      <span class="s2">workInProgressRootExitStatus = </span><span class="s5">1</span><span class="s2">;</span>
      <span class="s2">logUncaughtError(</span>
        <span class="s2">root,</span>
        <span class="s2">createCapturedValueAtFiber(thrownValue, root.current)</span>
      <span class="s2">);</span>
      <span class="s2">workInProgress = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== returnFiber) </span><span class="s4">throw </span><span class="s2">((workInProgress = returnFiber), error);</span>
    <span class="s2">workInProgressRootExitStatus = </span><span class="s5">1</span><span class="s2">;</span>
    <span class="s2">logUncaughtError(</span>
      <span class="s2">root,</span>
      <span class="s2">createCapturedValueAtFiber(thrownValue, root.current)</span>
    <span class="s2">);</span>
    <span class="s2">workInProgress = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">return</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s4">if </span><span class="s2">(unitOfWork.flags &amp; </span><span class="s5">32768</span><span class="s2">) {</span>
    <span class="s4">if </span><span class="s2">(isHydrating || </span><span class="s5">1 </span><span class="s2">=== suspendedReason) root = !</span><span class="s5">0</span><span class="s2">;</span>
    <span class="s4">else if </span><span class="s2">(</span>
      <span class="s2">workInProgressRootIsPrerendering ||</span>
      <span class="s5">0 </span><span class="s2">!== (workInProgressRootRenderLanes &amp; </span><span class="s5">536870912</span><span class="s2">)</span>
    <span class="s2">)</span>
      <span class="s2">root = !</span><span class="s5">1</span><span class="s2">;</span>
    <span class="s4">else if </span><span class="s2">(</span>
      <span class="s2">((workInProgressRootDidSkipSuspendedSiblings = root = !</span><span class="s5">0</span><span class="s2">),</span>
      <span class="s5">2 </span><span class="s2">=== suspendedReason ||</span>
        <span class="s5">9 </span><span class="s2">=== suspendedReason ||</span>
        <span class="s5">3 </span><span class="s2">=== suspendedReason ||</span>
        <span class="s5">6 </span><span class="s2">=== suspendedReason)</span>
    <span class="s2">)</span>
      <span class="s2">(suspendedReason = suspenseHandlerStackCursor.current),</span>
        <span class="s4">null </span><span class="s2">!== suspendedReason &amp;&amp;</span>
          <span class="s5">13 </span><span class="s2">=== suspendedReason.tag &amp;&amp;</span>
          <span class="s2">(suspendedReason.flags |= </span><span class="s5">16384</span><span class="s2">);</span>
    <span class="s2">unwindUnitOfWork(unitOfWork, root);</span>
  <span class="s2">} </span><span class="s4">else </span><span class="s2">completeUnitOfWork(unitOfWork);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">completeUnitOfWork(unitOfWork) {</span>
  <span class="s4">var </span><span class="s2">completedWork = unitOfWork;</span>
  <span class="s4">do </span><span class="s2">{</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (completedWork.flags &amp; </span><span class="s5">32768</span><span class="s2">)) {</span>
      <span class="s2">unwindUnitOfWork(</span>
        <span class="s2">completedWork,</span>
        <span class="s2">workInProgressRootDidSkipSuspendedSiblings</span>
      <span class="s2">);</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">var </span><span class="s2">current = completedWork.alternate;</span>
    <span class="s2">unitOfWork = completedWork.return;</span>
    <span class="s2">startProfilerTimer(completedWork);</span>
    <span class="s2">current = completeWork(current, completedWork, entangledRenderLanes);</span>
    <span class="s5">0 </span><span class="s2">!== (completedWork.mode &amp; </span><span class="s5">2</span><span class="s2">) &amp;&amp;</span>
      <span class="s2">stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== current) {</span>
      <span class="s2">workInProgress = current;</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s2">completedWork = completedWork.sibling;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== completedWork) {</span>
      <span class="s2">workInProgress = completedWork;</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s2">workInProgress = completedWork = unitOfWork;</span>
  <span class="s2">} </span><span class="s4">while </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== completedWork);</span>
  <span class="s5">0 </span><span class="s2">=== workInProgressRootExitStatus &amp;&amp; (workInProgressRootExitStatus = </span><span class="s5">5</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">unwindUnitOfWork(unitOfWork, skipSiblings) {</span>
  <span class="s4">do </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">next = unwindWork(unitOfWork.alternate, unitOfWork);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== next) {</span>
      <span class="s2">next.flags &amp;= </span><span class="s5">32767</span><span class="s2">;</span>
      <span class="s2">workInProgress = next;</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (unitOfWork.mode &amp; </span><span class="s5">2</span><span class="s2">)) {</span>
      <span class="s2">stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);</span>
      <span class="s2">next = unitOfWork.actualDuration;</span>
      <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">child = unitOfWork.child; </span><span class="s4">null </span><span class="s2">!== child; )</span>
        <span class="s2">(next += child.actualDuration), (child = child.sibling);</span>
      <span class="s2">unitOfWork.actualDuration = next;</span>
    <span class="s2">}</span>
    <span class="s2">next = unitOfWork.return;</span>
    <span class="s4">null </span><span class="s2">!== next &amp;&amp;</span>
      <span class="s2">((next.flags |= </span><span class="s5">32768</span><span class="s2">), (next.subtreeFlags = </span><span class="s5">0</span><span class="s2">), (next.deletions = </span><span class="s4">null</span><span class="s2">));</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">!skipSiblings &amp;&amp;</span>
      <span class="s2">((unitOfWork = unitOfWork.sibling), </span><span class="s4">null </span><span class="s2">!== unitOfWork)</span>
    <span class="s2">) {</span>
      <span class="s2">workInProgress = unitOfWork;</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s2">workInProgress = unitOfWork = next;</span>
  <span class="s2">} </span><span class="s4">while </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== unitOfWork);</span>
  <span class="s2">workInProgressRootExitStatus = </span><span class="s5">6</span><span class="s2">;</span>
  <span class="s2">workInProgress = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">commitRoot(</span>
  <span class="s2">root,</span>
  <span class="s2">finishedWork,</span>
  <span class="s2">lanes,</span>
  <span class="s2">recoverableErrors,</span>
  <span class="s2">transitions,</span>
  <span class="s2">didIncludeRenderPhaseUpdate,</span>
  <span class="s2">spawnedLane,</span>
  <span class="s2">updatedLanes,</span>
  <span class="s2">suspendedRetryLanes</span>
<span class="s2">) {</span>
  <span class="s2">root.cancelPendingCommit = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">do </span><span class="s2">flushPendingEffects();</span>
  <span class="s4">while </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== pendingEffectsStatus);</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (executionContext &amp; </span><span class="s5">6</span><span class="s2">)) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">327</span><span class="s2">));</span>
  <span class="s4">null </span><span class="s2">!== injectedProfilingHooks &amp;&amp;</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">injectedProfilingHooks.markCommitStarted &amp;&amp;</span>
    <span class="s2">injectedProfilingHooks.markCommitStarted(lanes);</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== finishedWork) markCommitStopped();</span>
  <span class="s4">else </span><span class="s2">{</span>
    <span class="s4">if </span><span class="s2">(finishedWork === root.current) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">177</span><span class="s2">));</span>
    <span class="s2">didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;</span>
    <span class="s2">didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;</span>
    <span class="s2">markRootFinished(</span>
      <span class="s2">root,</span>
      <span class="s2">lanes,</span>
      <span class="s2">didIncludeRenderPhaseUpdate,</span>
      <span class="s2">spawnedLane,</span>
      <span class="s2">updatedLanes,</span>
      <span class="s2">suspendedRetryLanes</span>
    <span class="s2">);</span>
    <span class="s2">root === workInProgressRoot &amp;&amp;</span>
      <span class="s2">((workInProgress = workInProgressRoot = </span><span class="s4">null</span><span class="s2">),</span>
      <span class="s2">(workInProgressRootRenderLanes = </span><span class="s5">0</span><span class="s2">));</span>
    <span class="s2">pendingFinishedWork = finishedWork;</span>
    <span class="s2">pendingEffectsRoot = root;</span>
    <span class="s2">pendingEffectsLanes = lanes;</span>
    <span class="s2">pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;</span>
    <span class="s2">pendingPassiveTransitions = transitions;</span>
    <span class="s2">pendingRecoverableErrors = recoverableErrors;</span>
    <span class="s5">0 </span><span class="s2">!== (finishedWork.subtreeFlags &amp; </span><span class="s5">10256</span><span class="s2">) ||</span>
    <span class="s5">0 </span><span class="s2">!== (finishedWork.flags &amp; </span><span class="s5">10256</span><span class="s2">)</span>
      <span class="s2">? ((root.callbackNode = </span><span class="s4">null</span><span class="s2">),</span>
        <span class="s2">(root.callbackPriority = </span><span class="s5">0</span><span class="s2">),</span>
        <span class="s2">scheduleCallback$1(NormalPriority$1, </span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s2">flushPassiveEffects(!</span><span class="s5">0</span><span class="s2">);</span>
          <span class="s4">return null</span><span class="s2">;</span>
        <span class="s2">}))</span>
      <span class="s2">: ((root.callbackNode = </span><span class="s4">null</span><span class="s2">), (root.callbackPriority = </span><span class="s5">0</span><span class="s2">));</span>
    <span class="s2">commitStartTime = now();</span>
    <span class="s2">recoverableErrors = </span><span class="s5">0 </span><span class="s2">!== (finishedWork.flags &amp; </span><span class="s5">13878</span><span class="s2">);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (finishedWork.subtreeFlags &amp; </span><span class="s5">13878</span><span class="s2">) || recoverableErrors) {</span>
      <span class="s2">recoverableErrors = ReactSharedInternals.T;</span>
      <span class="s2">ReactSharedInternals.T = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">transitions = ReactDOMSharedInternals.p;</span>
      <span class="s2">ReactDOMSharedInternals.p = </span><span class="s5">2</span><span class="s2">;</span>
      <span class="s2">spawnedLane = executionContext;</span>
      <span class="s2">executionContext |= </span><span class="s5">4</span><span class="s2">;</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s2">commitBeforeMutationEffects(root, finishedWork, lanes);</span>
      <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
        <span class="s2">(executionContext = spawnedLane),</span>
          <span class="s2">(ReactDOMSharedInternals.p = transitions),</span>
          <span class="s2">(ReactSharedInternals.T = recoverableErrors);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">pendingEffectsStatus = </span><span class="s5">1</span><span class="s2">;</span>
    <span class="s2">flushMutationEffects();</span>
    <span class="s2">flushLayoutEffects();</span>
    <span class="s2">flushSpawnedWork();</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">flushMutationEffects() {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">1 </span><span class="s2">=== pendingEffectsStatus) {</span>
    <span class="s2">pendingEffectsStatus = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s4">var </span><span class="s2">root = pendingEffectsRoot,</span>
      <span class="s2">finishedWork = pendingFinishedWork,</span>
      <span class="s2">lanes = pendingEffectsLanes,</span>
      <span class="s2">rootMutationHasEffect = </span><span class="s5">0 </span><span class="s2">!== (finishedWork.flags &amp; </span><span class="s5">13878</span><span class="s2">);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (finishedWork.subtreeFlags &amp; </span><span class="s5">13878</span><span class="s2">) || rootMutationHasEffect) {</span>
      <span class="s2">rootMutationHasEffect = ReactSharedInternals.T;</span>
      <span class="s2">ReactSharedInternals.T = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">var </span><span class="s2">previousPriority = ReactDOMSharedInternals.p;</span>
      <span class="s2">ReactDOMSharedInternals.p = </span><span class="s5">2</span><span class="s2">;</span>
      <span class="s4">var </span><span class="s2">prevExecutionContext = executionContext;</span>
      <span class="s2">executionContext |= </span><span class="s5">4</span><span class="s2">;</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s2">inProgressLanes = lanes;</span>
        <span class="s2">inProgressRoot = root;</span>
        <span class="s2">commitMutationEffectsOnFiber(finishedWork, root);</span>
        <span class="s2">inProgressRoot = inProgressLanes = </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s2">lanes = selectionInformation;</span>
        <span class="s4">var </span><span class="s2">curFocusedElem = getActiveElementDeep(root.containerInfo),</span>
          <span class="s2">priorFocusedElem = lanes.focusedElem,</span>
          <span class="s2">priorSelectionRange = lanes.selectionRange;</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">curFocusedElem !== priorFocusedElem &amp;&amp;</span>
          <span class="s2">priorFocusedElem &amp;&amp;</span>
          <span class="s2">priorFocusedElem.ownerDocument &amp;&amp;</span>
          <span class="s2">containsNode(</span>
            <span class="s2">priorFocusedElem.ownerDocument.documentElement,</span>
            <span class="s2">priorFocusedElem</span>
          <span class="s2">)</span>
        <span class="s2">) {</span>
          <span class="s4">if </span><span class="s2">(</span>
            <span class="s4">null </span><span class="s2">!== priorSelectionRange &amp;&amp;</span>
            <span class="s2">hasSelectionCapabilities(priorFocusedElem)</span>
          <span class="s2">) {</span>
            <span class="s4">var </span><span class="s2">start = priorSelectionRange.start,</span>
              <span class="s2">end = priorSelectionRange.end;</span>
            <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== end &amp;&amp; (end = start);</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;selectionStart&quot; </span><span class="s4">in </span><span class="s2">priorFocusedElem)</span>
              <span class="s2">(priorFocusedElem.selectionStart = start),</span>
                <span class="s2">(priorFocusedElem.selectionEnd = Math.min(</span>
                  <span class="s2">end,</span>
                  <span class="s2">priorFocusedElem.value.length</span>
                <span class="s2">));</span>
            <span class="s4">else </span><span class="s2">{</span>
              <span class="s4">var </span><span class="s2">doc = priorFocusedElem.ownerDocument || document,</span>
                <span class="s2">win = (doc &amp;&amp; doc.defaultView) || window;</span>
              <span class="s4">if </span><span class="s2">(win.getSelection) {</span>
                <span class="s4">var </span><span class="s2">selection = win.getSelection(),</span>
                  <span class="s2">length = priorFocusedElem.textContent.length,</span>
                  <span class="s2">start$jscomp$0 = Math.min(priorSelectionRange.start, length),</span>
                  <span class="s2">end$jscomp$0 =</span>
                    <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== priorSelectionRange.end</span>
                      <span class="s2">? start$jscomp$0</span>
                      <span class="s2">: Math.min(priorSelectionRange.end, length);</span>
                <span class="s2">!selection.extend &amp;&amp;</span>
                  <span class="s2">start$jscomp$0 &gt; end$jscomp$0 &amp;&amp;</span>
                  <span class="s2">((curFocusedElem = end$jscomp$0),</span>
                  <span class="s2">(end$jscomp$0 = start$jscomp$0),</span>
                  <span class="s2">(start$jscomp$0 = curFocusedElem));</span>
                <span class="s4">var </span><span class="s2">startMarker = getNodeForCharacterOffset(</span>
                    <span class="s2">priorFocusedElem,</span>
                    <span class="s2">start$jscomp$0</span>
                  <span class="s2">),</span>
                  <span class="s2">endMarker = getNodeForCharacterOffset(</span>
                    <span class="s2">priorFocusedElem,</span>
                    <span class="s2">end$jscomp$0</span>
                  <span class="s2">);</span>
                <span class="s4">if </span><span class="s2">(</span>
                  <span class="s2">startMarker &amp;&amp;</span>
                  <span class="s2">endMarker &amp;&amp;</span>
                  <span class="s2">(</span><span class="s5">1 </span><span class="s2">!== selection.rangeCount ||</span>
                    <span class="s2">selection.anchorNode !== startMarker.node ||</span>
                    <span class="s2">selection.anchorOffset !== startMarker.offset ||</span>
                    <span class="s2">selection.focusNode !== endMarker.node ||</span>
                    <span class="s2">selection.focusOffset !== endMarker.offset)</span>
                <span class="s2">) {</span>
                  <span class="s4">var </span><span class="s2">range = doc.createRange();</span>
                  <span class="s2">range.setStart(startMarker.node, startMarker.offset);</span>
                  <span class="s2">selection.removeAllRanges();</span>
                  <span class="s2">start$jscomp$0 &gt; end$jscomp$0</span>
                    <span class="s2">? (selection.addRange(range),</span>
                      <span class="s2">selection.extend(endMarker.node, endMarker.offset))</span>
                    <span class="s2">: (range.setEnd(endMarker.node, endMarker.offset),</span>
                      <span class="s2">selection.addRange(range));</span>
                <span class="s2">}</span>
              <span class="s2">}</span>
            <span class="s2">}</span>
          <span class="s2">}</span>
          <span class="s2">doc = [];</span>
          <span class="s4">for </span><span class="s2">(</span>
            <span class="s2">selection = priorFocusedElem;</span>
            <span class="s2">(selection = selection.parentNode);</span>

          <span class="s2">)</span>
            <span class="s5">1 </span><span class="s2">=== selection.nodeType &amp;&amp;</span>
              <span class="s2">doc.push({</span>
                <span class="s2">element: selection,</span>
                <span class="s2">left: selection.scrollLeft,</span>
                <span class="s2">top: selection.scrollTop</span>
              <span class="s2">});</span>
          <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">priorFocusedElem.focus &amp;&amp;</span>
            <span class="s2">priorFocusedElem.focus();</span>
          <span class="s4">for </span><span class="s2">(</span>
            <span class="s2">priorFocusedElem = </span><span class="s5">0</span><span class="s2">;</span>
            <span class="s2">priorFocusedElem &lt; doc.length;</span>
            <span class="s2">priorFocusedElem++</span>
          <span class="s2">) {</span>
            <span class="s4">var </span><span class="s2">info = doc[priorFocusedElem];</span>
            <span class="s2">info.element.scrollLeft = info.left;</span>
            <span class="s2">info.element.scrollTop = info.top;</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s2">_enabled = !!eventsEnabled;</span>
        <span class="s2">selectionInformation = eventsEnabled = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
        <span class="s2">(executionContext = prevExecutionContext),</span>
          <span class="s2">(ReactDOMSharedInternals.p = previousPriority),</span>
          <span class="s2">(ReactSharedInternals.T = rootMutationHasEffect);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">root.current = finishedWork;</span>
    <span class="s2">pendingEffectsStatus = </span><span class="s5">2</span><span class="s2">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">flushLayoutEffects() {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">2 </span><span class="s2">=== pendingEffectsStatus) {</span>
    <span class="s2">pendingEffectsStatus = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s4">var </span><span class="s2">root = pendingEffectsRoot,</span>
      <span class="s2">finishedWork = pendingFinishedWork,</span>
      <span class="s2">lanes = pendingEffectsLanes,</span>
      <span class="s2">rootHasLayoutEffect = </span><span class="s5">0 </span><span class="s2">!== (finishedWork.flags &amp; </span><span class="s5">8772</span><span class="s2">);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (finishedWork.subtreeFlags &amp; </span><span class="s5">8772</span><span class="s2">) || rootHasLayoutEffect) {</span>
      <span class="s2">rootHasLayoutEffect = ReactSharedInternals.T;</span>
      <span class="s2">ReactSharedInternals.T = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">var </span><span class="s2">previousPriority = ReactDOMSharedInternals.p;</span>
      <span class="s2">ReactDOMSharedInternals.p = </span><span class="s5">2</span><span class="s2">;</span>
      <span class="s4">var </span><span class="s2">prevExecutionContext = executionContext;</span>
      <span class="s2">executionContext |= </span><span class="s5">4</span><span class="s2">;</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s4">null </span><span class="s2">!== injectedProfilingHooks &amp;&amp;</span>
          <span class="s3">&quot;function&quot; </span><span class="s2">===</span>
            <span class="s4">typeof </span><span class="s2">injectedProfilingHooks.markLayoutEffectsStarted &amp;&amp;</span>
          <span class="s2">injectedProfilingHooks.markLayoutEffectsStarted(lanes),</span>
          <span class="s2">(inProgressLanes = lanes),</span>
          <span class="s2">(inProgressRoot = root),</span>
          <span class="s2">commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork),</span>
          <span class="s2">(inProgressRoot = inProgressLanes = </span><span class="s4">null</span><span class="s2">),</span>
          <span class="s4">null </span><span class="s2">!== injectedProfilingHooks &amp;&amp;</span>
            <span class="s3">&quot;function&quot; </span><span class="s2">===</span>
              <span class="s4">typeof </span><span class="s2">injectedProfilingHooks.markLayoutEffectsStopped &amp;&amp;</span>
            <span class="s2">injectedProfilingHooks.markLayoutEffectsStopped();</span>
      <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
        <span class="s2">(executionContext = prevExecutionContext),</span>
          <span class="s2">(ReactDOMSharedInternals.p = previousPriority),</span>
          <span class="s2">(ReactSharedInternals.T = rootHasLayoutEffect);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">pendingEffectsStatus = </span><span class="s5">3</span><span class="s2">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">flushSpawnedWork() {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">4 </span><span class="s2">=== pendingEffectsStatus || </span><span class="s5">3 </span><span class="s2">=== pendingEffectsStatus) {</span>
    <span class="s2">pendingEffectsStatus = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">requestPaint();</span>
    <span class="s4">var </span><span class="s2">root = pendingEffectsRoot,</span>
      <span class="s2">finishedWork = pendingFinishedWork,</span>
      <span class="s2">lanes = pendingEffectsLanes,</span>
      <span class="s2">recoverableErrors = pendingRecoverableErrors;</span>
    <span class="s5">0 </span><span class="s2">!== (finishedWork.subtreeFlags &amp; </span><span class="s5">10256</span><span class="s2">) ||</span>
    <span class="s5">0 </span><span class="s2">!== (finishedWork.flags &amp; </span><span class="s5">10256</span><span class="s2">)</span>
      <span class="s2">? (pendingEffectsStatus = </span><span class="s5">5</span><span class="s2">)</span>
      <span class="s2">: ((pendingEffectsStatus = </span><span class="s5">0</span><span class="s2">),</span>
        <span class="s2">(pendingFinishedWork = pendingEffectsRoot = </span><span class="s4">null</span><span class="s2">),</span>
        <span class="s2">releaseRootPooledCache(root, root.pendingLanes));</span>
    <span class="s4">var </span><span class="s2">remainingLanes = root.pendingLanes;</span>
    <span class="s5">0 </span><span class="s2">=== remainingLanes &amp;&amp; (legacyErrorBoundariesThatAlreadyFailed = </span><span class="s4">null</span><span class="s2">);</span>
    <span class="s2">remainingLanes = lanesToEventPriority(lanes);</span>
    <span class="s2">finishedWork = finishedWork.stateNode;</span>
    <span class="s4">if </span><span class="s2">(injectedHook &amp;&amp; </span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">injectedHook.onCommitFiberRoot)</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">didError = </span><span class="s5">128 </span><span class="s2">=== (finishedWork.current.flags &amp; </span><span class="s5">128</span><span class="s2">);</span>
        <span class="s4">switch </span><span class="s2">(remainingLanes) {</span>
          <span class="s4">case </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s4">var </span><span class="s2">schedulerPriority = ImmediatePriority;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s5">8</span><span class="s2">:</span>
            <span class="s2">schedulerPriority = UserBlockingPriority;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s5">32</span><span class="s2">:</span>
            <span class="s2">schedulerPriority = NormalPriority$1;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s5">268435456</span><span class="s2">:</span>
            <span class="s2">schedulerPriority = IdlePriority;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">default</span><span class="s2">:</span>
            <span class="s2">schedulerPriority = NormalPriority$1;</span>
        <span class="s2">}</span>
        <span class="s2">injectedHook.onCommitFiberRoot(</span>
          <span class="s2">rendererID,</span>
          <span class="s2">finishedWork,</span>
          <span class="s2">schedulerPriority,</span>
          <span class="s2">didError</span>
        <span class="s2">);</span>
      <span class="s2">} </span><span class="s4">catch </span><span class="s2">(err) {}</span>
    <span class="s2">isDevToolsPresent &amp;&amp; root.memoizedUpdaters.clear();</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== recoverableErrors) {</span>
      <span class="s2">didError = ReactSharedInternals.T;</span>
      <span class="s2">schedulerPriority = ReactDOMSharedInternals.p;</span>
      <span class="s2">ReactDOMSharedInternals.p = </span><span class="s5">2</span><span class="s2">;</span>
      <span class="s2">ReactSharedInternals.T = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">onRecoverableError = root.onRecoverableError;</span>
        <span class="s4">for </span><span class="s2">(</span>
          <span class="s2">finishedWork = </span><span class="s5">0</span><span class="s2">;</span>
          <span class="s2">finishedWork &lt; recoverableErrors.length;</span>
          <span class="s2">finishedWork++</span>
        <span class="s2">) {</span>
          <span class="s4">var </span><span class="s2">recoverableError = recoverableErrors[finishedWork];</span>
          <span class="s2">onRecoverableError(recoverableError.value, {</span>
            <span class="s2">componentStack: recoverableError.stack</span>
          <span class="s2">});</span>
        <span class="s2">}</span>
      <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
        <span class="s2">(ReactSharedInternals.T = didError),</span>
          <span class="s2">(ReactDOMSharedInternals.p = schedulerPriority);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s5">0 </span><span class="s2">!== (pendingEffectsLanes &amp; </span><span class="s5">3</span><span class="s2">) &amp;&amp; flushPendingEffects();</span>
    <span class="s2">ensureRootIsScheduled(root);</span>
    <span class="s2">remainingLanes = root.pendingLanes;</span>
    <span class="s5">0 </span><span class="s2">!== (lanes &amp; </span><span class="s5">4194090</span><span class="s2">) &amp;&amp; </span><span class="s5">0 </span><span class="s2">!== (remainingLanes &amp; </span><span class="s5">42</span><span class="s2">)</span>
      <span class="s2">? ((nestedUpdateScheduled = !</span><span class="s5">0</span><span class="s2">),</span>
        <span class="s2">root === rootWithNestedUpdates</span>
          <span class="s2">? nestedUpdateCount++</span>
          <span class="s2">: ((nestedUpdateCount = </span><span class="s5">0</span><span class="s2">), (rootWithNestedUpdates = root)))</span>
      <span class="s2">: (nestedUpdateCount = </span><span class="s5">0</span><span class="s2">);</span>
    <span class="s2">flushSyncWorkAcrossRoots_impl(</span><span class="s5">0</span><span class="s2">, !</span><span class="s5">1</span><span class="s2">);</span>
    <span class="s2">markCommitStopped();</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">releaseRootPooledCache(root, remainingLanes) {</span>
  <span class="s5">0 </span><span class="s2">=== (root.pooledCacheLanes &amp;= remainingLanes) &amp;&amp;</span>
    <span class="s2">((remainingLanes = root.pooledCache),</span>
    <span class="s4">null </span><span class="s2">!= remainingLanes &amp;&amp;</span>
      <span class="s2">((root.pooledCache = </span><span class="s4">null</span><span class="s2">), releaseCache(remainingLanes)));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">flushPendingEffects(wasDelayedCommit) {</span>
  <span class="s2">flushMutationEffects();</span>
  <span class="s2">flushLayoutEffects();</span>
  <span class="s2">flushSpawnedWork();</span>
  <span class="s4">return </span><span class="s2">flushPassiveEffects(wasDelayedCommit);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">flushPassiveEffects() {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">5 </span><span class="s2">!== pendingEffectsStatus) </span><span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">root = pendingEffectsRoot,</span>
    <span class="s2">remainingLanes = pendingEffectsRemainingLanes;</span>
  <span class="s2">pendingEffectsRemainingLanes = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">renderPriority = lanesToEventPriority(pendingEffectsLanes),</span>
    <span class="s2">prevTransition = ReactSharedInternals.T,</span>
    <span class="s2">previousPriority = ReactDOMSharedInternals.p;</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s2">ReactDOMSharedInternals.p = </span><span class="s5">32 </span><span class="s2">&gt; renderPriority ? </span><span class="s5">32 </span><span class="s2">: renderPriority;</span>
    <span class="s2">ReactSharedInternals.T = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s2">renderPriority = pendingPassiveTransitions;</span>
    <span class="s2">pendingPassiveTransitions = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">var </span><span class="s2">root$jscomp$0 = pendingEffectsRoot,</span>
      <span class="s2">lanes = pendingEffectsLanes;</span>
    <span class="s2">pendingEffectsStatus = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">pendingFinishedWork = pendingEffectsRoot = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s2">pendingEffectsLanes = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== (executionContext &amp; </span><span class="s5">6</span><span class="s2">)) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">331</span><span class="s2">));</span>
    <span class="s4">null </span><span class="s2">!== injectedProfilingHooks &amp;&amp;</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">injectedProfilingHooks.markPassiveEffectsStarted &amp;&amp;</span>
      <span class="s2">injectedProfilingHooks.markPassiveEffectsStarted(lanes);</span>
    <span class="s4">var </span><span class="s2">prevExecutionContext = executionContext;</span>
    <span class="s2">executionContext |= </span><span class="s5">4</span><span class="s2">;</span>
    <span class="s2">commitPassiveUnmountOnFiber(root$jscomp$0.current);</span>
    <span class="s2">commitPassiveMountOnFiber(</span>
      <span class="s2">root$jscomp$0,</span>
      <span class="s2">root$jscomp$0.current,</span>
      <span class="s2">lanes,</span>
      <span class="s2">renderPriority</span>
    <span class="s2">);</span>
    <span class="s4">null </span><span class="s2">!== injectedProfilingHooks &amp;&amp;</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">injectedProfilingHooks.markPassiveEffectsStopped &amp;&amp;</span>
      <span class="s2">injectedProfilingHooks.markPassiveEffectsStopped();</span>
    <span class="s2">executionContext = prevExecutionContext;</span>
    <span class="s2">flushSyncWorkAcrossRoots_impl(</span><span class="s5">0</span><span class="s2">, !</span><span class="s5">1</span><span class="s2">);</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">injectedHook &amp;&amp;</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">injectedHook.onPostCommitFiberRoot</span>
    <span class="s2">)</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s2">injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);</span>
      <span class="s2">} </span><span class="s4">catch </span><span class="s2">(err) {}</span>
    <span class="s4">var </span><span class="s2">stateNode = root$jscomp$0.current.stateNode;</span>
    <span class="s2">stateNode.effectDuration = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">stateNode.passiveEffectDuration = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
    <span class="s2">(ReactDOMSharedInternals.p = previousPriority),</span>
      <span class="s2">(ReactSharedInternals.T = prevTransition),</span>
      <span class="s2">releaseRootPooledCache(root, remainingLanes);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {</span>
  <span class="s2">sourceFiber = createCapturedValueAtFiber(error, sourceFiber);</span>
  <span class="s2">sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, </span><span class="s5">2</span><span class="s2">);</span>
  <span class="s2">rootFiber = enqueueUpdate(rootFiber, sourceFiber, </span><span class="s5">2</span><span class="s2">);</span>
  <span class="s4">null </span><span class="s2">!== rootFiber &amp;&amp;</span>
    <span class="s2">(markRootUpdated$1(rootFiber, </span><span class="s5">2</span><span class="s2">), ensureRootIsScheduled(rootFiber));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">3 </span><span class="s2">=== sourceFiber.tag)</span>
    <span class="s2">captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);</span>
  <span class="s4">else</span>
    <span class="s4">for </span><span class="s2">(; </span><span class="s4">null </span><span class="s2">!== nearestMountedAncestor; ) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s5">3 </span><span class="s2">=== nearestMountedAncestor.tag) {</span>
        <span class="s2">captureCommitPhaseErrorOnRoot(</span>
          <span class="s2">nearestMountedAncestor,</span>
          <span class="s2">sourceFiber,</span>
          <span class="s2">error</span>
        <span class="s2">);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s2">} </span><span class="s4">else if </span><span class="s2">(</span><span class="s5">1 </span><span class="s2">=== nearestMountedAncestor.tag) {</span>
        <span class="s4">var </span><span class="s2">instance = nearestMountedAncestor.stateNode;</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s3">&quot;function&quot; </span><span class="s2">===</span>
            <span class="s4">typeof </span><span class="s2">nearestMountedAncestor.type.getDerivedStateFromError ||</span>
          <span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">instance.componentDidCatch &amp;&amp;</span>
            <span class="s2">(</span><span class="s4">null </span><span class="s2">=== legacyErrorBoundariesThatAlreadyFailed ||</span>
              <span class="s2">!legacyErrorBoundariesThatAlreadyFailed.has(instance)))</span>
        <span class="s2">) {</span>
          <span class="s2">sourceFiber = createCapturedValueAtFiber(error, sourceFiber);</span>
          <span class="s2">error = createClassErrorUpdate(</span><span class="s5">2</span><span class="s2">);</span>
          <span class="s2">instance = enqueueUpdate(nearestMountedAncestor, error, </span><span class="s5">2</span><span class="s2">);</span>
          <span class="s4">null </span><span class="s2">!== instance &amp;&amp;</span>
            <span class="s2">(initializeClassErrorUpdate(</span>
              <span class="s2">error,</span>
              <span class="s2">instance,</span>
              <span class="s2">nearestMountedAncestor,</span>
              <span class="s2">sourceFiber</span>
            <span class="s2">),</span>
            <span class="s2">markRootUpdated$1(instance, </span><span class="s5">2</span><span class="s2">),</span>
            <span class="s2">ensureRootIsScheduled(instance));</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s2">nearestMountedAncestor = nearestMountedAncestor.return;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">attachPingListener(root, wakeable, lanes) {</span>
  <span class="s4">var </span><span class="s2">pingCache = root.pingCache;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== pingCache) {</span>
    <span class="s2">pingCache = root.pingCache = </span><span class="s4">new </span><span class="s2">PossiblyWeakMap();</span>
    <span class="s4">var </span><span class="s2">threadIDs = </span><span class="s4">new </span><span class="s2">Set();</span>
    <span class="s2">pingCache.set(wakeable, threadIDs);</span>
  <span class="s2">} </span><span class="s4">else</span>
    <span class="s2">(threadIDs = pingCache.get(wakeable)),</span>
      <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== threadIDs &amp;&amp;</span>
        <span class="s2">((threadIDs = </span><span class="s4">new </span><span class="s2">Set()), pingCache.set(wakeable, threadIDs));</span>
  <span class="s2">threadIDs.has(lanes) ||</span>
    <span class="s2">((workInProgressRootDidAttachPingListener = !</span><span class="s5">0</span><span class="s2">),</span>
    <span class="s2">threadIDs.add(lanes),</span>
    <span class="s2">(pingCache = pingSuspendedRoot.bind(</span><span class="s4">null</span><span class="s2">, root, wakeable, lanes)),</span>
    <span class="s2">isDevToolsPresent &amp;&amp; restorePendingUpdaters(root, lanes),</span>
    <span class="s2">wakeable.then(pingCache, pingCache));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">pingSuspendedRoot(root, wakeable, pingedLanes) {</span>
  <span class="s4">var </span><span class="s2">pingCache = root.pingCache;</span>
  <span class="s4">null </span><span class="s2">!== pingCache &amp;&amp; pingCache.delete(wakeable);</span>
  <span class="s2">root.pingedLanes |= root.suspendedLanes &amp; pingedLanes;</span>
  <span class="s2">root.warmLanes &amp;= ~pingedLanes;</span>
  <span class="s2">workInProgressRoot === root &amp;&amp;</span>
    <span class="s2">(workInProgressRootRenderLanes &amp; pingedLanes) === pingedLanes &amp;&amp;</span>
    <span class="s2">(</span><span class="s5">4 </span><span class="s2">=== workInProgressRootExitStatus ||</span>
    <span class="s2">(</span><span class="s5">3 </span><span class="s2">=== workInProgressRootExitStatus &amp;&amp;</span>
      <span class="s2">(workInProgressRootRenderLanes &amp; </span><span class="s5">62914560</span><span class="s2">) ===</span>
        <span class="s2">workInProgressRootRenderLanes &amp;&amp;</span>
      <span class="s5">300 </span><span class="s2">&gt; now$1() - globalMostRecentFallbackTime)</span>
      <span class="s2">? </span><span class="s5">0 </span><span class="s2">=== (executionContext &amp; </span><span class="s5">2</span><span class="s2">) &amp;&amp; prepareFreshStack(root, </span><span class="s5">0</span><span class="s2">)</span>
      <span class="s2">: (workInProgressRootPingedLanes |= pingedLanes),</span>
    <span class="s2">workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes &amp;&amp;</span>
      <span class="s2">(workInProgressSuspendedRetryLanes = </span><span class="s5">0</span><span class="s2">));</span>
  <span class="s2">ensureRootIsScheduled(root);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">retryTimedOutBoundary(boundaryFiber, retryLane) {</span>
  <span class="s5">0 </span><span class="s2">=== retryLane &amp;&amp; (retryLane = claimNextRetryLane());</span>
  <span class="s2">boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);</span>
  <span class="s4">null </span><span class="s2">!== boundaryFiber &amp;&amp;</span>
    <span class="s2">(markRootUpdated$1(boundaryFiber, retryLane),</span>
    <span class="s2">ensureRootIsScheduled(boundaryFiber));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">retryDehydratedSuspenseBoundary(boundaryFiber) {</span>
  <span class="s4">var </span><span class="s2">suspenseState = boundaryFiber.memoizedState,</span>
    <span class="s2">retryLane = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">null </span><span class="s2">!== suspenseState &amp;&amp; (retryLane = suspenseState.retryLane);</span>
  <span class="s2">retryTimedOutBoundary(boundaryFiber, retryLane);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">resolveRetryWakeable(boundaryFiber, wakeable) {</span>
  <span class="s4">var </span><span class="s2">retryLane = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">switch </span><span class="s2">(boundaryFiber.tag) {</span>
    <span class="s4">case </span><span class="s5">13</span><span class="s2">:</span>
      <span class="s4">var </span><span class="s2">retryCache = boundaryFiber.stateNode;</span>
      <span class="s4">var </span><span class="s2">suspenseState = boundaryFiber.memoizedState;</span>
      <span class="s4">null </span><span class="s2">!== suspenseState &amp;&amp; (retryLane = suspenseState.retryLane);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">19</span><span class="s2">:</span>
      <span class="s2">retryCache = boundaryFiber.stateNode;</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">22</span><span class="s2">:</span>
      <span class="s2">retryCache = boundaryFiber.stateNode._retryCache;</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">314</span><span class="s2">));</span>
  <span class="s2">}</span>
  <span class="s4">null </span><span class="s2">!== retryCache &amp;&amp; retryCache.delete(wakeable);</span>
  <span class="s2">retryTimedOutBoundary(boundaryFiber, retryLane);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">restorePendingUpdaters(root, lanes) {</span>
  <span class="s2">isDevToolsPresent &amp;&amp;</span>
    <span class="s2">root.memoizedUpdaters.forEach(</span><span class="s4">function </span><span class="s2">(schedulingFiber) {</span>
      <span class="s2">addFiberToLanesMap(root, schedulingFiber, lanes);</span>
    <span class="s2">});</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">scheduleCallback$1(priorityLevel, callback) {</span>
  <span class="s4">return </span><span class="s2">scheduleCallback$3(priorityLevel, callback);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">firstScheduledRoot = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">lastScheduledRoot = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">didScheduleMicrotask = !</span><span class="s5">1</span><span class="s2">,</span>
  <span class="s2">mightHavePendingSyncWork = !</span><span class="s5">1</span><span class="s2">,</span>
  <span class="s2">isFlushingWork = !</span><span class="s5">1</span><span class="s2">,</span>
  <span class="s2">currentEventTransitionLane = </span><span class="s5">0</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">ensureRootIsScheduled(root) {</span>
  <span class="s2">root !== lastScheduledRoot &amp;&amp;</span>
    <span class="s4">null </span><span class="s2">=== root.next &amp;&amp;</span>
    <span class="s2">(</span><span class="s4">null </span><span class="s2">=== lastScheduledRoot</span>
      <span class="s2">? (firstScheduledRoot = lastScheduledRoot = root)</span>
      <span class="s2">: (lastScheduledRoot = lastScheduledRoot.next = root));</span>
  <span class="s2">mightHavePendingSyncWork = !</span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">didScheduleMicrotask ||</span>
    <span class="s2">((didScheduleMicrotask = !</span><span class="s5">0</span><span class="s2">), scheduleImmediateRootScheduleTask());</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {</span>
  <span class="s4">if </span><span class="s2">(!isFlushingWork &amp;&amp; mightHavePendingSyncWork) {</span>
    <span class="s2">isFlushingWork = !</span><span class="s5">0</span><span class="s2">;</span>
    <span class="s4">do </span><span class="s2">{</span>
      <span class="s4">var </span><span class="s2">didPerformSomeWork = !</span><span class="s5">1</span><span class="s2">;</span>
      <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">root$189 = firstScheduledRoot; </span><span class="s4">null </span><span class="s2">!== root$189; ) {</span>
        <span class="s4">if </span><span class="s2">(!onlyLegacy)</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== syncTransitionLanes) {</span>
            <span class="s4">var </span><span class="s2">pendingLanes = root$189.pendingLanes;</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== pendingLanes) </span><span class="s4">var </span><span class="s2">JSCompiler_inline_result = </span><span class="s5">0</span><span class="s2">;</span>
            <span class="s4">else </span><span class="s2">{</span>
              <span class="s4">var </span><span class="s2">suspendedLanes = root$189.suspendedLanes,</span>
                <span class="s2">pingedLanes = root$189.pingedLanes;</span>
              <span class="s2">JSCompiler_inline_result =</span>
                <span class="s2">(</span><span class="s5">1 </span><span class="s2">&lt;&lt; (</span><span class="s5">31 </span><span class="s2">- clz32(</span><span class="s5">42 </span><span class="s2">| syncTransitionLanes) + </span><span class="s5">1</span><span class="s2">)) - </span><span class="s5">1</span><span class="s2">;</span>
              <span class="s2">JSCompiler_inline_result &amp;=</span>
                <span class="s2">pendingLanes &amp; ~(suspendedLanes &amp; ~pingedLanes);</span>
              <span class="s2">JSCompiler_inline_result =</span>
                <span class="s2">JSCompiler_inline_result &amp; </span><span class="s5">201326741</span>
                  <span class="s2">? (JSCompiler_inline_result &amp; </span><span class="s5">201326741</span><span class="s2">) | </span><span class="s5">1</span>
                  <span class="s2">: JSCompiler_inline_result</span>
                    <span class="s2">? JSCompiler_inline_result | </span><span class="s5">2</span>
                    <span class="s2">: </span><span class="s5">0</span><span class="s2">;</span>
            <span class="s2">}</span>
            <span class="s5">0 </span><span class="s2">!== JSCompiler_inline_result &amp;&amp;</span>
              <span class="s2">((didPerformSomeWork = !</span><span class="s5">0</span><span class="s2">),</span>
              <span class="s2">performSyncWorkOnRoot(root$189, JSCompiler_inline_result));</span>
          <span class="s2">} </span><span class="s4">else</span>
            <span class="s2">(JSCompiler_inline_result = workInProgressRootRenderLanes),</span>
              <span class="s2">(JSCompiler_inline_result = getNextLanes(</span>
                <span class="s2">root$189,</span>
                <span class="s2">root$189 === workInProgressRoot ? JSCompiler_inline_result : </span><span class="s5">0</span><span class="s2">,</span>
                <span class="s4">null </span><span class="s2">!== root$189.cancelPendingCommit ||</span>
                  <span class="s2">-</span><span class="s5">1 </span><span class="s2">!== root$189.timeoutHandle</span>
              <span class="s2">)),</span>
              <span class="s5">0 </span><span class="s2">=== (JSCompiler_inline_result &amp; </span><span class="s5">3</span><span class="s2">) ||</span>
                <span class="s2">checkIfRootIsPrerendering(root$189, JSCompiler_inline_result) ||</span>
                <span class="s2">((didPerformSomeWork = !</span><span class="s5">0</span><span class="s2">),</span>
                <span class="s2">performSyncWorkOnRoot(root$189, JSCompiler_inline_result));</span>
        <span class="s2">root$189 = root$189.next;</span>
      <span class="s2">}</span>
    <span class="s2">} </span><span class="s4">while </span><span class="s2">(didPerformSomeWork);</span>
    <span class="s2">isFlushingWork = !</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">processRootScheduleInImmediateTask() {</span>
  <span class="s2">processRootScheduleInMicrotask();</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">processRootScheduleInMicrotask() {</span>
  <span class="s2">mightHavePendingSyncWork = didScheduleMicrotask = !</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">syncTransitionLanes = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s5">0 </span><span class="s2">!== currentEventTransitionLane &amp;&amp;</span>
    <span class="s2">(shouldAttemptEagerTransition() &amp;&amp;</span>
      <span class="s2">(syncTransitionLanes = currentEventTransitionLane),</span>
    <span class="s2">(currentEventTransitionLane = </span><span class="s5">0</span><span class="s2">));</span>
  <span class="s4">for </span><span class="s2">(</span>
    <span class="s4">var </span><span class="s2">currentTime = now$1(), prev = </span><span class="s4">null</span><span class="s2">, root = firstScheduledRoot;</span>
    <span class="s4">null </span><span class="s2">!== root;</span>

  <span class="s2">) {</span>
    <span class="s4">var </span><span class="s2">next = root.next,</span>
      <span class="s2">nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== nextLanes)</span>
      <span class="s2">(root.next = </span><span class="s4">null</span><span class="s2">),</span>
        <span class="s4">null </span><span class="s2">=== prev ? (firstScheduledRoot = next) : (prev.next = next),</span>
        <span class="s4">null </span><span class="s2">=== next &amp;&amp; (lastScheduledRoot = prev);</span>
    <span class="s4">else if </span><span class="s2">(</span>
      <span class="s2">((prev = root), </span><span class="s5">0 </span><span class="s2">!== syncTransitionLanes || </span><span class="s5">0 </span><span class="s2">!== (nextLanes &amp; </span><span class="s5">3</span><span class="s2">))</span>
    <span class="s2">)</span>
      <span class="s2">mightHavePendingSyncWork = !</span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">root = next;</span>
  <span class="s2">}</span>
  <span class="s2">flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !</span><span class="s5">1</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">scheduleTaskForRootDuringMicrotask(root, currentTime) {</span>
  <span class="s4">for </span><span class="s2">(</span>
    <span class="s4">var </span><span class="s2">suspendedLanes = root.suspendedLanes,</span>
      <span class="s2">pingedLanes = root.pingedLanes,</span>
      <span class="s2">expirationTimes = root.expirationTimes,</span>
      <span class="s2">lanes = root.pendingLanes &amp; -</span><span class="s5">62914561</span><span class="s2">;</span>
    <span class="s5">0 </span><span class="s2">&lt; lanes;</span>

  <span class="s2">) {</span>
    <span class="s4">var </span><span class="s2">index$3 = </span><span class="s5">31 </span><span class="s2">- clz32(lanes),</span>
      <span class="s2">lane = </span><span class="s5">1 </span><span class="s2">&lt;&lt; index$3,</span>
      <span class="s2">expirationTime = expirationTimes[index$3];</span>
    <span class="s4">if </span><span class="s2">(-</span><span class="s5">1 </span><span class="s2">=== expirationTime) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== (lane &amp; suspendedLanes) || </span><span class="s5">0 </span><span class="s2">!== (lane &amp; pingedLanes))</span>
        <span class="s2">expirationTimes[index$3] = computeExpirationTime(lane, currentTime);</span>
    <span class="s2">} </span><span class="s4">else </span><span class="s2">expirationTime &lt;= currentTime &amp;&amp; (root.expiredLanes |= lane);</span>
    <span class="s2">lanes &amp;= ~lane;</span>
  <span class="s2">}</span>
  <span class="s2">currentTime = workInProgressRoot;</span>
  <span class="s2">suspendedLanes = workInProgressRootRenderLanes;</span>
  <span class="s2">suspendedLanes = getNextLanes(</span>
    <span class="s2">root,</span>
    <span class="s2">root === currentTime ? suspendedLanes : </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s4">null </span><span class="s2">!== root.cancelPendingCommit || -</span><span class="s5">1 </span><span class="s2">!== root.timeoutHandle</span>
  <span class="s2">);</span>
  <span class="s2">pingedLanes = root.callbackNode;</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s5">0 </span><span class="s2">=== suspendedLanes ||</span>
    <span class="s2">(root === currentTime &amp;&amp;</span>
      <span class="s2">(</span><span class="s5">2 </span><span class="s2">=== workInProgressSuspendedReason ||</span>
        <span class="s5">9 </span><span class="s2">=== workInProgressSuspendedReason)) ||</span>
    <span class="s4">null </span><span class="s2">!== root.cancelPendingCommit</span>
  <span class="s2">)</span>
    <span class="s4">return </span><span class="s2">(</span>
      <span class="s4">null </span><span class="s2">!== pingedLanes &amp;&amp;</span>
        <span class="s4">null </span><span class="s2">!== pingedLanes &amp;&amp;</span>
        <span class="s2">cancelCallback$1(pingedLanes),</span>
      <span class="s2">(root.callbackNode = </span><span class="s4">null</span><span class="s2">),</span>
      <span class="s2">(root.callbackPriority = </span><span class="s5">0</span><span class="s2">)</span>
    <span class="s2">);</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s5">0 </span><span class="s2">=== (suspendedLanes &amp; </span><span class="s5">3</span><span class="s2">) ||</span>
    <span class="s2">checkIfRootIsPrerendering(root, suspendedLanes)</span>
  <span class="s2">) {</span>
    <span class="s2">currentTime = suspendedLanes &amp; -suspendedLanes;</span>
    <span class="s4">if </span><span class="s2">(currentTime === root.callbackPriority) </span><span class="s4">return </span><span class="s2">currentTime;</span>
    <span class="s4">null </span><span class="s2">!== pingedLanes &amp;&amp; cancelCallback$1(pingedLanes);</span>
    <span class="s4">switch </span><span class="s2">(lanesToEventPriority(suspendedLanes)) {</span>
      <span class="s4">case </span><span class="s5">2</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s5">8</span><span class="s2">:</span>
        <span class="s2">suspendedLanes = UserBlockingPriority;</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s5">32</span><span class="s2">:</span>
        <span class="s2">suspendedLanes = NormalPriority$1;</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s5">268435456</span><span class="s2">:</span>
        <span class="s2">suspendedLanes = IdlePriority;</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">default</span><span class="s2">:</span>
        <span class="s2">suspendedLanes = NormalPriority$1;</span>
    <span class="s2">}</span>
    <span class="s2">pingedLanes = performWorkOnRootViaSchedulerTask.bind(</span><span class="s4">null</span><span class="s2">, root);</span>
    <span class="s2">suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);</span>
    <span class="s2">root.callbackPriority = currentTime;</span>
    <span class="s2">root.callbackNode = suspendedLanes;</span>
    <span class="s4">return </span><span class="s2">currentTime;</span>
  <span class="s2">}</span>
  <span class="s4">null </span><span class="s2">!== pingedLanes &amp;&amp; </span><span class="s4">null </span><span class="s2">!== pingedLanes &amp;&amp; cancelCallback$1(pingedLanes);</span>
  <span class="s2">root.callbackPriority = </span><span class="s5">2</span><span class="s2">;</span>
  <span class="s2">root.callbackNode = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">return </span><span class="s5">2</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">performWorkOnRootViaSchedulerTask(root, didTimeout) {</span>
  <span class="s2">nestedUpdateScheduled = currentUpdateIsNested = !</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== pendingEffectsStatus &amp;&amp; </span><span class="s5">5 </span><span class="s2">!== pendingEffectsStatus)</span>
    <span class="s4">return </span><span class="s2">(root.callbackNode = </span><span class="s4">null</span><span class="s2">), (root.callbackPriority = </span><span class="s5">0</span><span class="s2">), </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">originalCallbackNode = root.callbackNode;</span>
  <span class="s4">if </span><span class="s2">(flushPendingEffects(!</span><span class="s5">0</span><span class="s2">) &amp;&amp; root.callbackNode !== originalCallbackNode)</span>
    <span class="s4">return null</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;</span>
  <span class="s2">workInProgressRootRenderLanes$jscomp$0 = getNextLanes(</span>
    <span class="s2">root,</span>
    <span class="s2">root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s4">null </span><span class="s2">!== root.cancelPendingCommit || -</span><span class="s5">1 </span><span class="s2">!== root.timeoutHandle</span>
  <span class="s2">);</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== workInProgressRootRenderLanes$jscomp$0) </span><span class="s4">return null</span><span class="s2">;</span>
  <span class="s2">performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);</span>
  <span class="s2">scheduleTaskForRootDuringMicrotask(root, now$1());</span>
  <span class="s4">return null </span><span class="s2">!= root.callbackNode &amp;&amp; root.callbackNode === originalCallbackNode</span>
    <span class="s2">? performWorkOnRootViaSchedulerTask.bind(</span><span class="s4">null</span><span class="s2">, root)</span>
    <span class="s2">: </span><span class="s4">null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">performSyncWorkOnRoot(root, lanes) {</span>
  <span class="s4">if </span><span class="s2">(flushPendingEffects()) </span><span class="s4">return null</span><span class="s2">;</span>
  <span class="s2">currentUpdateIsNested = nestedUpdateScheduled;</span>
  <span class="s2">nestedUpdateScheduled = !</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">performWorkOnRoot(root, lanes, !</span><span class="s5">0</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">scheduleImmediateRootScheduleTask() {</span>
  <span class="s2">scheduleMicrotask(</span><span class="s4">function </span><span class="s2">() {</span>
    <span class="s5">0 </span><span class="s2">!== (executionContext &amp; </span><span class="s5">6</span><span class="s2">)</span>
      <span class="s2">? scheduleCallback$3(</span>
          <span class="s2">ImmediatePriority,</span>
          <span class="s2">processRootScheduleInImmediateTask</span>
        <span class="s2">)</span>
      <span class="s2">: processRootScheduleInMicrotask();</span>
  <span class="s2">});</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">requestTransitionLane() {</span>
  <span class="s5">0 </span><span class="s2">=== currentEventTransitionLane &amp;&amp;</span>
    <span class="s2">(currentEventTransitionLane = claimNextTransitionLane());</span>
  <span class="s4">return </span><span class="s2">currentEventTransitionLane;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">coerceFormActionProp(actionProp) {</span>
  <span class="s4">return null </span><span class="s2">== actionProp ||</span>
    <span class="s3">&quot;symbol&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">actionProp ||</span>
    <span class="s3">&quot;boolean&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">actionProp</span>
    <span class="s2">? </span><span class="s4">null</span>
    <span class="s2">: </span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">actionProp</span>
      <span class="s2">? actionProp</span>
      <span class="s2">: sanitizeURL(</span><span class="s3">&quot;&quot; </span><span class="s2">+ actionProp);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createFormDataWithSubmitter(form, submitter) {</span>
  <span class="s4">var </span><span class="s2">temp = submitter.ownerDocument.createElement(</span><span class="s3">&quot;input&quot;</span><span class="s2">);</span>
  <span class="s2">temp.name = submitter.name;</span>
  <span class="s2">temp.value = submitter.value;</span>
  <span class="s2">form.id &amp;&amp; temp.setAttribute(</span><span class="s3">&quot;form&quot;</span><span class="s2">, form.id);</span>
  <span class="s2">submitter.parentNode.insertBefore(temp, submitter);</span>
  <span class="s2">form = </span><span class="s4">new </span><span class="s2">FormData(form);</span>
  <span class="s2">temp.parentNode.removeChild(temp);</span>
  <span class="s4">return </span><span class="s2">form;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">extractEvents$1(</span>
  <span class="s2">dispatchQueue,</span>
  <span class="s2">domEventName,</span>
  <span class="s2">maybeTargetInst,</span>
  <span class="s2">nativeEvent,</span>
  <span class="s2">nativeEventTarget</span>
<span class="s2">) {</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s3">&quot;submit&quot; </span><span class="s2">=== domEventName &amp;&amp;</span>
    <span class="s2">maybeTargetInst &amp;&amp;</span>
    <span class="s2">maybeTargetInst.stateNode === nativeEventTarget</span>
  <span class="s2">) {</span>
    <span class="s4">var </span><span class="s2">action = coerceFormActionProp(</span>
        <span class="s2">(nativeEventTarget[internalPropsKey] || </span><span class="s4">null</span><span class="s2">).action</span>
      <span class="s2">),</span>
      <span class="s2">submitter = nativeEvent.submitter;</span>
    <span class="s2">submitter &amp;&amp;</span>
      <span class="s2">((domEventName = (domEventName = submitter[internalPropsKey] || </span><span class="s4">null</span><span class="s2">)</span>
        <span class="s2">? coerceFormActionProp(domEventName.formAction)</span>
        <span class="s2">: submitter.getAttribute(</span><span class="s3">&quot;formAction&quot;</span><span class="s2">)),</span>
      <span class="s4">null </span><span class="s2">!== domEventName &amp;&amp; ((action = domEventName), (submitter = </span><span class="s4">null</span><span class="s2">)));</span>
    <span class="s4">var </span><span class="s2">event = </span><span class="s4">new </span><span class="s2">SyntheticEvent(</span>
      <span class="s3">&quot;action&quot;</span><span class="s2">,</span>
      <span class="s3">&quot;action&quot;</span><span class="s2">,</span>
      <span class="s4">null</span><span class="s2">,</span>
      <span class="s2">nativeEvent,</span>
      <span class="s2">nativeEventTarget</span>
    <span class="s2">);</span>
    <span class="s2">dispatchQueue.push({</span>
      <span class="s2">event: event,</span>
      <span class="s2">listeners: [</span>
        <span class="s2">{</span>
          <span class="s2">instance: </span><span class="s4">null</span><span class="s2">,</span>
          <span class="s2">listener: </span><span class="s4">function </span><span class="s2">() {</span>
            <span class="s4">if </span><span class="s2">(nativeEvent.defaultPrevented) {</span>
              <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== currentEventTransitionLane) {</span>
                <span class="s4">var </span><span class="s2">formData = submitter</span>
                  <span class="s2">? createFormDataWithSubmitter(nativeEventTarget, submitter)</span>
                  <span class="s2">: </span><span class="s4">new </span><span class="s2">FormData(nativeEventTarget);</span>
                <span class="s2">startHostTransition(</span>
                  <span class="s2">maybeTargetInst,</span>
                  <span class="s2">{</span>
                    <span class="s2">pending: !</span><span class="s5">0</span><span class="s2">,</span>
                    <span class="s2">data: formData,</span>
                    <span class="s2">method: nativeEventTarget.method,</span>
                    <span class="s2">action: action</span>
                  <span class="s2">},</span>
                  <span class="s4">null</span><span class="s2">,</span>
                  <span class="s2">formData</span>
                <span class="s2">);</span>
              <span class="s2">}</span>
            <span class="s2">} </span><span class="s4">else</span>
              <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">action &amp;&amp;</span>
                <span class="s2">(event.preventDefault(),</span>
                <span class="s2">(formData = submitter</span>
                  <span class="s2">? createFormDataWithSubmitter(nativeEventTarget, submitter)</span>
                  <span class="s2">: </span><span class="s4">new </span><span class="s2">FormData(nativeEventTarget)),</span>
                <span class="s2">startHostTransition(</span>
                  <span class="s2">maybeTargetInst,</span>
                  <span class="s2">{</span>
                    <span class="s2">pending: !</span><span class="s5">0</span><span class="s2">,</span>
                    <span class="s2">data: formData,</span>
                    <span class="s2">method: nativeEventTarget.method,</span>
                    <span class="s2">action: action</span>
                  <span class="s2">},</span>
                  <span class="s2">action,</span>
                  <span class="s2">formData</span>
                <span class="s2">));</span>
          <span class="s2">},</span>
          <span class="s2">currentTarget: nativeEventTarget</span>
        <span class="s2">}</span>
      <span class="s2">]</span>
    <span class="s2">});</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">for </span><span class="s2">(</span>
  <span class="s4">var </span><span class="s2">i$jscomp$inline_1622 = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">i$jscomp$inline_1622 &lt; simpleEventPluginEvents.length;</span>
  <span class="s2">i$jscomp$inline_1622++</span>
<span class="s2">) {</span>
  <span class="s4">var </span><span class="s2">eventName$jscomp$inline_1623 =</span>
      <span class="s2">simpleEventPluginEvents[i$jscomp$inline_1622],</span>
    <span class="s2">domEventName$jscomp$inline_1624 =</span>
      <span class="s2">eventName$jscomp$inline_1623.toLowerCase(),</span>
    <span class="s2">capitalizedEvent$jscomp$inline_1625 =</span>
      <span class="s2">eventName$jscomp$inline_1623[</span><span class="s5">0</span><span class="s2">].toUpperCase() +</span>
      <span class="s2">eventName$jscomp$inline_1623.slice(</span><span class="s5">1</span><span class="s2">);</span>
  <span class="s2">registerSimpleEvent(</span>
    <span class="s2">domEventName$jscomp$inline_1624,</span>
    <span class="s3">&quot;on&quot; </span><span class="s2">+ capitalizedEvent$jscomp$inline_1625</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s2">registerSimpleEvent(ANIMATION_END, </span><span class="s3">&quot;onAnimationEnd&quot;</span><span class="s2">);</span>
<span class="s2">registerSimpleEvent(ANIMATION_ITERATION, </span><span class="s3">&quot;onAnimationIteration&quot;</span><span class="s2">);</span>
<span class="s2">registerSimpleEvent(ANIMATION_START, </span><span class="s3">&quot;onAnimationStart&quot;</span><span class="s2">);</span>
<span class="s2">registerSimpleEvent(</span><span class="s3">&quot;dblclick&quot;</span><span class="s2">, </span><span class="s3">&quot;onDoubleClick&quot;</span><span class="s2">);</span>
<span class="s2">registerSimpleEvent(</span><span class="s3">&quot;focusin&quot;</span><span class="s2">, </span><span class="s3">&quot;onFocus&quot;</span><span class="s2">);</span>
<span class="s2">registerSimpleEvent(</span><span class="s3">&quot;focusout&quot;</span><span class="s2">, </span><span class="s3">&quot;onBlur&quot;</span><span class="s2">);</span>
<span class="s2">registerSimpleEvent(TRANSITION_RUN, </span><span class="s3">&quot;onTransitionRun&quot;</span><span class="s2">);</span>
<span class="s2">registerSimpleEvent(TRANSITION_START, </span><span class="s3">&quot;onTransitionStart&quot;</span><span class="s2">);</span>
<span class="s2">registerSimpleEvent(TRANSITION_CANCEL, </span><span class="s3">&quot;onTransitionCancel&quot;</span><span class="s2">);</span>
<span class="s2">registerSimpleEvent(TRANSITION_END, </span><span class="s3">&quot;onTransitionEnd&quot;</span><span class="s2">);</span>
<span class="s2">registerDirectEvent(</span><span class="s3">&quot;onMouseEnter&quot;</span><span class="s2">, [</span><span class="s3">&quot;mouseout&quot;</span><span class="s2">, </span><span class="s3">&quot;mouseover&quot;</span><span class="s2">]);</span>
<span class="s2">registerDirectEvent(</span><span class="s3">&quot;onMouseLeave&quot;</span><span class="s2">, [</span><span class="s3">&quot;mouseout&quot;</span><span class="s2">, </span><span class="s3">&quot;mouseover&quot;</span><span class="s2">]);</span>
<span class="s2">registerDirectEvent(</span><span class="s3">&quot;onPointerEnter&quot;</span><span class="s2">, [</span><span class="s3">&quot;pointerout&quot;</span><span class="s2">, </span><span class="s3">&quot;pointerover&quot;</span><span class="s2">]);</span>
<span class="s2">registerDirectEvent(</span><span class="s3">&quot;onPointerLeave&quot;</span><span class="s2">, [</span><span class="s3">&quot;pointerout&quot;</span><span class="s2">, </span><span class="s3">&quot;pointerover&quot;</span><span class="s2">]);</span>
<span class="s2">registerTwoPhaseEvent(</span>
  <span class="s3">&quot;onChange&quot;</span><span class="s2">,</span>
  <span class="s3">&quot;change click focusin focusout input keydown keyup selectionchange&quot;</span><span class="s2">.split(</span><span class="s3">&quot; &quot;</span><span class="s2">)</span>
<span class="s2">);</span>
<span class="s2">registerTwoPhaseEvent(</span>
  <span class="s3">&quot;onSelect&quot;</span><span class="s2">,</span>
  <span class="s3">&quot;focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange&quot;</span><span class="s2">.split(</span>
    <span class="s3">&quot; &quot;</span>
  <span class="s2">)</span>
<span class="s2">);</span>
<span class="s2">registerTwoPhaseEvent(</span><span class="s3">&quot;onBeforeInput&quot;</span><span class="s2">, [</span>
  <span class="s3">&quot;compositionend&quot;</span><span class="s2">,</span>
  <span class="s3">&quot;keypress&quot;</span><span class="s2">,</span>
  <span class="s3">&quot;textInput&quot;</span><span class="s2">,</span>
  <span class="s3">&quot;paste&quot;</span>
<span class="s2">]);</span>
<span class="s2">registerTwoPhaseEvent(</span>
  <span class="s3">&quot;onCompositionEnd&quot;</span><span class="s2">,</span>
  <span class="s3">&quot;compositionend focusout keydown keypress keyup mousedown&quot;</span><span class="s2">.split(</span><span class="s3">&quot; &quot;</span><span class="s2">)</span>
<span class="s2">);</span>
<span class="s2">registerTwoPhaseEvent(</span>
  <span class="s3">&quot;onCompositionStart&quot;</span><span class="s2">,</span>
  <span class="s3">&quot;compositionstart focusout keydown keypress keyup mousedown&quot;</span><span class="s2">.split(</span><span class="s3">&quot; &quot;</span><span class="s2">)</span>
<span class="s2">);</span>
<span class="s2">registerTwoPhaseEvent(</span>
  <span class="s3">&quot;onCompositionUpdate&quot;</span><span class="s2">,</span>
  <span class="s3">&quot;compositionupdate focusout keydown keypress keyup mousedown&quot;</span><span class="s2">.split(</span><span class="s3">&quot; &quot;</span><span class="s2">)</span>
<span class="s2">);</span>
<span class="s4">var </span><span class="s2">mediaEventTypes =</span>
    <span class="s3">&quot;abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting&quot;</span><span class="s2">.split(</span>
      <span class="s3">&quot; &quot;</span>
    <span class="s2">),</span>
  <span class="s2">nonDelegatedEvents = </span><span class="s4">new </span><span class="s2">Set(</span>
    <span class="s3">&quot;beforetoggle cancel close invalid load scroll scrollend toggle&quot;</span>
      <span class="s2">.split(</span><span class="s3">&quot; &quot;</span><span class="s2">)</span>
      <span class="s2">.concat(mediaEventTypes)</span>
  <span class="s2">);</span>
<span class="s4">function </span><span class="s2">processDispatchQueue(dispatchQueue, eventSystemFlags) {</span>
  <span class="s2">eventSystemFlags = </span><span class="s5">0 </span><span class="s2">!== (eventSystemFlags &amp; </span><span class="s5">4</span><span class="s2">);</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; dispatchQueue.length; i++) {</span>
    <span class="s4">var </span><span class="s2">_dispatchQueue$i = dispatchQueue[i],</span>
      <span class="s2">event = _dispatchQueue$i.event;</span>
    <span class="s2">_dispatchQueue$i = _dispatchQueue$i.listeners;</span>
    <span class="s2">a: {</span>
      <span class="s4">var </span><span class="s2">previousInstance = </span><span class="s4">void </span><span class="s5">0</span><span class="s2">;</span>
      <span class="s4">if </span><span class="s2">(eventSystemFlags)</span>
        <span class="s4">for </span><span class="s2">(</span>
          <span class="s4">var </span><span class="s2">i$jscomp$0 = _dispatchQueue$i.length - </span><span class="s5">1</span><span class="s2">;</span>
          <span class="s5">0 </span><span class="s2">&lt;= i$jscomp$0;</span>
          <span class="s2">i$jscomp$0--</span>
        <span class="s2">) {</span>
          <span class="s4">var </span><span class="s2">_dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],</span>
            <span class="s2">instance = _dispatchListeners$i.instance,</span>
            <span class="s2">currentTarget = _dispatchListeners$i.currentTarget;</span>
          <span class="s2">_dispatchListeners$i = _dispatchListeners$i.listener;</span>
          <span class="s4">if </span><span class="s2">(instance !== previousInstance &amp;&amp; event.isPropagationStopped())</span>
            <span class="s4">break </span><span class="s2">a;</span>
          <span class="s2">previousInstance = _dispatchListeners$i;</span>
          <span class="s2">event.currentTarget = currentTarget;</span>
          <span class="s4">try </span><span class="s2">{</span>
            <span class="s2">previousInstance(event);</span>
          <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
            <span class="s2">reportGlobalError(error);</span>
          <span class="s2">}</span>
          <span class="s2">event.currentTarget = </span><span class="s4">null</span><span class="s2">;</span>
          <span class="s2">previousInstance = instance;</span>
        <span class="s2">}</span>
      <span class="s4">else</span>
        <span class="s4">for </span><span class="s2">(</span>
          <span class="s2">i$jscomp$0 = </span><span class="s5">0</span><span class="s2">;</span>
          <span class="s2">i$jscomp$0 &lt; _dispatchQueue$i.length;</span>
          <span class="s2">i$jscomp$0++</span>
        <span class="s2">) {</span>
          <span class="s2">_dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];</span>
          <span class="s2">instance = _dispatchListeners$i.instance;</span>
          <span class="s2">currentTarget = _dispatchListeners$i.currentTarget;</span>
          <span class="s2">_dispatchListeners$i = _dispatchListeners$i.listener;</span>
          <span class="s4">if </span><span class="s2">(instance !== previousInstance &amp;&amp; event.isPropagationStopped())</span>
            <span class="s4">break </span><span class="s2">a;</span>
          <span class="s2">previousInstance = _dispatchListeners$i;</span>
          <span class="s2">event.currentTarget = currentTarget;</span>
          <span class="s4">try </span><span class="s2">{</span>
            <span class="s2">previousInstance(event);</span>
          <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
            <span class="s2">reportGlobalError(error);</span>
          <span class="s2">}</span>
          <span class="s2">event.currentTarget = </span><span class="s4">null</span><span class="s2">;</span>
          <span class="s2">previousInstance = instance;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">listenToNonDelegatedEvent(domEventName, targetElement) {</span>
  <span class="s4">var </span><span class="s2">JSCompiler_inline_result = targetElement[internalEventHandlersKey];</span>
  <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== JSCompiler_inline_result &amp;&amp;</span>
    <span class="s2">(JSCompiler_inline_result = targetElement[internalEventHandlersKey] =</span>
      <span class="s4">new </span><span class="s2">Set());</span>
  <span class="s4">var </span><span class="s2">listenerSetKey = domEventName + </span><span class="s3">&quot;__bubble&quot;</span><span class="s2">;</span>
  <span class="s2">JSCompiler_inline_result.has(listenerSetKey) ||</span>
    <span class="s2">(addTrappedEventListener(targetElement, domEventName, </span><span class="s5">2</span><span class="s2">, !</span><span class="s5">1</span><span class="s2">),</span>
    <span class="s2">JSCompiler_inline_result.add(listenerSetKey));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">listenToNativeEvent(domEventName, isCapturePhaseListener, target) {</span>
  <span class="s4">var </span><span class="s2">eventSystemFlags = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">isCapturePhaseListener &amp;&amp; (eventSystemFlags |= </span><span class="s5">4</span><span class="s2">);</span>
  <span class="s2">addTrappedEventListener(</span>
    <span class="s2">target,</span>
    <span class="s2">domEventName,</span>
    <span class="s2">eventSystemFlags,</span>
    <span class="s2">isCapturePhaseListener</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">listeningMarker = </span><span class="s3">&quot;_reactListening&quot; </span><span class="s2">+ Math.random().toString(</span><span class="s5">36</span><span class="s2">).slice(</span><span class="s5">2</span><span class="s2">);</span>
<span class="s4">function </span><span class="s2">listenToAllSupportedEvents(rootContainerElement) {</span>
  <span class="s4">if </span><span class="s2">(!rootContainerElement[listeningMarker]) {</span>
    <span class="s2">rootContainerElement[listeningMarker] = !</span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">allNativeEvents.forEach(</span><span class="s4">function </span><span class="s2">(domEventName) {</span>
      <span class="s3">&quot;selectionchange&quot; </span><span class="s2">!== domEventName &amp;&amp;</span>
        <span class="s2">(nonDelegatedEvents.has(domEventName) ||</span>
          <span class="s2">listenToNativeEvent(domEventName, !</span><span class="s5">1</span><span class="s2">, rootContainerElement),</span>
        <span class="s2">listenToNativeEvent(domEventName, !</span><span class="s5">0</span><span class="s2">, rootContainerElement));</span>
    <span class="s2">});</span>
    <span class="s4">var </span><span class="s2">ownerDocument =</span>
      <span class="s5">9 </span><span class="s2">=== rootContainerElement.nodeType</span>
        <span class="s2">? rootContainerElement</span>
        <span class="s2">: rootContainerElement.ownerDocument;</span>
    <span class="s4">null </span><span class="s2">=== ownerDocument ||</span>
      <span class="s2">ownerDocument[listeningMarker] ||</span>
      <span class="s2">((ownerDocument[listeningMarker] = !</span><span class="s5">0</span><span class="s2">),</span>
      <span class="s2">listenToNativeEvent(</span><span class="s3">&quot;selectionchange&quot;</span><span class="s2">, !</span><span class="s5">1</span><span class="s2">, ownerDocument));</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">addTrappedEventListener(</span>
  <span class="s2">targetContainer,</span>
  <span class="s2">domEventName,</span>
  <span class="s2">eventSystemFlags,</span>
  <span class="s2">isCapturePhaseListener</span>
<span class="s2">) {</span>
  <span class="s4">switch </span><span class="s2">(getEventPriority(domEventName)) {</span>
    <span class="s4">case </span><span class="s5">2</span><span class="s2">:</span>
      <span class="s4">var </span><span class="s2">listenerWrapper = dispatchDiscreteEvent;</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">8</span><span class="s2">:</span>
      <span class="s2">listenerWrapper = dispatchContinuousEvent;</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s2">listenerWrapper = dispatchEvent;</span>
  <span class="s2">}</span>
  <span class="s2">eventSystemFlags = listenerWrapper.bind(</span>
    <span class="s4">null</span><span class="s2">,</span>
    <span class="s2">domEventName,</span>
    <span class="s2">eventSystemFlags,</span>
    <span class="s2">targetContainer</span>
  <span class="s2">);</span>
  <span class="s2">listenerWrapper = </span><span class="s4">void </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">!passiveBrowserEventsSupported ||</span>
    <span class="s2">(</span><span class="s3">&quot;touchstart&quot; </span><span class="s2">!== domEventName &amp;&amp;</span>
      <span class="s3">&quot;touchmove&quot; </span><span class="s2">!== domEventName &amp;&amp;</span>
      <span class="s3">&quot;wheel&quot; </span><span class="s2">!== domEventName) ||</span>
    <span class="s2">(listenerWrapper = !</span><span class="s5">0</span><span class="s2">);</span>
  <span class="s2">isCapturePhaseListener</span>
    <span class="s2">? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== listenerWrapper</span>
      <span class="s2">? targetContainer.addEventListener(domEventName, eventSystemFlags, {</span>
          <span class="s2">capture: !</span><span class="s5">0</span><span class="s2">,</span>
          <span class="s2">passive: listenerWrapper</span>
        <span class="s2">})</span>
      <span class="s2">: targetContainer.addEventListener(domEventName, eventSystemFlags, !</span><span class="s5">0</span><span class="s2">)</span>
    <span class="s2">: </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== listenerWrapper</span>
      <span class="s2">? targetContainer.addEventListener(domEventName, eventSystemFlags, {</span>
          <span class="s2">passive: listenerWrapper</span>
        <span class="s2">})</span>
      <span class="s2">: targetContainer.addEventListener(domEventName, eventSystemFlags, !</span><span class="s5">1</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">dispatchEventForPluginEventSystem(</span>
  <span class="s2">domEventName,</span>
  <span class="s2">eventSystemFlags,</span>
  <span class="s2">nativeEvent,</span>
  <span class="s2">targetInst$jscomp$0,</span>
  <span class="s2">targetContainer</span>
<span class="s2">) {</span>
  <span class="s4">var </span><span class="s2">ancestorInst = targetInst$jscomp$0;</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s5">0 </span><span class="s2">=== (eventSystemFlags &amp; </span><span class="s5">1</span><span class="s2">) &amp;&amp;</span>
    <span class="s5">0 </span><span class="s2">=== (eventSystemFlags &amp; </span><span class="s5">2</span><span class="s2">) &amp;&amp;</span>
    <span class="s4">null </span><span class="s2">!== targetInst$jscomp$0</span>
  <span class="s2">)</span>
    <span class="s2">a: </span><span class="s4">for </span><span class="s2">(;;) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== targetInst$jscomp$0) </span><span class="s4">return</span><span class="s2">;</span>
      <span class="s4">var </span><span class="s2">nodeTag = targetInst$jscomp$0.tag;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s5">3 </span><span class="s2">=== nodeTag || </span><span class="s5">4 </span><span class="s2">=== nodeTag) {</span>
        <span class="s4">var </span><span class="s2">container = targetInst$jscomp$0.stateNode.containerInfo;</span>
        <span class="s4">if </span><span class="s2">(container === targetContainer) </span><span class="s4">break</span><span class="s2">;</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s5">4 </span><span class="s2">=== nodeTag)</span>
          <span class="s4">for </span><span class="s2">(nodeTag = targetInst$jscomp$0.return; </span><span class="s4">null </span><span class="s2">!== nodeTag; ) {</span>
            <span class="s4">var </span><span class="s2">grandTag = nodeTag.tag;</span>
            <span class="s4">if </span><span class="s2">(</span>
              <span class="s2">(</span><span class="s5">3 </span><span class="s2">=== grandTag || </span><span class="s5">4 </span><span class="s2">=== grandTag) &amp;&amp;</span>
              <span class="s2">nodeTag.stateNode.containerInfo === targetContainer</span>
            <span class="s2">)</span>
              <span class="s4">return</span><span class="s2">;</span>
            <span class="s2">nodeTag = nodeTag.return;</span>
          <span class="s2">}</span>
        <span class="s4">for </span><span class="s2">(; </span><span class="s4">null </span><span class="s2">!== container; ) {</span>
          <span class="s2">nodeTag = getClosestInstanceFromNode(container);</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== nodeTag) </span><span class="s4">return</span><span class="s2">;</span>
          <span class="s2">grandTag = nodeTag.tag;</span>
          <span class="s4">if </span><span class="s2">(</span>
            <span class="s5">5 </span><span class="s2">=== grandTag ||</span>
            <span class="s5">6 </span><span class="s2">=== grandTag ||</span>
            <span class="s5">26 </span><span class="s2">=== grandTag ||</span>
            <span class="s5">27 </span><span class="s2">=== grandTag</span>
          <span class="s2">) {</span>
            <span class="s2">targetInst$jscomp$0 = ancestorInst = nodeTag;</span>
            <span class="s4">continue </span><span class="s2">a;</span>
          <span class="s2">}</span>
          <span class="s2">container = container.parentNode;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s2">targetInst$jscomp$0 = targetInst$jscomp$0.return;</span>
    <span class="s2">}</span>
  <span class="s2">batchedUpdates$2(</span><span class="s4">function </span><span class="s2">() {</span>
    <span class="s4">var </span><span class="s2">targetInst = ancestorInst,</span>
      <span class="s2">nativeEventTarget = getEventTarget(nativeEvent),</span>
      <span class="s2">dispatchQueue = [];</span>
    <span class="s2">a: {</span>
      <span class="s4">var </span><span class="s2">reactName = topLevelEventsToReactNames.get(domEventName);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== reactName) {</span>
        <span class="s4">var </span><span class="s2">SyntheticEventCtor = SyntheticEvent,</span>
          <span class="s2">reactEventType = domEventName;</span>
        <span class="s4">switch </span><span class="s2">(domEventName) {</span>
          <span class="s4">case </span><span class="s3">&quot;keypress&quot;</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== getEventCharCode(nativeEvent)) </span><span class="s4">break </span><span class="s2">a;</span>
          <span class="s4">case </span><span class="s3">&quot;keydown&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;keyup&quot;</span><span class="s2">:</span>
            <span class="s2">SyntheticEventCtor = SyntheticKeyboardEvent;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s3">&quot;focusin&quot;</span><span class="s2">:</span>
            <span class="s2">reactEventType = </span><span class="s3">&quot;focus&quot;</span><span class="s2">;</span>
            <span class="s2">SyntheticEventCtor = SyntheticFocusEvent;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s3">&quot;focusout&quot;</span><span class="s2">:</span>
            <span class="s2">reactEventType = </span><span class="s3">&quot;blur&quot;</span><span class="s2">;</span>
            <span class="s2">SyntheticEventCtor = SyntheticFocusEvent;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s3">&quot;beforeblur&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;afterblur&quot;</span><span class="s2">:</span>
            <span class="s2">SyntheticEventCtor = SyntheticFocusEvent;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s3">&quot;click&quot;</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s5">2 </span><span class="s2">=== nativeEvent.button) </span><span class="s4">break </span><span class="s2">a;</span>
          <span class="s4">case </span><span class="s3">&quot;auxclick&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;dblclick&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;mousedown&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;mousemove&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;mouseup&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;mouseout&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;mouseover&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;contextmenu&quot;</span><span class="s2">:</span>
            <span class="s2">SyntheticEventCtor = SyntheticMouseEvent;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s3">&quot;drag&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;dragend&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;dragenter&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;dragexit&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;dragleave&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;dragover&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;dragstart&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;drop&quot;</span><span class="s2">:</span>
            <span class="s2">SyntheticEventCtor = SyntheticDragEvent;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s3">&quot;touchcancel&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;touchend&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;touchmove&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;touchstart&quot;</span><span class="s2">:</span>
            <span class="s2">SyntheticEventCtor = SyntheticTouchEvent;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s2">ANIMATION_END:</span>
          <span class="s4">case </span><span class="s2">ANIMATION_ITERATION:</span>
          <span class="s4">case </span><span class="s2">ANIMATION_START:</span>
            <span class="s2">SyntheticEventCtor = SyntheticAnimationEvent;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s2">TRANSITION_END:</span>
            <span class="s2">SyntheticEventCtor = SyntheticTransitionEvent;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s3">&quot;scroll&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;scrollend&quot;</span><span class="s2">:</span>
            <span class="s2">SyntheticEventCtor = SyntheticUIEvent;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s3">&quot;wheel&quot;</span><span class="s2">:</span>
            <span class="s2">SyntheticEventCtor = SyntheticWheelEvent;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s3">&quot;copy&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;cut&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;paste&quot;</span><span class="s2">:</span>
            <span class="s2">SyntheticEventCtor = SyntheticClipboardEvent;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s3">&quot;gotpointercapture&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;lostpointercapture&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;pointercancel&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;pointerdown&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;pointermove&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;pointerout&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;pointerover&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;pointerup&quot;</span><span class="s2">:</span>
            <span class="s2">SyntheticEventCtor = SyntheticPointerEvent;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s3">&quot;toggle&quot;</span><span class="s2">:</span>
          <span class="s4">case </span><span class="s3">&quot;beforetoggle&quot;</span><span class="s2">:</span>
            <span class="s2">SyntheticEventCtor = SyntheticToggleEvent;</span>
        <span class="s2">}</span>
        <span class="s4">var </span><span class="s2">inCapturePhase = </span><span class="s5">0 </span><span class="s2">!== (eventSystemFlags &amp; </span><span class="s5">4</span><span class="s2">),</span>
          <span class="s2">accumulateTargetOnly =</span>
            <span class="s2">!inCapturePhase &amp;&amp;</span>
            <span class="s2">(</span><span class="s3">&quot;scroll&quot; </span><span class="s2">=== domEventName || </span><span class="s3">&quot;scrollend&quot; </span><span class="s2">=== domEventName),</span>
          <span class="s2">reactEventName = inCapturePhase</span>
            <span class="s2">? </span><span class="s4">null </span><span class="s2">!== reactName</span>
              <span class="s2">? reactName + </span><span class="s3">&quot;Capture&quot;</span>
              <span class="s2">: </span><span class="s4">null</span>
            <span class="s2">: reactName;</span>
        <span class="s2">inCapturePhase = [];</span>
        <span class="s4">for </span><span class="s2">(</span>
          <span class="s4">var </span><span class="s2">instance = targetInst, lastHostComponent;</span>
          <span class="s4">null </span><span class="s2">!== instance;</span>

        <span class="s2">) {</span>
          <span class="s4">var </span><span class="s2">_instance = instance;</span>
          <span class="s2">lastHostComponent = _instance.stateNode;</span>
          <span class="s2">_instance = _instance.tag;</span>
          <span class="s2">(</span><span class="s5">5 </span><span class="s2">!== _instance &amp;&amp; </span><span class="s5">26 </span><span class="s2">!== _instance &amp;&amp; </span><span class="s5">27 </span><span class="s2">!== _instance) ||</span>
            <span class="s4">null </span><span class="s2">=== lastHostComponent ||</span>
            <span class="s4">null </span><span class="s2">=== reactEventName ||</span>
            <span class="s2">((_instance = getListener(instance, reactEventName)),</span>
            <span class="s4">null </span><span class="s2">!= _instance &amp;&amp;</span>
              <span class="s2">inCapturePhase.push(</span>
                <span class="s2">createDispatchListener(instance, _instance, lastHostComponent)</span>
              <span class="s2">));</span>
          <span class="s4">if </span><span class="s2">(accumulateTargetOnly) </span><span class="s4">break</span><span class="s2">;</span>
          <span class="s2">instance = instance.return;</span>
        <span class="s2">}</span>
        <span class="s5">0 </span><span class="s2">&lt; inCapturePhase.length &amp;&amp;</span>
          <span class="s2">((reactName = </span><span class="s4">new </span><span class="s2">SyntheticEventCtor(</span>
            <span class="s2">reactName,</span>
            <span class="s2">reactEventType,</span>
            <span class="s4">null</span><span class="s2">,</span>
            <span class="s2">nativeEvent,</span>
            <span class="s2">nativeEventTarget</span>
          <span class="s2">)),</span>
          <span class="s2">dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== (eventSystemFlags &amp; </span><span class="s5">7</span><span class="s2">)) {</span>
      <span class="s2">a: {</span>
        <span class="s2">reactName =</span>
          <span class="s3">&quot;mouseover&quot; </span><span class="s2">=== domEventName || </span><span class="s3">&quot;pointerover&quot; </span><span class="s2">=== domEventName;</span>
        <span class="s2">SyntheticEventCtor =</span>
          <span class="s3">&quot;mouseout&quot; </span><span class="s2">=== domEventName || </span><span class="s3">&quot;pointerout&quot; </span><span class="s2">=== domEventName;</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">reactName &amp;&amp;</span>
          <span class="s2">nativeEvent !== currentReplayingEvent &amp;&amp;</span>
          <span class="s2">(reactEventType =</span>
            <span class="s2">nativeEvent.relatedTarget || nativeEvent.fromElement) &amp;&amp;</span>
          <span class="s2">(getClosestInstanceFromNode(reactEventType) ||</span>
            <span class="s2">reactEventType[internalContainerInstanceKey])</span>
        <span class="s2">)</span>
          <span class="s4">break </span><span class="s2">a;</span>
        <span class="s4">if </span><span class="s2">(SyntheticEventCtor || reactName) {</span>
          <span class="s2">reactName =</span>
            <span class="s2">nativeEventTarget.window === nativeEventTarget</span>
              <span class="s2">? nativeEventTarget</span>
              <span class="s2">: (reactName = nativeEventTarget.ownerDocument)</span>
                <span class="s2">? reactName.defaultView || reactName.parentWindow</span>
                <span class="s2">: window;</span>
          <span class="s4">if </span><span class="s2">(SyntheticEventCtor) {</span>
            <span class="s4">if </span><span class="s2">(</span>
              <span class="s2">((reactEventType =</span>
                <span class="s2">nativeEvent.relatedTarget || nativeEvent.toElement),</span>
              <span class="s2">(SyntheticEventCtor = targetInst),</span>
              <span class="s2">(reactEventType = reactEventType</span>
                <span class="s2">? getClosestInstanceFromNode(reactEventType)</span>
                <span class="s2">: </span><span class="s4">null</span><span class="s2">),</span>
              <span class="s4">null </span><span class="s2">!== reactEventType &amp;&amp;</span>
                <span class="s2">((accumulateTargetOnly =</span>
                  <span class="s2">getNearestMountedFiber(reactEventType)),</span>
                <span class="s2">(inCapturePhase = reactEventType.tag),</span>
                <span class="s2">reactEventType !== accumulateTargetOnly ||</span>
                  <span class="s2">(</span><span class="s5">5 </span><span class="s2">!== inCapturePhase &amp;&amp;</span>
                    <span class="s5">27 </span><span class="s2">!== inCapturePhase &amp;&amp;</span>
                    <span class="s5">6 </span><span class="s2">!== inCapturePhase)))</span>
            <span class="s2">)</span>
              <span class="s2">reactEventType = </span><span class="s4">null</span><span class="s2">;</span>
          <span class="s2">} </span><span class="s4">else </span><span class="s2">(SyntheticEventCtor = </span><span class="s4">null</span><span class="s2">), (reactEventType = targetInst);</span>
          <span class="s4">if </span><span class="s2">(SyntheticEventCtor !== reactEventType) {</span>
            <span class="s2">inCapturePhase = SyntheticMouseEvent;</span>
            <span class="s2">_instance = </span><span class="s3">&quot;onMouseLeave&quot;</span><span class="s2">;</span>
            <span class="s2">reactEventName = </span><span class="s3">&quot;onMouseEnter&quot;</span><span class="s2">;</span>
            <span class="s2">instance = </span><span class="s3">&quot;mouse&quot;</span><span class="s2">;</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;pointerout&quot; </span><span class="s2">=== domEventName || </span><span class="s3">&quot;pointerover&quot; </span><span class="s2">=== domEventName)</span>
              <span class="s2">(inCapturePhase = SyntheticPointerEvent),</span>
                <span class="s2">(_instance = </span><span class="s3">&quot;onPointerLeave&quot;</span><span class="s2">),</span>
                <span class="s2">(reactEventName = </span><span class="s3">&quot;onPointerEnter&quot;</span><span class="s2">),</span>
                <span class="s2">(instance = </span><span class="s3">&quot;pointer&quot;</span><span class="s2">);</span>
            <span class="s2">accumulateTargetOnly =</span>
              <span class="s4">null </span><span class="s2">== SyntheticEventCtor</span>
                <span class="s2">? reactName</span>
                <span class="s2">: getNodeFromInstance(SyntheticEventCtor);</span>
            <span class="s2">lastHostComponent =</span>
              <span class="s4">null </span><span class="s2">== reactEventType</span>
                <span class="s2">? reactName</span>
                <span class="s2">: getNodeFromInstance(reactEventType);</span>
            <span class="s2">reactName = </span><span class="s4">new </span><span class="s2">inCapturePhase(</span>
              <span class="s2">_instance,</span>
              <span class="s2">instance + </span><span class="s3">&quot;leave&quot;</span><span class="s2">,</span>
              <span class="s2">SyntheticEventCtor,</span>
              <span class="s2">nativeEvent,</span>
              <span class="s2">nativeEventTarget</span>
            <span class="s2">);</span>
            <span class="s2">reactName.target = accumulateTargetOnly;</span>
            <span class="s2">reactName.relatedTarget = lastHostComponent;</span>
            <span class="s2">_instance = </span><span class="s4">null</span><span class="s2">;</span>
            <span class="s2">getClosestInstanceFromNode(nativeEventTarget) === targetInst &amp;&amp;</span>
              <span class="s2">((inCapturePhase = </span><span class="s4">new </span><span class="s2">inCapturePhase(</span>
                <span class="s2">reactEventName,</span>
                <span class="s2">instance + </span><span class="s3">&quot;enter&quot;</span><span class="s2">,</span>
                <span class="s2">reactEventType,</span>
                <span class="s2">nativeEvent,</span>
                <span class="s2">nativeEventTarget</span>
              <span class="s2">)),</span>
              <span class="s2">(inCapturePhase.target = lastHostComponent),</span>
              <span class="s2">(inCapturePhase.relatedTarget = accumulateTargetOnly),</span>
              <span class="s2">(_instance = inCapturePhase));</span>
            <span class="s2">accumulateTargetOnly = _instance;</span>
            <span class="s4">if </span><span class="s2">(SyntheticEventCtor &amp;&amp; reactEventType)</span>
              <span class="s2">b: {</span>
                <span class="s2">inCapturePhase = SyntheticEventCtor;</span>
                <span class="s2">reactEventName = reactEventType;</span>
                <span class="s2">instance = </span><span class="s5">0</span><span class="s2">;</span>
                <span class="s4">for </span><span class="s2">(</span>
                  <span class="s2">lastHostComponent = inCapturePhase;</span>
                  <span class="s2">lastHostComponent;</span>
                  <span class="s2">lastHostComponent = getParent(lastHostComponent)</span>
                <span class="s2">)</span>
                  <span class="s2">instance++;</span>
                <span class="s2">lastHostComponent = </span><span class="s5">0</span><span class="s2">;</span>
                <span class="s4">for </span><span class="s2">(</span>
                  <span class="s2">_instance = reactEventName;</span>
                  <span class="s2">_instance;</span>
                  <span class="s2">_instance = getParent(_instance)</span>
                <span class="s2">)</span>
                  <span class="s2">lastHostComponent++;</span>
                <span class="s4">for </span><span class="s2">(; </span><span class="s5">0 </span><span class="s2">&lt; instance - lastHostComponent; )</span>
                  <span class="s2">(inCapturePhase = getParent(inCapturePhase)), instance--;</span>
                <span class="s4">for </span><span class="s2">(; </span><span class="s5">0 </span><span class="s2">&lt; lastHostComponent - instance; )</span>
                  <span class="s2">(reactEventName = getParent(reactEventName)),</span>
                    <span class="s2">lastHostComponent--;</span>
                <span class="s4">for </span><span class="s2">(; instance--; ) {</span>
                  <span class="s4">if </span><span class="s2">(</span>
                    <span class="s2">inCapturePhase === reactEventName ||</span>
                    <span class="s2">(</span><span class="s4">null </span><span class="s2">!== reactEventName &amp;&amp;</span>
                      <span class="s2">inCapturePhase === reactEventName.alternate)</span>
                  <span class="s2">)</span>
                    <span class="s4">break </span><span class="s2">b;</span>
                  <span class="s2">inCapturePhase = getParent(inCapturePhase);</span>
                  <span class="s2">reactEventName = getParent(reactEventName);</span>
                <span class="s2">}</span>
                <span class="s2">inCapturePhase = </span><span class="s4">null</span><span class="s2">;</span>
              <span class="s2">}</span>
            <span class="s4">else </span><span class="s2">inCapturePhase = </span><span class="s4">null</span><span class="s2">;</span>
            <span class="s4">null </span><span class="s2">!== SyntheticEventCtor &amp;&amp;</span>
              <span class="s2">accumulateEnterLeaveListenersForEvent(</span>
                <span class="s2">dispatchQueue,</span>
                <span class="s2">reactName,</span>
                <span class="s2">SyntheticEventCtor,</span>
                <span class="s2">inCapturePhase,</span>
                <span class="s2">!</span><span class="s5">1</span>
              <span class="s2">);</span>
            <span class="s4">null </span><span class="s2">!== reactEventType &amp;&amp;</span>
              <span class="s4">null </span><span class="s2">!== accumulateTargetOnly &amp;&amp;</span>
              <span class="s2">accumulateEnterLeaveListenersForEvent(</span>
                <span class="s2">dispatchQueue,</span>
                <span class="s2">accumulateTargetOnly,</span>
                <span class="s2">reactEventType,</span>
                <span class="s2">inCapturePhase,</span>
                <span class="s2">!</span><span class="s5">0</span>
              <span class="s2">);</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s2">a: {</span>
        <span class="s2">reactName = targetInst ? getNodeFromInstance(targetInst) : window;</span>
        <span class="s2">SyntheticEventCtor =</span>
          <span class="s2">reactName.nodeName &amp;&amp; reactName.nodeName.toLowerCase();</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s3">&quot;select&quot; </span><span class="s2">=== SyntheticEventCtor ||</span>
          <span class="s2">(</span><span class="s3">&quot;input&quot; </span><span class="s2">=== SyntheticEventCtor &amp;&amp; </span><span class="s3">&quot;file&quot; </span><span class="s2">=== reactName.type)</span>
        <span class="s2">)</span>
          <span class="s4">var </span><span class="s2">getTargetInstFunc = getTargetInstForChangeEvent;</span>
        <span class="s4">else if </span><span class="s2">(isTextInputElement(reactName))</span>
          <span class="s4">if </span><span class="s2">(isInputEventSupported)</span>
            <span class="s2">getTargetInstFunc = getTargetInstForInputOrChangeEvent;</span>
          <span class="s4">else </span><span class="s2">{</span>
            <span class="s2">getTargetInstFunc = getTargetInstForInputEventPolyfill;</span>
            <span class="s4">var </span><span class="s2">handleEventFunc = handleEventsForInputEventPolyfill;</span>
          <span class="s2">}</span>
        <span class="s4">else</span>
          <span class="s2">(SyntheticEventCtor = reactName.nodeName),</span>
            <span class="s2">!SyntheticEventCtor ||</span>
            <span class="s3">&quot;input&quot; </span><span class="s2">!== SyntheticEventCtor.toLowerCase() ||</span>
            <span class="s2">(</span><span class="s3">&quot;checkbox&quot; </span><span class="s2">!== reactName.type &amp;&amp; </span><span class="s3">&quot;radio&quot; </span><span class="s2">!== reactName.type)</span>
              <span class="s2">? targetInst &amp;&amp;</span>
                <span class="s2">isCustomElement(targetInst.elementType) &amp;&amp;</span>
                <span class="s2">(getTargetInstFunc = getTargetInstForChangeEvent)</span>
              <span class="s2">: (getTargetInstFunc = getTargetInstForClickEvent);</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">getTargetInstFunc &amp;&amp;</span>
          <span class="s2">(getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))</span>
        <span class="s2">) {</span>
          <span class="s2">createAndAccumulateChangeEvent(</span>
            <span class="s2">dispatchQueue,</span>
            <span class="s2">getTargetInstFunc,</span>
            <span class="s2">nativeEvent,</span>
            <span class="s2">nativeEventTarget</span>
          <span class="s2">);</span>
          <span class="s4">break </span><span class="s2">a;</span>
        <span class="s2">}</span>
        <span class="s2">handleEventFunc &amp;&amp; handleEventFunc(domEventName, reactName, targetInst);</span>
        <span class="s3">&quot;focusout&quot; </span><span class="s2">=== domEventName &amp;&amp;</span>
          <span class="s2">targetInst &amp;&amp;</span>
          <span class="s3">&quot;number&quot; </span><span class="s2">=== reactName.type &amp;&amp;</span>
          <span class="s4">null </span><span class="s2">!= targetInst.memoizedProps.value &amp;&amp;</span>
          <span class="s2">setDefaultValue(reactName, </span><span class="s3">&quot;number&quot;</span><span class="s2">, reactName.value);</span>
      <span class="s2">}</span>
      <span class="s2">handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;</span>
      <span class="s4">switch </span><span class="s2">(domEventName) {</span>
        <span class="s4">case </span><span class="s3">&quot;focusin&quot;</span><span class="s2">:</span>
          <span class="s4">if </span><span class="s2">(</span>
            <span class="s2">isTextInputElement(handleEventFunc) ||</span>
            <span class="s3">&quot;true&quot; </span><span class="s2">=== handleEventFunc.contentEditable</span>
          <span class="s2">)</span>
            <span class="s2">(activeElement = handleEventFunc),</span>
              <span class="s2">(activeElementInst = targetInst),</span>
              <span class="s2">(lastSelection = </span><span class="s4">null</span><span class="s2">);</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;focusout&quot;</span><span class="s2">:</span>
          <span class="s2">lastSelection = activeElementInst = activeElement = </span><span class="s4">null</span><span class="s2">;</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;mousedown&quot;</span><span class="s2">:</span>
          <span class="s2">mouseDown = !</span><span class="s5">0</span><span class="s2">;</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;contextmenu&quot;</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s3">&quot;mouseup&quot;</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s3">&quot;dragend&quot;</span><span class="s2">:</span>
          <span class="s2">mouseDown = !</span><span class="s5">1</span><span class="s2">;</span>
          <span class="s2">constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;selectionchange&quot;</span><span class="s2">:</span>
          <span class="s4">if </span><span class="s2">(skipSelectionChangeEvent) </span><span class="s4">break</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;keydown&quot;</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s3">&quot;keyup&quot;</span><span class="s2">:</span>
          <span class="s2">constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);</span>
      <span class="s2">}</span>
      <span class="s4">var </span><span class="s2">fallbackData;</span>
      <span class="s4">if </span><span class="s2">(canUseCompositionEvent)</span>
        <span class="s2">b: {</span>
          <span class="s4">switch </span><span class="s2">(domEventName) {</span>
            <span class="s4">case </span><span class="s3">&quot;compositionstart&quot;</span><span class="s2">:</span>
              <span class="s4">var </span><span class="s2">eventType = </span><span class="s3">&quot;onCompositionStart&quot;</span><span class="s2">;</span>
              <span class="s4">break </span><span class="s2">b;</span>
            <span class="s4">case </span><span class="s3">&quot;compositionend&quot;</span><span class="s2">:</span>
              <span class="s2">eventType = </span><span class="s3">&quot;onCompositionEnd&quot;</span><span class="s2">;</span>
              <span class="s4">break </span><span class="s2">b;</span>
            <span class="s4">case </span><span class="s3">&quot;compositionupdate&quot;</span><span class="s2">:</span>
              <span class="s2">eventType = </span><span class="s3">&quot;onCompositionUpdate&quot;</span><span class="s2">;</span>
              <span class="s4">break </span><span class="s2">b;</span>
          <span class="s2">}</span>
          <span class="s2">eventType = </span><span class="s4">void </span><span class="s5">0</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s4">else</span>
        <span class="s2">isComposing</span>
          <span class="s2">? isFallbackCompositionEnd(domEventName, nativeEvent) &amp;&amp;</span>
            <span class="s2">(eventType = </span><span class="s3">&quot;onCompositionEnd&quot;</span><span class="s2">)</span>
          <span class="s2">: </span><span class="s3">&quot;keydown&quot; </span><span class="s2">=== domEventName &amp;&amp;</span>
            <span class="s5">229 </span><span class="s2">=== nativeEvent.keyCode &amp;&amp;</span>
            <span class="s2">(eventType = </span><span class="s3">&quot;onCompositionStart&quot;</span><span class="s2">);</span>
      <span class="s2">eventType &amp;&amp;</span>
        <span class="s2">(useFallbackCompositionData &amp;&amp;</span>
          <span class="s3">&quot;ko&quot; </span><span class="s2">!== nativeEvent.locale &amp;&amp;</span>
          <span class="s2">(isComposing || </span><span class="s3">&quot;onCompositionStart&quot; </span><span class="s2">!== eventType</span>
            <span class="s2">? </span><span class="s3">&quot;onCompositionEnd&quot; </span><span class="s2">=== eventType &amp;&amp;</span>
              <span class="s2">isComposing &amp;&amp;</span>
              <span class="s2">(fallbackData = getData())</span>
            <span class="s2">: ((root = nativeEventTarget),</span>
              <span class="s2">(startText = </span><span class="s3">&quot;value&quot; </span><span class="s4">in </span><span class="s2">root ? root.value : root.textContent),</span>
              <span class="s2">(isComposing = !</span><span class="s5">0</span><span class="s2">))),</span>
        <span class="s2">(handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType)),</span>
        <span class="s5">0 </span><span class="s2">&lt; handleEventFunc.length &amp;&amp;</span>
          <span class="s2">((eventType = </span><span class="s4">new </span><span class="s2">SyntheticCompositionEvent(</span>
            <span class="s2">eventType,</span>
            <span class="s2">domEventName,</span>
            <span class="s4">null</span><span class="s2">,</span>
            <span class="s2">nativeEvent,</span>
            <span class="s2">nativeEventTarget</span>
          <span class="s2">)),</span>
          <span class="s2">dispatchQueue.push({ event: eventType, listeners: handleEventFunc }),</span>
          <span class="s2">fallbackData</span>
            <span class="s2">? (eventType.data = fallbackData)</span>
            <span class="s2">: ((fallbackData = getDataFromCustomEvent(nativeEvent)),</span>
              <span class="s4">null </span><span class="s2">!== fallbackData &amp;&amp; (eventType.data = fallbackData))));</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">(fallbackData = canUseTextInputEvent</span>
          <span class="s2">? getNativeBeforeInputChars(domEventName, nativeEvent)</span>
          <span class="s2">: getFallbackBeforeInputChars(domEventName, nativeEvent))</span>
      <span class="s2">)</span>
        <span class="s2">(eventType = accumulateTwoPhaseListeners(targetInst, </span><span class="s3">&quot;onBeforeInput&quot;</span><span class="s2">)),</span>
          <span class="s5">0 </span><span class="s2">&lt; eventType.length &amp;&amp;</span>
            <span class="s2">((handleEventFunc = </span><span class="s4">new </span><span class="s2">SyntheticCompositionEvent(</span>
              <span class="s3">&quot;onBeforeInput&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;beforeinput&quot;</span><span class="s2">,</span>
              <span class="s4">null</span><span class="s2">,</span>
              <span class="s2">nativeEvent,</span>
              <span class="s2">nativeEventTarget</span>
            <span class="s2">)),</span>
            <span class="s2">dispatchQueue.push({</span>
              <span class="s2">event: handleEventFunc,</span>
              <span class="s2">listeners: eventType</span>
            <span class="s2">}),</span>
            <span class="s2">(handleEventFunc.data = fallbackData));</span>
      <span class="s2">extractEvents$1(</span>
        <span class="s2">dispatchQueue,</span>
        <span class="s2">domEventName,</span>
        <span class="s2">targetInst,</span>
        <span class="s2">nativeEvent,</span>
        <span class="s2">nativeEventTarget</span>
      <span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s2">processDispatchQueue(dispatchQueue, eventSystemFlags);</span>
  <span class="s2">});</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createDispatchListener(instance, listener, currentTarget) {</span>
  <span class="s4">return </span><span class="s2">{</span>
    <span class="s2">instance: instance,</span>
    <span class="s2">listener: listener,</span>
    <span class="s2">currentTarget: currentTarget</span>
  <span class="s2">};</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">accumulateTwoPhaseListeners(targetFiber, reactName) {</span>
  <span class="s4">for </span><span class="s2">(</span>
    <span class="s4">var </span><span class="s2">captureName = reactName + </span><span class="s3">&quot;Capture&quot;</span><span class="s2">, listeners = [];</span>
    <span class="s4">null </span><span class="s2">!== targetFiber;</span>

  <span class="s2">) {</span>
    <span class="s4">var </span><span class="s2">_instance2 = targetFiber,</span>
      <span class="s2">stateNode = _instance2.stateNode;</span>
    <span class="s2">_instance2 = _instance2.tag;</span>
    <span class="s2">(</span><span class="s5">5 </span><span class="s2">!== _instance2 &amp;&amp; </span><span class="s5">26 </span><span class="s2">!== _instance2 &amp;&amp; </span><span class="s5">27 </span><span class="s2">!== _instance2) ||</span>
      <span class="s4">null </span><span class="s2">=== stateNode ||</span>
      <span class="s2">((_instance2 = getListener(targetFiber, captureName)),</span>
      <span class="s4">null </span><span class="s2">!= _instance2 &amp;&amp;</span>
        <span class="s2">listeners.unshift(</span>
          <span class="s2">createDispatchListener(targetFiber, _instance2, stateNode)</span>
        <span class="s2">),</span>
      <span class="s2">(_instance2 = getListener(targetFiber, reactName)),</span>
      <span class="s4">null </span><span class="s2">!= _instance2 &amp;&amp;</span>
        <span class="s2">listeners.push(</span>
          <span class="s2">createDispatchListener(targetFiber, _instance2, stateNode)</span>
        <span class="s2">));</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">3 </span><span class="s2">=== targetFiber.tag) </span><span class="s4">return </span><span class="s2">listeners;</span>
    <span class="s2">targetFiber = targetFiber.return;</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">[];</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getParent(inst) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== inst) </span><span class="s4">return null</span><span class="s2">;</span>
  <span class="s4">do </span><span class="s2">inst = inst.return;</span>
  <span class="s4">while </span><span class="s2">(inst &amp;&amp; </span><span class="s5">5 </span><span class="s2">!== inst.tag &amp;&amp; </span><span class="s5">27 </span><span class="s2">!== inst.tag);</span>
  <span class="s4">return </span><span class="s2">inst ? inst : </span><span class="s4">null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">accumulateEnterLeaveListenersForEvent(</span>
  <span class="s2">dispatchQueue,</span>
  <span class="s2">event,</span>
  <span class="s2">target,</span>
  <span class="s2">common,</span>
  <span class="s2">inCapturePhase</span>
<span class="s2">) {</span>
  <span class="s4">for </span><span class="s2">(</span>
    <span class="s4">var </span><span class="s2">registrationName = event._reactName, listeners = [];</span>
    <span class="s4">null </span><span class="s2">!== target &amp;&amp; target !== common;</span>

  <span class="s2">) {</span>
    <span class="s4">var </span><span class="s2">_instance3 = target,</span>
      <span class="s2">alternate = _instance3.alternate,</span>
      <span class="s2">stateNode = _instance3.stateNode;</span>
    <span class="s2">_instance3 = _instance3.tag;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== alternate &amp;&amp; alternate === common) </span><span class="s4">break</span><span class="s2">;</span>
    <span class="s2">(</span><span class="s5">5 </span><span class="s2">!== _instance3 &amp;&amp; </span><span class="s5">26 </span><span class="s2">!== _instance3 &amp;&amp; </span><span class="s5">27 </span><span class="s2">!== _instance3) ||</span>
      <span class="s4">null </span><span class="s2">=== stateNode ||</span>
      <span class="s2">((alternate = stateNode),</span>
      <span class="s2">inCapturePhase</span>
        <span class="s2">? ((stateNode = getListener(target, registrationName)),</span>
          <span class="s4">null </span><span class="s2">!= stateNode &amp;&amp;</span>
            <span class="s2">listeners.unshift(</span>
              <span class="s2">createDispatchListener(target, stateNode, alternate)</span>
            <span class="s2">))</span>
        <span class="s2">: inCapturePhase ||</span>
          <span class="s2">((stateNode = getListener(target, registrationName)),</span>
          <span class="s4">null </span><span class="s2">!= stateNode &amp;&amp;</span>
            <span class="s2">listeners.push(</span>
              <span class="s2">createDispatchListener(target, stateNode, alternate)</span>
            <span class="s2">)));</span>
    <span class="s2">target = target.return;</span>
  <span class="s2">}</span>
  <span class="s5">0 </span><span class="s2">!== listeners.length &amp;&amp;</span>
    <span class="s2">dispatchQueue.push({ event: event, listeners: listeners });</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">NORMALIZE_NEWLINES_REGEX = </span><span class="s7">/\r\n?/g</span><span class="s2">,</span>
  <span class="s2">NORMALIZE_NULL_AND_REPLACEMENT_REGEX = </span><span class="s7">/\u0000|\uFFFD/g</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">normalizeMarkupForTextOrAttribute(markup) {</span>
  <span class="s4">return </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">markup ? markup : </span><span class="s3">&quot;&quot; </span><span class="s2">+ markup)</span>
    <span class="s2">.replace(NORMALIZE_NEWLINES_REGEX, </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">)</span>
    <span class="s2">.replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, </span><span class="s3">&quot;&quot;</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">checkForUnmatchedText(serverText, clientText) {</span>
  <span class="s2">clientText = normalizeMarkupForTextOrAttribute(clientText);</span>
  <span class="s4">return </span><span class="s2">normalizeMarkupForTextOrAttribute(serverText) === clientText ? !</span><span class="s5">0 </span><span class="s2">: !</span><span class="s5">1</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">noop$2() {}</span>
<span class="s4">function </span><span class="s2">setProp(domElement, tag, key, value, props, prevValue) {</span>
  <span class="s4">switch </span><span class="s2">(key) {</span>
    <span class="s4">case </span><span class="s3">&quot;children&quot;</span><span class="s2">:</span>
      <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value</span>
        <span class="s2">? </span><span class="s3">&quot;body&quot; </span><span class="s2">=== tag ||</span>
          <span class="s2">(</span><span class="s3">&quot;textarea&quot; </span><span class="s2">=== tag &amp;&amp; </span><span class="s3">&quot;&quot; </span><span class="s2">=== value) ||</span>
          <span class="s2">setTextContent(domElement, value)</span>
        <span class="s2">: (</span><span class="s3">&quot;number&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value || </span><span class="s3">&quot;bigint&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) &amp;&amp;</span>
          <span class="s3">&quot;body&quot; </span><span class="s2">!== tag &amp;&amp;</span>
          <span class="s2">setTextContent(domElement, </span><span class="s3">&quot;&quot; </span><span class="s2">+ value);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;className&quot;</span><span class="s2">:</span>
      <span class="s2">setValueForKnownAttribute(domElement, </span><span class="s3">&quot;class&quot;</span><span class="s2">, value);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;tabIndex&quot;</span><span class="s2">:</span>
      <span class="s2">setValueForKnownAttribute(domElement, </span><span class="s3">&quot;tabindex&quot;</span><span class="s2">, value);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;dir&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;role&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;viewBox&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;width&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;height&quot;</span><span class="s2">:</span>
      <span class="s2">setValueForKnownAttribute(domElement, key, value);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;style&quot;</span><span class="s2">:</span>
      <span class="s2">setValueForStyles(domElement, value, prevValue);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;data&quot;</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">!== tag) {</span>
        <span class="s2">setValueForKnownAttribute(domElement, </span><span class="s3">&quot;data&quot;</span><span class="s2">, value);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s2">}</span>
    <span class="s4">case </span><span class="s3">&quot;src&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;href&quot;</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;&quot; </span><span class="s2">=== value &amp;&amp; (</span><span class="s3">&quot;a&quot; </span><span class="s2">!== tag || </span><span class="s3">&quot;href&quot; </span><span class="s2">!== key)) {</span>
        <span class="s2">domElement.removeAttribute(key);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s4">null </span><span class="s2">== value ||</span>
        <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value ||</span>
        <span class="s3">&quot;symbol&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value ||</span>
        <span class="s3">&quot;boolean&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value</span>
      <span class="s2">) {</span>
        <span class="s2">domElement.removeAttribute(key);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s2">value = sanitizeURL(</span><span class="s3">&quot;&quot; </span><span class="s2">+ value);</span>
      <span class="s2">domElement.setAttribute(key, value);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;action&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;formAction&quot;</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) {</span>
        <span class="s2">domElement.setAttribute(</span>
          <span class="s2">key,</span>
          <span class="s3">&quot;javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you</span><span class="s6">\\</span><span class="s3">'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')&quot;</span>
        <span class="s2">);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s2">} </span><span class="s4">else</span>
        <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">prevValue &amp;&amp;</span>
          <span class="s2">(</span><span class="s3">&quot;formAction&quot; </span><span class="s2">=== key</span>
            <span class="s2">? (</span><span class="s3">&quot;input&quot; </span><span class="s2">!== tag &amp;&amp;</span>
                <span class="s2">setProp(domElement, tag, </span><span class="s3">&quot;name&quot;</span><span class="s2">, props.name, props, </span><span class="s4">null</span><span class="s2">),</span>
              <span class="s2">setProp(</span>
                <span class="s2">domElement,</span>
                <span class="s2">tag,</span>
                <span class="s3">&quot;formEncType&quot;</span><span class="s2">,</span>
                <span class="s2">props.formEncType,</span>
                <span class="s2">props,</span>
                <span class="s4">null</span>
              <span class="s2">),</span>
              <span class="s2">setProp(</span>
                <span class="s2">domElement,</span>
                <span class="s2">tag,</span>
                <span class="s3">&quot;formMethod&quot;</span><span class="s2">,</span>
                <span class="s2">props.formMethod,</span>
                <span class="s2">props,</span>
                <span class="s4">null</span>
              <span class="s2">),</span>
              <span class="s2">setProp(</span>
                <span class="s2">domElement,</span>
                <span class="s2">tag,</span>
                <span class="s3">&quot;formTarget&quot;</span><span class="s2">,</span>
                <span class="s2">props.formTarget,</span>
                <span class="s2">props,</span>
                <span class="s4">null</span>
              <span class="s2">))</span>
            <span class="s2">: (setProp(domElement, tag, </span><span class="s3">&quot;encType&quot;</span><span class="s2">, props.encType, props, </span><span class="s4">null</span><span class="s2">),</span>
              <span class="s2">setProp(domElement, tag, </span><span class="s3">&quot;method&quot;</span><span class="s2">, props.method, props, </span><span class="s4">null</span><span class="s2">),</span>
              <span class="s2">setProp(domElement, tag, </span><span class="s3">&quot;target&quot;</span><span class="s2">, props.target, props, </span><span class="s4">null</span><span class="s2">)));</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s4">null </span><span class="s2">== value ||</span>
        <span class="s3">&quot;symbol&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value ||</span>
        <span class="s3">&quot;boolean&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value</span>
      <span class="s2">) {</span>
        <span class="s2">domElement.removeAttribute(key);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s2">value = sanitizeURL(</span><span class="s3">&quot;&quot; </span><span class="s2">+ value);</span>
      <span class="s2">domElement.setAttribute(key, value);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;onClick&quot;</span><span class="s2">:</span>
      <span class="s4">null </span><span class="s2">!= value &amp;&amp; (domElement.onclick = noop$2);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;onScroll&quot;</span><span class="s2">:</span>
      <span class="s4">null </span><span class="s2">!= value &amp;&amp; listenToNonDelegatedEvent(</span><span class="s3">&quot;scroll&quot;</span><span class="s2">, domElement);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;onScrollEnd&quot;</span><span class="s2">:</span>
      <span class="s4">null </span><span class="s2">!= value &amp;&amp; listenToNonDelegatedEvent(</span><span class="s3">&quot;scrollend&quot;</span><span class="s2">, domElement);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;dangerouslySetInnerHTML&quot;</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= value) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">value || !(</span><span class="s3">&quot;__html&quot; </span><span class="s4">in </span><span class="s2">value))</span>
          <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">61</span><span class="s2">));</span>
        <span class="s2">key = value.__html;</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= key) {</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= props.children) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">60</span><span class="s2">));</span>
          <span class="s2">domElement.innerHTML = key;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;multiple&quot;</span><span class="s2">:</span>
      <span class="s2">domElement.multiple =</span>
        <span class="s2">value &amp;&amp; </span><span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">value &amp;&amp; </span><span class="s3">&quot;symbol&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">value;</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;muted&quot;</span><span class="s2">:</span>
      <span class="s2">domElement.muted =</span>
        <span class="s2">value &amp;&amp; </span><span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">value &amp;&amp; </span><span class="s3">&quot;symbol&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">value;</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;suppressContentEditableWarning&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;suppressHydrationWarning&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;defaultValue&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;defaultChecked&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;innerHTML&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;ref&quot;</span><span class="s2">:</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;autoFocus&quot;</span><span class="s2">:</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;xlinkHref&quot;</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s4">null </span><span class="s2">== value ||</span>
        <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value ||</span>
        <span class="s3">&quot;boolean&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value ||</span>
        <span class="s3">&quot;symbol&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value</span>
      <span class="s2">) {</span>
        <span class="s2">domElement.removeAttribute(</span><span class="s3">&quot;xlink:href&quot;</span><span class="s2">);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s2">key = sanitizeURL(</span><span class="s3">&quot;&quot; </span><span class="s2">+ value);</span>
      <span class="s2">domElement.setAttributeNS(</span>
        <span class="s3">&quot;http://www.w3.org/1999/xlink&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;xlink:href&quot;</span><span class="s2">,</span>
        <span class="s2">key</span>
      <span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;contentEditable&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;spellCheck&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;draggable&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;value&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;autoReverse&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;externalResourcesRequired&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;focusable&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;preserveAlpha&quot;</span><span class="s2">:</span>
      <span class="s4">null </span><span class="s2">!= value &amp;&amp; </span><span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">value &amp;&amp; </span><span class="s3">&quot;symbol&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">value</span>
        <span class="s2">? domElement.setAttribute(key, </span><span class="s3">&quot;&quot; </span><span class="s2">+ value)</span>
        <span class="s2">: domElement.removeAttribute(key);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;inert&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;allowFullScreen&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;async&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;autoPlay&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;controls&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;default&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;defer&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;disabled&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;disablePictureInPicture&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;disableRemotePlayback&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;formNoValidate&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;hidden&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;loop&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;noModule&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;noValidate&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;open&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;playsInline&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;readOnly&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;required&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;reversed&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;scoped&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;seamless&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;itemScope&quot;</span><span class="s2">:</span>
      <span class="s2">value &amp;&amp; </span><span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">value &amp;&amp; </span><span class="s3">&quot;symbol&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">value</span>
        <span class="s2">? domElement.setAttribute(key, </span><span class="s3">&quot;&quot;</span><span class="s2">)</span>
        <span class="s2">: domElement.removeAttribute(key);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;capture&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;download&quot;</span><span class="s2">:</span>
      <span class="s2">!</span><span class="s5">0 </span><span class="s2">=== value</span>
        <span class="s2">? domElement.setAttribute(key, </span><span class="s3">&quot;&quot;</span><span class="s2">)</span>
        <span class="s2">: !</span><span class="s5">1 </span><span class="s2">!== value &amp;&amp;</span>
            <span class="s4">null </span><span class="s2">!= value &amp;&amp;</span>
            <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">value &amp;&amp;</span>
            <span class="s3">&quot;symbol&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">value</span>
          <span class="s2">? domElement.setAttribute(key, value)</span>
          <span class="s2">: domElement.removeAttribute(key);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;cols&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;rows&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;size&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;span&quot;</span><span class="s2">:</span>
      <span class="s4">null </span><span class="s2">!= value &amp;&amp;</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">value &amp;&amp;</span>
      <span class="s3">&quot;symbol&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">value &amp;&amp;</span>
      <span class="s2">!isNaN(value) &amp;&amp;</span>
      <span class="s5">1 </span><span class="s2">&lt;= value</span>
        <span class="s2">? domElement.setAttribute(key, value)</span>
        <span class="s2">: domElement.removeAttribute(key);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;rowSpan&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;start&quot;</span><span class="s2">:</span>
      <span class="s4">null </span><span class="s2">== value ||</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value ||</span>
      <span class="s3">&quot;symbol&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value ||</span>
      <span class="s2">isNaN(value)</span>
        <span class="s2">? domElement.removeAttribute(key)</span>
        <span class="s2">: domElement.setAttribute(key, value);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;popover&quot;</span><span class="s2">:</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;beforetoggle&quot;</span><span class="s2">, domElement);</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;toggle&quot;</span><span class="s2">, domElement);</span>
      <span class="s2">setValueForAttribute(domElement, </span><span class="s3">&quot;popover&quot;</span><span class="s2">, value);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;xlinkActuate&quot;</span><span class="s2">:</span>
      <span class="s2">setValueForNamespacedAttribute(</span>
        <span class="s2">domElement,</span>
        <span class="s3">&quot;http://www.w3.org/1999/xlink&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;xlink:actuate&quot;</span><span class="s2">,</span>
        <span class="s2">value</span>
      <span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;xlinkArcrole&quot;</span><span class="s2">:</span>
      <span class="s2">setValueForNamespacedAttribute(</span>
        <span class="s2">domElement,</span>
        <span class="s3">&quot;http://www.w3.org/1999/xlink&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;xlink:arcrole&quot;</span><span class="s2">,</span>
        <span class="s2">value</span>
      <span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;xlinkRole&quot;</span><span class="s2">:</span>
      <span class="s2">setValueForNamespacedAttribute(</span>
        <span class="s2">domElement,</span>
        <span class="s3">&quot;http://www.w3.org/1999/xlink&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;xlink:role&quot;</span><span class="s2">,</span>
        <span class="s2">value</span>
      <span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;xlinkShow&quot;</span><span class="s2">:</span>
      <span class="s2">setValueForNamespacedAttribute(</span>
        <span class="s2">domElement,</span>
        <span class="s3">&quot;http://www.w3.org/1999/xlink&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;xlink:show&quot;</span><span class="s2">,</span>
        <span class="s2">value</span>
      <span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;xlinkTitle&quot;</span><span class="s2">:</span>
      <span class="s2">setValueForNamespacedAttribute(</span>
        <span class="s2">domElement,</span>
        <span class="s3">&quot;http://www.w3.org/1999/xlink&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;xlink:title&quot;</span><span class="s2">,</span>
        <span class="s2">value</span>
      <span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;xlinkType&quot;</span><span class="s2">:</span>
      <span class="s2">setValueForNamespacedAttribute(</span>
        <span class="s2">domElement,</span>
        <span class="s3">&quot;http://www.w3.org/1999/xlink&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;xlink:type&quot;</span><span class="s2">,</span>
        <span class="s2">value</span>
      <span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;xmlBase&quot;</span><span class="s2">:</span>
      <span class="s2">setValueForNamespacedAttribute(</span>
        <span class="s2">domElement,</span>
        <span class="s3">&quot;http://www.w3.org/XML/1998/namespace&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;xml:base&quot;</span><span class="s2">,</span>
        <span class="s2">value</span>
      <span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;xmlLang&quot;</span><span class="s2">:</span>
      <span class="s2">setValueForNamespacedAttribute(</span>
        <span class="s2">domElement,</span>
        <span class="s3">&quot;http://www.w3.org/XML/1998/namespace&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;xml:lang&quot;</span><span class="s2">,</span>
        <span class="s2">value</span>
      <span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;xmlSpace&quot;</span><span class="s2">:</span>
      <span class="s2">setValueForNamespacedAttribute(</span>
        <span class="s2">domElement,</span>
        <span class="s3">&quot;http://www.w3.org/XML/1998/namespace&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;xml:space&quot;</span><span class="s2">,</span>
        <span class="s2">value</span>
      <span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;is&quot;</span><span class="s2">:</span>
      <span class="s2">setValueForAttribute(domElement, </span><span class="s3">&quot;is&quot;</span><span class="s2">, value);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;innerText&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;textContent&quot;</span><span class="s2">:</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">!(</span><span class="s5">2 </span><span class="s2">&lt; key.length) ||</span>
        <span class="s2">(</span><span class="s3">&quot;o&quot; </span><span class="s2">!== key[</span><span class="s5">0</span><span class="s2">] &amp;&amp; </span><span class="s3">&quot;O&quot; </span><span class="s2">!== key[</span><span class="s5">0</span><span class="s2">]) ||</span>
        <span class="s2">(</span><span class="s3">&quot;n&quot; </span><span class="s2">!== key[</span><span class="s5">1</span><span class="s2">] &amp;&amp; </span><span class="s3">&quot;N&quot; </span><span class="s2">!== key[</span><span class="s5">1</span><span class="s2">])</span>
      <span class="s2">)</span>
        <span class="s2">(key = aliases.get(key) || key),</span>
          <span class="s2">setValueForAttribute(domElement, key, value);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {</span>
  <span class="s4">switch </span><span class="s2">(key) {</span>
    <span class="s4">case </span><span class="s3">&quot;style&quot;</span><span class="s2">:</span>
      <span class="s2">setValueForStyles(domElement, value, prevValue);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;dangerouslySetInnerHTML&quot;</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= value) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">value || !(</span><span class="s3">&quot;__html&quot; </span><span class="s4">in </span><span class="s2">value))</span>
          <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">61</span><span class="s2">));</span>
        <span class="s2">key = value.__html;</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= key) {</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= props.children) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">60</span><span class="s2">));</span>
          <span class="s2">domElement.innerHTML = key;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;children&quot;</span><span class="s2">:</span>
      <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value</span>
        <span class="s2">? setTextContent(domElement, value)</span>
        <span class="s2">: (</span><span class="s3">&quot;number&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value || </span><span class="s3">&quot;bigint&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) &amp;&amp;</span>
          <span class="s2">setTextContent(domElement, </span><span class="s3">&quot;&quot; </span><span class="s2">+ value);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;onScroll&quot;</span><span class="s2">:</span>
      <span class="s4">null </span><span class="s2">!= value &amp;&amp; listenToNonDelegatedEvent(</span><span class="s3">&quot;scroll&quot;</span><span class="s2">, domElement);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;onScrollEnd&quot;</span><span class="s2">:</span>
      <span class="s4">null </span><span class="s2">!= value &amp;&amp; listenToNonDelegatedEvent(</span><span class="s3">&quot;scrollend&quot;</span><span class="s2">, domElement);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;onClick&quot;</span><span class="s2">:</span>
      <span class="s4">null </span><span class="s2">!= value &amp;&amp; (domElement.onclick = noop$2);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;suppressContentEditableWarning&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;suppressHydrationWarning&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;innerHTML&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;ref&quot;</span><span class="s2">:</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;innerText&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;textContent&quot;</span><span class="s2">:</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(!registrationNameDependencies.hasOwnProperty(key))</span>
        <span class="s2">a: {</span>
          <span class="s4">if </span><span class="s2">(</span>
            <span class="s3">&quot;o&quot; </span><span class="s2">=== key[</span><span class="s5">0</span><span class="s2">] &amp;&amp;</span>
            <span class="s3">&quot;n&quot; </span><span class="s2">=== key[</span><span class="s5">1</span><span class="s2">] &amp;&amp;</span>
            <span class="s2">((props = key.endsWith(</span><span class="s3">&quot;Capture&quot;</span><span class="s2">)),</span>
            <span class="s2">(tag = key.slice(</span><span class="s5">2</span><span class="s2">, props ? key.length - </span><span class="s5">7 </span><span class="s2">: </span><span class="s4">void </span><span class="s5">0</span><span class="s2">)),</span>
            <span class="s2">(prevValue = domElement[internalPropsKey] || </span><span class="s4">null</span><span class="s2">),</span>
            <span class="s2">(prevValue = </span><span class="s4">null </span><span class="s2">!= prevValue ? prevValue[key] : </span><span class="s4">null</span><span class="s2">),</span>
            <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">prevValue &amp;&amp;</span>
              <span class="s2">domElement.removeEventListener(tag, prevValue, props),</span>
            <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value)</span>
          <span class="s2">) {</span>
            <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">prevValue &amp;&amp;</span>
              <span class="s4">null </span><span class="s2">!== prevValue &amp;&amp;</span>
              <span class="s2">(key </span><span class="s4">in </span><span class="s2">domElement</span>
                <span class="s2">? (domElement[key] = </span><span class="s4">null</span><span class="s2">)</span>
                <span class="s2">: domElement.hasAttribute(key) &amp;&amp;</span>
                  <span class="s2">domElement.removeAttribute(key));</span>
            <span class="s2">domElement.addEventListener(tag, value, props);</span>
            <span class="s4">break </span><span class="s2">a;</span>
          <span class="s2">}</span>
          <span class="s2">key </span><span class="s4">in </span><span class="s2">domElement</span>
            <span class="s2">? (domElement[key] = value)</span>
            <span class="s2">: !</span><span class="s5">0 </span><span class="s2">=== value</span>
              <span class="s2">? domElement.setAttribute(key, </span><span class="s3">&quot;&quot;</span><span class="s2">)</span>
              <span class="s2">: setValueForAttribute(domElement, key, value);</span>
        <span class="s2">}</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">setInitialProperties(domElement, tag, props) {</span>
  <span class="s4">switch </span><span class="s2">(tag) {</span>
    <span class="s4">case </span><span class="s3">&quot;div&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;span&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;svg&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;path&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;a&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;g&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;p&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;li&quot;</span><span class="s2">:</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;img&quot;</span><span class="s2">:</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;error&quot;</span><span class="s2">, domElement);</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;load&quot;</span><span class="s2">, domElement);</span>
      <span class="s4">var </span><span class="s2">hasSrc = !</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s2">hasSrcSet = !</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s2">propKey;</span>
      <span class="s4">for </span><span class="s2">(propKey </span><span class="s4">in </span><span class="s2">props)</span>
        <span class="s4">if </span><span class="s2">(props.hasOwnProperty(propKey)) {</span>
          <span class="s4">var </span><span class="s2">propValue = props[propKey];</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= propValue)</span>
            <span class="s4">switch </span><span class="s2">(propKey) {</span>
              <span class="s4">case </span><span class="s3">&quot;src&quot;</span><span class="s2">:</span>
                <span class="s2">hasSrc = !</span><span class="s5">0</span><span class="s2">;</span>
                <span class="s4">break</span><span class="s2">;</span>
              <span class="s4">case </span><span class="s3">&quot;srcSet&quot;</span><span class="s2">:</span>
                <span class="s2">hasSrcSet = !</span><span class="s5">0</span><span class="s2">;</span>
                <span class="s4">break</span><span class="s2">;</span>
              <span class="s4">case </span><span class="s3">&quot;children&quot;</span><span class="s2">:</span>
              <span class="s4">case </span><span class="s3">&quot;dangerouslySetInnerHTML&quot;</span><span class="s2">:</span>
                <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">137</span><span class="s2">, tag));</span>
              <span class="s4">default</span><span class="s2">:</span>
                <span class="s2">setProp(domElement, tag, propKey, propValue, props, </span><span class="s4">null</span><span class="s2">);</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
      <span class="s2">hasSrcSet &amp;&amp;</span>
        <span class="s2">setProp(domElement, tag, </span><span class="s3">&quot;srcSet&quot;</span><span class="s2">, props.srcSet, props, </span><span class="s4">null</span><span class="s2">);</span>
      <span class="s2">hasSrc &amp;&amp; setProp(domElement, tag, </span><span class="s3">&quot;src&quot;</span><span class="s2">, props.src, props, </span><span class="s4">null</span><span class="s2">);</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;input&quot;</span><span class="s2">:</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;invalid&quot;</span><span class="s2">, domElement);</span>
      <span class="s4">var </span><span class="s2">defaultValue = (propKey = propValue = hasSrcSet = </span><span class="s4">null</span><span class="s2">),</span>
        <span class="s2">checked = </span><span class="s4">null</span><span class="s2">,</span>
        <span class="s2">defaultChecked = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">for </span><span class="s2">(hasSrc </span><span class="s4">in </span><span class="s2">props)</span>
        <span class="s4">if </span><span class="s2">(props.hasOwnProperty(hasSrc)) {</span>
          <span class="s4">var </span><span class="s2">propValue$203 = props[hasSrc];</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= propValue$203)</span>
            <span class="s4">switch </span><span class="s2">(hasSrc) {</span>
              <span class="s4">case </span><span class="s3">&quot;name&quot;</span><span class="s2">:</span>
                <span class="s2">hasSrcSet = propValue$203;</span>
                <span class="s4">break</span><span class="s2">;</span>
              <span class="s4">case </span><span class="s3">&quot;type&quot;</span><span class="s2">:</span>
                <span class="s2">propValue = propValue$203;</span>
                <span class="s4">break</span><span class="s2">;</span>
              <span class="s4">case </span><span class="s3">&quot;checked&quot;</span><span class="s2">:</span>
                <span class="s2">checked = propValue$203;</span>
                <span class="s4">break</span><span class="s2">;</span>
              <span class="s4">case </span><span class="s3">&quot;defaultChecked&quot;</span><span class="s2">:</span>
                <span class="s2">defaultChecked = propValue$203;</span>
                <span class="s4">break</span><span class="s2">;</span>
              <span class="s4">case </span><span class="s3">&quot;value&quot;</span><span class="s2">:</span>
                <span class="s2">propKey = propValue$203;</span>
                <span class="s4">break</span><span class="s2">;</span>
              <span class="s4">case </span><span class="s3">&quot;defaultValue&quot;</span><span class="s2">:</span>
                <span class="s2">defaultValue = propValue$203;</span>
                <span class="s4">break</span><span class="s2">;</span>
              <span class="s4">case </span><span class="s3">&quot;children&quot;</span><span class="s2">:</span>
              <span class="s4">case </span><span class="s3">&quot;dangerouslySetInnerHTML&quot;</span><span class="s2">:</span>
                <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= propValue$203)</span>
                  <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">137</span><span class="s2">, tag));</span>
                <span class="s4">break</span><span class="s2">;</span>
              <span class="s4">default</span><span class="s2">:</span>
                <span class="s2">setProp(domElement, tag, hasSrc, propValue$203, props, </span><span class="s4">null</span><span class="s2">);</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
      <span class="s2">initInput(</span>
        <span class="s2">domElement,</span>
        <span class="s2">propKey,</span>
        <span class="s2">defaultValue,</span>
        <span class="s2">checked,</span>
        <span class="s2">defaultChecked,</span>
        <span class="s2">propValue,</span>
        <span class="s2">hasSrcSet,</span>
        <span class="s2">!</span><span class="s5">1</span>
      <span class="s2">);</span>
      <span class="s2">track(domElement);</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;select&quot;</span><span class="s2">:</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;invalid&quot;</span><span class="s2">, domElement);</span>
      <span class="s2">hasSrc = propValue = propKey = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">for </span><span class="s2">(hasSrcSet </span><span class="s4">in </span><span class="s2">props)</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">props.hasOwnProperty(hasSrcSet) &amp;&amp;</span>
          <span class="s2">((defaultValue = props[hasSrcSet]), </span><span class="s4">null </span><span class="s2">!= defaultValue)</span>
        <span class="s2">)</span>
          <span class="s4">switch </span><span class="s2">(hasSrcSet) {</span>
            <span class="s4">case </span><span class="s3">&quot;value&quot;</span><span class="s2">:</span>
              <span class="s2">propKey = defaultValue;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;defaultValue&quot;</span><span class="s2">:</span>
              <span class="s2">propValue = defaultValue;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;multiple&quot;</span><span class="s2">:</span>
              <span class="s2">hasSrc = defaultValue;</span>
            <span class="s4">default</span><span class="s2">:</span>
              <span class="s2">setProp(domElement, tag, hasSrcSet, defaultValue, props, </span><span class="s4">null</span><span class="s2">);</span>
          <span class="s2">}</span>
      <span class="s2">tag = propKey;</span>
      <span class="s2">props = propValue;</span>
      <span class="s2">domElement.multiple = !!hasSrc;</span>
      <span class="s4">null </span><span class="s2">!= tag</span>
        <span class="s2">? updateOptions(domElement, !!hasSrc, tag, !</span><span class="s5">1</span><span class="s2">)</span>
        <span class="s2">: </span><span class="s4">null </span><span class="s2">!= props &amp;&amp; updateOptions(domElement, !!hasSrc, props, !</span><span class="s5">0</span><span class="s2">);</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;textarea&quot;</span><span class="s2">:</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;invalid&quot;</span><span class="s2">, domElement);</span>
      <span class="s2">propKey = hasSrcSet = hasSrc = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">for </span><span class="s2">(propValue </span><span class="s4">in </span><span class="s2">props)</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">props.hasOwnProperty(propValue) &amp;&amp;</span>
          <span class="s2">((defaultValue = props[propValue]), </span><span class="s4">null </span><span class="s2">!= defaultValue)</span>
        <span class="s2">)</span>
          <span class="s4">switch </span><span class="s2">(propValue) {</span>
            <span class="s4">case </span><span class="s3">&quot;value&quot;</span><span class="s2">:</span>
              <span class="s2">hasSrc = defaultValue;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;defaultValue&quot;</span><span class="s2">:</span>
              <span class="s2">hasSrcSet = defaultValue;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;children&quot;</span><span class="s2">:</span>
              <span class="s2">propKey = defaultValue;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;dangerouslySetInnerHTML&quot;</span><span class="s2">:</span>
              <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= defaultValue) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">91</span><span class="s2">));</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">default</span><span class="s2">:</span>
              <span class="s2">setProp(domElement, tag, propValue, defaultValue, props, </span><span class="s4">null</span><span class="s2">);</span>
          <span class="s2">}</span>
      <span class="s2">initTextarea(domElement, hasSrc, hasSrcSet, propKey);</span>
      <span class="s2">track(domElement);</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;option&quot;</span><span class="s2">:</span>
      <span class="s4">for </span><span class="s2">(checked </span><span class="s4">in </span><span class="s2">props)</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">props.hasOwnProperty(checked) &amp;&amp;</span>
          <span class="s2">((hasSrc = props[checked]), </span><span class="s4">null </span><span class="s2">!= hasSrc)</span>
        <span class="s2">)</span>
          <span class="s4">switch </span><span class="s2">(checked) {</span>
            <span class="s4">case </span><span class="s3">&quot;selected&quot;</span><span class="s2">:</span>
              <span class="s2">domElement.selected =</span>
                <span class="s2">hasSrc &amp;&amp;</span>
                <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">hasSrc &amp;&amp;</span>
                <span class="s3">&quot;symbol&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">hasSrc;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">default</span><span class="s2">:</span>
              <span class="s2">setProp(domElement, tag, checked, hasSrc, props, </span><span class="s4">null</span><span class="s2">);</span>
          <span class="s2">}</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;dialog&quot;</span><span class="s2">:</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;beforetoggle&quot;</span><span class="s2">, domElement);</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;toggle&quot;</span><span class="s2">, domElement);</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;cancel&quot;</span><span class="s2">, domElement);</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;close&quot;</span><span class="s2">, domElement);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;iframe&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;object&quot;</span><span class="s2">:</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;load&quot;</span><span class="s2">, domElement);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;video&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;audio&quot;</span><span class="s2">:</span>
      <span class="s4">for </span><span class="s2">(hasSrc = </span><span class="s5">0</span><span class="s2">; hasSrc &lt; mediaEventTypes.length; hasSrc++)</span>
        <span class="s2">listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;image&quot;</span><span class="s2">:</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;error&quot;</span><span class="s2">, domElement);</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;load&quot;</span><span class="s2">, domElement);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;details&quot;</span><span class="s2">:</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;toggle&quot;</span><span class="s2">, domElement);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;embed&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;source&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;link&quot;</span><span class="s2">:</span>
      <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;error&quot;</span><span class="s2">, domElement),</span>
        <span class="s2">listenToNonDelegatedEvent(</span><span class="s3">&quot;load&quot;</span><span class="s2">, domElement);</span>
    <span class="s4">case </span><span class="s3">&quot;area&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;base&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;br&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;col&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;hr&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;keygen&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;meta&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;param&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;track&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;wbr&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;menuitem&quot;</span><span class="s2">:</span>
      <span class="s4">for </span><span class="s2">(defaultChecked </span><span class="s4">in </span><span class="s2">props)</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">props.hasOwnProperty(defaultChecked) &amp;&amp;</span>
          <span class="s2">((hasSrc = props[defaultChecked]), </span><span class="s4">null </span><span class="s2">!= hasSrc)</span>
        <span class="s2">)</span>
          <span class="s4">switch </span><span class="s2">(defaultChecked) {</span>
            <span class="s4">case </span><span class="s3">&quot;children&quot;</span><span class="s2">:</span>
            <span class="s4">case </span><span class="s3">&quot;dangerouslySetInnerHTML&quot;</span><span class="s2">:</span>
              <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">137</span><span class="s2">, tag));</span>
            <span class="s4">default</span><span class="s2">:</span>
              <span class="s2">setProp(domElement, tag, defaultChecked, hasSrc, props, </span><span class="s4">null</span><span class="s2">);</span>
          <span class="s2">}</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(isCustomElement(tag)) {</span>
        <span class="s4">for </span><span class="s2">(propValue$203 </span><span class="s4">in </span><span class="s2">props)</span>
          <span class="s2">props.hasOwnProperty(propValue$203) &amp;&amp;</span>
            <span class="s2">((hasSrc = props[propValue$203]),</span>
            <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== hasSrc &amp;&amp;</span>
              <span class="s2">setPropOnCustomElement(</span>
                <span class="s2">domElement,</span>
                <span class="s2">tag,</span>
                <span class="s2">propValue$203,</span>
                <span class="s2">hasSrc,</span>
                <span class="s2">props,</span>
                <span class="s4">void </span><span class="s5">0</span>
              <span class="s2">));</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s4">for </span><span class="s2">(defaultValue </span><span class="s4">in </span><span class="s2">props)</span>
    <span class="s2">props.hasOwnProperty(defaultValue) &amp;&amp;</span>
      <span class="s2">((hasSrc = props[defaultValue]),</span>
      <span class="s4">null </span><span class="s2">!= hasSrc &amp;&amp;</span>
        <span class="s2">setProp(domElement, tag, defaultValue, hasSrc, props, </span><span class="s4">null</span><span class="s2">));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateProperties(domElement, tag, lastProps, nextProps) {</span>
  <span class="s4">switch </span><span class="s2">(tag) {</span>
    <span class="s4">case </span><span class="s3">&quot;div&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;span&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;svg&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;path&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;a&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;g&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;p&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;li&quot;</span><span class="s2">:</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;input&quot;</span><span class="s2">:</span>
      <span class="s4">var </span><span class="s2">name = </span><span class="s4">null</span><span class="s2">,</span>
        <span class="s2">type = </span><span class="s4">null</span><span class="s2">,</span>
        <span class="s2">value = </span><span class="s4">null</span><span class="s2">,</span>
        <span class="s2">defaultValue = </span><span class="s4">null</span><span class="s2">,</span>
        <span class="s2">lastDefaultValue = </span><span class="s4">null</span><span class="s2">,</span>
        <span class="s2">checked = </span><span class="s4">null</span><span class="s2">,</span>
        <span class="s2">defaultChecked = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">for </span><span class="s2">(propKey </span><span class="s4">in </span><span class="s2">lastProps) {</span>
        <span class="s4">var </span><span class="s2">lastProp = lastProps[propKey];</span>
        <span class="s4">if </span><span class="s2">(lastProps.hasOwnProperty(propKey) &amp;&amp; </span><span class="s4">null </span><span class="s2">!= lastProp)</span>
          <span class="s4">switch </span><span class="s2">(propKey) {</span>
            <span class="s4">case </span><span class="s3">&quot;checked&quot;</span><span class="s2">:</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;value&quot;</span><span class="s2">:</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;defaultValue&quot;</span><span class="s2">:</span>
              <span class="s2">lastDefaultValue = lastProp;</span>
            <span class="s4">default</span><span class="s2">:</span>
              <span class="s2">nextProps.hasOwnProperty(propKey) ||</span>
                <span class="s2">setProp(domElement, tag, propKey, </span><span class="s4">null</span><span class="s2">, nextProps, lastProp);</span>
          <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">propKey$220 </span><span class="s4">in </span><span class="s2">nextProps) {</span>
        <span class="s4">var </span><span class="s2">propKey = nextProps[propKey$220];</span>
        <span class="s2">lastProp = lastProps[propKey$220];</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">nextProps.hasOwnProperty(propKey$220) &amp;&amp;</span>
          <span class="s2">(</span><span class="s4">null </span><span class="s2">!= propKey || </span><span class="s4">null </span><span class="s2">!= lastProp)</span>
        <span class="s2">)</span>
          <span class="s4">switch </span><span class="s2">(propKey$220) {</span>
            <span class="s4">case </span><span class="s3">&quot;type&quot;</span><span class="s2">:</span>
              <span class="s2">type = propKey;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;name&quot;</span><span class="s2">:</span>
              <span class="s2">name = propKey;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;checked&quot;</span><span class="s2">:</span>
              <span class="s2">checked = propKey;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;defaultChecked&quot;</span><span class="s2">:</span>
              <span class="s2">defaultChecked = propKey;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;value&quot;</span><span class="s2">:</span>
              <span class="s2">value = propKey;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;defaultValue&quot;</span><span class="s2">:</span>
              <span class="s2">defaultValue = propKey;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;children&quot;</span><span class="s2">:</span>
            <span class="s4">case </span><span class="s3">&quot;dangerouslySetInnerHTML&quot;</span><span class="s2">:</span>
              <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= propKey)</span>
                <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">137</span><span class="s2">, tag));</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">default</span><span class="s2">:</span>
              <span class="s2">propKey !== lastProp &amp;&amp;</span>
                <span class="s2">setProp(</span>
                  <span class="s2">domElement,</span>
                  <span class="s2">tag,</span>
                  <span class="s2">propKey$220,</span>
                  <span class="s2">propKey,</span>
                  <span class="s2">nextProps,</span>
                  <span class="s2">lastProp</span>
                <span class="s2">);</span>
          <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s2">updateInput(</span>
        <span class="s2">domElement,</span>
        <span class="s2">value,</span>
        <span class="s2">defaultValue,</span>
        <span class="s2">lastDefaultValue,</span>
        <span class="s2">checked,</span>
        <span class="s2">defaultChecked,</span>
        <span class="s2">type,</span>
        <span class="s2">name</span>
      <span class="s2">);</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;select&quot;</span><span class="s2">:</span>
      <span class="s2">propKey = value = defaultValue = propKey$220 = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">for </span><span class="s2">(type </span><span class="s4">in </span><span class="s2">lastProps)</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">((lastDefaultValue = lastProps[type]),</span>
          <span class="s2">lastProps.hasOwnProperty(type) &amp;&amp; </span><span class="s4">null </span><span class="s2">!= lastDefaultValue)</span>
        <span class="s2">)</span>
          <span class="s4">switch </span><span class="s2">(type) {</span>
            <span class="s4">case </span><span class="s3">&quot;value&quot;</span><span class="s2">:</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;multiple&quot;</span><span class="s2">:</span>
              <span class="s2">propKey = lastDefaultValue;</span>
            <span class="s4">default</span><span class="s2">:</span>
              <span class="s2">nextProps.hasOwnProperty(type) ||</span>
                <span class="s2">setProp(</span>
                  <span class="s2">domElement,</span>
                  <span class="s2">tag,</span>
                  <span class="s2">type,</span>
                  <span class="s4">null</span><span class="s2">,</span>
                  <span class="s2">nextProps,</span>
                  <span class="s2">lastDefaultValue</span>
                <span class="s2">);</span>
          <span class="s2">}</span>
      <span class="s4">for </span><span class="s2">(name </span><span class="s4">in </span><span class="s2">nextProps)</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">((type = nextProps[name]),</span>
          <span class="s2">(lastDefaultValue = lastProps[name]),</span>
          <span class="s2">nextProps.hasOwnProperty(name) &amp;&amp;</span>
            <span class="s2">(</span><span class="s4">null </span><span class="s2">!= type || </span><span class="s4">null </span><span class="s2">!= lastDefaultValue))</span>
        <span class="s2">)</span>
          <span class="s4">switch </span><span class="s2">(name) {</span>
            <span class="s4">case </span><span class="s3">&quot;value&quot;</span><span class="s2">:</span>
              <span class="s2">propKey$220 = type;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;defaultValue&quot;</span><span class="s2">:</span>
              <span class="s2">defaultValue = type;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;multiple&quot;</span><span class="s2">:</span>
              <span class="s2">value = type;</span>
            <span class="s4">default</span><span class="s2">:</span>
              <span class="s2">type !== lastDefaultValue &amp;&amp;</span>
                <span class="s2">setProp(</span>
                  <span class="s2">domElement,</span>
                  <span class="s2">tag,</span>
                  <span class="s2">name,</span>
                  <span class="s2">type,</span>
                  <span class="s2">nextProps,</span>
                  <span class="s2">lastDefaultValue</span>
                <span class="s2">);</span>
          <span class="s2">}</span>
      <span class="s2">tag = defaultValue;</span>
      <span class="s2">lastProps = value;</span>
      <span class="s2">nextProps = propKey;</span>
      <span class="s4">null </span><span class="s2">!= propKey$220</span>
        <span class="s2">? updateOptions(domElement, !!lastProps, propKey$220, !</span><span class="s5">1</span><span class="s2">)</span>
        <span class="s2">: !!nextProps !== !!lastProps &amp;&amp;</span>
          <span class="s2">(</span><span class="s4">null </span><span class="s2">!= tag</span>
            <span class="s2">? updateOptions(domElement, !!lastProps, tag, !</span><span class="s5">0</span><span class="s2">)</span>
            <span class="s2">: updateOptions(domElement, !!lastProps, lastProps ? [] : </span><span class="s3">&quot;&quot;</span><span class="s2">, !</span><span class="s5">1</span><span class="s2">));</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;textarea&quot;</span><span class="s2">:</span>
      <span class="s2">propKey = propKey$220 = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">for </span><span class="s2">(defaultValue </span><span class="s4">in </span><span class="s2">lastProps)</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">((name = lastProps[defaultValue]),</span>
          <span class="s2">lastProps.hasOwnProperty(defaultValue) &amp;&amp;</span>
            <span class="s4">null </span><span class="s2">!= name &amp;&amp;</span>
            <span class="s2">!nextProps.hasOwnProperty(defaultValue))</span>
        <span class="s2">)</span>
          <span class="s4">switch </span><span class="s2">(defaultValue) {</span>
            <span class="s4">case </span><span class="s3">&quot;value&quot;</span><span class="s2">:</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;children&quot;</span><span class="s2">:</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">default</span><span class="s2">:</span>
              <span class="s2">setProp(domElement, tag, defaultValue, </span><span class="s4">null</span><span class="s2">, nextProps, name);</span>
          <span class="s2">}</span>
      <span class="s4">for </span><span class="s2">(value </span><span class="s4">in </span><span class="s2">nextProps)</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">((name = nextProps[value]),</span>
          <span class="s2">(type = lastProps[value]),</span>
          <span class="s2">nextProps.hasOwnProperty(value) &amp;&amp; (</span><span class="s4">null </span><span class="s2">!= name || </span><span class="s4">null </span><span class="s2">!= type))</span>
        <span class="s2">)</span>
          <span class="s4">switch </span><span class="s2">(value) {</span>
            <span class="s4">case </span><span class="s3">&quot;value&quot;</span><span class="s2">:</span>
              <span class="s2">propKey$220 = name;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;defaultValue&quot;</span><span class="s2">:</span>
              <span class="s2">propKey = name;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;children&quot;</span><span class="s2">:</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;dangerouslySetInnerHTML&quot;</span><span class="s2">:</span>
              <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= name) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">91</span><span class="s2">));</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">default</span><span class="s2">:</span>
              <span class="s2">name !== type &amp;&amp;</span>
                <span class="s2">setProp(domElement, tag, value, name, nextProps, type);</span>
          <span class="s2">}</span>
      <span class="s2">updateTextarea(domElement, propKey$220, propKey);</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;option&quot;</span><span class="s2">:</span>
      <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">propKey$236 </span><span class="s4">in </span><span class="s2">lastProps)</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">((propKey$220 = lastProps[propKey$236]),</span>
          <span class="s2">lastProps.hasOwnProperty(propKey$236) &amp;&amp;</span>
            <span class="s4">null </span><span class="s2">!= propKey$220 &amp;&amp;</span>
            <span class="s2">!nextProps.hasOwnProperty(propKey$236))</span>
        <span class="s2">)</span>
          <span class="s4">switch </span><span class="s2">(propKey$236) {</span>
            <span class="s4">case </span><span class="s3">&quot;selected&quot;</span><span class="s2">:</span>
              <span class="s2">domElement.selected = !</span><span class="s5">1</span><span class="s2">;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">default</span><span class="s2">:</span>
              <span class="s2">setProp(</span>
                <span class="s2">domElement,</span>
                <span class="s2">tag,</span>
                <span class="s2">propKey$236,</span>
                <span class="s4">null</span><span class="s2">,</span>
                <span class="s2">nextProps,</span>
                <span class="s2">propKey$220</span>
              <span class="s2">);</span>
          <span class="s2">}</span>
      <span class="s4">for </span><span class="s2">(lastDefaultValue </span><span class="s4">in </span><span class="s2">nextProps)</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">((propKey$220 = nextProps[lastDefaultValue]),</span>
          <span class="s2">(propKey = lastProps[lastDefaultValue]),</span>
          <span class="s2">nextProps.hasOwnProperty(lastDefaultValue) &amp;&amp;</span>
            <span class="s2">propKey$220 !== propKey &amp;&amp;</span>
            <span class="s2">(</span><span class="s4">null </span><span class="s2">!= propKey$220 || </span><span class="s4">null </span><span class="s2">!= propKey))</span>
        <span class="s2">)</span>
          <span class="s4">switch </span><span class="s2">(lastDefaultValue) {</span>
            <span class="s4">case </span><span class="s3">&quot;selected&quot;</span><span class="s2">:</span>
              <span class="s2">domElement.selected =</span>
                <span class="s2">propKey$220 &amp;&amp;</span>
                <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">propKey$220 &amp;&amp;</span>
                <span class="s3">&quot;symbol&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">propKey$220;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">default</span><span class="s2">:</span>
              <span class="s2">setProp(</span>
                <span class="s2">domElement,</span>
                <span class="s2">tag,</span>
                <span class="s2">lastDefaultValue,</span>
                <span class="s2">propKey$220,</span>
                <span class="s2">nextProps,</span>
                <span class="s2">propKey</span>
              <span class="s2">);</span>
          <span class="s2">}</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;img&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;link&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;area&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;base&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;br&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;col&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;embed&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;hr&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;keygen&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;meta&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;param&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;source&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;track&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;wbr&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;menuitem&quot;</span><span class="s2">:</span>
      <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">propKey$241 </span><span class="s4">in </span><span class="s2">lastProps)</span>
        <span class="s2">(propKey$220 = lastProps[propKey$241]),</span>
          <span class="s2">lastProps.hasOwnProperty(propKey$241) &amp;&amp;</span>
            <span class="s4">null </span><span class="s2">!= propKey$220 &amp;&amp;</span>
            <span class="s2">!nextProps.hasOwnProperty(propKey$241) &amp;&amp;</span>
            <span class="s2">setProp(domElement, tag, propKey$241, </span><span class="s4">null</span><span class="s2">, nextProps, propKey$220);</span>
      <span class="s4">for </span><span class="s2">(checked </span><span class="s4">in </span><span class="s2">nextProps)</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">((propKey$220 = nextProps[checked]),</span>
          <span class="s2">(propKey = lastProps[checked]),</span>
          <span class="s2">nextProps.hasOwnProperty(checked) &amp;&amp;</span>
            <span class="s2">propKey$220 !== propKey &amp;&amp;</span>
            <span class="s2">(</span><span class="s4">null </span><span class="s2">!= propKey$220 || </span><span class="s4">null </span><span class="s2">!= propKey))</span>
        <span class="s2">)</span>
          <span class="s4">switch </span><span class="s2">(checked) {</span>
            <span class="s4">case </span><span class="s3">&quot;children&quot;</span><span class="s2">:</span>
            <span class="s4">case </span><span class="s3">&quot;dangerouslySetInnerHTML&quot;</span><span class="s2">:</span>
              <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= propKey$220)</span>
                <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">137</span><span class="s2">, tag));</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">default</span><span class="s2">:</span>
              <span class="s2">setProp(</span>
                <span class="s2">domElement,</span>
                <span class="s2">tag,</span>
                <span class="s2">checked,</span>
                <span class="s2">propKey$220,</span>
                <span class="s2">nextProps,</span>
                <span class="s2">propKey</span>
              <span class="s2">);</span>
          <span class="s2">}</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(isCustomElement(tag)) {</span>
        <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">propKey$246 </span><span class="s4">in </span><span class="s2">lastProps)</span>
          <span class="s2">(propKey$220 = lastProps[propKey$246]),</span>
            <span class="s2">lastProps.hasOwnProperty(propKey$246) &amp;&amp;</span>
              <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== propKey$220 &amp;&amp;</span>
              <span class="s2">!nextProps.hasOwnProperty(propKey$246) &amp;&amp;</span>
              <span class="s2">setPropOnCustomElement(</span>
                <span class="s2">domElement,</span>
                <span class="s2">tag,</span>
                <span class="s2">propKey$246,</span>
                <span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
                <span class="s2">nextProps,</span>
                <span class="s2">propKey$220</span>
              <span class="s2">);</span>
        <span class="s4">for </span><span class="s2">(defaultChecked </span><span class="s4">in </span><span class="s2">nextProps)</span>
          <span class="s2">(propKey$220 = nextProps[defaultChecked]),</span>
            <span class="s2">(propKey = lastProps[defaultChecked]),</span>
            <span class="s2">!nextProps.hasOwnProperty(defaultChecked) ||</span>
              <span class="s2">propKey$220 === propKey ||</span>
              <span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== propKey$220 &amp;&amp; </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== propKey) ||</span>
              <span class="s2">setPropOnCustomElement(</span>
                <span class="s2">domElement,</span>
                <span class="s2">tag,</span>
                <span class="s2">defaultChecked,</span>
                <span class="s2">propKey$220,</span>
                <span class="s2">nextProps,</span>
                <span class="s2">propKey</span>
              <span class="s2">);</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">propKey$251 </span><span class="s4">in </span><span class="s2">lastProps)</span>
    <span class="s2">(propKey$220 = lastProps[propKey$251]),</span>
      <span class="s2">lastProps.hasOwnProperty(propKey$251) &amp;&amp;</span>
        <span class="s4">null </span><span class="s2">!= propKey$220 &amp;&amp;</span>
        <span class="s2">!nextProps.hasOwnProperty(propKey$251) &amp;&amp;</span>
        <span class="s2">setProp(domElement, tag, propKey$251, </span><span class="s4">null</span><span class="s2">, nextProps, propKey$220);</span>
  <span class="s4">for </span><span class="s2">(lastProp </span><span class="s4">in </span><span class="s2">nextProps)</span>
    <span class="s2">(propKey$220 = nextProps[lastProp]),</span>
      <span class="s2">(propKey = lastProps[lastProp]),</span>
      <span class="s2">!nextProps.hasOwnProperty(lastProp) ||</span>
        <span class="s2">propKey$220 === propKey ||</span>
        <span class="s2">(</span><span class="s4">null </span><span class="s2">== propKey$220 &amp;&amp; </span><span class="s4">null </span><span class="s2">== propKey) ||</span>
        <span class="s2">setProp(domElement, tag, lastProp, propKey$220, nextProps, propKey);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">eventsEnabled = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">selectionInformation = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">getOwnerDocumentFromRootContainer(rootContainerElement) {</span>
  <span class="s4">return </span><span class="s5">9 </span><span class="s2">=== rootContainerElement.nodeType</span>
    <span class="s2">? rootContainerElement</span>
    <span class="s2">: rootContainerElement.ownerDocument;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getOwnHostContext(namespaceURI) {</span>
  <span class="s4">switch </span><span class="s2">(namespaceURI) {</span>
    <span class="s4">case </span><span class="s3">&quot;http://www.w3.org/2000/svg&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s5">1</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;http://www.w3.org/1998/Math/MathML&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s5">2</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getChildHostContextProd(parentNamespace, type) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== parentNamespace)</span>
    <span class="s4">switch </span><span class="s2">(type) {</span>
      <span class="s4">case </span><span class="s3">&quot;svg&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s5">1</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s3">&quot;math&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s5">2</span><span class="s2">;</span>
      <span class="s4">default</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s4">return </span><span class="s5">1 </span><span class="s2">=== parentNamespace &amp;&amp; </span><span class="s3">&quot;foreignObject&quot; </span><span class="s2">=== type</span>
    <span class="s2">? </span><span class="s5">0</span>
    <span class="s2">: parentNamespace;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">shouldSetTextContent(type, props) {</span>
  <span class="s4">return </span><span class="s2">(</span>
    <span class="s3">&quot;textarea&quot; </span><span class="s2">=== type ||</span>
    <span class="s3">&quot;noscript&quot; </span><span class="s2">=== type ||</span>
    <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">props.children ||</span>
    <span class="s3">&quot;number&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">props.children ||</span>
    <span class="s3">&quot;bigint&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">props.children ||</span>
    <span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">props.dangerouslySetInnerHTML &amp;&amp;</span>
      <span class="s4">null </span><span class="s2">!== props.dangerouslySetInnerHTML &amp;&amp;</span>
      <span class="s4">null </span><span class="s2">!= props.dangerouslySetInnerHTML.__html)</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">currentPopstateTransitionEvent = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">shouldAttemptEagerTransition() {</span>
  <span class="s4">var </span><span class="s2">event = window.event;</span>
  <span class="s4">if </span><span class="s2">(event &amp;&amp; </span><span class="s3">&quot;popstate&quot; </span><span class="s2">=== event.type) {</span>
    <span class="s4">if </span><span class="s2">(event === currentPopstateTransitionEvent) </span><span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
    <span class="s2">currentPopstateTransitionEvent = event;</span>
    <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s2">currentPopstateTransitionEvent = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">scheduleTimeout = </span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">setTimeout ? setTimeout : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">cancelTimeout = </span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">clearTimeout ? clearTimeout : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">localPromise = </span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">Promise ? Promise : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">scheduleMicrotask =</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">queueMicrotask</span>
      <span class="s2">? queueMicrotask</span>
      <span class="s2">: </span><span class="s3">&quot;undefined&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">localPromise</span>
        <span class="s2">? </span><span class="s4">function </span><span class="s2">(callback) {</span>
            <span class="s4">return </span><span class="s2">localPromise</span>
              <span class="s2">.resolve(</span><span class="s4">null</span><span class="s2">)</span>
              <span class="s2">.then(callback)</span>
              <span class="s2">.catch(handleErrorInNextTick);</span>
          <span class="s2">}</span>
        <span class="s2">: scheduleTimeout;</span>
<span class="s4">function </span><span class="s2">handleErrorInNextTick(error) {</span>
  <span class="s2">setTimeout(</span><span class="s4">function </span><span class="s2">() {</span>
    <span class="s4">throw </span><span class="s2">error;</span>
  <span class="s2">});</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">isSingletonScope(type) {</span>
  <span class="s4">return </span><span class="s3">&quot;head&quot; </span><span class="s2">=== type;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">clearSuspenseBoundary(parentInstance, suspenseInstance) {</span>
  <span class="s4">var </span><span class="s2">node = suspenseInstance,</span>
    <span class="s2">possiblePreambleContribution = </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">depth = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">do </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">nextNode = node.nextSibling;</span>
    <span class="s2">parentInstance.removeChild(node);</span>
    <span class="s4">if </span><span class="s2">(nextNode &amp;&amp; </span><span class="s5">8 </span><span class="s2">=== nextNode.nodeType)</span>
      <span class="s4">if </span><span class="s2">(((node = nextNode.data), </span><span class="s3">&quot;/$&quot; </span><span class="s2">=== node)) {</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s5">0 </span><span class="s2">&lt; possiblePreambleContribution &amp;&amp;</span>
          <span class="s5">8 </span><span class="s2">&gt; possiblePreambleContribution</span>
        <span class="s2">) {</span>
          <span class="s2">node = possiblePreambleContribution;</span>
          <span class="s4">var </span><span class="s2">ownerDocument = parentInstance.ownerDocument;</span>
          <span class="s2">node &amp; </span><span class="s5">1 </span><span class="s2">&amp;&amp; releaseSingletonInstance(ownerDocument.documentElement);</span>
          <span class="s2">node &amp; </span><span class="s5">2 </span><span class="s2">&amp;&amp; releaseSingletonInstance(ownerDocument.body);</span>
          <span class="s4">if </span><span class="s2">(node &amp; </span><span class="s5">4</span><span class="s2">)</span>
            <span class="s4">for </span><span class="s2">(</span>
              <span class="s2">node = ownerDocument.head,</span>
                <span class="s2">releaseSingletonInstance(node),</span>
                <span class="s2">ownerDocument = node.firstChild;</span>
              <span class="s2">ownerDocument;</span>

            <span class="s2">) {</span>
              <span class="s4">var </span><span class="s2">nextNode$jscomp$0 = ownerDocument.nextSibling,</span>
                <span class="s2">nodeName = ownerDocument.nodeName;</span>
              <span class="s2">ownerDocument[internalHoistableMarker] ||</span>
                <span class="s3">&quot;SCRIPT&quot; </span><span class="s2">=== nodeName ||</span>
                <span class="s3">&quot;STYLE&quot; </span><span class="s2">=== nodeName ||</span>
                <span class="s2">(</span><span class="s3">&quot;LINK&quot; </span><span class="s2">=== nodeName &amp;&amp;</span>
                  <span class="s3">&quot;stylesheet&quot; </span><span class="s2">=== ownerDocument.rel.toLowerCase()) ||</span>
                <span class="s2">node.removeChild(ownerDocument);</span>
              <span class="s2">ownerDocument = nextNode$jscomp$0;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== depth) {</span>
          <span class="s2">parentInstance.removeChild(nextNode);</span>
          <span class="s2">retryIfBlockedOn(suspenseInstance);</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s2">depth--;</span>
      <span class="s2">} </span><span class="s4">else</span>
        <span class="s3">&quot;$&quot; </span><span class="s2">=== node || </span><span class="s3">&quot;$?&quot; </span><span class="s2">=== node || </span><span class="s3">&quot;$!&quot; </span><span class="s2">=== node</span>
          <span class="s2">? depth++</span>
          <span class="s2">: (possiblePreambleContribution = node.charCodeAt(</span><span class="s5">0</span><span class="s2">) - </span><span class="s5">48</span><span class="s2">);</span>
    <span class="s4">else </span><span class="s2">possiblePreambleContribution = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">node = nextNode;</span>
  <span class="s2">} </span><span class="s4">while </span><span class="s2">(node);</span>
  <span class="s2">retryIfBlockedOn(suspenseInstance);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">clearContainerSparingly(container) {</span>
  <span class="s4">var </span><span class="s2">nextNode = container.firstChild;</span>
  <span class="s2">nextNode &amp;&amp; </span><span class="s5">10 </span><span class="s2">=== nextNode.nodeType &amp;&amp; (nextNode = nextNode.nextSibling);</span>
  <span class="s4">for </span><span class="s2">(; nextNode; ) {</span>
    <span class="s4">var </span><span class="s2">node = nextNode;</span>
    <span class="s2">nextNode = nextNode.nextSibling;</span>
    <span class="s4">switch </span><span class="s2">(node.nodeName) {</span>
      <span class="s4">case </span><span class="s3">&quot;HTML&quot;</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">&quot;HEAD&quot;</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">&quot;BODY&quot;</span><span class="s2">:</span>
        <span class="s2">clearContainerSparingly(node);</span>
        <span class="s2">detachDeletedInstance(node);</span>
        <span class="s4">continue</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s3">&quot;SCRIPT&quot;</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">&quot;STYLE&quot;</span><span class="s2">:</span>
        <span class="s4">continue</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s3">&quot;LINK&quot;</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;stylesheet&quot; </span><span class="s2">=== node.rel.toLowerCase()) </span><span class="s4">continue</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s2">container.removeChild(node);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">canHydrateInstance(instance, type, props, inRootOrSingleton) {</span>
  <span class="s4">for </span><span class="s2">(; </span><span class="s5">1 </span><span class="s2">=== instance.nodeType; ) {</span>
    <span class="s4">var </span><span class="s2">anyProps = props;</span>
    <span class="s4">if </span><span class="s2">(instance.nodeName.toLowerCase() !== type.toLowerCase()) {</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">!inRootOrSingleton &amp;&amp;</span>
        <span class="s2">(</span><span class="s3">&quot;INPUT&quot; </span><span class="s2">!== instance.nodeName || </span><span class="s3">&quot;hidden&quot; </span><span class="s2">!== instance.type)</span>
      <span class="s2">)</span>
        <span class="s4">break</span><span class="s2">;</span>
    <span class="s2">} </span><span class="s4">else if </span><span class="s2">(!inRootOrSingleton)</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;input&quot; </span><span class="s2">=== type &amp;&amp; </span><span class="s3">&quot;hidden&quot; </span><span class="s2">=== instance.type) {</span>
        <span class="s4">var </span><span class="s2">name = </span><span class="s4">null </span><span class="s2">== anyProps.name ? </span><span class="s4">null </span><span class="s2">: </span><span class="s3">&quot;&quot; </span><span class="s2">+ anyProps.name;</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s3">&quot;hidden&quot; </span><span class="s2">=== anyProps.type &amp;&amp;</span>
          <span class="s2">instance.getAttribute(</span><span class="s3">&quot;name&quot;</span><span class="s2">) === name</span>
        <span class="s2">)</span>
          <span class="s4">return </span><span class="s2">instance;</span>
      <span class="s2">} </span><span class="s4">else return </span><span class="s2">instance;</span>
    <span class="s4">else if </span><span class="s2">(!instance[internalHoistableMarker])</span>
      <span class="s4">switch </span><span class="s2">(type) {</span>
        <span class="s4">case </span><span class="s3">&quot;meta&quot;</span><span class="s2">:</span>
          <span class="s4">if </span><span class="s2">(!instance.hasAttribute(</span><span class="s3">&quot;itemprop&quot;</span><span class="s2">)) </span><span class="s4">break</span><span class="s2">;</span>
          <span class="s4">return </span><span class="s2">instance;</span>
        <span class="s4">case </span><span class="s3">&quot;link&quot;</span><span class="s2">:</span>
          <span class="s2">name = instance.getAttribute(</span><span class="s3">&quot;rel&quot;</span><span class="s2">);</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;stylesheet&quot; </span><span class="s2">=== name &amp;&amp; instance.hasAttribute(</span><span class="s3">&quot;data-precedence&quot;</span><span class="s2">))</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">else if </span><span class="s2">(</span>
            <span class="s2">name !== anyProps.rel ||</span>
            <span class="s2">instance.getAttribute(</span><span class="s3">&quot;href&quot;</span><span class="s2">) !==</span>
              <span class="s2">(</span><span class="s4">null </span><span class="s2">== anyProps.href || </span><span class="s3">&quot;&quot; </span><span class="s2">=== anyProps.href</span>
                <span class="s2">? </span><span class="s4">null</span>
                <span class="s2">: anyProps.href) ||</span>
            <span class="s2">instance.getAttribute(</span><span class="s3">&quot;crossorigin&quot;</span><span class="s2">) !==</span>
              <span class="s2">(</span><span class="s4">null </span><span class="s2">== anyProps.crossOrigin ? </span><span class="s4">null </span><span class="s2">: anyProps.crossOrigin) ||</span>
            <span class="s2">instance.getAttribute(</span><span class="s3">&quot;title&quot;</span><span class="s2">) !==</span>
              <span class="s2">(</span><span class="s4">null </span><span class="s2">== anyProps.title ? </span><span class="s4">null </span><span class="s2">: anyProps.title)</span>
          <span class="s2">)</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">return </span><span class="s2">instance;</span>
        <span class="s4">case </span><span class="s3">&quot;style&quot;</span><span class="s2">:</span>
          <span class="s4">if </span><span class="s2">(instance.hasAttribute(</span><span class="s3">&quot;data-precedence&quot;</span><span class="s2">)) </span><span class="s4">break</span><span class="s2">;</span>
          <span class="s4">return </span><span class="s2">instance;</span>
        <span class="s4">case </span><span class="s3">&quot;script&quot;</span><span class="s2">:</span>
          <span class="s2">name = instance.getAttribute(</span><span class="s3">&quot;src&quot;</span><span class="s2">);</span>
          <span class="s4">if </span><span class="s2">(</span>
            <span class="s2">(name !== (</span><span class="s4">null </span><span class="s2">== anyProps.src ? </span><span class="s4">null </span><span class="s2">: anyProps.src) ||</span>
              <span class="s2">instance.getAttribute(</span><span class="s3">&quot;type&quot;</span><span class="s2">) !==</span>
                <span class="s2">(</span><span class="s4">null </span><span class="s2">== anyProps.type ? </span><span class="s4">null </span><span class="s2">: anyProps.type) ||</span>
              <span class="s2">instance.getAttribute(</span><span class="s3">&quot;crossorigin&quot;</span><span class="s2">) !==</span>
                <span class="s2">(</span><span class="s4">null </span><span class="s2">== anyProps.crossOrigin ? </span><span class="s4">null </span><span class="s2">: anyProps.crossOrigin)) &amp;&amp;</span>
            <span class="s2">name &amp;&amp;</span>
            <span class="s2">instance.hasAttribute(</span><span class="s3">&quot;async&quot;</span><span class="s2">) &amp;&amp;</span>
            <span class="s2">!instance.hasAttribute(</span><span class="s3">&quot;itemprop&quot;</span><span class="s2">)</span>
          <span class="s2">)</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">return </span><span class="s2">instance;</span>
        <span class="s4">default</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">instance;</span>
      <span class="s2">}</span>
    <span class="s2">instance = getNextHydratable(instance.nextSibling);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== instance) </span><span class="s4">break</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s4">return null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">canHydrateTextInstance(instance, text, inRootOrSingleton) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;&quot; </span><span class="s2">=== text) </span><span class="s4">return null</span><span class="s2">;</span>
  <span class="s4">for </span><span class="s2">(; </span><span class="s5">3 </span><span class="s2">!== instance.nodeType; ) {</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">(</span><span class="s5">1 </span><span class="s2">!== instance.nodeType ||</span>
        <span class="s3">&quot;INPUT&quot; </span><span class="s2">!== instance.nodeName ||</span>
        <span class="s3">&quot;hidden&quot; </span><span class="s2">!== instance.type) &amp;&amp;</span>
      <span class="s2">!inRootOrSingleton</span>
    <span class="s2">)</span>
      <span class="s4">return null</span><span class="s2">;</span>
    <span class="s2">instance = getNextHydratable(instance.nextSibling);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== instance) </span><span class="s4">return null</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">instance;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">isSuspenseInstanceFallback(instance) {</span>
  <span class="s4">return </span><span class="s2">(</span>
    <span class="s3">&quot;$!&quot; </span><span class="s2">=== instance.data ||</span>
    <span class="s2">(</span><span class="s3">&quot;$?&quot; </span><span class="s2">=== instance.data &amp;&amp; </span><span class="s3">&quot;complete&quot; </span><span class="s2">=== instance.ownerDocument.readyState)</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">registerSuspenseInstanceRetry(instance, callback) {</span>
  <span class="s4">var </span><span class="s2">ownerDocument = instance.ownerDocument;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;$?&quot; </span><span class="s2">!== instance.data || </span><span class="s3">&quot;complete&quot; </span><span class="s2">=== ownerDocument.readyState)</span>
    <span class="s2">callback();</span>
  <span class="s4">else </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">listener = </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s2">callback();</span>
      <span class="s2">ownerDocument.removeEventListener(</span><span class="s3">&quot;DOMContentLoaded&quot;</span><span class="s2">, listener);</span>
    <span class="s2">};</span>
    <span class="s2">ownerDocument.addEventListener(</span><span class="s3">&quot;DOMContentLoaded&quot;</span><span class="s2">, listener);</span>
    <span class="s2">instance._reactRetry = listener;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getNextHydratable(node) {</span>
  <span class="s4">for </span><span class="s2">(; </span><span class="s4">null </span><span class="s2">!= node; node = node.nextSibling) {</span>
    <span class="s4">var </span><span class="s2">nodeType = node.nodeType;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">1 </span><span class="s2">=== nodeType || </span><span class="s5">3 </span><span class="s2">=== nodeType) </span><span class="s4">break</span><span class="s2">;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">8 </span><span class="s2">=== nodeType) {</span>
      <span class="s2">nodeType = node.data;</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s3">&quot;$&quot; </span><span class="s2">=== nodeType ||</span>
        <span class="s3">&quot;$!&quot; </span><span class="s2">=== nodeType ||</span>
        <span class="s3">&quot;$?&quot; </span><span class="s2">=== nodeType ||</span>
        <span class="s3">&quot;F!&quot; </span><span class="s2">=== nodeType ||</span>
        <span class="s3">&quot;F&quot; </span><span class="s2">=== nodeType</span>
      <span class="s2">)</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;/$&quot; </span><span class="s2">=== nodeType) </span><span class="s4">return null</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">node;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">previousHydratableOnEnteringScopedSingleton = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">getParentSuspenseInstance(targetInstance) {</span>
  <span class="s2">targetInstance = targetInstance.previousSibling;</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">depth = </span><span class="s5">0</span><span class="s2">; targetInstance; ) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">8 </span><span class="s2">=== targetInstance.nodeType) {</span>
      <span class="s4">var </span><span class="s2">data = targetInstance.data;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;$&quot; </span><span class="s2">=== data || </span><span class="s3">&quot;$!&quot; </span><span class="s2">=== data || </span><span class="s3">&quot;$?&quot; </span><span class="s2">=== data) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== depth) </span><span class="s4">return </span><span class="s2">targetInstance;</span>
        <span class="s2">depth--;</span>
      <span class="s2">} </span><span class="s4">else </span><span class="s3">&quot;/$&quot; </span><span class="s2">=== data &amp;&amp; depth++;</span>
    <span class="s2">}</span>
    <span class="s2">targetInstance = targetInstance.previousSibling;</span>
  <span class="s2">}</span>
  <span class="s4">return null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">resolveSingletonInstance(type, props, rootContainerInstance) {</span>
  <span class="s2">props = getOwnerDocumentFromRootContainer(rootContainerInstance);</span>
  <span class="s4">switch </span><span class="s2">(type) {</span>
    <span class="s4">case </span><span class="s3">&quot;html&quot;</span><span class="s2">:</span>
      <span class="s2">type = props.documentElement;</span>
      <span class="s4">if </span><span class="s2">(!type) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">452</span><span class="s2">));</span>
      <span class="s4">return </span><span class="s2">type;</span>
    <span class="s4">case </span><span class="s3">&quot;head&quot;</span><span class="s2">:</span>
      <span class="s2">type = props.head;</span>
      <span class="s4">if </span><span class="s2">(!type) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">453</span><span class="s2">));</span>
      <span class="s4">return </span><span class="s2">type;</span>
    <span class="s4">case </span><span class="s3">&quot;body&quot;</span><span class="s2">:</span>
      <span class="s2">type = props.body;</span>
      <span class="s4">if </span><span class="s2">(!type) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">454</span><span class="s2">));</span>
      <span class="s4">return </span><span class="s2">type;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">451</span><span class="s2">));</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">releaseSingletonInstance(instance) {</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">attributes = instance.attributes; attributes.length; )</span>
    <span class="s2">instance.removeAttributeNode(attributes[</span><span class="s5">0</span><span class="s2">]);</span>
  <span class="s2">detachDeletedInstance(instance);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">preloadPropsMap = </span><span class="s4">new </span><span class="s2">Map(),</span>
  <span class="s2">preconnectsSet = </span><span class="s4">new </span><span class="s2">Set();</span>
<span class="s4">function </span><span class="s2">getHoistableRoot(container) {</span>
  <span class="s4">return </span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">container.getRootNode</span>
    <span class="s2">? container.getRootNode()</span>
    <span class="s2">: </span><span class="s5">9 </span><span class="s2">=== container.nodeType</span>
      <span class="s2">? container</span>
      <span class="s2">: container.ownerDocument;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">previousDispatcher = ReactDOMSharedInternals.d;</span>
<span class="s2">ReactDOMSharedInternals.d = {</span>
  <span class="s2">f: flushSyncWork,</span>
  <span class="s2">r: requestFormReset$1,</span>
  <span class="s2">D: prefetchDNS$1,</span>
  <span class="s2">C: preconnect$1,</span>
  <span class="s2">L: preload$1,</span>
  <span class="s2">m: preloadModule$1,</span>
  <span class="s2">X: preinitScript,</span>
  <span class="s2">S: preinitStyle,</span>
  <span class="s2">M: preinitModuleScript</span>
<span class="s2">};</span>
<span class="s4">function </span><span class="s2">flushSyncWork() {</span>
  <span class="s4">var </span><span class="s2">previousWasRendering = previousDispatcher.f(),</span>
    <span class="s2">wasRendering = flushSyncWork$1();</span>
  <span class="s4">return </span><span class="s2">previousWasRendering || wasRendering;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">requestFormReset$1(form) {</span>
  <span class="s4">var </span><span class="s2">formInst = getInstanceFromNode(form);</span>
  <span class="s4">null </span><span class="s2">!== formInst &amp;&amp; </span><span class="s5">5 </span><span class="s2">=== formInst.tag &amp;&amp; </span><span class="s3">&quot;form&quot; </span><span class="s2">=== formInst.type</span>
    <span class="s2">? requestFormReset$2(formInst)</span>
    <span class="s2">: previousDispatcher.r(form);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">globalDocument = </span><span class="s3">&quot;undefined&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">document ? </span><span class="s4">null </span><span class="s2">: document;</span>
<span class="s4">function </span><span class="s2">preconnectAs(rel, href, crossOrigin) {</span>
  <span class="s4">var </span><span class="s2">ownerDocument = globalDocument;</span>
  <span class="s4">if </span><span class="s2">(ownerDocument &amp;&amp; </span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">href &amp;&amp; href) {</span>
    <span class="s4">var </span><span class="s2">limitedEscapedHref =</span>
      <span class="s2">escapeSelectorAttributeValueInsideDoubleQuotes(href);</span>
    <span class="s2">limitedEscapedHref =</span>
      <span class="s3">'link[rel=&quot;' </span><span class="s2">+ rel + </span><span class="s3">'&quot;][href=&quot;' </span><span class="s2">+ limitedEscapedHref + </span><span class="s3">'&quot;]'</span><span class="s2">;</span>
    <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">crossOrigin &amp;&amp;</span>
      <span class="s2">(limitedEscapedHref += </span><span class="s3">'[crossorigin=&quot;' </span><span class="s2">+ crossOrigin + </span><span class="s3">'&quot;]'</span><span class="s2">);</span>
    <span class="s2">preconnectsSet.has(limitedEscapedHref) ||</span>
      <span class="s2">(preconnectsSet.add(limitedEscapedHref),</span>
      <span class="s2">(rel = { rel: rel, crossOrigin: crossOrigin, href: href }),</span>
      <span class="s4">null </span><span class="s2">=== ownerDocument.querySelector(limitedEscapedHref) &amp;&amp;</span>
        <span class="s2">((href = ownerDocument.createElement(</span><span class="s3">&quot;link&quot;</span><span class="s2">)),</span>
        <span class="s2">setInitialProperties(href, </span><span class="s3">&quot;link&quot;</span><span class="s2">, rel),</span>
        <span class="s2">markNodeAsHoistable(href),</span>
        <span class="s2">ownerDocument.head.appendChild(href)));</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">prefetchDNS$1(href) {</span>
  <span class="s2">previousDispatcher.D(href);</span>
  <span class="s2">preconnectAs(</span><span class="s3">&quot;dns-prefetch&quot;</span><span class="s2">, href, </span><span class="s4">null</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">preconnect$1(href, crossOrigin) {</span>
  <span class="s2">previousDispatcher.C(href, crossOrigin);</span>
  <span class="s2">preconnectAs(</span><span class="s3">&quot;preconnect&quot;</span><span class="s2">, href, crossOrigin);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">preload$1(href, as, options) {</span>
  <span class="s2">previousDispatcher.L(href, as, options);</span>
  <span class="s4">var </span><span class="s2">ownerDocument = globalDocument;</span>
  <span class="s4">if </span><span class="s2">(ownerDocument &amp;&amp; href &amp;&amp; as) {</span>
    <span class="s4">var </span><span class="s2">preloadSelector =</span>
      <span class="s3">'link[rel=&quot;preload&quot;][as=&quot;' </span><span class="s2">+</span>
      <span class="s2">escapeSelectorAttributeValueInsideDoubleQuotes(as) +</span>
      <span class="s3">'&quot;]'</span><span class="s2">;</span>
    <span class="s3">&quot;image&quot; </span><span class="s2">=== as</span>
      <span class="s2">? options &amp;&amp; options.imageSrcSet</span>
        <span class="s2">? ((preloadSelector +=</span>
            <span class="s3">'[imagesrcset=&quot;' </span><span class="s2">+</span>
            <span class="s2">escapeSelectorAttributeValueInsideDoubleQuotes(</span>
              <span class="s2">options.imageSrcSet</span>
            <span class="s2">) +</span>
            <span class="s3">'&quot;]'</span><span class="s2">),</span>
          <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options.imageSizes &amp;&amp;</span>
            <span class="s2">(preloadSelector +=</span>
              <span class="s3">'[imagesizes=&quot;' </span><span class="s2">+</span>
              <span class="s2">escapeSelectorAttributeValueInsideDoubleQuotes(</span>
                <span class="s2">options.imageSizes</span>
              <span class="s2">) +</span>
              <span class="s3">'&quot;]'</span><span class="s2">))</span>
        <span class="s2">: (preloadSelector +=</span>
            <span class="s3">'[href=&quot;' </span><span class="s2">+</span>
            <span class="s2">escapeSelectorAttributeValueInsideDoubleQuotes(href) +</span>
            <span class="s3">'&quot;]'</span><span class="s2">)</span>
      <span class="s2">: (preloadSelector +=</span>
          <span class="s3">'[href=&quot;' </span><span class="s2">+</span>
          <span class="s2">escapeSelectorAttributeValueInsideDoubleQuotes(href) +</span>
          <span class="s3">'&quot;]'</span><span class="s2">);</span>
    <span class="s4">var </span><span class="s2">key = preloadSelector;</span>
    <span class="s4">switch </span><span class="s2">(as) {</span>
      <span class="s4">case </span><span class="s3">&quot;style&quot;</span><span class="s2">:</span>
        <span class="s2">key = getStyleKey(href);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s3">&quot;script&quot;</span><span class="s2">:</span>
        <span class="s2">key = getScriptKey(href);</span>
    <span class="s2">}</span>
    <span class="s2">preloadPropsMap.has(key) ||</span>
      <span class="s2">((href = assign(</span>
        <span class="s2">{</span>
          <span class="s2">rel: </span><span class="s3">&quot;preload&quot;</span><span class="s2">,</span>
          <span class="s2">href:</span>
            <span class="s3">&quot;image&quot; </span><span class="s2">=== as &amp;&amp; options &amp;&amp; options.imageSrcSet ? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">: href,</span>
          <span class="s2">as: as</span>
        <span class="s2">},</span>
        <span class="s2">options</span>
      <span class="s2">)),</span>
      <span class="s2">preloadPropsMap.set(key, href),</span>
      <span class="s4">null </span><span class="s2">!== ownerDocument.querySelector(preloadSelector) ||</span>
        <span class="s2">(</span><span class="s3">&quot;style&quot; </span><span class="s2">=== as &amp;&amp;</span>
          <span class="s2">ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) ||</span>
        <span class="s2">(</span><span class="s3">&quot;script&quot; </span><span class="s2">=== as &amp;&amp;</span>
          <span class="s2">ownerDocument.querySelector(getScriptSelectorFromKey(key))) ||</span>
        <span class="s2">((as = ownerDocument.createElement(</span><span class="s3">&quot;link&quot;</span><span class="s2">)),</span>
        <span class="s2">setInitialProperties(as, </span><span class="s3">&quot;link&quot;</span><span class="s2">, href),</span>
        <span class="s2">markNodeAsHoistable(as),</span>
        <span class="s2">ownerDocument.head.appendChild(as)));</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">preloadModule$1(href, options) {</span>
  <span class="s2">previousDispatcher.m(href, options);</span>
  <span class="s4">var </span><span class="s2">ownerDocument = globalDocument;</span>
  <span class="s4">if </span><span class="s2">(ownerDocument &amp;&amp; href) {</span>
    <span class="s4">var </span><span class="s2">as = options &amp;&amp; </span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options.as ? options.as : </span><span class="s3">&quot;script&quot;</span><span class="s2">,</span>
      <span class="s2">preloadSelector =</span>
        <span class="s3">'link[rel=&quot;modulepreload&quot;][as=&quot;' </span><span class="s2">+</span>
        <span class="s2">escapeSelectorAttributeValueInsideDoubleQuotes(as) +</span>
        <span class="s3">'&quot;][href=&quot;' </span><span class="s2">+</span>
        <span class="s2">escapeSelectorAttributeValueInsideDoubleQuotes(href) +</span>
        <span class="s3">'&quot;]'</span><span class="s2">,</span>
      <span class="s2">key = preloadSelector;</span>
    <span class="s4">switch </span><span class="s2">(as) {</span>
      <span class="s4">case </span><span class="s3">&quot;audioworklet&quot;</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">&quot;paintworklet&quot;</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">&quot;serviceworker&quot;</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">&quot;sharedworker&quot;</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">&quot;worker&quot;</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">&quot;script&quot;</span><span class="s2">:</span>
        <span class="s2">key = getScriptKey(href);</span>
    <span class="s2">}</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">!preloadPropsMap.has(key) &amp;&amp;</span>
      <span class="s2">((href = assign({ rel: </span><span class="s3">&quot;modulepreload&quot;</span><span class="s2">, href: href }, options)),</span>
      <span class="s2">preloadPropsMap.set(key, href),</span>
      <span class="s4">null </span><span class="s2">=== ownerDocument.querySelector(preloadSelector))</span>
    <span class="s2">) {</span>
      <span class="s4">switch </span><span class="s2">(as) {</span>
        <span class="s4">case </span><span class="s3">&quot;audioworklet&quot;</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s3">&quot;paintworklet&quot;</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s3">&quot;serviceworker&quot;</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s3">&quot;sharedworker&quot;</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s3">&quot;worker&quot;</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s3">&quot;script&quot;</span><span class="s2">:</span>
          <span class="s4">if </span><span class="s2">(ownerDocument.querySelector(getScriptSelectorFromKey(key)))</span>
            <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s2">as = ownerDocument.createElement(</span><span class="s3">&quot;link&quot;</span><span class="s2">);</span>
      <span class="s2">setInitialProperties(as, </span><span class="s3">&quot;link&quot;</span><span class="s2">, href);</span>
      <span class="s2">markNodeAsHoistable(as);</span>
      <span class="s2">ownerDocument.head.appendChild(as);</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">preinitStyle(href, precedence, options) {</span>
  <span class="s2">previousDispatcher.S(href, precedence, options);</span>
  <span class="s4">var </span><span class="s2">ownerDocument = globalDocument;</span>
  <span class="s4">if </span><span class="s2">(ownerDocument &amp;&amp; href) {</span>
    <span class="s4">var </span><span class="s2">styles = getResourcesFromRoot(ownerDocument).hoistableStyles,</span>
      <span class="s2">key = getStyleKey(href);</span>
    <span class="s2">precedence = precedence || </span><span class="s3">&quot;default&quot;</span><span class="s2">;</span>
    <span class="s4">var </span><span class="s2">resource = styles.get(key);</span>
    <span class="s4">if </span><span class="s2">(!resource) {</span>
      <span class="s4">var </span><span class="s2">state = { loading: </span><span class="s5">0</span><span class="s2">, preload: </span><span class="s4">null </span><span class="s2">};</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">(resource = ownerDocument.querySelector(</span>
          <span class="s2">getStylesheetSelectorFromKey(key)</span>
        <span class="s2">))</span>
      <span class="s2">)</span>
        <span class="s2">state.loading = </span><span class="s5">5</span><span class="s2">;</span>
      <span class="s4">else </span><span class="s2">{</span>
        <span class="s2">href = assign(</span>
          <span class="s2">{ rel: </span><span class="s3">&quot;stylesheet&quot;</span><span class="s2">, href: href, </span><span class="s3">&quot;data-precedence&quot;</span><span class="s2">: precedence },</span>
          <span class="s2">options</span>
        <span class="s2">);</span>
        <span class="s2">(options = preloadPropsMap.get(key)) &amp;&amp;</span>
          <span class="s2">adoptPreloadPropsForStylesheet(href, options);</span>
        <span class="s4">var </span><span class="s2">link = (resource = ownerDocument.createElement(</span><span class="s3">&quot;link&quot;</span><span class="s2">));</span>
        <span class="s2">markNodeAsHoistable(link);</span>
        <span class="s2">setInitialProperties(link, </span><span class="s3">&quot;link&quot;</span><span class="s2">, href);</span>
        <span class="s2">link._p = </span><span class="s4">new </span><span class="s2">Promise(</span><span class="s4">function </span><span class="s2">(resolve, reject) {</span>
          <span class="s2">link.onload = resolve;</span>
          <span class="s2">link.onerror = reject;</span>
        <span class="s2">});</span>
        <span class="s2">link.addEventListener(</span><span class="s3">&quot;load&quot;</span><span class="s2">, </span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s2">state.loading |= </span><span class="s5">1</span><span class="s2">;</span>
        <span class="s2">});</span>
        <span class="s2">link.addEventListener(</span><span class="s3">&quot;error&quot;</span><span class="s2">, </span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s2">state.loading |= </span><span class="s5">2</span><span class="s2">;</span>
        <span class="s2">});</span>
        <span class="s2">state.loading |= </span><span class="s5">4</span><span class="s2">;</span>
        <span class="s2">insertStylesheet(resource, precedence, ownerDocument);</span>
      <span class="s2">}</span>
      <span class="s2">resource = {</span>
        <span class="s2">type: </span><span class="s3">&quot;stylesheet&quot;</span><span class="s2">,</span>
        <span class="s2">instance: resource,</span>
        <span class="s2">count: </span><span class="s5">1</span><span class="s2">,</span>
        <span class="s2">state: state</span>
      <span class="s2">};</span>
      <span class="s2">styles.set(key, resource);</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">preinitScript(src, options) {</span>
  <span class="s2">previousDispatcher.X(src, options);</span>
  <span class="s4">var </span><span class="s2">ownerDocument = globalDocument;</span>
  <span class="s4">if </span><span class="s2">(ownerDocument &amp;&amp; src) {</span>
    <span class="s4">var </span><span class="s2">scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,</span>
      <span class="s2">key = getScriptKey(src),</span>
      <span class="s2">resource = scripts.get(key);</span>
    <span class="s2">resource ||</span>
      <span class="s2">((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),</span>
      <span class="s2">resource ||</span>
        <span class="s2">((src = assign({ src: src, async: !</span><span class="s5">0 </span><span class="s2">}, options)),</span>
        <span class="s2">(options = preloadPropsMap.get(key)) &amp;&amp;</span>
          <span class="s2">adoptPreloadPropsForScript(src, options),</span>
        <span class="s2">(resource = ownerDocument.createElement(</span><span class="s3">&quot;script&quot;</span><span class="s2">)),</span>
        <span class="s2">markNodeAsHoistable(resource),</span>
        <span class="s2">setInitialProperties(resource, </span><span class="s3">&quot;link&quot;</span><span class="s2">, src),</span>
        <span class="s2">ownerDocument.head.appendChild(resource)),</span>
      <span class="s2">(resource = {</span>
        <span class="s2">type: </span><span class="s3">&quot;script&quot;</span><span class="s2">,</span>
        <span class="s2">instance: resource,</span>
        <span class="s2">count: </span><span class="s5">1</span><span class="s2">,</span>
        <span class="s2">state: </span><span class="s4">null</span>
      <span class="s2">}),</span>
      <span class="s2">scripts.set(key, resource));</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">preinitModuleScript(src, options) {</span>
  <span class="s2">previousDispatcher.M(src, options);</span>
  <span class="s4">var </span><span class="s2">ownerDocument = globalDocument;</span>
  <span class="s4">if </span><span class="s2">(ownerDocument &amp;&amp; src) {</span>
    <span class="s4">var </span><span class="s2">scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,</span>
      <span class="s2">key = getScriptKey(src),</span>
      <span class="s2">resource = scripts.get(key);</span>
    <span class="s2">resource ||</span>
      <span class="s2">((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),</span>
      <span class="s2">resource ||</span>
        <span class="s2">((src = assign({ src: src, async: !</span><span class="s5">0</span><span class="s2">, type: </span><span class="s3">&quot;module&quot; </span><span class="s2">}, options)),</span>
        <span class="s2">(options = preloadPropsMap.get(key)) &amp;&amp;</span>
          <span class="s2">adoptPreloadPropsForScript(src, options),</span>
        <span class="s2">(resource = ownerDocument.createElement(</span><span class="s3">&quot;script&quot;</span><span class="s2">)),</span>
        <span class="s2">markNodeAsHoistable(resource),</span>
        <span class="s2">setInitialProperties(resource, </span><span class="s3">&quot;link&quot;</span><span class="s2">, src),</span>
        <span class="s2">ownerDocument.head.appendChild(resource)),</span>
      <span class="s2">(resource = {</span>
        <span class="s2">type: </span><span class="s3">&quot;script&quot;</span><span class="s2">,</span>
        <span class="s2">instance: resource,</span>
        <span class="s2">count: </span><span class="s5">1</span><span class="s2">,</span>
        <span class="s2">state: </span><span class="s4">null</span>
      <span class="s2">}),</span>
      <span class="s2">scripts.set(key, resource));</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getResource(type, currentProps, pendingProps, currentResource) {</span>
  <span class="s4">var </span><span class="s2">JSCompiler_inline_result = (JSCompiler_inline_result =</span>
    <span class="s2">rootInstanceStackCursor.current)</span>
    <span class="s2">? getHoistableRoot(JSCompiler_inline_result)</span>
    <span class="s2">: </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(!JSCompiler_inline_result) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">446</span><span class="s2">));</span>
  <span class="s4">switch </span><span class="s2">(type) {</span>
    <span class="s4">case </span><span class="s3">&quot;meta&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;title&quot;</span><span class="s2">:</span>
      <span class="s4">return null</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;style&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">pendingProps.precedence &amp;&amp;</span>
        <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">pendingProps.href</span>
        <span class="s2">? ((currentProps = getStyleKey(pendingProps.href)),</span>
          <span class="s2">(pendingProps = getResourcesFromRoot(</span>
            <span class="s2">JSCompiler_inline_result</span>
          <span class="s2">).hoistableStyles),</span>
          <span class="s2">(currentResource = pendingProps.get(currentProps)),</span>
          <span class="s2">currentResource ||</span>
            <span class="s2">((currentResource = {</span>
              <span class="s2">type: </span><span class="s3">&quot;style&quot;</span><span class="s2">,</span>
              <span class="s2">instance: </span><span class="s4">null</span><span class="s2">,</span>
              <span class="s2">count: </span><span class="s5">0</span><span class="s2">,</span>
              <span class="s2">state: </span><span class="s4">null</span>
            <span class="s2">}),</span>
            <span class="s2">pendingProps.set(currentProps, currentResource)),</span>
          <span class="s2">currentResource)</span>
        <span class="s2">: { type: </span><span class="s3">&quot;void&quot;</span><span class="s2">, instance: </span><span class="s4">null</span><span class="s2">, count: </span><span class="s5">0</span><span class="s2">, state: </span><span class="s4">null </span><span class="s2">};</span>
    <span class="s4">case </span><span class="s3">&quot;link&quot;</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s3">&quot;stylesheet&quot; </span><span class="s2">=== pendingProps.rel &amp;&amp;</span>
        <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">pendingProps.href &amp;&amp;</span>
        <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">pendingProps.precedence</span>
      <span class="s2">) {</span>
        <span class="s2">type = getStyleKey(pendingProps.href);</span>
        <span class="s4">var </span><span class="s2">styles$259 = getResourcesFromRoot(</span>
            <span class="s2">JSCompiler_inline_result</span>
          <span class="s2">).hoistableStyles,</span>
          <span class="s2">resource$260 = styles$259.get(type);</span>
        <span class="s2">resource$260 ||</span>
          <span class="s2">((JSCompiler_inline_result =</span>
            <span class="s2">JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result),</span>
          <span class="s2">(resource$260 = {</span>
            <span class="s2">type: </span><span class="s3">&quot;stylesheet&quot;</span><span class="s2">,</span>
            <span class="s2">instance: </span><span class="s4">null</span><span class="s2">,</span>
            <span class="s2">count: </span><span class="s5">0</span><span class="s2">,</span>
            <span class="s2">state: { loading: </span><span class="s5">0</span><span class="s2">, preload: </span><span class="s4">null </span><span class="s2">}</span>
          <span class="s2">}),</span>
          <span class="s2">styles$259.set(type, resource$260),</span>
          <span class="s2">(styles$259 = JSCompiler_inline_result.querySelector(</span>
            <span class="s2">getStylesheetSelectorFromKey(type)</span>
          <span class="s2">)) &amp;&amp;</span>
            <span class="s2">!styles$259._p &amp;&amp;</span>
            <span class="s2">((resource$260.instance = styles$259),</span>
            <span class="s2">(resource$260.state.loading = </span><span class="s5">5</span><span class="s2">)),</span>
          <span class="s2">preloadPropsMap.has(type) ||</span>
            <span class="s2">((pendingProps = {</span>
              <span class="s2">rel: </span><span class="s3">&quot;preload&quot;</span><span class="s2">,</span>
              <span class="s2">as: </span><span class="s3">&quot;style&quot;</span><span class="s2">,</span>
              <span class="s2">href: pendingProps.href,</span>
              <span class="s2">crossOrigin: pendingProps.crossOrigin,</span>
              <span class="s2">integrity: pendingProps.integrity,</span>
              <span class="s2">media: pendingProps.media,</span>
              <span class="s2">hrefLang: pendingProps.hrefLang,</span>
              <span class="s2">referrerPolicy: pendingProps.referrerPolicy</span>
            <span class="s2">}),</span>
            <span class="s2">preloadPropsMap.set(type, pendingProps),</span>
            <span class="s2">styles$259 ||</span>
              <span class="s2">preloadStylesheet(</span>
                <span class="s2">JSCompiler_inline_result,</span>
                <span class="s2">type,</span>
                <span class="s2">pendingProps,</span>
                <span class="s2">resource$260.state</span>
              <span class="s2">)));</span>
        <span class="s4">if </span><span class="s2">(currentProps &amp;&amp; </span><span class="s4">null </span><span class="s2">=== currentResource)</span>
          <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">528</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s2">));</span>
        <span class="s4">return </span><span class="s2">resource$260;</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(currentProps &amp;&amp; </span><span class="s4">null </span><span class="s2">!== currentResource)</span>
        <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">529</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s2">));</span>
      <span class="s4">return null</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;script&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(currentProps = pendingProps.async),</span>
        <span class="s2">(pendingProps = pendingProps.src),</span>
        <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">pendingProps &amp;&amp;</span>
        <span class="s2">currentProps &amp;&amp;</span>
        <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">currentProps &amp;&amp;</span>
        <span class="s3">&quot;symbol&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">currentProps</span>
          <span class="s2">? ((currentProps = getScriptKey(pendingProps)),</span>
            <span class="s2">(pendingProps = getResourcesFromRoot(</span>
              <span class="s2">JSCompiler_inline_result</span>
            <span class="s2">).hoistableScripts),</span>
            <span class="s2">(currentResource = pendingProps.get(currentProps)),</span>
            <span class="s2">currentResource ||</span>
              <span class="s2">((currentResource = {</span>
                <span class="s2">type: </span><span class="s3">&quot;script&quot;</span><span class="s2">,</span>
                <span class="s2">instance: </span><span class="s4">null</span><span class="s2">,</span>
                <span class="s2">count: </span><span class="s5">0</span><span class="s2">,</span>
                <span class="s2">state: </span><span class="s4">null</span>
              <span class="s2">}),</span>
              <span class="s2">pendingProps.set(currentProps, currentResource)),</span>
            <span class="s2">currentResource)</span>
          <span class="s2">: { type: </span><span class="s3">&quot;void&quot;</span><span class="s2">, instance: </span><span class="s4">null</span><span class="s2">, count: </span><span class="s5">0</span><span class="s2">, state: </span><span class="s4">null </span><span class="s2">}</span>
      <span class="s2">);</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">444</span><span class="s2">, type));</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getStyleKey(href) {</span>
  <span class="s4">return </span><span class="s3">'href=&quot;' </span><span class="s2">+ escapeSelectorAttributeValueInsideDoubleQuotes(href) + </span><span class="s3">'&quot;'</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getStylesheetSelectorFromKey(key) {</span>
  <span class="s4">return </span><span class="s3">'link[rel=&quot;stylesheet&quot;][' </span><span class="s2">+ key + </span><span class="s3">&quot;]&quot;</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">stylesheetPropsFromRawProps(rawProps) {</span>
  <span class="s4">return </span><span class="s2">assign({}, rawProps, {</span>
    <span class="s3">&quot;data-precedence&quot;</span><span class="s2">: rawProps.precedence,</span>
    <span class="s2">precedence: </span><span class="s4">null</span>
  <span class="s2">});</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">preloadStylesheet(ownerDocument, key, preloadProps, state) {</span>
  <span class="s2">ownerDocument.querySelector(</span><span class="s3">'link[rel=&quot;preload&quot;][as=&quot;style&quot;][' </span><span class="s2">+ key + </span><span class="s3">&quot;]&quot;</span><span class="s2">)</span>
    <span class="s2">? (state.loading = </span><span class="s5">1</span><span class="s2">)</span>
    <span class="s2">: ((key = ownerDocument.createElement(</span><span class="s3">&quot;link&quot;</span><span class="s2">)),</span>
      <span class="s2">(state.preload = key),</span>
      <span class="s2">key.addEventListener(</span><span class="s3">&quot;load&quot;</span><span class="s2">, </span><span class="s4">function </span><span class="s2">() {</span>
        <span class="s4">return </span><span class="s2">(state.loading |= </span><span class="s5">1</span><span class="s2">);</span>
      <span class="s2">}),</span>
      <span class="s2">key.addEventListener(</span><span class="s3">&quot;error&quot;</span><span class="s2">, </span><span class="s4">function </span><span class="s2">() {</span>
        <span class="s4">return </span><span class="s2">(state.loading |= </span><span class="s5">2</span><span class="s2">);</span>
      <span class="s2">}),</span>
      <span class="s2">setInitialProperties(key, </span><span class="s3">&quot;link&quot;</span><span class="s2">, preloadProps),</span>
      <span class="s2">markNodeAsHoistable(key),</span>
      <span class="s2">ownerDocument.head.appendChild(key));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getScriptKey(src) {</span>
  <span class="s4">return </span><span class="s3">'[src=&quot;' </span><span class="s2">+ escapeSelectorAttributeValueInsideDoubleQuotes(src) + </span><span class="s3">'&quot;]'</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getScriptSelectorFromKey(key) {</span>
  <span class="s4">return </span><span class="s3">&quot;script[async]&quot; </span><span class="s2">+ key;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">acquireResource(hoistableRoot, resource, props) {</span>
  <span class="s2">resource.count++;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== resource.instance)</span>
    <span class="s4">switch </span><span class="s2">(resource.type) {</span>
      <span class="s4">case </span><span class="s3">&quot;style&quot;</span><span class="s2">:</span>
        <span class="s4">var </span><span class="s2">instance = hoistableRoot.querySelector(</span>
          <span class="s3">'style[data-href~=&quot;' </span><span class="s2">+</span>
            <span class="s2">escapeSelectorAttributeValueInsideDoubleQuotes(props.href) +</span>
            <span class="s3">'&quot;]'</span>
        <span class="s2">);</span>
        <span class="s4">if </span><span class="s2">(instance)</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s2">(resource.instance = instance),</span>
            <span class="s2">markNodeAsHoistable(instance),</span>
            <span class="s2">instance</span>
          <span class="s2">);</span>
        <span class="s4">var </span><span class="s2">styleProps = assign({}, props, {</span>
          <span class="s3">&quot;data-href&quot;</span><span class="s2">: props.href,</span>
          <span class="s3">&quot;data-precedence&quot;</span><span class="s2">: props.precedence,</span>
          <span class="s2">href: </span><span class="s4">null</span><span class="s2">,</span>
          <span class="s2">precedence: </span><span class="s4">null</span>
        <span class="s2">});</span>
        <span class="s2">instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(</span>
          <span class="s3">&quot;style&quot;</span>
        <span class="s2">);</span>
        <span class="s2">markNodeAsHoistable(instance);</span>
        <span class="s2">setInitialProperties(instance, </span><span class="s3">&quot;style&quot;</span><span class="s2">, styleProps);</span>
        <span class="s2">insertStylesheet(instance, props.precedence, hoistableRoot);</span>
        <span class="s4">return </span><span class="s2">(resource.instance = instance);</span>
      <span class="s4">case </span><span class="s3">&quot;stylesheet&quot;</span><span class="s2">:</span>
        <span class="s2">styleProps = getStyleKey(props.href);</span>
        <span class="s4">var </span><span class="s2">instance$265 = hoistableRoot.querySelector(</span>
          <span class="s2">getStylesheetSelectorFromKey(styleProps)</span>
        <span class="s2">);</span>
        <span class="s4">if </span><span class="s2">(instance$265)</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s2">(resource.state.loading |= </span><span class="s5">4</span><span class="s2">),</span>
            <span class="s2">(resource.instance = instance$265),</span>
            <span class="s2">markNodeAsHoistable(instance$265),</span>
            <span class="s2">instance$265</span>
          <span class="s2">);</span>
        <span class="s2">instance = stylesheetPropsFromRawProps(props);</span>
        <span class="s2">(styleProps = preloadPropsMap.get(styleProps)) &amp;&amp;</span>
          <span class="s2">adoptPreloadPropsForStylesheet(instance, styleProps);</span>
        <span class="s2">instance$265 = (</span>
          <span class="s2">hoistableRoot.ownerDocument || hoistableRoot</span>
        <span class="s2">).createElement(</span><span class="s3">&quot;link&quot;</span><span class="s2">);</span>
        <span class="s2">markNodeAsHoistable(instance$265);</span>
        <span class="s4">var </span><span class="s2">linkInstance = instance$265;</span>
        <span class="s2">linkInstance._p = </span><span class="s4">new </span><span class="s2">Promise(</span><span class="s4">function </span><span class="s2">(resolve, reject) {</span>
          <span class="s2">linkInstance.onload = resolve;</span>
          <span class="s2">linkInstance.onerror = reject;</span>
        <span class="s2">});</span>
        <span class="s2">setInitialProperties(instance$265, </span><span class="s3">&quot;link&quot;</span><span class="s2">, instance);</span>
        <span class="s2">resource.state.loading |= </span><span class="s5">4</span><span class="s2">;</span>
        <span class="s2">insertStylesheet(instance$265, props.precedence, hoistableRoot);</span>
        <span class="s4">return </span><span class="s2">(resource.instance = instance$265);</span>
      <span class="s4">case </span><span class="s3">&quot;script&quot;</span><span class="s2">:</span>
        <span class="s2">instance$265 = getScriptKey(props.src);</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">(styleProps = hoistableRoot.querySelector(</span>
            <span class="s2">getScriptSelectorFromKey(instance$265)</span>
          <span class="s2">))</span>
        <span class="s2">)</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s2">(resource.instance = styleProps),</span>
            <span class="s2">markNodeAsHoistable(styleProps),</span>
            <span class="s2">styleProps</span>
          <span class="s2">);</span>
        <span class="s2">instance = props;</span>
        <span class="s4">if </span><span class="s2">((styleProps = preloadPropsMap.get(instance$265)))</span>
          <span class="s2">(instance = assign({}, props)),</span>
            <span class="s2">adoptPreloadPropsForScript(instance, styleProps);</span>
        <span class="s2">hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;</span>
        <span class="s2">styleProps = hoistableRoot.createElement(</span><span class="s3">&quot;script&quot;</span><span class="s2">);</span>
        <span class="s2">markNodeAsHoistable(styleProps);</span>
        <span class="s2">setInitialProperties(styleProps, </span><span class="s3">&quot;link&quot;</span><span class="s2">, instance);</span>
        <span class="s2">hoistableRoot.head.appendChild(styleProps);</span>
        <span class="s4">return </span><span class="s2">(resource.instance = styleProps);</span>
      <span class="s4">case </span><span class="s3">&quot;void&quot;</span><span class="s2">:</span>
        <span class="s4">return null</span><span class="s2">;</span>
      <span class="s4">default</span><span class="s2">:</span>
        <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">443</span><span class="s2">, resource.type));</span>
    <span class="s2">}</span>
  <span class="s4">else</span>
    <span class="s3">&quot;stylesheet&quot; </span><span class="s2">=== resource.type &amp;&amp;</span>
      <span class="s5">0 </span><span class="s2">=== (resource.state.loading &amp; </span><span class="s5">4</span><span class="s2">) &amp;&amp;</span>
      <span class="s2">((instance = resource.instance),</span>
      <span class="s2">(resource.state.loading |= </span><span class="s5">4</span><span class="s2">),</span>
      <span class="s2">insertStylesheet(instance, props.precedence, hoistableRoot));</span>
  <span class="s4">return </span><span class="s2">resource.instance;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">insertStylesheet(instance, precedence, root) {</span>
  <span class="s4">for </span><span class="s2">(</span>
    <span class="s4">var </span><span class="s2">nodes = root.querySelectorAll(</span>
        <span class="s3">'link[rel=&quot;stylesheet&quot;][data-precedence],style[data-precedence]'</span>
      <span class="s2">),</span>
      <span class="s2">last = nodes.length ? nodes[nodes.length - </span><span class="s5">1</span><span class="s2">] : </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">prior = last,</span>
      <span class="s2">i = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">i &lt; nodes.length;</span>
    <span class="s2">i++</span>
  <span class="s2">) {</span>
    <span class="s4">var </span><span class="s2">node = nodes[i];</span>
    <span class="s4">if </span><span class="s2">(node.dataset.precedence === precedence) prior = node;</span>
    <span class="s4">else if </span><span class="s2">(prior !== last) </span><span class="s4">break</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s2">prior</span>
    <span class="s2">? prior.parentNode.insertBefore(instance, prior.nextSibling)</span>
    <span class="s2">: ((precedence = </span><span class="s5">9 </span><span class="s2">=== root.nodeType ? root.head : root),</span>
      <span class="s2">precedence.insertBefore(instance, precedence.firstChild));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {</span>
  <span class="s4">null </span><span class="s2">== stylesheetProps.crossOrigin &amp;&amp;</span>
    <span class="s2">(stylesheetProps.crossOrigin = preloadProps.crossOrigin);</span>
  <span class="s4">null </span><span class="s2">== stylesheetProps.referrerPolicy &amp;&amp;</span>
    <span class="s2">(stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);</span>
  <span class="s4">null </span><span class="s2">== stylesheetProps.title &amp;&amp; (stylesheetProps.title = preloadProps.title);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">adoptPreloadPropsForScript(scriptProps, preloadProps) {</span>
  <span class="s4">null </span><span class="s2">== scriptProps.crossOrigin &amp;&amp;</span>
    <span class="s2">(scriptProps.crossOrigin = preloadProps.crossOrigin);</span>
  <span class="s4">null </span><span class="s2">== scriptProps.referrerPolicy &amp;&amp;</span>
    <span class="s2">(scriptProps.referrerPolicy = preloadProps.referrerPolicy);</span>
  <span class="s4">null </span><span class="s2">== scriptProps.integrity &amp;&amp;</span>
    <span class="s2">(scriptProps.integrity = preloadProps.integrity);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">tagCaches = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">getHydratableHoistableCache(type, keyAttribute, ownerDocument) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== tagCaches) {</span>
    <span class="s4">var </span><span class="s2">cache = </span><span class="s4">new </span><span class="s2">Map();</span>
    <span class="s4">var </span><span class="s2">caches = (tagCaches = </span><span class="s4">new </span><span class="s2">Map());</span>
    <span class="s2">caches.set(ownerDocument, cache);</span>
  <span class="s2">} </span><span class="s4">else</span>
    <span class="s2">(caches = tagCaches),</span>
      <span class="s2">(cache = caches.get(ownerDocument)),</span>
      <span class="s2">cache || ((cache = </span><span class="s4">new </span><span class="s2">Map()), caches.set(ownerDocument, cache));</span>
  <span class="s4">if </span><span class="s2">(cache.has(type)) </span><span class="s4">return </span><span class="s2">cache;</span>
  <span class="s2">cache.set(type, </span><span class="s4">null</span><span class="s2">);</span>
  <span class="s2">ownerDocument = ownerDocument.getElementsByTagName(type);</span>
  <span class="s4">for </span><span class="s2">(caches = </span><span class="s5">0</span><span class="s2">; caches &lt; ownerDocument.length; caches++) {</span>
    <span class="s4">var </span><span class="s2">node = ownerDocument[caches];</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">!(</span>
        <span class="s2">node[internalHoistableMarker] ||</span>
        <span class="s2">node[internalInstanceKey] ||</span>
        <span class="s2">(</span><span class="s3">&quot;link&quot; </span><span class="s2">=== type &amp;&amp; </span><span class="s3">&quot;stylesheet&quot; </span><span class="s2">=== node.getAttribute(</span><span class="s3">&quot;rel&quot;</span><span class="s2">))</span>
      <span class="s2">) &amp;&amp;</span>
      <span class="s3">&quot;http://www.w3.org/2000/svg&quot; </span><span class="s2">!== node.namespaceURI</span>
    <span class="s2">) {</span>
      <span class="s4">var </span><span class="s2">nodeKey = node.getAttribute(keyAttribute) || </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
      <span class="s2">nodeKey = type + nodeKey;</span>
      <span class="s4">var </span><span class="s2">existing = cache.get(nodeKey);</span>
      <span class="s2">existing ? existing.push(node) : cache.set(nodeKey, [node]);</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">cache;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">mountHoistable(hoistableRoot, type, instance) {</span>
  <span class="s2">hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;</span>
  <span class="s2">hoistableRoot.head.insertBefore(</span>
    <span class="s2">instance,</span>
    <span class="s3">&quot;title&quot; </span><span class="s2">=== type ? hoistableRoot.querySelector(</span><span class="s3">&quot;head &gt; title&quot;</span><span class="s2">) : </span><span class="s4">null</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">isHostHoistableType(type, props, hostContext) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">1 </span><span class="s2">=== hostContext || </span><span class="s4">null </span><span class="s2">!= props.itemProp) </span><span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">switch </span><span class="s2">(type) {</span>
    <span class="s4">case </span><span class="s3">&quot;meta&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;title&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;style&quot;</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s3">&quot;string&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">props.precedence ||</span>
        <span class="s3">&quot;string&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">props.href ||</span>
        <span class="s3">&quot;&quot; </span><span class="s2">=== props.href</span>
      <span class="s2">)</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;link&quot;</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s3">&quot;string&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">props.rel ||</span>
        <span class="s3">&quot;string&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">props.href ||</span>
        <span class="s3">&quot;&quot; </span><span class="s2">=== props.href ||</span>
        <span class="s2">props.onLoad ||</span>
        <span class="s2">props.onError</span>
      <span class="s2">)</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">switch </span><span class="s2">(props.rel) {</span>
        <span class="s4">case </span><span class="s3">&quot;stylesheet&quot;</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s2">(type = props.disabled),</span>
            <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">props.precedence &amp;&amp; </span><span class="s4">null </span><span class="s2">== type</span>
          <span class="s2">);</span>
        <span class="s4">default</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
      <span class="s2">}</span>
    <span class="s4">case </span><span class="s3">&quot;script&quot;</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">props.async &amp;&amp;</span>
        <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">props.async &amp;&amp;</span>
        <span class="s3">&quot;symbol&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">props.async &amp;&amp;</span>
        <span class="s2">!props.onLoad &amp;&amp;</span>
        <span class="s2">!props.onError &amp;&amp;</span>
        <span class="s2">props.src &amp;&amp;</span>
        <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">props.src</span>
      <span class="s2">)</span>
        <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">preloadResource(resource) {</span>
  <span class="s4">return </span><span class="s3">&quot;stylesheet&quot; </span><span class="s2">=== resource.type &amp;&amp; </span><span class="s5">0 </span><span class="s2">=== (resource.state.loading &amp; </span><span class="s5">3</span><span class="s2">)</span>
    <span class="s2">? !</span><span class="s5">1</span>
    <span class="s2">: !</span><span class="s5">0</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">suspendedState = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">noop$1() {}</span>
<span class="s4">function </span><span class="s2">suspendResource(hoistableRoot, resource, props) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== suspendedState) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">475</span><span class="s2">));</span>
  <span class="s4">var </span><span class="s2">state = suspendedState;</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s3">&quot;stylesheet&quot; </span><span class="s2">=== resource.type &amp;&amp;</span>
    <span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">props.media ||</span>
      <span class="s2">!</span><span class="s5">1 </span><span class="s2">!== matchMedia(props.media).matches) &amp;&amp;</span>
    <span class="s5">0 </span><span class="s2">=== (resource.state.loading &amp; </span><span class="s5">4</span><span class="s2">)</span>
  <span class="s2">) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== resource.instance) {</span>
      <span class="s4">var </span><span class="s2">key = getStyleKey(props.href),</span>
        <span class="s2">instance = hoistableRoot.querySelector(</span>
          <span class="s2">getStylesheetSelectorFromKey(key)</span>
        <span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(instance) {</span>
        <span class="s2">hoistableRoot = instance._p;</span>
        <span class="s4">null </span><span class="s2">!== hoistableRoot &amp;&amp;</span>
          <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">hoistableRoot &amp;&amp;</span>
          <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">hoistableRoot.then &amp;&amp;</span>
          <span class="s2">(state.count++,</span>
          <span class="s2">(state = onUnsuspend.bind(state)),</span>
          <span class="s2">hoistableRoot.then(state, state));</span>
        <span class="s2">resource.state.loading |= </span><span class="s5">4</span><span class="s2">;</span>
        <span class="s2">resource.instance = instance;</span>
        <span class="s2">markNodeAsHoistable(instance);</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s2">instance = hoistableRoot.ownerDocument || hoistableRoot;</span>
      <span class="s2">props = stylesheetPropsFromRawProps(props);</span>
      <span class="s2">(key = preloadPropsMap.get(key)) &amp;&amp;</span>
        <span class="s2">adoptPreloadPropsForStylesheet(props, key);</span>
      <span class="s2">instance = instance.createElement(</span><span class="s3">&quot;link&quot;</span><span class="s2">);</span>
      <span class="s2">markNodeAsHoistable(instance);</span>
      <span class="s4">var </span><span class="s2">linkInstance = instance;</span>
      <span class="s2">linkInstance._p = </span><span class="s4">new </span><span class="s2">Promise(</span><span class="s4">function </span><span class="s2">(resolve, reject) {</span>
        <span class="s2">linkInstance.onload = resolve;</span>
        <span class="s2">linkInstance.onerror = reject;</span>
      <span class="s2">});</span>
      <span class="s2">setInitialProperties(instance, </span><span class="s3">&quot;link&quot;</span><span class="s2">, props);</span>
      <span class="s2">resource.instance = instance;</span>
    <span class="s2">}</span>
    <span class="s4">null </span><span class="s2">=== state.stylesheets &amp;&amp; (state.stylesheets = </span><span class="s4">new </span><span class="s2">Map());</span>
    <span class="s2">state.stylesheets.set(resource, hoistableRoot);</span>
    <span class="s2">(hoistableRoot = resource.state.preload) &amp;&amp;</span>
      <span class="s5">0 </span><span class="s2">=== (resource.state.loading &amp; </span><span class="s5">3</span><span class="s2">) &amp;&amp;</span>
      <span class="s2">(state.count++,</span>
      <span class="s2">(resource = onUnsuspend.bind(state)),</span>
      <span class="s2">hoistableRoot.addEventListener(</span><span class="s3">&quot;load&quot;</span><span class="s2">, resource),</span>
      <span class="s2">hoistableRoot.addEventListener(</span><span class="s3">&quot;error&quot;</span><span class="s2">, resource));</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">waitForCommitToBeReady() {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== suspendedState) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">475</span><span class="s2">));</span>
  <span class="s4">var </span><span class="s2">state = suspendedState;</span>
  <span class="s2">state.stylesheets &amp;&amp;</span>
    <span class="s5">0 </span><span class="s2">=== state.count &amp;&amp;</span>
    <span class="s2">insertSuspendedStylesheets(state, state.stylesheets);</span>
  <span class="s4">return </span><span class="s5">0 </span><span class="s2">&lt; state.count</span>
    <span class="s2">? </span><span class="s4">function </span><span class="s2">(commit) {</span>
        <span class="s4">var </span><span class="s2">stylesheetTimer = setTimeout(</span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s2">state.stylesheets &amp;&amp;</span>
            <span class="s2">insertSuspendedStylesheets(state, state.stylesheets);</span>
          <span class="s4">if </span><span class="s2">(state.unsuspend) {</span>
            <span class="s4">var </span><span class="s2">unsuspend = state.unsuspend;</span>
            <span class="s2">state.unsuspend = </span><span class="s4">null</span><span class="s2">;</span>
            <span class="s2">unsuspend();</span>
          <span class="s2">}</span>
        <span class="s2">}, </span><span class="s5">6e4</span><span class="s2">);</span>
        <span class="s2">state.unsuspend = commit;</span>
        <span class="s4">return function </span><span class="s2">() {</span>
          <span class="s2">state.unsuspend = </span><span class="s4">null</span><span class="s2">;</span>
          <span class="s2">clearTimeout(stylesheetTimer);</span>
        <span class="s2">};</span>
      <span class="s2">}</span>
    <span class="s2">: </span><span class="s4">null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">onUnsuspend() {</span>
  <span class="s4">this</span><span class="s2">.count--;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== </span><span class="s4">this</span><span class="s2">.count)</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">this</span><span class="s2">.stylesheets) insertSuspendedStylesheets(</span><span class="s4">this</span><span class="s2">, </span><span class="s4">this</span><span class="s2">.stylesheets);</span>
    <span class="s4">else if </span><span class="s2">(</span><span class="s4">this</span><span class="s2">.unsuspend) {</span>
      <span class="s4">var </span><span class="s2">unsuspend = </span><span class="s4">this</span><span class="s2">.unsuspend;</span>
      <span class="s4">this</span><span class="s2">.unsuspend = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">unsuspend();</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">precedencesByRoot = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">insertSuspendedStylesheets(state, resources) {</span>
  <span class="s2">state.stylesheets = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">null </span><span class="s2">!== state.unsuspend &amp;&amp;</span>
    <span class="s2">(state.count++,</span>
    <span class="s2">(precedencesByRoot = </span><span class="s4">new </span><span class="s2">Map()),</span>
    <span class="s2">resources.forEach(insertStylesheetIntoRoot, state),</span>
    <span class="s2">(precedencesByRoot = </span><span class="s4">null</span><span class="s2">),</span>
    <span class="s2">onUnsuspend.call(state));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">insertStylesheetIntoRoot(root, resource) {</span>
  <span class="s4">if </span><span class="s2">(!(resource.state.loading &amp; </span><span class="s5">4</span><span class="s2">)) {</span>
    <span class="s4">var </span><span class="s2">precedences = precedencesByRoot.get(root);</span>
    <span class="s4">if </span><span class="s2">(precedences) </span><span class="s4">var </span><span class="s2">last = precedences.get(</span><span class="s4">null</span><span class="s2">);</span>
    <span class="s4">else </span><span class="s2">{</span>
      <span class="s2">precedences = </span><span class="s4">new </span><span class="s2">Map();</span>
      <span class="s2">precedencesByRoot.set(root, precedences);</span>
      <span class="s4">for </span><span class="s2">(</span>
        <span class="s4">var </span><span class="s2">nodes = root.querySelectorAll(</span>
            <span class="s3">&quot;link[data-precedence],style[data-precedence]&quot;</span>
          <span class="s2">),</span>
          <span class="s2">i = </span><span class="s5">0</span><span class="s2">;</span>
        <span class="s2">i &lt; nodes.length;</span>
        <span class="s2">i++</span>
      <span class="s2">) {</span>
        <span class="s4">var </span><span class="s2">node = nodes[i];</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s3">&quot;LINK&quot; </span><span class="s2">=== node.nodeName ||</span>
          <span class="s3">&quot;not all&quot; </span><span class="s2">!== node.getAttribute(</span><span class="s3">&quot;media&quot;</span><span class="s2">)</span>
        <span class="s2">)</span>
          <span class="s2">precedences.set(node.dataset.precedence, node), (last = node);</span>
      <span class="s2">}</span>
      <span class="s2">last &amp;&amp; precedences.set(</span><span class="s4">null</span><span class="s2">, last);</span>
    <span class="s2">}</span>
    <span class="s2">nodes = resource.instance;</span>
    <span class="s2">node = nodes.getAttribute(</span><span class="s3">&quot;data-precedence&quot;</span><span class="s2">);</span>
    <span class="s2">i = precedences.get(node) || last;</span>
    <span class="s2">i === last &amp;&amp; precedences.set(</span><span class="s4">null</span><span class="s2">, nodes);</span>
    <span class="s2">precedences.set(node, nodes);</span>
    <span class="s4">this</span><span class="s2">.count++;</span>
    <span class="s2">last = onUnsuspend.bind(</span><span class="s4">this</span><span class="s2">);</span>
    <span class="s2">nodes.addEventListener(</span><span class="s3">&quot;load&quot;</span><span class="s2">, last);</span>
    <span class="s2">nodes.addEventListener(</span><span class="s3">&quot;error&quot;</span><span class="s2">, last);</span>
    <span class="s2">i</span>
      <span class="s2">? i.parentNode.insertBefore(nodes, i.nextSibling)</span>
      <span class="s2">: ((root = </span><span class="s5">9 </span><span class="s2">=== root.nodeType ? root.head : root),</span>
        <span class="s2">root.insertBefore(nodes, root.firstChild));</span>
    <span class="s2">resource.state.loading |= </span><span class="s5">4</span><span class="s2">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">HostTransitionContext = {</span>
  <span class="s2">$$typeof: REACT_CONTEXT_TYPE,</span>
  <span class="s2">Provider: </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">Consumer: </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">_currentValue: sharedNotPendingObject,</span>
  <span class="s2">_currentValue2: sharedNotPendingObject,</span>
  <span class="s2">_threadCount: </span><span class="s5">0</span>
<span class="s2">};</span>
<span class="s4">function </span><span class="s2">FiberRootNode(</span>
  <span class="s2">containerInfo,</span>
  <span class="s2">tag,</span>
  <span class="s2">hydrate,</span>
  <span class="s2">identifierPrefix,</span>
  <span class="s2">onUncaughtError,</span>
  <span class="s2">onCaughtError,</span>
  <span class="s2">onRecoverableError,</span>
  <span class="s2">formState</span>
<span class="s2">) {</span>
  <span class="s4">this</span><span class="s2">.tag = </span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.containerInfo = containerInfo;</span>
  <span class="s4">this</span><span class="s2">.pingCache = </span><span class="s4">this</span><span class="s2">.current = </span><span class="s4">this</span><span class="s2">.pendingChildren = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.timeoutHandle = -</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.callbackNode =</span>
    <span class="s4">this</span><span class="s2">.next =</span>
    <span class="s4">this</span><span class="s2">.pendingContext =</span>
    <span class="s4">this</span><span class="s2">.context =</span>
    <span class="s4">this</span><span class="s2">.cancelPendingCommit =</span>
      <span class="s4">null</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.callbackPriority = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.expirationTimes = createLaneMap(-</span><span class="s5">1</span><span class="s2">);</span>
  <span class="s4">this</span><span class="s2">.entangledLanes =</span>
    <span class="s4">this</span><span class="s2">.shellSuspendCounter =</span>
    <span class="s4">this</span><span class="s2">.errorRecoveryDisabledLanes =</span>
    <span class="s4">this</span><span class="s2">.expiredLanes =</span>
    <span class="s4">this</span><span class="s2">.warmLanes =</span>
    <span class="s4">this</span><span class="s2">.pingedLanes =</span>
    <span class="s4">this</span><span class="s2">.suspendedLanes =</span>
    <span class="s4">this</span><span class="s2">.pendingLanes =</span>
      <span class="s5">0</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.entanglements = createLaneMap(</span><span class="s5">0</span><span class="s2">);</span>
  <span class="s4">this</span><span class="s2">.hiddenUpdates = createLaneMap(</span><span class="s4">null</span><span class="s2">);</span>
  <span class="s4">this</span><span class="s2">.identifierPrefix = identifierPrefix;</span>
  <span class="s4">this</span><span class="s2">.onUncaughtError = onUncaughtError;</span>
  <span class="s4">this</span><span class="s2">.onCaughtError = onCaughtError;</span>
  <span class="s4">this</span><span class="s2">.onRecoverableError = onRecoverableError;</span>
  <span class="s4">this</span><span class="s2">.pooledCache = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.pooledCacheLanes = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.formState = formState;</span>
  <span class="s4">this</span><span class="s2">.incompleteTransitions = </span><span class="s4">new </span><span class="s2">Map();</span>
  <span class="s4">this</span><span class="s2">.passiveEffectDuration = </span><span class="s4">this</span><span class="s2">.effectDuration = -</span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.memoizedUpdaters = </span><span class="s4">new </span><span class="s2">Set();</span>
  <span class="s2">containerInfo = </span><span class="s4">this</span><span class="s2">.pendingUpdatersLaneMap = [];</span>
  <span class="s4">for </span><span class="s2">(tag = </span><span class="s5">0</span><span class="s2">; </span><span class="s5">31 </span><span class="s2">&gt; tag; tag++) containerInfo.push(</span><span class="s4">new </span><span class="s2">Set());</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createFiberRoot(</span>
  <span class="s2">containerInfo,</span>
  <span class="s2">tag,</span>
  <span class="s2">hydrate,</span>
  <span class="s2">initialChildren,</span>
  <span class="s2">hydrationCallbacks,</span>
  <span class="s2">isStrictMode,</span>
  <span class="s2">identifierPrefix,</span>
  <span class="s2">onUncaughtError,</span>
  <span class="s2">onCaughtError,</span>
  <span class="s2">onRecoverableError,</span>
  <span class="s2">transitionCallbacks,</span>
  <span class="s2">formState</span>
<span class="s2">) {</span>
  <span class="s2">containerInfo = </span><span class="s4">new </span><span class="s2">FiberRootNode(</span>
    <span class="s2">containerInfo,</span>
    <span class="s2">tag,</span>
    <span class="s2">hydrate,</span>
    <span class="s2">identifierPrefix,</span>
    <span class="s2">onUncaughtError,</span>
    <span class="s2">onCaughtError,</span>
    <span class="s2">onRecoverableError,</span>
    <span class="s2">formState</span>
  <span class="s2">);</span>
  <span class="s2">tag = </span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">!</span><span class="s5">0 </span><span class="s2">=== isStrictMode &amp;&amp; (tag |= </span><span class="s5">24</span><span class="s2">);</span>
  <span class="s2">isDevToolsPresent &amp;&amp; (tag |= </span><span class="s5">2</span><span class="s2">);</span>
  <span class="s2">isStrictMode = createFiberImplClass(</span><span class="s5">3</span><span class="s2">, </span><span class="s4">null</span><span class="s2">, </span><span class="s4">null</span><span class="s2">, tag);</span>
  <span class="s2">containerInfo.current = isStrictMode;</span>
  <span class="s2">isStrictMode.stateNode = containerInfo;</span>
  <span class="s2">tag = createCache();</span>
  <span class="s2">tag.refCount++;</span>
  <span class="s2">containerInfo.pooledCache = tag;</span>
  <span class="s2">tag.refCount++;</span>
  <span class="s2">isStrictMode.memoizedState = {</span>
    <span class="s2">element: initialChildren,</span>
    <span class="s2">isDehydrated: hydrate,</span>
    <span class="s2">cache: tag</span>
  <span class="s2">};</span>
  <span class="s2">initializeUpdateQueue(isStrictMode);</span>
  <span class="s4">return </span><span class="s2">containerInfo;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createPortal$1(children, containerInfo, implementation) {</span>
  <span class="s4">var </span><span class="s2">key =</span>
    <span class="s5">3 </span><span class="s2">&lt; arguments.length &amp;&amp; </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== arguments[</span><span class="s5">3</span><span class="s2">] ? arguments[</span><span class="s5">3</span><span class="s2">] : </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">return </span><span class="s2">{</span>
    <span class="s2">$$typeof: REACT_PORTAL_TYPE,</span>
    <span class="s2">key: </span><span class="s4">null </span><span class="s2">== key ? </span><span class="s4">null </span><span class="s2">: </span><span class="s3">&quot;&quot; </span><span class="s2">+ key,</span>
    <span class="s2">children: children,</span>
    <span class="s2">containerInfo: containerInfo,</span>
    <span class="s2">implementation: implementation</span>
  <span class="s2">};</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getContextForSubtree(parentComponent) {</span>
  <span class="s4">if </span><span class="s2">(!parentComponent) </span><span class="s4">return </span><span class="s2">emptyContextObject;</span>
  <span class="s2">parentComponent = emptyContextObject;</span>
  <span class="s4">return </span><span class="s2">parentComponent;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">updateContainerImpl(</span>
  <span class="s2">rootFiber,</span>
  <span class="s2">lane,</span>
  <span class="s2">element,</span>
  <span class="s2">container,</span>
  <span class="s2">parentComponent,</span>
  <span class="s2">callback</span>
<span class="s2">) {</span>
  <span class="s4">null </span><span class="s2">!== injectedProfilingHooks &amp;&amp;</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">injectedProfilingHooks.markRenderScheduled &amp;&amp;</span>
    <span class="s2">injectedProfilingHooks.markRenderScheduled(lane);</span>
  <span class="s2">parentComponent = getContextForSubtree(parentComponent);</span>
  <span class="s4">null </span><span class="s2">=== container.context</span>
    <span class="s2">? (container.context = parentComponent)</span>
    <span class="s2">: (container.pendingContext = parentComponent);</span>
  <span class="s2">container = createUpdate(lane);</span>
  <span class="s2">container.payload = { element: element };</span>
  <span class="s2">callback = </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== callback ? </span><span class="s4">null </span><span class="s2">: callback;</span>
  <span class="s4">null </span><span class="s2">!== callback &amp;&amp; (container.callback = callback);</span>
  <span class="s2">element = enqueueUpdate(rootFiber, container, lane);</span>
  <span class="s4">null </span><span class="s2">!== element &amp;&amp;</span>
    <span class="s2">(scheduleUpdateOnFiber(element, rootFiber, lane),</span>
    <span class="s2">entangleTransitions(element, rootFiber, lane));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">markRetryLaneImpl(fiber, retryLane) {</span>
  <span class="s2">fiber = fiber.memoizedState;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== fiber &amp;&amp; </span><span class="s4">null </span><span class="s2">!== fiber.dehydrated) {</span>
    <span class="s4">var </span><span class="s2">a = fiber.retryLane;</span>
    <span class="s2">fiber.retryLane = </span><span class="s5">0 </span><span class="s2">!== a &amp;&amp; a &lt; retryLane ? a : retryLane;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">markRetryLaneIfNotHydrated(fiber, retryLane) {</span>
  <span class="s2">markRetryLaneImpl(fiber, retryLane);</span>
  <span class="s2">(fiber = fiber.alternate) &amp;&amp; markRetryLaneImpl(fiber, retryLane);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">attemptContinuousHydration(fiber) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">13 </span><span class="s2">=== fiber.tag) {</span>
    <span class="s4">var </span><span class="s2">root = enqueueConcurrentRenderForLane(fiber, </span><span class="s5">67108864</span><span class="s2">);</span>
    <span class="s4">null </span><span class="s2">!== root &amp;&amp; scheduleUpdateOnFiber(root, fiber, </span><span class="s5">67108864</span><span class="s2">);</span>
    <span class="s2">markRetryLaneIfNotHydrated(fiber, </span><span class="s5">67108864</span><span class="s2">);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">_enabled = !</span><span class="s5">0</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">dispatchDiscreteEvent(</span>
  <span class="s2">domEventName,</span>
  <span class="s2">eventSystemFlags,</span>
  <span class="s2">container,</span>
  <span class="s2">nativeEvent</span>
<span class="s2">) {</span>
  <span class="s4">var </span><span class="s2">prevTransition = ReactSharedInternals.T;</span>
  <span class="s2">ReactSharedInternals.T = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">previousPriority = ReactDOMSharedInternals.p;</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s2">(ReactDOMSharedInternals.p = </span><span class="s5">2</span><span class="s2">),</span>
      <span class="s2">dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);</span>
  <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
    <span class="s2">(ReactDOMSharedInternals.p = previousPriority),</span>
      <span class="s2">(ReactSharedInternals.T = prevTransition);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">dispatchContinuousEvent(</span>
  <span class="s2">domEventName,</span>
  <span class="s2">eventSystemFlags,</span>
  <span class="s2">container,</span>
  <span class="s2">nativeEvent</span>
<span class="s2">) {</span>
  <span class="s4">var </span><span class="s2">prevTransition = ReactSharedInternals.T;</span>
  <span class="s2">ReactSharedInternals.T = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">previousPriority = ReactDOMSharedInternals.p;</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s2">(ReactDOMSharedInternals.p = </span><span class="s5">8</span><span class="s2">),</span>
      <span class="s2">dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);</span>
  <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
    <span class="s2">(ReactDOMSharedInternals.p = previousPriority),</span>
      <span class="s2">(ReactSharedInternals.T = prevTransition);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">dispatchEvent(</span>
  <span class="s2">domEventName,</span>
  <span class="s2">eventSystemFlags,</span>
  <span class="s2">targetContainer,</span>
  <span class="s2">nativeEvent</span>
<span class="s2">) {</span>
  <span class="s4">if </span><span class="s2">(_enabled) {</span>
    <span class="s4">var </span><span class="s2">blockedOn = findInstanceBlockingEvent(nativeEvent);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== blockedOn)</span>
      <span class="s2">dispatchEventForPluginEventSystem(</span>
        <span class="s2">domEventName,</span>
        <span class="s2">eventSystemFlags,</span>
        <span class="s2">nativeEvent,</span>
        <span class="s2">return_targetInst,</span>
        <span class="s2">targetContainer</span>
      <span class="s2">),</span>
        <span class="s2">clearIfContinuousEvent(domEventName, nativeEvent);</span>
    <span class="s4">else if </span><span class="s2">(</span>
      <span class="s2">queueIfContinuousEvent(</span>
        <span class="s2">blockedOn,</span>
        <span class="s2">domEventName,</span>
        <span class="s2">eventSystemFlags,</span>
        <span class="s2">targetContainer,</span>
        <span class="s2">nativeEvent</span>
      <span class="s2">)</span>
    <span class="s2">)</span>
      <span class="s2">nativeEvent.stopPropagation();</span>
    <span class="s4">else if </span><span class="s2">(</span>
      <span class="s2">(clearIfContinuousEvent(domEventName, nativeEvent),</span>
      <span class="s2">eventSystemFlags &amp; </span><span class="s5">4 </span><span class="s2">&amp;&amp;</span>
        <span class="s2">-</span><span class="s5">1 </span><span class="s2">&lt; discreteReplayableEvents.indexOf(domEventName))</span>
    <span class="s2">) {</span>
      <span class="s4">for </span><span class="s2">(; </span><span class="s4">null </span><span class="s2">!== blockedOn; ) {</span>
        <span class="s4">var </span><span class="s2">fiber = getInstanceFromNode(blockedOn);</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== fiber)</span>
          <span class="s4">switch </span><span class="s2">(fiber.tag) {</span>
            <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
              <span class="s2">fiber = fiber.stateNode;</span>
              <span class="s4">if </span><span class="s2">(fiber.current.memoizedState.isDehydrated) {</span>
                <span class="s4">var </span><span class="s2">lanes = getHighestPriorityLanes(fiber.pendingLanes);</span>
                <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== lanes) {</span>
                  <span class="s4">var </span><span class="s2">root = fiber;</span>
                  <span class="s2">root.pendingLanes |= </span><span class="s5">2</span><span class="s2">;</span>
                  <span class="s4">for </span><span class="s2">(root.entangledLanes |= </span><span class="s5">2</span><span class="s2">; lanes; ) {</span>
                    <span class="s4">var </span><span class="s2">lane = </span><span class="s5">1 </span><span class="s2">&lt;&lt; (</span><span class="s5">31 </span><span class="s2">- clz32(lanes));</span>
                    <span class="s2">root.entanglements[</span><span class="s5">1</span><span class="s2">] |= lane;</span>
                    <span class="s2">lanes &amp;= ~lane;</span>
                  <span class="s2">}</span>
                  <span class="s2">ensureRootIsScheduled(fiber);</span>
                  <span class="s5">0 </span><span class="s2">=== (executionContext &amp; </span><span class="s5">6</span><span class="s2">) &amp;&amp;</span>
                    <span class="s2">((workInProgressRootRenderTargetTime = now$1() + </span><span class="s5">500</span><span class="s2">),</span>
                    <span class="s2">flushSyncWorkAcrossRoots_impl(</span><span class="s5">0</span><span class="s2">, !</span><span class="s5">1</span><span class="s2">));</span>
                <span class="s2">}</span>
              <span class="s2">}</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s5">13</span><span class="s2">:</span>
              <span class="s2">(root = enqueueConcurrentRenderForLane(fiber, </span><span class="s5">2</span><span class="s2">)),</span>
                <span class="s4">null </span><span class="s2">!== root &amp;&amp; scheduleUpdateOnFiber(root, fiber, </span><span class="s5">2</span><span class="s2">),</span>
                <span class="s2">flushSyncWork$1(),</span>
                <span class="s2">markRetryLaneIfNotHydrated(fiber, </span><span class="s5">2</span><span class="s2">);</span>
          <span class="s2">}</span>
        <span class="s2">fiber = findInstanceBlockingEvent(nativeEvent);</span>
        <span class="s4">null </span><span class="s2">=== fiber &amp;&amp;</span>
          <span class="s2">dispatchEventForPluginEventSystem(</span>
            <span class="s2">domEventName,</span>
            <span class="s2">eventSystemFlags,</span>
            <span class="s2">nativeEvent,</span>
            <span class="s2">return_targetInst,</span>
            <span class="s2">targetContainer</span>
          <span class="s2">);</span>
        <span class="s4">if </span><span class="s2">(fiber === blockedOn) </span><span class="s4">break</span><span class="s2">;</span>
        <span class="s2">blockedOn = fiber;</span>
      <span class="s2">}</span>
      <span class="s4">null </span><span class="s2">!== blockedOn &amp;&amp; nativeEvent.stopPropagation();</span>
    <span class="s2">} </span><span class="s4">else</span>
      <span class="s2">dispatchEventForPluginEventSystem(</span>
        <span class="s2">domEventName,</span>
        <span class="s2">eventSystemFlags,</span>
        <span class="s2">nativeEvent,</span>
        <span class="s4">null</span><span class="s2">,</span>
        <span class="s2">targetContainer</span>
      <span class="s2">);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">findInstanceBlockingEvent(nativeEvent) {</span>
  <span class="s2">nativeEvent = getEventTarget(nativeEvent);</span>
  <span class="s4">return </span><span class="s2">findInstanceBlockingTarget(nativeEvent);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">return_targetInst = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">findInstanceBlockingTarget(targetNode) {</span>
  <span class="s2">return_targetInst = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">targetNode = getClosestInstanceFromNode(targetNode);</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== targetNode) {</span>
    <span class="s4">var </span><span class="s2">nearestMounted = getNearestMountedFiber(targetNode);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== nearestMounted) targetNode = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">else </span><span class="s2">{</span>
      <span class="s4">var </span><span class="s2">tag = nearestMounted.tag;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s5">13 </span><span class="s2">=== tag) {</span>
        <span class="s2">targetNode = getSuspenseInstanceFromFiber(nearestMounted);</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== targetNode) </span><span class="s4">return </span><span class="s2">targetNode;</span>
        <span class="s2">targetNode = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">} </span><span class="s4">else if </span><span class="s2">(</span><span class="s5">3 </span><span class="s2">=== tag) {</span>
        <span class="s4">if </span><span class="s2">(nearestMounted.stateNode.current.memoizedState.isDehydrated)</span>
          <span class="s4">return </span><span class="s5">3 </span><span class="s2">=== nearestMounted.tag</span>
            <span class="s2">? nearestMounted.stateNode.containerInfo</span>
            <span class="s2">: </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s2">targetNode = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">} </span><span class="s4">else </span><span class="s2">nearestMounted !== targetNode &amp;&amp; (targetNode = </span><span class="s4">null</span><span class="s2">);</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s2">return_targetInst = targetNode;</span>
  <span class="s4">return null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getEventPriority(domEventName) {</span>
  <span class="s4">switch </span><span class="s2">(domEventName) {</span>
    <span class="s4">case </span><span class="s3">&quot;beforetoggle&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;cancel&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;click&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;close&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;contextmenu&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;copy&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;cut&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;auxclick&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;dblclick&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;dragend&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;dragstart&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;drop&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;focusin&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;focusout&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;input&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;invalid&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;keydown&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;keypress&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;keyup&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;mousedown&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;mouseup&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;paste&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;pause&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;play&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;pointercancel&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;pointerdown&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;pointerup&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;ratechange&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;reset&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;resize&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;seeked&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;submit&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;toggle&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;touchcancel&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;touchend&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;touchstart&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;volumechange&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;change&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;selectionchange&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;textInput&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;compositionstart&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;compositionend&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;compositionupdate&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;beforeblur&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;afterblur&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;beforeinput&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;blur&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;fullscreenchange&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;focus&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;hashchange&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;popstate&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;select&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;selectstart&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s5">2</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;drag&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;dragenter&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;dragexit&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;dragleave&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;dragover&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;mousemove&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;mouseout&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;mouseover&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;pointermove&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;pointerout&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;pointerover&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;scroll&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;touchmove&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;wheel&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;mouseenter&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;mouseleave&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;pointerenter&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;pointerleave&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s5">8</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;message&quot;</span><span class="s2">:</span>
      <span class="s4">switch </span><span class="s2">(getCurrentPriorityLevel()) {</span>
        <span class="s4">case </span><span class="s2">ImmediatePriority:</span>
          <span class="s4">return </span><span class="s5">2</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s2">UserBlockingPriority:</span>
          <span class="s4">return </span><span class="s5">8</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s2">NormalPriority$1:</span>
        <span class="s4">case </span><span class="s2">LowPriority:</span>
          <span class="s4">return </span><span class="s5">32</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s2">IdlePriority:</span>
          <span class="s4">return </span><span class="s5">268435456</span><span class="s2">;</span>
        <span class="s4">default</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s5">32</span><span class="s2">;</span>
      <span class="s2">}</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s5">32</span><span class="s2">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">hasScheduledReplayAttempt = !</span><span class="s5">1</span><span class="s2">,</span>
  <span class="s2">queuedFocus = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">queuedDrag = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">queuedMouse = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">queuedPointers = </span><span class="s4">new </span><span class="s2">Map(),</span>
  <span class="s2">queuedPointerCaptures = </span><span class="s4">new </span><span class="s2">Map(),</span>
  <span class="s2">queuedExplicitHydrationTargets = [],</span>
  <span class="s2">discreteReplayableEvents =</span>
    <span class="s3">&quot;mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset&quot;</span><span class="s2">.split(</span>
      <span class="s3">&quot; &quot;</span>
    <span class="s2">);</span>
<span class="s4">function </span><span class="s2">clearIfContinuousEvent(domEventName, nativeEvent) {</span>
  <span class="s4">switch </span><span class="s2">(domEventName) {</span>
    <span class="s4">case </span><span class="s3">&quot;focusin&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;focusout&quot;</span><span class="s2">:</span>
      <span class="s2">queuedFocus = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;dragenter&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;dragleave&quot;</span><span class="s2">:</span>
      <span class="s2">queuedDrag = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;mouseover&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;mouseout&quot;</span><span class="s2">:</span>
      <span class="s2">queuedMouse = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;pointerover&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;pointerout&quot;</span><span class="s2">:</span>
      <span class="s2">queuedPointers.delete(nativeEvent.pointerId);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;gotpointercapture&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;lostpointercapture&quot;</span><span class="s2">:</span>
      <span class="s2">queuedPointerCaptures.delete(nativeEvent.pointerId);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">accumulateOrCreateContinuousQueuedReplayableEvent(</span>
  <span class="s2">existingQueuedEvent,</span>
  <span class="s2">blockedOn,</span>
  <span class="s2">domEventName,</span>
  <span class="s2">eventSystemFlags,</span>
  <span class="s2">targetContainer,</span>
  <span class="s2">nativeEvent</span>
<span class="s2">) {</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s4">null </span><span class="s2">=== existingQueuedEvent ||</span>
    <span class="s2">existingQueuedEvent.nativeEvent !== nativeEvent</span>
  <span class="s2">)</span>
    <span class="s4">return </span><span class="s2">(</span>
      <span class="s2">(existingQueuedEvent = {</span>
        <span class="s2">blockedOn: blockedOn,</span>
        <span class="s2">domEventName: domEventName,</span>
        <span class="s2">eventSystemFlags: eventSystemFlags,</span>
        <span class="s2">nativeEvent: nativeEvent,</span>
        <span class="s2">targetContainers: [targetContainer]</span>
      <span class="s2">}),</span>
      <span class="s4">null </span><span class="s2">!== blockedOn &amp;&amp;</span>
        <span class="s2">((blockedOn = getInstanceFromNode(blockedOn)),</span>
        <span class="s4">null </span><span class="s2">!== blockedOn &amp;&amp; attemptContinuousHydration(blockedOn)),</span>
      <span class="s2">existingQueuedEvent</span>
    <span class="s2">);</span>
  <span class="s2">existingQueuedEvent.eventSystemFlags |= eventSystemFlags;</span>
  <span class="s2">blockedOn = existingQueuedEvent.targetContainers;</span>
  <span class="s4">null </span><span class="s2">!== targetContainer &amp;&amp;</span>
    <span class="s2">-</span><span class="s5">1 </span><span class="s2">=== blockedOn.indexOf(targetContainer) &amp;&amp;</span>
    <span class="s2">blockedOn.push(targetContainer);</span>
  <span class="s4">return </span><span class="s2">existingQueuedEvent;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">queueIfContinuousEvent(</span>
  <span class="s2">blockedOn,</span>
  <span class="s2">domEventName,</span>
  <span class="s2">eventSystemFlags,</span>
  <span class="s2">targetContainer,</span>
  <span class="s2">nativeEvent</span>
<span class="s2">) {</span>
  <span class="s4">switch </span><span class="s2">(domEventName) {</span>
    <span class="s4">case </span><span class="s3">&quot;focusin&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(</span>
          <span class="s2">queuedFocus,</span>
          <span class="s2">blockedOn,</span>
          <span class="s2">domEventName,</span>
          <span class="s2">eventSystemFlags,</span>
          <span class="s2">targetContainer,</span>
          <span class="s2">nativeEvent</span>
        <span class="s2">)),</span>
        <span class="s2">!</span><span class="s5">0</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s3">&quot;dragenter&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(</span>
          <span class="s2">queuedDrag,</span>
          <span class="s2">blockedOn,</span>
          <span class="s2">domEventName,</span>
          <span class="s2">eventSystemFlags,</span>
          <span class="s2">targetContainer,</span>
          <span class="s2">nativeEvent</span>
        <span class="s2">)),</span>
        <span class="s2">!</span><span class="s5">0</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s3">&quot;mouseover&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(</span>
          <span class="s2">queuedMouse,</span>
          <span class="s2">blockedOn,</span>
          <span class="s2">domEventName,</span>
          <span class="s2">eventSystemFlags,</span>
          <span class="s2">targetContainer,</span>
          <span class="s2">nativeEvent</span>
        <span class="s2">)),</span>
        <span class="s2">!</span><span class="s5">0</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s3">&quot;pointerover&quot;</span><span class="s2">:</span>
      <span class="s4">var </span><span class="s2">pointerId = nativeEvent.pointerId;</span>
      <span class="s2">queuedPointers.set(</span>
        <span class="s2">pointerId,</span>
        <span class="s2">accumulateOrCreateContinuousQueuedReplayableEvent(</span>
          <span class="s2">queuedPointers.get(pointerId) || </span><span class="s4">null</span><span class="s2">,</span>
          <span class="s2">blockedOn,</span>
          <span class="s2">domEventName,</span>
          <span class="s2">eventSystemFlags,</span>
          <span class="s2">targetContainer,</span>
          <span class="s2">nativeEvent</span>
        <span class="s2">)</span>
      <span class="s2">);</span>
      <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;gotpointercapture&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(pointerId = nativeEvent.pointerId),</span>
        <span class="s2">queuedPointerCaptures.set(</span>
          <span class="s2">pointerId,</span>
          <span class="s2">accumulateOrCreateContinuousQueuedReplayableEvent(</span>
            <span class="s2">queuedPointerCaptures.get(pointerId) || </span><span class="s4">null</span><span class="s2">,</span>
            <span class="s2">blockedOn,</span>
            <span class="s2">domEventName,</span>
            <span class="s2">eventSystemFlags,</span>
            <span class="s2">targetContainer,</span>
            <span class="s2">nativeEvent</span>
          <span class="s2">)</span>
        <span class="s2">),</span>
        <span class="s2">!</span><span class="s5">0</span>
      <span class="s2">);</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">attemptExplicitHydrationTarget(queuedTarget) {</span>
  <span class="s4">var </span><span class="s2">targetInst = getClosestInstanceFromNode(queuedTarget.target);</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== targetInst) {</span>
    <span class="s4">var </span><span class="s2">nearestMounted = getNearestMountedFiber(targetInst);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== nearestMounted)</span>
      <span class="s4">if </span><span class="s2">(((targetInst = nearestMounted.tag), </span><span class="s5">13 </span><span class="s2">=== targetInst)) {</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">((targetInst = getSuspenseInstanceFromFiber(nearestMounted)),</span>
          <span class="s4">null </span><span class="s2">!== targetInst)</span>
        <span class="s2">) {</span>
          <span class="s2">queuedTarget.blockedOn = targetInst;</span>
          <span class="s2">runWithPriority(queuedTarget.priority, </span><span class="s4">function </span><span class="s2">() {</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s5">13 </span><span class="s2">=== nearestMounted.tag) {</span>
              <span class="s4">var </span><span class="s2">lane = requestUpdateLane();</span>
              <span class="s2">lane = getBumpedLaneForHydrationByLane(lane);</span>
              <span class="s4">var </span><span class="s2">root = enqueueConcurrentRenderForLane(nearestMounted, lane);</span>
              <span class="s4">null </span><span class="s2">!== root &amp;&amp;</span>
                <span class="s2">scheduleUpdateOnFiber(root, nearestMounted, lane);</span>
              <span class="s2">markRetryLaneIfNotHydrated(nearestMounted, lane);</span>
            <span class="s2">}</span>
          <span class="s2">});</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">} </span><span class="s4">else if </span><span class="s2">(</span>
        <span class="s5">3 </span><span class="s2">=== targetInst &amp;&amp;</span>
        <span class="s2">nearestMounted.stateNode.current.memoizedState.isDehydrated</span>
      <span class="s2">) {</span>
        <span class="s2">queuedTarget.blockedOn =</span>
          <span class="s5">3 </span><span class="s2">=== nearestMounted.tag</span>
            <span class="s2">? nearestMounted.stateNode.containerInfo</span>
            <span class="s2">: </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s2">queuedTarget.blockedOn = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">attemptReplayContinuousQueuedEvent(queuedEvent) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== queuedEvent.blockedOn) </span><span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">for </span><span class="s2">(</span>
    <span class="s4">var </span><span class="s2">targetContainers = queuedEvent.targetContainers;</span>
    <span class="s5">0 </span><span class="s2">&lt; targetContainers.length;</span>

  <span class="s2">) {</span>
    <span class="s4">var </span><span class="s2">nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== nextBlockedOn) {</span>
      <span class="s2">nextBlockedOn = queuedEvent.nativeEvent;</span>
      <span class="s4">var </span><span class="s2">nativeEventClone = </span><span class="s4">new </span><span class="s2">nextBlockedOn.constructor(</span>
        <span class="s2">nextBlockedOn.type,</span>
        <span class="s2">nextBlockedOn</span>
      <span class="s2">);</span>
      <span class="s2">currentReplayingEvent = nativeEventClone;</span>
      <span class="s2">nextBlockedOn.target.dispatchEvent(nativeEventClone);</span>
      <span class="s2">currentReplayingEvent = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s2">} </span><span class="s4">else</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(targetContainers = getInstanceFromNode(nextBlockedOn)),</span>
        <span class="s4">null </span><span class="s2">!== targetContainers &amp;&amp;</span>
          <span class="s2">attemptContinuousHydration(targetContainers),</span>
        <span class="s2">(queuedEvent.blockedOn = nextBlockedOn),</span>
        <span class="s2">!</span><span class="s5">1</span>
      <span class="s2">);</span>
    <span class="s2">targetContainers.shift();</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {</span>
  <span class="s2">attemptReplayContinuousQueuedEvent(queuedEvent) &amp;&amp; map.delete(key);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">replayUnblockedEvents() {</span>
  <span class="s2">hasScheduledReplayAttempt = !</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">null </span><span class="s2">!== queuedFocus &amp;&amp;</span>
    <span class="s2">attemptReplayContinuousQueuedEvent(queuedFocus) &amp;&amp;</span>
    <span class="s2">(queuedFocus = </span><span class="s4">null</span><span class="s2">);</span>
  <span class="s4">null </span><span class="s2">!== queuedDrag &amp;&amp;</span>
    <span class="s2">attemptReplayContinuousQueuedEvent(queuedDrag) &amp;&amp;</span>
    <span class="s2">(queuedDrag = </span><span class="s4">null</span><span class="s2">);</span>
  <span class="s4">null </span><span class="s2">!== queuedMouse &amp;&amp;</span>
    <span class="s2">attemptReplayContinuousQueuedEvent(queuedMouse) &amp;&amp;</span>
    <span class="s2">(queuedMouse = </span><span class="s4">null</span><span class="s2">);</span>
  <span class="s2">queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);</span>
  <span class="s2">queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">scheduleCallbackIfUnblocked(queuedEvent, unblocked) {</span>
  <span class="s2">queuedEvent.blockedOn === unblocked &amp;&amp;</span>
    <span class="s2">((queuedEvent.blockedOn = </span><span class="s4">null</span><span class="s2">),</span>
    <span class="s2">hasScheduledReplayAttempt ||</span>
      <span class="s2">((hasScheduledReplayAttempt = !</span><span class="s5">0</span><span class="s2">),</span>
      <span class="s2">Scheduler.unstable_scheduleCallback(</span>
        <span class="s2">Scheduler.unstable_NormalPriority,</span>
        <span class="s2">replayUnblockedEvents</span>
      <span class="s2">)));</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">lastScheduledReplayQueue = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">scheduleReplayQueueIfNeeded(formReplayingQueue) {</span>
  <span class="s2">lastScheduledReplayQueue !== formReplayingQueue &amp;&amp;</span>
    <span class="s2">((lastScheduledReplayQueue = formReplayingQueue),</span>
    <span class="s2">Scheduler.unstable_scheduleCallback(</span>
      <span class="s2">Scheduler.unstable_NormalPriority,</span>
      <span class="s4">function </span><span class="s2">() {</span>
        <span class="s2">lastScheduledReplayQueue === formReplayingQueue &amp;&amp;</span>
          <span class="s2">(lastScheduledReplayQueue = </span><span class="s4">null</span><span class="s2">);</span>
        <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; formReplayingQueue.length; i += </span><span class="s5">3</span><span class="s2">) {</span>
          <span class="s4">var </span><span class="s2">form = formReplayingQueue[i],</span>
            <span class="s2">submitterOrAction = formReplayingQueue[i + </span><span class="s5">1</span><span class="s2">],</span>
            <span class="s2">formData = formReplayingQueue[i + </span><span class="s5">2</span><span class="s2">];</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">submitterOrAction)</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== findInstanceBlockingTarget(submitterOrAction || form))</span>
              <span class="s4">continue</span><span class="s2">;</span>
            <span class="s4">else break</span><span class="s2">;</span>
          <span class="s4">var </span><span class="s2">formInst = getInstanceFromNode(form);</span>
          <span class="s4">null </span><span class="s2">!== formInst &amp;&amp;</span>
            <span class="s2">(formReplayingQueue.splice(i, </span><span class="s5">3</span><span class="s2">),</span>
            <span class="s2">(i -= </span><span class="s5">3</span><span class="s2">),</span>
            <span class="s2">startHostTransition(</span>
              <span class="s2">formInst,</span>
              <span class="s2">{</span>
                <span class="s2">pending: !</span><span class="s5">0</span><span class="s2">,</span>
                <span class="s2">data: formData,</span>
                <span class="s2">method: form.method,</span>
                <span class="s2">action: submitterOrAction</span>
              <span class="s2">},</span>
              <span class="s2">submitterOrAction,</span>
              <span class="s2">formData</span>
            <span class="s2">));</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">retryIfBlockedOn(unblocked) {</span>
  <span class="s4">function </span><span class="s2">unblock(queuedEvent) {</span>
    <span class="s4">return </span><span class="s2">scheduleCallbackIfUnblocked(queuedEvent, unblocked);</span>
  <span class="s2">}</span>
  <span class="s4">null </span><span class="s2">!== queuedFocus &amp;&amp; scheduleCallbackIfUnblocked(queuedFocus, unblocked);</span>
  <span class="s4">null </span><span class="s2">!== queuedDrag &amp;&amp; scheduleCallbackIfUnblocked(queuedDrag, unblocked);</span>
  <span class="s4">null </span><span class="s2">!== queuedMouse &amp;&amp; scheduleCallbackIfUnblocked(queuedMouse, unblocked);</span>
  <span class="s2">queuedPointers.forEach(unblock);</span>
  <span class="s2">queuedPointerCaptures.forEach(unblock);</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; queuedExplicitHydrationTargets.length; i++) {</span>
    <span class="s4">var </span><span class="s2">queuedTarget = queuedExplicitHydrationTargets[i];</span>
    <span class="s2">queuedTarget.blockedOn === unblocked &amp;&amp; (queuedTarget.blockedOn = </span><span class="s4">null</span><span class="s2">);</span>
  <span class="s2">}</span>
  <span class="s4">for </span><span class="s2">(</span>
    <span class="s2">;</span>
    <span class="s5">0 </span><span class="s2">&lt; queuedExplicitHydrationTargets.length &amp;&amp;</span>
    <span class="s2">((i = queuedExplicitHydrationTargets[</span><span class="s5">0</span><span class="s2">]), </span><span class="s4">null </span><span class="s2">=== i.blockedOn);</span>

  <span class="s2">)</span>
    <span class="s2">attemptExplicitHydrationTarget(i),</span>
      <span class="s4">null </span><span class="s2">=== i.blockedOn &amp;&amp; queuedExplicitHydrationTargets.shift();</span>
  <span class="s2">i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= i)</span>
    <span class="s4">for </span><span class="s2">(queuedTarget = </span><span class="s5">0</span><span class="s2">; queuedTarget &lt; i.length; queuedTarget += </span><span class="s5">3</span><span class="s2">) {</span>
      <span class="s4">var </span><span class="s2">form = i[queuedTarget],</span>
        <span class="s2">submitterOrAction = i[queuedTarget + </span><span class="s5">1</span><span class="s2">],</span>
        <span class="s2">formProps = form[internalPropsKey] || </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">submitterOrAction)</span>
        <span class="s2">formProps || scheduleReplayQueueIfNeeded(i);</span>
      <span class="s4">else if </span><span class="s2">(formProps) {</span>
        <span class="s4">var </span><span class="s2">action = </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s4">if </span><span class="s2">(submitterOrAction &amp;&amp; submitterOrAction.hasAttribute(</span><span class="s3">&quot;formAction&quot;</span><span class="s2">))</span>
          <span class="s4">if </span><span class="s2">(</span>
            <span class="s2">((form = submitterOrAction),</span>
            <span class="s2">(formProps = submitterOrAction[internalPropsKey] || </span><span class="s4">null</span><span class="s2">))</span>
          <span class="s2">)</span>
            <span class="s2">action = formProps.formAction;</span>
          <span class="s4">else </span><span class="s2">{</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== findInstanceBlockingTarget(form)) </span><span class="s4">continue</span><span class="s2">;</span>
          <span class="s2">}</span>
        <span class="s4">else </span><span class="s2">action = formProps.action;</span>
        <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">action</span>
          <span class="s2">? (i[queuedTarget + </span><span class="s5">1</span><span class="s2">] = action)</span>
          <span class="s2">: (i.splice(queuedTarget, </span><span class="s5">3</span><span class="s2">), (queuedTarget -= </span><span class="s5">3</span><span class="s2">));</span>
        <span class="s2">scheduleReplayQueueIfNeeded(i);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">ReactDOMRoot(internalRoot) {</span>
  <span class="s4">this</span><span class="s2">._internalRoot = internalRoot;</span>
<span class="s2">}</span>
<span class="s2">ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =</span>
  <span class="s4">function </span><span class="s2">(children) {</span>
    <span class="s4">var </span><span class="s2">root = </span><span class="s4">this</span><span class="s2">._internalRoot;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== root) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">409</span><span class="s2">));</span>
    <span class="s4">var </span><span class="s2">current = root.current,</span>
      <span class="s2">lane = requestUpdateLane();</span>
    <span class="s2">updateContainerImpl(current, lane, children, root, </span><span class="s4">null</span><span class="s2">, </span><span class="s4">null</span><span class="s2">);</span>
  <span class="s2">};</span>
<span class="s2">ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount =</span>
  <span class="s4">function </span><span class="s2">() {</span>
    <span class="s4">var </span><span class="s2">root = </span><span class="s4">this</span><span class="s2">._internalRoot;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== root) {</span>
      <span class="s4">this</span><span class="s2">._internalRoot = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">var </span><span class="s2">container = root.containerInfo;</span>
      <span class="s2">updateContainerImpl(root.current, </span><span class="s5">2</span><span class="s2">, </span><span class="s4">null</span><span class="s2">, root, </span><span class="s4">null</span><span class="s2">, </span><span class="s4">null</span><span class="s2">);</span>
      <span class="s2">flushSyncWork$1();</span>
      <span class="s2">container[internalContainerInstanceKey] = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s2">};</span>
<span class="s4">function </span><span class="s2">ReactDOMHydrationRoot(internalRoot) {</span>
  <span class="s4">this</span><span class="s2">._internalRoot = internalRoot;</span>
<span class="s2">}</span>
<span class="s2">ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = </span><span class="s4">function </span><span class="s2">(target) {</span>
  <span class="s4">if </span><span class="s2">(target) {</span>
    <span class="s4">var </span><span class="s2">updatePriority = resolveUpdatePriority();</span>
    <span class="s2">target = { blockedOn: </span><span class="s4">null</span><span class="s2">, target: target, priority: updatePriority };</span>
    <span class="s4">for </span><span class="s2">(</span>
      <span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">;</span>
      <span class="s2">i &lt; queuedExplicitHydrationTargets.length &amp;&amp;</span>
      <span class="s5">0 </span><span class="s2">!== updatePriority &amp;&amp;</span>
      <span class="s2">updatePriority &lt; queuedExplicitHydrationTargets[i].priority;</span>
      <span class="s2">i++</span>
    <span class="s2">);</span>
    <span class="s2">queuedExplicitHydrationTargets.splice(i, </span><span class="s5">0</span><span class="s2">, target);</span>
    <span class="s5">0 </span><span class="s2">=== i &amp;&amp; attemptExplicitHydrationTarget(target);</span>
  <span class="s2">}</span>
<span class="s2">};</span>
<span class="s4">var </span><span class="s2">isomorphicReactPackageVersion$jscomp$inline_1881 = React.version;</span>
<span class="s4">if </span><span class="s2">(</span>
  <span class="s3">&quot;19.1.0&quot; </span><span class="s2">!==</span>
  <span class="s2">isomorphicReactPackageVersion$jscomp$inline_1881</span>
<span class="s2">)</span>
  <span class="s4">throw </span><span class="s2">Error(</span>
    <span class="s2">formatProdErrorMessage(</span>
      <span class="s5">527</span><span class="s2">,</span>
      <span class="s2">isomorphicReactPackageVersion$jscomp$inline_1881,</span>
      <span class="s3">&quot;19.1.0&quot;</span>
    <span class="s2">)</span>
  <span class="s2">);</span>
<span class="s2">ReactDOMSharedInternals.findDOMNode = </span><span class="s4">function </span><span class="s2">(componentOrElement) {</span>
  <span class="s4">var </span><span class="s2">fiber = componentOrElement._reactInternals;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== fiber) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">componentOrElement.render)</span>
      <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">188</span><span class="s2">));</span>
    <span class="s2">componentOrElement = Object.keys(componentOrElement).join(</span><span class="s3">&quot;,&quot;</span><span class="s2">);</span>
    <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">268</span><span class="s2">, componentOrElement));</span>
  <span class="s2">}</span>
  <span class="s2">componentOrElement = findCurrentFiberUsingSlowPath(fiber);</span>
  <span class="s2">componentOrElement =</span>
    <span class="s4">null </span><span class="s2">!== componentOrElement</span>
      <span class="s2">? findCurrentHostFiberImpl(componentOrElement)</span>
      <span class="s2">: </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">componentOrElement =</span>
    <span class="s4">null </span><span class="s2">=== componentOrElement ? </span><span class="s4">null </span><span class="s2">: componentOrElement.stateNode;</span>
  <span class="s4">return </span><span class="s2">componentOrElement;</span>
<span class="s2">};</span>
<span class="s4">var </span><span class="s2">internals$jscomp$inline_1888 = {</span>
  <span class="s2">bundleType: </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">version: </span><span class="s3">&quot;19.1.0&quot;</span><span class="s2">,</span>
  <span class="s2">rendererPackageName: </span><span class="s3">&quot;react-dom&quot;</span><span class="s2">,</span>
  <span class="s2">currentDispatcherRef: ReactSharedInternals,</span>
  <span class="s2">reconcilerVersion: </span><span class="s3">&quot;19.1.0&quot;</span><span class="s2">,</span>
  <span class="s2">getLaneLabelMap: </span><span class="s4">function </span><span class="s2">() {</span>
    <span class="s4">for </span><span class="s2">(</span>
      <span class="s4">var </span><span class="s2">map = </span><span class="s4">new </span><span class="s2">Map(), lane = </span><span class="s5">1</span><span class="s2">, index$282 = </span><span class="s5">0</span><span class="s2">;</span>
      <span class="s5">31 </span><span class="s2">&gt; index$282;</span>
      <span class="s2">index$282++</span>
    <span class="s2">) {</span>
      <span class="s4">var </span><span class="s2">label = getLabelForLane(lane);</span>
      <span class="s2">map.set(lane, label);</span>
      <span class="s2">lane *= </span><span class="s5">2</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">return </span><span class="s2">map;</span>
  <span class="s2">},</span>
  <span class="s2">injectProfilingHooks: </span><span class="s4">function </span><span class="s2">(profilingHooks) {</span>
    <span class="s2">injectedProfilingHooks = profilingHooks;</span>
  <span class="s2">}</span>
<span class="s2">};</span>
<span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;undefined&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">__REACT_DEVTOOLS_GLOBAL_HOOK__) {</span>
  <span class="s4">var </span><span class="s2">hook$jscomp$inline_2320 = __REACT_DEVTOOLS_GLOBAL_HOOK__;</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s2">!hook$jscomp$inline_2320.isDisabled &amp;&amp;</span>
    <span class="s2">hook$jscomp$inline_2320.supportsFiber</span>
  <span class="s2">)</span>
    <span class="s4">try </span><span class="s2">{</span>
      <span class="s2">(rendererID = hook$jscomp$inline_2320.inject(</span>
        <span class="s2">internals$jscomp$inline_1888</span>
      <span class="s2">)),</span>
        <span class="s2">(injectedHook = hook$jscomp$inline_2320);</span>
    <span class="s2">} </span><span class="s4">catch </span><span class="s2">(err) {}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">noop() {}</span>
<span class="s4">function </span><span class="s2">getCrossOriginStringAs(as, input) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;font&quot; </span><span class="s2">=== as) </span><span class="s4">return </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">input)</span>
    <span class="s4">return </span><span class="s3">&quot;use-credentials&quot; </span><span class="s2">=== input ? input : </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s2">exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = {</span>
  <span class="s2">d: {</span>
    <span class="s2">f: noop,</span>
    <span class="s2">r: </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">522</span><span class="s2">));</span>
    <span class="s2">},</span>
    <span class="s2">D: noop,</span>
    <span class="s2">C: noop,</span>
    <span class="s2">L: noop,</span>
    <span class="s2">m: noop,</span>
    <span class="s2">X: noop,</span>
    <span class="s2">S: noop,</span>
    <span class="s2">M: noop</span>
  <span class="s2">},</span>
  <span class="s2">p: </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">findDOMNode: </span><span class="s4">null</span>
<span class="s2">};</span>
<span class="s2">exports.createPortal = </span><span class="s4">function </span><span class="s2">(children, container) {</span>
  <span class="s4">var </span><span class="s2">key =</span>
    <span class="s5">2 </span><span class="s2">&lt; arguments.length &amp;&amp; </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== arguments[</span><span class="s5">2</span><span class="s2">] ? arguments[</span><span class="s5">2</span><span class="s2">] : </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(!isValidContainer(container)) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">299</span><span class="s2">));</span>
  <span class="s4">return </span><span class="s2">createPortal$1(children, container, </span><span class="s4">null</span><span class="s2">, key);</span>
<span class="s2">};</span>
<span class="s2">exports.createRoot = </span><span class="s4">function </span><span class="s2">(container, options) {</span>
  <span class="s4">if </span><span class="s2">(!isValidContainer(container)) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">299</span><span class="s2">));</span>
  <span class="s4">var </span><span class="s2">isStrictMode = !</span><span class="s5">1</span><span class="s2">,</span>
    <span class="s2">identifierPrefix = </span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
    <span class="s2">onUncaughtError = defaultOnUncaughtError,</span>
    <span class="s2">onCaughtError = defaultOnCaughtError,</span>
    <span class="s2">onRecoverableError = defaultOnRecoverableError,</span>
    <span class="s2">transitionCallbacks = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">null </span><span class="s2">!== options &amp;&amp;</span>
    <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== options &amp;&amp;</span>
    <span class="s2">(!</span><span class="s5">0 </span><span class="s2">=== options.unstable_strictMode &amp;&amp; (isStrictMode = !</span><span class="s5">0</span><span class="s2">),</span>
    <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== options.identifierPrefix &amp;&amp;</span>
      <span class="s2">(identifierPrefix = options.identifierPrefix),</span>
    <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== options.onUncaughtError &amp;&amp;</span>
      <span class="s2">(onUncaughtError = options.onUncaughtError),</span>
    <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== options.onCaughtError &amp;&amp; (onCaughtError = options.onCaughtError),</span>
    <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== options.onRecoverableError &amp;&amp;</span>
      <span class="s2">(onRecoverableError = options.onRecoverableError),</span>
    <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== options.unstable_transitionCallbacks &amp;&amp;</span>
      <span class="s2">(transitionCallbacks = options.unstable_transitionCallbacks));</span>
  <span class="s2">options = createFiberRoot(</span>
    <span class="s2">container,</span>
    <span class="s5">1</span><span class="s2">,</span>
    <span class="s2">!</span><span class="s5">1</span><span class="s2">,</span>
    <span class="s4">null</span><span class="s2">,</span>
    <span class="s4">null</span><span class="s2">,</span>
    <span class="s2">isStrictMode,</span>
    <span class="s2">identifierPrefix,</span>
    <span class="s2">onUncaughtError,</span>
    <span class="s2">onCaughtError,</span>
    <span class="s2">onRecoverableError,</span>
    <span class="s2">transitionCallbacks,</span>
    <span class="s4">null</span>
  <span class="s2">);</span>
  <span class="s2">container[internalContainerInstanceKey] = options.current;</span>
  <span class="s2">listenToAllSupportedEvents(container);</span>
  <span class="s4">return new </span><span class="s2">ReactDOMRoot(options);</span>
<span class="s2">};</span>
<span class="s2">exports.flushSync = </span><span class="s4">function </span><span class="s2">(fn) {</span>
  <span class="s4">var </span><span class="s2">previousTransition = ReactSharedInternals.T,</span>
    <span class="s2">previousUpdatePriority = ReactDOMSharedInternals.p;</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s4">if </span><span class="s2">(((ReactSharedInternals.T = </span><span class="s4">null</span><span class="s2">), (ReactDOMSharedInternals.p = </span><span class="s5">2</span><span class="s2">), fn))</span>
      <span class="s4">return </span><span class="s2">fn();</span>
  <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
    <span class="s2">(ReactSharedInternals.T = previousTransition),</span>
      <span class="s2">(ReactDOMSharedInternals.p = previousUpdatePriority),</span>
      <span class="s2">ReactDOMSharedInternals.d.f();</span>
  <span class="s2">}</span>
<span class="s2">};</span>
<span class="s2">exports.hydrateRoot = </span><span class="s4">function </span><span class="s2">(container, initialChildren, options) {</span>
  <span class="s4">if </span><span class="s2">(!isValidContainer(container)) </span><span class="s4">throw </span><span class="s2">Error(formatProdErrorMessage(</span><span class="s5">299</span><span class="s2">));</span>
  <span class="s4">var </span><span class="s2">isStrictMode = !</span><span class="s5">1</span><span class="s2">,</span>
    <span class="s2">identifierPrefix = </span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
    <span class="s2">onUncaughtError = defaultOnUncaughtError,</span>
    <span class="s2">onCaughtError = defaultOnCaughtError,</span>
    <span class="s2">onRecoverableError = defaultOnRecoverableError,</span>
    <span class="s2">transitionCallbacks = </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">formState = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">null </span><span class="s2">!== options &amp;&amp;</span>
    <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== options &amp;&amp;</span>
    <span class="s2">(!</span><span class="s5">0 </span><span class="s2">=== options.unstable_strictMode &amp;&amp; (isStrictMode = !</span><span class="s5">0</span><span class="s2">),</span>
    <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== options.identifierPrefix &amp;&amp;</span>
      <span class="s2">(identifierPrefix = options.identifierPrefix),</span>
    <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== options.onUncaughtError &amp;&amp;</span>
      <span class="s2">(onUncaughtError = options.onUncaughtError),</span>
    <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== options.onCaughtError &amp;&amp; (onCaughtError = options.onCaughtError),</span>
    <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== options.onRecoverableError &amp;&amp;</span>
      <span class="s2">(onRecoverableError = options.onRecoverableError),</span>
    <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== options.unstable_transitionCallbacks &amp;&amp;</span>
      <span class="s2">(transitionCallbacks = options.unstable_transitionCallbacks),</span>
    <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== options.formState &amp;&amp; (formState = options.formState));</span>
  <span class="s2">initialChildren = createFiberRoot(</span>
    <span class="s2">container,</span>
    <span class="s5">1</span><span class="s2">,</span>
    <span class="s2">!</span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">initialChildren,</span>
    <span class="s4">null </span><span class="s2">!= options ? options : </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">isStrictMode,</span>
    <span class="s2">identifierPrefix,</span>
    <span class="s2">onUncaughtError,</span>
    <span class="s2">onCaughtError,</span>
    <span class="s2">onRecoverableError,</span>
    <span class="s2">transitionCallbacks,</span>
    <span class="s2">formState</span>
  <span class="s2">);</span>
  <span class="s2">initialChildren.context = getContextForSubtree(</span><span class="s4">null</span><span class="s2">);</span>
  <span class="s2">options = initialChildren.current;</span>
  <span class="s2">isStrictMode = requestUpdateLane();</span>
  <span class="s2">isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);</span>
  <span class="s2">identifierPrefix = createUpdate(isStrictMode);</span>
  <span class="s2">identifierPrefix.callback = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">enqueueUpdate(options, identifierPrefix, isStrictMode);</span>
  <span class="s2">options = isStrictMode;</span>
  <span class="s2">initialChildren.current.lanes = options;</span>
  <span class="s2">markRootUpdated$1(initialChildren, options);</span>
  <span class="s2">ensureRootIsScheduled(initialChildren);</span>
  <span class="s2">container[internalContainerInstanceKey] = initialChildren.current;</span>
  <span class="s2">listenToAllSupportedEvents(container);</span>
  <span class="s4">return new </span><span class="s2">ReactDOMHydrationRoot(initialChildren);</span>
<span class="s2">};</span>
<span class="s2">exports.preconnect = </span><span class="s4">function </span><span class="s2">(href, options) {</span>
  <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">href &amp;&amp;</span>
    <span class="s2">(options</span>
      <span class="s2">? ((options = options.crossOrigin),</span>
        <span class="s2">(options =</span>
          <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options</span>
            <span class="s2">? </span><span class="s3">&quot;use-credentials&quot; </span><span class="s2">=== options</span>
              <span class="s2">? options</span>
              <span class="s2">: </span><span class="s3">&quot;&quot;</span>
            <span class="s2">: </span><span class="s4">void </span><span class="s5">0</span><span class="s2">))</span>
      <span class="s2">: (options = </span><span class="s4">null</span><span class="s2">),</span>
    <span class="s2">ReactDOMSharedInternals.d.C(href, options));</span>
<span class="s2">};</span>
<span class="s2">exports.prefetchDNS = </span><span class="s4">function </span><span class="s2">(href) {</span>
  <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">href &amp;&amp; ReactDOMSharedInternals.d.D(href);</span>
<span class="s2">};</span>
<span class="s2">exports.preinit = </span><span class="s4">function </span><span class="s2">(href, options) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">href &amp;&amp; options &amp;&amp; </span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options.as) {</span>
    <span class="s4">var </span><span class="s2">as = options.as,</span>
      <span class="s2">crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),</span>
      <span class="s2">integrity =</span>
        <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options.integrity ? options.integrity : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">fetchPriority =</span>
        <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options.fetchPriority</span>
          <span class="s2">? options.fetchPriority</span>
          <span class="s2">: </span><span class="s4">void </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s3">&quot;style&quot; </span><span class="s2">=== as</span>
      <span class="s2">? ReactDOMSharedInternals.d.S(</span>
          <span class="s2">href,</span>
          <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options.precedence ? options.precedence : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
          <span class="s2">{</span>
            <span class="s2">crossOrigin: crossOrigin,</span>
            <span class="s2">integrity: integrity,</span>
            <span class="s2">fetchPriority: fetchPriority</span>
          <span class="s2">}</span>
        <span class="s2">)</span>
      <span class="s2">: </span><span class="s3">&quot;script&quot; </span><span class="s2">=== as &amp;&amp;</span>
        <span class="s2">ReactDOMSharedInternals.d.X(href, {</span>
          <span class="s2">crossOrigin: crossOrigin,</span>
          <span class="s2">integrity: integrity,</span>
          <span class="s2">fetchPriority: fetchPriority,</span>
          <span class="s2">nonce: </span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options.nonce ? options.nonce : </span><span class="s4">void </span><span class="s5">0</span>
        <span class="s2">});</span>
  <span class="s2">}</span>
<span class="s2">};</span>
<span class="s2">exports.preinitModule = </span><span class="s4">function </span><span class="s2">(href, options) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">href)</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options &amp;&amp; </span><span class="s4">null </span><span class="s2">!== options) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">== options.as || </span><span class="s3">&quot;script&quot; </span><span class="s2">=== options.as) {</span>
        <span class="s4">var </span><span class="s2">crossOrigin = getCrossOriginStringAs(</span>
          <span class="s2">options.as,</span>
          <span class="s2">options.crossOrigin</span>
        <span class="s2">);</span>
        <span class="s2">ReactDOMSharedInternals.d.M(href, {</span>
          <span class="s2">crossOrigin: crossOrigin,</span>
          <span class="s2">integrity:</span>
            <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options.integrity ? options.integrity : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
          <span class="s2">nonce: </span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options.nonce ? options.nonce : </span><span class="s4">void </span><span class="s5">0</span>
        <span class="s2">});</span>
      <span class="s2">}</span>
    <span class="s2">} </span><span class="s4">else null </span><span class="s2">== options &amp;&amp; ReactDOMSharedInternals.d.M(href);</span>
<span class="s2">};</span>
<span class="s2">exports.preload = </span><span class="s4">function </span><span class="s2">(href, options) {</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">href &amp;&amp;</span>
    <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options &amp;&amp;</span>
    <span class="s4">null </span><span class="s2">!== options &amp;&amp;</span>
    <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options.as</span>
  <span class="s2">) {</span>
    <span class="s4">var </span><span class="s2">as = options.as,</span>
      <span class="s2">crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);</span>
    <span class="s2">ReactDOMSharedInternals.d.L(href, as, {</span>
      <span class="s2">crossOrigin: crossOrigin,</span>
      <span class="s2">integrity:</span>
        <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options.integrity ? options.integrity : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">nonce: </span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options.nonce ? options.nonce : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">type: </span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options.type ? options.type : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">fetchPriority:</span>
        <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options.fetchPriority</span>
          <span class="s2">? options.fetchPriority</span>
          <span class="s2">: </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">referrerPolicy:</span>
        <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options.referrerPolicy</span>
          <span class="s2">? options.referrerPolicy</span>
          <span class="s2">: </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">imageSrcSet:</span>
        <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options.imageSrcSet ? options.imageSrcSet : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">imageSizes:</span>
        <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options.imageSizes ? options.imageSizes : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">media: </span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options.media ? options.media : </span><span class="s4">void </span><span class="s5">0</span>
    <span class="s2">});</span>
  <span class="s2">}</span>
<span class="s2">};</span>
<span class="s2">exports.preloadModule = </span><span class="s4">function </span><span class="s2">(href, options) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">href)</span>
    <span class="s4">if </span><span class="s2">(options) {</span>
      <span class="s4">var </span><span class="s2">crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);</span>
      <span class="s2">ReactDOMSharedInternals.d.m(href, {</span>
        <span class="s2">as:</span>
          <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options.as &amp;&amp; </span><span class="s3">&quot;script&quot; </span><span class="s2">!== options.as</span>
            <span class="s2">? options.as</span>
            <span class="s2">: </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
        <span class="s2">crossOrigin: crossOrigin,</span>
        <span class="s2">integrity:</span>
          <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options.integrity ? options.integrity : </span><span class="s4">void </span><span class="s5">0</span>
      <span class="s2">});</span>
    <span class="s2">} </span><span class="s4">else </span><span class="s2">ReactDOMSharedInternals.d.m(href);</span>
<span class="s2">};</span>
<span class="s2">exports.requestFormReset = </span><span class="s4">function </span><span class="s2">(form) {</span>
  <span class="s2">ReactDOMSharedInternals.d.r(form);</span>
<span class="s2">};</span>
<span class="s2">exports.unstable_batchedUpdates = </span><span class="s4">function </span><span class="s2">(fn, a) {</span>
  <span class="s4">return </span><span class="s2">fn(a);</span>
<span class="s2">};</span>
<span class="s2">exports.useFormState = </span><span class="s4">function </span><span class="s2">(action, initialState, permalink) {</span>
  <span class="s4">return </span><span class="s2">ReactSharedInternals.H.useFormState(action, initialState, permalink);</span>
<span class="s2">};</span>
<span class="s2">exports.useFormStatus = </span><span class="s4">function </span><span class="s2">() {</span>
  <span class="s4">return </span><span class="s2">ReactSharedInternals.H.useHostTransitionStatus();</span>
<span class="s2">};</span>
<span class="s2">exports.version = </span><span class="s3">&quot;19.1.0&quot;</span><span class="s2">;</span>
<span class="s3">&quot;undefined&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">__REACT_DEVTOOLS_GLOBAL_HOOK__ &amp;&amp;</span>
  <span class="s3">&quot;function&quot; </span><span class="s2">===</span>
    <span class="s4">typeof </span><span class="s2">__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &amp;&amp;</span>
  <span class="s2">__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());</span>
</pre>
</body>
</html>