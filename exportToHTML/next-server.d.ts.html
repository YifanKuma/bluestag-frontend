<html>
<head>
<title>next-server.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
next-server.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s2">'./node-environment'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s2">'./require-hook'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s2">'./node-polyfill-crypto'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { CacheFs } from </span><span class="s2">'../shared/lib/utils'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { MiddlewareManifest } from </span><span class="s2">'../build/webpack/plugins/middleware-plugin'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type RenderResult from </span><span class="s2">'./render-result'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { FetchEventResult } from </span><span class="s2">'./web/types'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { PrerenderManifest } from </span><span class="s2">'../build'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { PagesManifest } from </span><span class="s2">'../build/webpack/plugins/pages-manifest-plugin'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { NextParsedUrlQuery, NextUrlWithParsedQuery } from </span><span class="s2">'./request-meta'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { Params } from </span><span class="s2">'./request/params'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { RouteMatch } from </span><span class="s2">'./route-matches/route-match'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { IncomingMessage, ServerResponse } from </span><span class="s2">'http'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { UrlWithParsedQuery } from </span><span class="s2">'url'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { ParsedUrlQuery } from </span><span class="s2">'querystring'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { ParsedUrl } from </span><span class="s2">'../shared/lib/router/utils/parse-url'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { CacheControl } from </span><span class="s2">'./lib/cache-control'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { WaitUntil } from </span><span class="s2">'./after/builtin-request-context'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ NodeNextRequest, NodeNextResponse } from </span><span class="s2">'./base-http/node'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { Options, FindComponentsResult, MiddlewareRoutingItem, RequestContext, NormalizedRouteManifest, LoadedRenderOpts, RouteHandler, NextEnabledDirectories, BaseRequestHandler } from </span><span class="s2">'./base-server'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">BaseServer from </span><span class="s2">'./base-server'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { LoadComponentsReturnType } from </span><span class="s2">'./load-components'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">ResponseCache, { type IncrementalResponseCacheEntry } from </span><span class="s2">'./response-cache'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ IncrementalCache } from </span><span class="s2">'./lib/incremental-cache'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { PagesAPIRouteMatch } from </span><span class="s2">'./route-matches/pages-api-route-match'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { NextFontManifest } from </span><span class="s2">'../build/webpack/plugins/next-font-manifest-plugin'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { ServerOnInstrumentationRequestError } from </span><span class="s2">'./app-render/types'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ AsyncCallbackSet } from </span><span class="s2">'./lib/async-callback-set'</span><span class="s1">;</span>
<span class="s0">export </span><span class="s1">* from </span><span class="s2">'./base-server'</span><span class="s1">;</span>
<span class="s0">export </span><span class="s1">type NodeRequestHandler = BaseRequestHandler&lt;IncomingMessage | NodeNextRequest, ServerResponse | NodeNextResponse&gt;;</span>
<span class="s1">type NodeRouteHandler = RouteHandler&lt;NodeNextRequest, NodeNextResponse&gt;;</span>
<span class="s0">export default class </span><span class="s1">NextNodeServer </span><span class="s0">extends </span><span class="s1">BaseServer&lt;Options, NodeNextRequest, NodeNextResponse&gt; {</span>
    <span class="s0">protected </span><span class="s1">middlewareManifestPath: string;</span>
    <span class="s0">private </span><span class="s1">_serverDistDir;</span>
    <span class="s0">private </span><span class="s1">imageResponseCache?;</span>
    <span class="s0">protected </span><span class="s1">renderWorkersPromises?: Promise&lt;</span><span class="s0">void</span><span class="s1">&gt;;</span>
    <span class="s0">protected </span><span class="s1">dynamicRoutes?: {</span>
        <span class="s1">match: </span><span class="s0">import</span><span class="s1">(</span><span class="s2">'../shared/lib/router/utils/route-matcher'</span><span class="s1">).RouteMatchFn;</span>
        <span class="s1">page: string;</span>
        <span class="s1">re: RegExp;</span>
    <span class="s1">}[];</span>
    <span class="s0">private </span><span class="s1">routerServerHandler?;</span>
    <span class="s0">protected </span><span class="s1">cleanupListeners: AsyncCallbackSet;</span>
    <span class="s0">protected </span><span class="s1">internalWaitUntil: WaitUntil | undefined;</span>
    <span class="s0">private </span><span class="s1">isDev;</span>
    <span class="s0">private </span><span class="s1">sriEnabled;</span>
    <span class="s1">constructor(options: Options);</span>
    <span class="s1">unstable_preloadEntries(): Promise&lt;</span><span class="s0">void</span><span class="s1">&gt;;</span>
    <span class="s0">protected </span><span class="s1">handleUpgrade(): Promise&lt;</span><span class="s0">void</span><span class="s1">&gt;;</span>
    <span class="s0">protected </span><span class="s1">loadInstrumentationModule(): Promise&lt;</span><span class="s0">import</span><span class="s1">(</span><span class="s2">&quot;./instrumentation/types&quot;</span><span class="s1">).InstrumentationModule | undefined&gt;;</span>
    <span class="s0">protected </span><span class="s1">prepareImpl(): Promise&lt;</span><span class="s0">void</span><span class="s1">&gt;;</span>
    <span class="s0">protected </span><span class="s1">runInstrumentationHookIfAvailable(): Promise&lt;</span><span class="s0">void</span><span class="s1">&gt;;</span>
    <span class="s0">protected </span><span class="s1">loadEnvConfig({ dev, forceReload, silent, }: {</span>
        <span class="s1">dev: boolean;</span>
        <span class="s1">forceReload?: boolean;</span>
        <span class="s1">silent?: boolean;</span>
    <span class="s1">}): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s0">private </span><span class="s1">loadCustomCacheHandlers;</span>
    <span class="s0">protected </span><span class="s1">getIncrementalCache({ requestHeaders, }: {</span>
        <span class="s1">requestHeaders: IncrementalCache[</span><span class="s2">'requestHeaders'</span><span class="s1">];</span>
    <span class="s1">}): Promise&lt;IncrementalCache&gt;;</span>
    <span class="s0">protected </span><span class="s1">getResponseCache(): ResponseCache;</span>
    <span class="s0">protected </span><span class="s1">getPublicDir(): string;</span>
    <span class="s0">protected </span><span class="s1">getHasStaticDir(): boolean;</span>
    <span class="s0">protected </span><span class="s1">getPagesManifest(): PagesManifest | undefined;</span>
    <span class="s0">protected </span><span class="s1">getAppPathsManifest(): PagesManifest | undefined;</span>
    <span class="s0">protected </span><span class="s1">getinterceptionRoutePatterns(): RegExp[];</span>
    <span class="s0">protected </span><span class="s1">hasPage(pathname: string): Promise&lt;boolean&gt;;</span>
    <span class="s0">protected </span><span class="s1">getBuildId(): string;</span>
    <span class="s0">protected </span><span class="s1">getEnabledDirectories(dev: boolean): NextEnabledDirectories;</span>
    <span class="s0">protected </span><span class="s1">sendRenderResult(req: NodeNextRequest, res: NodeNextResponse, options: {</span>
        <span class="s1">result: RenderResult;</span>
        <span class="s1">generateEtags: boolean;</span>
        <span class="s1">poweredByHeader: boolean;</span>
        <span class="s1">cacheControl: CacheControl | undefined;</span>
    <span class="s1">}): Promise&lt;</span><span class="s0">void</span><span class="s1">&gt;;</span>
    <span class="s0">protected </span><span class="s1">runApi(req: NodeNextRequest, res: NodeNextResponse, query: ParsedUrlQuery, match: PagesAPIRouteMatch): Promise&lt;boolean&gt;;</span>
    <span class="s0">protected </span><span class="s1">renderHTML(req: NodeNextRequest, res: NodeNextResponse, pathname: string, query: NextParsedUrlQuery, renderOpts: LoadedRenderOpts): Promise&lt;RenderResult&gt;;</span>
    <span class="s0">private </span><span class="s1">renderHTMLImpl;</span>
    <span class="s0">protected </span><span class="s1">imageOptimizer(req: NodeNextRequest, res: NodeNextResponse, paramsResult: </span><span class="s0">import</span><span class="s1">(</span><span class="s2">'./image-optimizer'</span><span class="s1">).ImageParamsResult, previousCacheEntry?: IncrementalResponseCacheEntry | </span><span class="s0">null</span><span class="s1">): Promise&lt;{</span>
        <span class="s1">buffer: Buffer;</span>
        <span class="s1">contentType: string;</span>
        <span class="s1">maxAge: number;</span>
        <span class="s1">upstreamEtag: string;</span>
        <span class="s1">etag: string;</span>
    <span class="s1">}&gt;;</span>
    <span class="s0">protected </span><span class="s1">getPagePath(pathname: string, locales?: string[]): string;</span>
    <span class="s0">protected </span><span class="s1">renderPageComponent(ctx: RequestContext&lt;NodeNextRequest, NodeNextResponse&gt;, bubbleNoFallback: boolean): Promise&lt;</span><span class="s0">false </span><span class="s1">| {</span>
        <span class="s1">body: RenderResult;</span>
        <span class="s1">cacheControl?: CacheControl;</span>
    <span class="s1">} | </span><span class="s0">null</span><span class="s1">&gt;;</span>
    <span class="s0">protected </span><span class="s1">findPageComponents({ locale, page, query, params, isAppPath, url, }: {</span>
        <span class="s1">locale: string | undefined;</span>
        <span class="s1">page: string;</span>
        <span class="s1">query: NextParsedUrlQuery;</span>
        <span class="s1">params: Params;</span>
        <span class="s1">isAppPath: boolean;</span>
        <span class="s1">sriEnabled?: boolean;</span>
        <span class="s1">appPaths?: ReadonlyArray&lt;string&gt; | </span><span class="s0">null</span><span class="s1">;</span>
        <span class="s1">shouldEnsure: boolean;</span>
        <span class="s1">url?: string;</span>
    <span class="s1">}): Promise&lt;FindComponentsResult | </span><span class="s0">null</span><span class="s1">&gt;;</span>
    <span class="s0">private </span><span class="s1">findPageComponentsImpl;</span>
    <span class="s0">protected </span><span class="s1">getNextFontManifest(): NextFontManifest | undefined;</span>
    <span class="s0">protected </span><span class="s1">handleNextImageRequest: NodeRouteHandler;</span>
    <span class="s0">protected </span><span class="s1">handleCatchallRenderRequest: NodeRouteHandler;</span>
    <span class="s0">protected </span><span class="s1">logErrorWithOriginalStack(_err?: unknown, _type?: </span><span class="s2">'unhandledRejection' </span><span class="s1">| </span><span class="s2">'uncaughtException' </span><span class="s1">| </span><span class="s2">'warning' </span><span class="s1">| </span><span class="s2">'app-dir'</span><span class="s1">): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s0">protected </span><span class="s1">ensurePage(_opts: {</span>
        <span class="s1">page: string;</span>
        <span class="s1">clientOnly: boolean;</span>
        <span class="s1">appPaths?: ReadonlyArray&lt;string&gt; | </span><span class="s0">null</span><span class="s1">;</span>
        <span class="s1">match?: RouteMatch;</span>
        <span class="s1">url?: string;</span>
    <span class="s1">}): Promise&lt;</span><span class="s0">void</span><span class="s1">&gt;;</span>
    <span class="s3">/**</span>
     <span class="s3">* Resolves `API` request, in development builds on demand</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">req http request</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">res http response</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">pathname path of request</span>
     <span class="s3">*/</span>
    <span class="s0">protected </span><span class="s1">handleApiRequest(req: NodeNextRequest, res: NodeNextResponse, query: ParsedUrlQuery, match: PagesAPIRouteMatch): Promise&lt;boolean&gt;;</span>
    <span class="s0">protected </span><span class="s1">getCacheFilesystem(): CacheFs;</span>
    <span class="s0">protected </span><span class="s1">normalizeReq(req: NodeNextRequest | IncomingMessage): NodeNextRequest;</span>
    <span class="s0">protected </span><span class="s1">normalizeRes(res: NodeNextResponse | ServerResponse): NodeNextResponse;</span>
    <span class="s1">getRequestHandler(): NodeRequestHandler;</span>
    <span class="s0">private </span><span class="s1">makeRequestHandler;</span>
    <span class="s1">revalidate({ urlPath, revalidateHeaders, opts, }: {</span>
        <span class="s1">urlPath: string;</span>
        <span class="s1">revalidateHeaders: {</span>
            <span class="s1">[key: string]: string | string[];</span>
        <span class="s1">};</span>
        <span class="s1">opts: {</span>
            <span class="s1">unstable_onlyGenerated?: boolean;</span>
        <span class="s1">};</span>
    <span class="s1">}): Promise&lt;</span><span class="s0">void</span><span class="s1">&gt;;</span>
    <span class="s1">render(req: NodeNextRequest | IncomingMessage, res: NodeNextResponse | ServerResponse, pathname: string, query?: NextParsedUrlQuery, parsedUrl?: NextUrlWithParsedQuery, internal?: boolean): Promise&lt;</span><span class="s0">void</span><span class="s1">&gt;;</span>
    <span class="s1">renderToHTML(req: NodeNextRequest | IncomingMessage, res: NodeNextResponse | ServerResponse, pathname: string, query?: ParsedUrlQuery): Promise&lt;string | </span><span class="s0">null</span><span class="s1">&gt;;</span>
    <span class="s0">protected </span><span class="s1">renderErrorToResponseImpl(ctx: RequestContext&lt;NodeNextRequest, NodeNextResponse&gt;, err: Error | </span><span class="s0">null</span><span class="s1">): Promise&lt;{</span>
        <span class="s1">body: RenderResult;</span>
        <span class="s1">cacheControl?: CacheControl;</span>
    <span class="s1">} | </span><span class="s0">null</span><span class="s1">&gt;;</span>
    <span class="s1">renderError(err: Error | </span><span class="s0">null</span><span class="s1">, req: NodeNextRequest | IncomingMessage, res: NodeNextResponse | ServerResponse, pathname: string, query?: NextParsedUrlQuery, setHeaders?: boolean): Promise&lt;</span><span class="s0">void</span><span class="s1">&gt;;</span>
    <span class="s1">renderErrorToHTML(err: Error | </span><span class="s0">null</span><span class="s1">, req: NodeNextRequest | IncomingMessage, res: NodeNextResponse | ServerResponse, pathname: string, query?: ParsedUrlQuery): Promise&lt;string | </span><span class="s0">null</span><span class="s1">&gt;;</span>
    <span class="s1">render404(req: NodeNextRequest | IncomingMessage, res: NodeNextResponse | ServerResponse, parsedUrl?: NextUrlWithParsedQuery, setHeaders?: boolean): Promise&lt;</span><span class="s0">void</span><span class="s1">&gt;;</span>
    <span class="s0">protected </span><span class="s1">getMiddlewareManifest(): MiddlewareManifest | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/** Returns the middleware routing item if there is one. */</span>
    <span class="s0">protected </span><span class="s1">getMiddleware(): Promise&lt;MiddlewareRoutingItem | undefined&gt;;</span>
    <span class="s0">protected </span><span class="s1">getEdgeFunctionsPages(): string[];</span>
    <span class="s3">/**</span>
     <span class="s3">* Get information for the edge function located in the provided page</span>
     <span class="s3">* folder. If the edge function info can't be found it will throw</span>
     <span class="s3">* an error.</span>
     <span class="s3">*/</span>
    <span class="s0">protected </span><span class="s1">getEdgeFunctionInfo(params: {</span>
        <span class="s1">page: string;</span>
        <span class="s3">/** Whether we should look for a middleware or not */</span>
        <span class="s1">middleware: boolean;</span>
    <span class="s1">}): {</span>
        <span class="s1">name: string;</span>
        <span class="s1">paths: string[];</span>
        <span class="s1">wasm: {</span>
            <span class="s1">filePath: string;</span>
            <span class="s1">name: string;</span>
        <span class="s1">}[];</span>
        <span class="s1">env: {</span>
            <span class="s1">[key: string]: string;</span>
        <span class="s1">};</span>
        <span class="s1">assets?: {</span>
            <span class="s1">filePath: string;</span>
            <span class="s1">name: string;</span>
        <span class="s1">}[];</span>
    <span class="s1">} | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s0">private </span><span class="s1">loadNodeMiddleware;</span>
    <span class="s3">/**</span>
     <span class="s3">* Checks if a middleware exists. This method is useful for the development</span>
     <span class="s3">* server where we need to check the filesystem. Here we just check the</span>
     <span class="s3">* middleware manifest.</span>
     <span class="s3">*/</span>
    <span class="s0">protected </span><span class="s1">hasMiddleware(pathname: string): Promise&lt;boolean&gt;;</span>
    <span class="s3">/**</span>
     <span class="s3">* A placeholder for a function to be defined in the development server.</span>
     <span class="s3">* It will make sure that the root middleware or an edge function has been compiled</span>
     <span class="s3">* so that we can run it.</span>
     <span class="s3">*/</span>
    <span class="s0">protected </span><span class="s1">ensureMiddleware(_url?: string): Promise&lt;</span><span class="s0">void</span><span class="s1">&gt;;</span>
    <span class="s0">protected </span><span class="s1">ensureEdgeFunction(_params: {</span>
        <span class="s1">page: string;</span>
        <span class="s1">appPaths: string[] | </span><span class="s0">null</span><span class="s1">;</span>
        <span class="s1">url?: string;</span>
    <span class="s1">}): Promise&lt;</span><span class="s0">void</span><span class="s1">&gt;;</span>
    <span class="s3">/**</span>
     <span class="s3">* This method gets all middleware matchers and execute them when the request</span>
     <span class="s3">* matches. It will make sure that each middleware exists and is compiled and</span>
     <span class="s3">* ready to be invoked. The development server will decorate it to add warns</span>
     <span class="s3">* and errors with rich traces.</span>
     <span class="s3">*/</span>
    <span class="s0">protected </span><span class="s1">runMiddleware(params: {</span>
        <span class="s1">request: NodeNextRequest;</span>
        <span class="s1">response: NodeNextResponse;</span>
        <span class="s1">parsedUrl: ParsedUrl;</span>
        <span class="s1">parsed: UrlWithParsedQuery;</span>
        <span class="s1">onWarning?: (warning: Error) =&gt; </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">}): Promise&lt;FetchEventResult | {</span>
        <span class="s1">finished: boolean;</span>
    <span class="s1">}&gt;;</span>
    <span class="s0">protected </span><span class="s1">handleCatchallMiddlewareRequest: NodeRouteHandler;</span>
    <span class="s0">private </span><span class="s1">_cachedPreviewManifest;</span>
    <span class="s0">protected </span><span class="s1">getPrerenderManifest(): PrerenderManifest;</span>
    <span class="s0">protected </span><span class="s1">getRoutesManifest(): NormalizedRouteManifest | undefined;</span>
    <span class="s0">protected </span><span class="s1">attachRequestMeta(req: NodeNextRequest, parsedUrl: NextUrlWithParsedQuery, isUpgradeReq?: boolean): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s0">protected </span><span class="s1">runEdgeFunction(params: {</span>
        <span class="s1">req: NodeNextRequest;</span>
        <span class="s1">res: NodeNextResponse;</span>
        <span class="s1">query: ParsedUrlQuery;</span>
        <span class="s1">params: Params | undefined;</span>
        <span class="s1">page: string;</span>
        <span class="s1">appPaths: string[] | </span><span class="s0">null</span><span class="s1">;</span>
        <span class="s1">match?: RouteMatch;</span>
        <span class="s1">onError?: (err: unknown) =&gt; </span><span class="s0">void</span><span class="s1">;</span>
        <span class="s1">onWarning?: (warning: Error) =&gt; </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">}): Promise&lt;FetchEventResult | </span><span class="s0">null</span><span class="s1">&gt;;</span>
    <span class="s0">protected </span><span class="s1">get serverDistDir(): string;</span>
    <span class="s0">protected </span><span class="s1">getFallbackErrorComponents(_url?: string): Promise&lt;LoadComponentsReturnType | </span><span class="s0">null</span><span class="s1">&gt;;</span>
    <span class="s0">protected </span><span class="s1">instrumentationOnRequestError(...args: Parameters&lt;ServerOnInstrumentationRequestError&gt;): Promise&lt;</span><span class="s0">void</span><span class="s1">&gt;;</span>
    <span class="s0">protected </span><span class="s1">onServerClose(listener: () =&gt; Promise&lt;</span><span class="s0">void</span><span class="s1">&gt;): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">close(): Promise&lt;</span><span class="s0">void</span><span class="s1">&gt;;</span>
    <span class="s0">protected </span><span class="s1">getInternalWaitUntil(): WaitUntil;</span>
    <span class="s0">private </span><span class="s1">createInternalWaitUntil;</span>
<span class="s1">}</span>
</pre>
</body>
</html>