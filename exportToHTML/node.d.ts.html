<html>
<head>
<title>node.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
node.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">AtRule = require(</span><span class="s2">'./at-rule.js'</span><span class="s1">)</span>
<span class="s0">import </span><span class="s1">{ AtRuleProps } from </span><span class="s2">'./at-rule.js'</span>
<span class="s0">import </span><span class="s1">Comment, { CommentProps } from </span><span class="s2">'./comment.js'</span>
<span class="s0">import </span><span class="s1">Container, { NewChild } from </span><span class="s2">'./container.js'</span>
<span class="s0">import </span><span class="s1">CssSyntaxError from </span><span class="s2">'./css-syntax-error.js'</span>
<span class="s0">import </span><span class="s1">Declaration, { DeclarationProps } from </span><span class="s2">'./declaration.js'</span>
<span class="s0">import </span><span class="s1">Document from </span><span class="s2">'./document.js'</span>
<span class="s0">import </span><span class="s1">Input from </span><span class="s2">'./input.js'</span>
<span class="s0">import </span><span class="s1">{ Stringifier, Syntax } from </span><span class="s2">'./postcss.js'</span>
<span class="s0">import </span><span class="s1">Result from </span><span class="s2">'./result.js'</span>
<span class="s0">import </span><span class="s1">Root from </span><span class="s2">'./root.js'</span>
<span class="s0">import </span><span class="s1">Rule, { RuleProps } from </span><span class="s2">'./rule.js'</span>
<span class="s0">import </span><span class="s1">Warning, { WarningOptions } from </span><span class="s2">'./warning.js'</span>

<span class="s1">declare namespace Node {</span>
  <span class="s0">export </span><span class="s1">type ChildNode = AtRule.default | Comment | Declaration | Rule</span>

  <span class="s0">export </span><span class="s1">type AnyNode =</span>
    <span class="s1">| AtRule.default</span>
    <span class="s1">| Comment</span>
    <span class="s1">| Declaration</span>
    <span class="s1">| Document</span>
    <span class="s1">| Root</span>
    <span class="s1">| Rule</span>

  <span class="s0">export </span><span class="s1">type ChildProps =</span>
    <span class="s1">| AtRuleProps</span>
    <span class="s1">| CommentProps</span>
    <span class="s1">| DeclarationProps</span>
    <span class="s1">| RuleProps</span>

  <span class="s0">export interface </span><span class="s1">Position {</span>
    <span class="s3">/**</span>
     <span class="s3">* Source line in file. In contrast to `offset` it starts from 1.</span>
     <span class="s3">*/</span>
    <span class="s1">column: number</span>

    <span class="s3">/**</span>
     <span class="s3">* Source column in file.</span>
     <span class="s3">*/</span>
    <span class="s1">line: number</span>

    <span class="s3">/**</span>
     <span class="s3">* Source offset in file. It starts from 0.</span>
     <span class="s3">*/</span>
    <span class="s1">offset: number</span>
  <span class="s1">}</span>

  <span class="s0">export interface </span><span class="s1">Range {</span>
    <span class="s3">/**</span>
     <span class="s3">* End position, exclusive.</span>
     <span class="s3">*/</span>
    <span class="s1">end: Position</span>

    <span class="s3">/**</span>
     <span class="s3">* Start position, inclusive.</span>
     <span class="s3">*/</span>
    <span class="s1">start: Position</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Source represents an interface for the {</span><span class="s4">@link </span><span class="s3">Node.source} property.</span>
   <span class="s3">*/</span>
  <span class="s0">export interface </span><span class="s1">Source {</span>
    <span class="s3">/**</span>
     <span class="s3">* The inclusive ending position for the source</span>
     <span class="s3">* code of a node.</span>
     <span class="s3">*</span>
     <span class="s3">* However, `end.offset` of a non `Root` node is the exclusive position.</span>
     <span class="s3">* See https://github.com/postcss/postcss/pull/1879 for details.</span>
     <span class="s3">*</span>
     <span class="s3">* ```js</span>
     <span class="s3">* const root = postcss.parse('a { color: black }')</span>
     <span class="s3">* const a = root.first</span>
     <span class="s3">* const color = a.first</span>
     <span class="s3">*</span>
     <span class="s3">* // The offset of `Root` node is the inclusive position</span>
     <span class="s3">* css.source.end   // { line: 1, column: 19, offset: 18 }</span>
     <span class="s3">*</span>
     <span class="s3">* // The offset of non `Root` node is the exclusive position</span>
     <span class="s3">* a.source.end     // { line: 1, column: 18, offset: 18 }</span>
     <span class="s3">* color.source.end // { line: 1, column: 16, offset: 16 }</span>
     <span class="s3">* ```</span>
     <span class="s3">*/</span>
    <span class="s1">end?: Position</span>

    <span class="s3">/**</span>
     <span class="s3">* The source file from where a node has originated.</span>
     <span class="s3">*/</span>
    <span class="s1">input: Input</span>

    <span class="s3">/**</span>
     <span class="s3">* The inclusive starting position for the source</span>
     <span class="s3">* code of a node.</span>
     <span class="s3">*/</span>
    <span class="s1">start?: Position</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Interface represents an interface for an object received</span>
   <span class="s3">* as parameter by Node class constructor.</span>
   <span class="s3">*/</span>
  <span class="s0">export interface </span><span class="s1">NodeProps {</span>
    <span class="s1">source?: Source</span>
  <span class="s1">}</span>

  <span class="s0">export interface </span><span class="s1">NodeErrorOptions {</span>
    <span class="s3">/**</span>
     <span class="s3">* An ending index inside a node's string that should be highlighted as</span>
     <span class="s3">* source of error.</span>
     <span class="s3">*/</span>
    <span class="s1">endIndex?: number</span>
    <span class="s3">/**</span>
     <span class="s3">* An index inside a node's string that should be highlighted as source</span>
     <span class="s3">* of error.</span>
     <span class="s3">*/</span>
    <span class="s1">index?: number</span>
    <span class="s3">/**</span>
     <span class="s3">* Plugin name that created this error. PostCSS will set it automatically.</span>
     <span class="s3">*/</span>
    <span class="s1">plugin?: string</span>
    <span class="s3">/**</span>
     <span class="s3">* A word inside a node's string, that should be highlighted as source</span>
     <span class="s3">* of error.</span>
     <span class="s3">*/</span>
    <span class="s1">word?: string</span>
  <span class="s1">}</span>

  <span class="s3">// eslint-disable-next-line @typescript-eslint/no-shadow</span>
  <span class="s0">class </span><span class="s1">Node </span><span class="s0">extends </span><span class="s1">Node_ {}</span>
  <span class="s0">export </span><span class="s1">{ Node as </span><span class="s0">default </span><span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* It represents an abstract class that handles common</span>
 <span class="s3">* methods for other CSS abstract syntax tree nodes.</span>
 <span class="s3">*</span>
 <span class="s3">* Any node that represents CSS selector or value should</span>
 <span class="s3">* not extend the `Node` class.</span>
 <span class="s3">*/</span>
<span class="s1">declare abstract </span><span class="s0">class </span><span class="s1">Node_ {</span>
  <span class="s3">/**</span>
   <span class="s3">* It represents parent of the current node.</span>
   <span class="s3">*</span>
   <span class="s3">* ```js</span>
   <span class="s3">* root.nodes[0].parent === root //=&gt; true</span>
   <span class="s3">* ```</span>
   <span class="s3">*/</span>
  <span class="s1">parent: Container | Document | undefined</span>

  <span class="s3">/**</span>
   <span class="s3">* It represents unnecessary whitespace and characters present</span>
   <span class="s3">* in the css source code.</span>
   <span class="s3">*</span>
   <span class="s3">* Information to generate byte-to-byte equal node string as it was</span>
   <span class="s3">* in the origin input.</span>
   <span class="s3">*</span>
   <span class="s3">* The properties of the raws object are decided by parser,</span>
   <span class="s3">* the default parser uses the following properties:</span>
   <span class="s3">*</span>
   <span class="s3">* * `before`: the space symbols before the node. It also stores `*`</span>
   <span class="s3">*   and `_` symbols before the declaration (IE hack).</span>
   <span class="s3">* * `after`: the space symbols after the last child of the node</span>
   <span class="s3">*   to the end of the node.</span>
   <span class="s3">* * `between`: the symbols between the property and value</span>
   <span class="s3">*   for declarations, selector and `{` for rules, or last parameter</span>
   <span class="s3">*   and `{` for at-rules.</span>
   <span class="s3">* * `semicolon`: contains true if the last child has</span>
   <span class="s3">*   an (optional) semicolon.</span>
   <span class="s3">* * `afterName`: the space between the at-rule name and its parameters.</span>
   <span class="s3">* * `left`: the space symbols between `/*` and the comment’s text.</span>
   <span class="s3">* * `right`: the space symbols between the comment’s text</span>
   <span class="s3">*   and &lt;code&gt;*&amp;#47;&lt;/code&gt;.</span>
   <span class="s3">* - `important`: the content of the important statement,</span>
   <span class="s3">*   if it is not just `!important`.</span>
   <span class="s3">*</span>
   <span class="s3">* PostCSS filters out the comments inside selectors, declaration values</span>
   <span class="s3">* and at-rule parameters but it stores the origin content in raws.</span>
   <span class="s3">*</span>
   <span class="s3">* ```js</span>
   <span class="s3">* const root = postcss.parse('a {\n  color:black\n}')</span>
   <span class="s3">* root.first.first.raws //=&gt; { before: '\n  ', between: ':' }</span>
   <span class="s3">* ```</span>
   <span class="s3">*/</span>
  <span class="s1">raws: any</span>

  <span class="s3">/**</span>
   <span class="s3">* It represents information related to origin of a node and is required</span>
   <span class="s3">* for generating source maps.</span>
   <span class="s3">*</span>
   <span class="s3">* The nodes that are created manually using the public APIs</span>
   <span class="s3">* provided by PostCSS will have `source` undefined and</span>
   <span class="s3">* will be absent in the source map.</span>
   <span class="s3">*</span>
   <span class="s3">* For this reason, the plugin developer should consider</span>
   <span class="s3">* duplicating nodes as the duplicate node will have the</span>
   <span class="s3">* same source as the original node by default or assign</span>
   <span class="s3">* source to a node created manually.</span>
   <span class="s3">*</span>
   <span class="s3">* ```js</span>
   <span class="s3">* decl.source.input.from //=&gt; '/home/ai/source.css'</span>
   <span class="s3">* decl.source.start      //=&gt; { line: 10, column: 2 }</span>
   <span class="s3">* decl.source.end        //=&gt; { line: 10, column: 12 }</span>
   <span class="s3">* ```</span>
   <span class="s3">*</span>
   <span class="s3">* ```js</span>
   <span class="s3">* // Incorrect method, source not specified!</span>
   <span class="s3">* const prefixed = postcss.decl({</span>
   <span class="s3">*   prop: '-moz-' + decl.prop,</span>
   <span class="s3">*   value: decl.value</span>
   <span class="s3">* })</span>
   <span class="s3">*</span>
   <span class="s3">* // Correct method, source is inherited when duplicating.</span>
   <span class="s3">* const prefixed = decl.clone({</span>
   <span class="s3">*   prop: '-moz-' + decl.prop</span>
   <span class="s3">* })</span>
   <span class="s3">* ```</span>
   <span class="s3">*</span>
   <span class="s3">* ```js</span>
   <span class="s3">* if (atrule.name === 'add-link') {</span>
   <span class="s3">*   const rule = postcss.rule({</span>
   <span class="s3">*     selector: 'a',</span>
   <span class="s3">*     source: atrule.source</span>
   <span class="s3">*   })</span>
   <span class="s3">*</span>
   <span class="s3">*  atrule.parent.insertBefore(atrule, rule)</span>
   <span class="s3">* }</span>
   <span class="s3">* ```</span>
   <span class="s3">*/</span>
  <span class="s1">source?: Node.Source</span>

  <span class="s3">/**</span>
   <span class="s3">* It represents type of a node in</span>
   <span class="s3">* an abstract syntax tree.</span>
   <span class="s3">*</span>
   <span class="s3">* A type of node helps in identification of a node</span>
   <span class="s3">* and perform operation based on it's type.</span>
   <span class="s3">*</span>
   <span class="s3">* ```js</span>
   <span class="s3">* const declaration = new Declaration({</span>
   <span class="s3">*   prop: 'color',</span>
   <span class="s3">*   value: 'black'</span>
   <span class="s3">* })</span>
   <span class="s3">*</span>
   <span class="s3">* declaration.type //=&gt; 'decl'</span>
   <span class="s3">* ```</span>
   <span class="s3">*/</span>
  <span class="s1">type: string</span>

  <span class="s1">constructor(defaults?: object)</span>

  <span class="s3">/**</span>
   <span class="s3">* Insert new node after current node to current node’s parent.</span>
   <span class="s3">*</span>
   <span class="s3">* Just alias for `node.parent.insertAfter(node, add)`.</span>
   <span class="s3">*</span>
   <span class="s3">* ```js</span>
   <span class="s3">* decl.after('color: black')</span>
   <span class="s3">* ```</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">newNode New node.</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">This node for methods chain.</span>
   <span class="s3">*/</span>
  <span class="s1">after(</span>
    <span class="s1">newNode: Node | Node.ChildProps | readonly Node[] | string | undefined</span>
  <span class="s1">): </span><span class="s0">this</span>

  <span class="s3">/**</span>
   <span class="s3">* It assigns properties to an existing node instance.</span>
   <span class="s3">*</span>
   <span class="s3">* ```js</span>
   <span class="s3">* decl.assign({ prop: 'word-wrap', value: 'break-word' })</span>
   <span class="s3">* ```</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">overrides New properties to override the node.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">`this` for method chaining.</span>
   <span class="s3">*/</span>
  <span class="s1">assign(overrides: object): </span><span class="s0">this</span>

  <span class="s3">/**</span>
   <span class="s3">* Insert new node before current node to current node’s parent.</span>
   <span class="s3">*</span>
   <span class="s3">* Just alias for `node.parent.insertBefore(node, add)`.</span>
   <span class="s3">*</span>
   <span class="s3">* ```js</span>
   <span class="s3">* decl.before('content: &quot;&quot;')</span>
   <span class="s3">* ```</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">newNode New node.</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">This node for methods chain.</span>
   <span class="s3">*/</span>
  <span class="s1">before(</span>
    <span class="s1">newNode: Node | Node.ChildProps | readonly Node[] | string | undefined</span>
  <span class="s1">): </span><span class="s0">this</span>

  <span class="s3">/**</span>
   <span class="s3">* Clear the code style properties for the node and its children.</span>
   <span class="s3">*</span>
   <span class="s3">* ```js</span>
   <span class="s3">* node.raws.before  //=&gt; ' '</span>
   <span class="s3">* node.cleanRaws()</span>
   <span class="s3">* node.raws.before  //=&gt; undefined</span>
   <span class="s3">* ```</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">keepBetween Keep the `raws.between` symbols.</span>
   <span class="s3">*/</span>
  <span class="s1">cleanRaws(keepBetween?: boolean): </span><span class="s0">void</span>

  <span class="s3">/**</span>
   <span class="s3">* It creates clone of an existing node, which includes all the properties</span>
   <span class="s3">* and their values, that includes `raws` but not `type`.</span>
   <span class="s3">*</span>
   <span class="s3">* ```js</span>
   <span class="s3">* decl.raws.before    //=&gt; &quot;\n  &quot;</span>
   <span class="s3">* const cloned = decl.clone({ prop: '-moz-' + decl.prop })</span>
   <span class="s3">* cloned.raws.before  //=&gt; &quot;\n  &quot;</span>
   <span class="s3">* cloned.toString()   //=&gt; -moz-transform: scale(0)</span>
   <span class="s3">* ```</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">overrides New properties to override in the clone.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">Duplicate of the node instance.</span>
   <span class="s3">*/</span>
  <span class="s1">clone(overrides?: object): </span><span class="s0">this</span>

  <span class="s3">/**</span>
   <span class="s3">* Shortcut to clone the node and insert the resulting cloned node</span>
   <span class="s3">* after the current node.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">overrides New properties to override in the clone.</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">New node.</span>
   <span class="s3">*/</span>
  <span class="s1">cloneAfter(overrides?: object): </span><span class="s0">this</span>

  <span class="s3">/**</span>
   <span class="s3">* Shortcut to clone the node and insert the resulting cloned node</span>
   <span class="s3">* before the current node.</span>
   <span class="s3">*</span>
   <span class="s3">* ```js</span>
   <span class="s3">* decl.cloneBefore({ prop: '-moz-' + decl.prop })</span>
   <span class="s3">* ```</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">overrides Mew properties to override in the clone.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">New node</span>
   <span class="s3">*/</span>
  <span class="s1">cloneBefore(overrides?: object): </span><span class="s0">this</span>

  <span class="s3">/**</span>
   <span class="s3">* It creates an instance of the class `CssSyntaxError` and parameters passed</span>
   <span class="s3">* to this method are assigned to the error instance.</span>
   <span class="s3">*</span>
   <span class="s3">* The error instance will have description for the</span>
   <span class="s3">* error, original position of the node in the</span>
   <span class="s3">* source, showing line and column number.</span>
   <span class="s3">*</span>
   <span class="s3">* If any previous map is present, it would be used</span>
   <span class="s3">* to get original position of the source.</span>
   <span class="s3">*</span>
   <span class="s3">* The Previous Map here is referred to the source map</span>
   <span class="s3">* generated by previous compilation, example: Less,</span>
   <span class="s3">* Stylus and Sass.</span>
   <span class="s3">*</span>
   <span class="s3">* This method returns the error instance instead of</span>
   <span class="s3">* throwing it.</span>
   <span class="s3">*</span>
   <span class="s3">* ```js</span>
   <span class="s3">* if (!variables[name]) {</span>
   <span class="s3">*   throw decl.error(`Unknown variable ${name}`, { word: name })</span>
   <span class="s3">*   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black</span>
   <span class="s3">*   //   color: $black</span>
   <span class="s3">*   // a</span>
   <span class="s3">*   //          ^</span>
   <span class="s3">*   //   background: white</span>
   <span class="s3">* }</span>
   <span class="s3">* ```</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">message Description for the error instance.</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">options Options for the error instance.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">Error instance is returned.</span>
   <span class="s3">*/</span>
  <span class="s1">error(message: string, options?: Node.NodeErrorOptions): CssSyntaxError</span>

  <span class="s3">/**</span>
   <span class="s3">* Returns the next child of the node’s parent.</span>
   <span class="s3">* Returns `undefined` if the current node is the last child.</span>
   <span class="s3">*</span>
   <span class="s3">* ```js</span>
   <span class="s3">* if (comment.text === 'delete next') {</span>
   <span class="s3">*   const next = comment.next()</span>
   <span class="s3">*   if (next) {</span>
   <span class="s3">*     next.remove()</span>
   <span class="s3">*   }</span>
   <span class="s3">* }</span>
   <span class="s3">* ```</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">Next node.</span>
   <span class="s3">*/</span>
  <span class="s1">next(): Node.ChildNode | undefined</span>

  <span class="s3">/**</span>
   <span class="s3">* Get the position for a word or an index inside the node.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">opts Options.</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">Position.</span>
   <span class="s3">*/</span>
  <span class="s1">positionBy(opts?: Pick&lt;WarningOptions, </span><span class="s2">'index' </span><span class="s1">| </span><span class="s2">'word'</span><span class="s1">&gt;): Node.Position</span>

  <span class="s3">/**</span>
   <span class="s3">* Convert string index to line/column.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">index The symbol number in the node’s string.</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">Symbol position in file.</span>
   <span class="s3">*/</span>
  <span class="s1">positionInside(index: number): Node.Position</span>

  <span class="s3">/**</span>
   <span class="s3">* Returns the previous child of the node’s parent.</span>
   <span class="s3">* Returns `undefined` if the current node is the first child.</span>
   <span class="s3">*</span>
   <span class="s3">* ```js</span>
   <span class="s3">* const annotation = decl.prev()</span>
   <span class="s3">* if (annotation.type === 'comment') {</span>
   <span class="s3">*   readAnnotation(annotation.text)</span>
   <span class="s3">* }</span>
   <span class="s3">* ```</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">Previous node.</span>
   <span class="s3">*/</span>
  <span class="s1">prev(): Node.ChildNode | undefined</span>

  <span class="s3">/**</span>
   <span class="s3">* Get the range for a word or start and end index inside the node.</span>
   <span class="s3">* The start index is inclusive; the end index is exclusive.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">opts Options.</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">Range.</span>
   <span class="s3">*/</span>
  <span class="s1">rangeBy(</span>
    <span class="s1">opts?: Pick&lt;WarningOptions, </span><span class="s2">'end' </span><span class="s1">| </span><span class="s2">'endIndex' </span><span class="s1">| </span><span class="s2">'index' </span><span class="s1">| </span><span class="s2">'start' </span><span class="s1">| </span><span class="s2">'word'</span><span class="s1">&gt;</span>
  <span class="s1">): Node.Range</span>

  <span class="s3">/**</span>
   <span class="s3">* Returns a `raws` value. If the node is missing</span>
   <span class="s3">* the code style property (because the node was manually built or cloned),</span>
   <span class="s3">* PostCSS will try to autodetect the code style property by looking</span>
   <span class="s3">* at other nodes in the tree.</span>
   <span class="s3">*</span>
   <span class="s3">* ```js</span>
   <span class="s3">* const root = postcss.parse('a { background: white }')</span>
   <span class="s3">* root.nodes[0].append({ prop: 'color', value: 'black' })</span>
   <span class="s3">* root.nodes[0].nodes[1].raws.before   //=&gt; undefined</span>
   <span class="s3">* root.nodes[0].nodes[1].raw('before') //=&gt; ' '</span>
   <span class="s3">* ```</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">prop        Name of code style property.</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">defaultType Name of default value, it can be missed</span>
   <span class="s3">*                    if the value is the same as prop.</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">{string} Code style value.</span>
   <span class="s3">*/</span>
  <span class="s1">raw(prop: string, defaultType?: string): string</span>

  <span class="s3">/**</span>
   <span class="s3">* It removes the node from its parent and deletes its parent property.</span>
   <span class="s3">*</span>
   <span class="s3">* ```js</span>
   <span class="s3">* if (decl.prop.match(/^-webkit-/)) {</span>
   <span class="s3">*   decl.remove()</span>
   <span class="s3">* }</span>
   <span class="s3">* ```</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">`this` for method chaining.</span>
   <span class="s3">*/</span>
  <span class="s1">remove(): </span><span class="s0">this</span>

  <span class="s3">/**</span>
   <span class="s3">* Inserts node(s) before the current node and removes the current node.</span>
   <span class="s3">*</span>
   <span class="s3">* ```js</span>
   <span class="s3">* AtRule: {</span>
   <span class="s3">*   mixin: atrule =&gt; {</span>
   <span class="s3">*     atrule.replaceWith(mixinRules[atrule.params])</span>
   <span class="s3">*   }</span>
   <span class="s3">* }</span>
   <span class="s3">* ```</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">nodes Mode(s) to replace current one.</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">Current node to methods chain.</span>
   <span class="s3">*/</span>
  <span class="s1">replaceWith(...nodes: NewChild[]): </span><span class="s0">this</span>

  <span class="s3">/**</span>
   <span class="s3">* Finds the Root instance of the node’s tree.</span>
   <span class="s3">*</span>
   <span class="s3">* ```js</span>
   <span class="s3">* root.nodes[0].nodes[0].root() === root</span>
   <span class="s3">* ```</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">Root parent.</span>
   <span class="s3">*/</span>
  <span class="s1">root(): Root</span>

  <span class="s3">/**</span>
   <span class="s3">* Fix circular links on `JSON.stringify()`.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">Cleaned object.</span>
   <span class="s3">*/</span>
  <span class="s1">toJSON(): object</span>

  <span class="s3">/**</span>
   <span class="s3">* It compiles the node to browser readable cascading style sheets string</span>
   <span class="s3">* depending on it's type.</span>
   <span class="s3">*</span>
   <span class="s3">* ```js</span>
   <span class="s3">* new Rule({ selector: 'a' }).toString() //=&gt; &quot;a {}&quot;</span>
   <span class="s3">* ```</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">stringifier A syntax to use in string generation.</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">CSS string of this node.</span>
   <span class="s3">*/</span>
  <span class="s1">toString(stringifier?: Stringifier | Syntax): string</span>

  <span class="s3">/**</span>
   <span class="s3">* It is a wrapper for {</span><span class="s4">@link </span><span class="s3">Result#warn}, providing convenient</span>
   <span class="s3">* way of generating warnings.</span>
   <span class="s3">*</span>
   <span class="s3">* ```js</span>
   <span class="s3">*   Declaration: {</span>
   <span class="s3">*     bad: (decl, { result }) =&gt; {</span>
   <span class="s3">*       decl.warn(result, 'Deprecated property: bad')</span>
   <span class="s3">*     }</span>
   <span class="s3">*   }</span>
   <span class="s3">* ```</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">result The `Result` instance that will receive the warning.</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">message Description for the warning.</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">options Options for the warning.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">`Warning` instance is returned</span>
   <span class="s3">*/</span>
  <span class="s1">warn(result: Result, message: string, options?: WarningOptions): Warning</span>

  <span class="s3">/**</span>
   <span class="s3">* If this node isn't already dirty, marks it and its ancestors as such. This</span>
   <span class="s3">* indicates to the LazyResult processor that the {</span><span class="s4">@link </span><span class="s3">Root} has been</span>
   <span class="s3">* modified by the current plugin and may need to be processed again by other</span>
   <span class="s3">* plugins.</span>
   <span class="s3">*/</span>
  <span class="s0">protected </span><span class="s1">markDirty(): </span><span class="s0">void</span>
<span class="s1">}</span>

<span class="s1">declare </span><span class="s0">class </span><span class="s1">Node </span><span class="s0">extends </span><span class="s1">Node_ {}</span>

<span class="s0">export </span><span class="s1">= Node</span>
</pre>
</body>
</html>