<html>
<head>
<title>route-types-utils.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
route-types-utils.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/server/lib/router-utils/route-types-utils.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import path from 'path'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getRouteRegex,</span><span class="s3">\n  </span><span class="s1">type Group,</span><span class="s3">\n</span><span class="s1">} from '../../../shared/lib/router/utils/route-regex'</span><span class="s3">\n</span><span class="s1">import type { NextConfigComplete } from '../../config-shared'</span><span class="s3">\n\n</span><span class="s1">import fs from 'fs'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">generateRouteTypesFile,</span><span class="s3">\n  </span><span class="s1">generateLinkTypesFile,</span><span class="s3">\n  </span><span class="s1">generateValidatorFile,</span><span class="s3">\n</span><span class="s1">} from './typegen'</span><span class="s3">\n</span><span class="s1">import { tryToParsePath } from '../../../lib/try-to-parse-path'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">extractInterceptionRouteInformation,</span><span class="s3">\n  </span><span class="s1">isInterceptionRouteAppPath,</span><span class="s3">\n</span><span class="s1">} from '../../../shared/lib/router/utils/interception-routes'</span><span class="s3">\n\n</span><span class="s1">import { normalizePathSep } from '../../../shared/lib/page-path/normalize-path-sep'</span><span class="s3">\n\n</span><span class="s1">interface RouteInfo {</span><span class="s3">\n  </span><span class="s1">path: string</span><span class="s3">\n  </span><span class="s1">groups: { [groupName: string]: Group }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface RouteTypesManifest {</span><span class="s3">\n  </span><span class="s1">appRoutes: Record&lt;string, RouteInfo&gt;</span><span class="s3">\n  </span><span class="s1">pageRoutes: Record&lt;string, RouteInfo&gt;</span><span class="s3">\n  </span><span class="s1">layoutRoutes: Record&lt;string, RouteInfo &amp; { slots: string[] }&gt;</span><span class="s3">\n  </span><span class="s1">appRouteHandlerRoutes: Record&lt;string, RouteInfo&gt;</span><span class="s3">\n  </span><span class="s1">/** Map of redirect source =&gt; RouteInfo */</span><span class="s3">\n  </span><span class="s1">redirectRoutes: Record&lt;string, RouteInfo&gt;</span><span class="s3">\n  </span><span class="s1">/** Map of rewrite source =&gt; RouteInfo */</span><span class="s3">\n  </span><span class="s1">rewriteRoutes: Record&lt;string, RouteInfo&gt;</span><span class="s3">\n  </span><span class="s1">/** File paths for validation */</span><span class="s3">\n  </span><span class="s1">appPagePaths: Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">pagesRouterPagePaths: Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">layoutPaths: Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">appRouteHandlers: Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">pageApiRoutes: Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">/** Direct mapping from file paths to routes for validation */</span><span class="s3">\n  </span><span class="s1">filePathToRoute: Map&lt;string, string&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Convert a custom-route source string (`/blog/:slug`, `/docs/:path*`, ...)</span><span class="s3">\n</span><span class="s1">// into the bracket-syntax used by other Next.js route helpers so that we can</span><span class="s3">\n</span><span class="s1">// reuse `getRouteRegex()` to extract groups.</span><span class="s3">\n</span><span class="s1">export function convertCustomRouteSource(source: string): string[] {</span><span class="s3">\n  </span><span class="s1">const parseResult = tryToParsePath(source)</span><span class="s3">\n\n  </span><span class="s1">if (parseResult.error || !parseResult.tokens) {</span><span class="s3">\n    </span><span class="s1">// Fallback to original source if parsing fails</span><span class="s3">\n    </span><span class="s1">return source.startsWith('/') ? [source] : ['/' + source]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const possibleNormalizedRoutes = ['']</span><span class="s3">\n  </span><span class="s1">let slugCnt = 1</span><span class="s3">\n\n  </span><span class="s1">function append(suffix: string) {</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; possibleNormalizedRoutes.length; i++) {</span><span class="s3">\n      </span><span class="s1">possibleNormalizedRoutes[i] += suffix</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function fork(suffix: string) {</span><span class="s3">\n    </span><span class="s1">const currentLength = possibleNormalizedRoutes.length</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; currentLength; i++) {</span><span class="s3">\n      </span><span class="s1">possibleNormalizedRoutes.push(possibleNormalizedRoutes[i] + suffix)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const token of parseResult.tokens) {</span><span class="s3">\n    </span><span class="s1">if (typeof token === 'object') {</span><span class="s3">\n      </span><span class="s1">// Make sure the slug is always named.</span><span class="s3">\n      </span><span class="s1">const slug = token.name || (slugCnt++ === 1 ? 'slug' : `slug${slugCnt}`)</span><span class="s3">\n      </span><span class="s1">if (token.modifier === '*') {</span><span class="s3">\n        </span><span class="s1">append(`${token.prefix}[[...${slug}]]`)</span><span class="s3">\n      </span><span class="s1">} else if (token.modifier === '+') {</span><span class="s3">\n        </span><span class="s1">append(`${token.prefix}[...${slug}]`)</span><span class="s3">\n      </span><span class="s1">} else if (token.modifier === '') {</span><span class="s3">\n        </span><span class="s1">if (token.pattern === '[^</span><span class="s3">\\\\</span><span class="s1">/#</span><span class="s3">\\\\</span><span class="s1">?]+?') {</span><span class="s3">\n          </span><span class="s1">// A safe slug</span><span class="s3">\n          </span><span class="s1">append(`${token.prefix}[${slug}]`)</span><span class="s3">\n        </span><span class="s1">} else if (token.pattern === '.*') {</span><span class="s3">\n          </span><span class="s1">// An optional catch-all slug</span><span class="s3">\n          </span><span class="s1">append(`${token.prefix}[[...${slug}]]`)</span><span class="s3">\n        </span><span class="s1">} else if (token.pattern === '.+') {</span><span class="s3">\n          </span><span class="s1">// A catch-all slug</span><span class="s3">\n          </span><span class="s1">append(`${token.prefix}[...${slug}]`)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// Other regex patterns are not supported. Skip this route.</span><span class="s3">\n          </span><span class="s1">return []</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (token.modifier === '?') {</span><span class="s3">\n        </span><span class="s1">if (/^[a-zA-Z0-9_/]*$/.test(token.pattern)) {</span><span class="s3">\n          </span><span class="s1">// An optional slug with plain text only, fork the route.</span><span class="s3">\n          </span><span class="s1">append(token.prefix)</span><span class="s3">\n          </span><span class="s1">fork(token.pattern)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// Optional modifier `?` and regex patterns are not supported.</span><span class="s3">\n          </span><span class="s1">return []</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (typeof token === 'string') {</span><span class="s3">\n      </span><span class="s1">append(token)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Ensure leading slash</span><span class="s3">\n  </span><span class="s1">return possibleNormalizedRoutes.map((route) =&gt;</span><span class="s3">\n    </span><span class="s1">route.startsWith('/') ? route : '/' + route</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Extracts route parameters from a route pattern</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function extractRouteParams(route: string) {</span><span class="s3">\n  </span><span class="s1">const regex = getRouteRegex(route)</span><span class="s3">\n  </span><span class="s1">return regex.groups</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Resolves an intercepting route to its canonical equivalent</span><span class="s3">\n </span><span class="s1">* Example: /gallery/test/(..)photo/[id] -&gt; /gallery/photo/[id]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function resolveInterceptingRoute(route: string): string {</span><span class="s3">\n  </span><span class="s1">// Reuse centralized interception route normalization logic</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">if (!isInterceptionRouteAppPath(route)) return route</span><span class="s3">\n    </span><span class="s1">const { interceptedRoute } = extractInterceptionRouteInformation(route)</span><span class="s3">\n    </span><span class="s1">return interceptedRoute</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">// If parsing fails, fall back to the original route</span><span class="s3">\n    </span><span class="s1">return route</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a route types manifest from processed route data</span><span class="s3">\n </span><span class="s1">* (used for both build and dev)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export async function createRouteTypesManifest({</span><span class="s3">\n  </span><span class="s1">dir,</span><span class="s3">\n  </span><span class="s1">pageRoutes,</span><span class="s3">\n  </span><span class="s1">appRoutes,</span><span class="s3">\n  </span><span class="s1">appRouteHandlers,</span><span class="s3">\n  </span><span class="s1">pageApiRoutes,</span><span class="s3">\n  </span><span class="s1">layoutRoutes,</span><span class="s3">\n  </span><span class="s1">slots,</span><span class="s3">\n  </span><span class="s1">redirects,</span><span class="s3">\n  </span><span class="s1">rewrites,</span><span class="s3">\n  </span><span class="s1">validatorFilePath,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">dir: string</span><span class="s3">\n  </span><span class="s1">pageRoutes: Array&lt;{ route: string; filePath: string }&gt;</span><span class="s3">\n  </span><span class="s1">appRoutes: Array&lt;{ route: string; filePath: string }&gt;</span><span class="s3">\n  </span><span class="s1">appRouteHandlers: Array&lt;{ route: string; filePath: string }&gt;</span><span class="s3">\n  </span><span class="s1">pageApiRoutes: Array&lt;{ route: string; filePath: string }&gt;</span><span class="s3">\n  </span><span class="s1">layoutRoutes: Array&lt;{ route: string; filePath: string }&gt;</span><span class="s3">\n  </span><span class="s1">slots: Array&lt;{ name: string; parent: string }&gt;</span><span class="s3">\n  </span><span class="s1">redirects?: NextConfigComplete['redirects']</span><span class="s3">\n  </span><span class="s1">rewrites?: NextConfigComplete['rewrites']</span><span class="s3">\n  </span><span class="s1">validatorFilePath?: string</span><span class="s3">\n</span><span class="s1">}): Promise&lt;RouteTypesManifest&gt; {</span><span class="s3">\n  </span><span class="s1">// Helper function to calculate the correct relative path</span><span class="s3">\n  </span><span class="s1">const getRelativePath = (filePath: string) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (validatorFilePath) {</span><span class="s3">\n      </span><span class="s1">// For validator generation, calculate path relative to validator directory</span><span class="s3">\n      </span><span class="s1">return normalizePathSep(</span><span class="s3">\n        </span><span class="s1">path.relative(path.dirname(validatorFilePath), filePath)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// For other uses, calculate path relative to project directory</span><span class="s3">\n    </span><span class="s1">return normalizePathSep(path.relative(dir, filePath))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const manifest: RouteTypesManifest = {</span><span class="s3">\n    </span><span class="s1">appRoutes: {},</span><span class="s3">\n    </span><span class="s1">pageRoutes: {},</span><span class="s3">\n    </span><span class="s1">layoutRoutes: {},</span><span class="s3">\n    </span><span class="s1">appRouteHandlerRoutes: {},</span><span class="s3">\n    </span><span class="s1">redirectRoutes: {},</span><span class="s3">\n    </span><span class="s1">rewriteRoutes: {},</span><span class="s3">\n    </span><span class="s1">appRouteHandlers: new Set(</span><span class="s3">\n      </span><span class="s1">appRouteHandlers.map(({ filePath }) =&gt; getRelativePath(filePath))</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">pageApiRoutes: new Set(</span><span class="s3">\n      </span><span class="s1">pageApiRoutes.map(({ filePath }) =&gt; getRelativePath(filePath))</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">appPagePaths: new Set(</span><span class="s3">\n      </span><span class="s1">appRoutes.map(({ filePath }) =&gt; getRelativePath(filePath))</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">pagesRouterPagePaths: new Set(</span><span class="s3">\n      </span><span class="s1">pageRoutes.map(({ filePath }) =&gt; getRelativePath(filePath))</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">layoutPaths: new Set(</span><span class="s3">\n      </span><span class="s1">layoutRoutes.map(({ filePath }) =&gt; getRelativePath(filePath))</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">filePathToRoute: new Map([</span><span class="s3">\n      </span><span class="s1">...appRoutes.map(</span><span class="s3">\n        </span><span class="s1">({ route, filePath }) =&gt;</span><span class="s3">\n          </span><span class="s1">[getRelativePath(filePath), resolveInterceptingRoute(route)] as [</span><span class="s3">\n            </span><span class="s1">string,</span><span class="s3">\n            </span><span class="s1">string,</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">...layoutRoutes.map(</span><span class="s3">\n        </span><span class="s1">({ route, filePath }) =&gt;</span><span class="s3">\n          </span><span class="s1">[getRelativePath(filePath), resolveInterceptingRoute(route)] as [</span><span class="s3">\n            </span><span class="s1">string,</span><span class="s3">\n            </span><span class="s1">string,</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">...appRouteHandlers.map(</span><span class="s3">\n        </span><span class="s1">({ route, filePath }) =&gt;</span><span class="s3">\n          </span><span class="s1">[getRelativePath(filePath), resolveInterceptingRoute(route)] as [</span><span class="s3">\n            </span><span class="s1">string,</span><span class="s3">\n            </span><span class="s1">string,</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">...pageRoutes.map(</span><span class="s3">\n        </span><span class="s1">({ route, filePath }) =&gt;</span><span class="s3">\n          </span><span class="s1">[getRelativePath(filePath), route] as [string, string]</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">...pageApiRoutes.map(</span><span class="s3">\n        </span><span class="s1">({ route, filePath }) =&gt;</span><span class="s3">\n          </span><span class="s1">[getRelativePath(filePath), route] as [string, string]</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">]),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Process page routes</span><span class="s3">\n  </span><span class="s1">for (const { route, filePath } of pageRoutes) {</span><span class="s3">\n    </span><span class="s1">manifest.pageRoutes[route] = {</span><span class="s3">\n      </span><span class="s1">path: getRelativePath(filePath),</span><span class="s3">\n      </span><span class="s1">groups: extractRouteParams(route),</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Process layout routes</span><span class="s3">\n  </span><span class="s1">for (const { route, filePath } of layoutRoutes) {</span><span class="s3">\n    </span><span class="s1">// Use the resolved route (for interception routes, this gives us the canonical route)</span><span class="s3">\n    </span><span class="s1">const resolvedRoute = resolveInterceptingRoute(route)</span><span class="s3">\n\n    </span><span class="s1">if (!manifest.layoutRoutes[resolvedRoute]) {</span><span class="s3">\n      </span><span class="s1">manifest.layoutRoutes[resolvedRoute] = {</span><span class="s3">\n        </span><span class="s1">path: getRelativePath(filePath),</span><span class="s3">\n        </span><span class="s1">groups: extractRouteParams(resolvedRoute),</span><span class="s3">\n        </span><span class="s1">slots: [],</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Process slots</span><span class="s3">\n  </span><span class="s1">for (const slot of slots) {</span><span class="s3">\n    </span><span class="s1">if (manifest.layoutRoutes[slot.parent]) {</span><span class="s3">\n      </span><span class="s1">manifest.layoutRoutes[slot.parent].slots.push(slot.name)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Process app routes</span><span class="s3">\n  </span><span class="s1">for (const { route, filePath } of appRoutes) {</span><span class="s3">\n    </span><span class="s1">// Don't include metadata routes or pages</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!filePath.endsWith('page.ts') &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!filePath.endsWith('page.tsx') &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!filePath.endsWith('.mdx') &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!filePath.endsWith('.md')</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Use the resolved route (for interception routes, this gives us the canonical route)</span><span class="s3">\n    </span><span class="s1">const resolvedRoute = resolveInterceptingRoute(route)</span><span class="s3">\n\n    </span><span class="s1">if (!manifest.appRoutes[resolvedRoute]) {</span><span class="s3">\n      </span><span class="s1">manifest.appRoutes[resolvedRoute] = {</span><span class="s3">\n        </span><span class="s1">path: getRelativePath(filePath),</span><span class="s3">\n        </span><span class="s1">groups: extractRouteParams(resolvedRoute),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Process app route handlers</span><span class="s3">\n  </span><span class="s1">for (const { route, filePath } of appRouteHandlers) {</span><span class="s3">\n    </span><span class="s1">// Use the resolved route (for interception routes, this gives us the canonical route)</span><span class="s3">\n    </span><span class="s1">const resolvedRoute = resolveInterceptingRoute(route)</span><span class="s3">\n\n    </span><span class="s1">if (!manifest.appRouteHandlerRoutes[resolvedRoute]) {</span><span class="s3">\n      </span><span class="s1">manifest.appRouteHandlerRoutes[resolvedRoute] = {</span><span class="s3">\n        </span><span class="s1">path: getRelativePath(filePath),</span><span class="s3">\n        </span><span class="s1">groups: extractRouteParams(resolvedRoute),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Process redirects</span><span class="s3">\n  </span><span class="s1">if (typeof redirects === 'function') {</span><span class="s3">\n    </span><span class="s1">const rd = await redirects()</span><span class="s3">\n\n    </span><span class="s1">for (const item of rd) {</span><span class="s3">\n      </span><span class="s1">const possibleRoutes = convertCustomRouteSource(item.source)</span><span class="s3">\n      </span><span class="s1">for (const route of possibleRoutes) {</span><span class="s3">\n        </span><span class="s1">manifest.redirectRoutes[route] = {</span><span class="s3">\n          </span><span class="s1">path: route,</span><span class="s3">\n          </span><span class="s1">groups: extractRouteParams(route),</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Process rewrites</span><span class="s3">\n  </span><span class="s1">if (typeof rewrites === 'function') {</span><span class="s3">\n    </span><span class="s1">const rw = await rewrites()</span><span class="s3">\n\n    </span><span class="s1">const allSources = Array.isArray(rw)</span><span class="s3">\n      </span><span class="s1">? rw</span><span class="s3">\n      </span><span class="s1">: [</span><span class="s3">\n          </span><span class="s1">...(rw?.beforeFiles || []),</span><span class="s3">\n          </span><span class="s1">...(rw?.afterFiles || []),</span><span class="s3">\n          </span><span class="s1">...(rw?.fallback || []),</span><span class="s3">\n        </span><span class="s1">]</span><span class="s3">\n\n    </span><span class="s1">for (const item of allSources) {</span><span class="s3">\n      </span><span class="s1">const possibleRoutes = convertCustomRouteSource(item.source)</span><span class="s3">\n      </span><span class="s1">for (const route of possibleRoutes) {</span><span class="s3">\n        </span><span class="s1">manifest.rewriteRoutes[route] = {</span><span class="s3">\n          </span><span class="s1">path: route,</span><span class="s3">\n          </span><span class="s1">groups: extractRouteParams(route),</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return manifest</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function writeRouteTypesManifest(</span><span class="s3">\n  </span><span class="s1">manifest: RouteTypesManifest,</span><span class="s3">\n  </span><span class="s1">filePath: string,</span><span class="s3">\n  </span><span class="s1">config: NextConfigComplete</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const dirname = path.dirname(filePath)</span><span class="s3">\n\n  </span><span class="s1">if (!fs.existsSync(dirname)) {</span><span class="s3">\n    </span><span class="s1">await fs.promises.mkdir(dirname, { recursive: true })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Write the main routes.d.ts file</span><span class="s3">\n  </span><span class="s1">await fs.promises.writeFile(filePath, generateRouteTypesFile(manifest))</span><span class="s3">\n\n  </span><span class="s1">// Write the link.d.ts file if typedRoutes is enabled</span><span class="s3">\n  </span><span class="s1">if (config.typedRoutes === true) {</span><span class="s3">\n    </span><span class="s1">const linkTypesPath = path.join(dirname, 'link.d.ts')</span><span class="s3">\n    </span><span class="s1">await fs.promises.writeFile(linkTypesPath, generateLinkTypesFile(manifest))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function writeValidatorFile(</span><span class="s3">\n  </span><span class="s1">manifest: RouteTypesManifest,</span><span class="s3">\n  </span><span class="s1">filePath: string</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const dirname = path.dirname(filePath)</span><span class="s3">\n\n  </span><span class="s1">if (!fs.existsSync(dirname)) {</span><span class="s3">\n    </span><span class="s1">await fs.promises.mkdir(dirname, { recursive: true })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">await fs.promises.writeFile(filePath, generateValidatorFile(manifest))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;convertCustomRouteSource&quot;</span><span class="s0">,</span><span class="s1">&quot;createRouteTypesManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;extractRouteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;writeRouteTypesManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;writeValidatorFile&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;parseResult&quot;</span><span class="s0">,</span><span class="s1">&quot;tryToParsePath&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;tokens&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;possibleNormalizedRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;slugCnt&quot;</span><span class="s0">,</span><span class="s1">&quot;append&quot;</span><span class="s0">,</span><span class="s1">&quot;suffix&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;fork&quot;</span><span class="s0">,</span><span class="s1">&quot;currentLength&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;token&quot;</span><span class="s0">,</span><span class="s1">&quot;slug&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;modifier&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">,</span><span class="s1">&quot;pattern&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;regex&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;groups&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveInterceptingRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;isInterceptionRouteAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;extractInterceptionRouteInformation&quot;</span><span class="s0">,</span><span class="s1">&quot;dir&quot;</span><span class="s0">,</span><span class="s1">&quot;pageRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;appRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;appRouteHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;pageApiRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;layoutRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;slots&quot;</span><span class="s0">,</span><span class="s1">&quot;redirects&quot;</span><span class="s0">,</span><span class="s1">&quot;rewrites&quot;</span><span class="s0">,</span><span class="s1">&quot;validatorFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;getRelativePath&quot;</span><span class="s0">,</span><span class="s1">&quot;filePath&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizePathSep&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;relative&quot;</span><span class="s0">,</span><span class="s1">&quot;dirname&quot;</span><span class="s0">,</span><span class="s1">&quot;manifest&quot;</span><span class="s0">,</span><span class="s1">&quot;appRouteHandlerRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;redirectRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;appPagePaths&quot;</span><span class="s0">,</span><span class="s1">&quot;pagesRouterPagePaths&quot;</span><span class="s0">,</span><span class="s1">&quot;layoutPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;filePathToRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;slot&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;rd&quot;</span><span class="s0">,</span><span class="s1">&quot;item&quot;</span><span class="s0">,</span><span class="s1">&quot;possibleRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;rw&quot;</span><span class="s0">,</span><span class="s1">&quot;allSources&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;beforeFiles&quot;</span><span class="s0">,</span><span class="s1">&quot;afterFiles&quot;</span><span class="s0">,</span><span class="s1">&quot;fallback&quot;</span><span class="s0">,</span><span class="s1">&quot;config&quot;</span><span class="s0">,</span><span class="s1">&quot;fs&quot;</span><span class="s0">,</span><span class="s1">&quot;existsSync&quot;</span><span class="s0">,</span><span class="s1">&quot;promises&quot;</span><span class="s0">,</span><span class="s1">&quot;mkdir&quot;</span><span class="s0">,</span><span class="s1">&quot;recursive&quot;</span><span class="s0">,</span><span class="s1">&quot;writeFile&quot;</span><span class="s0">,</span><span class="s1">&quot;generateRouteTypesFile&quot;</span><span class="s0">,</span><span class="s1">&quot;typedRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;linkTypesPath&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;generateLinkTypesFile&quot;</span><span class="s0">,</span><span class="s1">&quot;generateValidatorFile&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>