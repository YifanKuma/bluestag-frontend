<html>
<head>
<title>node_modules_fe693df6._.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #0037a6;}
.s5 { color: #264eff;}
.s6 { color: #8c8c8c; font-style: italic;}
.s7 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
node_modules_fe693df6._.js</font>
</center></td></tr></table>
<pre><span class="s0">module.exports = [</span>
<span class="s1">&quot;[project]/node_modules/picocolors/picocolors.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>

<span class="s2">let </span><span class="s0">p = process || {}, argv = p.argv || [], env = p.env || {};</span>
<span class="s2">let </span><span class="s0">isColorSupported = !(!!env.NO_COLOR || argv.includes(</span><span class="s1">&quot;--no-color&quot;</span><span class="s0">)) &amp;&amp; (!!env.FORCE_COLOR || argv.includes(</span><span class="s1">&quot;--color&quot;</span><span class="s0">) || p.platform === </span><span class="s1">&quot;win32&quot; </span><span class="s0">|| (p.stdout || {}).isTTY &amp;&amp; env.TERM !== </span><span class="s1">&quot;dumb&quot; </span><span class="s0">|| !!env.CI);</span>
<span class="s2">let </span><span class="s0">formatter = (open, close, replace = open)=&gt;(input)=&gt;{</span>
        <span class="s2">let </span><span class="s0">string = </span><span class="s1">&quot;&quot; </span><span class="s0">+ input, index = string.indexOf(close, open.length);</span>
        <span class="s2">return </span><span class="s0">~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;</span>
    <span class="s0">};</span>
<span class="s2">let </span><span class="s0">replaceClose = (string, close, replace, index)=&gt;{</span>
    <span class="s2">let </span><span class="s0">result = </span><span class="s1">&quot;&quot;</span><span class="s0">, cursor = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">do </span><span class="s0">{</span>
        <span class="s0">result += string.substring(cursor, index) + replace;</span>
        <span class="s0">cursor = index + close.length;</span>
        <span class="s0">index = string.indexOf(close, cursor);</span>
    <span class="s0">}</span><span class="s2">while </span><span class="s0">(~index)</span>
    <span class="s2">return </span><span class="s0">result + string.substring(cursor);</span>
<span class="s0">};</span>
<span class="s2">let </span><span class="s0">createColors = (enabled = isColorSupported)=&gt;{</span>
    <span class="s2">let </span><span class="s0">f = enabled ? formatter : ()=&gt;String;</span>
    <span class="s2">return </span><span class="s0">{</span>
        <span class="s0">isColorSupported: enabled,</span>
        <span class="s0">reset: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[0m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[0m&quot;</span><span class="s0">),</span>
        <span class="s0">bold: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[1m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[22m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[22m</span><span class="s4">\x1b</span><span class="s1">[1m&quot;</span><span class="s0">),</span>
        <span class="s0">dim: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[2m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[22m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[22m</span><span class="s4">\x1b</span><span class="s1">[2m&quot;</span><span class="s0">),</span>
        <span class="s0">italic: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[3m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[23m&quot;</span><span class="s0">),</span>
        <span class="s0">underline: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[4m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[24m&quot;</span><span class="s0">),</span>
        <span class="s0">inverse: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[7m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[27m&quot;</span><span class="s0">),</span>
        <span class="s0">hidden: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[8m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[28m&quot;</span><span class="s0">),</span>
        <span class="s0">strikethrough: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[9m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[29m&quot;</span><span class="s0">),</span>
        <span class="s0">black: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[30m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[39m&quot;</span><span class="s0">),</span>
        <span class="s0">red: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[31m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[39m&quot;</span><span class="s0">),</span>
        <span class="s0">green: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[32m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[39m&quot;</span><span class="s0">),</span>
        <span class="s0">yellow: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[33m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[39m&quot;</span><span class="s0">),</span>
        <span class="s0">blue: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[34m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[39m&quot;</span><span class="s0">),</span>
        <span class="s0">magenta: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[35m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[39m&quot;</span><span class="s0">),</span>
        <span class="s0">cyan: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[36m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[39m&quot;</span><span class="s0">),</span>
        <span class="s0">white: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[37m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[39m&quot;</span><span class="s0">),</span>
        <span class="s0">gray: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[90m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[39m&quot;</span><span class="s0">),</span>
        <span class="s0">bgBlack: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[40m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[49m&quot;</span><span class="s0">),</span>
        <span class="s0">bgRed: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[41m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[49m&quot;</span><span class="s0">),</span>
        <span class="s0">bgGreen: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[42m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[49m&quot;</span><span class="s0">),</span>
        <span class="s0">bgYellow: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[43m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[49m&quot;</span><span class="s0">),</span>
        <span class="s0">bgBlue: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[44m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[49m&quot;</span><span class="s0">),</span>
        <span class="s0">bgMagenta: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[45m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[49m&quot;</span><span class="s0">),</span>
        <span class="s0">bgCyan: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[46m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[49m&quot;</span><span class="s0">),</span>
        <span class="s0">bgWhite: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[47m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[49m&quot;</span><span class="s0">),</span>
        <span class="s0">blackBright: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[90m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[39m&quot;</span><span class="s0">),</span>
        <span class="s0">redBright: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[91m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[39m&quot;</span><span class="s0">),</span>
        <span class="s0">greenBright: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[92m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[39m&quot;</span><span class="s0">),</span>
        <span class="s0">yellowBright: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[93m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[39m&quot;</span><span class="s0">),</span>
        <span class="s0">blueBright: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[94m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[39m&quot;</span><span class="s0">),</span>
        <span class="s0">magentaBright: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[95m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[39m&quot;</span><span class="s0">),</span>
        <span class="s0">cyanBright: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[96m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[39m&quot;</span><span class="s0">),</span>
        <span class="s0">whiteBright: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[97m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[39m&quot;</span><span class="s0">),</span>
        <span class="s0">bgBlackBright: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[100m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[49m&quot;</span><span class="s0">),</span>
        <span class="s0">bgRedBright: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[101m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[49m&quot;</span><span class="s0">),</span>
        <span class="s0">bgGreenBright: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[102m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[49m&quot;</span><span class="s0">),</span>
        <span class="s0">bgYellowBright: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[103m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[49m&quot;</span><span class="s0">),</span>
        <span class="s0">bgBlueBright: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[104m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[49m&quot;</span><span class="s0">),</span>
        <span class="s0">bgMagentaBright: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[105m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[49m&quot;</span><span class="s0">),</span>
        <span class="s0">bgCyanBright: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[106m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[49m&quot;</span><span class="s0">),</span>
        <span class="s0">bgWhiteBright: f(</span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[107m&quot;</span><span class="s0">, </span><span class="s1">&quot;</span><span class="s4">\x1b</span><span class="s1">[49m&quot;</span><span class="s0">)</span>
    <span class="s0">};</span>
<span class="s0">};</span>
<span class="s0">module.exports = createColors();</span>
<span class="s0">module.exports.createColors = createColors;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/tokenize.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">const </span><span class="s0">SINGLE_QUOTE = </span><span class="s1">&quot;'&quot;</span><span class="s0">.charCodeAt(</span><span class="s3">0</span><span class="s0">);</span>
<span class="s2">const </span><span class="s0">DOUBLE_QUOTE = </span><span class="s1">'&quot;'</span><span class="s0">.charCodeAt(</span><span class="s3">0</span><span class="s0">);</span>
<span class="s2">const </span><span class="s0">BACKSLASH = </span><span class="s1">'</span><span class="s4">\\</span><span class="s1">'</span><span class="s0">.charCodeAt(</span><span class="s3">0</span><span class="s0">);</span>
<span class="s2">const </span><span class="s0">SLASH = </span><span class="s1">'/'</span><span class="s0">.charCodeAt(</span><span class="s3">0</span><span class="s0">);</span>
<span class="s2">const </span><span class="s0">NEWLINE = </span><span class="s1">'</span><span class="s4">\n</span><span class="s1">'</span><span class="s0">.charCodeAt(</span><span class="s3">0</span><span class="s0">);</span>
<span class="s2">const </span><span class="s0">SPACE = </span><span class="s1">' '</span><span class="s0">.charCodeAt(</span><span class="s3">0</span><span class="s0">);</span>
<span class="s2">const </span><span class="s0">FEED = </span><span class="s1">'</span><span class="s4">\f</span><span class="s1">'</span><span class="s0">.charCodeAt(</span><span class="s3">0</span><span class="s0">);</span>
<span class="s2">const </span><span class="s0">TAB = </span><span class="s1">'</span><span class="s4">\t</span><span class="s1">'</span><span class="s0">.charCodeAt(</span><span class="s3">0</span><span class="s0">);</span>
<span class="s2">const </span><span class="s0">CR = </span><span class="s1">'</span><span class="s4">\r</span><span class="s1">'</span><span class="s0">.charCodeAt(</span><span class="s3">0</span><span class="s0">);</span>
<span class="s2">const </span><span class="s0">OPEN_SQUARE = </span><span class="s1">'['</span><span class="s0">.charCodeAt(</span><span class="s3">0</span><span class="s0">);</span>
<span class="s2">const </span><span class="s0">CLOSE_SQUARE = </span><span class="s1">']'</span><span class="s0">.charCodeAt(</span><span class="s3">0</span><span class="s0">);</span>
<span class="s2">const </span><span class="s0">OPEN_PARENTHESES = </span><span class="s1">'('</span><span class="s0">.charCodeAt(</span><span class="s3">0</span><span class="s0">);</span>
<span class="s2">const </span><span class="s0">CLOSE_PARENTHESES = </span><span class="s1">')'</span><span class="s0">.charCodeAt(</span><span class="s3">0</span><span class="s0">);</span>
<span class="s2">const </span><span class="s0">OPEN_CURLY = </span><span class="s1">'{'</span><span class="s0">.charCodeAt(</span><span class="s3">0</span><span class="s0">);</span>
<span class="s2">const </span><span class="s0">CLOSE_CURLY = </span><span class="s1">'}'</span><span class="s0">.charCodeAt(</span><span class="s3">0</span><span class="s0">);</span>
<span class="s2">const </span><span class="s0">SEMICOLON = </span><span class="s1">';'</span><span class="s0">.charCodeAt(</span><span class="s3">0</span><span class="s0">);</span>
<span class="s2">const </span><span class="s0">ASTERISK = </span><span class="s1">'*'</span><span class="s0">.charCodeAt(</span><span class="s3">0</span><span class="s0">);</span>
<span class="s2">const </span><span class="s0">COLON = </span><span class="s1">':'</span><span class="s0">.charCodeAt(</span><span class="s3">0</span><span class="s0">);</span>
<span class="s2">const </span><span class="s0">AT = </span><span class="s1">'@'</span><span class="s0">.charCodeAt(</span><span class="s3">0</span><span class="s0">);</span>
<span class="s2">const </span><span class="s0">RE_AT_END = </span><span class="s5">/[\t\n\f\r &quot;#'()/;[\\\]{}]/g</span><span class="s0">;</span>
<span class="s2">const </span><span class="s0">RE_WORD_END = </span><span class="s5">/[\t\n\f\r !&quot;#'():;@[\\\]{}]|\/(?=\*)/g</span><span class="s0">;</span>
<span class="s2">const </span><span class="s0">RE_BAD_BRACKET = </span><span class="s5">/.[\r\n&quot;'(/\\]/</span><span class="s0">;</span>
<span class="s2">const </span><span class="s0">RE_HEX_ESCAPE = </span><span class="s5">/[\da-f]/i</span><span class="s0">;</span>
<span class="s0">module.exports = </span><span class="s2">function </span><span class="s0">tokenizer(input, options = {}) {</span>
    <span class="s2">let </span><span class="s0">css = input.css.valueOf();</span>
    <span class="s2">let </span><span class="s0">ignore = options.ignoreErrors;</span>
    <span class="s2">let </span><span class="s0">code, content, escape, next, quote;</span>
    <span class="s2">let </span><span class="s0">currentToken, escaped, escapePos, n, prev;</span>
    <span class="s2">let </span><span class="s0">length = css.length;</span>
    <span class="s2">let </span><span class="s0">pos = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">let </span><span class="s0">buffer = [];</span>
    <span class="s2">let </span><span class="s0">returned = [];</span>
    <span class="s2">function </span><span class="s0">position() {</span>
        <span class="s2">return </span><span class="s0">pos;</span>
    <span class="s0">}</span>
    <span class="s2">function </span><span class="s0">unclosed(what) {</span>
        <span class="s2">throw </span><span class="s0">input.error(</span><span class="s1">'Unclosed ' </span><span class="s0">+ what, pos);</span>
    <span class="s0">}</span>
    <span class="s2">function </span><span class="s0">endOfFile() {</span>
        <span class="s2">return </span><span class="s0">returned.length === </span><span class="s3">0 </span><span class="s0">&amp;&amp; pos &gt;= length;</span>
    <span class="s0">}</span>
    <span class="s2">function </span><span class="s0">nextToken(opts) {</span>
        <span class="s2">if </span><span class="s0">(returned.length) </span><span class="s2">return </span><span class="s0">returned.pop();</span>
        <span class="s2">if </span><span class="s0">(pos &gt;= length) </span><span class="s2">return</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">ignoreUnclosed = opts ? opts.ignoreUnclosed : </span><span class="s2">false</span><span class="s0">;</span>
        <span class="s0">code = css.charCodeAt(pos);</span>
        <span class="s2">switch</span><span class="s0">(code){</span>
            <span class="s2">case </span><span class="s0">NEWLINE:</span>
            <span class="s2">case </span><span class="s0">SPACE:</span>
            <span class="s2">case </span><span class="s0">TAB:</span>
            <span class="s2">case </span><span class="s0">CR:</span>
            <span class="s2">case </span><span class="s0">FEED:</span>
                <span class="s0">{</span>
                    <span class="s0">next = pos;</span>
                    <span class="s2">do </span><span class="s0">{</span>
                        <span class="s0">next += </span><span class="s3">1</span><span class="s0">;</span>
                        <span class="s0">code = css.charCodeAt(next);</span>
                    <span class="s0">}</span><span class="s2">while </span><span class="s0">(code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED)</span>
                    <span class="s0">currentToken = [</span>
                        <span class="s1">'space'</span><span class="s0">,</span>
                        <span class="s0">css.slice(pos, next)</span>
                    <span class="s0">];</span>
                    <span class="s0">pos = next - </span><span class="s3">1</span><span class="s0">;</span>
                    <span class="s2">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s2">case </span><span class="s0">OPEN_SQUARE:</span>
            <span class="s2">case </span><span class="s0">CLOSE_SQUARE:</span>
            <span class="s2">case </span><span class="s0">OPEN_CURLY:</span>
            <span class="s2">case </span><span class="s0">CLOSE_CURLY:</span>
            <span class="s2">case </span><span class="s0">COLON:</span>
            <span class="s2">case </span><span class="s0">SEMICOLON:</span>
            <span class="s2">case </span><span class="s0">CLOSE_PARENTHESES:</span>
                <span class="s0">{</span>
                    <span class="s2">let </span><span class="s0">controlChar = String.fromCharCode(code);</span>
                    <span class="s0">currentToken = [</span>
                        <span class="s0">controlChar,</span>
                        <span class="s0">controlChar,</span>
                        <span class="s0">pos</span>
                    <span class="s0">];</span>
                    <span class="s2">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s2">case </span><span class="s0">OPEN_PARENTHESES:</span>
                <span class="s0">{</span>
                    <span class="s0">prev = buffer.length ? buffer.pop()[</span><span class="s3">1</span><span class="s0">] : </span><span class="s1">''</span><span class="s0">;</span>
                    <span class="s0">n = css.charCodeAt(pos + </span><span class="s3">1</span><span class="s0">);</span>
                    <span class="s2">if </span><span class="s0">(prev === </span><span class="s1">'url' </span><span class="s0">&amp;&amp; n !== SINGLE_QUOTE &amp;&amp; n !== DOUBLE_QUOTE &amp;&amp; n !== SPACE &amp;&amp; n !== NEWLINE &amp;&amp; n !== TAB &amp;&amp; n !== FEED &amp;&amp; n !== CR) {</span>
                        <span class="s0">next = pos;</span>
                        <span class="s2">do </span><span class="s0">{</span>
                            <span class="s0">escaped = </span><span class="s2">false</span><span class="s0">;</span>
                            <span class="s0">next = css.indexOf(</span><span class="s1">')'</span><span class="s0">, next + </span><span class="s3">1</span><span class="s0">);</span>
                            <span class="s2">if </span><span class="s0">(next === -</span><span class="s3">1</span><span class="s0">) {</span>
                                <span class="s2">if </span><span class="s0">(ignore || ignoreUnclosed) {</span>
                                    <span class="s0">next = pos;</span>
                                    <span class="s2">break</span><span class="s0">;</span>
                                <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                                    <span class="s0">unclosed(</span><span class="s1">'bracket'</span><span class="s0">);</span>
                                <span class="s0">}</span>
                            <span class="s0">}</span>
                            <span class="s0">escapePos = next;</span>
                            <span class="s2">while</span><span class="s0">(css.charCodeAt(escapePos - </span><span class="s3">1</span><span class="s0">) === BACKSLASH){</span>
                                <span class="s0">escapePos -= </span><span class="s3">1</span><span class="s0">;</span>
                                <span class="s0">escaped = !escaped;</span>
                            <span class="s0">}</span>
                        <span class="s0">}</span><span class="s2">while </span><span class="s0">(escaped)</span>
                        <span class="s0">currentToken = [</span>
                            <span class="s1">'brackets'</span><span class="s0">,</span>
                            <span class="s0">css.slice(pos, next + </span><span class="s3">1</span><span class="s0">),</span>
                            <span class="s0">pos,</span>
                            <span class="s0">next</span>
                        <span class="s0">];</span>
                        <span class="s0">pos = next;</span>
                    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                        <span class="s0">next = css.indexOf(</span><span class="s1">')'</span><span class="s0">, pos + </span><span class="s3">1</span><span class="s0">);</span>
                        <span class="s0">content = css.slice(pos, next + </span><span class="s3">1</span><span class="s0">);</span>
                        <span class="s2">if </span><span class="s0">(next === -</span><span class="s3">1 </span><span class="s0">|| RE_BAD_BRACKET.test(content)) {</span>
                            <span class="s0">currentToken = [</span>
                                <span class="s1">'('</span><span class="s0">,</span>
                                <span class="s1">'('</span><span class="s0">,</span>
                                <span class="s0">pos</span>
                            <span class="s0">];</span>
                        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                            <span class="s0">currentToken = [</span>
                                <span class="s1">'brackets'</span><span class="s0">,</span>
                                <span class="s0">content,</span>
                                <span class="s0">pos,</span>
                                <span class="s0">next</span>
                            <span class="s0">];</span>
                            <span class="s0">pos = next;</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                    <span class="s2">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s2">case </span><span class="s0">SINGLE_QUOTE:</span>
            <span class="s2">case </span><span class="s0">DOUBLE_QUOTE:</span>
                <span class="s0">{</span>
                    <span class="s0">quote = code === SINGLE_QUOTE ? </span><span class="s1">&quot;'&quot; </span><span class="s0">: </span><span class="s1">'&quot;'</span><span class="s0">;</span>
                    <span class="s0">next = pos;</span>
                    <span class="s2">do </span><span class="s0">{</span>
                        <span class="s0">escaped = </span><span class="s2">false</span><span class="s0">;</span>
                        <span class="s0">next = css.indexOf(quote, next + </span><span class="s3">1</span><span class="s0">);</span>
                        <span class="s2">if </span><span class="s0">(next === -</span><span class="s3">1</span><span class="s0">) {</span>
                            <span class="s2">if </span><span class="s0">(ignore || ignoreUnclosed) {</span>
                                <span class="s0">next = pos + </span><span class="s3">1</span><span class="s0">;</span>
                                <span class="s2">break</span><span class="s0">;</span>
                            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                                <span class="s0">unclosed(</span><span class="s1">'string'</span><span class="s0">);</span>
                            <span class="s0">}</span>
                        <span class="s0">}</span>
                        <span class="s0">escapePos = next;</span>
                        <span class="s2">while</span><span class="s0">(css.charCodeAt(escapePos - </span><span class="s3">1</span><span class="s0">) === BACKSLASH){</span>
                            <span class="s0">escapePos -= </span><span class="s3">1</span><span class="s0">;</span>
                            <span class="s0">escaped = !escaped;</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span><span class="s2">while </span><span class="s0">(escaped)</span>
                    <span class="s0">currentToken = [</span>
                        <span class="s1">'string'</span><span class="s0">,</span>
                        <span class="s0">css.slice(pos, next + </span><span class="s3">1</span><span class="s0">),</span>
                        <span class="s0">pos,</span>
                        <span class="s0">next</span>
                    <span class="s0">];</span>
                    <span class="s0">pos = next;</span>
                    <span class="s2">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s2">case </span><span class="s0">AT:</span>
                <span class="s0">{</span>
                    <span class="s0">RE_AT_END.lastIndex = pos + </span><span class="s3">1</span><span class="s0">;</span>
                    <span class="s0">RE_AT_END.test(css);</span>
                    <span class="s2">if </span><span class="s0">(RE_AT_END.lastIndex === </span><span class="s3">0</span><span class="s0">) {</span>
                        <span class="s0">next = css.length - </span><span class="s3">1</span><span class="s0">;</span>
                    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                        <span class="s0">next = RE_AT_END.lastIndex - </span><span class="s3">2</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s0">currentToken = [</span>
                        <span class="s1">'at-word'</span><span class="s0">,</span>
                        <span class="s0">css.slice(pos, next + </span><span class="s3">1</span><span class="s0">),</span>
                        <span class="s0">pos,</span>
                        <span class="s0">next</span>
                    <span class="s0">];</span>
                    <span class="s0">pos = next;</span>
                    <span class="s2">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s2">case </span><span class="s0">BACKSLASH:</span>
                <span class="s0">{</span>
                    <span class="s0">next = pos;</span>
                    <span class="s0">escape = </span><span class="s2">true</span><span class="s0">;</span>
                    <span class="s2">while</span><span class="s0">(css.charCodeAt(next + </span><span class="s3">1</span><span class="s0">) === BACKSLASH){</span>
                        <span class="s0">next += </span><span class="s3">1</span><span class="s0">;</span>
                        <span class="s0">escape = !escape;</span>
                    <span class="s0">}</span>
                    <span class="s0">code = css.charCodeAt(next + </span><span class="s3">1</span><span class="s0">);</span>
                    <span class="s2">if </span><span class="s0">(escape &amp;&amp; code !== SLASH &amp;&amp; code !== SPACE &amp;&amp; code !== NEWLINE &amp;&amp; code !== TAB &amp;&amp; code !== CR &amp;&amp; code !== FEED) {</span>
                        <span class="s0">next += </span><span class="s3">1</span><span class="s0">;</span>
                        <span class="s2">if </span><span class="s0">(RE_HEX_ESCAPE.test(css.charAt(next))) {</span>
                            <span class="s2">while</span><span class="s0">(RE_HEX_ESCAPE.test(css.charAt(next + </span><span class="s3">1</span><span class="s0">))){</span>
                                <span class="s0">next += </span><span class="s3">1</span><span class="s0">;</span>
                            <span class="s0">}</span>
                            <span class="s2">if </span><span class="s0">(css.charCodeAt(next + </span><span class="s3">1</span><span class="s0">) === SPACE) {</span>
                                <span class="s0">next += </span><span class="s3">1</span><span class="s0">;</span>
                            <span class="s0">}</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                    <span class="s0">currentToken = [</span>
                        <span class="s1">'word'</span><span class="s0">,</span>
                        <span class="s0">css.slice(pos, next + </span><span class="s3">1</span><span class="s0">),</span>
                        <span class="s0">pos,</span>
                        <span class="s0">next</span>
                    <span class="s0">];</span>
                    <span class="s0">pos = next;</span>
                    <span class="s2">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s2">default</span><span class="s0">:</span>
                <span class="s0">{</span>
                    <span class="s2">if </span><span class="s0">(code === SLASH &amp;&amp; css.charCodeAt(pos + </span><span class="s3">1</span><span class="s0">) === ASTERISK) {</span>
                        <span class="s0">next = css.indexOf(</span><span class="s1">'*/'</span><span class="s0">, pos + </span><span class="s3">2</span><span class="s0">) + </span><span class="s3">1</span><span class="s0">;</span>
                        <span class="s2">if </span><span class="s0">(next === </span><span class="s3">0</span><span class="s0">) {</span>
                            <span class="s2">if </span><span class="s0">(ignore || ignoreUnclosed) {</span>
                                <span class="s0">next = css.length;</span>
                            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                                <span class="s0">unclosed(</span><span class="s1">'comment'</span><span class="s0">);</span>
                            <span class="s0">}</span>
                        <span class="s0">}</span>
                        <span class="s0">currentToken = [</span>
                            <span class="s1">'comment'</span><span class="s0">,</span>
                            <span class="s0">css.slice(pos, next + </span><span class="s3">1</span><span class="s0">),</span>
                            <span class="s0">pos,</span>
                            <span class="s0">next</span>
                        <span class="s0">];</span>
                        <span class="s0">pos = next;</span>
                    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                        <span class="s0">RE_WORD_END.lastIndex = pos + </span><span class="s3">1</span><span class="s0">;</span>
                        <span class="s0">RE_WORD_END.test(css);</span>
                        <span class="s2">if </span><span class="s0">(RE_WORD_END.lastIndex === </span><span class="s3">0</span><span class="s0">) {</span>
                            <span class="s0">next = css.length - </span><span class="s3">1</span><span class="s0">;</span>
                        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                            <span class="s0">next = RE_WORD_END.lastIndex - </span><span class="s3">2</span><span class="s0">;</span>
                        <span class="s0">}</span>
                        <span class="s0">currentToken = [</span>
                            <span class="s1">'word'</span><span class="s0">,</span>
                            <span class="s0">css.slice(pos, next + </span><span class="s3">1</span><span class="s0">),</span>
                            <span class="s0">pos,</span>
                            <span class="s0">next</span>
                        <span class="s0">];</span>
                        <span class="s0">buffer.push(currentToken);</span>
                        <span class="s0">pos = next;</span>
                    <span class="s0">}</span>
                    <span class="s2">break</span><span class="s0">;</span>
                <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">pos++;</span>
        <span class="s2">return </span><span class="s0">currentToken;</span>
    <span class="s0">}</span>
    <span class="s2">function </span><span class="s0">back(token) {</span>
        <span class="s0">returned.push(token);</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">{</span>
        <span class="s0">back,</span>
        <span class="s0">endOfFile,</span>
        <span class="s0">nextToken,</span>
        <span class="s0">position</span>
    <span class="s0">};</span>
<span class="s0">};</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/terminal-highlight.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">let </span><span class="s0">pico = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/picocolors/picocolors.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">tokenizer = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/tokenize.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Input;</span>
<span class="s2">function </span><span class="s0">registerInput(dependant) {</span>
    <span class="s0">Input = dependant;</span>
<span class="s0">}</span>
<span class="s2">const </span><span class="s0">HIGHLIGHT_THEME = {</span>
    <span class="s1">';'</span><span class="s0">: pico.yellow,</span>
    <span class="s1">':'</span><span class="s0">: pico.yellow,</span>
    <span class="s1">'('</span><span class="s0">: pico.cyan,</span>
    <span class="s1">')'</span><span class="s0">: pico.cyan,</span>
    <span class="s1">'['</span><span class="s0">: pico.yellow,</span>
    <span class="s1">']'</span><span class="s0">: pico.yellow,</span>
    <span class="s1">'{'</span><span class="s0">: pico.yellow,</span>
    <span class="s1">'}'</span><span class="s0">: pico.yellow,</span>
    <span class="s1">'at-word'</span><span class="s0">: pico.cyan,</span>
    <span class="s1">'brackets'</span><span class="s0">: pico.cyan,</span>
    <span class="s1">'call'</span><span class="s0">: pico.cyan,</span>
    <span class="s1">'class'</span><span class="s0">: pico.yellow,</span>
    <span class="s1">'comment'</span><span class="s0">: pico.gray,</span>
    <span class="s1">'hash'</span><span class="s0">: pico.magenta,</span>
    <span class="s1">'string'</span><span class="s0">: pico.green</span>
<span class="s0">};</span>
<span class="s2">function </span><span class="s0">getTokenType([type, value], processor) {</span>
    <span class="s2">if </span><span class="s0">(type === </span><span class="s1">'word'</span><span class="s0">) {</span>
        <span class="s2">if </span><span class="s0">(value[</span><span class="s3">0</span><span class="s0">] === </span><span class="s1">'.'</span><span class="s0">) {</span>
            <span class="s2">return </span><span class="s1">'class'</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(value[</span><span class="s3">0</span><span class="s0">] === </span><span class="s1">'#'</span><span class="s0">) {</span>
            <span class="s2">return </span><span class="s1">'hash'</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(!processor.endOfFile()) {</span>
        <span class="s2">let </span><span class="s0">next = processor.nextToken();</span>
        <span class="s0">processor.back(next);</span>
        <span class="s2">if </span><span class="s0">(next[</span><span class="s3">0</span><span class="s0">] === </span><span class="s1">'brackets' </span><span class="s0">|| next[</span><span class="s3">0</span><span class="s0">] === </span><span class="s1">'('</span><span class="s0">) </span><span class="s2">return </span><span class="s1">'call'</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">type;</span>
<span class="s0">}</span>
<span class="s2">function </span><span class="s0">terminalHighlight(css) {</span>
    <span class="s2">let </span><span class="s0">processor = tokenizer(</span><span class="s2">new </span><span class="s0">Input(css), {</span>
        <span class="s0">ignoreErrors: </span><span class="s2">true</span>
    <span class="s0">});</span>
    <span class="s2">let </span><span class="s0">result = </span><span class="s1">''</span><span class="s0">;</span>
    <span class="s2">while</span><span class="s0">(!processor.endOfFile()){</span>
        <span class="s2">let </span><span class="s0">token = processor.nextToken();</span>
        <span class="s2">let </span><span class="s0">color = HIGHLIGHT_THEME[getTokenType(token, processor)];</span>
        <span class="s2">if </span><span class="s0">(color) {</span>
            <span class="s0">result += token[</span><span class="s3">1</span><span class="s0">].split(</span><span class="s5">/\r?\n/</span><span class="s0">).map((i)=&gt;color(i)).join(</span><span class="s1">'</span><span class="s4">\n</span><span class="s1">'</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s0">result += token[</span><span class="s3">1</span><span class="s0">];</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">result;</span>
<span class="s0">}</span>
<span class="s0">terminalHighlight.registerInput = registerInput;</span>
<span class="s0">module.exports = terminalHighlight;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/css-syntax-error.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">let </span><span class="s0">pico = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/picocolors/picocolors.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">terminalHighlight = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/terminal-highlight.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">class </span><span class="s0">CssSyntaxError </span><span class="s2">extends </span><span class="s0">Error {</span>
    <span class="s0">constructor(message, line, column, source, file, plugin){</span>
        <span class="s2">super</span><span class="s0">(message);</span>
        <span class="s2">this</span><span class="s0">.name = </span><span class="s1">'CssSyntaxError'</span><span class="s0">;</span>
        <span class="s2">this</span><span class="s0">.reason = message;</span>
        <span class="s2">if </span><span class="s0">(file) {</span>
            <span class="s2">this</span><span class="s0">.file = file;</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(source) {</span>
            <span class="s2">this</span><span class="s0">.source = source;</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(plugin) {</span>
            <span class="s2">this</span><span class="s0">.plugin = plugin;</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">line !== </span><span class="s1">'undefined' </span><span class="s0">&amp;&amp; </span><span class="s2">typeof </span><span class="s0">column !== </span><span class="s1">'undefined'</span><span class="s0">) {</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">line === </span><span class="s1">'number'</span><span class="s0">) {</span>
                <span class="s2">this</span><span class="s0">.line = line;</span>
                <span class="s2">this</span><span class="s0">.column = column;</span>
            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                <span class="s2">this</span><span class="s0">.line = line.line;</span>
                <span class="s2">this</span><span class="s0">.column = line.column;</span>
                <span class="s2">this</span><span class="s0">.endLine = column.line;</span>
                <span class="s2">this</span><span class="s0">.endColumn = column.column;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">this</span><span class="s0">.setMessage();</span>
        <span class="s2">if </span><span class="s0">(Error.captureStackTrace) {</span>
            <span class="s0">Error.captureStackTrace(</span><span class="s2">this</span><span class="s0">, CssSyntaxError);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">setMessage() {</span>
        <span class="s2">this</span><span class="s0">.message = </span><span class="s2">this</span><span class="s0">.plugin ? </span><span class="s2">this</span><span class="s0">.plugin + </span><span class="s1">': ' </span><span class="s0">: </span><span class="s1">''</span><span class="s0">;</span>
        <span class="s2">this</span><span class="s0">.message += </span><span class="s2">this</span><span class="s0">.file ? </span><span class="s2">this</span><span class="s0">.file : </span><span class="s1">'&lt;css input&gt;'</span><span class="s0">;</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof this</span><span class="s0">.line !== </span><span class="s1">'undefined'</span><span class="s0">) {</span>
            <span class="s2">this</span><span class="s0">.message += </span><span class="s1">':' </span><span class="s0">+ </span><span class="s2">this</span><span class="s0">.line + </span><span class="s1">':' </span><span class="s0">+ </span><span class="s2">this</span><span class="s0">.column;</span>
        <span class="s0">}</span>
        <span class="s2">this</span><span class="s0">.message += </span><span class="s1">': ' </span><span class="s0">+ </span><span class="s2">this</span><span class="s0">.reason;</span>
    <span class="s0">}</span>
    <span class="s0">showSourceCode(color) {</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.source) </span><span class="s2">return </span><span class="s1">''</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">css = </span><span class="s2">this</span><span class="s0">.source;</span>
        <span class="s2">if </span><span class="s0">(color == </span><span class="s2">null</span><span class="s0">) color = pico.isColorSupported;</span>
        <span class="s2">let </span><span class="s0">aside = (text)=&gt;text;</span>
        <span class="s2">let </span><span class="s0">mark = (text)=&gt;text;</span>
        <span class="s2">let </span><span class="s0">highlight = (text)=&gt;text;</span>
        <span class="s2">if </span><span class="s0">(color) {</span>
            <span class="s2">let </span><span class="s0">{ bold, gray, red } = pico.createColors(</span><span class="s2">true</span><span class="s0">);</span>
            <span class="s0">mark = (text)=&gt;bold(red(text));</span>
            <span class="s0">aside = (text)=&gt;gray(text);</span>
            <span class="s2">if </span><span class="s0">(terminalHighlight) {</span>
                <span class="s0">highlight = (text)=&gt;terminalHighlight(text);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">let </span><span class="s0">lines = css.split(</span><span class="s5">/\r?\n/</span><span class="s0">);</span>
        <span class="s2">let </span><span class="s0">start = Math.max(</span><span class="s2">this</span><span class="s0">.line - </span><span class="s3">3</span><span class="s0">, </span><span class="s3">0</span><span class="s0">);</span>
        <span class="s2">let </span><span class="s0">end = Math.min(</span><span class="s2">this</span><span class="s0">.line + </span><span class="s3">2</span><span class="s0">, lines.length);</span>
        <span class="s2">let </span><span class="s0">maxWidth = String(end).length;</span>
        <span class="s2">return </span><span class="s0">lines.slice(start, end).map((line, index)=&gt;{</span>
            <span class="s2">let </span><span class="s0">number = start + </span><span class="s3">1 </span><span class="s0">+ index;</span>
            <span class="s2">let </span><span class="s0">gutter = </span><span class="s1">' ' </span><span class="s0">+ (</span><span class="s1">' ' </span><span class="s0">+ number).slice(-maxWidth) + </span><span class="s1">' | '</span><span class="s0">;</span>
            <span class="s2">if </span><span class="s0">(number === </span><span class="s2">this</span><span class="s0">.line) {</span>
                <span class="s2">if </span><span class="s0">(line.length &gt; </span><span class="s3">160</span><span class="s0">) {</span>
                    <span class="s2">let </span><span class="s0">padding = </span><span class="s3">20</span><span class="s0">;</span>
                    <span class="s2">let </span><span class="s0">subLineStart = Math.max(</span><span class="s3">0</span><span class="s0">, </span><span class="s2">this</span><span class="s0">.column - padding);</span>
                    <span class="s2">let </span><span class="s0">subLineEnd = Math.max(</span><span class="s2">this</span><span class="s0">.column + padding, </span><span class="s2">this</span><span class="s0">.endColumn + padding);</span>
                    <span class="s2">let </span><span class="s0">subLine = line.slice(subLineStart, subLineEnd);</span>
                    <span class="s2">let </span><span class="s0">spacing = aside(gutter.replace(</span><span class="s5">/\d/g</span><span class="s0">, </span><span class="s1">' '</span><span class="s0">)) + line.slice(</span><span class="s3">0</span><span class="s0">, Math.min(</span><span class="s2">this</span><span class="s0">.column - </span><span class="s3">1</span><span class="s0">, padding - </span><span class="s3">1</span><span class="s0">)).replace(</span><span class="s5">/[^\t]/g</span><span class="s0">, </span><span class="s1">' '</span><span class="s0">);</span>
                    <span class="s2">return </span><span class="s0">mark(</span><span class="s1">'&gt;'</span><span class="s0">) + aside(gutter) + highlight(subLine) + </span><span class="s1">'</span><span class="s4">\n </span><span class="s1">' </span><span class="s0">+ spacing + mark(</span><span class="s1">'^'</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s2">let </span><span class="s0">spacing = aside(gutter.replace(</span><span class="s5">/\d/g</span><span class="s0">, </span><span class="s1">' '</span><span class="s0">)) + line.slice(</span><span class="s3">0</span><span class="s0">, </span><span class="s2">this</span><span class="s0">.column - </span><span class="s3">1</span><span class="s0">).replace(</span><span class="s5">/[^\t]/g</span><span class="s0">, </span><span class="s1">' '</span><span class="s0">);</span>
                <span class="s2">return </span><span class="s0">mark(</span><span class="s1">'&gt;'</span><span class="s0">) + aside(gutter) + highlight(line) + </span><span class="s1">'</span><span class="s4">\n </span><span class="s1">' </span><span class="s0">+ spacing + mark(</span><span class="s1">'^'</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s2">return </span><span class="s1">' ' </span><span class="s0">+ aside(gutter) + highlight(line);</span>
        <span class="s0">}).join(</span><span class="s1">'</span><span class="s4">\n</span><span class="s1">'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s0">toString() {</span>
        <span class="s2">let </span><span class="s0">code = </span><span class="s2">this</span><span class="s0">.showSourceCode();</span>
        <span class="s2">if </span><span class="s0">(code) {</span>
            <span class="s0">code = </span><span class="s1">'</span><span class="s4">\n\n</span><span class="s1">' </span><span class="s0">+ code + </span><span class="s1">'</span><span class="s4">\n</span><span class="s1">'</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s2">return this</span><span class="s0">.name + </span><span class="s1">': ' </span><span class="s0">+ </span><span class="s2">this</span><span class="s0">.message + code;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">module.exports = CssSyntaxError;</span>
<span class="s0">CssSyntaxError.default = CssSyntaxError;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/stringifier.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">const </span><span class="s0">DEFAULT_RAW = {</span>
    <span class="s0">after: </span><span class="s1">'</span><span class="s4">\n</span><span class="s1">'</span><span class="s0">,</span>
    <span class="s0">beforeClose: </span><span class="s1">'</span><span class="s4">\n</span><span class="s1">'</span><span class="s0">,</span>
    <span class="s0">beforeComment: </span><span class="s1">'</span><span class="s4">\n</span><span class="s1">'</span><span class="s0">,</span>
    <span class="s0">beforeDecl: </span><span class="s1">'</span><span class="s4">\n</span><span class="s1">'</span><span class="s0">,</span>
    <span class="s0">beforeOpen: </span><span class="s1">' '</span><span class="s0">,</span>
    <span class="s0">beforeRule: </span><span class="s1">'</span><span class="s4">\n</span><span class="s1">'</span><span class="s0">,</span>
    <span class="s0">colon: </span><span class="s1">': '</span><span class="s0">,</span>
    <span class="s0">commentLeft: </span><span class="s1">' '</span><span class="s0">,</span>
    <span class="s0">commentRight: </span><span class="s1">' '</span><span class="s0">,</span>
    <span class="s0">emptyBody: </span><span class="s1">''</span><span class="s0">,</span>
    <span class="s0">indent: </span><span class="s1">'    '</span><span class="s0">,</span>
    <span class="s0">semicolon: </span><span class="s2">false</span>
<span class="s0">};</span>
<span class="s2">function </span><span class="s0">capitalize(str) {</span>
    <span class="s2">return </span><span class="s0">str[</span><span class="s3">0</span><span class="s0">].toUpperCase() + str.slice(</span><span class="s3">1</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s2">class </span><span class="s0">Stringifier {</span>
    <span class="s0">constructor(builder){</span>
        <span class="s2">this</span><span class="s0">.builder = builder;</span>
    <span class="s0">}</span>
    <span class="s0">atrule(node, semicolon) {</span>
        <span class="s2">let </span><span class="s0">name = </span><span class="s1">'@' </span><span class="s0">+ node.name;</span>
        <span class="s2">let </span><span class="s0">params = node.params ? </span><span class="s2">this</span><span class="s0">.rawValue(node, </span><span class="s1">'params'</span><span class="s0">) : </span><span class="s1">''</span><span class="s0">;</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">node.raws.afterName !== </span><span class="s1">'undefined'</span><span class="s0">) {</span>
            <span class="s0">name += node.raws.afterName;</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(params) {</span>
            <span class="s0">name += </span><span class="s1">' '</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(node.nodes) {</span>
            <span class="s2">this</span><span class="s0">.block(node, name + params);</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">let </span><span class="s0">end = (node.raws.between || </span><span class="s1">''</span><span class="s0">) + (semicolon ? </span><span class="s1">';' </span><span class="s0">: </span><span class="s1">''</span><span class="s0">);</span>
            <span class="s2">this</span><span class="s0">.builder(name + params + end, node);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">beforeAfter(node, detect) {</span>
        <span class="s2">let </span><span class="s0">value;</span>
        <span class="s2">if </span><span class="s0">(node.type === </span><span class="s1">'decl'</span><span class="s0">) {</span>
            <span class="s0">value = </span><span class="s2">this</span><span class="s0">.raw(node, </span><span class="s2">null</span><span class="s0">, </span><span class="s1">'beforeDecl'</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(node.type === </span><span class="s1">'comment'</span><span class="s0">) {</span>
            <span class="s0">value = </span><span class="s2">this</span><span class="s0">.raw(node, </span><span class="s2">null</span><span class="s0">, </span><span class="s1">'beforeComment'</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(detect === </span><span class="s1">'before'</span><span class="s0">) {</span>
            <span class="s0">value = </span><span class="s2">this</span><span class="s0">.raw(node, </span><span class="s2">null</span><span class="s0">, </span><span class="s1">'beforeRule'</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s0">value = </span><span class="s2">this</span><span class="s0">.raw(node, </span><span class="s2">null</span><span class="s0">, </span><span class="s1">'beforeClose'</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s2">let </span><span class="s0">buf = node.parent;</span>
        <span class="s2">let </span><span class="s0">depth = </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s2">while</span><span class="s0">(buf &amp;&amp; buf.type !== </span><span class="s1">'root'</span><span class="s0">){</span>
            <span class="s0">depth += </span><span class="s3">1</span><span class="s0">;</span>
            <span class="s0">buf = buf.parent;</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(value.includes(</span><span class="s1">'</span><span class="s4">\n</span><span class="s1">'</span><span class="s0">)) {</span>
            <span class="s2">let </span><span class="s0">indent = </span><span class="s2">this</span><span class="s0">.raw(node, </span><span class="s2">null</span><span class="s0">, </span><span class="s1">'indent'</span><span class="s0">);</span>
            <span class="s2">if </span><span class="s0">(indent.length) {</span>
                <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">step = </span><span class="s3">0</span><span class="s0">; step &lt; depth; step++)value += indent;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">value;</span>
    <span class="s0">}</span>
    <span class="s0">block(node, start) {</span>
        <span class="s2">let </span><span class="s0">between = </span><span class="s2">this</span><span class="s0">.raw(node, </span><span class="s1">'between'</span><span class="s0">, </span><span class="s1">'beforeOpen'</span><span class="s0">);</span>
        <span class="s2">this</span><span class="s0">.builder(start + between + </span><span class="s1">'{'</span><span class="s0">, node, </span><span class="s1">'start'</span><span class="s0">);</span>
        <span class="s2">let </span><span class="s0">after;</span>
        <span class="s2">if </span><span class="s0">(node.nodes &amp;&amp; node.nodes.length) {</span>
            <span class="s2">this</span><span class="s0">.body(node);</span>
            <span class="s0">after = </span><span class="s2">this</span><span class="s0">.raw(node, </span><span class="s1">'after'</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s0">after = </span><span class="s2">this</span><span class="s0">.raw(node, </span><span class="s1">'after'</span><span class="s0">, </span><span class="s1">'emptyBody'</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(after) </span><span class="s2">this</span><span class="s0">.builder(after);</span>
        <span class="s2">this</span><span class="s0">.builder(</span><span class="s1">'}'</span><span class="s0">, node, </span><span class="s1">'end'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s0">body(node) {</span>
        <span class="s2">let </span><span class="s0">last = node.nodes.length - </span><span class="s3">1</span><span class="s0">;</span>
        <span class="s2">while</span><span class="s0">(last &gt; </span><span class="s3">0</span><span class="s0">){</span>
            <span class="s2">if </span><span class="s0">(node.nodes[last].type !== </span><span class="s1">'comment'</span><span class="s0">) </span><span class="s2">break</span><span class="s0">;</span>
            <span class="s0">last -= </span><span class="s3">1</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s2">let </span><span class="s0">semicolon = </span><span class="s2">this</span><span class="s0">.raw(node, </span><span class="s1">'semicolon'</span><span class="s0">);</span>
        <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; node.nodes.length; i++){</span>
            <span class="s2">let </span><span class="s0">child = node.nodes[i];</span>
            <span class="s2">let </span><span class="s0">before = </span><span class="s2">this</span><span class="s0">.raw(child, </span><span class="s1">'before'</span><span class="s0">);</span>
            <span class="s2">if </span><span class="s0">(before) </span><span class="s2">this</span><span class="s0">.builder(before);</span>
            <span class="s2">this</span><span class="s0">.stringify(child, last !== i || semicolon);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">comment(node) {</span>
        <span class="s2">let </span><span class="s0">left = </span><span class="s2">this</span><span class="s0">.raw(node, </span><span class="s1">'left'</span><span class="s0">, </span><span class="s1">'commentLeft'</span><span class="s0">);</span>
        <span class="s2">let </span><span class="s0">right = </span><span class="s2">this</span><span class="s0">.raw(node, </span><span class="s1">'right'</span><span class="s0">, </span><span class="s1">'commentRight'</span><span class="s0">);</span>
        <span class="s2">this</span><span class="s0">.builder(</span><span class="s1">'/*' </span><span class="s0">+ left + node.text + right + </span><span class="s1">'*/'</span><span class="s0">, node);</span>
    <span class="s0">}</span>
    <span class="s0">decl(node, semicolon) {</span>
        <span class="s2">let </span><span class="s0">between = </span><span class="s2">this</span><span class="s0">.raw(node, </span><span class="s1">'between'</span><span class="s0">, </span><span class="s1">'colon'</span><span class="s0">);</span>
        <span class="s2">let </span><span class="s0">string = node.prop + between + </span><span class="s2">this</span><span class="s0">.rawValue(node, </span><span class="s1">'value'</span><span class="s0">);</span>
        <span class="s2">if </span><span class="s0">(node.important) {</span>
            <span class="s0">string += node.raws.important || </span><span class="s1">' !important'</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(semicolon) string += </span><span class="s1">';'</span><span class="s0">;</span>
        <span class="s2">this</span><span class="s0">.builder(string, node);</span>
    <span class="s0">}</span>
    <span class="s0">document(node) {</span>
        <span class="s2">this</span><span class="s0">.body(node);</span>
    <span class="s0">}</span>
    <span class="s0">raw(node, own, detect) {</span>
        <span class="s2">let </span><span class="s0">value;</span>
        <span class="s2">if </span><span class="s0">(!detect) detect = own;</span>
        <span class="s6">// Already had</span>
        <span class="s2">if </span><span class="s0">(own) {</span>
            <span class="s0">value = node.raws[own];</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">value !== </span><span class="s1">'undefined'</span><span class="s0">) </span><span class="s2">return </span><span class="s0">value;</span>
        <span class="s0">}</span>
        <span class="s2">let </span><span class="s0">parent = node.parent;</span>
        <span class="s2">if </span><span class="s0">(detect === </span><span class="s1">'before'</span><span class="s0">) {</span>
            <span class="s6">// Hack for first rule in CSS</span>
            <span class="s2">if </span><span class="s0">(!parent || parent.type === </span><span class="s1">'root' </span><span class="s0">&amp;&amp; parent.first === node) {</span>
                <span class="s2">return </span><span class="s1">''</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s6">// `root` nodes in `document` should use only their own raws</span>
            <span class="s2">if </span><span class="s0">(parent &amp;&amp; parent.type === </span><span class="s1">'document'</span><span class="s0">) {</span>
                <span class="s2">return </span><span class="s1">''</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s6">// Floating child without parent</span>
        <span class="s2">if </span><span class="s0">(!parent) </span><span class="s2">return </span><span class="s0">DEFAULT_RAW[detect];</span>
        <span class="s6">// Detect style by other nodes</span>
        <span class="s2">let </span><span class="s0">root = node.root();</span>
        <span class="s2">if </span><span class="s0">(!root.rawCache) root.rawCache = {};</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">root.rawCache[detect] !== </span><span class="s1">'undefined'</span><span class="s0">) {</span>
            <span class="s2">return </span><span class="s0">root.rawCache[detect];</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(detect === </span><span class="s1">'before' </span><span class="s0">|| detect === </span><span class="s1">'after'</span><span class="s0">) {</span>
            <span class="s2">return this</span><span class="s0">.beforeAfter(node, detect);</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">let </span><span class="s0">method = </span><span class="s1">'raw' </span><span class="s0">+ capitalize(detect);</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">[method]) {</span>
                <span class="s0">value = </span><span class="s2">this</span><span class="s0">[method](root, node);</span>
            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                <span class="s0">root.walk((i)=&gt;{</span>
                    <span class="s0">value = i.raws[own];</span>
                    <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">value !== </span><span class="s1">'undefined'</span><span class="s0">) </span><span class="s2">return false</span><span class="s0">;</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">value === </span><span class="s1">'undefined'</span><span class="s0">) value = DEFAULT_RAW[detect];</span>
        <span class="s0">root.rawCache[detect] = value;</span>
        <span class="s2">return </span><span class="s0">value;</span>
    <span class="s0">}</span>
    <span class="s0">rawBeforeClose(root) {</span>
        <span class="s2">let </span><span class="s0">value;</span>
        <span class="s0">root.walk((i)=&gt;{</span>
            <span class="s2">if </span><span class="s0">(i.nodes &amp;&amp; i.nodes.length &gt; </span><span class="s3">0</span><span class="s0">) {</span>
                <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">i.raws.after !== </span><span class="s1">'undefined'</span><span class="s0">) {</span>
                    <span class="s0">value = i.raws.after;</span>
                    <span class="s2">if </span><span class="s0">(value.includes(</span><span class="s1">'</span><span class="s4">\n</span><span class="s1">'</span><span class="s0">)) {</span>
                        <span class="s0">value = value.replace(</span><span class="s5">/[^\n]+$/</span><span class="s0">, </span><span class="s1">''</span><span class="s0">);</span>
                    <span class="s0">}</span>
                    <span class="s2">return false</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s2">if </span><span class="s0">(value) value = value.replace(</span><span class="s5">/\S/g</span><span class="s0">, </span><span class="s1">''</span><span class="s0">);</span>
        <span class="s2">return </span><span class="s0">value;</span>
    <span class="s0">}</span>
    <span class="s0">rawBeforeComment(root, node) {</span>
        <span class="s2">let </span><span class="s0">value;</span>
        <span class="s0">root.walkComments((i)=&gt;{</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">i.raws.before !== </span><span class="s1">'undefined'</span><span class="s0">) {</span>
                <span class="s0">value = i.raws.before;</span>
                <span class="s2">if </span><span class="s0">(value.includes(</span><span class="s1">'</span><span class="s4">\n</span><span class="s1">'</span><span class="s0">)) {</span>
                    <span class="s0">value = value.replace(</span><span class="s5">/[^\n]+$/</span><span class="s0">, </span><span class="s1">''</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s2">return false</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">value === </span><span class="s1">'undefined'</span><span class="s0">) {</span>
            <span class="s0">value = </span><span class="s2">this</span><span class="s0">.raw(node, </span><span class="s2">null</span><span class="s0">, </span><span class="s1">'beforeDecl'</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(value) {</span>
            <span class="s0">value = value.replace(</span><span class="s5">/\S/g</span><span class="s0">, </span><span class="s1">''</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">value;</span>
    <span class="s0">}</span>
    <span class="s0">rawBeforeDecl(root, node) {</span>
        <span class="s2">let </span><span class="s0">value;</span>
        <span class="s0">root.walkDecls((i)=&gt;{</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">i.raws.before !== </span><span class="s1">'undefined'</span><span class="s0">) {</span>
                <span class="s0">value = i.raws.before;</span>
                <span class="s2">if </span><span class="s0">(value.includes(</span><span class="s1">'</span><span class="s4">\n</span><span class="s1">'</span><span class="s0">)) {</span>
                    <span class="s0">value = value.replace(</span><span class="s5">/[^\n]+$/</span><span class="s0">, </span><span class="s1">''</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s2">return false</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">value === </span><span class="s1">'undefined'</span><span class="s0">) {</span>
            <span class="s0">value = </span><span class="s2">this</span><span class="s0">.raw(node, </span><span class="s2">null</span><span class="s0">, </span><span class="s1">'beforeRule'</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(value) {</span>
            <span class="s0">value = value.replace(</span><span class="s5">/\S/g</span><span class="s0">, </span><span class="s1">''</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">value;</span>
    <span class="s0">}</span>
    <span class="s0">rawBeforeOpen(root) {</span>
        <span class="s2">let </span><span class="s0">value;</span>
        <span class="s0">root.walk((i)=&gt;{</span>
            <span class="s2">if </span><span class="s0">(i.type !== </span><span class="s1">'decl'</span><span class="s0">) {</span>
                <span class="s0">value = i.raws.between;</span>
                <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">value !== </span><span class="s1">'undefined'</span><span class="s0">) </span><span class="s2">return false</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s2">return </span><span class="s0">value;</span>
    <span class="s0">}</span>
    <span class="s0">rawBeforeRule(root) {</span>
        <span class="s2">let </span><span class="s0">value;</span>
        <span class="s0">root.walk((i)=&gt;{</span>
            <span class="s2">if </span><span class="s0">(i.nodes &amp;&amp; (i.parent !== root || root.first !== i)) {</span>
                <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">i.raws.before !== </span><span class="s1">'undefined'</span><span class="s0">) {</span>
                    <span class="s0">value = i.raws.before;</span>
                    <span class="s2">if </span><span class="s0">(value.includes(</span><span class="s1">'</span><span class="s4">\n</span><span class="s1">'</span><span class="s0">)) {</span>
                        <span class="s0">value = value.replace(</span><span class="s5">/[^\n]+$/</span><span class="s0">, </span><span class="s1">''</span><span class="s0">);</span>
                    <span class="s0">}</span>
                    <span class="s2">return false</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s2">if </span><span class="s0">(value) value = value.replace(</span><span class="s5">/\S/g</span><span class="s0">, </span><span class="s1">''</span><span class="s0">);</span>
        <span class="s2">return </span><span class="s0">value;</span>
    <span class="s0">}</span>
    <span class="s0">rawColon(root) {</span>
        <span class="s2">let </span><span class="s0">value;</span>
        <span class="s0">root.walkDecls((i)=&gt;{</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">i.raws.between !== </span><span class="s1">'undefined'</span><span class="s0">) {</span>
                <span class="s0">value = i.raws.between.replace(</span><span class="s5">/[^\s:]/g</span><span class="s0">, </span><span class="s1">''</span><span class="s0">);</span>
                <span class="s2">return false</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s2">return </span><span class="s0">value;</span>
    <span class="s0">}</span>
    <span class="s0">rawEmptyBody(root) {</span>
        <span class="s2">let </span><span class="s0">value;</span>
        <span class="s0">root.walk((i)=&gt;{</span>
            <span class="s2">if </span><span class="s0">(i.nodes &amp;&amp; i.nodes.length === </span><span class="s3">0</span><span class="s0">) {</span>
                <span class="s0">value = i.raws.after;</span>
                <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">value !== </span><span class="s1">'undefined'</span><span class="s0">) </span><span class="s2">return false</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s2">return </span><span class="s0">value;</span>
    <span class="s0">}</span>
    <span class="s0">rawIndent(root) {</span>
        <span class="s2">if </span><span class="s0">(root.raws.indent) </span><span class="s2">return </span><span class="s0">root.raws.indent;</span>
        <span class="s2">let </span><span class="s0">value;</span>
        <span class="s0">root.walk((i)=&gt;{</span>
            <span class="s2">let </span><span class="s0">p = i.parent;</span>
            <span class="s2">if </span><span class="s0">(p &amp;&amp; p !== root &amp;&amp; p.parent &amp;&amp; p.parent === root) {</span>
                <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">i.raws.before !== </span><span class="s1">'undefined'</span><span class="s0">) {</span>
                    <span class="s2">let </span><span class="s0">parts = i.raws.before.split(</span><span class="s1">'</span><span class="s4">\n</span><span class="s1">'</span><span class="s0">);</span>
                    <span class="s0">value = parts[parts.length - </span><span class="s3">1</span><span class="s0">];</span>
                    <span class="s0">value = value.replace(</span><span class="s5">/\S/g</span><span class="s0">, </span><span class="s1">''</span><span class="s0">);</span>
                    <span class="s2">return false</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s2">return </span><span class="s0">value;</span>
    <span class="s0">}</span>
    <span class="s0">rawSemicolon(root) {</span>
        <span class="s2">let </span><span class="s0">value;</span>
        <span class="s0">root.walk((i)=&gt;{</span>
            <span class="s2">if </span><span class="s0">(i.nodes &amp;&amp; i.nodes.length &amp;&amp; i.last.type === </span><span class="s1">'decl'</span><span class="s0">) {</span>
                <span class="s0">value = i.raws.semicolon;</span>
                <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">value !== </span><span class="s1">'undefined'</span><span class="s0">) </span><span class="s2">return false</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s2">return </span><span class="s0">value;</span>
    <span class="s0">}</span>
    <span class="s0">rawValue(node, prop) {</span>
        <span class="s2">let </span><span class="s0">value = node[prop];</span>
        <span class="s2">let </span><span class="s0">raw = node.raws[prop];</span>
        <span class="s2">if </span><span class="s0">(raw &amp;&amp; raw.value === value) {</span>
            <span class="s2">return </span><span class="s0">raw.raw;</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">value;</span>
    <span class="s0">}</span>
    <span class="s0">root(node) {</span>
        <span class="s2">this</span><span class="s0">.body(node);</span>
        <span class="s2">if </span><span class="s0">(node.raws.after) </span><span class="s2">this</span><span class="s0">.builder(node.raws.after);</span>
    <span class="s0">}</span>
    <span class="s0">rule(node) {</span>
        <span class="s2">this</span><span class="s0">.block(node, </span><span class="s2">this</span><span class="s0">.rawValue(node, </span><span class="s1">'selector'</span><span class="s0">));</span>
        <span class="s2">if </span><span class="s0">(node.raws.ownSemicolon) {</span>
            <span class="s2">this</span><span class="s0">.builder(node.raws.ownSemicolon, node, </span><span class="s1">'end'</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">stringify(node, semicolon) {</span>
        <span class="s6">/* c8 ignore start */ </span><span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">[node.type]) {</span>
            <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">'Unknown AST node type ' </span><span class="s0">+ node.type + </span><span class="s1">'. ' </span><span class="s0">+ </span><span class="s1">'Maybe you need to change PostCSS stringifier.'</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s6">/* c8 ignore stop */ </span><span class="s2">this</span><span class="s0">[node.type](node, semicolon);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">module.exports = Stringifier;</span>
<span class="s0">Stringifier.default = Stringifier;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/stringify.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">let </span><span class="s0">Stringifier = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/stringifier.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">function </span><span class="s0">stringify(node, builder) {</span>
    <span class="s2">let </span><span class="s0">str = </span><span class="s2">new </span><span class="s0">Stringifier(builder);</span>
    <span class="s0">str.stringify(node);</span>
<span class="s0">}</span>
<span class="s0">module.exports = stringify;</span>
<span class="s0">stringify.default = stringify;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/symbols.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">module.exports.isClean = Symbol(</span><span class="s1">'isClean'</span><span class="s0">);</span>
<span class="s0">module.exports.my = Symbol(</span><span class="s1">'my'</span><span class="s0">);</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/node.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">let </span><span class="s0">CssSyntaxError = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/css-syntax-error.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Stringifier = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/stringifier.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">stringify = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/stringify.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">{ isClean, my } = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/symbols.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">function </span><span class="s0">cloneNode(obj, parent) {</span>
    <span class="s2">let </span><span class="s0">cloned = </span><span class="s2">new </span><span class="s0">obj.constructor();</span>
    <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">i </span><span class="s2">in </span><span class="s0">obj){</span>
        <span class="s2">if </span><span class="s0">(!Object.prototype.hasOwnProperty.call(obj, i)) {</span>
            <span class="s2">continue</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(i === </span><span class="s1">'proxyCache'</span><span class="s0">) </span><span class="s2">continue</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">value = obj[i];</span>
        <span class="s2">let </span><span class="s0">type = </span><span class="s2">typeof </span><span class="s0">value;</span>
        <span class="s2">if </span><span class="s0">(i === </span><span class="s1">'parent' </span><span class="s0">&amp;&amp; type === </span><span class="s1">'object'</span><span class="s0">) {</span>
            <span class="s2">if </span><span class="s0">(parent) cloned[i] = parent;</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(i === </span><span class="s1">'source'</span><span class="s0">) {</span>
            <span class="s0">cloned[i] = value;</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(Array.isArray(value)) {</span>
            <span class="s0">cloned[i] = value.map((j)=&gt;cloneNode(j, cloned));</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">if </span><span class="s0">(type === </span><span class="s1">'object' </span><span class="s0">&amp;&amp; value !== </span><span class="s2">null</span><span class="s0">) value = cloneNode(value);</span>
            <span class="s0">cloned[i] = value;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">cloned;</span>
<span class="s0">}</span>
<span class="s2">function </span><span class="s0">sourceOffset(inputCSS, position) {</span>
    <span class="s6">// Not all custom syntaxes support `offset` in `source.start` and `source.end`</span>
    <span class="s2">if </span><span class="s0">(position &amp;&amp; </span><span class="s2">typeof </span><span class="s0">position.offset !== </span><span class="s1">'undefined'</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">position.offset;</span>
    <span class="s0">}</span>
    <span class="s2">let </span><span class="s0">column = </span><span class="s3">1</span><span class="s0">;</span>
    <span class="s2">let </span><span class="s0">line = </span><span class="s3">1</span><span class="s0">;</span>
    <span class="s2">let </span><span class="s0">offset = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; inputCSS.length; i++){</span>
        <span class="s2">if </span><span class="s0">(line === position.line &amp;&amp; column === position.column) {</span>
            <span class="s0">offset = i;</span>
            <span class="s2">break</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(inputCSS[i] === </span><span class="s1">'</span><span class="s4">\n</span><span class="s1">'</span><span class="s0">) {</span>
            <span class="s0">column = </span><span class="s3">1</span><span class="s0">;</span>
            <span class="s0">line += </span><span class="s3">1</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s0">column += </span><span class="s3">1</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">offset;</span>
<span class="s0">}</span>
<span class="s2">class </span><span class="s0">Node {</span>
    <span class="s0">get proxyOf() {</span>
        <span class="s2">return this</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">constructor(defaults = {}){</span>
        <span class="s2">this</span><span class="s0">.raws = {};</span>
        <span class="s2">this</span><span class="s0">[isClean] = </span><span class="s2">false</span><span class="s0">;</span>
        <span class="s2">this</span><span class="s0">[my] = </span><span class="s2">true</span><span class="s0">;</span>
        <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">name </span><span class="s2">in </span><span class="s0">defaults){</span>
            <span class="s2">if </span><span class="s0">(name === </span><span class="s1">'nodes'</span><span class="s0">) {</span>
                <span class="s2">this</span><span class="s0">.nodes = [];</span>
                <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">node of defaults[name]){</span>
                    <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">node.clone === </span><span class="s1">'function'</span><span class="s0">) {</span>
                        <span class="s2">this</span><span class="s0">.append(node.clone());</span>
                    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                        <span class="s2">this</span><span class="s0">.append(node);</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                <span class="s2">this</span><span class="s0">[name] = defaults[name];</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">addToError(error) {</span>
        <span class="s0">error.postcssNode = </span><span class="s2">this</span><span class="s0">;</span>
        <span class="s2">if </span><span class="s0">(error.stack &amp;&amp; </span><span class="s2">this</span><span class="s0">.source &amp;&amp; </span><span class="s5">/\n\s{4}at /</span><span class="s0">.test(error.stack)) {</span>
            <span class="s2">let </span><span class="s0">s = </span><span class="s2">this</span><span class="s0">.source;</span>
            <span class="s0">error.stack = error.stack.replace(</span><span class="s5">/\n\s{4}at /</span><span class="s0">, </span><span class="s1">`$&amp;</span><span class="s0">${s.input.from}</span><span class="s1">:</span><span class="s0">${s.start.line}</span><span class="s1">:</span><span class="s0">${s.start.column}</span><span class="s1">$&amp;`</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">error;</span>
    <span class="s0">}</span>
    <span class="s0">after(add) {</span>
        <span class="s2">this</span><span class="s0">.parent.insertAfter(</span><span class="s2">this</span><span class="s0">, add);</span>
        <span class="s2">return this</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">assign(overrides = {}) {</span>
        <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">name </span><span class="s2">in </span><span class="s0">overrides){</span>
            <span class="s2">this</span><span class="s0">[name] = overrides[name];</span>
        <span class="s0">}</span>
        <span class="s2">return this</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">before(add) {</span>
        <span class="s2">this</span><span class="s0">.parent.insertBefore(</span><span class="s2">this</span><span class="s0">, add);</span>
        <span class="s2">return this</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">cleanRaws(keepBetween) {</span>
        <span class="s2">delete this</span><span class="s0">.raws.before;</span>
        <span class="s2">delete this</span><span class="s0">.raws.after;</span>
        <span class="s2">if </span><span class="s0">(!keepBetween) </span><span class="s2">delete this</span><span class="s0">.raws.between;</span>
    <span class="s0">}</span>
    <span class="s0">clone(overrides = {}) {</span>
        <span class="s2">let </span><span class="s0">cloned = cloneNode(</span><span class="s2">this</span><span class="s0">);</span>
        <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">name </span><span class="s2">in </span><span class="s0">overrides){</span>
            <span class="s0">cloned[name] = overrides[name];</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">cloned;</span>
    <span class="s0">}</span>
    <span class="s0">cloneAfter(overrides = {}) {</span>
        <span class="s2">let </span><span class="s0">cloned = </span><span class="s2">this</span><span class="s0">.clone(overrides);</span>
        <span class="s2">this</span><span class="s0">.parent.insertAfter(</span><span class="s2">this</span><span class="s0">, cloned);</span>
        <span class="s2">return </span><span class="s0">cloned;</span>
    <span class="s0">}</span>
    <span class="s0">cloneBefore(overrides = {}) {</span>
        <span class="s2">let </span><span class="s0">cloned = </span><span class="s2">this</span><span class="s0">.clone(overrides);</span>
        <span class="s2">this</span><span class="s0">.parent.insertBefore(</span><span class="s2">this</span><span class="s0">, cloned);</span>
        <span class="s2">return </span><span class="s0">cloned;</span>
    <span class="s0">}</span>
    <span class="s0">error(message, opts = {}) {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.source) {</span>
            <span class="s2">let </span><span class="s0">{ end, start } = </span><span class="s2">this</span><span class="s0">.rangeBy(opts);</span>
            <span class="s2">return this</span><span class="s0">.source.input.error(message, {</span>
                <span class="s0">column: start.column,</span>
                <span class="s0">line: start.line</span>
            <span class="s0">}, {</span>
                <span class="s0">column: end.column,</span>
                <span class="s0">line: end.line</span>
            <span class="s0">}, opts);</span>
        <span class="s0">}</span>
        <span class="s2">return new </span><span class="s0">CssSyntaxError(message);</span>
    <span class="s0">}</span>
    <span class="s0">getProxyProcessor() {</span>
        <span class="s2">return </span><span class="s0">{</span>
            <span class="s0">get (node, prop) {</span>
                <span class="s2">if </span><span class="s0">(prop === </span><span class="s1">'proxyOf'</span><span class="s0">) {</span>
                    <span class="s2">return </span><span class="s0">node;</span>
                <span class="s0">} </span><span class="s2">else if </span><span class="s0">(prop === </span><span class="s1">'root'</span><span class="s0">) {</span>
                    <span class="s2">return </span><span class="s0">()=&gt;node.root().toProxy();</span>
                <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                    <span class="s2">return </span><span class="s0">node[prop];</span>
                <span class="s0">}</span>
            <span class="s0">},</span>
            <span class="s0">set (node, prop, value) {</span>
                <span class="s2">if </span><span class="s0">(node[prop] === value) </span><span class="s2">return true</span><span class="s0">;</span>
                <span class="s0">node[prop] = value;</span>
                <span class="s2">if </span><span class="s0">(prop === </span><span class="s1">'prop' </span><span class="s0">|| prop === </span><span class="s1">'value' </span><span class="s0">|| prop === </span><span class="s1">'name' </span><span class="s0">|| prop === </span><span class="s1">'params' </span><span class="s0">|| prop === </span><span class="s1">'important' </span><span class="s0">|| </span><span class="s6">/* c8 ignore next */ </span><span class="s0">prop === </span><span class="s1">'text'</span><span class="s0">) {</span>
                    <span class="s0">node.markDirty();</span>
                <span class="s0">}</span>
                <span class="s2">return true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s6">/* c8 ignore next 3 */ </span><span class="s0">markClean() {</span>
        <span class="s2">this</span><span class="s0">[isClean] = </span><span class="s2">true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">markDirty() {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">[isClean]) {</span>
            <span class="s2">this</span><span class="s0">[isClean] = </span><span class="s2">false</span><span class="s0">;</span>
            <span class="s2">let </span><span class="s0">next = </span><span class="s2">this</span><span class="s0">;</span>
            <span class="s2">while</span><span class="s0">(next = next.parent){</span>
                <span class="s0">next[isClean] = </span><span class="s2">false</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">next() {</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.parent) </span><span class="s2">return </span><span class="s0">undefined;</span>
        <span class="s2">let </span><span class="s0">index = </span><span class="s2">this</span><span class="s0">.parent.index(</span><span class="s2">this</span><span class="s0">);</span>
        <span class="s2">return this</span><span class="s0">.parent.nodes[index + </span><span class="s3">1</span><span class="s0">];</span>
    <span class="s0">}</span>
    <span class="s0">positionBy(opts = {}) {</span>
        <span class="s2">let </span><span class="s0">pos = </span><span class="s2">this</span><span class="s0">.source.start;</span>
        <span class="s2">if </span><span class="s0">(opts.index) {</span>
            <span class="s0">pos = </span><span class="s2">this</span><span class="s0">.positionInside(opts.index);</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(opts.word) {</span>
            <span class="s2">let </span><span class="s0">inputString = </span><span class="s1">'document' </span><span class="s2">in this</span><span class="s0">.source.input ? </span><span class="s2">this</span><span class="s0">.source.input.document : </span><span class="s2">this</span><span class="s0">.source.input.css;</span>
            <span class="s2">let </span><span class="s0">stringRepresentation = inputString.slice(sourceOffset(inputString, </span><span class="s2">this</span><span class="s0">.source.start), sourceOffset(inputString, </span><span class="s2">this</span><span class="s0">.source.end));</span>
            <span class="s2">let </span><span class="s0">index = stringRepresentation.indexOf(opts.word);</span>
            <span class="s2">if </span><span class="s0">(index !== -</span><span class="s3">1</span><span class="s0">) pos = </span><span class="s2">this</span><span class="s0">.positionInside(index);</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">pos;</span>
    <span class="s0">}</span>
    <span class="s0">positionInside(index) {</span>
        <span class="s2">let </span><span class="s0">column = </span><span class="s2">this</span><span class="s0">.source.start.column;</span>
        <span class="s2">let </span><span class="s0">line = </span><span class="s2">this</span><span class="s0">.source.start.line;</span>
        <span class="s2">let </span><span class="s0">inputString = </span><span class="s1">'document' </span><span class="s2">in this</span><span class="s0">.source.input ? </span><span class="s2">this</span><span class="s0">.source.input.document : </span><span class="s2">this</span><span class="s0">.source.input.css;</span>
        <span class="s2">let </span><span class="s0">offset = sourceOffset(inputString, </span><span class="s2">this</span><span class="s0">.source.start);</span>
        <span class="s2">let </span><span class="s0">end = offset + index;</span>
        <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">i = offset; i &lt; end; i++){</span>
            <span class="s2">if </span><span class="s0">(inputString[i] === </span><span class="s1">'</span><span class="s4">\n</span><span class="s1">'</span><span class="s0">) {</span>
                <span class="s0">column = </span><span class="s3">1</span><span class="s0">;</span>
                <span class="s0">line += </span><span class="s3">1</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                <span class="s0">column += </span><span class="s3">1</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">{</span>
            <span class="s0">column,</span>
            <span class="s0">line,</span>
            <span class="s0">offset: end</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s0">prev() {</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.parent) </span><span class="s2">return </span><span class="s0">undefined;</span>
        <span class="s2">let </span><span class="s0">index = </span><span class="s2">this</span><span class="s0">.parent.index(</span><span class="s2">this</span><span class="s0">);</span>
        <span class="s2">return this</span><span class="s0">.parent.nodes[index - </span><span class="s3">1</span><span class="s0">];</span>
    <span class="s0">}</span>
    <span class="s0">rangeBy(opts = {}) {</span>
        <span class="s2">let </span><span class="s0">inputString = </span><span class="s1">'document' </span><span class="s2">in this</span><span class="s0">.source.input ? </span><span class="s2">this</span><span class="s0">.source.input.document : </span><span class="s2">this</span><span class="s0">.source.input.css;</span>
        <span class="s2">let </span><span class="s0">start = {</span>
            <span class="s0">column: </span><span class="s2">this</span><span class="s0">.source.start.column,</span>
            <span class="s0">line: </span><span class="s2">this</span><span class="s0">.source.start.line,</span>
            <span class="s0">offset: sourceOffset(inputString, </span><span class="s2">this</span><span class="s0">.source.start)</span>
        <span class="s0">};</span>
        <span class="s2">let </span><span class="s0">end = </span><span class="s2">this</span><span class="s0">.source.end ? {</span>
            <span class="s0">column: </span><span class="s2">this</span><span class="s0">.source.end.column + </span><span class="s3">1</span><span class="s0">,</span>
            <span class="s0">line: </span><span class="s2">this</span><span class="s0">.source.end.line,</span>
            <span class="s0">offset: </span><span class="s2">typeof this</span><span class="s0">.source.end.offset === </span><span class="s1">'number' </span><span class="s0">? </span><span class="s2">this</span><span class="s0">.source.end.offset : </span><span class="s6">// the `sourceOffset(... , this.source.end)` returns an inclusive offset.</span>
            <span class="s6">// So, we add 1 to convert it to exclusive.</span>
            <span class="s0">sourceOffset(inputString, </span><span class="s2">this</span><span class="s0">.source.end) + </span><span class="s3">1</span>
        <span class="s0">} : {</span>
            <span class="s0">column: start.column + </span><span class="s3">1</span><span class="s0">,</span>
            <span class="s0">line: start.line,</span>
            <span class="s0">offset: start.offset + </span><span class="s3">1</span>
        <span class="s0">};</span>
        <span class="s2">if </span><span class="s0">(opts.word) {</span>
            <span class="s2">let </span><span class="s0">stringRepresentation = inputString.slice(sourceOffset(inputString, </span><span class="s2">this</span><span class="s0">.source.start), sourceOffset(inputString, </span><span class="s2">this</span><span class="s0">.source.end));</span>
            <span class="s2">let </span><span class="s0">index = stringRepresentation.indexOf(opts.word);</span>
            <span class="s2">if </span><span class="s0">(index !== -</span><span class="s3">1</span><span class="s0">) {</span>
                <span class="s0">start = </span><span class="s2">this</span><span class="s0">.positionInside(index);</span>
                <span class="s0">end = </span><span class="s2">this</span><span class="s0">.positionInside(index + opts.word.length);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">if </span><span class="s0">(opts.start) {</span>
                <span class="s0">start = {</span>
                    <span class="s0">column: opts.start.column,</span>
                    <span class="s0">line: opts.start.line,</span>
                    <span class="s0">offset: sourceOffset(inputString, opts.start)</span>
                <span class="s0">};</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(opts.index) {</span>
                <span class="s0">start = </span><span class="s2">this</span><span class="s0">.positionInside(opts.index);</span>
            <span class="s0">}</span>
            <span class="s2">if </span><span class="s0">(opts.end) {</span>
                <span class="s0">end = {</span>
                    <span class="s0">column: opts.end.column,</span>
                    <span class="s0">line: opts.end.line,</span>
                    <span class="s0">offset: sourceOffset(inputString, opts.end)</span>
                <span class="s0">};</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">opts.endIndex === </span><span class="s1">'number'</span><span class="s0">) {</span>
                <span class="s0">end = </span><span class="s2">this</span><span class="s0">.positionInside(opts.endIndex);</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(opts.index) {</span>
                <span class="s0">end = </span><span class="s2">this</span><span class="s0">.positionInside(opts.index + </span><span class="s3">1</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(end.line &lt; start.line || end.line === start.line &amp;&amp; end.column &lt;= start.column) {</span>
            <span class="s0">end = {</span>
                <span class="s0">column: start.column + </span><span class="s3">1</span><span class="s0">,</span>
                <span class="s0">line: start.line,</span>
                <span class="s0">offset: start.offset + </span><span class="s3">1</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">{</span>
            <span class="s0">end,</span>
            <span class="s0">start</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s0">raw(prop, defaultType) {</span>
        <span class="s2">let </span><span class="s0">str = </span><span class="s2">new </span><span class="s0">Stringifier();</span>
        <span class="s2">return </span><span class="s0">str.raw(</span><span class="s2">this</span><span class="s0">, prop, defaultType);</span>
    <span class="s0">}</span>
    <span class="s0">remove() {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.parent) {</span>
            <span class="s2">this</span><span class="s0">.parent.removeChild(</span><span class="s2">this</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s2">this</span><span class="s0">.parent = undefined;</span>
        <span class="s2">return this</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">replaceWith(...nodes) {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.parent) {</span>
            <span class="s2">let </span><span class="s0">bookmark = </span><span class="s2">this</span><span class="s0">;</span>
            <span class="s2">let </span><span class="s0">foundSelf = </span><span class="s2">false</span><span class="s0">;</span>
            <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">node of nodes){</span>
                <span class="s2">if </span><span class="s0">(node === </span><span class="s2">this</span><span class="s0">) {</span>
                    <span class="s0">foundSelf = </span><span class="s2">true</span><span class="s0">;</span>
                <span class="s0">} </span><span class="s2">else if </span><span class="s0">(foundSelf) {</span>
                    <span class="s2">this</span><span class="s0">.parent.insertAfter(bookmark, node);</span>
                    <span class="s0">bookmark = node;</span>
                <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                    <span class="s2">this</span><span class="s0">.parent.insertBefore(bookmark, node);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s2">if </span><span class="s0">(!foundSelf) {</span>
                <span class="s2">this</span><span class="s0">.remove();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">return this</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">root() {</span>
        <span class="s2">let </span><span class="s0">result = </span><span class="s2">this</span><span class="s0">;</span>
        <span class="s2">while</span><span class="s0">(result.parent &amp;&amp; result.parent.type !== </span><span class="s1">'document'</span><span class="s0">){</span>
            <span class="s0">result = result.parent;</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">result;</span>
    <span class="s0">}</span>
    <span class="s0">toJSON(_, inputs) {</span>
        <span class="s2">let </span><span class="s0">fixed = {};</span>
        <span class="s2">let </span><span class="s0">emitInputs = inputs == </span><span class="s2">null</span><span class="s0">;</span>
        <span class="s0">inputs = inputs || </span><span class="s2">new </span><span class="s0">Map();</span>
        <span class="s2">let </span><span class="s0">inputsNextIndex = </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">name </span><span class="s2">in this</span><span class="s0">){</span>
            <span class="s2">if </span><span class="s0">(!Object.prototype.hasOwnProperty.call(</span><span class="s2">this</span><span class="s0">, name)) {</span>
                <span class="s2">continue</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s2">if </span><span class="s0">(name === </span><span class="s1">'parent' </span><span class="s0">|| name === </span><span class="s1">'proxyCache'</span><span class="s0">) </span><span class="s2">continue</span><span class="s0">;</span>
            <span class="s2">let </span><span class="s0">value = </span><span class="s2">this</span><span class="s0">[name];</span>
            <span class="s2">if </span><span class="s0">(Array.isArray(value)) {</span>
                <span class="s0">fixed[name] = value.map((i)=&gt;{</span>
                    <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">i === </span><span class="s1">'object' </span><span class="s0">&amp;&amp; i.toJSON) {</span>
                        <span class="s2">return </span><span class="s0">i.toJSON(</span><span class="s2">null</span><span class="s0">, inputs);</span>
                    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                        <span class="s2">return </span><span class="s0">i;</span>
                    <span class="s0">}</span>
                <span class="s0">});</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">value === </span><span class="s1">'object' </span><span class="s0">&amp;&amp; value.toJSON) {</span>
                <span class="s0">fixed[name] = value.toJSON(</span><span class="s2">null</span><span class="s0">, inputs);</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(name === </span><span class="s1">'source'</span><span class="s0">) {</span>
                <span class="s2">if </span><span class="s0">(value == </span><span class="s2">null</span><span class="s0">) </span><span class="s2">continue</span><span class="s0">;</span>
                <span class="s2">let </span><span class="s0">inputId = inputs.get(value.input);</span>
                <span class="s2">if </span><span class="s0">(inputId == </span><span class="s2">null</span><span class="s0">) {</span>
                    <span class="s0">inputId = inputsNextIndex;</span>
                    <span class="s0">inputs.set(value.input, inputsNextIndex);</span>
                    <span class="s0">inputsNextIndex++;</span>
                <span class="s0">}</span>
                <span class="s0">fixed[name] = {</span>
                    <span class="s0">end: value.end,</span>
                    <span class="s0">inputId,</span>
                    <span class="s0">start: value.start</span>
                <span class="s0">};</span>
            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                <span class="s0">fixed[name] = value;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(emitInputs) {</span>
            <span class="s0">fixed.inputs = [</span>
                <span class="s0">...inputs.keys()</span>
            <span class="s0">].map((input)=&gt;input.toJSON());</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">fixed;</span>
    <span class="s0">}</span>
    <span class="s0">toProxy() {</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.proxyCache) {</span>
            <span class="s2">this</span><span class="s0">.proxyCache = </span><span class="s2">new </span><span class="s0">Proxy(</span><span class="s2">this</span><span class="s0">, </span><span class="s2">this</span><span class="s0">.getProxyProcessor());</span>
        <span class="s0">}</span>
        <span class="s2">return this</span><span class="s0">.proxyCache;</span>
    <span class="s0">}</span>
    <span class="s0">toString(stringifier = stringify) {</span>
        <span class="s2">if </span><span class="s0">(stringifier.stringify) stringifier = stringifier.stringify;</span>
        <span class="s2">let </span><span class="s0">result = </span><span class="s1">''</span><span class="s0">;</span>
        <span class="s0">stringifier(</span><span class="s2">this</span><span class="s0">, (i)=&gt;{</span>
            <span class="s0">result += i;</span>
        <span class="s0">});</span>
        <span class="s2">return </span><span class="s0">result;</span>
    <span class="s0">}</span>
    <span class="s0">warn(result, text, opts = {}) {</span>
        <span class="s2">let </span><span class="s0">data = {</span>
            <span class="s0">node: </span><span class="s2">this</span>
        <span class="s0">};</span>
        <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">i </span><span class="s2">in </span><span class="s0">opts)data[i] = opts[i];</span>
        <span class="s2">return </span><span class="s0">result.warn(text, data);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">module.exports = Node;</span>
<span class="s0">Node.default = Node;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/comment.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">let </span><span class="s0">Node = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/node.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">class </span><span class="s0">Comment </span><span class="s2">extends </span><span class="s0">Node {</span>
    <span class="s0">constructor(defaults){</span>
        <span class="s2">super</span><span class="s0">(defaults);</span>
        <span class="s2">this</span><span class="s0">.type = </span><span class="s1">'comment'</span><span class="s0">;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">module.exports = Comment;</span>
<span class="s0">Comment.default = Comment;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/declaration.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">let </span><span class="s0">Node = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/node.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">class </span><span class="s0">Declaration </span><span class="s2">extends </span><span class="s0">Node {</span>
    <span class="s0">get variable() {</span>
        <span class="s2">return this</span><span class="s0">.prop.startsWith(</span><span class="s1">'--'</span><span class="s0">) || </span><span class="s2">this</span><span class="s0">.prop[</span><span class="s3">0</span><span class="s0">] === </span><span class="s1">'$'</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">constructor(defaults){</span>
        <span class="s2">if </span><span class="s0">(defaults &amp;&amp; </span><span class="s2">typeof </span><span class="s0">defaults.value !== </span><span class="s1">'undefined' </span><span class="s0">&amp;&amp; </span><span class="s2">typeof </span><span class="s0">defaults.value !== </span><span class="s1">'string'</span><span class="s0">) {</span>
            <span class="s0">defaults = {</span>
                <span class="s0">...defaults,</span>
                <span class="s0">value: String(defaults.value)</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s2">super</span><span class="s0">(defaults);</span>
        <span class="s2">this</span><span class="s0">.type = </span><span class="s1">'decl'</span><span class="s0">;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">module.exports = Declaration;</span>
<span class="s0">Declaration.default = Declaration;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/container.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">let </span><span class="s0">Comment = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/comment.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Declaration = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/declaration.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Node = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/node.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">{ isClean, my } = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/symbols.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">AtRule, parse, Root, Rule;</span>
<span class="s2">function </span><span class="s0">cleanSource(nodes) {</span>
    <span class="s2">return </span><span class="s0">nodes.map((i)=&gt;{</span>
        <span class="s2">if </span><span class="s0">(i.nodes) i.nodes = cleanSource(i.nodes);</span>
        <span class="s2">delete </span><span class="s0">i.source;</span>
        <span class="s2">return </span><span class="s0">i;</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s2">function </span><span class="s0">markTreeDirty(node) {</span>
    <span class="s0">node[isClean] = </span><span class="s2">false</span><span class="s0">;</span>
    <span class="s2">if </span><span class="s0">(node.proxyOf.nodes) {</span>
        <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">i of node.proxyOf.nodes){</span>
            <span class="s0">markTreeDirty(i);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s2">class </span><span class="s0">Container </span><span class="s2">extends </span><span class="s0">Node {</span>
    <span class="s0">get first() {</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.proxyOf.nodes) </span><span class="s2">return </span><span class="s0">undefined;</span>
        <span class="s2">return this</span><span class="s0">.proxyOf.nodes[</span><span class="s3">0</span><span class="s0">];</span>
    <span class="s0">}</span>
    <span class="s0">get last() {</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.proxyOf.nodes) </span><span class="s2">return </span><span class="s0">undefined;</span>
        <span class="s2">return this</span><span class="s0">.proxyOf.nodes[</span><span class="s2">this</span><span class="s0">.proxyOf.nodes.length - </span><span class="s3">1</span><span class="s0">];</span>
    <span class="s0">}</span>
    <span class="s0">append(...children) {</span>
        <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">child of children){</span>
            <span class="s2">let </span><span class="s0">nodes = </span><span class="s2">this</span><span class="s0">.normalize(child, </span><span class="s2">this</span><span class="s0">.last);</span>
            <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">node of nodes)</span><span class="s2">this</span><span class="s0">.proxyOf.nodes.push(node);</span>
        <span class="s0">}</span>
        <span class="s2">this</span><span class="s0">.markDirty();</span>
        <span class="s2">return this</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">cleanRaws(keepBetween) {</span>
        <span class="s2">super</span><span class="s0">.cleanRaws(keepBetween);</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.nodes) {</span>
            <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">node of </span><span class="s2">this</span><span class="s0">.nodes)node.cleanRaws(keepBetween);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">each(callback) {</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.proxyOf.nodes) </span><span class="s2">return </span><span class="s0">undefined;</span>
        <span class="s2">let </span><span class="s0">iterator = </span><span class="s2">this</span><span class="s0">.getIterator();</span>
        <span class="s2">let </span><span class="s0">index, result;</span>
        <span class="s2">while</span><span class="s0">(</span><span class="s2">this</span><span class="s0">.indexes[iterator] &lt; </span><span class="s2">this</span><span class="s0">.proxyOf.nodes.length){</span>
            <span class="s0">index = </span><span class="s2">this</span><span class="s0">.indexes[iterator];</span>
            <span class="s0">result = callback(</span><span class="s2">this</span><span class="s0">.proxyOf.nodes[index], index);</span>
            <span class="s2">if </span><span class="s0">(result === </span><span class="s2">false</span><span class="s0">) </span><span class="s2">break</span><span class="s0">;</span>
            <span class="s2">this</span><span class="s0">.indexes[iterator] += </span><span class="s3">1</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s2">delete this</span><span class="s0">.indexes[iterator];</span>
        <span class="s2">return </span><span class="s0">result;</span>
    <span class="s0">}</span>
    <span class="s0">every(condition) {</span>
        <span class="s2">return this</span><span class="s0">.nodes.every(condition);</span>
    <span class="s0">}</span>
    <span class="s0">getIterator() {</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.lastEach) </span><span class="s2">this</span><span class="s0">.lastEach = </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.indexes) </span><span class="s2">this</span><span class="s0">.indexes = {};</span>
        <span class="s2">this</span><span class="s0">.lastEach += </span><span class="s3">1</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">iterator = </span><span class="s2">this</span><span class="s0">.lastEach;</span>
        <span class="s2">this</span><span class="s0">.indexes[iterator] = </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s2">return </span><span class="s0">iterator;</span>
    <span class="s0">}</span>
    <span class="s0">getProxyProcessor() {</span>
        <span class="s2">return </span><span class="s0">{</span>
            <span class="s0">get (node, prop) {</span>
                <span class="s2">if </span><span class="s0">(prop === </span><span class="s1">'proxyOf'</span><span class="s0">) {</span>
                    <span class="s2">return </span><span class="s0">node;</span>
                <span class="s0">} </span><span class="s2">else if </span><span class="s0">(!node[prop]) {</span>
                    <span class="s2">return </span><span class="s0">node[prop];</span>
                <span class="s0">} </span><span class="s2">else if </span><span class="s0">(prop === </span><span class="s1">'each' </span><span class="s0">|| </span><span class="s2">typeof </span><span class="s0">prop === </span><span class="s1">'string' </span><span class="s0">&amp;&amp; prop.startsWith(</span><span class="s1">'walk'</span><span class="s0">)) {</span>
                    <span class="s2">return </span><span class="s0">(...args)=&gt;{</span>
                        <span class="s2">return </span><span class="s0">node[prop](...args.map((i)=&gt;{</span>
                            <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">i === </span><span class="s1">'function'</span><span class="s0">) {</span>
                                <span class="s2">return </span><span class="s0">(child, index)=&gt;i(child.toProxy(), index);</span>
                            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                                <span class="s2">return </span><span class="s0">i;</span>
                            <span class="s0">}</span>
                        <span class="s0">}));</span>
                    <span class="s0">};</span>
                <span class="s0">} </span><span class="s2">else if </span><span class="s0">(prop === </span><span class="s1">'every' </span><span class="s0">|| prop === </span><span class="s1">'some'</span><span class="s0">) {</span>
                    <span class="s2">return </span><span class="s0">(cb)=&gt;{</span>
                        <span class="s2">return </span><span class="s0">node[prop]((child, ...other)=&gt;cb(child.toProxy(), ...other));</span>
                    <span class="s0">};</span>
                <span class="s0">} </span><span class="s2">else if </span><span class="s0">(prop === </span><span class="s1">'root'</span><span class="s0">) {</span>
                    <span class="s2">return </span><span class="s0">()=&gt;node.root().toProxy();</span>
                <span class="s0">} </span><span class="s2">else if </span><span class="s0">(prop === </span><span class="s1">'nodes'</span><span class="s0">) {</span>
                    <span class="s2">return </span><span class="s0">node.nodes.map((i)=&gt;i.toProxy());</span>
                <span class="s0">} </span><span class="s2">else if </span><span class="s0">(prop === </span><span class="s1">'first' </span><span class="s0">|| prop === </span><span class="s1">'last'</span><span class="s0">) {</span>
                    <span class="s2">return </span><span class="s0">node[prop].toProxy();</span>
                <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                    <span class="s2">return </span><span class="s0">node[prop];</span>
                <span class="s0">}</span>
            <span class="s0">},</span>
            <span class="s0">set (node, prop, value) {</span>
                <span class="s2">if </span><span class="s0">(node[prop] === value) </span><span class="s2">return true</span><span class="s0">;</span>
                <span class="s0">node[prop] = value;</span>
                <span class="s2">if </span><span class="s0">(prop === </span><span class="s1">'name' </span><span class="s0">|| prop === </span><span class="s1">'params' </span><span class="s0">|| prop === </span><span class="s1">'selector'</span><span class="s0">) {</span>
                    <span class="s0">node.markDirty();</span>
                <span class="s0">}</span>
                <span class="s2">return true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s0">index(child) {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">child === </span><span class="s1">'number'</span><span class="s0">) </span><span class="s2">return </span><span class="s0">child;</span>
        <span class="s2">if </span><span class="s0">(child.proxyOf) child = child.proxyOf;</span>
        <span class="s2">return this</span><span class="s0">.proxyOf.nodes.indexOf(child);</span>
    <span class="s0">}</span>
    <span class="s0">insertAfter(exist, add) {</span>
        <span class="s2">let </span><span class="s0">existIndex = </span><span class="s2">this</span><span class="s0">.index(exist);</span>
        <span class="s2">let </span><span class="s0">nodes = </span><span class="s2">this</span><span class="s0">.normalize(add, </span><span class="s2">this</span><span class="s0">.proxyOf.nodes[existIndex]).reverse();</span>
        <span class="s0">existIndex = </span><span class="s2">this</span><span class="s0">.index(exist);</span>
        <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">node of nodes)</span><span class="s2">this</span><span class="s0">.proxyOf.nodes.splice(existIndex + </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, node);</span>
        <span class="s2">let </span><span class="s0">index;</span>
        <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">id </span><span class="s2">in this</span><span class="s0">.indexes){</span>
            <span class="s0">index = </span><span class="s2">this</span><span class="s0">.indexes[id];</span>
            <span class="s2">if </span><span class="s0">(existIndex &lt; index) {</span>
                <span class="s2">this</span><span class="s0">.indexes[id] = index + nodes.length;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">this</span><span class="s0">.markDirty();</span>
        <span class="s2">return this</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">insertBefore(exist, add) {</span>
        <span class="s2">let </span><span class="s0">existIndex = </span><span class="s2">this</span><span class="s0">.index(exist);</span>
        <span class="s2">let </span><span class="s0">type = existIndex === </span><span class="s3">0 </span><span class="s0">? </span><span class="s1">'prepend' </span><span class="s0">: </span><span class="s2">false</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">nodes = </span><span class="s2">this</span><span class="s0">.normalize(add, </span><span class="s2">this</span><span class="s0">.proxyOf.nodes[existIndex], type).reverse();</span>
        <span class="s0">existIndex = </span><span class="s2">this</span><span class="s0">.index(exist);</span>
        <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">node of nodes)</span><span class="s2">this</span><span class="s0">.proxyOf.nodes.splice(existIndex, </span><span class="s3">0</span><span class="s0">, node);</span>
        <span class="s2">let </span><span class="s0">index;</span>
        <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">id </span><span class="s2">in this</span><span class="s0">.indexes){</span>
            <span class="s0">index = </span><span class="s2">this</span><span class="s0">.indexes[id];</span>
            <span class="s2">if </span><span class="s0">(existIndex &lt;= index) {</span>
                <span class="s2">this</span><span class="s0">.indexes[id] = index + nodes.length;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">this</span><span class="s0">.markDirty();</span>
        <span class="s2">return this</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">normalize(nodes, sample) {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">nodes === </span><span class="s1">'string'</span><span class="s0">) {</span>
            <span class="s0">nodes = cleanSource(parse(nodes).nodes);</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">nodes === </span><span class="s1">'undefined'</span><span class="s0">) {</span>
            <span class="s0">nodes = [];</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(Array.isArray(nodes)) {</span>
            <span class="s0">nodes = nodes.slice(</span><span class="s3">0</span><span class="s0">);</span>
            <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">i of nodes){</span>
                <span class="s2">if </span><span class="s0">(i.parent) i.parent.removeChild(i, </span><span class="s1">'ignore'</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(nodes.type === </span><span class="s1">'root' </span><span class="s0">&amp;&amp; </span><span class="s2">this</span><span class="s0">.type !== </span><span class="s1">'document'</span><span class="s0">) {</span>
            <span class="s0">nodes = nodes.nodes.slice(</span><span class="s3">0</span><span class="s0">);</span>
            <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">i of nodes){</span>
                <span class="s2">if </span><span class="s0">(i.parent) i.parent.removeChild(i, </span><span class="s1">'ignore'</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(nodes.type) {</span>
            <span class="s0">nodes = [</span>
                <span class="s0">nodes</span>
            <span class="s0">];</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(nodes.prop) {</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">nodes.value === </span><span class="s1">'undefined'</span><span class="s0">) {</span>
                <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">'Value field is missed in node creation'</span><span class="s0">);</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">nodes.value !== </span><span class="s1">'string'</span><span class="s0">) {</span>
                <span class="s0">nodes.value = String(nodes.value);</span>
            <span class="s0">}</span>
            <span class="s0">nodes = [</span>
                <span class="s2">new </span><span class="s0">Declaration(nodes)</span>
            <span class="s0">];</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(nodes.selector || nodes.selectors) {</span>
            <span class="s0">nodes = [</span>
                <span class="s2">new </span><span class="s0">Rule(nodes)</span>
            <span class="s0">];</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(nodes.name) {</span>
            <span class="s0">nodes = [</span>
                <span class="s2">new </span><span class="s0">AtRule(nodes)</span>
            <span class="s0">];</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(nodes.text) {</span>
            <span class="s0">nodes = [</span>
                <span class="s2">new </span><span class="s0">Comment(nodes)</span>
            <span class="s0">];</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">'Unknown node type in node creation'</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s2">let </span><span class="s0">processed = nodes.map((i)=&gt;{</span>
            <span class="s6">/* c8 ignore next */ </span><span class="s2">if </span><span class="s0">(!i[my]) Container.rebuild(i);</span>
            <span class="s0">i = i.proxyOf;</span>
            <span class="s2">if </span><span class="s0">(i.parent) i.parent.removeChild(i);</span>
            <span class="s2">if </span><span class="s0">(i[isClean]) markTreeDirty(i);</span>
            <span class="s2">if </span><span class="s0">(!i.raws) i.raws = {};</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">i.raws.before === </span><span class="s1">'undefined'</span><span class="s0">) {</span>
                <span class="s2">if </span><span class="s0">(sample &amp;&amp; </span><span class="s2">typeof </span><span class="s0">sample.raws.before !== </span><span class="s1">'undefined'</span><span class="s0">) {</span>
                    <span class="s0">i.raws.before = sample.raws.before.replace(</span><span class="s5">/\S/g</span><span class="s0">, </span><span class="s1">''</span><span class="s0">);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">i.parent = </span><span class="s2">this</span><span class="s0">.proxyOf;</span>
            <span class="s2">return </span><span class="s0">i;</span>
        <span class="s0">});</span>
        <span class="s2">return </span><span class="s0">processed;</span>
    <span class="s0">}</span>
    <span class="s0">prepend(...children) {</span>
        <span class="s0">children = children.reverse();</span>
        <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">child of children){</span>
            <span class="s2">let </span><span class="s0">nodes = </span><span class="s2">this</span><span class="s0">.normalize(child, </span><span class="s2">this</span><span class="s0">.first, </span><span class="s1">'prepend'</span><span class="s0">).reverse();</span>
            <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">node of nodes)</span><span class="s2">this</span><span class="s0">.proxyOf.nodes.unshift(node);</span>
            <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">id </span><span class="s2">in this</span><span class="s0">.indexes){</span>
                <span class="s2">this</span><span class="s0">.indexes[id] = </span><span class="s2">this</span><span class="s0">.indexes[id] + nodes.length;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">this</span><span class="s0">.markDirty();</span>
        <span class="s2">return this</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">push(child) {</span>
        <span class="s0">child.parent = </span><span class="s2">this</span><span class="s0">;</span>
        <span class="s2">this</span><span class="s0">.proxyOf.nodes.push(child);</span>
        <span class="s2">return this</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">removeAll() {</span>
        <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">node of </span><span class="s2">this</span><span class="s0">.proxyOf.nodes)node.parent = undefined;</span>
        <span class="s2">this</span><span class="s0">.proxyOf.nodes = [];</span>
        <span class="s2">this</span><span class="s0">.markDirty();</span>
        <span class="s2">return this</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">removeChild(child) {</span>
        <span class="s0">child = </span><span class="s2">this</span><span class="s0">.index(child);</span>
        <span class="s2">this</span><span class="s0">.proxyOf.nodes[child].parent = undefined;</span>
        <span class="s2">this</span><span class="s0">.proxyOf.nodes.splice(child, </span><span class="s3">1</span><span class="s0">);</span>
        <span class="s2">let </span><span class="s0">index;</span>
        <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">id </span><span class="s2">in this</span><span class="s0">.indexes){</span>
            <span class="s0">index = </span><span class="s2">this</span><span class="s0">.indexes[id];</span>
            <span class="s2">if </span><span class="s0">(index &gt;= child) {</span>
                <span class="s2">this</span><span class="s0">.indexes[id] = index - </span><span class="s3">1</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">this</span><span class="s0">.markDirty();</span>
        <span class="s2">return this</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">replaceValues(pattern, opts, callback) {</span>
        <span class="s2">if </span><span class="s0">(!callback) {</span>
            <span class="s0">callback = opts;</span>
            <span class="s0">opts = {};</span>
        <span class="s0">}</span>
        <span class="s2">this</span><span class="s0">.walkDecls((decl)=&gt;{</span>
            <span class="s2">if </span><span class="s0">(opts.props &amp;&amp; !opts.props.includes(decl.prop)) </span><span class="s2">return</span><span class="s0">;</span>
            <span class="s2">if </span><span class="s0">(opts.fast &amp;&amp; !decl.value.includes(opts.fast)) </span><span class="s2">return</span><span class="s0">;</span>
            <span class="s0">decl.value = decl.value.replace(pattern, callback);</span>
        <span class="s0">});</span>
        <span class="s2">this</span><span class="s0">.markDirty();</span>
        <span class="s2">return this</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">some(condition) {</span>
        <span class="s2">return this</span><span class="s0">.nodes.some(condition);</span>
    <span class="s0">}</span>
    <span class="s0">walk(callback) {</span>
        <span class="s2">return this</span><span class="s0">.each((child, i)=&gt;{</span>
            <span class="s2">let </span><span class="s0">result;</span>
            <span class="s2">try </span><span class="s0">{</span>
                <span class="s0">result = callback(child, i);</span>
            <span class="s0">} </span><span class="s2">catch </span><span class="s0">(e) {</span>
                <span class="s2">throw </span><span class="s0">child.addToError(e);</span>
            <span class="s0">}</span>
            <span class="s2">if </span><span class="s0">(result !== </span><span class="s2">false </span><span class="s0">&amp;&amp; child.walk) {</span>
                <span class="s0">result = child.walk(callback);</span>
            <span class="s0">}</span>
            <span class="s2">return </span><span class="s0">result;</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s0">walkAtRules(name, callback) {</span>
        <span class="s2">if </span><span class="s0">(!callback) {</span>
            <span class="s0">callback = name;</span>
            <span class="s2">return this</span><span class="s0">.walk((child, i)=&gt;{</span>
                <span class="s2">if </span><span class="s0">(child.type === </span><span class="s1">'atrule'</span><span class="s0">) {</span>
                    <span class="s2">return </span><span class="s0">callback(child, i);</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(name </span><span class="s2">instanceof </span><span class="s0">RegExp) {</span>
            <span class="s2">return this</span><span class="s0">.walk((child, i)=&gt;{</span>
                <span class="s2">if </span><span class="s0">(child.type === </span><span class="s1">'atrule' </span><span class="s0">&amp;&amp; name.test(child.name)) {</span>
                    <span class="s2">return </span><span class="s0">callback(child, i);</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s2">return this</span><span class="s0">.walk((child, i)=&gt;{</span>
            <span class="s2">if </span><span class="s0">(child.type === </span><span class="s1">'atrule' </span><span class="s0">&amp;&amp; child.name === name) {</span>
                <span class="s2">return </span><span class="s0">callback(child, i);</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s0">walkComments(callback) {</span>
        <span class="s2">return this</span><span class="s0">.walk((child, i)=&gt;{</span>
            <span class="s2">if </span><span class="s0">(child.type === </span><span class="s1">'comment'</span><span class="s0">) {</span>
                <span class="s2">return </span><span class="s0">callback(child, i);</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s0">walkDecls(prop, callback) {</span>
        <span class="s2">if </span><span class="s0">(!callback) {</span>
            <span class="s0">callback = prop;</span>
            <span class="s2">return this</span><span class="s0">.walk((child, i)=&gt;{</span>
                <span class="s2">if </span><span class="s0">(child.type === </span><span class="s1">'decl'</span><span class="s0">) {</span>
                    <span class="s2">return </span><span class="s0">callback(child, i);</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(prop </span><span class="s2">instanceof </span><span class="s0">RegExp) {</span>
            <span class="s2">return this</span><span class="s0">.walk((child, i)=&gt;{</span>
                <span class="s2">if </span><span class="s0">(child.type === </span><span class="s1">'decl' </span><span class="s0">&amp;&amp; prop.test(child.prop)) {</span>
                    <span class="s2">return </span><span class="s0">callback(child, i);</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s2">return this</span><span class="s0">.walk((child, i)=&gt;{</span>
            <span class="s2">if </span><span class="s0">(child.type === </span><span class="s1">'decl' </span><span class="s0">&amp;&amp; child.prop === prop) {</span>
                <span class="s2">return </span><span class="s0">callback(child, i);</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s0">walkRules(selector, callback) {</span>
        <span class="s2">if </span><span class="s0">(!callback) {</span>
            <span class="s0">callback = selector;</span>
            <span class="s2">return this</span><span class="s0">.walk((child, i)=&gt;{</span>
                <span class="s2">if </span><span class="s0">(child.type === </span><span class="s1">'rule'</span><span class="s0">) {</span>
                    <span class="s2">return </span><span class="s0">callback(child, i);</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(selector </span><span class="s2">instanceof </span><span class="s0">RegExp) {</span>
            <span class="s2">return this</span><span class="s0">.walk((child, i)=&gt;{</span>
                <span class="s2">if </span><span class="s0">(child.type === </span><span class="s1">'rule' </span><span class="s0">&amp;&amp; selector.test(child.selector)) {</span>
                    <span class="s2">return </span><span class="s0">callback(child, i);</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s2">return this</span><span class="s0">.walk((child, i)=&gt;{</span>
            <span class="s2">if </span><span class="s0">(child.type === </span><span class="s1">'rule' </span><span class="s0">&amp;&amp; child.selector === selector) {</span>
                <span class="s2">return </span><span class="s0">callback(child, i);</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">Container.registerParse = (dependant)=&gt;{</span>
    <span class="s0">parse = dependant;</span>
<span class="s0">};</span>
<span class="s0">Container.registerRule = (dependant)=&gt;{</span>
    <span class="s0">Rule = dependant;</span>
<span class="s0">};</span>
<span class="s0">Container.registerAtRule = (dependant)=&gt;{</span>
    <span class="s0">AtRule = dependant;</span>
<span class="s0">};</span>
<span class="s0">Container.registerRoot = (dependant)=&gt;{</span>
    <span class="s0">Root = dependant;</span>
<span class="s0">};</span>
<span class="s0">module.exports = Container;</span>
<span class="s0">Container.default = Container;</span>
<span class="s6">/* c8 ignore start */ </span><span class="s0">Container.rebuild = (node)=&gt;{</span>
    <span class="s2">if </span><span class="s0">(node.type === </span><span class="s1">'atrule'</span><span class="s0">) {</span>
        <span class="s0">Object.setPrototypeOf(node, AtRule.prototype);</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(node.type === </span><span class="s1">'rule'</span><span class="s0">) {</span>
        <span class="s0">Object.setPrototypeOf(node, Rule.prototype);</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(node.type === </span><span class="s1">'decl'</span><span class="s0">) {</span>
        <span class="s0">Object.setPrototypeOf(node, Declaration.prototype);</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(node.type === </span><span class="s1">'comment'</span><span class="s0">) {</span>
        <span class="s0">Object.setPrototypeOf(node, Comment.prototype);</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(node.type === </span><span class="s1">'root'</span><span class="s0">) {</span>
        <span class="s0">Object.setPrototypeOf(node, Root.prototype);</span>
    <span class="s0">}</span>
    <span class="s0">node[my] = </span><span class="s2">true</span><span class="s0">;</span>
    <span class="s2">if </span><span class="s0">(node.nodes) {</span>
        <span class="s0">node.nodes.forEach((child)=&gt;{</span>
            <span class="s0">Container.rebuild(child);</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
<span class="s0">}; </span><span class="s6">/* c8 ignore stop */ </span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/at-rule.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">let </span><span class="s0">Container = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/container.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">class </span><span class="s0">AtRule </span><span class="s2">extends </span><span class="s0">Container {</span>
    <span class="s0">constructor(defaults){</span>
        <span class="s2">super</span><span class="s0">(defaults);</span>
        <span class="s2">this</span><span class="s0">.type = </span><span class="s1">'atrule'</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">append(...children) {</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.proxyOf.nodes) </span><span class="s2">this</span><span class="s0">.nodes = [];</span>
        <span class="s2">return super</span><span class="s0">.append(...children);</span>
    <span class="s0">}</span>
    <span class="s0">prepend(...children) {</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.proxyOf.nodes) </span><span class="s2">this</span><span class="s0">.nodes = [];</span>
        <span class="s2">return super</span><span class="s0">.prepend(...children);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">module.exports = AtRule;</span>
<span class="s0">AtRule.default = AtRule;</span>
<span class="s0">Container.registerAtRule(AtRule);</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/document.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">let </span><span class="s0">Container = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/container.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">LazyResult, Processor;</span>
<span class="s2">class </span><span class="s0">Document </span><span class="s2">extends </span><span class="s0">Container {</span>
    <span class="s0">constructor(defaults){</span>
        <span class="s6">// type needs to be passed to super, otherwise child roots won't be normalized correctly</span>
        <span class="s2">super</span><span class="s0">({</span>
            <span class="s0">type: </span><span class="s1">'document'</span><span class="s0">,</span>
            <span class="s0">...defaults</span>
        <span class="s0">});</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.nodes) {</span>
            <span class="s2">this</span><span class="s0">.nodes = [];</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">toResult(opts = {}) {</span>
        <span class="s2">let </span><span class="s0">lazy = </span><span class="s2">new </span><span class="s0">LazyResult(</span><span class="s2">new </span><span class="s0">Processor(), </span><span class="s2">this</span><span class="s0">, opts);</span>
        <span class="s2">return </span><span class="s0">lazy.stringify();</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">Document.registerLazyResult = (dependant)=&gt;{</span>
    <span class="s0">LazyResult = dependant;</span>
<span class="s0">};</span>
<span class="s0">Document.registerProcessor = (dependant)=&gt;{</span>
    <span class="s0">Processor = dependant;</span>
<span class="s0">};</span>
<span class="s0">module.exports = Document;</span>
<span class="s0">Document.default = Document;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/nanoid/non-secure/index.cjs [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>

<span class="s6">// This alphabet uses `A-Za-z0-9_-` symbols.</span>
<span class="s6">// The order of characters is optimized for better gzip and brotli compression.</span>
<span class="s6">// References to the same file (works both for gzip and brotli):</span>
<span class="s6">// `'use`, `andom`, and `rict'`</span>
<span class="s6">// References to the brotli default dictionary:</span>
<span class="s6">// `-26T`, `1983`, `40px`, `75px`, `bush`, `jack`, `mind`, `very`, and `wolf`</span>
<span class="s2">let </span><span class="s0">urlAlphabet = </span><span class="s1">'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'</span><span class="s0">;</span>
<span class="s2">let </span><span class="s0">customAlphabet = (alphabet, defaultSize = </span><span class="s3">21</span><span class="s0">)=&gt;{</span>
    <span class="s2">return </span><span class="s0">(size = defaultSize)=&gt;{</span>
        <span class="s2">let </span><span class="s0">id = </span><span class="s1">''</span><span class="s0">;</span>
        <span class="s6">// A compact alternative for `for (var i = 0; i &lt; step; i++)`.</span>
        <span class="s2">let </span><span class="s0">i = size | </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s2">while</span><span class="s0">(i--){</span>
            <span class="s6">// `| 0` is more compact and faster than `Math.floor()`.</span>
            <span class="s0">id += alphabet[Math.random() * alphabet.length | </span><span class="s3">0</span><span class="s0">];</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">id;</span>
    <span class="s0">};</span>
<span class="s0">};</span>
<span class="s2">let </span><span class="s0">nanoid = (size = </span><span class="s3">21</span><span class="s0">)=&gt;{</span>
    <span class="s2">let </span><span class="s0">id = </span><span class="s1">''</span><span class="s0">;</span>
    <span class="s6">// A compact alternative for `for (var i = 0; i &lt; step; i++)`.</span>
    <span class="s2">let </span><span class="s0">i = size | </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">while</span><span class="s0">(i--){</span>
        <span class="s6">// `| 0` is more compact and faster than `Math.floor()`.</span>
        <span class="s0">id += urlAlphabet[Math.random() * </span><span class="s3">64 </span><span class="s0">| </span><span class="s3">0</span><span class="s0">];</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">id;</span>
<span class="s0">};</span>
<span class="s0">module.exports = {</span>
    <span class="s0">nanoid,</span>
    <span class="s0">customAlphabet</span>
<span class="s0">};</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/source-map-js/lib/base64.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>

<span class="s6">/* -*- Mode: js; js-indent-level: 2; -*- */ /* 
 * Copyright 2011 Mozilla Foundation and contributors 
 * Licensed under the New BSD license. See LICENSE or: 
 * http://opensource.org/licenses/BSD-3-Clause 
 */ </span><span class="s2">var </span><span class="s0">intToCharMap = </span><span class="s1">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span><span class="s0">.split(</span><span class="s1">''</span><span class="s0">);</span>
<span class="s6">/**</span>
 <span class="s6">* Encode an integer in the range of 0 to 63 to a single base 64 digit.</span>
 <span class="s6">*/ </span><span class="s0">exports.encode = </span><span class="s2">function</span><span class="s0">(number) {</span>
    <span class="s2">if </span><span class="s0">(</span><span class="s3">0 </span><span class="s0">&lt;= number &amp;&amp; number &lt; intToCharMap.length) {</span>
        <span class="s2">return </span><span class="s0">intToCharMap[number];</span>
    <span class="s0">}</span>
    <span class="s2">throw new </span><span class="s0">TypeError(</span><span class="s1">&quot;Must be between 0 and 63: &quot; </span><span class="s0">+ number);</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Decode a single base 64 character code digit to an integer. Returns -1 on</span>
 <span class="s6">* failure.</span>
 <span class="s6">*/ </span><span class="s0">exports.decode = </span><span class="s2">function</span><span class="s0">(charCode) {</span>
    <span class="s2">var </span><span class="s0">bigA = </span><span class="s3">65</span><span class="s0">; </span><span class="s6">// 'A'</span>
    <span class="s2">var </span><span class="s0">bigZ = </span><span class="s3">90</span><span class="s0">; </span><span class="s6">// 'Z'</span>
    <span class="s2">var </span><span class="s0">littleA = </span><span class="s3">97</span><span class="s0">; </span><span class="s6">// 'a'</span>
    <span class="s2">var </span><span class="s0">littleZ = </span><span class="s3">122</span><span class="s0">; </span><span class="s6">// 'z'</span>
    <span class="s2">var </span><span class="s0">zero = </span><span class="s3">48</span><span class="s0">; </span><span class="s6">// '0'</span>
    <span class="s2">var </span><span class="s0">nine = </span><span class="s3">57</span><span class="s0">; </span><span class="s6">// '9'</span>
    <span class="s2">var </span><span class="s0">plus = </span><span class="s3">43</span><span class="s0">; </span><span class="s6">// '+'</span>
    <span class="s2">var </span><span class="s0">slash = </span><span class="s3">47</span><span class="s0">; </span><span class="s6">// '/'</span>
    <span class="s2">var </span><span class="s0">littleOffset = </span><span class="s3">26</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">numberOffset = </span><span class="s3">52</span><span class="s0">;</span>
    <span class="s6">// 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ</span>
    <span class="s2">if </span><span class="s0">(bigA &lt;= charCode &amp;&amp; charCode &lt;= bigZ) {</span>
        <span class="s2">return </span><span class="s0">charCode - bigA;</span>
    <span class="s0">}</span>
    <span class="s6">// 26 - 51: abcdefghijklmnopqrstuvwxyz</span>
    <span class="s2">if </span><span class="s0">(littleA &lt;= charCode &amp;&amp; charCode &lt;= littleZ) {</span>
        <span class="s2">return </span><span class="s0">charCode - littleA + littleOffset;</span>
    <span class="s0">}</span>
    <span class="s6">// 52 - 61: 0123456789</span>
    <span class="s2">if </span><span class="s0">(zero &lt;= charCode &amp;&amp; charCode &lt;= nine) {</span>
        <span class="s2">return </span><span class="s0">charCode - zero + numberOffset;</span>
    <span class="s0">}</span>
    <span class="s6">// 62: +</span>
    <span class="s2">if </span><span class="s0">(charCode == plus) {</span>
        <span class="s2">return </span><span class="s3">62</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s6">// 63: /</span>
    <span class="s2">if </span><span class="s0">(charCode == slash) {</span>
        <span class="s2">return </span><span class="s3">63</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s6">// Invalid base64 digit.</span>
    <span class="s2">return </span><span class="s0">-</span><span class="s3">1</span><span class="s0">;</span>
<span class="s0">};</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/source-map-js/lib/base64-vlq.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>

<span class="s6">/* -*- Mode: js; js-indent-level: 2; -*- */ /* 
 * Copyright 2011 Mozilla Foundation and contributors 
 * Licensed under the New BSD license. See LICENSE or: 
 * http://opensource.org/licenses/BSD-3-Clause 
 * 
 * Based on the Base 64 VLQ implementation in Closure Compiler: 
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java 
 * 
 * Copyright 2011 The Closure Compiler Authors. All rights reserved. 
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are 
 * met: 
 * 
 *  * Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 *  * Redistributions in binary form must reproduce the above 
 *    copyright notice, this list of conditions and the following 
 *    disclaimer in the documentation and/or other materials provided 
 *    with the distribution. 
 *  * Neither the name of Google Inc. nor the names of its 
 *    contributors may be used to endorse or promote products derived 
 *    from this software without specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */ </span><span class="s2">var </span><span class="s0">base64 = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/source-map-js/lib/base64.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s6">// A single base 64 digit can contain 6 bits of data. For the base 64 variable</span>
<span class="s6">// length quantities we use in the source map spec, the first bit is the sign,</span>
<span class="s6">// the next four bits are the actual value, and the 6th bit is the</span>
<span class="s6">// continuation bit. The continuation bit tells us whether there are more</span>
<span class="s6">// digits in this value following this digit.</span>
<span class="s6">//</span>
<span class="s6">//   Continuation</span>
<span class="s6">//   |    Sign</span>
<span class="s6">//   |    |</span>
<span class="s6">//   V    V</span>
<span class="s6">//   101011</span>
<span class="s2">var </span><span class="s0">VLQ_BASE_SHIFT = </span><span class="s3">5</span><span class="s0">;</span>
<span class="s6">// binary: 100000</span>
<span class="s2">var </span><span class="s0">VLQ_BASE = </span><span class="s3">1 </span><span class="s0">&lt;&lt; VLQ_BASE_SHIFT;</span>
<span class="s6">// binary: 011111</span>
<span class="s2">var </span><span class="s0">VLQ_BASE_MASK = VLQ_BASE - </span><span class="s3">1</span><span class="s0">;</span>
<span class="s6">// binary: 100000</span>
<span class="s2">var </span><span class="s0">VLQ_CONTINUATION_BIT = VLQ_BASE;</span>
<span class="s6">/**</span>
 <span class="s6">* Converts from a two-complement value to a value where the sign bit is</span>
 <span class="s6">* placed in the least significant bit.  For example, as decimals:</span>
 <span class="s6">*   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)</span>
 <span class="s6">*   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)</span>
 <span class="s6">*/ </span><span class="s2">function </span><span class="s0">toVLQSigned(aValue) {</span>
    <span class="s2">return </span><span class="s0">aValue &lt; </span><span class="s3">0 </span><span class="s0">? (-aValue &lt;&lt; </span><span class="s3">1</span><span class="s0">) + </span><span class="s3">1 </span><span class="s0">: (aValue &lt;&lt; </span><span class="s3">1</span><span class="s0">) + </span><span class="s3">0</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s6">/**</span>
 <span class="s6">* Converts to a two-complement value from a value where the sign bit is</span>
 <span class="s6">* placed in the least significant bit.  For example, as decimals:</span>
 <span class="s6">*   2 (10 binary) becomes 1, 3 (11 binary) becomes -1</span>
 <span class="s6">*   4 (100 binary) becomes 2, 5 (101 binary) becomes -2</span>
 <span class="s6">*/ </span><span class="s2">function </span><span class="s0">fromVLQSigned(aValue) {</span>
    <span class="s2">var </span><span class="s0">isNegative = (aValue &amp; </span><span class="s3">1</span><span class="s0">) === </span><span class="s3">1</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">shifted = aValue &gt;&gt; </span><span class="s3">1</span><span class="s0">;</span>
    <span class="s2">return </span><span class="s0">isNegative ? -shifted : shifted;</span>
<span class="s0">}</span>
<span class="s6">/**</span>
 <span class="s6">* Returns the base 64 VLQ encoded value.</span>
 <span class="s6">*/ </span><span class="s0">exports.encode = </span><span class="s2">function </span><span class="s0">base64VLQ_encode(aValue) {</span>
    <span class="s2">var </span><span class="s0">encoded = </span><span class="s1">&quot;&quot;</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">digit;</span>
    <span class="s2">var </span><span class="s0">vlq = toVLQSigned(aValue);</span>
    <span class="s2">do </span><span class="s0">{</span>
        <span class="s0">digit = vlq &amp; VLQ_BASE_MASK;</span>
        <span class="s0">vlq &gt;&gt;&gt;= VLQ_BASE_SHIFT;</span>
        <span class="s2">if </span><span class="s0">(vlq &gt; </span><span class="s3">0</span><span class="s0">) {</span>
            <span class="s6">// There are still more digits in this value, so we must make sure the</span>
            <span class="s6">// continuation bit is marked.</span>
            <span class="s0">digit |= VLQ_CONTINUATION_BIT;</span>
        <span class="s0">}</span>
        <span class="s0">encoded += base64.encode(digit);</span>
    <span class="s0">}</span><span class="s2">while </span><span class="s0">(vlq &gt; </span><span class="s3">0</span><span class="s0">)</span>
    <span class="s2">return </span><span class="s0">encoded;</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Decodes the next base 64 VLQ value from the given string and returns the</span>
 <span class="s6">* value and the rest of the string via the out parameter.</span>
 <span class="s6">*/ </span><span class="s0">exports.decode = </span><span class="s2">function </span><span class="s0">base64VLQ_decode(aStr, aIndex, aOutParam) {</span>
    <span class="s2">var </span><span class="s0">strLen = aStr.length;</span>
    <span class="s2">var </span><span class="s0">result = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">shift = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">continuation, digit;</span>
    <span class="s2">do </span><span class="s0">{</span>
        <span class="s2">if </span><span class="s0">(aIndex &gt;= strLen) {</span>
            <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">&quot;Expected more digits in base 64 VLQ value.&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">digit = base64.decode(aStr.charCodeAt(aIndex++));</span>
        <span class="s2">if </span><span class="s0">(digit === -</span><span class="s3">1</span><span class="s0">) {</span>
            <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">&quot;Invalid base64 digit: &quot; </span><span class="s0">+ aStr.charAt(aIndex - </span><span class="s3">1</span><span class="s0">));</span>
        <span class="s0">}</span>
        <span class="s0">continuation = !!(digit &amp; VLQ_CONTINUATION_BIT);</span>
        <span class="s0">digit &amp;= VLQ_BASE_MASK;</span>
        <span class="s0">result = result + (digit &lt;&lt; shift);</span>
        <span class="s0">shift += VLQ_BASE_SHIFT;</span>
    <span class="s0">}</span><span class="s2">while </span><span class="s0">(continuation)</span>
    <span class="s0">aOutParam.value = fromVLQSigned(result);</span>
    <span class="s0">aOutParam.rest = aIndex;</span>
<span class="s0">};</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>

<span class="s6">/* -*- Mode: js; js-indent-level: 2; -*- */ /* 
 * Copyright 2011 Mozilla Foundation and contributors 
 * Licensed under the New BSD license. See LICENSE or: 
 * http://opensource.org/licenses/BSD-3-Clause 
 */ /**</span>
 <span class="s6">* This is a helper function for getting values from parameter/options</span>
 <span class="s6">* objects.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">args The object we are extracting values from</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">name The name of the property we are getting.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">defaultValue An optional value to return if the property is missing</span>
 <span class="s6">* from the object. If this is not specified and the property is missing, an</span>
 <span class="s6">* error will be thrown.</span>
 <span class="s6">*/ </span><span class="s2">function </span><span class="s0">getArg(aArgs, aName, aDefaultValue) {</span>
    <span class="s2">if </span><span class="s0">(aName </span><span class="s2">in </span><span class="s0">aArgs) {</span>
        <span class="s2">return </span><span class="s0">aArgs[aName];</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(arguments.length === </span><span class="s3">3</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">aDefaultValue;</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">'&quot;' </span><span class="s0">+ aName + </span><span class="s1">'&quot; is a required argument.'</span><span class="s0">);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">exports.getArg = getArg;</span>
<span class="s2">var </span><span class="s0">urlRegexp = </span><span class="s5">/^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/</span><span class="s0">;</span>
<span class="s2">var </span><span class="s0">dataUrlRegexp = </span><span class="s5">/^data:.+\,.+$/</span><span class="s0">;</span>
<span class="s2">function </span><span class="s0">urlParse(aUrl) {</span>
    <span class="s2">var </span><span class="s0">match = aUrl.match(urlRegexp);</span>
    <span class="s2">if </span><span class="s0">(!match) {</span>
        <span class="s2">return null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">{</span>
        <span class="s0">scheme: match[</span><span class="s3">1</span><span class="s0">],</span>
        <span class="s0">auth: match[</span><span class="s3">2</span><span class="s0">],</span>
        <span class="s0">host: match[</span><span class="s3">3</span><span class="s0">],</span>
        <span class="s0">port: match[</span><span class="s3">4</span><span class="s0">],</span>
        <span class="s0">path: match[</span><span class="s3">5</span><span class="s0">]</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s0">exports.urlParse = urlParse;</span>
<span class="s2">function </span><span class="s0">urlGenerate(aParsedUrl) {</span>
    <span class="s2">var </span><span class="s0">url = </span><span class="s1">''</span><span class="s0">;</span>
    <span class="s2">if </span><span class="s0">(aParsedUrl.scheme) {</span>
        <span class="s0">url += aParsedUrl.scheme + </span><span class="s1">':'</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">url += </span><span class="s1">'//'</span><span class="s0">;</span>
    <span class="s2">if </span><span class="s0">(aParsedUrl.auth) {</span>
        <span class="s0">url += aParsedUrl.auth + </span><span class="s1">'@'</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(aParsedUrl.host) {</span>
        <span class="s0">url += aParsedUrl.host;</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(aParsedUrl.port) {</span>
        <span class="s0">url += </span><span class="s1">&quot;:&quot; </span><span class="s0">+ aParsedUrl.port;</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(aParsedUrl.path) {</span>
        <span class="s0">url += aParsedUrl.path;</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">url;</span>
<span class="s0">}</span>
<span class="s0">exports.urlGenerate = urlGenerate;</span>
<span class="s2">var </span><span class="s0">MAX_CACHED_INPUTS = </span><span class="s3">32</span><span class="s0">;</span>
<span class="s6">/**</span>
 <span class="s6">* Takes some function `f(input) -&gt; result` and returns a memoized version of</span>
 <span class="s6">* `f`.</span>
 <span class="s6">*</span>
 <span class="s6">* We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The</span>
 <span class="s6">* memoization is a dumb-simple, linear least-recently-used cache.</span>
 <span class="s6">*/ </span><span class="s2">function </span><span class="s0">lruMemoize(f) {</span>
    <span class="s2">var </span><span class="s0">cache = [];</span>
    <span class="s2">return function</span><span class="s0">(input) {</span>
        <span class="s2">for</span><span class="s0">(</span><span class="s2">var </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; cache.length; i++){</span>
            <span class="s2">if </span><span class="s0">(cache[i].input === input) {</span>
                <span class="s2">var </span><span class="s0">temp = cache[</span><span class="s3">0</span><span class="s0">];</span>
                <span class="s0">cache[</span><span class="s3">0</span><span class="s0">] = cache[i];</span>
                <span class="s0">cache[i] = temp;</span>
                <span class="s2">return </span><span class="s0">cache[</span><span class="s3">0</span><span class="s0">].result;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">var </span><span class="s0">result = f(input);</span>
        <span class="s0">cache.unshift({</span>
            <span class="s0">input,</span>
            <span class="s0">result</span>
        <span class="s0">});</span>
        <span class="s2">if </span><span class="s0">(cache.length &gt; MAX_CACHED_INPUTS) {</span>
            <span class="s0">cache.pop();</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">result;</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s6">/**</span>
 <span class="s6">* Normalizes a path, or the path portion of a URL:</span>
 <span class="s6">*</span>
 <span class="s6">* - Replaces consecutive slashes with one slash.</span>
 <span class="s6">* - Removes unnecessary '.' parts.</span>
 <span class="s6">* - Removes unnecessary '&lt;dir&gt;/..' parts.</span>
 <span class="s6">*</span>
 <span class="s6">* Based on code in the Node.js 'path' core module.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aPath The path or url to normalize.</span>
 <span class="s6">*/ </span><span class="s2">var </span><span class="s0">normalize = lruMemoize(</span><span class="s2">function </span><span class="s0">normalize(aPath) {</span>
    <span class="s2">var </span><span class="s0">path = aPath;</span>
    <span class="s2">var </span><span class="s0">url = urlParse(aPath);</span>
    <span class="s2">if </span><span class="s0">(url) {</span>
        <span class="s2">if </span><span class="s0">(!url.path) {</span>
            <span class="s2">return </span><span class="s0">aPath;</span>
        <span class="s0">}</span>
        <span class="s0">path = url.path;</span>
    <span class="s0">}</span>
    <span class="s2">var </span><span class="s0">isAbsolute = exports.isAbsolute(path);</span>
    <span class="s6">// Split the path into parts between `/` characters. This is much faster than</span>
    <span class="s6">// using `.split(/\/+/g)`.</span>
    <span class="s2">var </span><span class="s0">parts = [];</span>
    <span class="s2">var </span><span class="s0">start = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">while</span><span class="s0">(</span><span class="s2">true</span><span class="s0">){</span>
        <span class="s0">start = i;</span>
        <span class="s0">i = path.indexOf(</span><span class="s1">&quot;/&quot;</span><span class="s0">, start);</span>
        <span class="s2">if </span><span class="s0">(i === -</span><span class="s3">1</span><span class="s0">) {</span>
            <span class="s0">parts.push(path.slice(start));</span>
            <span class="s2">break</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s0">parts.push(path.slice(start, i));</span>
            <span class="s2">while</span><span class="s0">(i &lt; path.length &amp;&amp; path[i] === </span><span class="s1">&quot;/&quot;</span><span class="s0">){</span>
                <span class="s0">i++;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s2">for</span><span class="s0">(</span><span class="s2">var </span><span class="s0">part, up = </span><span class="s3">0</span><span class="s0">, i = parts.length - </span><span class="s3">1</span><span class="s0">; i &gt;= </span><span class="s3">0</span><span class="s0">; i--){</span>
        <span class="s0">part = parts[i];</span>
        <span class="s2">if </span><span class="s0">(part === </span><span class="s1">'.'</span><span class="s0">) {</span>
            <span class="s0">parts.splice(i, </span><span class="s3">1</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(part === </span><span class="s1">'..'</span><span class="s0">) {</span>
            <span class="s0">up++;</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(up &gt; </span><span class="s3">0</span><span class="s0">) {</span>
            <span class="s2">if </span><span class="s0">(part === </span><span class="s1">''</span><span class="s0">) {</span>
                <span class="s6">// The first part is blank if the path is absolute. Trying to go</span>
                <span class="s6">// above the root is a no-op. Therefore we can remove all '..' parts</span>
                <span class="s6">// directly after the root.</span>
                <span class="s0">parts.splice(i + </span><span class="s3">1</span><span class="s0">, up);</span>
                <span class="s0">up = </span><span class="s3">0</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                <span class="s0">parts.splice(i, </span><span class="s3">2</span><span class="s0">);</span>
                <span class="s0">up--;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">path = parts.join(</span><span class="s1">'/'</span><span class="s0">);</span>
    <span class="s2">if </span><span class="s0">(path === </span><span class="s1">''</span><span class="s0">) {</span>
        <span class="s0">path = isAbsolute ? </span><span class="s1">'/' </span><span class="s0">: </span><span class="s1">'.'</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(url) {</span>
        <span class="s0">url.path = path;</span>
        <span class="s2">return </span><span class="s0">urlGenerate(url);</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">path;</span>
<span class="s0">});</span>
<span class="s0">exports.normalize = normalize;</span>
<span class="s6">/**</span>
 <span class="s6">* Joins two paths/URLs.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aRoot The root path or URL.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aPath The path or URL to be joined with the root.</span>
 <span class="s6">*</span>
 <span class="s6">* - If aPath is a URL or a data URI, aPath is returned, unless aPath is a</span>
 <span class="s6">*   scheme-relative URL: Then the scheme of aRoot, if any, is prepended</span>
 <span class="s6">*   first.</span>
 <span class="s6">* - Otherwise aPath is a path. If aRoot is a URL, then its path portion</span>
 <span class="s6">*   is updated with the result and aRoot is returned. Otherwise the result</span>
 <span class="s6">*   is returned.</span>
 <span class="s6">*   - If aPath is absolute, the result is aPath.</span>
 <span class="s6">*   - Otherwise the two paths are joined with a slash.</span>
 <span class="s6">* - Joining for example 'http://' and 'www.example.com' is also supported.</span>
 <span class="s6">*/ </span><span class="s2">function </span><span class="s0">join(aRoot, aPath) {</span>
    <span class="s2">if </span><span class="s0">(aRoot === </span><span class="s1">&quot;&quot;</span><span class="s0">) {</span>
        <span class="s0">aRoot = </span><span class="s1">&quot;.&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(aPath === </span><span class="s1">&quot;&quot;</span><span class="s0">) {</span>
        <span class="s0">aPath = </span><span class="s1">&quot;.&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s2">var </span><span class="s0">aPathUrl = urlParse(aPath);</span>
    <span class="s2">var </span><span class="s0">aRootUrl = urlParse(aRoot);</span>
    <span class="s2">if </span><span class="s0">(aRootUrl) {</span>
        <span class="s0">aRoot = aRootUrl.path || </span><span class="s1">'/'</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s6">// `join(foo, '//www.example.org')`</span>
    <span class="s2">if </span><span class="s0">(aPathUrl &amp;&amp; !aPathUrl.scheme) {</span>
        <span class="s2">if </span><span class="s0">(aRootUrl) {</span>
            <span class="s0">aPathUrl.scheme = aRootUrl.scheme;</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">urlGenerate(aPathUrl);</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(aPathUrl || aPath.match(dataUrlRegexp)) {</span>
        <span class="s2">return </span><span class="s0">aPath;</span>
    <span class="s0">}</span>
    <span class="s6">// `join('http://', 'www.example.com')`</span>
    <span class="s2">if </span><span class="s0">(aRootUrl &amp;&amp; !aRootUrl.host &amp;&amp; !aRootUrl.path) {</span>
        <span class="s0">aRootUrl.host = aPath;</span>
        <span class="s2">return </span><span class="s0">urlGenerate(aRootUrl);</span>
    <span class="s0">}</span>
    <span class="s2">var </span><span class="s0">joined = aPath.charAt(</span><span class="s3">0</span><span class="s0">) === </span><span class="s1">'/' </span><span class="s0">? aPath : normalize(aRoot.replace(</span><span class="s5">/\/+$/</span><span class="s0">, </span><span class="s1">''</span><span class="s0">) + </span><span class="s1">'/' </span><span class="s0">+ aPath);</span>
    <span class="s2">if </span><span class="s0">(aRootUrl) {</span>
        <span class="s0">aRootUrl.path = joined;</span>
        <span class="s2">return </span><span class="s0">urlGenerate(aRootUrl);</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">joined;</span>
<span class="s0">}</span>
<span class="s0">exports.join = join;</span>
<span class="s0">exports.isAbsolute = </span><span class="s2">function</span><span class="s0">(aPath) {</span>
    <span class="s2">return </span><span class="s0">aPath.charAt(</span><span class="s3">0</span><span class="s0">) === </span><span class="s1">'/' </span><span class="s0">|| urlRegexp.test(aPath);</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Make a path relative to a URL or another path.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aRoot The root path or URL.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aPath The path or URL to be made relative to aRoot.</span>
 <span class="s6">*/ </span><span class="s2">function </span><span class="s0">relative(aRoot, aPath) {</span>
    <span class="s2">if </span><span class="s0">(aRoot === </span><span class="s1">&quot;&quot;</span><span class="s0">) {</span>
        <span class="s0">aRoot = </span><span class="s1">&quot;.&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">aRoot = aRoot.replace(</span><span class="s5">/\/$/</span><span class="s0">, </span><span class="s1">''</span><span class="s0">);</span>
    <span class="s6">// It is possible for the path to be above the root. In this case, simply</span>
    <span class="s6">// checking whether the root is a prefix of the path won't work. Instead, we</span>
    <span class="s6">// need to remove components from the root one by one, until either we find</span>
    <span class="s6">// a prefix that fits, or we run out of components to remove.</span>
    <span class="s2">var </span><span class="s0">level = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">while</span><span class="s0">(aPath.indexOf(aRoot + </span><span class="s1">'/'</span><span class="s0">) !== </span><span class="s3">0</span><span class="s0">){</span>
        <span class="s2">var </span><span class="s0">index = aRoot.lastIndexOf(</span><span class="s1">&quot;/&quot;</span><span class="s0">);</span>
        <span class="s2">if </span><span class="s0">(index &lt; </span><span class="s3">0</span><span class="s0">) {</span>
            <span class="s2">return </span><span class="s0">aPath;</span>
        <span class="s0">}</span>
        <span class="s6">// If the only part of the root that is left is the scheme (i.e. http://,</span>
        <span class="s6">// file:///, etc.), one or more slashes (/), or simply nothing at all, we</span>
        <span class="s6">// have exhausted all components, so the path is not relative to the root.</span>
        <span class="s0">aRoot = aRoot.slice(</span><span class="s3">0</span><span class="s0">, index);</span>
        <span class="s2">if </span><span class="s0">(aRoot.match(</span><span class="s5">/^([^\/]+:\/)?\/*$/</span><span class="s0">)) {</span>
            <span class="s2">return </span><span class="s0">aPath;</span>
        <span class="s0">}</span>
        <span class="s0">++level;</span>
    <span class="s0">}</span>
    <span class="s6">// Make sure we add a &quot;../&quot; for each component we removed from the root.</span>
    <span class="s2">return </span><span class="s0">Array(level + </span><span class="s3">1</span><span class="s0">).join(</span><span class="s1">&quot;../&quot;</span><span class="s0">) + aPath.substr(aRoot.length + </span><span class="s3">1</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s0">exports.relative = relative;</span>
<span class="s2">var </span><span class="s0">supportsNullProto = </span><span class="s2">function</span><span class="s0">() {</span>
    <span class="s2">var </span><span class="s0">obj = Object.create(</span><span class="s2">null</span><span class="s0">);</span>
    <span class="s2">return </span><span class="s0">!(</span><span class="s1">'__proto__' </span><span class="s2">in </span><span class="s0">obj);</span>
<span class="s0">}();</span>
<span class="s2">function </span><span class="s0">identity(s) {</span>
    <span class="s2">return </span><span class="s0">s;</span>
<span class="s0">}</span>
<span class="s6">/**</span>
 <span class="s6">* Because behavior goes wacky when you set `__proto__` on objects, we</span>
 <span class="s6">* have to prefix all the strings in our set with an arbitrary character.</span>
 <span class="s6">*</span>
 <span class="s6">* See https://github.com/mozilla/source-map/pull/31 and</span>
 <span class="s6">* https://github.com/mozilla/source-map/issues/30</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">String aStr</span>
 <span class="s6">*/ </span><span class="s2">function </span><span class="s0">toSetString(aStr) {</span>
    <span class="s2">if </span><span class="s0">(isProtoString(aStr)) {</span>
        <span class="s2">return </span><span class="s1">'$' </span><span class="s0">+ aStr;</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">aStr;</span>
<span class="s0">}</span>
<span class="s0">exports.toSetString = supportsNullProto ? identity : toSetString;</span>
<span class="s2">function </span><span class="s0">fromSetString(aStr) {</span>
    <span class="s2">if </span><span class="s0">(isProtoString(aStr)) {</span>
        <span class="s2">return </span><span class="s0">aStr.slice(</span><span class="s3">1</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">aStr;</span>
<span class="s0">}</span>
<span class="s0">exports.fromSetString = supportsNullProto ? identity : fromSetString;</span>
<span class="s2">function </span><span class="s0">isProtoString(s) {</span>
    <span class="s2">if </span><span class="s0">(!s) {</span>
        <span class="s2">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s2">var </span><span class="s0">length = s.length;</span>
    <span class="s2">if </span><span class="s0">(length &lt; </span><span class="s3">9 </span><span class="s6">/* &quot;__proto__&quot;.length */ </span><span class="s0">) {</span>
        <span class="s2">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(s.charCodeAt(length - </span><span class="s3">1</span><span class="s0">) !== </span><span class="s3">95 </span><span class="s6">/* '_' */  </span><span class="s0">|| s.charCodeAt(length - </span><span class="s3">2</span><span class="s0">) !== </span><span class="s3">95 </span><span class="s6">/* '_' */  </span><span class="s0">|| s.charCodeAt(length - </span><span class="s3">3</span><span class="s0">) !== </span><span class="s3">111 </span><span class="s6">/* 'o' */  </span><span class="s0">|| s.charCodeAt(length - </span><span class="s3">4</span><span class="s0">) !== </span><span class="s3">116 </span><span class="s6">/* 't' */  </span><span class="s0">|| s.charCodeAt(length - </span><span class="s3">5</span><span class="s0">) !== </span><span class="s3">111 </span><span class="s6">/* 'o' */  </span><span class="s0">|| s.charCodeAt(length - </span><span class="s3">6</span><span class="s0">) !== </span><span class="s3">114 </span><span class="s6">/* 'r' */  </span><span class="s0">|| s.charCodeAt(length - </span><span class="s3">7</span><span class="s0">) !== </span><span class="s3">112 </span><span class="s6">/* 'p' */  </span><span class="s0">|| s.charCodeAt(length - </span><span class="s3">8</span><span class="s0">) !== </span><span class="s3">95 </span><span class="s6">/* '_' */  </span><span class="s0">|| s.charCodeAt(length - </span><span class="s3">9</span><span class="s0">) !== </span><span class="s3">95 </span><span class="s6">/* '_' */ </span><span class="s0">) {</span>
        <span class="s2">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s2">for</span><span class="s0">(</span><span class="s2">var </span><span class="s0">i = length - </span><span class="s3">10</span><span class="s0">; i &gt;= </span><span class="s3">0</span><span class="s0">; i--){</span>
        <span class="s2">if </span><span class="s0">(s.charCodeAt(i) !== </span><span class="s3">36 </span><span class="s6">/* '$' */ </span><span class="s0">) {</span>
            <span class="s2">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s2">return true</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s6">/**</span>
 <span class="s6">* Comparator between two mappings where the original positions are compared.</span>
 <span class="s6">*</span>
 <span class="s6">* Optionally pass in `true` as `onlyCompareGenerated` to consider two</span>
 <span class="s6">* mappings with the same original source/line/column, but different generated</span>
 <span class="s6">* line and column the same. Useful when searching for a mapping with a</span>
 <span class="s6">* stubbed out mapping.</span>
 <span class="s6">*/ </span><span class="s2">function </span><span class="s0">compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {</span>
    <span class="s2">var </span><span class="s0">cmp = strcmp(mappingA.source, mappingB.source);</span>
    <span class="s2">if </span><span class="s0">(cmp !== </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">cmp;</span>
    <span class="s0">}</span>
    <span class="s0">cmp = mappingA.originalLine - mappingB.originalLine;</span>
    <span class="s2">if </span><span class="s0">(cmp !== </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">cmp;</span>
    <span class="s0">}</span>
    <span class="s0">cmp = mappingA.originalColumn - mappingB.originalColumn;</span>
    <span class="s2">if </span><span class="s0">(cmp !== </span><span class="s3">0 </span><span class="s0">|| onlyCompareOriginal) {</span>
        <span class="s2">return </span><span class="s0">cmp;</span>
    <span class="s0">}</span>
    <span class="s0">cmp = mappingA.generatedColumn - mappingB.generatedColumn;</span>
    <span class="s2">if </span><span class="s0">(cmp !== </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">cmp;</span>
    <span class="s0">}</span>
    <span class="s0">cmp = mappingA.generatedLine - mappingB.generatedLine;</span>
    <span class="s2">if </span><span class="s0">(cmp !== </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">cmp;</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">strcmp(mappingA.name, mappingB.name);</span>
<span class="s0">}</span>
<span class="s0">exports.compareByOriginalPositions = compareByOriginalPositions;</span>
<span class="s2">function </span><span class="s0">compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {</span>
    <span class="s2">var </span><span class="s0">cmp;</span>
    <span class="s0">cmp = mappingA.originalLine - mappingB.originalLine;</span>
    <span class="s2">if </span><span class="s0">(cmp !== </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">cmp;</span>
    <span class="s0">}</span>
    <span class="s0">cmp = mappingA.originalColumn - mappingB.originalColumn;</span>
    <span class="s2">if </span><span class="s0">(cmp !== </span><span class="s3">0 </span><span class="s0">|| onlyCompareOriginal) {</span>
        <span class="s2">return </span><span class="s0">cmp;</span>
    <span class="s0">}</span>
    <span class="s0">cmp = mappingA.generatedColumn - mappingB.generatedColumn;</span>
    <span class="s2">if </span><span class="s0">(cmp !== </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">cmp;</span>
    <span class="s0">}</span>
    <span class="s0">cmp = mappingA.generatedLine - mappingB.generatedLine;</span>
    <span class="s2">if </span><span class="s0">(cmp !== </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">cmp;</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">strcmp(mappingA.name, mappingB.name);</span>
<span class="s0">}</span>
<span class="s0">exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;</span>
<span class="s6">/**</span>
 <span class="s6">* Comparator between two mappings with deflated source and name indices where</span>
 <span class="s6">* the generated positions are compared.</span>
 <span class="s6">*</span>
 <span class="s6">* Optionally pass in `true` as `onlyCompareGenerated` to consider two</span>
 <span class="s6">* mappings with the same generated line and column, but different</span>
 <span class="s6">* source/name/original line and column the same. Useful when searching for a</span>
 <span class="s6">* mapping with a stubbed out mapping.</span>
 <span class="s6">*/ </span><span class="s2">function </span><span class="s0">compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {</span>
    <span class="s2">var </span><span class="s0">cmp = mappingA.generatedLine - mappingB.generatedLine;</span>
    <span class="s2">if </span><span class="s0">(cmp !== </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">cmp;</span>
    <span class="s0">}</span>
    <span class="s0">cmp = mappingA.generatedColumn - mappingB.generatedColumn;</span>
    <span class="s2">if </span><span class="s0">(cmp !== </span><span class="s3">0 </span><span class="s0">|| onlyCompareGenerated) {</span>
        <span class="s2">return </span><span class="s0">cmp;</span>
    <span class="s0">}</span>
    <span class="s0">cmp = strcmp(mappingA.source, mappingB.source);</span>
    <span class="s2">if </span><span class="s0">(cmp !== </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">cmp;</span>
    <span class="s0">}</span>
    <span class="s0">cmp = mappingA.originalLine - mappingB.originalLine;</span>
    <span class="s2">if </span><span class="s0">(cmp !== </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">cmp;</span>
    <span class="s0">}</span>
    <span class="s0">cmp = mappingA.originalColumn - mappingB.originalColumn;</span>
    <span class="s2">if </span><span class="s0">(cmp !== </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">cmp;</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">strcmp(mappingA.name, mappingB.name);</span>
<span class="s0">}</span>
<span class="s0">exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;</span>
<span class="s2">function </span><span class="s0">compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {</span>
    <span class="s2">var </span><span class="s0">cmp = mappingA.generatedColumn - mappingB.generatedColumn;</span>
    <span class="s2">if </span><span class="s0">(cmp !== </span><span class="s3">0 </span><span class="s0">|| onlyCompareGenerated) {</span>
        <span class="s2">return </span><span class="s0">cmp;</span>
    <span class="s0">}</span>
    <span class="s0">cmp = strcmp(mappingA.source, mappingB.source);</span>
    <span class="s2">if </span><span class="s0">(cmp !== </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">cmp;</span>
    <span class="s0">}</span>
    <span class="s0">cmp = mappingA.originalLine - mappingB.originalLine;</span>
    <span class="s2">if </span><span class="s0">(cmp !== </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">cmp;</span>
    <span class="s0">}</span>
    <span class="s0">cmp = mappingA.originalColumn - mappingB.originalColumn;</span>
    <span class="s2">if </span><span class="s0">(cmp !== </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">cmp;</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">strcmp(mappingA.name, mappingB.name);</span>
<span class="s0">}</span>
<span class="s0">exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;</span>
<span class="s2">function </span><span class="s0">strcmp(aStr1, aStr2) {</span>
    <span class="s2">if </span><span class="s0">(aStr1 === aStr2) {</span>
        <span class="s2">return </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(aStr1 === </span><span class="s2">null</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s3">1</span><span class="s0">; </span><span class="s6">// aStr2 !== null</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(aStr2 === </span><span class="s2">null</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">-</span><span class="s3">1</span><span class="s0">; </span><span class="s6">// aStr1 !== null</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(aStr1 &gt; aStr2) {</span>
        <span class="s2">return </span><span class="s3">1</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">-</span><span class="s3">1</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s6">/**</span>
 <span class="s6">* Comparator between two mappings with inflated source and name strings where</span>
 <span class="s6">* the generated positions are compared.</span>
 <span class="s6">*/ </span><span class="s2">function </span><span class="s0">compareByGeneratedPositionsInflated(mappingA, mappingB) {</span>
    <span class="s2">var </span><span class="s0">cmp = mappingA.generatedLine - mappingB.generatedLine;</span>
    <span class="s2">if </span><span class="s0">(cmp !== </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">cmp;</span>
    <span class="s0">}</span>
    <span class="s0">cmp = mappingA.generatedColumn - mappingB.generatedColumn;</span>
    <span class="s2">if </span><span class="s0">(cmp !== </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">cmp;</span>
    <span class="s0">}</span>
    <span class="s0">cmp = strcmp(mappingA.source, mappingB.source);</span>
    <span class="s2">if </span><span class="s0">(cmp !== </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">cmp;</span>
    <span class="s0">}</span>
    <span class="s0">cmp = mappingA.originalLine - mappingB.originalLine;</span>
    <span class="s2">if </span><span class="s0">(cmp !== </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">cmp;</span>
    <span class="s0">}</span>
    <span class="s0">cmp = mappingA.originalColumn - mappingB.originalColumn;</span>
    <span class="s2">if </span><span class="s0">(cmp !== </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">cmp;</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">strcmp(mappingA.name, mappingB.name);</span>
<span class="s0">}</span>
<span class="s0">exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;</span>
<span class="s6">/**</span>
 <span class="s6">* Strip any JSON XSSI avoidance prefix from the string (as documented</span>
 <span class="s6">* in the source maps specification), and then parse the string as</span>
 <span class="s6">* JSON.</span>
 <span class="s6">*/ </span><span class="s2">function </span><span class="s0">parseSourceMapInput(str) {</span>
    <span class="s2">return </span><span class="s0">JSON.parse(str.replace(</span><span class="s5">/^\)]}'[^\n]*\n/</span><span class="s0">, </span><span class="s1">''</span><span class="s0">));</span>
<span class="s0">}</span>
<span class="s0">exports.parseSourceMapInput = parseSourceMapInput;</span>
<span class="s6">/**</span>
 <span class="s6">* Compute the URL of a source given the the source root, the source's</span>
 <span class="s6">* URL, and the source map's URL.</span>
 <span class="s6">*/ </span><span class="s2">function </span><span class="s0">computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {</span>
    <span class="s0">sourceURL = sourceURL || </span><span class="s1">''</span><span class="s0">;</span>
    <span class="s2">if </span><span class="s0">(sourceRoot) {</span>
        <span class="s6">// This follows what Chrome does.</span>
        <span class="s2">if </span><span class="s0">(sourceRoot[sourceRoot.length - </span><span class="s3">1</span><span class="s0">] !== </span><span class="s1">'/' </span><span class="s0">&amp;&amp; sourceURL[</span><span class="s3">0</span><span class="s0">] !== </span><span class="s1">'/'</span><span class="s0">) {</span>
            <span class="s0">sourceRoot += </span><span class="s1">'/'</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s6">// The spec says:</span>
        <span class="s6">//   Line 4: An optional source root, useful for relocating source</span>
        <span class="s6">//   files on a server or removing repeated values in the</span>
        <span class="s6">//   sources entry.  This value is prepended to the individual</span>
        <span class="s6">//   entries in the source field.</span>
        <span class="s0">sourceURL = sourceRoot + sourceURL;</span>
    <span class="s0">}</span>
    <span class="s6">// Historically, SourceMapConsumer did not take the sourceMapURL as</span>
    <span class="s6">// a parameter.  This mode is still somewhat supported, which is why</span>
    <span class="s6">// this code block is conditional.  However, it's preferable to pass</span>
    <span class="s6">// the source map URL to SourceMapConsumer, so that this function</span>
    <span class="s6">// can implement the source URL resolution algorithm as outlined in</span>
    <span class="s6">// the spec.  This block is basically the equivalent of:</span>
    <span class="s6">//    new URL(sourceURL, sourceMapURL).toString()</span>
    <span class="s6">// ... except it avoids using URL, which wasn't available in the</span>
    <span class="s6">// older releases of node still supported by this library.</span>
    <span class="s6">//</span>
    <span class="s6">// The spec says:</span>
    <span class="s6">//   If the sources are not absolute URLs after prepending of the</span>
    <span class="s6">//   sourceRoot, the sources are resolved relative to the</span>
    <span class="s6">//   SourceMap (like resolving script src in a html document).</span>
    <span class="s2">if </span><span class="s0">(sourceMapURL) {</span>
        <span class="s2">var </span><span class="s0">parsed = urlParse(sourceMapURL);</span>
        <span class="s2">if </span><span class="s0">(!parsed) {</span>
            <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">&quot;sourceMapURL could not be parsed&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(parsed.path) {</span>
            <span class="s6">// Strip the last path component, but keep the &quot;/&quot;.</span>
            <span class="s2">var </span><span class="s0">index = parsed.path.lastIndexOf(</span><span class="s1">'/'</span><span class="s0">);</span>
            <span class="s2">if </span><span class="s0">(index &gt;= </span><span class="s3">0</span><span class="s0">) {</span>
                <span class="s0">parsed.path = parsed.path.substring(</span><span class="s3">0</span><span class="s0">, index + </span><span class="s3">1</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">sourceURL = join(urlGenerate(parsed), sourceURL);</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">normalize(sourceURL);</span>
<span class="s0">}</span>
<span class="s0">exports.computeSourceURL = computeSourceURL;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/source-map-js/lib/array-set.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>

<span class="s6">/* -*- Mode: js; js-indent-level: 2; -*- */ /* 
 * Copyright 2011 Mozilla Foundation and contributors 
 * Licensed under the New BSD license. See LICENSE or: 
 * http://opensource.org/licenses/BSD-3-Clause 
 */ </span><span class="s2">var </span><span class="s0">util = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">var </span><span class="s0">has = Object.prototype.hasOwnProperty;</span>
<span class="s2">var </span><span class="s0">hasNativeMap = </span><span class="s2">typeof </span><span class="s0">Map !== </span><span class="s1">&quot;undefined&quot;</span><span class="s0">;</span>
<span class="s6">/**</span>
 <span class="s6">* A data structure which is a combination of an array and a set. Adding a new</span>
 <span class="s6">* member is O(1), testing for membership is O(1), and finding the index of an</span>
 <span class="s6">* element is O(1). Removing elements from the set is not supported. Only</span>
 <span class="s6">* strings are supported for membership.</span>
 <span class="s6">*/ </span><span class="s2">function </span><span class="s0">ArraySet() {</span>
    <span class="s2">this</span><span class="s0">._array = [];</span>
    <span class="s2">this</span><span class="s0">._set = hasNativeMap ? </span><span class="s2">new </span><span class="s0">Map() : Object.create(</span><span class="s2">null</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s6">/**</span>
 <span class="s6">* Static method for creating ArraySet instances from an existing array.</span>
 <span class="s6">*/ </span><span class="s0">ArraySet.fromArray = </span><span class="s2">function </span><span class="s0">ArraySet_fromArray(aArray, aAllowDuplicates) {</span>
    <span class="s2">var </span><span class="s0">set = </span><span class="s2">new </span><span class="s0">ArraySet();</span>
    <span class="s2">for</span><span class="s0">(</span><span class="s2">var </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">, len = aArray.length; i &lt; len; i++){</span>
        <span class="s0">set.add(aArray[i], aAllowDuplicates);</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">set;</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Return how many unique items are in this ArraySet. If duplicates have been</span>
 <span class="s6">* added, than those do not count towards the size.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@returns </span><span class="s6">Number</span>
 <span class="s6">*/ </span><span class="s0">ArraySet.prototype.size = </span><span class="s2">function </span><span class="s0">ArraySet_size() {</span>
    <span class="s2">return </span><span class="s0">hasNativeMap ? </span><span class="s2">this</span><span class="s0">._set.size : Object.getOwnPropertyNames(</span><span class="s2">this</span><span class="s0">._set).length;</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Add the given string to this set.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">String aStr</span>
 <span class="s6">*/ </span><span class="s0">ArraySet.prototype.add = </span><span class="s2">function </span><span class="s0">ArraySet_add(aStr, aAllowDuplicates) {</span>
    <span class="s2">var </span><span class="s0">sStr = hasNativeMap ? aStr : util.toSetString(aStr);</span>
    <span class="s2">var </span><span class="s0">isDuplicate = hasNativeMap ? </span><span class="s2">this</span><span class="s0">.has(aStr) : has.call(</span><span class="s2">this</span><span class="s0">._set, sStr);</span>
    <span class="s2">var </span><span class="s0">idx = </span><span class="s2">this</span><span class="s0">._array.length;</span>
    <span class="s2">if </span><span class="s0">(!isDuplicate || aAllowDuplicates) {</span>
        <span class="s2">this</span><span class="s0">._array.push(aStr);</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(!isDuplicate) {</span>
        <span class="s2">if </span><span class="s0">(hasNativeMap) {</span>
            <span class="s2">this</span><span class="s0">._set.set(aStr, idx);</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">this</span><span class="s0">._set[sStr] = idx;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Is the given string a member of this set?</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">String aStr</span>
 <span class="s6">*/ </span><span class="s0">ArraySet.prototype.has = </span><span class="s2">function </span><span class="s0">ArraySet_has(aStr) {</span>
    <span class="s2">if </span><span class="s0">(hasNativeMap) {</span>
        <span class="s2">return this</span><span class="s0">._set.has(aStr);</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s2">var </span><span class="s0">sStr = util.toSetString(aStr);</span>
        <span class="s2">return </span><span class="s0">has.call(</span><span class="s2">this</span><span class="s0">._set, sStr);</span>
    <span class="s0">}</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* What is the index of the given string in the array?</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">String aStr</span>
 <span class="s6">*/ </span><span class="s0">ArraySet.prototype.indexOf = </span><span class="s2">function </span><span class="s0">ArraySet_indexOf(aStr) {</span>
    <span class="s2">if </span><span class="s0">(hasNativeMap) {</span>
        <span class="s2">var </span><span class="s0">idx = </span><span class="s2">this</span><span class="s0">._set.get(aStr);</span>
        <span class="s2">if </span><span class="s0">(idx &gt;= </span><span class="s3">0</span><span class="s0">) {</span>
            <span class="s2">return </span><span class="s0">idx;</span>
        <span class="s0">}</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s2">var </span><span class="s0">sStr = util.toSetString(aStr);</span>
        <span class="s2">if </span><span class="s0">(has.call(</span><span class="s2">this</span><span class="s0">._set, sStr)) {</span>
            <span class="s2">return this</span><span class="s0">._set[sStr];</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">'&quot;' </span><span class="s0">+ aStr + </span><span class="s1">'&quot; is not in the set.'</span><span class="s0">);</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* What is the element at the given index?</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">Number aIdx</span>
 <span class="s6">*/ </span><span class="s0">ArraySet.prototype.at = </span><span class="s2">function </span><span class="s0">ArraySet_at(aIdx) {</span>
    <span class="s2">if </span><span class="s0">(aIdx &gt;= </span><span class="s3">0 </span><span class="s0">&amp;&amp; aIdx &lt; </span><span class="s2">this</span><span class="s0">._array.length) {</span>
        <span class="s2">return this</span><span class="s0">._array[aIdx];</span>
    <span class="s0">}</span>
    <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">'No element indexed by ' </span><span class="s0">+ aIdx);</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Returns the array representation of this set (which has the proper indices</span>
 <span class="s6">* indicated by indexOf). Note that this is a copy of the internal array used</span>
 <span class="s6">* for storing the members so that no one can mess with internal state.</span>
 <span class="s6">*/ </span><span class="s0">ArraySet.prototype.toArray = </span><span class="s2">function </span><span class="s0">ArraySet_toArray() {</span>
    <span class="s2">return this</span><span class="s0">._array.slice();</span>
<span class="s0">};</span>
<span class="s0">exports.ArraySet = ArraySet;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/source-map-js/lib/mapping-list.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>

<span class="s6">/* -*- Mode: js; js-indent-level: 2; -*- */ /* 
 * Copyright 2014 Mozilla Foundation and contributors 
 * Licensed under the New BSD license. See LICENSE or: 
 * http://opensource.org/licenses/BSD-3-Clause 
 */ </span><span class="s2">var </span><span class="s0">util = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s6">/**</span>
 <span class="s6">* Determine whether mappingB is after mappingA with respect to generated</span>
 <span class="s6">* position.</span>
 <span class="s6">*/ </span><span class="s2">function </span><span class="s0">generatedPositionAfter(mappingA, mappingB) {</span>
    <span class="s6">// Optimized for most common case</span>
    <span class="s2">var </span><span class="s0">lineA = mappingA.generatedLine;</span>
    <span class="s2">var </span><span class="s0">lineB = mappingB.generatedLine;</span>
    <span class="s2">var </span><span class="s0">columnA = mappingA.generatedColumn;</span>
    <span class="s2">var </span><span class="s0">columnB = mappingB.generatedColumn;</span>
    <span class="s2">return </span><span class="s0">lineB &gt; lineA || lineB == lineA &amp;&amp; columnB &gt;= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) &lt;= </span><span class="s3">0</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s6">/**</span>
 <span class="s6">* A data structure to provide a sorted view of accumulated mappings in a</span>
 <span class="s6">* performance conscious manner. It trades a neglibable overhead in general</span>
 <span class="s6">* case for a large speedup in case of mappings being added in order.</span>
 <span class="s6">*/ </span><span class="s2">function </span><span class="s0">MappingList() {</span>
    <span class="s2">this</span><span class="s0">._array = [];</span>
    <span class="s2">this</span><span class="s0">._sorted = </span><span class="s2">true</span><span class="s0">;</span>
    <span class="s6">// Serves as infimum</span>
    <span class="s2">this</span><span class="s0">._last = {</span>
        <span class="s0">generatedLine: -</span><span class="s3">1</span><span class="s0">,</span>
        <span class="s0">generatedColumn: </span><span class="s3">0</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s6">/**</span>
 <span class="s6">* Iterate through internal items. This method takes the same arguments that</span>
 <span class="s6">* `Array.prototype.forEach` takes.</span>
 <span class="s6">*</span>
 <span class="s6">* NOTE: The order of the mappings is NOT guaranteed.</span>
 <span class="s6">*/ </span><span class="s0">MappingList.prototype.unsortedForEach = </span><span class="s2">function </span><span class="s0">MappingList_forEach(aCallback, aThisArg) {</span>
    <span class="s2">this</span><span class="s0">._array.forEach(aCallback, aThisArg);</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Add the given source mapping.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">Object aMapping</span>
 <span class="s6">*/ </span><span class="s0">MappingList.prototype.add = </span><span class="s2">function </span><span class="s0">MappingList_add(aMapping) {</span>
    <span class="s2">if </span><span class="s0">(generatedPositionAfter(</span><span class="s2">this</span><span class="s0">._last, aMapping)) {</span>
        <span class="s2">this</span><span class="s0">._last = aMapping;</span>
        <span class="s2">this</span><span class="s0">._array.push(aMapping);</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s2">this</span><span class="s0">._sorted = </span><span class="s2">false</span><span class="s0">;</span>
        <span class="s2">this</span><span class="s0">._array.push(aMapping);</span>
    <span class="s0">}</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Returns the flat, sorted array of mappings. The mappings are sorted by</span>
 <span class="s6">* generated position.</span>
 <span class="s6">*</span>
 <span class="s6">* WARNING: This method returns internal data without copying, for</span>
 <span class="s6">* performance. The return value must NOT be mutated, and should be treated as</span>
 <span class="s6">* an immutable borrow. If you want to take ownership, you must make your own</span>
 <span class="s6">* copy.</span>
 <span class="s6">*/ </span><span class="s0">MappingList.prototype.toArray = </span><span class="s2">function </span><span class="s0">MappingList_toArray() {</span>
    <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">._sorted) {</span>
        <span class="s2">this</span><span class="s0">._array.sort(util.compareByGeneratedPositionsInflated);</span>
        <span class="s2">this</span><span class="s0">._sorted = </span><span class="s2">true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s2">return this</span><span class="s0">._array;</span>
<span class="s0">};</span>
<span class="s0">exports.MappingList = MappingList;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/source-map-js/lib/source-map-generator.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>

<span class="s6">/* -*- Mode: js; js-indent-level: 2; -*- */ /* 
 * Copyright 2011 Mozilla Foundation and contributors 
 * Licensed under the New BSD license. See LICENSE or: 
 * http://opensource.org/licenses/BSD-3-Clause 
 */ </span><span class="s2">var </span><span class="s0">base64VLQ = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/source-map-js/lib/base64-vlq.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">var </span><span class="s0">util = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">var </span><span class="s0">ArraySet = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/source-map-js/lib/array-set.js [postcss] (ecmascript)&quot;</span><span class="s0">).ArraySet;</span>
<span class="s2">var </span><span class="s0">MappingList = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/source-map-js/lib/mapping-list.js [postcss] (ecmascript)&quot;</span><span class="s0">).MappingList;</span>
<span class="s6">/**</span>
 <span class="s6">* An instance of the SourceMapGenerator represents a source map which is</span>
 <span class="s6">* being built incrementally. You may pass an object with the following</span>
 <span class="s6">* properties:</span>
 <span class="s6">*</span>
 <span class="s6">*   - file: The filename of the generated source.</span>
 <span class="s6">*   - sourceRoot: A root for all relative URLs in this source map.</span>
 <span class="s6">*/ </span><span class="s2">function </span><span class="s0">SourceMapGenerator(aArgs) {</span>
    <span class="s2">if </span><span class="s0">(!aArgs) {</span>
        <span class="s0">aArgs = {};</span>
    <span class="s0">}</span>
    <span class="s2">this</span><span class="s0">._file = util.getArg(aArgs, </span><span class="s1">'file'</span><span class="s0">, </span><span class="s2">null</span><span class="s0">);</span>
    <span class="s2">this</span><span class="s0">._sourceRoot = util.getArg(aArgs, </span><span class="s1">'sourceRoot'</span><span class="s0">, </span><span class="s2">null</span><span class="s0">);</span>
    <span class="s2">this</span><span class="s0">._skipValidation = util.getArg(aArgs, </span><span class="s1">'skipValidation'</span><span class="s0">, </span><span class="s2">false</span><span class="s0">);</span>
    <span class="s2">this</span><span class="s0">._ignoreInvalidMapping = util.getArg(aArgs, </span><span class="s1">'ignoreInvalidMapping'</span><span class="s0">, </span><span class="s2">false</span><span class="s0">);</span>
    <span class="s2">this</span><span class="s0">._sources = </span><span class="s2">new </span><span class="s0">ArraySet();</span>
    <span class="s2">this</span><span class="s0">._names = </span><span class="s2">new </span><span class="s0">ArraySet();</span>
    <span class="s2">this</span><span class="s0">._mappings = </span><span class="s2">new </span><span class="s0">MappingList();</span>
    <span class="s2">this</span><span class="s0">._sourcesContents = </span><span class="s2">null</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s0">SourceMapGenerator.prototype._version = </span><span class="s3">3</span><span class="s0">;</span>
<span class="s6">/**</span>
 <span class="s6">* Creates a new SourceMapGenerator based on a SourceMapConsumer</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aSourceMapConsumer The SourceMap.</span>
 <span class="s6">*/ </span><span class="s0">SourceMapGenerator.fromSourceMap = </span><span class="s2">function </span><span class="s0">SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {</span>
    <span class="s2">var </span><span class="s0">sourceRoot = aSourceMapConsumer.sourceRoot;</span>
    <span class="s2">var </span><span class="s0">generator = </span><span class="s2">new </span><span class="s0">SourceMapGenerator(Object.assign(generatorOps || {}, {</span>
        <span class="s0">file: aSourceMapConsumer.file,</span>
        <span class="s0">sourceRoot: sourceRoot</span>
    <span class="s0">}));</span>
    <span class="s0">aSourceMapConsumer.eachMapping(</span><span class="s2">function</span><span class="s0">(mapping) {</span>
        <span class="s2">var </span><span class="s0">newMapping = {</span>
            <span class="s0">generated: {</span>
                <span class="s0">line: mapping.generatedLine,</span>
                <span class="s0">column: mapping.generatedColumn</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s2">if </span><span class="s0">(mapping.source != </span><span class="s2">null</span><span class="s0">) {</span>
            <span class="s0">newMapping.source = mapping.source;</span>
            <span class="s2">if </span><span class="s0">(sourceRoot != </span><span class="s2">null</span><span class="s0">) {</span>
                <span class="s0">newMapping.source = util.relative(sourceRoot, newMapping.source);</span>
            <span class="s0">}</span>
            <span class="s0">newMapping.original = {</span>
                <span class="s0">line: mapping.originalLine,</span>
                <span class="s0">column: mapping.originalColumn</span>
            <span class="s0">};</span>
            <span class="s2">if </span><span class="s0">(mapping.name != </span><span class="s2">null</span><span class="s0">) {</span>
                <span class="s0">newMapping.name = mapping.name;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">generator.addMapping(newMapping);</span>
    <span class="s0">});</span>
    <span class="s0">aSourceMapConsumer.sources.forEach(</span><span class="s2">function</span><span class="s0">(sourceFile) {</span>
        <span class="s2">var </span><span class="s0">sourceRelative = sourceFile;</span>
        <span class="s2">if </span><span class="s0">(sourceRoot !== </span><span class="s2">null</span><span class="s0">) {</span>
            <span class="s0">sourceRelative = util.relative(sourceRoot, sourceFile);</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(!generator._sources.has(sourceRelative)) {</span>
            <span class="s0">generator._sources.add(sourceRelative);</span>
        <span class="s0">}</span>
        <span class="s2">var </span><span class="s0">content = aSourceMapConsumer.sourceContentFor(sourceFile);</span>
        <span class="s2">if </span><span class="s0">(content != </span><span class="s2">null</span><span class="s0">) {</span>
            <span class="s0">generator.setSourceContent(sourceFile, content);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s2">return </span><span class="s0">generator;</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Add a single mapping from original source line and column to the generated</span>
 <span class="s6">* source's line and column for this source map being created. The mapping</span>
 <span class="s6">* object should have the following properties:</span>
 <span class="s6">*</span>
 <span class="s6">*   - generated: An object with the generated line and column positions.</span>
 <span class="s6">*   - original: An object with the original line and column positions.</span>
 <span class="s6">*   - source: The original source file (relative to the sourceRoot).</span>
 <span class="s6">*   - name: An optional original token name for this mapping.</span>
 <span class="s6">*/ </span><span class="s0">SourceMapGenerator.prototype.addMapping = </span><span class="s2">function </span><span class="s0">SourceMapGenerator_addMapping(aArgs) {</span>
    <span class="s2">var </span><span class="s0">generated = util.getArg(aArgs, </span><span class="s1">'generated'</span><span class="s0">);</span>
    <span class="s2">var </span><span class="s0">original = util.getArg(aArgs, </span><span class="s1">'original'</span><span class="s0">, </span><span class="s2">null</span><span class="s0">);</span>
    <span class="s2">var </span><span class="s0">source = util.getArg(aArgs, </span><span class="s1">'source'</span><span class="s0">, </span><span class="s2">null</span><span class="s0">);</span>
    <span class="s2">var </span><span class="s0">name = util.getArg(aArgs, </span><span class="s1">'name'</span><span class="s0">, </span><span class="s2">null</span><span class="s0">);</span>
    <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">._skipValidation) {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">._validateMapping(generated, original, source, name) === </span><span class="s2">false</span><span class="s0">) {</span>
            <span class="s2">return</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(source != </span><span class="s2">null</span><span class="s0">) {</span>
        <span class="s0">source = String(source);</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">._sources.has(source)) {</span>
            <span class="s2">this</span><span class="s0">._sources.add(source);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(name != </span><span class="s2">null</span><span class="s0">) {</span>
        <span class="s0">name = String(name);</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">._names.has(name)) {</span>
            <span class="s2">this</span><span class="s0">._names.add(name);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s2">this</span><span class="s0">._mappings.add({</span>
        <span class="s0">generatedLine: generated.line,</span>
        <span class="s0">generatedColumn: generated.column,</span>
        <span class="s0">originalLine: original != </span><span class="s2">null </span><span class="s0">&amp;&amp; original.line,</span>
        <span class="s0">originalColumn: original != </span><span class="s2">null </span><span class="s0">&amp;&amp; original.column,</span>
        <span class="s0">source: source,</span>
        <span class="s0">name: name</span>
    <span class="s0">});</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Set the source content for a source file.</span>
 <span class="s6">*/ </span><span class="s0">SourceMapGenerator.prototype.setSourceContent = </span><span class="s2">function </span><span class="s0">SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {</span>
    <span class="s2">var </span><span class="s0">source = aSourceFile;</span>
    <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">._sourceRoot != </span><span class="s2">null</span><span class="s0">) {</span>
        <span class="s0">source = util.relative(</span><span class="s2">this</span><span class="s0">._sourceRoot, source);</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(aSourceContent != </span><span class="s2">null</span><span class="s0">) {</span>
        <span class="s6">// Add the source content to the _sourcesContents map.</span>
        <span class="s6">// Create a new _sourcesContents map if the property is null.</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">._sourcesContents) {</span>
            <span class="s2">this</span><span class="s0">._sourcesContents = Object.create(</span><span class="s2">null</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s2">this</span><span class="s0">._sourcesContents[util.toSetString(source)] = aSourceContent;</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">._sourcesContents) {</span>
        <span class="s6">// Remove the source file from the _sourcesContents map.</span>
        <span class="s6">// If the _sourcesContents map is empty, set the property to null.</span>
        <span class="s2">delete this</span><span class="s0">._sourcesContents[util.toSetString(source)];</span>
        <span class="s2">if </span><span class="s0">(Object.keys(</span><span class="s2">this</span><span class="s0">._sourcesContents).length === </span><span class="s3">0</span><span class="s0">) {</span>
            <span class="s2">this</span><span class="s0">._sourcesContents = </span><span class="s2">null</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Applies the mappings of a sub-source-map for a specific source file to the</span>
 <span class="s6">* source map being generated. Each mapping to the supplied source file is</span>
 <span class="s6">* rewritten using the supplied source map. Note: The resolution for the</span>
 <span class="s6">* resulting mappings is the minimium of this map and the supplied map.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aSourceMapConsumer The source map to be applied.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aSourceFile Optional. The filename of the source file.</span>
 <span class="s6">*        If omitted, SourceMapConsumer's file property will be used.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aSourceMapPath Optional. The dirname of the path to the source map</span>
 <span class="s6">*        to be applied. If relative, it is relative to the SourceMapConsumer.</span>
 <span class="s6">*        This parameter is needed when the two source maps aren't in the same</span>
 <span class="s6">*        directory, and the source map to be applied contains relative source</span>
 <span class="s6">*        paths. If so, those relative source paths need to be rewritten</span>
 <span class="s6">*        relative to the SourceMapGenerator.</span>
 <span class="s6">*/ </span><span class="s0">SourceMapGenerator.prototype.applySourceMap = </span><span class="s2">function </span><span class="s0">SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {</span>
    <span class="s2">var </span><span class="s0">sourceFile = aSourceFile;</span>
    <span class="s6">// If aSourceFile is omitted, we will use the file property of the SourceMap</span>
    <span class="s2">if </span><span class="s0">(aSourceFile == </span><span class="s2">null</span><span class="s0">) {</span>
        <span class="s2">if </span><span class="s0">(aSourceMapConsumer.file == </span><span class="s2">null</span><span class="s0">) {</span>
            <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' </span><span class="s0">+ </span><span class="s1">'or the source map</span><span class="s4">\'</span><span class="s1">s &quot;file&quot; property. Both were omitted.'</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">sourceFile = aSourceMapConsumer.file;</span>
    <span class="s0">}</span>
    <span class="s2">var </span><span class="s0">sourceRoot = </span><span class="s2">this</span><span class="s0">._sourceRoot;</span>
    <span class="s6">// Make &quot;sourceFile&quot; relative if an absolute Url is passed.</span>
    <span class="s2">if </span><span class="s0">(sourceRoot != </span><span class="s2">null</span><span class="s0">) {</span>
        <span class="s0">sourceFile = util.relative(sourceRoot, sourceFile);</span>
    <span class="s0">}</span>
    <span class="s6">// Applying the SourceMap can add and remove items from the sources and</span>
    <span class="s6">// the names array.</span>
    <span class="s2">var </span><span class="s0">newSources = </span><span class="s2">new </span><span class="s0">ArraySet();</span>
    <span class="s2">var </span><span class="s0">newNames = </span><span class="s2">new </span><span class="s0">ArraySet();</span>
    <span class="s6">// Find mappings for the &quot;sourceFile&quot;</span>
    <span class="s2">this</span><span class="s0">._mappings.unsortedForEach(</span><span class="s2">function</span><span class="s0">(mapping) {</span>
        <span class="s2">if </span><span class="s0">(mapping.source === sourceFile &amp;&amp; mapping.originalLine != </span><span class="s2">null</span><span class="s0">) {</span>
            <span class="s6">// Check if it can be mapped by the source map, then update the mapping.</span>
            <span class="s2">var </span><span class="s0">original = aSourceMapConsumer.originalPositionFor({</span>
                <span class="s0">line: mapping.originalLine,</span>
                <span class="s0">column: mapping.originalColumn</span>
            <span class="s0">});</span>
            <span class="s2">if </span><span class="s0">(original.source != </span><span class="s2">null</span><span class="s0">) {</span>
                <span class="s6">// Copy mapping</span>
                <span class="s0">mapping.source = original.source;</span>
                <span class="s2">if </span><span class="s0">(aSourceMapPath != </span><span class="s2">null</span><span class="s0">) {</span>
                    <span class="s0">mapping.source = util.join(aSourceMapPath, mapping.source);</span>
                <span class="s0">}</span>
                <span class="s2">if </span><span class="s0">(sourceRoot != </span><span class="s2">null</span><span class="s0">) {</span>
                    <span class="s0">mapping.source = util.relative(sourceRoot, mapping.source);</span>
                <span class="s0">}</span>
                <span class="s0">mapping.originalLine = original.line;</span>
                <span class="s0">mapping.originalColumn = original.column;</span>
                <span class="s2">if </span><span class="s0">(original.name != </span><span class="s2">null</span><span class="s0">) {</span>
                    <span class="s0">mapping.name = original.name;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">var </span><span class="s0">source = mapping.source;</span>
        <span class="s2">if </span><span class="s0">(source != </span><span class="s2">null </span><span class="s0">&amp;&amp; !newSources.has(source)) {</span>
            <span class="s0">newSources.add(source);</span>
        <span class="s0">}</span>
        <span class="s2">var </span><span class="s0">name = mapping.name;</span>
        <span class="s2">if </span><span class="s0">(name != </span><span class="s2">null </span><span class="s0">&amp;&amp; !newNames.has(name)) {</span>
            <span class="s0">newNames.add(name);</span>
        <span class="s0">}</span>
    <span class="s0">}, </span><span class="s2">this</span><span class="s0">);</span>
    <span class="s2">this</span><span class="s0">._sources = newSources;</span>
    <span class="s2">this</span><span class="s0">._names = newNames;</span>
    <span class="s6">// Copy sourcesContents of applied map.</span>
    <span class="s0">aSourceMapConsumer.sources.forEach(</span><span class="s2">function</span><span class="s0">(sourceFile) {</span>
        <span class="s2">var </span><span class="s0">content = aSourceMapConsumer.sourceContentFor(sourceFile);</span>
        <span class="s2">if </span><span class="s0">(content != </span><span class="s2">null</span><span class="s0">) {</span>
            <span class="s2">if </span><span class="s0">(aSourceMapPath != </span><span class="s2">null</span><span class="s0">) {</span>
                <span class="s0">sourceFile = util.join(aSourceMapPath, sourceFile);</span>
            <span class="s0">}</span>
            <span class="s2">if </span><span class="s0">(sourceRoot != </span><span class="s2">null</span><span class="s0">) {</span>
                <span class="s0">sourceFile = util.relative(sourceRoot, sourceFile);</span>
            <span class="s0">}</span>
            <span class="s2">this</span><span class="s0">.setSourceContent(sourceFile, content);</span>
        <span class="s0">}</span>
    <span class="s0">}, </span><span class="s2">this</span><span class="s0">);</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* A mapping can have one of the three levels of data:</span>
 <span class="s6">*</span>
 <span class="s6">*   1. Just the generated position.</span>
 <span class="s6">*   2. The Generated position, original position, and original source.</span>
 <span class="s6">*   3. Generated and original position, original source, as well as a name</span>
 <span class="s6">*      token.</span>
 <span class="s6">*</span>
 <span class="s6">* To maintain consistency, we validate that any new mapping being added falls</span>
 <span class="s6">* in to one of these categories.</span>
 <span class="s6">*/ </span><span class="s0">SourceMapGenerator.prototype._validateMapping = </span><span class="s2">function </span><span class="s0">SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {</span>
    <span class="s6">// When aOriginal is truthy but has empty values for .line and .column,</span>
    <span class="s6">// it is most likely a programmer error. In this case we throw a very</span>
    <span class="s6">// specific error message to try to guide them the right way.</span>
    <span class="s6">// For example: https://github.com/Polymer/polymer-bundler/pull/519</span>
    <span class="s2">if </span><span class="s0">(aOriginal &amp;&amp; </span><span class="s2">typeof </span><span class="s0">aOriginal.line !== </span><span class="s1">'number' </span><span class="s0">&amp;&amp; </span><span class="s2">typeof </span><span class="s0">aOriginal.column !== </span><span class="s1">'number'</span><span class="s0">) {</span>
        <span class="s2">var </span><span class="s0">message = </span><span class="s1">'original.line and original.column are not numbers -- you probably meant to omit ' </span><span class="s0">+ </span><span class="s1">'the original mapping entirely and only map the generated position. If so, pass ' </span><span class="s0">+ </span><span class="s1">'null for the original mapping instead of an object with empty or null values.'</span><span class="s0">;</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">._ignoreInvalidMapping) {</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">console !== </span><span class="s1">'undefined' </span><span class="s0">&amp;&amp; console.warn) {</span>
                <span class="s0">console.warn(message);</span>
            <span class="s0">}</span>
            <span class="s2">return false</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">throw new </span><span class="s0">Error(message);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(aGenerated &amp;&amp; </span><span class="s1">'line' </span><span class="s2">in </span><span class="s0">aGenerated &amp;&amp; </span><span class="s1">'column' </span><span class="s2">in </span><span class="s0">aGenerated &amp;&amp; aGenerated.line &gt; </span><span class="s3">0 </span><span class="s0">&amp;&amp; aGenerated.column &gt;= </span><span class="s3">0 </span><span class="s0">&amp;&amp; !aOriginal &amp;&amp; !aSource &amp;&amp; !aName) {</span>
        <span class="s6">// Case 1.</span>
        <span class="s2">return</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(aGenerated &amp;&amp; </span><span class="s1">'line' </span><span class="s2">in </span><span class="s0">aGenerated &amp;&amp; </span><span class="s1">'column' </span><span class="s2">in </span><span class="s0">aGenerated &amp;&amp; aOriginal &amp;&amp; </span><span class="s1">'line' </span><span class="s2">in </span><span class="s0">aOriginal &amp;&amp; </span><span class="s1">'column' </span><span class="s2">in </span><span class="s0">aOriginal &amp;&amp; aGenerated.line &gt; </span><span class="s3">0 </span><span class="s0">&amp;&amp; aGenerated.column &gt;= </span><span class="s3">0 </span><span class="s0">&amp;&amp; aOriginal.line &gt; </span><span class="s3">0 </span><span class="s0">&amp;&amp; aOriginal.column &gt;= </span><span class="s3">0 </span><span class="s0">&amp;&amp; aSource) {</span>
        <span class="s6">// Cases 2 and 3.</span>
        <span class="s2">return</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s2">var </span><span class="s0">message = </span><span class="s1">'Invalid mapping: ' </span><span class="s0">+ JSON.stringify({</span>
            <span class="s0">generated: aGenerated,</span>
            <span class="s0">source: aSource,</span>
            <span class="s0">original: aOriginal,</span>
            <span class="s0">name: aName</span>
        <span class="s0">});</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">._ignoreInvalidMapping) {</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">console !== </span><span class="s1">'undefined' </span><span class="s0">&amp;&amp; console.warn) {</span>
                <span class="s0">console.warn(message);</span>
            <span class="s0">}</span>
            <span class="s2">return false</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">throw new </span><span class="s0">Error(message);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Serialize the accumulated mappings in to the stream of base 64 VLQs</span>
 <span class="s6">* specified by the source map format.</span>
 <span class="s6">*/ </span><span class="s0">SourceMapGenerator.prototype._serializeMappings = </span><span class="s2">function </span><span class="s0">SourceMapGenerator_serializeMappings() {</span>
    <span class="s2">var </span><span class="s0">previousGeneratedColumn = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">previousGeneratedLine = </span><span class="s3">1</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">previousOriginalColumn = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">previousOriginalLine = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">previousName = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">previousSource = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">result = </span><span class="s1">''</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">next;</span>
    <span class="s2">var </span><span class="s0">mapping;</span>
    <span class="s2">var </span><span class="s0">nameIdx;</span>
    <span class="s2">var </span><span class="s0">sourceIdx;</span>
    <span class="s2">var </span><span class="s0">mappings = </span><span class="s2">this</span><span class="s0">._mappings.toArray();</span>
    <span class="s2">for</span><span class="s0">(</span><span class="s2">var </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">, len = mappings.length; i &lt; len; i++){</span>
        <span class="s0">mapping = mappings[i];</span>
        <span class="s0">next = </span><span class="s1">''</span><span class="s0">;</span>
        <span class="s2">if </span><span class="s0">(mapping.generatedLine !== previousGeneratedLine) {</span>
            <span class="s0">previousGeneratedColumn = </span><span class="s3">0</span><span class="s0">;</span>
            <span class="s2">while</span><span class="s0">(mapping.generatedLine !== previousGeneratedLine){</span>
                <span class="s0">next += </span><span class="s1">';'</span><span class="s0">;</span>
                <span class="s0">previousGeneratedLine++;</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">if </span><span class="s0">(i &gt; </span><span class="s3">0</span><span class="s0">) {</span>
                <span class="s2">if </span><span class="s0">(!util.compareByGeneratedPositionsInflated(mapping, mappings[i - </span><span class="s3">1</span><span class="s0">])) {</span>
                    <span class="s2">continue</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">next += </span><span class="s1">','</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);</span>
        <span class="s0">previousGeneratedColumn = mapping.generatedColumn;</span>
        <span class="s2">if </span><span class="s0">(mapping.source != </span><span class="s2">null</span><span class="s0">) {</span>
            <span class="s0">sourceIdx = </span><span class="s2">this</span><span class="s0">._sources.indexOf(mapping.source);</span>
            <span class="s0">next += base64VLQ.encode(sourceIdx - previousSource);</span>
            <span class="s0">previousSource = sourceIdx;</span>
            <span class="s6">// lines are stored 0-based in SourceMap spec version 3</span>
            <span class="s0">next += base64VLQ.encode(mapping.originalLine - </span><span class="s3">1 </span><span class="s0">- previousOriginalLine);</span>
            <span class="s0">previousOriginalLine = mapping.originalLine - </span><span class="s3">1</span><span class="s0">;</span>
            <span class="s0">next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);</span>
            <span class="s0">previousOriginalColumn = mapping.originalColumn;</span>
            <span class="s2">if </span><span class="s0">(mapping.name != </span><span class="s2">null</span><span class="s0">) {</span>
                <span class="s0">nameIdx = </span><span class="s2">this</span><span class="s0">._names.indexOf(mapping.name);</span>
                <span class="s0">next += base64VLQ.encode(nameIdx - previousName);</span>
                <span class="s0">previousName = nameIdx;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">result += next;</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">result;</span>
<span class="s0">};</span>
<span class="s0">SourceMapGenerator.prototype._generateSourcesContent = </span><span class="s2">function </span><span class="s0">SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {</span>
    <span class="s2">return </span><span class="s0">aSources.map(</span><span class="s2">function</span><span class="s0">(source) {</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">._sourcesContents) {</span>
            <span class="s2">return null</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(aSourceRoot != </span><span class="s2">null</span><span class="s0">) {</span>
            <span class="s0">source = util.relative(aSourceRoot, source);</span>
        <span class="s0">}</span>
        <span class="s2">var </span><span class="s0">key = util.toSetString(source);</span>
        <span class="s2">return </span><span class="s0">Object.prototype.hasOwnProperty.call(</span><span class="s2">this</span><span class="s0">._sourcesContents, key) ? </span><span class="s2">this</span><span class="s0">._sourcesContents[key] : </span><span class="s2">null</span><span class="s0">;</span>
    <span class="s0">}, </span><span class="s2">this</span><span class="s0">);</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Externalize the source map.</span>
 <span class="s6">*/ </span><span class="s0">SourceMapGenerator.prototype.toJSON = </span><span class="s2">function </span><span class="s0">SourceMapGenerator_toJSON() {</span>
    <span class="s2">var </span><span class="s0">map = {</span>
        <span class="s0">version: </span><span class="s2">this</span><span class="s0">._version,</span>
        <span class="s0">sources: </span><span class="s2">this</span><span class="s0">._sources.toArray(),</span>
        <span class="s0">names: </span><span class="s2">this</span><span class="s0">._names.toArray(),</span>
        <span class="s0">mappings: </span><span class="s2">this</span><span class="s0">._serializeMappings()</span>
    <span class="s0">};</span>
    <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">._file != </span><span class="s2">null</span><span class="s0">) {</span>
        <span class="s0">map.file = </span><span class="s2">this</span><span class="s0">._file;</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">._sourceRoot != </span><span class="s2">null</span><span class="s0">) {</span>
        <span class="s0">map.sourceRoot = </span><span class="s2">this</span><span class="s0">._sourceRoot;</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">._sourcesContents) {</span>
        <span class="s0">map.sourcesContent = </span><span class="s2">this</span><span class="s0">._generateSourcesContent(map.sources, map.sourceRoot);</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">map;</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Render the source map being generated to a string.</span>
 <span class="s6">*/ </span><span class="s0">SourceMapGenerator.prototype.toString = </span><span class="s2">function </span><span class="s0">SourceMapGenerator_toString() {</span>
    <span class="s2">return </span><span class="s0">JSON.stringify(</span><span class="s2">this</span><span class="s0">.toJSON());</span>
<span class="s0">};</span>
<span class="s0">exports.SourceMapGenerator = SourceMapGenerator;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/source-map-js/lib/binary-search.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>

<span class="s6">/* -*- Mode: js; js-indent-level: 2; -*- */ /* 
 * Copyright 2011 Mozilla Foundation and contributors 
 * Licensed under the New BSD license. See LICENSE or: 
 * http://opensource.org/licenses/BSD-3-Clause 
 */ </span><span class="s0">exports.GREATEST_LOWER_BOUND = </span><span class="s3">1</span><span class="s0">;</span>
<span class="s0">exports.LEAST_UPPER_BOUND = </span><span class="s3">2</span><span class="s0">;</span>
<span class="s6">/**</span>
 <span class="s6">* Recursive implementation of binary search.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aLow Indices here and lower do not contain the needle.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aHigh Indices here and higher do not contain the needle.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aNeedle The element being searched for.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aHaystack The non-empty array being searched.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aCompare Function which takes two elements and returns -1, 0, or 1.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or</span>
 <span class="s6">*     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the</span>
 <span class="s6">*     closest element that is smaller than or greater than the one we are</span>
 <span class="s6">*     searching for, respectively, if the exact element cannot be found.</span>
 <span class="s6">*/ </span><span class="s2">function </span><span class="s0">recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {</span>
    <span class="s6">// This function terminates when one of the following is true:</span>
    <span class="s6">//</span>
    <span class="s6">//   1. We find the exact element we are looking for.</span>
    <span class="s6">//</span>
    <span class="s6">//   2. We did not find the exact element, but we can return the index of</span>
    <span class="s6">//      the next-closest element.</span>
    <span class="s6">//</span>
    <span class="s6">//   3. We did not find the exact element, and there is no next-closest</span>
    <span class="s6">//      element than the one we are searching for, so we return -1.</span>
    <span class="s2">var </span><span class="s0">mid = Math.floor((aHigh - aLow) / </span><span class="s3">2</span><span class="s0">) + aLow;</span>
    <span class="s2">var </span><span class="s0">cmp = aCompare(aNeedle, aHaystack[mid], </span><span class="s2">true</span><span class="s0">);</span>
    <span class="s2">if </span><span class="s0">(cmp === </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s6">// Found the element we are looking for.</span>
        <span class="s2">return </span><span class="s0">mid;</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(cmp &gt; </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s6">// Our needle is greater than aHaystack[mid].</span>
        <span class="s2">if </span><span class="s0">(aHigh - mid &gt; </span><span class="s3">1</span><span class="s0">) {</span>
            <span class="s6">// The element is in the upper half.</span>
            <span class="s2">return </span><span class="s0">recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);</span>
        <span class="s0">}</span>
        <span class="s6">// The exact needle element was not found in this haystack. Determine if</span>
        <span class="s6">// we are in termination case (3) or (2) and return the appropriate thing.</span>
        <span class="s2">if </span><span class="s0">(aBias == exports.LEAST_UPPER_BOUND) {</span>
            <span class="s2">return </span><span class="s0">aHigh &lt; aHaystack.length ? aHigh : -</span><span class="s3">1</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">return </span><span class="s0">mid;</span>
        <span class="s0">}</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s6">// Our needle is less than aHaystack[mid].</span>
        <span class="s2">if </span><span class="s0">(mid - aLow &gt; </span><span class="s3">1</span><span class="s0">) {</span>
            <span class="s6">// The element is in the lower half.</span>
            <span class="s2">return </span><span class="s0">recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);</span>
        <span class="s0">}</span>
        <span class="s6">// we are in termination case (3) or (2) and return the appropriate thing.</span>
        <span class="s2">if </span><span class="s0">(aBias == exports.LEAST_UPPER_BOUND) {</span>
            <span class="s2">return </span><span class="s0">mid;</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">return </span><span class="s0">aLow &lt; </span><span class="s3">0 </span><span class="s0">? -</span><span class="s3">1 </span><span class="s0">: aLow;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s6">/**</span>
 <span class="s6">* This is an implementation of binary search which will always try and return</span>
 <span class="s6">* the index of the closest element if there is no exact hit. This is because</span>
 <span class="s6">* mappings between original and generated line/col pairs are single points,</span>
 <span class="s6">* and there is an implicit region between each of them, so a miss just means</span>
 <span class="s6">* that you aren't on the very start of a region.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aNeedle The element you are looking for.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aHaystack The array that is being searched.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aCompare A function which takes the needle and an element in the</span>
 <span class="s6">*     array and returns -1, 0, or 1 depending on whether the needle is less</span>
 <span class="s6">*     than, equal to, or greater than the element, respectively.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or</span>
 <span class="s6">*     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the</span>
 <span class="s6">*     closest element that is smaller than or greater than the one we are</span>
 <span class="s6">*     searching for, respectively, if the exact element cannot be found.</span>
 <span class="s6">*     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.</span>
 <span class="s6">*/ </span><span class="s0">exports.search = </span><span class="s2">function </span><span class="s0">search(aNeedle, aHaystack, aCompare, aBias) {</span>
    <span class="s2">if </span><span class="s0">(aHaystack.length === </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">-</span><span class="s3">1</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s2">var </span><span class="s0">index = recursiveSearch(-</span><span class="s3">1</span><span class="s0">, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);</span>
    <span class="s2">if </span><span class="s0">(index &lt; </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">-</span><span class="s3">1</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s6">// We have found either the exact element, or the next-closest element than</span>
    <span class="s6">// the one we are searching for. However, there may be more than one such</span>
    <span class="s6">// element. Make sure we always return the smallest of these.</span>
    <span class="s2">while</span><span class="s0">(index - </span><span class="s3">1 </span><span class="s0">&gt;= </span><span class="s3">0</span><span class="s0">){</span>
        <span class="s2">if </span><span class="s0">(aCompare(aHaystack[index], aHaystack[index - </span><span class="s3">1</span><span class="s0">], </span><span class="s2">true</span><span class="s0">) !== </span><span class="s3">0</span><span class="s0">) {</span>
            <span class="s2">break</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">--index;</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">index;</span>
<span class="s0">};</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/source-map-js/lib/quick-sort.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>

<span class="s6">/* -*- Mode: js; js-indent-level: 2; -*- */ /* 
 * Copyright 2011 Mozilla Foundation and contributors 
 * Licensed under the New BSD license. See LICENSE or: 
 * http://opensource.org/licenses/BSD-3-Clause 
 */ // It turns out that some (most?) JavaScript engines don't self-host</span>
<span class="s6">// `Array.prototype.sort`. This makes sense because C++ will likely remain</span>
<span class="s6">// faster than JS when doing raw CPU-intensive sorting. However, when using a</span>
<span class="s6">// custom comparator function, calling back and forth between the VM's C++ and</span>
<span class="s6">// JIT'd JS is rather slow *and* loses JIT type information, resulting in</span>
<span class="s6">// worse generated code for the comparator function than would be optimal. In</span>
<span class="s6">// fact, when sorting with a comparator, these costs outweigh the benefits of</span>
<span class="s6">// sorting in C++. By using our own JS-implemented Quick Sort (below), we get</span>
<span class="s6">// a ~3500ms mean speed-up in `bench/bench.html`.</span>
<span class="s2">function </span><span class="s0">SortTemplate(comparator) {</span>
    <span class="s6">/**</span>
 <span class="s6">* Swap the elements indexed by `x` and `y` in the array `ary`.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Array} ary</span>
 <span class="s6">*        The array.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Number} x</span>
 <span class="s6">*        The index of the first item.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Number} y</span>
 <span class="s6">*        The index of the second item.</span>
 <span class="s6">*/ </span><span class="s2">function </span><span class="s0">swap(ary, x, y) {</span>
        <span class="s2">var </span><span class="s0">temp = ary[x];</span>
        <span class="s0">ary[x] = ary[y];</span>
        <span class="s0">ary[y] = temp;</span>
    <span class="s0">}</span>
    <span class="s6">/**</span>
 <span class="s6">* Returns a random integer within the range `low .. high` inclusive.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Number} low</span>
 <span class="s6">*        The lower bound on the range.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Number} high</span>
 <span class="s6">*        The upper bound on the range.</span>
 <span class="s6">*/ </span><span class="s2">function </span><span class="s0">randomIntInRange(low, high) {</span>
        <span class="s2">return </span><span class="s0">Math.round(low + Math.random() * (high - low));</span>
    <span class="s0">}</span>
    <span class="s6">/**</span>
 <span class="s6">* The Quick Sort algorithm.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Array} ary</span>
 <span class="s6">*        An array to sort.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{function} comparator</span>
 <span class="s6">*        Function to use to compare two items.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Number} p</span>
 <span class="s6">*        Start index of the array</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Number} r</span>
 <span class="s6">*        End index of the array</span>
 <span class="s6">*/ </span><span class="s2">function </span><span class="s0">doQuickSort(ary, comparator, p, r) {</span>
        <span class="s6">// If our lower bound is less than our upper bound, we (1) partition the</span>
        <span class="s6">// array into two pieces and (2) recurse on each half. If it is not, this is</span>
        <span class="s6">// the empty array and our base case.</span>
        <span class="s2">if </span><span class="s0">(p &lt; r) {</span>
            <span class="s6">// (1) Partitioning.</span>
            <span class="s6">//</span>
            <span class="s6">// The partitioning chooses a pivot between `p` and `r` and moves all</span>
            <span class="s6">// elements that are less than or equal to the pivot to the before it, and</span>
            <span class="s6">// all the elements that are greater than it after it. The effect is that</span>
            <span class="s6">// once partition is done, the pivot is in the exact place it will be when</span>
            <span class="s6">// the array is put in sorted order, and it will not need to be moved</span>
            <span class="s6">// again. This runs in O(n) time.</span>
            <span class="s6">// Always choose a random pivot so that an input array which is reverse</span>
            <span class="s6">// sorted does not cause O(n^2) running time.</span>
            <span class="s2">var </span><span class="s0">pivotIndex = randomIntInRange(p, r);</span>
            <span class="s2">var </span><span class="s0">i = p - </span><span class="s3">1</span><span class="s0">;</span>
            <span class="s0">swap(ary, pivotIndex, r);</span>
            <span class="s2">var </span><span class="s0">pivot = ary[r];</span>
            <span class="s6">// Immediately after `j` is incremented in this loop, the following hold</span>
            <span class="s6">// true:</span>
            <span class="s6">//</span>
            <span class="s6">//   * Every element in `ary[p .. i]` is less than or equal to the pivot.</span>
            <span class="s6">//</span>
            <span class="s6">//   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.</span>
            <span class="s2">for</span><span class="s0">(</span><span class="s2">var </span><span class="s0">j = p; j &lt; r; j++){</span>
                <span class="s2">if </span><span class="s0">(comparator(ary[j], pivot, </span><span class="s2">false</span><span class="s0">) &lt;= </span><span class="s3">0</span><span class="s0">) {</span>
                    <span class="s0">i += </span><span class="s3">1</span><span class="s0">;</span>
                    <span class="s0">swap(ary, i, j);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">swap(ary, i + </span><span class="s3">1</span><span class="s0">, j);</span>
            <span class="s2">var </span><span class="s0">q = i + </span><span class="s3">1</span><span class="s0">;</span>
            <span class="s6">// (2) Recurse on each half.</span>
            <span class="s0">doQuickSort(ary, comparator, p, q - </span><span class="s3">1</span><span class="s0">);</span>
            <span class="s0">doQuickSort(ary, comparator, q + </span><span class="s3">1</span><span class="s0">, r);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">doQuickSort;</span>
<span class="s0">}</span>
<span class="s2">function </span><span class="s0">cloneSort(comparator) {</span>
    <span class="s2">let </span><span class="s0">template = SortTemplate.toString();</span>
    <span class="s2">let </span><span class="s0">templateFn = </span><span class="s2">new </span><span class="s0">Function(</span><span class="s1">`return </span><span class="s0">${template}</span><span class="s1">`</span><span class="s0">)();</span>
    <span class="s2">return </span><span class="s0">templateFn(comparator);</span>
<span class="s0">}</span>
<span class="s6">/**</span>
 <span class="s6">* Sort the given array in-place with the given comparator function.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Array} ary</span>
 <span class="s6">*        An array to sort.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{function} comparator</span>
 <span class="s6">*        Function to use to compare two items.</span>
 <span class="s6">*/ </span><span class="s2">let </span><span class="s0">sortCache = </span><span class="s2">new </span><span class="s0">WeakMap();</span>
<span class="s0">exports.quickSort = </span><span class="s2">function</span><span class="s0">(ary, comparator, start = </span><span class="s3">0</span><span class="s0">) {</span>
    <span class="s2">let </span><span class="s0">doQuickSort = sortCache.get(comparator);</span>
    <span class="s2">if </span><span class="s0">(doQuickSort === </span><span class="s2">void </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s0">doQuickSort = cloneSort(comparator);</span>
        <span class="s0">sortCache.set(comparator, doQuickSort);</span>
    <span class="s0">}</span>
    <span class="s0">doQuickSort(ary, comparator, start, ary.length - </span><span class="s3">1</span><span class="s0">);</span>
<span class="s0">};</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/source-map-js/lib/source-map-consumer.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>

<span class="s6">/* -*- Mode: js; js-indent-level: 2; -*- */ /* 
 * Copyright 2011 Mozilla Foundation and contributors 
 * Licensed under the New BSD license. See LICENSE or: 
 * http://opensource.org/licenses/BSD-3-Clause 
 */ </span><span class="s2">var </span><span class="s0">util = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">var </span><span class="s0">binarySearch = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/source-map-js/lib/binary-search.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">var </span><span class="s0">ArraySet = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/source-map-js/lib/array-set.js [postcss] (ecmascript)&quot;</span><span class="s0">).ArraySet;</span>
<span class="s2">var </span><span class="s0">base64VLQ = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/source-map-js/lib/base64-vlq.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">var </span><span class="s0">quickSort = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/source-map-js/lib/quick-sort.js [postcss] (ecmascript)&quot;</span><span class="s0">).quickSort;</span>
<span class="s2">function </span><span class="s0">SourceMapConsumer(aSourceMap, aSourceMapURL) {</span>
    <span class="s2">var </span><span class="s0">sourceMap = aSourceMap;</span>
    <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">aSourceMap === </span><span class="s1">'string'</span><span class="s0">) {</span>
        <span class="s0">sourceMap = util.parseSourceMapInput(aSourceMap);</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">sourceMap.sections != </span><span class="s2">null </span><span class="s0">? </span><span class="s2">new </span><span class="s0">IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : </span><span class="s2">new </span><span class="s0">BasicSourceMapConsumer(sourceMap, aSourceMapURL);</span>
<span class="s0">}</span>
<span class="s0">SourceMapConsumer.fromSourceMap = </span><span class="s2">function</span><span class="s0">(aSourceMap, aSourceMapURL) {</span>
    <span class="s2">return </span><span class="s0">BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* The version of the source mapping spec that we are consuming.</span>
 <span class="s6">*/ </span><span class="s0">SourceMapConsumer.prototype._version = </span><span class="s3">3</span><span class="s0">;</span>
<span class="s6">// `__generatedMappings` and `__originalMappings` are arrays that hold the</span>
<span class="s6">// parsed mapping coordinates from the source map's &quot;mappings&quot; attribute. They</span>
<span class="s6">// are lazily instantiated, accessed via the `_generatedMappings` and</span>
<span class="s6">// `_originalMappings` getters respectively, and we only parse the mappings</span>
<span class="s6">// and create these arrays once queried for a source location. We jump through</span>
<span class="s6">// these hoops because there can be many thousands of mappings, and parsing</span>
<span class="s6">// them is expensive, so we only want to do it if we must.</span>
<span class="s6">//</span>
<span class="s6">// Each object in the arrays is of the form:</span>
<span class="s6">//</span>
<span class="s6">//     {</span>
<span class="s6">//       generatedLine: The line number in the generated code,</span>
<span class="s6">//       generatedColumn: The column number in the generated code,</span>
<span class="s6">//       source: The path to the original source file that generated this</span>
<span class="s6">//               chunk of code,</span>
<span class="s6">//       originalLine: The line number in the original source that</span>
<span class="s6">//                     corresponds to this chunk of generated code,</span>
<span class="s6">//       originalColumn: The column number in the original source that</span>
<span class="s6">//                       corresponds to this chunk of generated code,</span>
<span class="s6">//       name: The name of the original symbol which generated this chunk of</span>
<span class="s6">//             code.</span>
<span class="s6">//     }</span>
<span class="s6">//</span>
<span class="s6">// All properties except for `generatedLine` and `generatedColumn` can be</span>
<span class="s6">// `null`.</span>
<span class="s6">//</span>
<span class="s6">// `_generatedMappings` is ordered by the generated positions.</span>
<span class="s6">//</span>
<span class="s6">// `_originalMappings` is ordered by the original positions.</span>
<span class="s0">SourceMapConsumer.prototype.__generatedMappings = </span><span class="s2">null</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(SourceMapConsumer.prototype, </span><span class="s1">'_generatedMappings'</span><span class="s0">, {</span>
    <span class="s0">configurable: </span><span class="s2">true</span><span class="s0">,</span>
    <span class="s0">enumerable: </span><span class="s2">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s2">function</span><span class="s0">() {</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.__generatedMappings) {</span>
            <span class="s2">this</span><span class="s0">._parseMappings(</span><span class="s2">this</span><span class="s0">._mappings, </span><span class="s2">this</span><span class="s0">.sourceRoot);</span>
        <span class="s0">}</span>
        <span class="s2">return this</span><span class="s0">.__generatedMappings;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s0">SourceMapConsumer.prototype.__originalMappings = </span><span class="s2">null</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(SourceMapConsumer.prototype, </span><span class="s1">'_originalMappings'</span><span class="s0">, {</span>
    <span class="s0">configurable: </span><span class="s2">true</span><span class="s0">,</span>
    <span class="s0">enumerable: </span><span class="s2">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s2">function</span><span class="s0">() {</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.__originalMappings) {</span>
            <span class="s2">this</span><span class="s0">._parseMappings(</span><span class="s2">this</span><span class="s0">._mappings, </span><span class="s2">this</span><span class="s0">.sourceRoot);</span>
        <span class="s0">}</span>
        <span class="s2">return this</span><span class="s0">.__originalMappings;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s0">SourceMapConsumer.prototype._charIsMappingSeparator = </span><span class="s2">function </span><span class="s0">SourceMapConsumer_charIsMappingSeparator(aStr, index) {</span>
    <span class="s2">var </span><span class="s0">c = aStr.charAt(index);</span>
    <span class="s2">return </span><span class="s0">c === </span><span class="s1">&quot;;&quot; </span><span class="s0">|| c === </span><span class="s1">&quot;,&quot;</span><span class="s0">;</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Parse the mappings in a string in to a data structure which we can easily</span>
 <span class="s6">* query (the ordered arrays in the `this.__generatedMappings` and</span>
 <span class="s6">* `this.__originalMappings` properties).</span>
 <span class="s6">*/ </span><span class="s0">SourceMapConsumer.prototype._parseMappings = </span><span class="s2">function </span><span class="s0">SourceMapConsumer_parseMappings(aStr, aSourceRoot) {</span>
    <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">&quot;Subclasses must implement _parseMappings&quot;</span><span class="s0">);</span>
<span class="s0">};</span>
<span class="s0">SourceMapConsumer.GENERATED_ORDER = </span><span class="s3">1</span><span class="s0">;</span>
<span class="s0">SourceMapConsumer.ORIGINAL_ORDER = </span><span class="s3">2</span><span class="s0">;</span>
<span class="s0">SourceMapConsumer.GREATEST_LOWER_BOUND = </span><span class="s3">1</span><span class="s0">;</span>
<span class="s0">SourceMapConsumer.LEAST_UPPER_BOUND = </span><span class="s3">2</span><span class="s0">;</span>
<span class="s6">/**</span>
 <span class="s6">* Iterate over each mapping between an original source/line/column and a</span>
 <span class="s6">* generated line/column in this source map.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">Function aCallback</span>
 <span class="s6">*        The function that is called with each mapping.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">Object aContext</span>
 <span class="s6">*        Optional. If specified, this object will be the value of `this` every</span>
 <span class="s6">*        time that `aCallback` is called.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aOrder</span>
 <span class="s6">*        Either `SourceMapConsumer.GENERATED_ORDER` or</span>
 <span class="s6">*        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to</span>
 <span class="s6">*        iterate over the mappings sorted by the generated file's line/column</span>
 <span class="s6">*        order or the original's source/line/column order, respectively. Defaults to</span>
 <span class="s6">*        `SourceMapConsumer.GENERATED_ORDER`.</span>
 <span class="s6">*/ </span><span class="s0">SourceMapConsumer.prototype.eachMapping = </span><span class="s2">function </span><span class="s0">SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {</span>
    <span class="s2">var </span><span class="s0">context = aContext || </span><span class="s2">null</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">order = aOrder || SourceMapConsumer.GENERATED_ORDER;</span>
    <span class="s2">var </span><span class="s0">mappings;</span>
    <span class="s2">switch</span><span class="s0">(order){</span>
        <span class="s2">case </span><span class="s0">SourceMapConsumer.GENERATED_ORDER:</span>
            <span class="s0">mappings = </span><span class="s2">this</span><span class="s0">._generatedMappings;</span>
            <span class="s2">break</span><span class="s0">;</span>
        <span class="s2">case </span><span class="s0">SourceMapConsumer.ORIGINAL_ORDER:</span>
            <span class="s0">mappings = </span><span class="s2">this</span><span class="s0">._originalMappings;</span>
            <span class="s2">break</span><span class="s0">;</span>
        <span class="s2">default</span><span class="s0">:</span>
            <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">&quot;Unknown order of iteration.&quot;</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s2">var </span><span class="s0">sourceRoot = </span><span class="s2">this</span><span class="s0">.sourceRoot;</span>
    <span class="s2">var </span><span class="s0">boundCallback = aCallback.bind(context);</span>
    <span class="s2">var </span><span class="s0">names = </span><span class="s2">this</span><span class="s0">._names;</span>
    <span class="s2">var </span><span class="s0">sources = </span><span class="s2">this</span><span class="s0">._sources;</span>
    <span class="s2">var </span><span class="s0">sourceMapURL = </span><span class="s2">this</span><span class="s0">._sourceMapURL;</span>
    <span class="s2">for</span><span class="s0">(</span><span class="s2">var </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">, n = mappings.length; i &lt; n; i++){</span>
        <span class="s2">var </span><span class="s0">mapping = mappings[i];</span>
        <span class="s2">var </span><span class="s0">source = mapping.source === </span><span class="s2">null </span><span class="s0">? </span><span class="s2">null </span><span class="s0">: sources.at(mapping.source);</span>
        <span class="s2">if </span><span class="s0">(source !== </span><span class="s2">null</span><span class="s0">) {</span>
            <span class="s0">source = util.computeSourceURL(sourceRoot, source, sourceMapURL);</span>
        <span class="s0">}</span>
        <span class="s0">boundCallback({</span>
            <span class="s0">source: source,</span>
            <span class="s0">generatedLine: mapping.generatedLine,</span>
            <span class="s0">generatedColumn: mapping.generatedColumn,</span>
            <span class="s0">originalLine: mapping.originalLine,</span>
            <span class="s0">originalColumn: mapping.originalColumn,</span>
            <span class="s0">name: mapping.name === </span><span class="s2">null </span><span class="s0">? </span><span class="s2">null </span><span class="s0">: names.at(mapping.name)</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Returns all generated line and column information for the original source,</span>
 <span class="s6">* line, and column provided. If no column is provided, returns all mappings</span>
 <span class="s6">* corresponding to a either the line we are searching for or the next</span>
 <span class="s6">* closest line that has any mappings. Otherwise, returns all mappings</span>
 <span class="s6">* corresponding to the given line and either the column we are searching for</span>
 <span class="s6">* or the next closest column that has any offsets.</span>
 <span class="s6">*</span>
 <span class="s6">* The only argument is an object with the following properties:</span>
 <span class="s6">*</span>
 <span class="s6">*   - source: The filename of the original source.</span>
 <span class="s6">*   - line: The line number in the original source.  The line number is 1-based.</span>
 <span class="s6">*   - column: Optional. the column number in the original source.</span>
 <span class="s6">*    The column number is 0-based.</span>
 <span class="s6">*</span>
 <span class="s6">* and an array of objects is returned, each with the following properties:</span>
 <span class="s6">*</span>
 <span class="s6">*   - line: The line number in the generated source, or null.  The</span>
 <span class="s6">*    line number is 1-based.</span>
 <span class="s6">*   - column: The column number in the generated source, or null.</span>
 <span class="s6">*    The column number is 0-based.</span>
 <span class="s6">*/ </span><span class="s0">SourceMapConsumer.prototype.allGeneratedPositionsFor = </span><span class="s2">function </span><span class="s0">SourceMapConsumer_allGeneratedPositionsFor(aArgs) {</span>
    <span class="s2">var </span><span class="s0">line = util.getArg(aArgs, </span><span class="s1">'line'</span><span class="s0">);</span>
    <span class="s6">// When there is no exact match, BasicSourceMapConsumer.prototype._findMapping</span>
    <span class="s6">// returns the index of the closest mapping less than the needle. By</span>
    <span class="s6">// setting needle.originalColumn to 0, we thus find the last mapping for</span>
    <span class="s6">// the given line, provided such a mapping exists.</span>
    <span class="s2">var </span><span class="s0">needle = {</span>
        <span class="s0">source: util.getArg(aArgs, </span><span class="s1">'source'</span><span class="s0">),</span>
        <span class="s0">originalLine: line,</span>
        <span class="s0">originalColumn: util.getArg(aArgs, </span><span class="s1">'column'</span><span class="s0">, </span><span class="s3">0</span><span class="s0">)</span>
    <span class="s0">};</span>
    <span class="s0">needle.source = </span><span class="s2">this</span><span class="s0">._findSourceIndex(needle.source);</span>
    <span class="s2">if </span><span class="s0">(needle.source &lt; </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">[];</span>
    <span class="s0">}</span>
    <span class="s2">var </span><span class="s0">mappings = [];</span>
    <span class="s2">var </span><span class="s0">index = </span><span class="s2">this</span><span class="s0">._findMapping(needle, </span><span class="s2">this</span><span class="s0">._originalMappings, </span><span class="s1">&quot;originalLine&quot;</span><span class="s0">, </span><span class="s1">&quot;originalColumn&quot;</span><span class="s0">, util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);</span>
    <span class="s2">if </span><span class="s0">(index &gt;= </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">var </span><span class="s0">mapping = </span><span class="s2">this</span><span class="s0">._originalMappings[index];</span>
        <span class="s2">if </span><span class="s0">(aArgs.column === undefined) {</span>
            <span class="s2">var </span><span class="s0">originalLine = mapping.originalLine;</span>
            <span class="s6">// Iterate until either we run out of mappings, or we run into</span>
            <span class="s6">// a mapping for a different line than the one we found. Since</span>
            <span class="s6">// mappings are sorted, this is guaranteed to find all mappings for</span>
            <span class="s6">// the line we found.</span>
            <span class="s2">while</span><span class="s0">(mapping &amp;&amp; mapping.originalLine === originalLine){</span>
                <span class="s0">mappings.push({</span>
                    <span class="s0">line: util.getArg(mapping, </span><span class="s1">'generatedLine'</span><span class="s0">, </span><span class="s2">null</span><span class="s0">),</span>
                    <span class="s0">column: util.getArg(mapping, </span><span class="s1">'generatedColumn'</span><span class="s0">, </span><span class="s2">null</span><span class="s0">),</span>
                    <span class="s0">lastColumn: util.getArg(mapping, </span><span class="s1">'lastGeneratedColumn'</span><span class="s0">, </span><span class="s2">null</span><span class="s0">)</span>
                <span class="s0">});</span>
                <span class="s0">mapping = </span><span class="s2">this</span><span class="s0">._originalMappings[++index];</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">var </span><span class="s0">originalColumn = mapping.originalColumn;</span>
            <span class="s6">// Iterate until either we run out of mappings, or we run into</span>
            <span class="s6">// a mapping for a different line than the one we were searching for.</span>
            <span class="s6">// Since mappings are sorted, this is guaranteed to find all mappings for</span>
            <span class="s6">// the line we are searching for.</span>
            <span class="s2">while</span><span class="s0">(mapping &amp;&amp; mapping.originalLine === line &amp;&amp; mapping.originalColumn == originalColumn){</span>
                <span class="s0">mappings.push({</span>
                    <span class="s0">line: util.getArg(mapping, </span><span class="s1">'generatedLine'</span><span class="s0">, </span><span class="s2">null</span><span class="s0">),</span>
                    <span class="s0">column: util.getArg(mapping, </span><span class="s1">'generatedColumn'</span><span class="s0">, </span><span class="s2">null</span><span class="s0">),</span>
                    <span class="s0">lastColumn: util.getArg(mapping, </span><span class="s1">'lastGeneratedColumn'</span><span class="s0">, </span><span class="s2">null</span><span class="s0">)</span>
                <span class="s0">});</span>
                <span class="s0">mapping = </span><span class="s2">this</span><span class="s0">._originalMappings[++index];</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">mappings;</span>
<span class="s0">};</span>
<span class="s0">exports.SourceMapConsumer = SourceMapConsumer;</span>
<span class="s6">/**</span>
 <span class="s6">* A BasicSourceMapConsumer instance represents a parsed source map which we can</span>
 <span class="s6">* query for information about the original file positions by giving it a file</span>
 <span class="s6">* position in the generated source.</span>
 <span class="s6">*</span>
 <span class="s6">* The first parameter is the raw source map (either as a JSON string, or</span>
 <span class="s6">* already parsed to an object). According to the spec, source maps have the</span>
 <span class="s6">* following attributes:</span>
 <span class="s6">*</span>
 <span class="s6">*   - version: Which version of the source map spec this map is following.</span>
 <span class="s6">*   - sources: An array of URLs to the original source files.</span>
 <span class="s6">*   - names: An array of identifiers which can be referrenced by individual mappings.</span>
 <span class="s6">*   - sourceRoot: Optional. The URL root from which all sources are relative.</span>
 <span class="s6">*   - sourcesContent: Optional. An array of contents of the original source files.</span>
 <span class="s6">*   - mappings: A string of base64 VLQs which contain the actual mappings.</span>
 <span class="s6">*   - file: Optional. The generated file this source map is associated with.</span>
 <span class="s6">*</span>
 <span class="s6">* Here is an example source map, taken from the source map spec[0]:</span>
 <span class="s6">*</span>
 <span class="s6">*     {</span>
 <span class="s6">*       version : 3,</span>
 <span class="s6">*       file: &quot;out.js&quot;,</span>
 <span class="s6">*       sourceRoot : &quot;&quot;,</span>
 <span class="s6">*       sources: [&quot;foo.js&quot;, &quot;bar.js&quot;],</span>
 <span class="s6">*       names: [&quot;src&quot;, &quot;maps&quot;, &quot;are&quot;, &quot;fun&quot;],</span>
 <span class="s6">*       mappings: &quot;AA,AB;;ABCDE;&quot;</span>
 <span class="s6">*     }</span>
 <span class="s6">*</span>
 <span class="s6">* The second parameter, if given, is a string whose value is the URL</span>
 <span class="s6">* at which the source map was found.  This URL is used to compute the</span>
 <span class="s6">* sources array.</span>
 <span class="s6">*</span>
 <span class="s6">* [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#</span>
 <span class="s6">*/ </span><span class="s2">function </span><span class="s0">BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {</span>
    <span class="s2">var </span><span class="s0">sourceMap = aSourceMap;</span>
    <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">aSourceMap === </span><span class="s1">'string'</span><span class="s0">) {</span>
        <span class="s0">sourceMap = util.parseSourceMapInput(aSourceMap);</span>
    <span class="s0">}</span>
    <span class="s2">var </span><span class="s0">version = util.getArg(sourceMap, </span><span class="s1">'version'</span><span class="s0">);</span>
    <span class="s2">var </span><span class="s0">sources = util.getArg(sourceMap, </span><span class="s1">'sources'</span><span class="s0">);</span>
    <span class="s6">// Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which</span>
    <span class="s6">// requires the array) to play nice here.</span>
    <span class="s2">var </span><span class="s0">names = util.getArg(sourceMap, </span><span class="s1">'names'</span><span class="s0">, []);</span>
    <span class="s2">var </span><span class="s0">sourceRoot = util.getArg(sourceMap, </span><span class="s1">'sourceRoot'</span><span class="s0">, </span><span class="s2">null</span><span class="s0">);</span>
    <span class="s2">var </span><span class="s0">sourcesContent = util.getArg(sourceMap, </span><span class="s1">'sourcesContent'</span><span class="s0">, </span><span class="s2">null</span><span class="s0">);</span>
    <span class="s2">var </span><span class="s0">mappings = util.getArg(sourceMap, </span><span class="s1">'mappings'</span><span class="s0">);</span>
    <span class="s2">var </span><span class="s0">file = util.getArg(sourceMap, </span><span class="s1">'file'</span><span class="s0">, </span><span class="s2">null</span><span class="s0">);</span>
    <span class="s6">// Once again, Sass deviates from the spec and supplies the version as a</span>
    <span class="s6">// string rather than a number, so we use loose equality checking here.</span>
    <span class="s2">if </span><span class="s0">(version != </span><span class="s2">this</span><span class="s0">._version) {</span>
        <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">'Unsupported version: ' </span><span class="s0">+ version);</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(sourceRoot) {</span>
        <span class="s0">sourceRoot = util.normalize(sourceRoot);</span>
    <span class="s0">}</span>
    <span class="s0">sources = sources.map(String)</span><span class="s6">// Some source maps produce relative source paths like &quot;./foo.js&quot; instead of</span>
    <span class="s6">// &quot;foo.js&quot;.  Normalize these first so that future comparisons will succeed.</span>
    <span class="s6">// See bugzil.la/1090768.</span>
    <span class="s0">.map(util.normalize)</span><span class="s6">// Always ensure that absolute sources are internally stored relative to</span>
    <span class="s6">// the source root, if the source root is absolute. Not doing this would</span>
    <span class="s6">// be particularly problematic when the source root is a prefix of the</span>
    <span class="s6">// source (valid, but why??). See github issue #199 and bugzil.la/1188982.</span>
    <span class="s0">.map(</span><span class="s2">function</span><span class="s0">(source) {</span>
        <span class="s2">return </span><span class="s0">sourceRoot &amp;&amp; util.isAbsolute(sourceRoot) &amp;&amp; util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;</span>
    <span class="s0">});</span>
    <span class="s6">// Pass `true` below to allow duplicate names and sources. While source maps</span>
    <span class="s6">// are intended to be compressed and deduplicated, the TypeScript compiler</span>
    <span class="s6">// sometimes generates source maps with duplicates in them. See Github issue</span>
    <span class="s6">// #72 and bugzil.la/889492.</span>
    <span class="s2">this</span><span class="s0">._names = ArraySet.fromArray(names.map(String), </span><span class="s2">true</span><span class="s0">);</span>
    <span class="s2">this</span><span class="s0">._sources = ArraySet.fromArray(sources, </span><span class="s2">true</span><span class="s0">);</span>
    <span class="s2">this</span><span class="s0">._absoluteSources = </span><span class="s2">this</span><span class="s0">._sources.toArray().map(</span><span class="s2">function</span><span class="s0">(s) {</span>
        <span class="s2">return </span><span class="s0">util.computeSourceURL(sourceRoot, s, aSourceMapURL);</span>
    <span class="s0">});</span>
    <span class="s2">this</span><span class="s0">.sourceRoot = sourceRoot;</span>
    <span class="s2">this</span><span class="s0">.sourcesContent = sourcesContent;</span>
    <span class="s2">this</span><span class="s0">._mappings = mappings;</span>
    <span class="s2">this</span><span class="s0">._sourceMapURL = aSourceMapURL;</span>
    <span class="s2">this</span><span class="s0">.file = file;</span>
<span class="s0">}</span>
<span class="s0">BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);</span>
<span class="s0">BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;</span>
<span class="s6">/**</span>
 <span class="s6">* Utility function to find the index of a source.  Returns -1 if not</span>
 <span class="s6">* found.</span>
 <span class="s6">*/ </span><span class="s0">BasicSourceMapConsumer.prototype._findSourceIndex = </span><span class="s2">function</span><span class="s0">(aSource) {</span>
    <span class="s2">var </span><span class="s0">relativeSource = aSource;</span>
    <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.sourceRoot != </span><span class="s2">null</span><span class="s0">) {</span>
        <span class="s0">relativeSource = util.relative(</span><span class="s2">this</span><span class="s0">.sourceRoot, relativeSource);</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">._sources.has(relativeSource)) {</span>
        <span class="s2">return this</span><span class="s0">._sources.indexOf(relativeSource);</span>
    <span class="s0">}</span>
    <span class="s6">// Maybe aSource is an absolute URL as returned by |sources|.  In</span>
    <span class="s6">// this case we can't simply undo the transform.</span>
    <span class="s2">var </span><span class="s0">i;</span>
    <span class="s2">for</span><span class="s0">(i = </span><span class="s3">0</span><span class="s0">; i &lt; </span><span class="s2">this</span><span class="s0">._absoluteSources.length; ++i){</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">._absoluteSources[i] == aSource) {</span>
            <span class="s2">return </span><span class="s0">i;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">-</span><span class="s3">1</span><span class="s0">;</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Create a BasicSourceMapConsumer from a SourceMapGenerator.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">SourceMapGenerator aSourceMap</span>
 <span class="s6">*        The source map that will be consumed.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">String aSourceMapURL</span>
 <span class="s6">*        The URL at which the source map can be found (optional)</span>
 <span class="s6">* </span><span class="s7">@returns </span><span class="s6">BasicSourceMapConsumer</span>
 <span class="s6">*/ </span><span class="s0">BasicSourceMapConsumer.fromSourceMap = </span><span class="s2">function </span><span class="s0">SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {</span>
    <span class="s2">var </span><span class="s0">smc = Object.create(BasicSourceMapConsumer.prototype);</span>
    <span class="s2">var </span><span class="s0">names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), </span><span class="s2">true</span><span class="s0">);</span>
    <span class="s2">var </span><span class="s0">sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), </span><span class="s2">true</span><span class="s0">);</span>
    <span class="s0">smc.sourceRoot = aSourceMap._sourceRoot;</span>
    <span class="s0">smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);</span>
    <span class="s0">smc.file = aSourceMap._file;</span>
    <span class="s0">smc._sourceMapURL = aSourceMapURL;</span>
    <span class="s0">smc._absoluteSources = smc._sources.toArray().map(</span><span class="s2">function</span><span class="s0">(s) {</span>
        <span class="s2">return </span><span class="s0">util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);</span>
    <span class="s0">});</span>
    <span class="s6">// Because we are modifying the entries (by converting string sources and</span>
    <span class="s6">// names to indices into the sources and names ArraySets), we have to make</span>
    <span class="s6">// a copy of the entry or else bad things happen. Shared mutable state</span>
    <span class="s6">// strikes again! See github issue #191.</span>
    <span class="s2">var </span><span class="s0">generatedMappings = aSourceMap._mappings.toArray().slice();</span>
    <span class="s2">var </span><span class="s0">destGeneratedMappings = smc.__generatedMappings = [];</span>
    <span class="s2">var </span><span class="s0">destOriginalMappings = smc.__originalMappings = [];</span>
    <span class="s2">for</span><span class="s0">(</span><span class="s2">var </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">, length = generatedMappings.length; i &lt; length; i++){</span>
        <span class="s2">var </span><span class="s0">srcMapping = generatedMappings[i];</span>
        <span class="s2">var </span><span class="s0">destMapping = </span><span class="s2">new </span><span class="s0">Mapping;</span>
        <span class="s0">destMapping.generatedLine = srcMapping.generatedLine;</span>
        <span class="s0">destMapping.generatedColumn = srcMapping.generatedColumn;</span>
        <span class="s2">if </span><span class="s0">(srcMapping.source) {</span>
            <span class="s0">destMapping.source = sources.indexOf(srcMapping.source);</span>
            <span class="s0">destMapping.originalLine = srcMapping.originalLine;</span>
            <span class="s0">destMapping.originalColumn = srcMapping.originalColumn;</span>
            <span class="s2">if </span><span class="s0">(srcMapping.name) {</span>
                <span class="s0">destMapping.name = names.indexOf(srcMapping.name);</span>
            <span class="s0">}</span>
            <span class="s0">destOriginalMappings.push(destMapping);</span>
        <span class="s0">}</span>
        <span class="s0">destGeneratedMappings.push(destMapping);</span>
    <span class="s0">}</span>
    <span class="s0">quickSort(smc.__originalMappings, util.compareByOriginalPositions);</span>
    <span class="s2">return </span><span class="s0">smc;</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* The version of the source mapping spec that we are consuming.</span>
 <span class="s6">*/ </span><span class="s0">BasicSourceMapConsumer.prototype._version = </span><span class="s3">3</span><span class="s0">;</span>
<span class="s6">/**</span>
 <span class="s6">* The list of original sources.</span>
 <span class="s6">*/ </span><span class="s0">Object.defineProperty(BasicSourceMapConsumer.prototype, </span><span class="s1">'sources'</span><span class="s0">, {</span>
    <span class="s0">get: </span><span class="s2">function</span><span class="s0">() {</span>
        <span class="s2">return this</span><span class="s0">._absoluteSources.slice();</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s6">/**</span>
 <span class="s6">* Provide the JIT with a nice shape / hidden class.</span>
 <span class="s6">*/ </span><span class="s2">function </span><span class="s0">Mapping() {</span>
    <span class="s2">this</span><span class="s0">.generatedLine = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">this</span><span class="s0">.generatedColumn = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">this</span><span class="s0">.source = </span><span class="s2">null</span><span class="s0">;</span>
    <span class="s2">this</span><span class="s0">.originalLine = </span><span class="s2">null</span><span class="s0">;</span>
    <span class="s2">this</span><span class="s0">.originalColumn = </span><span class="s2">null</span><span class="s0">;</span>
    <span class="s2">this</span><span class="s0">.name = </span><span class="s2">null</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s6">/**</span>
 <span class="s6">* Parse the mappings in a string in to a data structure which we can easily</span>
 <span class="s6">* query (the ordered arrays in the `this.__generatedMappings` and</span>
 <span class="s6">* `this.__originalMappings` properties).</span>
 <span class="s6">*/ </span><span class="s2">const </span><span class="s0">compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;</span>
<span class="s2">function </span><span class="s0">sortGenerated(array, start) {</span>
    <span class="s2">let </span><span class="s0">l = array.length;</span>
    <span class="s2">let </span><span class="s0">n = array.length - start;</span>
    <span class="s2">if </span><span class="s0">(n &lt;= </span><span class="s3">1</span><span class="s0">) {</span>
        <span class="s2">return</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(n == </span><span class="s3">2</span><span class="s0">) {</span>
        <span class="s2">let </span><span class="s0">a = array[start];</span>
        <span class="s2">let </span><span class="s0">b = array[start + </span><span class="s3">1</span><span class="s0">];</span>
        <span class="s2">if </span><span class="s0">(compareGenerated(a, b) &gt; </span><span class="s3">0</span><span class="s0">) {</span>
            <span class="s0">array[start] = b;</span>
            <span class="s0">array[start + </span><span class="s3">1</span><span class="s0">] = a;</span>
        <span class="s0">}</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(n &lt; </span><span class="s3">20</span><span class="s0">) {</span>
        <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">i = start; i &lt; l; i++){</span>
            <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">j = i; j &gt; start; j--){</span>
                <span class="s2">let </span><span class="s0">a = array[j - </span><span class="s3">1</span><span class="s0">];</span>
                <span class="s2">let </span><span class="s0">b = array[j];</span>
                <span class="s2">if </span><span class="s0">(compareGenerated(a, b) &lt;= </span><span class="s3">0</span><span class="s0">) {</span>
                    <span class="s2">break</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">array[j - </span><span class="s3">1</span><span class="s0">] = b;</span>
                <span class="s0">array[j] = a;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s0">quickSort(array, compareGenerated, start);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">BasicSourceMapConsumer.prototype._parseMappings = </span><span class="s2">function </span><span class="s0">SourceMapConsumer_parseMappings(aStr, aSourceRoot) {</span>
    <span class="s2">var </span><span class="s0">generatedLine = </span><span class="s3">1</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">previousGeneratedColumn = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">previousOriginalLine = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">previousOriginalColumn = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">previousSource = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">previousName = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">length = aStr.length;</span>
    <span class="s2">var </span><span class="s0">index = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">cachedSegments = {};</span>
    <span class="s2">var </span><span class="s0">temp = {};</span>
    <span class="s2">var </span><span class="s0">originalMappings = [];</span>
    <span class="s2">var </span><span class="s0">generatedMappings = [];</span>
    <span class="s2">var </span><span class="s0">mapping, str, segment, end, value;</span>
    <span class="s2">let </span><span class="s0">subarrayStart = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">while</span><span class="s0">(index &lt; length){</span>
        <span class="s2">if </span><span class="s0">(aStr.charAt(index) === </span><span class="s1">';'</span><span class="s0">) {</span>
            <span class="s0">generatedLine++;</span>
            <span class="s0">index++;</span>
            <span class="s0">previousGeneratedColumn = </span><span class="s3">0</span><span class="s0">;</span>
            <span class="s0">sortGenerated(generatedMappings, subarrayStart);</span>
            <span class="s0">subarrayStart = generatedMappings.length;</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(aStr.charAt(index) === </span><span class="s1">','</span><span class="s0">) {</span>
            <span class="s0">index++;</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s0">mapping = </span><span class="s2">new </span><span class="s0">Mapping();</span>
            <span class="s0">mapping.generatedLine = generatedLine;</span>
            <span class="s2">for</span><span class="s0">(end = index; end &lt; length; end++){</span>
                <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">._charIsMappingSeparator(aStr, end)) {</span>
                    <span class="s2">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">str = aStr.slice(index, end);</span>
            <span class="s0">segment = [];</span>
            <span class="s2">while</span><span class="s0">(index &lt; end){</span>
                <span class="s0">base64VLQ.decode(aStr, index, temp);</span>
                <span class="s0">value = temp.value;</span>
                <span class="s0">index = temp.rest;</span>
                <span class="s0">segment.push(value);</span>
            <span class="s0">}</span>
            <span class="s2">if </span><span class="s0">(segment.length === </span><span class="s3">2</span><span class="s0">) {</span>
                <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">'Found a source, but no line and column'</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s2">if </span><span class="s0">(segment.length === </span><span class="s3">3</span><span class="s0">) {</span>
                <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">'Found a source and line, but no column'</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s6">// Generated column.</span>
            <span class="s0">mapping.generatedColumn = previousGeneratedColumn + segment[</span><span class="s3">0</span><span class="s0">];</span>
            <span class="s0">previousGeneratedColumn = mapping.generatedColumn;</span>
            <span class="s2">if </span><span class="s0">(segment.length &gt; </span><span class="s3">1</span><span class="s0">) {</span>
                <span class="s6">// Original source.</span>
                <span class="s0">mapping.source = previousSource + segment[</span><span class="s3">1</span><span class="s0">];</span>
                <span class="s0">previousSource += segment[</span><span class="s3">1</span><span class="s0">];</span>
                <span class="s6">// Original line.</span>
                <span class="s0">mapping.originalLine = previousOriginalLine + segment[</span><span class="s3">2</span><span class="s0">];</span>
                <span class="s0">previousOriginalLine = mapping.originalLine;</span>
                <span class="s6">// Lines are stored 0-based</span>
                <span class="s0">mapping.originalLine += </span><span class="s3">1</span><span class="s0">;</span>
                <span class="s6">// Original column.</span>
                <span class="s0">mapping.originalColumn = previousOriginalColumn + segment[</span><span class="s3">3</span><span class="s0">];</span>
                <span class="s0">previousOriginalColumn = mapping.originalColumn;</span>
                <span class="s2">if </span><span class="s0">(segment.length &gt; </span><span class="s3">4</span><span class="s0">) {</span>
                    <span class="s6">// Original name.</span>
                    <span class="s0">mapping.name = previousName + segment[</span><span class="s3">4</span><span class="s0">];</span>
                    <span class="s0">previousName += segment[</span><span class="s3">4</span><span class="s0">];</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">generatedMappings.push(mapping);</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">mapping.originalLine === </span><span class="s1">'number'</span><span class="s0">) {</span>
                <span class="s2">let </span><span class="s0">currentSource = mapping.source;</span>
                <span class="s2">while</span><span class="s0">(originalMappings.length &lt;= currentSource){</span>
                    <span class="s0">originalMappings.push(</span><span class="s2">null</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s2">if </span><span class="s0">(originalMappings[currentSource] === </span><span class="s2">null</span><span class="s0">) {</span>
                    <span class="s0">originalMappings[currentSource] = [];</span>
                <span class="s0">}</span>
                <span class="s0">originalMappings[currentSource].push(mapping);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">sortGenerated(generatedMappings, subarrayStart);</span>
    <span class="s2">this</span><span class="s0">.__generatedMappings = generatedMappings;</span>
    <span class="s2">for</span><span class="s0">(</span><span class="s2">var </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; originalMappings.length; i++){</span>
        <span class="s2">if </span><span class="s0">(originalMappings[i] != </span><span class="s2">null</span><span class="s0">) {</span>
            <span class="s0">quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s2">this</span><span class="s0">.__originalMappings = [].concat(...originalMappings);</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Find the mapping that best matches the hypothetical &quot;needle&quot; mapping that</span>
 <span class="s6">* we are searching for in the given &quot;haystack&quot; of mappings.</span>
 <span class="s6">*/ </span><span class="s0">BasicSourceMapConsumer.prototype._findMapping = </span><span class="s2">function </span><span class="s0">SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {</span>
    <span class="s6">// To return the position we are searching for, we must first find the</span>
    <span class="s6">// mapping for the given position and then return the opposite position it</span>
    <span class="s6">// points to. Because the mappings are sorted, we can use binary search to</span>
    <span class="s6">// find the best mapping.</span>
    <span class="s2">if </span><span class="s0">(aNeedle[aLineName] &lt;= </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">throw new </span><span class="s0">TypeError(</span><span class="s1">'Line must be greater than or equal to 1, got ' </span><span class="s0">+ aNeedle[aLineName]);</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(aNeedle[aColumnName] &lt; </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">throw new </span><span class="s0">TypeError(</span><span class="s1">'Column must be greater than or equal to 0, got ' </span><span class="s0">+ aNeedle[aColumnName]);</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">binarySearch.search(aNeedle, aMappings, aComparator, aBias);</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Compute the last column for each generated mapping. The last column is</span>
 <span class="s6">* inclusive.</span>
 <span class="s6">*/ </span><span class="s0">BasicSourceMapConsumer.prototype.computeColumnSpans = </span><span class="s2">function </span><span class="s0">SourceMapConsumer_computeColumnSpans() {</span>
    <span class="s2">for</span><span class="s0">(</span><span class="s2">var </span><span class="s0">index = </span><span class="s3">0</span><span class="s0">; index &lt; </span><span class="s2">this</span><span class="s0">._generatedMappings.length; ++index){</span>
        <span class="s2">var </span><span class="s0">mapping = </span><span class="s2">this</span><span class="s0">._generatedMappings[index];</span>
        <span class="s6">// Mappings do not contain a field for the last generated columnt. We</span>
        <span class="s6">// can come up with an optimistic estimate, however, by assuming that</span>
        <span class="s6">// mappings are contiguous (i.e. given two consecutive mappings, the</span>
        <span class="s6">// first mapping ends where the second one starts).</span>
        <span class="s2">if </span><span class="s0">(index + </span><span class="s3">1 </span><span class="s0">&lt; </span><span class="s2">this</span><span class="s0">._generatedMappings.length) {</span>
            <span class="s2">var </span><span class="s0">nextMapping = </span><span class="s2">this</span><span class="s0">._generatedMappings[index + </span><span class="s3">1</span><span class="s0">];</span>
            <span class="s2">if </span><span class="s0">(mapping.generatedLine === nextMapping.generatedLine) {</span>
                <span class="s0">mapping.lastGeneratedColumn = nextMapping.generatedColumn - </span><span class="s3">1</span><span class="s0">;</span>
                <span class="s2">continue</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s6">// The last mapping for each line spans the entire line.</span>
        <span class="s0">mapping.lastGeneratedColumn = Infinity;</span>
    <span class="s0">}</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Returns the original source, line, and column information for the generated</span>
 <span class="s6">* source's line and column positions provided. The only argument is an object</span>
 <span class="s6">* with the following properties:</span>
 <span class="s6">*</span>
 <span class="s6">*   - line: The line number in the generated source.  The line number</span>
 <span class="s6">*     is 1-based.</span>
 <span class="s6">*   - column: The column number in the generated source.  The column</span>
 <span class="s6">*     number is 0-based.</span>
 <span class="s6">*   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or</span>
 <span class="s6">*     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the</span>
 <span class="s6">*     closest element that is smaller than or greater than the one we are</span>
 <span class="s6">*     searching for, respectively, if the exact element cannot be found.</span>
 <span class="s6">*     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.</span>
 <span class="s6">*</span>
 <span class="s6">* and an object is returned with the following properties:</span>
 <span class="s6">*</span>
 <span class="s6">*   - source: The original source file, or null.</span>
 <span class="s6">*   - line: The line number in the original source, or null.  The</span>
 <span class="s6">*     line number is 1-based.</span>
 <span class="s6">*   - column: The column number in the original source, or null.  The</span>
 <span class="s6">*     column number is 0-based.</span>
 <span class="s6">*   - name: The original identifier, or null.</span>
 <span class="s6">*/ </span><span class="s0">BasicSourceMapConsumer.prototype.originalPositionFor = </span><span class="s2">function </span><span class="s0">SourceMapConsumer_originalPositionFor(aArgs) {</span>
    <span class="s2">var </span><span class="s0">needle = {</span>
        <span class="s0">generatedLine: util.getArg(aArgs, </span><span class="s1">'line'</span><span class="s0">),</span>
        <span class="s0">generatedColumn: util.getArg(aArgs, </span><span class="s1">'column'</span><span class="s0">)</span>
    <span class="s0">};</span>
    <span class="s2">var </span><span class="s0">index = </span><span class="s2">this</span><span class="s0">._findMapping(needle, </span><span class="s2">this</span><span class="s0">._generatedMappings, </span><span class="s1">&quot;generatedLine&quot;</span><span class="s0">, </span><span class="s1">&quot;generatedColumn&quot;</span><span class="s0">, util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, </span><span class="s1">'bias'</span><span class="s0">, SourceMapConsumer.GREATEST_LOWER_BOUND));</span>
    <span class="s2">if </span><span class="s0">(index &gt;= </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">var </span><span class="s0">mapping = </span><span class="s2">this</span><span class="s0">._generatedMappings[index];</span>
        <span class="s2">if </span><span class="s0">(mapping.generatedLine === needle.generatedLine) {</span>
            <span class="s2">var </span><span class="s0">source = util.getArg(mapping, </span><span class="s1">'source'</span><span class="s0">, </span><span class="s2">null</span><span class="s0">);</span>
            <span class="s2">if </span><span class="s0">(source !== </span><span class="s2">null</span><span class="s0">) {</span>
                <span class="s0">source = </span><span class="s2">this</span><span class="s0">._sources.at(source);</span>
                <span class="s0">source = util.computeSourceURL(</span><span class="s2">this</span><span class="s0">.sourceRoot, source, </span><span class="s2">this</span><span class="s0">._sourceMapURL);</span>
            <span class="s0">}</span>
            <span class="s2">var </span><span class="s0">name = util.getArg(mapping, </span><span class="s1">'name'</span><span class="s0">, </span><span class="s2">null</span><span class="s0">);</span>
            <span class="s2">if </span><span class="s0">(name !== </span><span class="s2">null</span><span class="s0">) {</span>
                <span class="s0">name = </span><span class="s2">this</span><span class="s0">._names.at(name);</span>
            <span class="s0">}</span>
            <span class="s2">return </span><span class="s0">{</span>
                <span class="s0">source: source,</span>
                <span class="s0">line: util.getArg(mapping, </span><span class="s1">'originalLine'</span><span class="s0">, </span><span class="s2">null</span><span class="s0">),</span>
                <span class="s0">column: util.getArg(mapping, </span><span class="s1">'originalColumn'</span><span class="s0">, </span><span class="s2">null</span><span class="s0">),</span>
                <span class="s0">name: name</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">{</span>
        <span class="s0">source: </span><span class="s2">null</span><span class="s0">,</span>
        <span class="s0">line: </span><span class="s2">null</span><span class="s0">,</span>
        <span class="s0">column: </span><span class="s2">null</span><span class="s0">,</span>
        <span class="s0">name: </span><span class="s2">null</span>
    <span class="s0">};</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Return true if we have the source content for every source in the source</span>
 <span class="s6">* map, false otherwise.</span>
 <span class="s6">*/ </span><span class="s0">BasicSourceMapConsumer.prototype.hasContentsOfAllSources = </span><span class="s2">function </span><span class="s0">BasicSourceMapConsumer_hasContentsOfAllSources() {</span>
    <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.sourcesContent) {</span>
        <span class="s2">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s2">return this</span><span class="s0">.sourcesContent.length &gt;= </span><span class="s2">this</span><span class="s0">._sources.size() &amp;&amp; !</span><span class="s2">this</span><span class="s0">.sourcesContent.some(</span><span class="s2">function</span><span class="s0">(sc) {</span>
        <span class="s2">return </span><span class="s0">sc == </span><span class="s2">null</span><span class="s0">;</span>
    <span class="s0">});</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Returns the original source content. The only argument is the url of the</span>
 <span class="s6">* original source file. Returns null if no original source content is</span>
 <span class="s6">* available.</span>
 <span class="s6">*/ </span><span class="s0">BasicSourceMapConsumer.prototype.sourceContentFor = </span><span class="s2">function </span><span class="s0">SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {</span>
    <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.sourcesContent) {</span>
        <span class="s2">return null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s2">var </span><span class="s0">index = </span><span class="s2">this</span><span class="s0">._findSourceIndex(aSource);</span>
    <span class="s2">if </span><span class="s0">(index &gt;= </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">return this</span><span class="s0">.sourcesContent[index];</span>
    <span class="s0">}</span>
    <span class="s2">var </span><span class="s0">relativeSource = aSource;</span>
    <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.sourceRoot != </span><span class="s2">null</span><span class="s0">) {</span>
        <span class="s0">relativeSource = util.relative(</span><span class="s2">this</span><span class="s0">.sourceRoot, relativeSource);</span>
    <span class="s0">}</span>
    <span class="s2">var </span><span class="s0">url;</span>
    <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.sourceRoot != </span><span class="s2">null </span><span class="s0">&amp;&amp; (url = util.urlParse(</span><span class="s2">this</span><span class="s0">.sourceRoot))) {</span>
        <span class="s6">// XXX: file:// URIs and absolute paths lead to unexpected behavior for</span>
        <span class="s6">// many users. We can help them out when they expect file:// URIs to</span>
        <span class="s6">// behave like it would if they were running a local HTTP server. See</span>
        <span class="s6">// https://bugzilla.mozilla.org/show_bug.cgi?id=885597.</span>
        <span class="s2">var </span><span class="s0">fileUriAbsPath = relativeSource.replace(</span><span class="s5">/^file:\/\//</span><span class="s0">, </span><span class="s1">&quot;&quot;</span><span class="s0">);</span>
        <span class="s2">if </span><span class="s0">(url.scheme == </span><span class="s1">&quot;file&quot; </span><span class="s0">&amp;&amp; </span><span class="s2">this</span><span class="s0">._sources.has(fileUriAbsPath)) {</span>
            <span class="s2">return this</span><span class="s0">.sourcesContent[</span><span class="s2">this</span><span class="s0">._sources.indexOf(fileUriAbsPath)];</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">((!url.path || url.path == </span><span class="s1">&quot;/&quot;</span><span class="s0">) &amp;&amp; </span><span class="s2">this</span><span class="s0">._sources.has(</span><span class="s1">&quot;/&quot; </span><span class="s0">+ relativeSource)) {</span>
            <span class="s2">return this</span><span class="s0">.sourcesContent[</span><span class="s2">this</span><span class="s0">._sources.indexOf(</span><span class="s1">&quot;/&quot; </span><span class="s0">+ relativeSource)];</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s6">// This function is used recursively from</span>
    <span class="s6">// IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we</span>
    <span class="s6">// don't want to throw if we can't find the source - we just want to</span>
    <span class="s6">// return null, so we provide a flag to exit gracefully.</span>
    <span class="s2">if </span><span class="s0">(nullOnMissing) {</span>
        <span class="s2">return null</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">'&quot;' </span><span class="s0">+ relativeSource + </span><span class="s1">'&quot; is not in the SourceMap.'</span><span class="s0">);</span>
    <span class="s0">}</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Returns the generated line and column information for the original source,</span>
 <span class="s6">* line, and column positions provided. The only argument is an object with</span>
 <span class="s6">* the following properties:</span>
 <span class="s6">*</span>
 <span class="s6">*   - source: The filename of the original source.</span>
 <span class="s6">*   - line: The line number in the original source.  The line number</span>
 <span class="s6">*     is 1-based.</span>
 <span class="s6">*   - column: The column number in the original source.  The column</span>
 <span class="s6">*     number is 0-based.</span>
 <span class="s6">*   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or</span>
 <span class="s6">*     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the</span>
 <span class="s6">*     closest element that is smaller than or greater than the one we are</span>
 <span class="s6">*     searching for, respectively, if the exact element cannot be found.</span>
 <span class="s6">*     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.</span>
 <span class="s6">*</span>
 <span class="s6">* and an object is returned with the following properties:</span>
 <span class="s6">*</span>
 <span class="s6">*   - line: The line number in the generated source, or null.  The</span>
 <span class="s6">*     line number is 1-based.</span>
 <span class="s6">*   - column: The column number in the generated source, or null.</span>
 <span class="s6">*     The column number is 0-based.</span>
 <span class="s6">*/ </span><span class="s0">BasicSourceMapConsumer.prototype.generatedPositionFor = </span><span class="s2">function </span><span class="s0">SourceMapConsumer_generatedPositionFor(aArgs) {</span>
    <span class="s2">var </span><span class="s0">source = util.getArg(aArgs, </span><span class="s1">'source'</span><span class="s0">);</span>
    <span class="s0">source = </span><span class="s2">this</span><span class="s0">._findSourceIndex(source);</span>
    <span class="s2">if </span><span class="s0">(source &lt; </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">{</span>
            <span class="s0">line: </span><span class="s2">null</span><span class="s0">,</span>
            <span class="s0">column: </span><span class="s2">null</span><span class="s0">,</span>
            <span class="s0">lastColumn: </span><span class="s2">null</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s2">var </span><span class="s0">needle = {</span>
        <span class="s0">source: source,</span>
        <span class="s0">originalLine: util.getArg(aArgs, </span><span class="s1">'line'</span><span class="s0">),</span>
        <span class="s0">originalColumn: util.getArg(aArgs, </span><span class="s1">'column'</span><span class="s0">)</span>
    <span class="s0">};</span>
    <span class="s2">var </span><span class="s0">index = </span><span class="s2">this</span><span class="s0">._findMapping(needle, </span><span class="s2">this</span><span class="s0">._originalMappings, </span><span class="s1">&quot;originalLine&quot;</span><span class="s0">, </span><span class="s1">&quot;originalColumn&quot;</span><span class="s0">, util.compareByOriginalPositions, util.getArg(aArgs, </span><span class="s1">'bias'</span><span class="s0">, SourceMapConsumer.GREATEST_LOWER_BOUND));</span>
    <span class="s2">if </span><span class="s0">(index &gt;= </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s2">var </span><span class="s0">mapping = </span><span class="s2">this</span><span class="s0">._originalMappings[index];</span>
        <span class="s2">if </span><span class="s0">(mapping.source === needle.source) {</span>
            <span class="s2">return </span><span class="s0">{</span>
                <span class="s0">line: util.getArg(mapping, </span><span class="s1">'generatedLine'</span><span class="s0">, </span><span class="s2">null</span><span class="s0">),</span>
                <span class="s0">column: util.getArg(mapping, </span><span class="s1">'generatedColumn'</span><span class="s0">, </span><span class="s2">null</span><span class="s0">),</span>
                <span class="s0">lastColumn: util.getArg(mapping, </span><span class="s1">'lastGeneratedColumn'</span><span class="s0">, </span><span class="s2">null</span><span class="s0">)</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">{</span>
        <span class="s0">line: </span><span class="s2">null</span><span class="s0">,</span>
        <span class="s0">column: </span><span class="s2">null</span><span class="s0">,</span>
        <span class="s0">lastColumn: </span><span class="s2">null</span>
    <span class="s0">};</span>
<span class="s0">};</span>
<span class="s0">exports.BasicSourceMapConsumer = BasicSourceMapConsumer;</span>
<span class="s6">/**</span>
 <span class="s6">* An IndexedSourceMapConsumer instance represents a parsed source map which</span>
 <span class="s6">* we can query for information. It differs from BasicSourceMapConsumer in</span>
 <span class="s6">* that it takes &quot;indexed&quot; source maps (i.e. ones with a &quot;sections&quot; field) as</span>
 <span class="s6">* input.</span>
 <span class="s6">*</span>
 <span class="s6">* The first parameter is a raw source map (either as a JSON string, or already</span>
 <span class="s6">* parsed to an object). According to the spec for indexed source maps, they</span>
 <span class="s6">* have the following attributes:</span>
 <span class="s6">*</span>
 <span class="s6">*   - version: Which version of the source map spec this map is following.</span>
 <span class="s6">*   - file: Optional. The generated file this source map is associated with.</span>
 <span class="s6">*   - sections: A list of section definitions.</span>
 <span class="s6">*</span>
 <span class="s6">* Each value under the &quot;sections&quot; field has two fields:</span>
 <span class="s6">*   - offset: The offset into the original specified at which this section</span>
 <span class="s6">*       begins to apply, defined as an object with a &quot;line&quot; and &quot;column&quot;</span>
 <span class="s6">*       field.</span>
 <span class="s6">*   - map: A source map definition. This source map could also be indexed,</span>
 <span class="s6">*       but doesn't have to be.</span>
 <span class="s6">*</span>
 <span class="s6">* Instead of the &quot;map&quot; field, it's also possible to have a &quot;url&quot; field</span>
 <span class="s6">* specifying a URL to retrieve a source map from, but that's currently</span>
 <span class="s6">* unsupported.</span>
 <span class="s6">*</span>
 <span class="s6">* Here's an example source map, taken from the source map spec[0], but</span>
 <span class="s6">* modified to omit a section which uses the &quot;url&quot; field.</span>
 <span class="s6">*</span>
 <span class="s6">*  {</span>
 <span class="s6">*    version : 3,</span>
 <span class="s6">*    file: &quot;app.js&quot;,</span>
 <span class="s6">*    sections: [{</span>
 <span class="s6">*      offset: {line:100, column:10},</span>
 <span class="s6">*      map: {</span>
 <span class="s6">*        version : 3,</span>
 <span class="s6">*        file: &quot;section.js&quot;,</span>
 <span class="s6">*        sources: [&quot;foo.js&quot;, &quot;bar.js&quot;],</span>
 <span class="s6">*        names: [&quot;src&quot;, &quot;maps&quot;, &quot;are&quot;, &quot;fun&quot;],</span>
 <span class="s6">*        mappings: &quot;AAAA,E;;ABCDE;&quot;</span>
 <span class="s6">*      }</span>
 <span class="s6">*    }],</span>
 <span class="s6">*  }</span>
 <span class="s6">*</span>
 <span class="s6">* The second parameter, if given, is a string whose value is the URL</span>
 <span class="s6">* at which the source map was found.  This URL is used to compute the</span>
 <span class="s6">* sources array.</span>
 <span class="s6">*</span>
 <span class="s6">* [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt</span>
 <span class="s6">*/ </span><span class="s2">function </span><span class="s0">IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {</span>
    <span class="s2">var </span><span class="s0">sourceMap = aSourceMap;</span>
    <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">aSourceMap === </span><span class="s1">'string'</span><span class="s0">) {</span>
        <span class="s0">sourceMap = util.parseSourceMapInput(aSourceMap);</span>
    <span class="s0">}</span>
    <span class="s2">var </span><span class="s0">version = util.getArg(sourceMap, </span><span class="s1">'version'</span><span class="s0">);</span>
    <span class="s2">var </span><span class="s0">sections = util.getArg(sourceMap, </span><span class="s1">'sections'</span><span class="s0">);</span>
    <span class="s2">if </span><span class="s0">(version != </span><span class="s2">this</span><span class="s0">._version) {</span>
        <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">'Unsupported version: ' </span><span class="s0">+ version);</span>
    <span class="s0">}</span>
    <span class="s2">this</span><span class="s0">._sources = </span><span class="s2">new </span><span class="s0">ArraySet();</span>
    <span class="s2">this</span><span class="s0">._names = </span><span class="s2">new </span><span class="s0">ArraySet();</span>
    <span class="s2">var </span><span class="s0">lastOffset = {</span>
        <span class="s0">line: -</span><span class="s3">1</span><span class="s0">,</span>
        <span class="s0">column: </span><span class="s3">0</span>
    <span class="s0">};</span>
    <span class="s2">this</span><span class="s0">._sections = sections.map(</span><span class="s2">function</span><span class="s0">(s) {</span>
        <span class="s2">if </span><span class="s0">(s.url) {</span>
            <span class="s6">// The url field will require support for asynchronicity.</span>
            <span class="s6">// See https://github.com/mozilla/source-map/issues/16</span>
            <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">'Support for url field in sections not implemented.'</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s2">var </span><span class="s0">offset = util.getArg(s, </span><span class="s1">'offset'</span><span class="s0">);</span>
        <span class="s2">var </span><span class="s0">offsetLine = util.getArg(offset, </span><span class="s1">'line'</span><span class="s0">);</span>
        <span class="s2">var </span><span class="s0">offsetColumn = util.getArg(offset, </span><span class="s1">'column'</span><span class="s0">);</span>
        <span class="s2">if </span><span class="s0">(offsetLine &lt; lastOffset.line || offsetLine === lastOffset.line &amp;&amp; offsetColumn &lt; lastOffset.column) {</span>
            <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">'Section offsets must be ordered and non-overlapping.'</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">lastOffset = offset;</span>
        <span class="s2">return </span><span class="s0">{</span>
            <span class="s0">generatedOffset: {</span>
                <span class="s6">// The offset fields are 0-based, but we use 1-based indices when</span>
                <span class="s6">// encoding/decoding from VLQ.</span>
                <span class="s0">generatedLine: offsetLine + </span><span class="s3">1</span><span class="s0">,</span>
                <span class="s0">generatedColumn: offsetColumn + </span><span class="s3">1</span>
            <span class="s0">},</span>
            <span class="s0">consumer: </span><span class="s2">new </span><span class="s0">SourceMapConsumer(util.getArg(s, </span><span class="s1">'map'</span><span class="s0">), aSourceMapURL)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);</span>
<span class="s0">IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;</span>
<span class="s6">/**</span>
 <span class="s6">* The version of the source mapping spec that we are consuming.</span>
 <span class="s6">*/ </span><span class="s0">IndexedSourceMapConsumer.prototype._version = </span><span class="s3">3</span><span class="s0">;</span>
<span class="s6">/**</span>
 <span class="s6">* The list of original sources.</span>
 <span class="s6">*/ </span><span class="s0">Object.defineProperty(IndexedSourceMapConsumer.prototype, </span><span class="s1">'sources'</span><span class="s0">, {</span>
    <span class="s0">get: </span><span class="s2">function</span><span class="s0">() {</span>
        <span class="s2">var </span><span class="s0">sources = [];</span>
        <span class="s2">for</span><span class="s0">(</span><span class="s2">var </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; </span><span class="s2">this</span><span class="s0">._sections.length; i++){</span>
            <span class="s2">for</span><span class="s0">(</span><span class="s2">var </span><span class="s0">j = </span><span class="s3">0</span><span class="s0">; j &lt; </span><span class="s2">this</span><span class="s0">._sections[i].consumer.sources.length; j++){</span>
                <span class="s0">sources.push(</span><span class="s2">this</span><span class="s0">._sections[i].consumer.sources[j]);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">sources;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s6">/**</span>
 <span class="s6">* Returns the original source, line, and column information for the generated</span>
 <span class="s6">* source's line and column positions provided. The only argument is an object</span>
 <span class="s6">* with the following properties:</span>
 <span class="s6">*</span>
 <span class="s6">*   - line: The line number in the generated source.  The line number</span>
 <span class="s6">*     is 1-based.</span>
 <span class="s6">*   - column: The column number in the generated source.  The column</span>
 <span class="s6">*     number is 0-based.</span>
 <span class="s6">*</span>
 <span class="s6">* and an object is returned with the following properties:</span>
 <span class="s6">*</span>
 <span class="s6">*   - source: The original source file, or null.</span>
 <span class="s6">*   - line: The line number in the original source, or null.  The</span>
 <span class="s6">*     line number is 1-based.</span>
 <span class="s6">*   - column: The column number in the original source, or null.  The</span>
 <span class="s6">*     column number is 0-based.</span>
 <span class="s6">*   - name: The original identifier, or null.</span>
 <span class="s6">*/ </span><span class="s0">IndexedSourceMapConsumer.prototype.originalPositionFor = </span><span class="s2">function </span><span class="s0">IndexedSourceMapConsumer_originalPositionFor(aArgs) {</span>
    <span class="s2">var </span><span class="s0">needle = {</span>
        <span class="s0">generatedLine: util.getArg(aArgs, </span><span class="s1">'line'</span><span class="s0">),</span>
        <span class="s0">generatedColumn: util.getArg(aArgs, </span><span class="s1">'column'</span><span class="s0">)</span>
    <span class="s0">};</span>
    <span class="s6">// Find the section containing the generated position we're trying to map</span>
    <span class="s6">// to an original position.</span>
    <span class="s2">var </span><span class="s0">sectionIndex = binarySearch.search(needle, </span><span class="s2">this</span><span class="s0">._sections, </span><span class="s2">function</span><span class="s0">(needle, section) {</span>
        <span class="s2">var </span><span class="s0">cmp = needle.generatedLine - section.generatedOffset.generatedLine;</span>
        <span class="s2">if </span><span class="s0">(cmp) {</span>
            <span class="s2">return </span><span class="s0">cmp;</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">needle.generatedColumn - section.generatedOffset.generatedColumn;</span>
    <span class="s0">});</span>
    <span class="s2">var </span><span class="s0">section = </span><span class="s2">this</span><span class="s0">._sections[sectionIndex];</span>
    <span class="s2">if </span><span class="s0">(!section) {</span>
        <span class="s2">return </span><span class="s0">{</span>
            <span class="s0">source: </span><span class="s2">null</span><span class="s0">,</span>
            <span class="s0">line: </span><span class="s2">null</span><span class="s0">,</span>
            <span class="s0">column: </span><span class="s2">null</span><span class="s0">,</span>
            <span class="s0">name: </span><span class="s2">null</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">section.consumer.originalPositionFor({</span>
        <span class="s0">line: needle.generatedLine - (section.generatedOffset.generatedLine - </span><span class="s3">1</span><span class="s0">),</span>
        <span class="s0">column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - </span><span class="s3">1 </span><span class="s0">: </span><span class="s3">0</span><span class="s0">),</span>
        <span class="s0">bias: aArgs.bias</span>
    <span class="s0">});</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Return true if we have the source content for every source in the source</span>
 <span class="s6">* map, false otherwise.</span>
 <span class="s6">*/ </span><span class="s0">IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = </span><span class="s2">function </span><span class="s0">IndexedSourceMapConsumer_hasContentsOfAllSources() {</span>
    <span class="s2">return this</span><span class="s0">._sections.every(</span><span class="s2">function</span><span class="s0">(s) {</span>
        <span class="s2">return </span><span class="s0">s.consumer.hasContentsOfAllSources();</span>
    <span class="s0">});</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Returns the original source content. The only argument is the url of the</span>
 <span class="s6">* original source file. Returns null if no original source content is</span>
 <span class="s6">* available.</span>
 <span class="s6">*/ </span><span class="s0">IndexedSourceMapConsumer.prototype.sourceContentFor = </span><span class="s2">function </span><span class="s0">IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {</span>
    <span class="s2">for</span><span class="s0">(</span><span class="s2">var </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; </span><span class="s2">this</span><span class="s0">._sections.length; i++){</span>
        <span class="s2">var </span><span class="s0">section = </span><span class="s2">this</span><span class="s0">._sections[i];</span>
        <span class="s2">var </span><span class="s0">content = section.consumer.sourceContentFor(aSource, </span><span class="s2">true</span><span class="s0">);</span>
        <span class="s2">if </span><span class="s0">(content || content === </span><span class="s1">''</span><span class="s0">) {</span>
            <span class="s2">return </span><span class="s0">content;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(nullOnMissing) {</span>
        <span class="s2">return null</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">'&quot;' </span><span class="s0">+ aSource + </span><span class="s1">'&quot; is not in the SourceMap.'</span><span class="s0">);</span>
    <span class="s0">}</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Returns the generated line and column information for the original source,</span>
 <span class="s6">* line, and column positions provided. The only argument is an object with</span>
 <span class="s6">* the following properties:</span>
 <span class="s6">*</span>
 <span class="s6">*   - source: The filename of the original source.</span>
 <span class="s6">*   - line: The line number in the original source.  The line number</span>
 <span class="s6">*     is 1-based.</span>
 <span class="s6">*   - column: The column number in the original source.  The column</span>
 <span class="s6">*     number is 0-based.</span>
 <span class="s6">*</span>
 <span class="s6">* and an object is returned with the following properties:</span>
 <span class="s6">*</span>
 <span class="s6">*   - line: The line number in the generated source, or null.  The</span>
 <span class="s6">*     line number is 1-based. </span>
 <span class="s6">*   - column: The column number in the generated source, or null.</span>
 <span class="s6">*     The column number is 0-based.</span>
 <span class="s6">*/ </span><span class="s0">IndexedSourceMapConsumer.prototype.generatedPositionFor = </span><span class="s2">function </span><span class="s0">IndexedSourceMapConsumer_generatedPositionFor(aArgs) {</span>
    <span class="s2">for</span><span class="s0">(</span><span class="s2">var </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; </span><span class="s2">this</span><span class="s0">._sections.length; i++){</span>
        <span class="s2">var </span><span class="s0">section = </span><span class="s2">this</span><span class="s0">._sections[i];</span>
        <span class="s6">// Only consider this section if the requested source is in the list of</span>
        <span class="s6">// sources of the consumer.</span>
        <span class="s2">if </span><span class="s0">(section.consumer._findSourceIndex(util.getArg(aArgs, </span><span class="s1">'source'</span><span class="s0">)) === -</span><span class="s3">1</span><span class="s0">) {</span>
            <span class="s2">continue</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s2">var </span><span class="s0">generatedPosition = section.consumer.generatedPositionFor(aArgs);</span>
        <span class="s2">if </span><span class="s0">(generatedPosition) {</span>
            <span class="s2">var </span><span class="s0">ret = {</span>
                <span class="s0">line: generatedPosition.line + (section.generatedOffset.generatedLine - </span><span class="s3">1</span><span class="s0">),</span>
                <span class="s0">column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - </span><span class="s3">1 </span><span class="s0">: </span><span class="s3">0</span><span class="s0">)</span>
            <span class="s0">};</span>
            <span class="s2">return </span><span class="s0">ret;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">{</span>
        <span class="s0">line: </span><span class="s2">null</span><span class="s0">,</span>
        <span class="s0">column: </span><span class="s2">null</span>
    <span class="s0">};</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Parse the mappings in a string in to a data structure which we can easily</span>
 <span class="s6">* query (the ordered arrays in the `this.__generatedMappings` and</span>
 <span class="s6">* `this.__originalMappings` properties).</span>
 <span class="s6">*/ </span><span class="s0">IndexedSourceMapConsumer.prototype._parseMappings = </span><span class="s2">function </span><span class="s0">IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {</span>
    <span class="s2">this</span><span class="s0">.__generatedMappings = [];</span>
    <span class="s2">this</span><span class="s0">.__originalMappings = [];</span>
    <span class="s2">for</span><span class="s0">(</span><span class="s2">var </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; </span><span class="s2">this</span><span class="s0">._sections.length; i++){</span>
        <span class="s2">var </span><span class="s0">section = </span><span class="s2">this</span><span class="s0">._sections[i];</span>
        <span class="s2">var </span><span class="s0">sectionMappings = section.consumer._generatedMappings;</span>
        <span class="s2">for</span><span class="s0">(</span><span class="s2">var </span><span class="s0">j = </span><span class="s3">0</span><span class="s0">; j &lt; sectionMappings.length; j++){</span>
            <span class="s2">var </span><span class="s0">mapping = sectionMappings[j];</span>
            <span class="s2">var </span><span class="s0">source = section.consumer._sources.at(mapping.source);</span>
            <span class="s2">if </span><span class="s0">(source !== </span><span class="s2">null</span><span class="s0">) {</span>
                <span class="s0">source = util.computeSourceURL(section.consumer.sourceRoot, source, </span><span class="s2">this</span><span class="s0">._sourceMapURL);</span>
            <span class="s0">}</span>
            <span class="s2">this</span><span class="s0">._sources.add(source);</span>
            <span class="s0">source = </span><span class="s2">this</span><span class="s0">._sources.indexOf(source);</span>
            <span class="s2">var </span><span class="s0">name = </span><span class="s2">null</span><span class="s0">;</span>
            <span class="s2">if </span><span class="s0">(mapping.name) {</span>
                <span class="s0">name = section.consumer._names.at(mapping.name);</span>
                <span class="s2">this</span><span class="s0">._names.add(name);</span>
                <span class="s0">name = </span><span class="s2">this</span><span class="s0">._names.indexOf(name);</span>
            <span class="s0">}</span>
            <span class="s6">// The mappings coming from the consumer for the section have</span>
            <span class="s6">// generated positions relative to the start of the section, so we</span>
            <span class="s6">// need to offset them to be relative to the start of the concatenated</span>
            <span class="s6">// generated file.</span>
            <span class="s2">var </span><span class="s0">adjustedMapping = {</span>
                <span class="s0">source: source,</span>
                <span class="s0">generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - </span><span class="s3">1</span><span class="s0">),</span>
                <span class="s0">generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - </span><span class="s3">1 </span><span class="s0">: </span><span class="s3">0</span><span class="s0">),</span>
                <span class="s0">originalLine: mapping.originalLine,</span>
                <span class="s0">originalColumn: mapping.originalColumn,</span>
                <span class="s0">name: name</span>
            <span class="s0">};</span>
            <span class="s2">this</span><span class="s0">.__generatedMappings.push(adjustedMapping);</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">adjustedMapping.originalLine === </span><span class="s1">'number'</span><span class="s0">) {</span>
                <span class="s2">this</span><span class="s0">.__originalMappings.push(adjustedMapping);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">quickSort(</span><span class="s2">this</span><span class="s0">.__generatedMappings, util.compareByGeneratedPositionsDeflated);</span>
    <span class="s0">quickSort(</span><span class="s2">this</span><span class="s0">.__originalMappings, util.compareByOriginalPositions);</span>
<span class="s0">};</span>
<span class="s0">exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/source-map-js/lib/source-node.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>

<span class="s6">/* -*- Mode: js; js-indent-level: 2; -*- */ /* 
 * Copyright 2011 Mozilla Foundation and contributors 
 * Licensed under the New BSD license. See LICENSE or: 
 * http://opensource.org/licenses/BSD-3-Clause 
 */ </span><span class="s2">var </span><span class="s0">SourceMapGenerator = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/source-map-js/lib/source-map-generator.js [postcss] (ecmascript)&quot;</span><span class="s0">).SourceMapGenerator;</span>
<span class="s2">var </span><span class="s0">util = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s6">// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other</span>
<span class="s6">// operating systems these days (capturing the result).</span>
<span class="s2">var </span><span class="s0">REGEX_NEWLINE = </span><span class="s5">/(\r?\n)/</span><span class="s0">;</span>
<span class="s6">// Newline character code for charCodeAt() comparisons</span>
<span class="s2">var </span><span class="s0">NEWLINE_CODE = </span><span class="s3">10</span><span class="s0">;</span>
<span class="s6">// Private symbol for identifying `SourceNode`s when multiple versions of</span>
<span class="s6">// the source-map library are loaded. This MUST NOT CHANGE across</span>
<span class="s6">// versions!</span>
<span class="s2">var </span><span class="s0">isSourceNode = </span><span class="s1">&quot;$$$isSourceNode$$$&quot;</span><span class="s0">;</span>
<span class="s6">/**</span>
 <span class="s6">* SourceNodes provide a way to abstract over interpolating/concatenating</span>
 <span class="s6">* snippets of generated JavaScript source code while maintaining the line and</span>
 <span class="s6">* column information associated with the original source code.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aLine The original line number.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aColumn The original column number.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aSource The original source's filename.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aChunks Optional. An array of strings which are snippets of</span>
 <span class="s6">*        generated JS, or other SourceNodes.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aName The original identifier.</span>
 <span class="s6">*/ </span><span class="s2">function </span><span class="s0">SourceNode(aLine, aColumn, aSource, aChunks, aName) {</span>
    <span class="s2">this</span><span class="s0">.children = [];</span>
    <span class="s2">this</span><span class="s0">.sourceContents = {};</span>
    <span class="s2">this</span><span class="s0">.line = aLine == </span><span class="s2">null </span><span class="s0">? </span><span class="s2">null </span><span class="s0">: aLine;</span>
    <span class="s2">this</span><span class="s0">.column = aColumn == </span><span class="s2">null </span><span class="s0">? </span><span class="s2">null </span><span class="s0">: aColumn;</span>
    <span class="s2">this</span><span class="s0">.source = aSource == </span><span class="s2">null </span><span class="s0">? </span><span class="s2">null </span><span class="s0">: aSource;</span>
    <span class="s2">this</span><span class="s0">.name = aName == </span><span class="s2">null </span><span class="s0">? </span><span class="s2">null </span><span class="s0">: aName;</span>
    <span class="s2">this</span><span class="s0">[isSourceNode] = </span><span class="s2">true</span><span class="s0">;</span>
    <span class="s2">if </span><span class="s0">(aChunks != </span><span class="s2">null</span><span class="s0">) </span><span class="s2">this</span><span class="s0">.add(aChunks);</span>
<span class="s0">}</span>
<span class="s6">/**</span>
 <span class="s6">* Creates a SourceNode from generated code and a SourceMapConsumer.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aGeneratedCode The generated code</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aSourceMapConsumer The SourceMap for the generated code</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aRelativePath Optional. The path that relative sources in the</span>
 <span class="s6">*        SourceMapConsumer should be relative to.</span>
 <span class="s6">*/ </span><span class="s0">SourceNode.fromStringWithSourceMap = </span><span class="s2">function </span><span class="s0">SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {</span>
    <span class="s6">// The SourceNode we want to fill with the generated code</span>
    <span class="s6">// and the SourceMap</span>
    <span class="s2">var </span><span class="s0">node = </span><span class="s2">new </span><span class="s0">SourceNode();</span>
    <span class="s6">// All even indices of this array are one line of the generated code,</span>
    <span class="s6">// while all odd indices are the newlines between two adjacent lines</span>
    <span class="s6">// (since `REGEX_NEWLINE` captures its match).</span>
    <span class="s6">// Processed fragments are accessed by calling `shiftNextLine`.</span>
    <span class="s2">var </span><span class="s0">remainingLines = aGeneratedCode.split(REGEX_NEWLINE);</span>
    <span class="s2">var </span><span class="s0">remainingLinesIndex = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">shiftNextLine = </span><span class="s2">function</span><span class="s0">() {</span>
        <span class="s2">var </span><span class="s0">lineContents = getNextLine();</span>
        <span class="s6">// The last line of a file might not have a newline.</span>
        <span class="s2">var </span><span class="s0">newLine = getNextLine() || </span><span class="s1">&quot;&quot;</span><span class="s0">;</span>
        <span class="s2">return </span><span class="s0">lineContents + newLine;</span>
        <span class="s6">//TURBOPACK unreachable</span>
        <span class="s0">;</span>
        <span class="s2">function </span><span class="s0">getNextLine() {</span>
            <span class="s2">return </span><span class="s0">remainingLinesIndex &lt; remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;</span>
        <span class="s0">}</span>
    <span class="s0">};</span>
    <span class="s6">// We need to remember the position of &quot;remainingLines&quot;</span>
    <span class="s2">var </span><span class="s0">lastGeneratedLine = </span><span class="s3">1</span><span class="s0">, lastGeneratedColumn = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s6">// The generate SourceNodes we need a code range.</span>
    <span class="s6">// To extract it current and last mapping is used.</span>
    <span class="s6">// Here we store the last mapping.</span>
    <span class="s2">var </span><span class="s0">lastMapping = </span><span class="s2">null</span><span class="s0">;</span>
    <span class="s0">aSourceMapConsumer.eachMapping(</span><span class="s2">function</span><span class="s0">(mapping) {</span>
        <span class="s2">if </span><span class="s0">(lastMapping !== </span><span class="s2">null</span><span class="s0">) {</span>
            <span class="s6">// We add the code from &quot;lastMapping&quot; to &quot;mapping&quot;:</span>
            <span class="s6">// First check if there is a new line in between.</span>
            <span class="s2">if </span><span class="s0">(lastGeneratedLine &lt; mapping.generatedLine) {</span>
                <span class="s6">// Associate first line with &quot;lastMapping&quot;</span>
                <span class="s0">addMappingWithCode(lastMapping, shiftNextLine());</span>
                <span class="s0">lastGeneratedLine++;</span>
                <span class="s0">lastGeneratedColumn = </span><span class="s3">0</span><span class="s0">;</span>
            <span class="s6">// The remaining code is added without mapping</span>
            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                <span class="s6">// There is no new line in between.</span>
                <span class="s6">// Associate the code between &quot;lastGeneratedColumn&quot; and</span>
                <span class="s6">// &quot;mapping.generatedColumn&quot; with &quot;lastMapping&quot;</span>
                <span class="s2">var </span><span class="s0">nextLine = remainingLines[remainingLinesIndex] || </span><span class="s1">''</span><span class="s0">;</span>
                <span class="s2">var </span><span class="s0">code = nextLine.substr(</span><span class="s3">0</span><span class="s0">, mapping.generatedColumn - lastGeneratedColumn);</span>
                <span class="s0">remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);</span>
                <span class="s0">lastGeneratedColumn = mapping.generatedColumn;</span>
                <span class="s0">addMappingWithCode(lastMapping, code);</span>
                <span class="s6">// No more remaining code, continue</span>
                <span class="s0">lastMapping = mapping;</span>
                <span class="s2">return</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s6">// We add the generated code until the first mapping</span>
        <span class="s6">// to the SourceNode without any mapping.</span>
        <span class="s6">// Each line is added as separate string.</span>
        <span class="s2">while</span><span class="s0">(lastGeneratedLine &lt; mapping.generatedLine){</span>
            <span class="s0">node.add(shiftNextLine());</span>
            <span class="s0">lastGeneratedLine++;</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(lastGeneratedColumn &lt; mapping.generatedColumn) {</span>
            <span class="s2">var </span><span class="s0">nextLine = remainingLines[remainingLinesIndex] || </span><span class="s1">''</span><span class="s0">;</span>
            <span class="s0">node.add(nextLine.substr(</span><span class="s3">0</span><span class="s0">, mapping.generatedColumn));</span>
            <span class="s0">remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);</span>
            <span class="s0">lastGeneratedColumn = mapping.generatedColumn;</span>
        <span class="s0">}</span>
        <span class="s0">lastMapping = mapping;</span>
    <span class="s0">}, </span><span class="s2">this</span><span class="s0">);</span>
    <span class="s6">// We have processed all mappings.</span>
    <span class="s2">if </span><span class="s0">(remainingLinesIndex &lt; remainingLines.length) {</span>
        <span class="s2">if </span><span class="s0">(lastMapping) {</span>
            <span class="s6">// Associate the remaining code in the current line with &quot;lastMapping&quot;</span>
            <span class="s0">addMappingWithCode(lastMapping, shiftNextLine());</span>
        <span class="s0">}</span>
        <span class="s6">// and add the remaining lines without any mapping</span>
        <span class="s0">node.add(remainingLines.splice(remainingLinesIndex).join(</span><span class="s1">&quot;&quot;</span><span class="s0">));</span>
    <span class="s0">}</span>
    <span class="s6">// Copy sourcesContent into SourceNode</span>
    <span class="s0">aSourceMapConsumer.sources.forEach(</span><span class="s2">function</span><span class="s0">(sourceFile) {</span>
        <span class="s2">var </span><span class="s0">content = aSourceMapConsumer.sourceContentFor(sourceFile);</span>
        <span class="s2">if </span><span class="s0">(content != </span><span class="s2">null</span><span class="s0">) {</span>
            <span class="s2">if </span><span class="s0">(aRelativePath != </span><span class="s2">null</span><span class="s0">) {</span>
                <span class="s0">sourceFile = util.join(aRelativePath, sourceFile);</span>
            <span class="s0">}</span>
            <span class="s0">node.setSourceContent(sourceFile, content);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s2">return </span><span class="s0">node;</span>
    <span class="s6">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
    <span class="s2">function </span><span class="s0">addMappingWithCode(mapping, code) {</span>
        <span class="s2">if </span><span class="s0">(mapping === </span><span class="s2">null </span><span class="s0">|| mapping.source === undefined) {</span>
            <span class="s0">node.add(code);</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">var </span><span class="s0">source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;</span>
            <span class="s0">node.add(</span><span class="s2">new </span><span class="s0">SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Add a chunk of generated JS to this source node.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aChunk A string snippet of generated JS code, another instance of</span>
 <span class="s6">*        SourceNode, or an array where each member is one of those things.</span>
 <span class="s6">*/ </span><span class="s0">SourceNode.prototype.add = </span><span class="s2">function </span><span class="s0">SourceNode_add(aChunk) {</span>
    <span class="s2">if </span><span class="s0">(Array.isArray(aChunk)) {</span>
        <span class="s0">aChunk.forEach(</span><span class="s2">function</span><span class="s0">(chunk) {</span>
            <span class="s2">this</span><span class="s0">.add(chunk);</span>
        <span class="s0">}, </span><span class="s2">this</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(aChunk[isSourceNode] || </span><span class="s2">typeof </span><span class="s0">aChunk === </span><span class="s1">&quot;string&quot;</span><span class="s0">) {</span>
        <span class="s2">if </span><span class="s0">(aChunk) {</span>
            <span class="s2">this</span><span class="s0">.children.push(aChunk);</span>
        <span class="s0">}</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s2">throw new </span><span class="s0">TypeError(</span><span class="s1">&quot;Expected a SourceNode, string, or an array of SourceNodes and strings. Got &quot; </span><span class="s0">+ aChunk);</span>
    <span class="s0">}</span>
    <span class="s2">return this</span><span class="s0">;</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Add a chunk of generated JS to the beginning of this source node.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aChunk A string snippet of generated JS code, another instance of</span>
 <span class="s6">*        SourceNode, or an array where each member is one of those things.</span>
 <span class="s6">*/ </span><span class="s0">SourceNode.prototype.prepend = </span><span class="s2">function </span><span class="s0">SourceNode_prepend(aChunk) {</span>
    <span class="s2">if </span><span class="s0">(Array.isArray(aChunk)) {</span>
        <span class="s2">for</span><span class="s0">(</span><span class="s2">var </span><span class="s0">i = aChunk.length - </span><span class="s3">1</span><span class="s0">; i &gt;= </span><span class="s3">0</span><span class="s0">; i--){</span>
            <span class="s2">this</span><span class="s0">.prepend(aChunk[i]);</span>
        <span class="s0">}</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(aChunk[isSourceNode] || </span><span class="s2">typeof </span><span class="s0">aChunk === </span><span class="s1">&quot;string&quot;</span><span class="s0">) {</span>
        <span class="s2">this</span><span class="s0">.children.unshift(aChunk);</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s2">throw new </span><span class="s0">TypeError(</span><span class="s1">&quot;Expected a SourceNode, string, or an array of SourceNodes and strings. Got &quot; </span><span class="s0">+ aChunk);</span>
    <span class="s0">}</span>
    <span class="s2">return this</span><span class="s0">;</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Walk over the tree of JS snippets in this node and its children. The</span>
 <span class="s6">* walking function is called once for each snippet of JS and is passed that</span>
 <span class="s6">* snippet and the its original associated source's line/column location.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aFn The traversal function.</span>
 <span class="s6">*/ </span><span class="s0">SourceNode.prototype.walk = </span><span class="s2">function </span><span class="s0">SourceNode_walk(aFn) {</span>
    <span class="s2">var </span><span class="s0">chunk;</span>
    <span class="s2">for</span><span class="s0">(</span><span class="s2">var </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">, len = </span><span class="s2">this</span><span class="s0">.children.length; i &lt; len; i++){</span>
        <span class="s0">chunk = </span><span class="s2">this</span><span class="s0">.children[i];</span>
        <span class="s2">if </span><span class="s0">(chunk[isSourceNode]) {</span>
            <span class="s0">chunk.walk(aFn);</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">if </span><span class="s0">(chunk !== </span><span class="s1">''</span><span class="s0">) {</span>
                <span class="s0">aFn(chunk, {</span>
                    <span class="s0">source: </span><span class="s2">this</span><span class="s0">.source,</span>
                    <span class="s0">line: </span><span class="s2">this</span><span class="s0">.line,</span>
                    <span class="s0">column: </span><span class="s2">this</span><span class="s0">.column,</span>
                    <span class="s0">name: </span><span class="s2">this</span><span class="s0">.name</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between</span>
 <span class="s6">* each of `this.children`.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aSep The separator.</span>
 <span class="s6">*/ </span><span class="s0">SourceNode.prototype.join = </span><span class="s2">function </span><span class="s0">SourceNode_join(aSep) {</span>
    <span class="s2">var </span><span class="s0">newChildren;</span>
    <span class="s2">var </span><span class="s0">i;</span>
    <span class="s2">var </span><span class="s0">len = </span><span class="s2">this</span><span class="s0">.children.length;</span>
    <span class="s2">if </span><span class="s0">(len &gt; </span><span class="s3">0</span><span class="s0">) {</span>
        <span class="s0">newChildren = [];</span>
        <span class="s2">for</span><span class="s0">(i = </span><span class="s3">0</span><span class="s0">; i &lt; len - </span><span class="s3">1</span><span class="s0">; i++){</span>
            <span class="s0">newChildren.push(</span><span class="s2">this</span><span class="s0">.children[i]);</span>
            <span class="s0">newChildren.push(aSep);</span>
        <span class="s0">}</span>
        <span class="s0">newChildren.push(</span><span class="s2">this</span><span class="s0">.children[i]);</span>
        <span class="s2">this</span><span class="s0">.children = newChildren;</span>
    <span class="s0">}</span>
    <span class="s2">return this</span><span class="s0">;</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Call String.prototype.replace on the very right-most source snippet. Useful</span>
 <span class="s6">* for trimming whitespace from the end of a source node, etc.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aPattern The pattern to replace.</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aReplacement The thing to replace the pattern with.</span>
 <span class="s6">*/ </span><span class="s0">SourceNode.prototype.replaceRight = </span><span class="s2">function </span><span class="s0">SourceNode_replaceRight(aPattern, aReplacement) {</span>
    <span class="s2">var </span><span class="s0">lastChild = </span><span class="s2">this</span><span class="s0">.children[</span><span class="s2">this</span><span class="s0">.children.length - </span><span class="s3">1</span><span class="s0">];</span>
    <span class="s2">if </span><span class="s0">(lastChild[isSourceNode]) {</span>
        <span class="s0">lastChild.replaceRight(aPattern, aReplacement);</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">lastChild === </span><span class="s1">'string'</span><span class="s0">) {</span>
        <span class="s2">this</span><span class="s0">.children[</span><span class="s2">this</span><span class="s0">.children.length - </span><span class="s3">1</span><span class="s0">] = lastChild.replace(aPattern, aReplacement);</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s2">this</span><span class="s0">.children.push(</span><span class="s1">''</span><span class="s0">.replace(aPattern, aReplacement));</span>
    <span class="s0">}</span>
    <span class="s2">return this</span><span class="s0">;</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Set the source content for a source file. This will be added to the SourceMapGenerator</span>
 <span class="s6">* in the sourcesContent field.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aSourceFile The filename of the source file</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aSourceContent The content of the source file</span>
 <span class="s6">*/ </span><span class="s0">SourceNode.prototype.setSourceContent = </span><span class="s2">function </span><span class="s0">SourceNode_setSourceContent(aSourceFile, aSourceContent) {</span>
    <span class="s2">this</span><span class="s0">.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Walk over the tree of SourceNodes. The walking function is called for each</span>
 <span class="s6">* source file content and is passed the filename and source content.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aFn The traversal function.</span>
 <span class="s6">*/ </span><span class="s0">SourceNode.prototype.walkSourceContents = </span><span class="s2">function </span><span class="s0">SourceNode_walkSourceContents(aFn) {</span>
    <span class="s2">for</span><span class="s0">(</span><span class="s2">var </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">, len = </span><span class="s2">this</span><span class="s0">.children.length; i &lt; len; i++){</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.children[i][isSourceNode]) {</span>
            <span class="s2">this</span><span class="s0">.children[i].walkSourceContents(aFn);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s2">var </span><span class="s0">sources = Object.keys(</span><span class="s2">this</span><span class="s0">.sourceContents);</span>
    <span class="s2">for</span><span class="s0">(</span><span class="s2">var </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">, len = sources.length; i &lt; len; i++){</span>
        <span class="s0">aFn(util.fromSetString(sources[i]), </span><span class="s2">this</span><span class="s0">.sourceContents[sources[i]]);</span>
    <span class="s0">}</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Return the string representation of this source node. Walks over the tree</span>
 <span class="s6">* and concatenates all the various snippets together to one string.</span>
 <span class="s6">*/ </span><span class="s0">SourceNode.prototype.toString = </span><span class="s2">function </span><span class="s0">SourceNode_toString() {</span>
    <span class="s2">var </span><span class="s0">str = </span><span class="s1">&quot;&quot;</span><span class="s0">;</span>
    <span class="s2">this</span><span class="s0">.walk(</span><span class="s2">function</span><span class="s0">(chunk) {</span>
        <span class="s0">str += chunk;</span>
    <span class="s0">});</span>
    <span class="s2">return </span><span class="s0">str;</span>
<span class="s0">};</span>
<span class="s6">/**</span>
 <span class="s6">* Returns the string representation of this source node along with a source</span>
 <span class="s6">* map.</span>
 <span class="s6">*/ </span><span class="s0">SourceNode.prototype.toStringWithSourceMap = </span><span class="s2">function </span><span class="s0">SourceNode_toStringWithSourceMap(aArgs) {</span>
    <span class="s2">var </span><span class="s0">generated = {</span>
        <span class="s0">code: </span><span class="s1">&quot;&quot;</span><span class="s0">,</span>
        <span class="s0">line: </span><span class="s3">1</span><span class="s0">,</span>
        <span class="s0">column: </span><span class="s3">0</span>
    <span class="s0">};</span>
    <span class="s2">var </span><span class="s0">map = </span><span class="s2">new </span><span class="s0">SourceMapGenerator(aArgs);</span>
    <span class="s2">var </span><span class="s0">sourceMappingActive = </span><span class="s2">false</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">lastOriginalSource = </span><span class="s2">null</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">lastOriginalLine = </span><span class="s2">null</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">lastOriginalColumn = </span><span class="s2">null</span><span class="s0">;</span>
    <span class="s2">var </span><span class="s0">lastOriginalName = </span><span class="s2">null</span><span class="s0">;</span>
    <span class="s2">this</span><span class="s0">.walk(</span><span class="s2">function</span><span class="s0">(chunk, original) {</span>
        <span class="s0">generated.code += chunk;</span>
        <span class="s2">if </span><span class="s0">(original.source !== </span><span class="s2">null </span><span class="s0">&amp;&amp; original.line !== </span><span class="s2">null </span><span class="s0">&amp;&amp; original.column !== </span><span class="s2">null</span><span class="s0">) {</span>
            <span class="s2">if </span><span class="s0">(lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {</span>
                <span class="s0">map.addMapping({</span>
                    <span class="s0">source: original.source,</span>
                    <span class="s0">original: {</span>
                        <span class="s0">line: original.line,</span>
                        <span class="s0">column: original.column</span>
                    <span class="s0">},</span>
                    <span class="s0">generated: {</span>
                        <span class="s0">line: generated.line,</span>
                        <span class="s0">column: generated.column</span>
                    <span class="s0">},</span>
                    <span class="s0">name: original.name</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s0">lastOriginalSource = original.source;</span>
            <span class="s0">lastOriginalLine = original.line;</span>
            <span class="s0">lastOriginalColumn = original.column;</span>
            <span class="s0">lastOriginalName = original.name;</span>
            <span class="s0">sourceMappingActive = </span><span class="s2">true</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(sourceMappingActive) {</span>
            <span class="s0">map.addMapping({</span>
                <span class="s0">generated: {</span>
                    <span class="s0">line: generated.line,</span>
                    <span class="s0">column: generated.column</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
            <span class="s0">lastOriginalSource = </span><span class="s2">null</span><span class="s0">;</span>
            <span class="s0">sourceMappingActive = </span><span class="s2">false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s2">for</span><span class="s0">(</span><span class="s2">var </span><span class="s0">idx = </span><span class="s3">0</span><span class="s0">, length = chunk.length; idx &lt; length; idx++){</span>
            <span class="s2">if </span><span class="s0">(chunk.charCodeAt(idx) === NEWLINE_CODE) {</span>
                <span class="s0">generated.line++;</span>
                <span class="s0">generated.column = </span><span class="s3">0</span><span class="s0">;</span>
                <span class="s6">// Mappings end at eol</span>
                <span class="s2">if </span><span class="s0">(idx + </span><span class="s3">1 </span><span class="s0">=== length) {</span>
                    <span class="s0">lastOriginalSource = </span><span class="s2">null</span><span class="s0">;</span>
                    <span class="s0">sourceMappingActive = </span><span class="s2">false</span><span class="s0">;</span>
                <span class="s0">} </span><span class="s2">else if </span><span class="s0">(sourceMappingActive) {</span>
                    <span class="s0">map.addMapping({</span>
                        <span class="s0">source: original.source,</span>
                        <span class="s0">original: {</span>
                            <span class="s0">line: original.line,</span>
                            <span class="s0">column: original.column</span>
                        <span class="s0">},</span>
                        <span class="s0">generated: {</span>
                            <span class="s0">line: generated.line,</span>
                            <span class="s0">column: generated.column</span>
                        <span class="s0">},</span>
                        <span class="s0">name: original.name</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                <span class="s0">generated.column++;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s2">this</span><span class="s0">.walkSourceContents(</span><span class="s2">function</span><span class="s0">(sourceFile, sourceContent) {</span>
        <span class="s0">map.setSourceContent(sourceFile, sourceContent);</span>
    <span class="s0">});</span>
    <span class="s2">return </span><span class="s0">{</span>
        <span class="s0">code: generated.code,</span>
        <span class="s0">map: map</span>
    <span class="s0">};</span>
<span class="s0">};</span>
<span class="s0">exports.SourceNode = SourceNode;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/source-map-js/source-map.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>

<span class="s6">/* 
 * Copyright 2009-2011 Mozilla Foundation and contributors 
 * Licensed under the New BSD license. See LICENSE.txt or: 
 * http://opensource.org/licenses/BSD-3-Clause 
 */ </span><span class="s0">exports.SourceMapGenerator = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/source-map-js/lib/source-map-generator.js [postcss] (ecmascript)&quot;</span><span class="s0">).SourceMapGenerator;</span>
<span class="s0">exports.SourceMapConsumer = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/source-map-js/lib/source-map-consumer.js [postcss] (ecmascript)&quot;</span><span class="s0">).SourceMapConsumer;</span>
<span class="s0">exports.SourceNode = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/source-map-js/lib/source-node.js [postcss] (ecmascript)&quot;</span><span class="s0">).SourceNode;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/previous-map.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">let </span><span class="s0">{ existsSync, readFileSync } = __turbopack_context__.r(</span><span class="s1">&quot;[externals]/fs [external] (fs, cjs)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">{ dirname, join } = __turbopack_context__.r(</span><span class="s1">&quot;[externals]/path [external] (path, cjs)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">{ SourceMapConsumer, SourceMapGenerator } = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/source-map-js/source-map.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">function </span><span class="s0">fromBase64(str) {</span>
    <span class="s2">if </span><span class="s0">(</span><span class="s1">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s0">) {</span>
        <span class="s2">return </span><span class="s0">Buffer.from(str, </span><span class="s1">'base64'</span><span class="s0">).toString();</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s6">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
<span class="s0">}</span>
<span class="s2">class </span><span class="s0">PreviousMap {</span>
    <span class="s0">constructor(css, opts){</span>
        <span class="s2">if </span><span class="s0">(opts.map === </span><span class="s2">false</span><span class="s0">) </span><span class="s2">return</span><span class="s0">;</span>
        <span class="s2">this</span><span class="s0">.loadAnnotation(css);</span>
        <span class="s2">this</span><span class="s0">.inline = </span><span class="s2">this</span><span class="s0">.startWith(</span><span class="s2">this</span><span class="s0">.annotation, </span><span class="s1">'data:'</span><span class="s0">);</span>
        <span class="s2">let </span><span class="s0">prev = opts.map ? opts.map.prev : undefined;</span>
        <span class="s2">let </span><span class="s0">text = </span><span class="s2">this</span><span class="s0">.loadMap(opts.from, prev);</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.mapFile &amp;&amp; opts.from) {</span>
            <span class="s2">this</span><span class="s0">.mapFile = opts.from;</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.mapFile) </span><span class="s2">this</span><span class="s0">.root = dirname(</span><span class="s2">this</span><span class="s0">.mapFile);</span>
        <span class="s2">if </span><span class="s0">(text) </span><span class="s2">this</span><span class="s0">.text = text;</span>
    <span class="s0">}</span>
    <span class="s0">consumer() {</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.consumerCache) {</span>
            <span class="s2">this</span><span class="s0">.consumerCache = </span><span class="s2">new </span><span class="s0">SourceMapConsumer(</span><span class="s2">this</span><span class="s0">.text);</span>
        <span class="s0">}</span>
        <span class="s2">return this</span><span class="s0">.consumerCache;</span>
    <span class="s0">}</span>
    <span class="s0">decodeInline(text) {</span>
        <span class="s2">let </span><span class="s0">baseCharsetUri = </span><span class="s5">/^data:application\/json;charset=utf-?8;base64,/</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">baseUri = </span><span class="s5">/^data:application\/json;base64,/</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">charsetUri = </span><span class="s5">/^data:application\/json;charset=utf-?8,/</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">uri = </span><span class="s5">/^data:application\/json,/</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">uriMatch = text.match(charsetUri) || text.match(uri);</span>
        <span class="s2">if </span><span class="s0">(uriMatch) {</span>
            <span class="s2">return </span><span class="s0">decodeURIComponent(text.substr(uriMatch[</span><span class="s3">0</span><span class="s0">].length));</span>
        <span class="s0">}</span>
        <span class="s2">let </span><span class="s0">baseUriMatch = text.match(baseCharsetUri) || text.match(baseUri);</span>
        <span class="s2">if </span><span class="s0">(baseUriMatch) {</span>
            <span class="s2">return </span><span class="s0">fromBase64(text.substr(baseUriMatch[</span><span class="s3">0</span><span class="s0">].length));</span>
        <span class="s0">}</span>
        <span class="s2">let </span><span class="s0">encoding = text.match(</span><span class="s5">/data:application\/json;([^,]+),/</span><span class="s0">)[</span><span class="s3">1</span><span class="s0">];</span>
        <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">'Unsupported source map encoding ' </span><span class="s0">+ encoding);</span>
    <span class="s0">}</span>
    <span class="s0">getAnnotationURL(sourceMapString) {</span>
        <span class="s2">return </span><span class="s0">sourceMapString.replace(</span><span class="s5">/^\/\*\s*# sourceMappingURL=/</span><span class="s0">, </span><span class="s1">''</span><span class="s0">).trim();</span>
    <span class="s0">}</span>
    <span class="s0">isMap(map) {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">map !== </span><span class="s1">'object'</span><span class="s0">) </span><span class="s2">return false</span><span class="s0">;</span>
        <span class="s2">return typeof </span><span class="s0">map.mappings === </span><span class="s1">'string' </span><span class="s0">|| </span><span class="s2">typeof </span><span class="s0">map._mappings === </span><span class="s1">'string' </span><span class="s0">|| Array.isArray(map.sections);</span>
    <span class="s0">}</span>
    <span class="s0">loadAnnotation(css) {</span>
        <span class="s2">let </span><span class="s0">comments = css.match(</span><span class="s5">/\/\*\s*# sourceMappingURL=/g</span><span class="s0">);</span>
        <span class="s2">if </span><span class="s0">(!comments) </span><span class="s2">return</span><span class="s0">;</span>
        <span class="s6">// sourceMappingURLs from comments, strings, etc.</span>
        <span class="s2">let </span><span class="s0">start = css.lastIndexOf(comments.pop());</span>
        <span class="s2">let </span><span class="s0">end = css.indexOf(</span><span class="s1">'*/'</span><span class="s0">, start);</span>
        <span class="s2">if </span><span class="s0">(start &gt; -</span><span class="s3">1 </span><span class="s0">&amp;&amp; end &gt; -</span><span class="s3">1</span><span class="s0">) {</span>
            <span class="s6">// Locate the last sourceMappingURL to avoid pickin</span>
            <span class="s2">this</span><span class="s0">.annotation = </span><span class="s2">this</span><span class="s0">.getAnnotationURL(css.substring(start, end));</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">loadFile(path) {</span>
        <span class="s2">this</span><span class="s0">.root = dirname(path);</span>
        <span class="s2">if </span><span class="s0">(existsSync(path)) {</span>
            <span class="s2">this</span><span class="s0">.mapFile = path;</span>
            <span class="s2">return </span><span class="s0">readFileSync(path, </span><span class="s1">'utf-8'</span><span class="s0">).toString().trim();</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">loadMap(file, prev) {</span>
        <span class="s2">if </span><span class="s0">(prev === </span><span class="s2">false</span><span class="s0">) </span><span class="s2">return false</span><span class="s0">;</span>
        <span class="s2">if </span><span class="s0">(prev) {</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">prev === </span><span class="s1">'string'</span><span class="s0">) {</span>
                <span class="s2">return </span><span class="s0">prev;</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">prev === </span><span class="s1">'function'</span><span class="s0">) {</span>
                <span class="s2">let </span><span class="s0">prevPath = prev(file);</span>
                <span class="s2">if </span><span class="s0">(prevPath) {</span>
                    <span class="s2">let </span><span class="s0">map = </span><span class="s2">this</span><span class="s0">.loadFile(prevPath);</span>
                    <span class="s2">if </span><span class="s0">(!map) {</span>
                        <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">'Unable to load previous source map: ' </span><span class="s0">+ prevPath.toString());</span>
                    <span class="s0">}</span>
                    <span class="s2">return </span><span class="s0">map;</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(prev </span><span class="s2">instanceof </span><span class="s0">SourceMapConsumer) {</span>
                <span class="s2">return </span><span class="s0">SourceMapGenerator.fromSourceMap(prev).toString();</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(prev </span><span class="s2">instanceof </span><span class="s0">SourceMapGenerator) {</span>
                <span class="s2">return </span><span class="s0">prev.toString();</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.isMap(prev)) {</span>
                <span class="s2">return </span><span class="s0">JSON.stringify(prev);</span>
            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">'Unsupported previous source map format: ' </span><span class="s0">+ prev.toString());</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.inline) {</span>
            <span class="s2">return this</span><span class="s0">.decodeInline(</span><span class="s2">this</span><span class="s0">.annotation);</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.annotation) {</span>
            <span class="s2">let </span><span class="s0">map = </span><span class="s2">this</span><span class="s0">.annotation;</span>
            <span class="s2">if </span><span class="s0">(file) map = join(dirname(file), map);</span>
            <span class="s2">return this</span><span class="s0">.loadFile(map);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">startWith(string, start) {</span>
        <span class="s2">if </span><span class="s0">(!string) </span><span class="s2">return false</span><span class="s0">;</span>
        <span class="s2">return </span><span class="s0">string.substr(</span><span class="s3">0</span><span class="s0">, start.length) === start;</span>
    <span class="s0">}</span>
    <span class="s0">withContent() {</span>
        <span class="s2">return </span><span class="s0">!!(</span><span class="s2">this</span><span class="s0">.consumer().sourcesContent &amp;&amp; </span><span class="s2">this</span><span class="s0">.consumer().sourcesContent.length &gt; </span><span class="s3">0</span><span class="s0">);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">module.exports = PreviousMap;</span>
<span class="s0">PreviousMap.default = PreviousMap;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/input.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">let </span><span class="s0">{ nanoid } = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/nanoid/non-secure/index.cjs [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">{ isAbsolute, resolve } = __turbopack_context__.r(</span><span class="s1">&quot;[externals]/path [external] (path, cjs)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">{ SourceMapConsumer, SourceMapGenerator } = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/source-map-js/source-map.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">{ fileURLToPath, pathToFileURL } = __turbopack_context__.r(</span><span class="s1">&quot;[externals]/url [external] (url, cjs)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">CssSyntaxError = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/css-syntax-error.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">PreviousMap = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/previous-map.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">terminalHighlight = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/terminal-highlight.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">lineToIndexCache = Symbol(</span><span class="s1">'lineToIndexCache'</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">sourceMapAvailable = Boolean(SourceMapConsumer &amp;&amp; SourceMapGenerator);</span>
<span class="s2">let </span><span class="s0">pathAvailable = Boolean(resolve &amp;&amp; isAbsolute);</span>
<span class="s2">function </span><span class="s0">getLineToIndex(input) {</span>
    <span class="s2">if </span><span class="s0">(input[lineToIndexCache]) </span><span class="s2">return </span><span class="s0">input[lineToIndexCache];</span>
    <span class="s2">let </span><span class="s0">lines = input.css.split(</span><span class="s1">'</span><span class="s4">\n</span><span class="s1">'</span><span class="s0">);</span>
    <span class="s2">let </span><span class="s0">lineToIndex = </span><span class="s2">new </span><span class="s0">Array(lines.length);</span>
    <span class="s2">let </span><span class="s0">prevIndex = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">, l = lines.length; i &lt; l; i++){</span>
        <span class="s0">lineToIndex[i] = prevIndex;</span>
        <span class="s0">prevIndex += lines[i].length + </span><span class="s3">1</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">input[lineToIndexCache] = lineToIndex;</span>
    <span class="s2">return </span><span class="s0">lineToIndex;</span>
<span class="s0">}</span>
<span class="s2">class </span><span class="s0">Input {</span>
    <span class="s0">get from() {</span>
        <span class="s2">return this</span><span class="s0">.file || </span><span class="s2">this</span><span class="s0">.id;</span>
    <span class="s0">}</span>
    <span class="s0">constructor(css, opts = {}){</span>
        <span class="s2">if </span><span class="s0">(css === </span><span class="s2">null </span><span class="s0">|| </span><span class="s2">typeof </span><span class="s0">css === </span><span class="s1">'undefined' </span><span class="s0">|| </span><span class="s2">typeof </span><span class="s0">css === </span><span class="s1">'object' </span><span class="s0">&amp;&amp; !css.toString) {</span>
            <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">`PostCSS received </span><span class="s0">${css} </span><span class="s1">instead of CSS string`</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s2">this</span><span class="s0">.css = css.toString();</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.css[</span><span class="s3">0</span><span class="s0">] === </span><span class="s1">'</span><span class="s4">\uFEFF</span><span class="s1">' </span><span class="s0">|| </span><span class="s2">this</span><span class="s0">.css[</span><span class="s3">0</span><span class="s0">] === </span><span class="s1">'</span><span class="s4">\uFFFE</span><span class="s1">'</span><span class="s0">) {</span>
            <span class="s2">this</span><span class="s0">.hasBOM = </span><span class="s2">true</span><span class="s0">;</span>
            <span class="s2">this</span><span class="s0">.css = </span><span class="s2">this</span><span class="s0">.css.slice(</span><span class="s3">1</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">this</span><span class="s0">.hasBOM = </span><span class="s2">false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s2">this</span><span class="s0">.document = </span><span class="s2">this</span><span class="s0">.css;</span>
        <span class="s2">if </span><span class="s0">(opts.document) </span><span class="s2">this</span><span class="s0">.document = opts.document.toString();</span>
        <span class="s2">if </span><span class="s0">(opts.from) {</span>
            <span class="s2">if </span><span class="s0">(!pathAvailable || </span><span class="s5">/^\w+:\/\//</span><span class="s0">.test(opts.from) || isAbsolute(opts.from)) {</span>
                <span class="s2">this</span><span class="s0">.file = opts.from;</span>
            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                <span class="s2">this</span><span class="s0">.file = resolve(opts.from);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(pathAvailable &amp;&amp; sourceMapAvailable) {</span>
            <span class="s2">let </span><span class="s0">map = </span><span class="s2">new </span><span class="s0">PreviousMap(</span><span class="s2">this</span><span class="s0">.css, opts);</span>
            <span class="s2">if </span><span class="s0">(map.text) {</span>
                <span class="s2">this</span><span class="s0">.map = map;</span>
                <span class="s2">let </span><span class="s0">file = map.consumer().file;</span>
                <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.file &amp;&amp; file) </span><span class="s2">this</span><span class="s0">.file = </span><span class="s2">this</span><span class="s0">.mapResolve(file);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.file) {</span>
            <span class="s2">this</span><span class="s0">.id = </span><span class="s1">'&lt;input css ' </span><span class="s0">+ nanoid(</span><span class="s3">6</span><span class="s0">) + </span><span class="s1">'&gt;'</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.map) </span><span class="s2">this</span><span class="s0">.map.file = </span><span class="s2">this</span><span class="s0">.from;</span>
    <span class="s0">}</span>
    <span class="s0">error(message, line, column, opts = {}) {</span>
        <span class="s2">let </span><span class="s0">endColumn, endLine, endOffset, offset, result;</span>
        <span class="s2">if </span><span class="s0">(line &amp;&amp; </span><span class="s2">typeof </span><span class="s0">line === </span><span class="s1">'object'</span><span class="s0">) {</span>
            <span class="s2">let </span><span class="s0">start = line;</span>
            <span class="s2">let </span><span class="s0">end = column;</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">start.offset === </span><span class="s1">'number'</span><span class="s0">) {</span>
                <span class="s0">offset = start.offset;</span>
                <span class="s2">let </span><span class="s0">pos = </span><span class="s2">this</span><span class="s0">.fromOffset(offset);</span>
                <span class="s0">line = pos.line;</span>
                <span class="s0">column = pos.col;</span>
            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                <span class="s0">line = start.line;</span>
                <span class="s0">column = start.column;</span>
                <span class="s0">offset = </span><span class="s2">this</span><span class="s0">.fromLineAndColumn(line, column);</span>
            <span class="s0">}</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">end.offset === </span><span class="s1">'number'</span><span class="s0">) {</span>
                <span class="s0">endOffset = end.offset;</span>
                <span class="s2">let </span><span class="s0">pos = </span><span class="s2">this</span><span class="s0">.fromOffset(endOffset);</span>
                <span class="s0">endLine = pos.line;</span>
                <span class="s0">endColumn = pos.col;</span>
            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                <span class="s0">endLine = end.line;</span>
                <span class="s0">endColumn = end.column;</span>
                <span class="s0">endOffset = </span><span class="s2">this</span><span class="s0">.fromLineAndColumn(end.line, end.column);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(!column) {</span>
            <span class="s0">offset = line;</span>
            <span class="s2">let </span><span class="s0">pos = </span><span class="s2">this</span><span class="s0">.fromOffset(offset);</span>
            <span class="s0">line = pos.line;</span>
            <span class="s0">column = pos.col;</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s0">offset = </span><span class="s2">this</span><span class="s0">.fromLineAndColumn(line, column);</span>
        <span class="s0">}</span>
        <span class="s2">let </span><span class="s0">origin = </span><span class="s2">this</span><span class="s0">.origin(line, column, endLine, endColumn);</span>
        <span class="s2">if </span><span class="s0">(origin) {</span>
            <span class="s0">result = </span><span class="s2">new </span><span class="s0">CssSyntaxError(message, origin.endLine === undefined ? origin.line : {</span>
                <span class="s0">column: origin.column,</span>
                <span class="s0">line: origin.line</span>
            <span class="s0">}, origin.endLine === undefined ? origin.column : {</span>
                <span class="s0">column: origin.endColumn,</span>
                <span class="s0">line: origin.endLine</span>
            <span class="s0">}, origin.source, origin.file, opts.plugin);</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s0">result = </span><span class="s2">new </span><span class="s0">CssSyntaxError(message, endLine === undefined ? line : {</span>
                <span class="s0">column,</span>
                <span class="s0">line</span>
            <span class="s0">}, endLine === undefined ? column : {</span>
                <span class="s0">column: endColumn,</span>
                <span class="s0">line: endLine</span>
            <span class="s0">}, </span><span class="s2">this</span><span class="s0">.css, </span><span class="s2">this</span><span class="s0">.file, opts.plugin);</span>
        <span class="s0">}</span>
        <span class="s0">result.input = {</span>
            <span class="s0">column,</span>
            <span class="s0">endColumn,</span>
            <span class="s0">endLine,</span>
            <span class="s0">endOffset,</span>
            <span class="s0">line,</span>
            <span class="s0">offset,</span>
            <span class="s0">source: </span><span class="s2">this</span><span class="s0">.css</span>
        <span class="s0">};</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.file) {</span>
            <span class="s2">if </span><span class="s0">(pathToFileURL) {</span>
                <span class="s0">result.input.url = pathToFileURL(</span><span class="s2">this</span><span class="s0">.file).toString();</span>
            <span class="s0">}</span>
            <span class="s0">result.input.file = </span><span class="s2">this</span><span class="s0">.file;</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">result;</span>
    <span class="s0">}</span>
    <span class="s0">fromLineAndColumn(line, column) {</span>
        <span class="s2">let </span><span class="s0">lineToIndex = getLineToIndex(</span><span class="s2">this</span><span class="s0">);</span>
        <span class="s2">let </span><span class="s0">index = lineToIndex[line - </span><span class="s3">1</span><span class="s0">];</span>
        <span class="s2">return </span><span class="s0">index + column - </span><span class="s3">1</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">fromOffset(offset) {</span>
        <span class="s2">let </span><span class="s0">lineToIndex = getLineToIndex(</span><span class="s2">this</span><span class="s0">);</span>
        <span class="s2">let </span><span class="s0">lastLine = lineToIndex[lineToIndex.length - </span><span class="s3">1</span><span class="s0">];</span>
        <span class="s2">let </span><span class="s0">min = </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s2">if </span><span class="s0">(offset &gt;= lastLine) {</span>
            <span class="s0">min = lineToIndex.length - </span><span class="s3">1</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">let </span><span class="s0">max = lineToIndex.length - </span><span class="s3">2</span><span class="s0">;</span>
            <span class="s2">let </span><span class="s0">mid;</span>
            <span class="s2">while</span><span class="s0">(min &lt; max){</span>
                <span class="s0">mid = min + (max - min &gt;&gt; </span><span class="s3">1</span><span class="s0">);</span>
                <span class="s2">if </span><span class="s0">(offset &lt; lineToIndex[mid]) {</span>
                    <span class="s0">max = mid - </span><span class="s3">1</span><span class="s0">;</span>
                <span class="s0">} </span><span class="s2">else if </span><span class="s0">(offset &gt;= lineToIndex[mid + </span><span class="s3">1</span><span class="s0">]) {</span>
                    <span class="s0">min = mid + </span><span class="s3">1</span><span class="s0">;</span>
                <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                    <span class="s0">min = mid;</span>
                    <span class="s2">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">{</span>
            <span class="s0">col: offset - lineToIndex[min] + </span><span class="s3">1</span><span class="s0">,</span>
            <span class="s0">line: min + </span><span class="s3">1</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s0">mapResolve(file) {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s5">/^\w+:\/\//</span><span class="s0">.test(file)) {</span>
            <span class="s2">return </span><span class="s0">file;</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">resolve(</span><span class="s2">this</span><span class="s0">.map.consumer().sourceRoot || </span><span class="s2">this</span><span class="s0">.map.root || </span><span class="s1">'.'</span><span class="s0">, file);</span>
    <span class="s0">}</span>
    <span class="s0">origin(line, column, endLine, endColumn) {</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.map) </span><span class="s2">return false</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">consumer = </span><span class="s2">this</span><span class="s0">.map.consumer();</span>
        <span class="s2">let </span><span class="s0">from = consumer.originalPositionFor({</span>
            <span class="s0">column,</span>
            <span class="s0">line</span>
        <span class="s0">});</span>
        <span class="s2">if </span><span class="s0">(!from.source) </span><span class="s2">return false</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">to;</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">endLine === </span><span class="s1">'number'</span><span class="s0">) {</span>
            <span class="s0">to = consumer.originalPositionFor({</span>
                <span class="s0">column: endColumn,</span>
                <span class="s0">line: endLine</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s2">let </span><span class="s0">fromUrl;</span>
        <span class="s2">if </span><span class="s0">(isAbsolute(from.source)) {</span>
            <span class="s0">fromUrl = pathToFileURL(from.source);</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s0">fromUrl = </span><span class="s2">new </span><span class="s0">URL(from.source, </span><span class="s2">this</span><span class="s0">.map.consumer().sourceRoot || pathToFileURL(</span><span class="s2">this</span><span class="s0">.map.mapFile));</span>
        <span class="s0">}</span>
        <span class="s2">let </span><span class="s0">result = {</span>
            <span class="s0">column: from.column,</span>
            <span class="s0">endColumn: to &amp;&amp; to.column,</span>
            <span class="s0">endLine: to &amp;&amp; to.line,</span>
            <span class="s0">line: from.line,</span>
            <span class="s0">url: fromUrl.toString()</span>
        <span class="s0">};</span>
        <span class="s2">if </span><span class="s0">(fromUrl.protocol === </span><span class="s1">'file:'</span><span class="s0">) {</span>
            <span class="s2">if </span><span class="s0">(fileURLToPath) {</span>
                <span class="s0">result.file = fileURLToPath(fromUrl);</span>
            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                <span class="s6">/* c8 ignore next 2 */ </span><span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">`file: protocol is not available in this PostCSS build`</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">let </span><span class="s0">source = consumer.sourceContentFor(from.source);</span>
        <span class="s2">if </span><span class="s0">(source) result.source = source;</span>
        <span class="s2">return </span><span class="s0">result;</span>
    <span class="s0">}</span>
    <span class="s0">toJSON() {</span>
        <span class="s2">let </span><span class="s0">json = {};</span>
        <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">name of [</span>
            <span class="s1">'hasBOM'</span><span class="s0">,</span>
            <span class="s1">'css'</span><span class="s0">,</span>
            <span class="s1">'file'</span><span class="s0">,</span>
            <span class="s1">'id'</span>
        <span class="s0">]){</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">[name] != </span><span class="s2">null</span><span class="s0">) {</span>
                <span class="s0">json[name] = </span><span class="s2">this</span><span class="s0">[name];</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.map) {</span>
            <span class="s0">json.map = {</span>
                <span class="s0">...</span><span class="s2">this</span><span class="s0">.map</span>
            <span class="s0">};</span>
            <span class="s2">if </span><span class="s0">(json.map.consumerCache) {</span>
                <span class="s0">json.map.consumerCache = undefined;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">json;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">module.exports = Input;</span>
<span class="s0">Input.default = Input;</span>
<span class="s2">if </span><span class="s0">(terminalHighlight &amp;&amp; terminalHighlight.registerInput) {</span>
    <span class="s0">terminalHighlight.registerInput(Input);</span>
<span class="s0">}</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/root.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">let </span><span class="s0">Container = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/container.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">LazyResult, Processor;</span>
<span class="s2">class </span><span class="s0">Root </span><span class="s2">extends </span><span class="s0">Container {</span>
    <span class="s0">constructor(defaults){</span>
        <span class="s2">super</span><span class="s0">(defaults);</span>
        <span class="s2">this</span><span class="s0">.type = </span><span class="s1">'root'</span><span class="s0">;</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.nodes) </span><span class="s2">this</span><span class="s0">.nodes = [];</span>
    <span class="s0">}</span>
    <span class="s0">normalize(child, sample, type) {</span>
        <span class="s2">let </span><span class="s0">nodes = </span><span class="s2">super</span><span class="s0">.normalize(child);</span>
        <span class="s2">if </span><span class="s0">(sample) {</span>
            <span class="s2">if </span><span class="s0">(type === </span><span class="s1">'prepend'</span><span class="s0">) {</span>
                <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.nodes.length &gt; </span><span class="s3">1</span><span class="s0">) {</span>
                    <span class="s0">sample.raws.before = </span><span class="s2">this</span><span class="s0">.nodes[</span><span class="s3">1</span><span class="s0">].raws.before;</span>
                <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                    <span class="s2">delete </span><span class="s0">sample.raws.before;</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.first !== sample) {</span>
                <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">node of nodes){</span>
                    <span class="s0">node.raws.before = sample.raws.before;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">nodes;</span>
    <span class="s0">}</span>
    <span class="s0">removeChild(child, ignore) {</span>
        <span class="s2">let </span><span class="s0">index = </span><span class="s2">this</span><span class="s0">.index(child);</span>
        <span class="s2">if </span><span class="s0">(!ignore &amp;&amp; index === </span><span class="s3">0 </span><span class="s0">&amp;&amp; </span><span class="s2">this</span><span class="s0">.nodes.length &gt; </span><span class="s3">1</span><span class="s0">) {</span>
            <span class="s2">this</span><span class="s0">.nodes[</span><span class="s3">1</span><span class="s0">].raws.before = </span><span class="s2">this</span><span class="s0">.nodes[index].raws.before;</span>
        <span class="s0">}</span>
        <span class="s2">return super</span><span class="s0">.removeChild(child);</span>
    <span class="s0">}</span>
    <span class="s0">toResult(opts = {}) {</span>
        <span class="s2">let </span><span class="s0">lazy = </span><span class="s2">new </span><span class="s0">LazyResult(</span><span class="s2">new </span><span class="s0">Processor(), </span><span class="s2">this</span><span class="s0">, opts);</span>
        <span class="s2">return </span><span class="s0">lazy.stringify();</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">Root.registerLazyResult = (dependant)=&gt;{</span>
    <span class="s0">LazyResult = dependant;</span>
<span class="s0">};</span>
<span class="s0">Root.registerProcessor = (dependant)=&gt;{</span>
    <span class="s0">Processor = dependant;</span>
<span class="s0">};</span>
<span class="s0">module.exports = Root;</span>
<span class="s0">Root.default = Root;</span>
<span class="s0">Container.registerRoot(Root);</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/list.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">let </span><span class="s0">list = {</span>
    <span class="s0">comma (string) {</span>
        <span class="s2">return </span><span class="s0">list.split(string, [</span>
            <span class="s1">','</span>
        <span class="s0">], </span><span class="s2">true</span><span class="s0">);</span>
    <span class="s0">},</span>
    <span class="s0">space (string) {</span>
        <span class="s2">let </span><span class="s0">spaces = [</span>
            <span class="s1">' '</span><span class="s0">,</span>
            <span class="s1">'</span><span class="s4">\n</span><span class="s1">'</span><span class="s0">,</span>
            <span class="s1">'</span><span class="s4">\t</span><span class="s1">'</span>
        <span class="s0">];</span>
        <span class="s2">return </span><span class="s0">list.split(string, spaces);</span>
    <span class="s0">},</span>
    <span class="s0">split (string, separators, last) {</span>
        <span class="s2">let </span><span class="s0">array = [];</span>
        <span class="s2">let </span><span class="s0">current = </span><span class="s1">''</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">split = </span><span class="s2">false</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">func = </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">inQuote = </span><span class="s2">false</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">prevQuote = </span><span class="s1">''</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">escape = </span><span class="s2">false</span><span class="s0">;</span>
        <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">letter of string){</span>
            <span class="s2">if </span><span class="s0">(escape) {</span>
                <span class="s0">escape = </span><span class="s2">false</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(letter === </span><span class="s1">'</span><span class="s4">\\</span><span class="s1">'</span><span class="s0">) {</span>
                <span class="s0">escape = </span><span class="s2">true</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(inQuote) {</span>
                <span class="s2">if </span><span class="s0">(letter === prevQuote) {</span>
                    <span class="s0">inQuote = </span><span class="s2">false</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(letter === </span><span class="s1">'&quot;' </span><span class="s0">|| letter === </span><span class="s1">&quot;'&quot;</span><span class="s0">) {</span>
                <span class="s0">inQuote = </span><span class="s2">true</span><span class="s0">;</span>
                <span class="s0">prevQuote = letter;</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(letter === </span><span class="s1">'('</span><span class="s0">) {</span>
                <span class="s0">func += </span><span class="s3">1</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(letter === </span><span class="s1">')'</span><span class="s0">) {</span>
                <span class="s2">if </span><span class="s0">(func &gt; </span><span class="s3">0</span><span class="s0">) func -= </span><span class="s3">1</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(func === </span><span class="s3">0</span><span class="s0">) {</span>
                <span class="s2">if </span><span class="s0">(separators.includes(letter)) split = </span><span class="s2">true</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s2">if </span><span class="s0">(split) {</span>
                <span class="s2">if </span><span class="s0">(current !== </span><span class="s1">''</span><span class="s0">) array.push(current.trim());</span>
                <span class="s0">current = </span><span class="s1">''</span><span class="s0">;</span>
                <span class="s0">split = </span><span class="s2">false</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                <span class="s0">current += letter;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(last || current !== </span><span class="s1">''</span><span class="s0">) array.push(current.trim());</span>
        <span class="s2">return </span><span class="s0">array;</span>
    <span class="s0">}</span>
<span class="s0">};</span>
<span class="s0">module.exports = list;</span>
<span class="s0">list.default = list;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/rule.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">let </span><span class="s0">Container = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/container.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">list = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/list.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">class </span><span class="s0">Rule </span><span class="s2">extends </span><span class="s0">Container {</span>
    <span class="s0">get selectors() {</span>
        <span class="s2">return </span><span class="s0">list.comma(</span><span class="s2">this</span><span class="s0">.selector);</span>
    <span class="s0">}</span>
    <span class="s0">set selectors(values) {</span>
        <span class="s2">let </span><span class="s0">match = </span><span class="s2">this</span><span class="s0">.selector ? </span><span class="s2">this</span><span class="s0">.selector.match(</span><span class="s5">/,\s*/</span><span class="s0">) : </span><span class="s2">null</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">sep = match ? match[</span><span class="s3">0</span><span class="s0">] : </span><span class="s1">',' </span><span class="s0">+ </span><span class="s2">this</span><span class="s0">.raw(</span><span class="s1">'between'</span><span class="s0">, </span><span class="s1">'beforeOpen'</span><span class="s0">);</span>
        <span class="s2">this</span><span class="s0">.selector = values.join(sep);</span>
    <span class="s0">}</span>
    <span class="s0">constructor(defaults){</span>
        <span class="s2">super</span><span class="s0">(defaults);</span>
        <span class="s2">this</span><span class="s0">.type = </span><span class="s1">'rule'</span><span class="s0">;</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.nodes) </span><span class="s2">this</span><span class="s0">.nodes = [];</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">module.exports = Rule;</span>
<span class="s0">Rule.default = Rule;</span>
<span class="s0">Container.registerRule(Rule);</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/fromJSON.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">let </span><span class="s0">AtRule = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/at-rule.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Comment = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/comment.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Declaration = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/declaration.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Input = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/input.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">PreviousMap = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/previous-map.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Root = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/root.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Rule = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/rule.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">function </span><span class="s0">fromJSON(json, inputs) {</span>
    <span class="s2">if </span><span class="s0">(Array.isArray(json)) </span><span class="s2">return </span><span class="s0">json.map((n)=&gt;fromJSON(n));</span>
    <span class="s2">let </span><span class="s0">{ inputs: ownInputs, ...defaults } = json;</span>
    <span class="s2">if </span><span class="s0">(ownInputs) {</span>
        <span class="s0">inputs = [];</span>
        <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">input of ownInputs){</span>
            <span class="s2">let </span><span class="s0">inputHydrated = {</span>
                <span class="s0">...input,</span>
                <span class="s0">__proto__: Input.prototype</span>
            <span class="s0">};</span>
            <span class="s2">if </span><span class="s0">(inputHydrated.map) {</span>
                <span class="s0">inputHydrated.map = {</span>
                    <span class="s0">...inputHydrated.map,</span>
                    <span class="s0">__proto__: PreviousMap.prototype</span>
                <span class="s0">};</span>
            <span class="s0">}</span>
            <span class="s0">inputs.push(inputHydrated);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(defaults.nodes) {</span>
        <span class="s0">defaults.nodes = json.nodes.map((n)=&gt;fromJSON(n, inputs));</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(defaults.source) {</span>
        <span class="s2">let </span><span class="s0">{ inputId, ...source } = defaults.source;</span>
        <span class="s0">defaults.source = source;</span>
        <span class="s2">if </span><span class="s0">(inputId != </span><span class="s2">null</span><span class="s0">) {</span>
            <span class="s0">defaults.source.input = inputs[inputId];</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(defaults.type === </span><span class="s1">'root'</span><span class="s0">) {</span>
        <span class="s2">return new </span><span class="s0">Root(defaults);</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(defaults.type === </span><span class="s1">'decl'</span><span class="s0">) {</span>
        <span class="s2">return new </span><span class="s0">Declaration(defaults);</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(defaults.type === </span><span class="s1">'rule'</span><span class="s0">) {</span>
        <span class="s2">return new </span><span class="s0">Rule(defaults);</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(defaults.type === </span><span class="s1">'comment'</span><span class="s0">) {</span>
        <span class="s2">return new </span><span class="s0">Comment(defaults);</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(defaults.type === </span><span class="s1">'atrule'</span><span class="s0">) {</span>
        <span class="s2">return new </span><span class="s0">AtRule(defaults);</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">'Unknown node type: ' </span><span class="s0">+ json.type);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">module.exports = fromJSON;</span>
<span class="s0">fromJSON.default = fromJSON;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/map-generator.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">let </span><span class="s0">{ dirname, relative, resolve, sep } = __turbopack_context__.r(</span><span class="s1">&quot;[externals]/path [external] (path, cjs)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">{ SourceMapConsumer, SourceMapGenerator } = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/source-map-js/source-map.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">{ pathToFileURL } = __turbopack_context__.r(</span><span class="s1">&quot;[externals]/url [external] (url, cjs)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Input = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/input.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">sourceMapAvailable = Boolean(SourceMapConsumer &amp;&amp; SourceMapGenerator);</span>
<span class="s2">let </span><span class="s0">pathAvailable = Boolean(dirname &amp;&amp; resolve &amp;&amp; relative &amp;&amp; sep);</span>
<span class="s2">class </span><span class="s0">MapGenerator {</span>
    <span class="s0">constructor(stringify, root, opts, cssString){</span>
        <span class="s2">this</span><span class="s0">.stringify = stringify;</span>
        <span class="s2">this</span><span class="s0">.mapOpts = opts.map || {};</span>
        <span class="s2">this</span><span class="s0">.root = root;</span>
        <span class="s2">this</span><span class="s0">.opts = opts;</span>
        <span class="s2">this</span><span class="s0">.css = cssString;</span>
        <span class="s2">this</span><span class="s0">.originalCSS = cssString;</span>
        <span class="s2">this</span><span class="s0">.usesFileUrls = !</span><span class="s2">this</span><span class="s0">.mapOpts.from &amp;&amp; </span><span class="s2">this</span><span class="s0">.mapOpts.absolute;</span>
        <span class="s2">this</span><span class="s0">.memoizedFileURLs = </span><span class="s2">new </span><span class="s0">Map();</span>
        <span class="s2">this</span><span class="s0">.memoizedPaths = </span><span class="s2">new </span><span class="s0">Map();</span>
        <span class="s2">this</span><span class="s0">.memoizedURLs = </span><span class="s2">new </span><span class="s0">Map();</span>
    <span class="s0">}</span>
    <span class="s0">addAnnotation() {</span>
        <span class="s2">let </span><span class="s0">content;</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.isInline()) {</span>
            <span class="s0">content = </span><span class="s1">'data:application/json;base64,' </span><span class="s0">+ </span><span class="s2">this</span><span class="s0">.toBase64(</span><span class="s2">this</span><span class="s0">.map.toString());</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">typeof this</span><span class="s0">.mapOpts.annotation === </span><span class="s1">'string'</span><span class="s0">) {</span>
            <span class="s0">content = </span><span class="s2">this</span><span class="s0">.mapOpts.annotation;</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">typeof this</span><span class="s0">.mapOpts.annotation === </span><span class="s1">'function'</span><span class="s0">) {</span>
            <span class="s0">content = </span><span class="s2">this</span><span class="s0">.mapOpts.annotation(</span><span class="s2">this</span><span class="s0">.opts.to, </span><span class="s2">this</span><span class="s0">.root);</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s0">content = </span><span class="s2">this</span><span class="s0">.outputFile() + </span><span class="s1">'.map'</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s2">let </span><span class="s0">eol = </span><span class="s1">'</span><span class="s4">\n</span><span class="s1">'</span><span class="s0">;</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.css.includes(</span><span class="s1">'</span><span class="s4">\r\n</span><span class="s1">'</span><span class="s0">)) eol = </span><span class="s1">'</span><span class="s4">\r\n</span><span class="s1">'</span><span class="s0">;</span>
        <span class="s2">this</span><span class="s0">.css += eol + </span><span class="s1">'/*# sourceMappingURL=' </span><span class="s0">+ content + </span><span class="s1">' */'</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">applyPrevMaps() {</span>
        <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">prev of </span><span class="s2">this</span><span class="s0">.previous()){</span>
            <span class="s2">let </span><span class="s0">from = </span><span class="s2">this</span><span class="s0">.toUrl(</span><span class="s2">this</span><span class="s0">.path(prev.file));</span>
            <span class="s2">let </span><span class="s0">root = prev.root || dirname(prev.file);</span>
            <span class="s2">let </span><span class="s0">map;</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.mapOpts.sourcesContent === </span><span class="s2">false</span><span class="s0">) {</span>
                <span class="s0">map = </span><span class="s2">new </span><span class="s0">SourceMapConsumer(prev.text);</span>
                <span class="s2">if </span><span class="s0">(map.sourcesContent) {</span>
                    <span class="s0">map.sourcesContent = </span><span class="s2">null</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                <span class="s0">map = prev.consumer();</span>
            <span class="s0">}</span>
            <span class="s2">this</span><span class="s0">.map.applySourceMap(map, from, </span><span class="s2">this</span><span class="s0">.toUrl(</span><span class="s2">this</span><span class="s0">.path(root)));</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">clearAnnotation() {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.mapOpts.annotation === </span><span class="s2">false</span><span class="s0">) </span><span class="s2">return</span><span class="s0">;</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.root) {</span>
            <span class="s2">let </span><span class="s0">node;</span>
            <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">i = </span><span class="s2">this</span><span class="s0">.root.nodes.length - </span><span class="s3">1</span><span class="s0">; i &gt;= </span><span class="s3">0</span><span class="s0">; i--){</span>
                <span class="s0">node = </span><span class="s2">this</span><span class="s0">.root.nodes[i];</span>
                <span class="s2">if </span><span class="s0">(node.type !== </span><span class="s1">'comment'</span><span class="s0">) </span><span class="s2">continue</span><span class="s0">;</span>
                <span class="s2">if </span><span class="s0">(node.text.startsWith(</span><span class="s1">'# sourceMappingURL='</span><span class="s0">)) {</span>
                    <span class="s2">this</span><span class="s0">.root.removeChild(i);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.css) {</span>
            <span class="s2">this</span><span class="s0">.css = </span><span class="s2">this</span><span class="s0">.css.replace(</span><span class="s5">/\n*\/\*#[\S\s]*?\*\/$/gm</span><span class="s0">, </span><span class="s1">''</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">generate() {</span>
        <span class="s2">this</span><span class="s0">.clearAnnotation();</span>
        <span class="s2">if </span><span class="s0">(pathAvailable &amp;&amp; sourceMapAvailable &amp;&amp; </span><span class="s2">this</span><span class="s0">.isMap()) {</span>
            <span class="s2">return this</span><span class="s0">.generateMap();</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">let </span><span class="s0">result = </span><span class="s1">''</span><span class="s0">;</span>
            <span class="s2">this</span><span class="s0">.stringify(</span><span class="s2">this</span><span class="s0">.root, (i)=&gt;{</span>
                <span class="s0">result += i;</span>
            <span class="s0">});</span>
            <span class="s2">return </span><span class="s0">[</span>
                <span class="s0">result</span>
            <span class="s0">];</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">generateMap() {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.root) {</span>
            <span class="s2">this</span><span class="s0">.generateString();</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.previous().length === </span><span class="s3">1</span><span class="s0">) {</span>
            <span class="s2">let </span><span class="s0">prev = </span><span class="s2">this</span><span class="s0">.previous()[</span><span class="s3">0</span><span class="s0">].consumer();</span>
            <span class="s0">prev.file = </span><span class="s2">this</span><span class="s0">.outputFile();</span>
            <span class="s2">this</span><span class="s0">.map = SourceMapGenerator.fromSourceMap(prev, {</span>
                <span class="s0">ignoreInvalidMapping: </span><span class="s2">true</span>
            <span class="s0">});</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">this</span><span class="s0">.map = </span><span class="s2">new </span><span class="s0">SourceMapGenerator({</span>
                <span class="s0">file: </span><span class="s2">this</span><span class="s0">.outputFile(),</span>
                <span class="s0">ignoreInvalidMapping: </span><span class="s2">true</span>
            <span class="s0">});</span>
            <span class="s2">this</span><span class="s0">.map.addMapping({</span>
                <span class="s0">generated: {</span>
                    <span class="s0">column: </span><span class="s3">0</span><span class="s0">,</span>
                    <span class="s0">line: </span><span class="s3">1</span>
                <span class="s0">},</span>
                <span class="s0">original: {</span>
                    <span class="s0">column: </span><span class="s3">0</span><span class="s0">,</span>
                    <span class="s0">line: </span><span class="s3">1</span>
                <span class="s0">},</span>
                <span class="s0">source: </span><span class="s2">this</span><span class="s0">.opts.from ? </span><span class="s2">this</span><span class="s0">.toUrl(</span><span class="s2">this</span><span class="s0">.path(</span><span class="s2">this</span><span class="s0">.opts.from)) : </span><span class="s1">'&lt;no source&gt;'</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.isSourcesContent()) </span><span class="s2">this</span><span class="s0">.setSourcesContent();</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.root &amp;&amp; </span><span class="s2">this</span><span class="s0">.previous().length &gt; </span><span class="s3">0</span><span class="s0">) </span><span class="s2">this</span><span class="s0">.applyPrevMaps();</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.isAnnotation()) </span><span class="s2">this</span><span class="s0">.addAnnotation();</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.isInline()) {</span>
            <span class="s2">return </span><span class="s0">[</span>
                <span class="s2">this</span><span class="s0">.css</span>
            <span class="s0">];</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">return </span><span class="s0">[</span>
                <span class="s2">this</span><span class="s0">.css,</span>
                <span class="s2">this</span><span class="s0">.map</span>
            <span class="s0">];</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">generateString() {</span>
        <span class="s2">this</span><span class="s0">.css = </span><span class="s1">''</span><span class="s0">;</span>
        <span class="s2">this</span><span class="s0">.map = </span><span class="s2">new </span><span class="s0">SourceMapGenerator({</span>
            <span class="s0">file: </span><span class="s2">this</span><span class="s0">.outputFile(),</span>
            <span class="s0">ignoreInvalidMapping: </span><span class="s2">true</span>
        <span class="s0">});</span>
        <span class="s2">let </span><span class="s0">line = </span><span class="s3">1</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">column = </span><span class="s3">1</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">noSource = </span><span class="s1">'&lt;no source&gt;'</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">mapping = {</span>
            <span class="s0">generated: {</span>
                <span class="s0">column: </span><span class="s3">0</span><span class="s0">,</span>
                <span class="s0">line: </span><span class="s3">0</span>
            <span class="s0">},</span>
            <span class="s0">original: {</span>
                <span class="s0">column: </span><span class="s3">0</span><span class="s0">,</span>
                <span class="s0">line: </span><span class="s3">0</span>
            <span class="s0">},</span>
            <span class="s0">source: </span><span class="s1">''</span>
        <span class="s0">};</span>
        <span class="s2">let </span><span class="s0">last, lines;</span>
        <span class="s2">this</span><span class="s0">.stringify(</span><span class="s2">this</span><span class="s0">.root, (str, node, type)=&gt;{</span>
            <span class="s2">this</span><span class="s0">.css += str;</span>
            <span class="s2">if </span><span class="s0">(node &amp;&amp; type !== </span><span class="s1">'end'</span><span class="s0">) {</span>
                <span class="s0">mapping.generated.line = line;</span>
                <span class="s0">mapping.generated.column = column - </span><span class="s3">1</span><span class="s0">;</span>
                <span class="s2">if </span><span class="s0">(node.source &amp;&amp; node.source.start) {</span>
                    <span class="s0">mapping.source = </span><span class="s2">this</span><span class="s0">.sourcePath(node);</span>
                    <span class="s0">mapping.original.line = node.source.start.line;</span>
                    <span class="s0">mapping.original.column = node.source.start.column - </span><span class="s3">1</span><span class="s0">;</span>
                    <span class="s2">this</span><span class="s0">.map.addMapping(mapping);</span>
                <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                    <span class="s0">mapping.source = noSource;</span>
                    <span class="s0">mapping.original.line = </span><span class="s3">1</span><span class="s0">;</span>
                    <span class="s0">mapping.original.column = </span><span class="s3">0</span><span class="s0">;</span>
                    <span class="s2">this</span><span class="s0">.map.addMapping(mapping);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">lines = str.match(</span><span class="s5">/\n/g</span><span class="s0">);</span>
            <span class="s2">if </span><span class="s0">(lines) {</span>
                <span class="s0">line += lines.length;</span>
                <span class="s0">last = str.lastIndexOf(</span><span class="s1">'</span><span class="s4">\n</span><span class="s1">'</span><span class="s0">);</span>
                <span class="s0">column = str.length - last;</span>
            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                <span class="s0">column += str.length;</span>
            <span class="s0">}</span>
            <span class="s2">if </span><span class="s0">(node &amp;&amp; type !== </span><span class="s1">'start'</span><span class="s0">) {</span>
                <span class="s2">let </span><span class="s0">p = node.parent || {</span>
                    <span class="s0">raws: {}</span>
                <span class="s0">};</span>
                <span class="s2">let </span><span class="s0">childless = node.type === </span><span class="s1">'decl' </span><span class="s0">|| node.type === </span><span class="s1">'atrule' </span><span class="s0">&amp;&amp; !node.nodes;</span>
                <span class="s2">if </span><span class="s0">(!childless || node !== p.last || p.raws.semicolon) {</span>
                    <span class="s2">if </span><span class="s0">(node.source &amp;&amp; node.source.end) {</span>
                        <span class="s0">mapping.source = </span><span class="s2">this</span><span class="s0">.sourcePath(node);</span>
                        <span class="s0">mapping.original.line = node.source.end.line;</span>
                        <span class="s0">mapping.original.column = node.source.end.column - </span><span class="s3">1</span><span class="s0">;</span>
                        <span class="s0">mapping.generated.line = line;</span>
                        <span class="s0">mapping.generated.column = column - </span><span class="s3">2</span><span class="s0">;</span>
                        <span class="s2">this</span><span class="s0">.map.addMapping(mapping);</span>
                    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                        <span class="s0">mapping.source = noSource;</span>
                        <span class="s0">mapping.original.line = </span><span class="s3">1</span><span class="s0">;</span>
                        <span class="s0">mapping.original.column = </span><span class="s3">0</span><span class="s0">;</span>
                        <span class="s0">mapping.generated.line = line;</span>
                        <span class="s0">mapping.generated.column = column - </span><span class="s3">1</span><span class="s0">;</span>
                        <span class="s2">this</span><span class="s0">.map.addMapping(mapping);</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s0">isAnnotation() {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.isInline()) {</span>
            <span class="s2">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof this</span><span class="s0">.mapOpts.annotation !== </span><span class="s1">'undefined'</span><span class="s0">) {</span>
            <span class="s2">return this</span><span class="s0">.mapOpts.annotation;</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.previous().length) {</span>
            <span class="s2">return this</span><span class="s0">.previous().some((i)=&gt;i.annotation);</span>
        <span class="s0">}</span>
        <span class="s2">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">isInline() {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof this</span><span class="s0">.mapOpts.inline !== </span><span class="s1">'undefined'</span><span class="s0">) {</span>
            <span class="s2">return this</span><span class="s0">.mapOpts.inline;</span>
        <span class="s0">}</span>
        <span class="s2">let </span><span class="s0">annotation = </span><span class="s2">this</span><span class="s0">.mapOpts.annotation;</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">annotation !== </span><span class="s1">'undefined' </span><span class="s0">&amp;&amp; annotation !== </span><span class="s2">true</span><span class="s0">) {</span>
            <span class="s2">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.previous().length) {</span>
            <span class="s2">return this</span><span class="s0">.previous().some((i)=&gt;i.inline);</span>
        <span class="s0">}</span>
        <span class="s2">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">isMap() {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof this</span><span class="s0">.opts.map !== </span><span class="s1">'undefined'</span><span class="s0">) {</span>
            <span class="s2">return </span><span class="s0">!!</span><span class="s2">this</span><span class="s0">.opts.map;</span>
        <span class="s0">}</span>
        <span class="s2">return this</span><span class="s0">.previous().length &gt; </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">isSourcesContent() {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof this</span><span class="s0">.mapOpts.sourcesContent !== </span><span class="s1">'undefined'</span><span class="s0">) {</span>
            <span class="s2">return this</span><span class="s0">.mapOpts.sourcesContent;</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.previous().length) {</span>
            <span class="s2">return this</span><span class="s0">.previous().some((i)=&gt;i.withContent());</span>
        <span class="s0">}</span>
        <span class="s2">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">outputFile() {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.opts.to) {</span>
            <span class="s2">return this</span><span class="s0">.path(</span><span class="s2">this</span><span class="s0">.opts.to);</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.opts.from) {</span>
            <span class="s2">return this</span><span class="s0">.path(</span><span class="s2">this</span><span class="s0">.opts.from);</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">return </span><span class="s1">'to.css'</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">path(file) {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.mapOpts.absolute) </span><span class="s2">return </span><span class="s0">file;</span>
        <span class="s2">if </span><span class="s0">(file.charCodeAt(</span><span class="s3">0</span><span class="s0">) === </span><span class="s3">60 </span><span class="s6">/* `&lt;` */ </span><span class="s0">) </span><span class="s2">return </span><span class="s0">file;</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s5">/^\w+:\/\//</span><span class="s0">.test(file)) </span><span class="s2">return </span><span class="s0">file;</span>
        <span class="s2">let </span><span class="s0">cached = </span><span class="s2">this</span><span class="s0">.memoizedPaths.get(file);</span>
        <span class="s2">if </span><span class="s0">(cached) </span><span class="s2">return </span><span class="s0">cached;</span>
        <span class="s2">let </span><span class="s0">from = </span><span class="s2">this</span><span class="s0">.opts.to ? dirname(</span><span class="s2">this</span><span class="s0">.opts.to) : </span><span class="s1">'.'</span><span class="s0">;</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof this</span><span class="s0">.mapOpts.annotation === </span><span class="s1">'string'</span><span class="s0">) {</span>
            <span class="s0">from = dirname(resolve(from, </span><span class="s2">this</span><span class="s0">.mapOpts.annotation));</span>
        <span class="s0">}</span>
        <span class="s2">let </span><span class="s0">path = relative(from, file);</span>
        <span class="s2">this</span><span class="s0">.memoizedPaths.set(file, path);</span>
        <span class="s2">return </span><span class="s0">path;</span>
    <span class="s0">}</span>
    <span class="s0">previous() {</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.previousMaps) {</span>
            <span class="s2">this</span><span class="s0">.previousMaps = [];</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.root) {</span>
                <span class="s2">this</span><span class="s0">.root.walk((node)=&gt;{</span>
                    <span class="s2">if </span><span class="s0">(node.source &amp;&amp; node.source.input.map) {</span>
                        <span class="s2">let </span><span class="s0">map = node.source.input.map;</span>
                        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.previousMaps.includes(map)) {</span>
                            <span class="s2">this</span><span class="s0">.previousMaps.push(map);</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">});</span>
            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                <span class="s2">let </span><span class="s0">input = </span><span class="s2">new </span><span class="s0">Input(</span><span class="s2">this</span><span class="s0">.originalCSS, </span><span class="s2">this</span><span class="s0">.opts);</span>
                <span class="s2">if </span><span class="s0">(input.map) </span><span class="s2">this</span><span class="s0">.previousMaps.push(input.map);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">return this</span><span class="s0">.previousMaps;</span>
    <span class="s0">}</span>
    <span class="s0">setSourcesContent() {</span>
        <span class="s2">let </span><span class="s0">already = {};</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.root) {</span>
            <span class="s2">this</span><span class="s0">.root.walk((node)=&gt;{</span>
                <span class="s2">if </span><span class="s0">(node.source) {</span>
                    <span class="s2">let </span><span class="s0">from = node.source.input.from;</span>
                    <span class="s2">if </span><span class="s0">(from &amp;&amp; !already[from]) {</span>
                        <span class="s0">already[from] = </span><span class="s2">true</span><span class="s0">;</span>
                        <span class="s2">let </span><span class="s0">fromUrl = </span><span class="s2">this</span><span class="s0">.usesFileUrls ? </span><span class="s2">this</span><span class="s0">.toFileUrl(from) : </span><span class="s2">this</span><span class="s0">.toUrl(</span><span class="s2">this</span><span class="s0">.path(from));</span>
                        <span class="s2">this</span><span class="s0">.map.setSourceContent(fromUrl, node.source.input.css);</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.css) {</span>
            <span class="s2">let </span><span class="s0">from = </span><span class="s2">this</span><span class="s0">.opts.from ? </span><span class="s2">this</span><span class="s0">.toUrl(</span><span class="s2">this</span><span class="s0">.path(</span><span class="s2">this</span><span class="s0">.opts.from)) : </span><span class="s1">'&lt;no source&gt;'</span><span class="s0">;</span>
            <span class="s2">this</span><span class="s0">.map.setSourceContent(from, </span><span class="s2">this</span><span class="s0">.css);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">sourcePath(node) {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.mapOpts.from) {</span>
            <span class="s2">return this</span><span class="s0">.toUrl(</span><span class="s2">this</span><span class="s0">.mapOpts.from);</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.usesFileUrls) {</span>
            <span class="s2">return this</span><span class="s0">.toFileUrl(node.source.input.from);</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">return this</span><span class="s0">.toUrl(</span><span class="s2">this</span><span class="s0">.path(node.source.input.from));</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">toBase64(str) {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s1">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s0">) {</span>
            <span class="s2">return </span><span class="s0">Buffer.from(str).toString(</span><span class="s1">'base64'</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s6">//TURBOPACK unreachable</span>
        <span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">toFileUrl(path) {</span>
        <span class="s2">let </span><span class="s0">cached = </span><span class="s2">this</span><span class="s0">.memoizedFileURLs.get(path);</span>
        <span class="s2">if </span><span class="s0">(cached) </span><span class="s2">return </span><span class="s0">cached;</span>
        <span class="s2">if </span><span class="s0">(pathToFileURL) {</span>
            <span class="s2">let </span><span class="s0">fileURL = pathToFileURL(path).toString();</span>
            <span class="s2">this</span><span class="s0">.memoizedFileURLs.set(path, fileURL);</span>
            <span class="s2">return </span><span class="s0">fileURL;</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">'`map.absolute` option is not available in this PostCSS build'</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">toUrl(path) {</span>
        <span class="s2">let </span><span class="s0">cached = </span><span class="s2">this</span><span class="s0">.memoizedURLs.get(path);</span>
        <span class="s2">if </span><span class="s0">(cached) </span><span class="s2">return </span><span class="s0">cached;</span>
        <span class="s2">if </span><span class="s0">(sep === </span><span class="s1">'</span><span class="s4">\\</span><span class="s1">'</span><span class="s0">) {</span>
            <span class="s0">path = path.replace(</span><span class="s5">/\\/g</span><span class="s0">, </span><span class="s1">'/'</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s2">let </span><span class="s0">url = encodeURI(path).replace(</span><span class="s5">/[#?]/g</span><span class="s0">, encodeURIComponent);</span>
        <span class="s2">this</span><span class="s0">.memoizedURLs.set(path, url);</span>
        <span class="s2">return </span><span class="s0">url;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">module.exports = MapGenerator;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/parser.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">let </span><span class="s0">AtRule = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/at-rule.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Comment = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/comment.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Declaration = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/declaration.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Root = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/root.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Rule = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/rule.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">tokenizer = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/tokenize.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">const </span><span class="s0">SAFE_COMMENT_NEIGHBOR = {</span>
    <span class="s0">empty: </span><span class="s2">true</span><span class="s0">,</span>
    <span class="s0">space: </span><span class="s2">true</span>
<span class="s0">};</span>
<span class="s2">function </span><span class="s0">findLastWithPosition(tokens) {</span>
    <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">i = tokens.length - </span><span class="s3">1</span><span class="s0">; i &gt;= </span><span class="s3">0</span><span class="s0">; i--){</span>
        <span class="s2">let </span><span class="s0">token = tokens[i];</span>
        <span class="s2">let </span><span class="s0">pos = token[</span><span class="s3">3</span><span class="s0">] || token[</span><span class="s3">2</span><span class="s0">];</span>
        <span class="s2">if </span><span class="s0">(pos) </span><span class="s2">return </span><span class="s0">pos;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s2">class </span><span class="s0">Parser {</span>
    <span class="s0">constructor(input){</span>
        <span class="s2">this</span><span class="s0">.input = input;</span>
        <span class="s2">this</span><span class="s0">.root = </span><span class="s2">new </span><span class="s0">Root();</span>
        <span class="s2">this</span><span class="s0">.current = </span><span class="s2">this</span><span class="s0">.root;</span>
        <span class="s2">this</span><span class="s0">.spaces = </span><span class="s1">''</span><span class="s0">;</span>
        <span class="s2">this</span><span class="s0">.semicolon = </span><span class="s2">false</span><span class="s0">;</span>
        <span class="s2">this</span><span class="s0">.createTokenizer();</span>
        <span class="s2">this</span><span class="s0">.root.source = {</span>
            <span class="s0">input,</span>
            <span class="s0">start: {</span>
                <span class="s0">column: </span><span class="s3">1</span><span class="s0">,</span>
                <span class="s0">line: </span><span class="s3">1</span><span class="s0">,</span>
                <span class="s0">offset: </span><span class="s3">0</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s0">atrule(token) {</span>
        <span class="s2">let </span><span class="s0">node = </span><span class="s2">new </span><span class="s0">AtRule();</span>
        <span class="s0">node.name = token[</span><span class="s3">1</span><span class="s0">].slice(</span><span class="s3">1</span><span class="s0">);</span>
        <span class="s2">if </span><span class="s0">(node.name === </span><span class="s1">''</span><span class="s0">) {</span>
            <span class="s2">this</span><span class="s0">.unnamedAtrule(node, token);</span>
        <span class="s0">}</span>
        <span class="s2">this</span><span class="s0">.init(node, token[</span><span class="s3">2</span><span class="s0">]);</span>
        <span class="s2">let </span><span class="s0">type;</span>
        <span class="s2">let </span><span class="s0">prev;</span>
        <span class="s2">let </span><span class="s0">shift;</span>
        <span class="s2">let </span><span class="s0">last = </span><span class="s2">false</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">open = </span><span class="s2">false</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">params = [];</span>
        <span class="s2">let </span><span class="s0">brackets = [];</span>
        <span class="s2">while</span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.tokenizer.endOfFile()){</span>
            <span class="s0">token = </span><span class="s2">this</span><span class="s0">.tokenizer.nextToken();</span>
            <span class="s0">type = token[</span><span class="s3">0</span><span class="s0">];</span>
            <span class="s2">if </span><span class="s0">(type === </span><span class="s1">'(' </span><span class="s0">|| type === </span><span class="s1">'['</span><span class="s0">) {</span>
                <span class="s0">brackets.push(type === </span><span class="s1">'(' </span><span class="s0">? </span><span class="s1">')' </span><span class="s0">: </span><span class="s1">']'</span><span class="s0">);</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(type === </span><span class="s1">'{' </span><span class="s0">&amp;&amp; brackets.length &gt; </span><span class="s3">0</span><span class="s0">) {</span>
                <span class="s0">brackets.push(</span><span class="s1">'}'</span><span class="s0">);</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(type === brackets[brackets.length - </span><span class="s3">1</span><span class="s0">]) {</span>
                <span class="s0">brackets.pop();</span>
            <span class="s0">}</span>
            <span class="s2">if </span><span class="s0">(brackets.length === </span><span class="s3">0</span><span class="s0">) {</span>
                <span class="s2">if </span><span class="s0">(type === </span><span class="s1">';'</span><span class="s0">) {</span>
                    <span class="s0">node.source.end = </span><span class="s2">this</span><span class="s0">.getPosition(token[</span><span class="s3">2</span><span class="s0">]);</span>
                    <span class="s0">node.source.end.offset++;</span>
                    <span class="s2">this</span><span class="s0">.semicolon = </span><span class="s2">true</span><span class="s0">;</span>
                    <span class="s2">break</span><span class="s0">;</span>
                <span class="s0">} </span><span class="s2">else if </span><span class="s0">(type === </span><span class="s1">'{'</span><span class="s0">) {</span>
                    <span class="s0">open = </span><span class="s2">true</span><span class="s0">;</span>
                    <span class="s2">break</span><span class="s0">;</span>
                <span class="s0">} </span><span class="s2">else if </span><span class="s0">(type === </span><span class="s1">'}'</span><span class="s0">) {</span>
                    <span class="s2">if </span><span class="s0">(params.length &gt; </span><span class="s3">0</span><span class="s0">) {</span>
                        <span class="s0">shift = params.length - </span><span class="s3">1</span><span class="s0">;</span>
                        <span class="s0">prev = params[shift];</span>
                        <span class="s2">while</span><span class="s0">(prev &amp;&amp; prev[</span><span class="s3">0</span><span class="s0">] === </span><span class="s1">'space'</span><span class="s0">){</span>
                            <span class="s0">prev = params[--shift];</span>
                        <span class="s0">}</span>
                        <span class="s2">if </span><span class="s0">(prev) {</span>
                            <span class="s0">node.source.end = </span><span class="s2">this</span><span class="s0">.getPosition(prev[</span><span class="s3">3</span><span class="s0">] || prev[</span><span class="s3">2</span><span class="s0">]);</span>
                            <span class="s0">node.source.end.offset++;</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                    <span class="s2">this</span><span class="s0">.end(token);</span>
                    <span class="s2">break</span><span class="s0">;</span>
                <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                    <span class="s0">params.push(token);</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                <span class="s0">params.push(token);</span>
            <span class="s0">}</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.tokenizer.endOfFile()) {</span>
                <span class="s0">last = </span><span class="s2">true</span><span class="s0">;</span>
                <span class="s2">break</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">node.raws.between = </span><span class="s2">this</span><span class="s0">.spacesAndCommentsFromEnd(params);</span>
        <span class="s2">if </span><span class="s0">(params.length) {</span>
            <span class="s0">node.raws.afterName = </span><span class="s2">this</span><span class="s0">.spacesAndCommentsFromStart(params);</span>
            <span class="s2">this</span><span class="s0">.raw(node, </span><span class="s1">'params'</span><span class="s0">, params);</span>
            <span class="s2">if </span><span class="s0">(last) {</span>
                <span class="s0">token = params[params.length - </span><span class="s3">1</span><span class="s0">];</span>
                <span class="s0">node.source.end = </span><span class="s2">this</span><span class="s0">.getPosition(token[</span><span class="s3">3</span><span class="s0">] || token[</span><span class="s3">2</span><span class="s0">]);</span>
                <span class="s0">node.source.end.offset++;</span>
                <span class="s2">this</span><span class="s0">.spaces = node.raws.between;</span>
                <span class="s0">node.raws.between = </span><span class="s1">''</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s0">node.raws.afterName = </span><span class="s1">''</span><span class="s0">;</span>
            <span class="s0">node.params = </span><span class="s1">''</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(open) {</span>
            <span class="s0">node.nodes = [];</span>
            <span class="s2">this</span><span class="s0">.current = node;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">checkMissedSemicolon(tokens) {</span>
        <span class="s2">let </span><span class="s0">colon = </span><span class="s2">this</span><span class="s0">.colon(tokens);</span>
        <span class="s2">if </span><span class="s0">(colon === </span><span class="s2">false</span><span class="s0">) </span><span class="s2">return</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">founded = </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">token;</span>
        <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">j = colon - </span><span class="s3">1</span><span class="s0">; j &gt;= </span><span class="s3">0</span><span class="s0">; j--){</span>
            <span class="s0">token = tokens[j];</span>
            <span class="s2">if </span><span class="s0">(token[</span><span class="s3">0</span><span class="s0">] !== </span><span class="s1">'space'</span><span class="s0">) {</span>
                <span class="s0">founded += </span><span class="s3">1</span><span class="s0">;</span>
                <span class="s2">if </span><span class="s0">(founded === </span><span class="s3">2</span><span class="s0">) </span><span class="s2">break</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s6">// If the token is a word, e.g. `!important`, `red` or any other valid property's value.</span>
        <span class="s6">// Then we need to return the colon after that word token. [3] is the &quot;end&quot; colon of that word.</span>
        <span class="s6">// And because we need it after that one we do +1 to get the next one.</span>
        <span class="s2">throw this</span><span class="s0">.input.error(</span><span class="s1">'Missed semicolon'</span><span class="s0">, token[</span><span class="s3">0</span><span class="s0">] === </span><span class="s1">'word' </span><span class="s0">? token[</span><span class="s3">3</span><span class="s0">] + </span><span class="s3">1 </span><span class="s0">: token[</span><span class="s3">2</span><span class="s0">]);</span>
    <span class="s0">}</span>
    <span class="s0">colon(tokens) {</span>
        <span class="s2">let </span><span class="s0">brackets = </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">prev, token, type;</span>
        <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">[i, element] of tokens.entries()){</span>
            <span class="s0">token = element;</span>
            <span class="s0">type = token[</span><span class="s3">0</span><span class="s0">];</span>
            <span class="s2">if </span><span class="s0">(type === </span><span class="s1">'('</span><span class="s0">) {</span>
                <span class="s0">brackets += </span><span class="s3">1</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s2">if </span><span class="s0">(type === </span><span class="s1">')'</span><span class="s0">) {</span>
                <span class="s0">brackets -= </span><span class="s3">1</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s2">if </span><span class="s0">(brackets === </span><span class="s3">0 </span><span class="s0">&amp;&amp; type === </span><span class="s1">':'</span><span class="s0">) {</span>
                <span class="s2">if </span><span class="s0">(!prev) {</span>
                    <span class="s2">this</span><span class="s0">.doubleColon(token);</span>
                <span class="s0">} </span><span class="s2">else if </span><span class="s0">(prev[</span><span class="s3">0</span><span class="s0">] === </span><span class="s1">'word' </span><span class="s0">&amp;&amp; prev[</span><span class="s3">1</span><span class="s0">] === </span><span class="s1">'progid'</span><span class="s0">) {</span>
                    <span class="s2">continue</span><span class="s0">;</span>
                <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                    <span class="s2">return </span><span class="s0">i;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">prev = token;</span>
        <span class="s0">}</span>
        <span class="s2">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">comment(token) {</span>
        <span class="s2">let </span><span class="s0">node = </span><span class="s2">new </span><span class="s0">Comment();</span>
        <span class="s2">this</span><span class="s0">.init(node, token[</span><span class="s3">2</span><span class="s0">]);</span>
        <span class="s0">node.source.end = </span><span class="s2">this</span><span class="s0">.getPosition(token[</span><span class="s3">3</span><span class="s0">] || token[</span><span class="s3">2</span><span class="s0">]);</span>
        <span class="s0">node.source.end.offset++;</span>
        <span class="s2">let </span><span class="s0">text = token[</span><span class="s3">1</span><span class="s0">].slice(</span><span class="s3">2</span><span class="s0">, -</span><span class="s3">2</span><span class="s0">);</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s5">/^\s*$/</span><span class="s0">.test(text)) {</span>
            <span class="s0">node.text = </span><span class="s1">''</span><span class="s0">;</span>
            <span class="s0">node.raws.left = text;</span>
            <span class="s0">node.raws.right = </span><span class="s1">''</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">let </span><span class="s0">match = text.match(</span><span class="s5">/^(\s*)([^]*\S)(\s*)$/</span><span class="s0">);</span>
            <span class="s0">node.text = match[</span><span class="s3">2</span><span class="s0">];</span>
            <span class="s0">node.raws.left = match[</span><span class="s3">1</span><span class="s0">];</span>
            <span class="s0">node.raws.right = match[</span><span class="s3">3</span><span class="s0">];</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">createTokenizer() {</span>
        <span class="s2">this</span><span class="s0">.tokenizer = tokenizer(</span><span class="s2">this</span><span class="s0">.input);</span>
    <span class="s0">}</span>
    <span class="s0">decl(tokens, customProperty) {</span>
        <span class="s2">let </span><span class="s0">node = </span><span class="s2">new </span><span class="s0">Declaration();</span>
        <span class="s2">this</span><span class="s0">.init(node, tokens[</span><span class="s3">0</span><span class="s0">][</span><span class="s3">2</span><span class="s0">]);</span>
        <span class="s2">let </span><span class="s0">last = tokens[tokens.length - </span><span class="s3">1</span><span class="s0">];</span>
        <span class="s2">if </span><span class="s0">(last[</span><span class="s3">0</span><span class="s0">] === </span><span class="s1">';'</span><span class="s0">) {</span>
            <span class="s2">this</span><span class="s0">.semicolon = </span><span class="s2">true</span><span class="s0">;</span>
            <span class="s0">tokens.pop();</span>
        <span class="s0">}</span>
        <span class="s0">node.source.end = </span><span class="s2">this</span><span class="s0">.getPosition(last[</span><span class="s3">3</span><span class="s0">] || last[</span><span class="s3">2</span><span class="s0">] || findLastWithPosition(tokens));</span>
        <span class="s0">node.source.end.offset++;</span>
        <span class="s2">while</span><span class="s0">(tokens[</span><span class="s3">0</span><span class="s0">][</span><span class="s3">0</span><span class="s0">] !== </span><span class="s1">'word'</span><span class="s0">){</span>
            <span class="s2">if </span><span class="s0">(tokens.length === </span><span class="s3">1</span><span class="s0">) </span><span class="s2">this</span><span class="s0">.unknownWord(tokens);</span>
            <span class="s0">node.raws.before += tokens.shift()[</span><span class="s3">1</span><span class="s0">];</span>
        <span class="s0">}</span>
        <span class="s0">node.source.start = </span><span class="s2">this</span><span class="s0">.getPosition(tokens[</span><span class="s3">0</span><span class="s0">][</span><span class="s3">2</span><span class="s0">]);</span>
        <span class="s0">node.prop = </span><span class="s1">''</span><span class="s0">;</span>
        <span class="s2">while</span><span class="s0">(tokens.length){</span>
            <span class="s2">let </span><span class="s0">type = tokens[</span><span class="s3">0</span><span class="s0">][</span><span class="s3">0</span><span class="s0">];</span>
            <span class="s2">if </span><span class="s0">(type === </span><span class="s1">':' </span><span class="s0">|| type === </span><span class="s1">'space' </span><span class="s0">|| type === </span><span class="s1">'comment'</span><span class="s0">) {</span>
                <span class="s2">break</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">node.prop += tokens.shift()[</span><span class="s3">1</span><span class="s0">];</span>
        <span class="s0">}</span>
        <span class="s0">node.raws.between = </span><span class="s1">''</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">token;</span>
        <span class="s2">while</span><span class="s0">(tokens.length){</span>
            <span class="s0">token = tokens.shift();</span>
            <span class="s2">if </span><span class="s0">(token[</span><span class="s3">0</span><span class="s0">] === </span><span class="s1">':'</span><span class="s0">) {</span>
                <span class="s0">node.raws.between += token[</span><span class="s3">1</span><span class="s0">];</span>
                <span class="s2">break</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                <span class="s2">if </span><span class="s0">(token[</span><span class="s3">0</span><span class="s0">] === </span><span class="s1">'word' </span><span class="s0">&amp;&amp; </span><span class="s5">/\w/</span><span class="s0">.test(token[</span><span class="s3">1</span><span class="s0">])) {</span>
                    <span class="s2">this</span><span class="s0">.unknownWord([</span>
                        <span class="s0">token</span>
                    <span class="s0">]);</span>
                <span class="s0">}</span>
                <span class="s0">node.raws.between += token[</span><span class="s3">1</span><span class="s0">];</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(node.prop[</span><span class="s3">0</span><span class="s0">] === </span><span class="s1">'_' </span><span class="s0">|| node.prop[</span><span class="s3">0</span><span class="s0">] === </span><span class="s1">'*'</span><span class="s0">) {</span>
            <span class="s0">node.raws.before += node.prop[</span><span class="s3">0</span><span class="s0">];</span>
            <span class="s0">node.prop = node.prop.slice(</span><span class="s3">1</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s2">let </span><span class="s0">firstSpaces = [];</span>
        <span class="s2">let </span><span class="s0">next;</span>
        <span class="s2">while</span><span class="s0">(tokens.length){</span>
            <span class="s0">next = tokens[</span><span class="s3">0</span><span class="s0">][</span><span class="s3">0</span><span class="s0">];</span>
            <span class="s2">if </span><span class="s0">(next !== </span><span class="s1">'space' </span><span class="s0">&amp;&amp; next !== </span><span class="s1">'comment'</span><span class="s0">) </span><span class="s2">break</span><span class="s0">;</span>
            <span class="s0">firstSpaces.push(tokens.shift());</span>
        <span class="s0">}</span>
        <span class="s2">this</span><span class="s0">.precheckMissedSemicolon(tokens);</span>
        <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">i = tokens.length - </span><span class="s3">1</span><span class="s0">; i &gt;= </span><span class="s3">0</span><span class="s0">; i--){</span>
            <span class="s0">token = tokens[i];</span>
            <span class="s2">if </span><span class="s0">(token[</span><span class="s3">1</span><span class="s0">].toLowerCase() === </span><span class="s1">'!important'</span><span class="s0">) {</span>
                <span class="s0">node.important = </span><span class="s2">true</span><span class="s0">;</span>
                <span class="s2">let </span><span class="s0">string = </span><span class="s2">this</span><span class="s0">.stringFrom(tokens, i);</span>
                <span class="s0">string = </span><span class="s2">this</span><span class="s0">.spacesFromEnd(tokens) + string;</span>
                <span class="s2">if </span><span class="s0">(string !== </span><span class="s1">' !important'</span><span class="s0">) node.raws.important = string;</span>
                <span class="s2">break</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(token[</span><span class="s3">1</span><span class="s0">].toLowerCase() === </span><span class="s1">'important'</span><span class="s0">) {</span>
                <span class="s2">let </span><span class="s0">cache = tokens.slice(</span><span class="s3">0</span><span class="s0">);</span>
                <span class="s2">let </span><span class="s0">str = </span><span class="s1">''</span><span class="s0">;</span>
                <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">j = i; j &gt; </span><span class="s3">0</span><span class="s0">; j--){</span>
                    <span class="s2">let </span><span class="s0">type = cache[j][</span><span class="s3">0</span><span class="s0">];</span>
                    <span class="s2">if </span><span class="s0">(str.trim().startsWith(</span><span class="s1">'!'</span><span class="s0">) &amp;&amp; type !== </span><span class="s1">'space'</span><span class="s0">) {</span>
                        <span class="s2">break</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s0">str = cache.pop()[</span><span class="s3">1</span><span class="s0">] + str;</span>
                <span class="s0">}</span>
                <span class="s2">if </span><span class="s0">(str.trim().startsWith(</span><span class="s1">'!'</span><span class="s0">)) {</span>
                    <span class="s0">node.important = </span><span class="s2">true</span><span class="s0">;</span>
                    <span class="s0">node.raws.important = str;</span>
                    <span class="s0">tokens = cache;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s2">if </span><span class="s0">(token[</span><span class="s3">0</span><span class="s0">] !== </span><span class="s1">'space' </span><span class="s0">&amp;&amp; token[</span><span class="s3">0</span><span class="s0">] !== </span><span class="s1">'comment'</span><span class="s0">) {</span>
                <span class="s2">break</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">let </span><span class="s0">hasWord = tokens.some((i)=&gt;i[</span><span class="s3">0</span><span class="s0">] !== </span><span class="s1">'space' </span><span class="s0">&amp;&amp; i[</span><span class="s3">0</span><span class="s0">] !== </span><span class="s1">'comment'</span><span class="s0">);</span>
        <span class="s2">if </span><span class="s0">(hasWord) {</span>
            <span class="s0">node.raws.between += firstSpaces.map((i)=&gt;i[</span><span class="s3">1</span><span class="s0">]).join(</span><span class="s1">''</span><span class="s0">);</span>
            <span class="s0">firstSpaces = [];</span>
        <span class="s0">}</span>
        <span class="s2">this</span><span class="s0">.raw(node, </span><span class="s1">'value'</span><span class="s0">, firstSpaces.concat(tokens), customProperty);</span>
        <span class="s2">if </span><span class="s0">(node.value.includes(</span><span class="s1">':'</span><span class="s0">) &amp;&amp; !customProperty) {</span>
            <span class="s2">this</span><span class="s0">.checkMissedSemicolon(tokens);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">doubleColon(token) {</span>
        <span class="s2">throw this</span><span class="s0">.input.error(</span><span class="s1">'Double colon'</span><span class="s0">, {</span>
            <span class="s0">offset: token[</span><span class="s3">2</span><span class="s0">]</span>
        <span class="s0">}, {</span>
            <span class="s0">offset: token[</span><span class="s3">2</span><span class="s0">] + token[</span><span class="s3">1</span><span class="s0">].length</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s0">emptyRule(token) {</span>
        <span class="s2">let </span><span class="s0">node = </span><span class="s2">new </span><span class="s0">Rule();</span>
        <span class="s2">this</span><span class="s0">.init(node, token[</span><span class="s3">2</span><span class="s0">]);</span>
        <span class="s0">node.selector = </span><span class="s1">''</span><span class="s0">;</span>
        <span class="s0">node.raws.between = </span><span class="s1">''</span><span class="s0">;</span>
        <span class="s2">this</span><span class="s0">.current = node;</span>
    <span class="s0">}</span>
    <span class="s0">end(token) {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.current.nodes &amp;&amp; </span><span class="s2">this</span><span class="s0">.current.nodes.length) {</span>
            <span class="s2">this</span><span class="s0">.current.raws.semicolon = </span><span class="s2">this</span><span class="s0">.semicolon;</span>
        <span class="s0">}</span>
        <span class="s2">this</span><span class="s0">.semicolon = </span><span class="s2">false</span><span class="s0">;</span>
        <span class="s2">this</span><span class="s0">.current.raws.after = (</span><span class="s2">this</span><span class="s0">.current.raws.after || </span><span class="s1">''</span><span class="s0">) + </span><span class="s2">this</span><span class="s0">.spaces;</span>
        <span class="s2">this</span><span class="s0">.spaces = </span><span class="s1">''</span><span class="s0">;</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.current.parent) {</span>
            <span class="s2">this</span><span class="s0">.current.source.end = </span><span class="s2">this</span><span class="s0">.getPosition(token[</span><span class="s3">2</span><span class="s0">]);</span>
            <span class="s2">this</span><span class="s0">.current.source.end.offset++;</span>
            <span class="s2">this</span><span class="s0">.current = </span><span class="s2">this</span><span class="s0">.current.parent;</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">this</span><span class="s0">.unexpectedClose(token);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">endFile() {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.current.parent) </span><span class="s2">this</span><span class="s0">.unclosedBlock();</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.current.nodes &amp;&amp; </span><span class="s2">this</span><span class="s0">.current.nodes.length) {</span>
            <span class="s2">this</span><span class="s0">.current.raws.semicolon = </span><span class="s2">this</span><span class="s0">.semicolon;</span>
        <span class="s0">}</span>
        <span class="s2">this</span><span class="s0">.current.raws.after = (</span><span class="s2">this</span><span class="s0">.current.raws.after || </span><span class="s1">''</span><span class="s0">) + </span><span class="s2">this</span><span class="s0">.spaces;</span>
        <span class="s2">this</span><span class="s0">.root.source.end = </span><span class="s2">this</span><span class="s0">.getPosition(</span><span class="s2">this</span><span class="s0">.tokenizer.position());</span>
    <span class="s0">}</span>
    <span class="s0">freeSemicolon(token) {</span>
        <span class="s2">this</span><span class="s0">.spaces += token[</span><span class="s3">1</span><span class="s0">];</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.current.nodes) {</span>
            <span class="s2">let </span><span class="s0">prev = </span><span class="s2">this</span><span class="s0">.current.nodes[</span><span class="s2">this</span><span class="s0">.current.nodes.length - </span><span class="s3">1</span><span class="s0">];</span>
            <span class="s2">if </span><span class="s0">(prev &amp;&amp; prev.type === </span><span class="s1">'rule' </span><span class="s0">&amp;&amp; !prev.raws.ownSemicolon) {</span>
                <span class="s0">prev.raws.ownSemicolon = </span><span class="s2">this</span><span class="s0">.spaces;</span>
                <span class="s2">this</span><span class="s0">.spaces = </span><span class="s1">''</span><span class="s0">;</span>
                <span class="s0">prev.source.end = </span><span class="s2">this</span><span class="s0">.getPosition(token[</span><span class="s3">2</span><span class="s0">]);</span>
                <span class="s0">prev.source.end.offset += prev.raws.ownSemicolon.length;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s6">// Helpers</span>
    <span class="s0">getPosition(offset) {</span>
        <span class="s2">let </span><span class="s0">pos = </span><span class="s2">this</span><span class="s0">.input.fromOffset(offset);</span>
        <span class="s2">return </span><span class="s0">{</span>
            <span class="s0">column: pos.col,</span>
            <span class="s0">line: pos.line,</span>
            <span class="s0">offset</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s0">init(node, offset) {</span>
        <span class="s2">this</span><span class="s0">.current.push(node);</span>
        <span class="s0">node.source = {</span>
            <span class="s0">input: </span><span class="s2">this</span><span class="s0">.input,</span>
            <span class="s0">start: </span><span class="s2">this</span><span class="s0">.getPosition(offset)</span>
        <span class="s0">};</span>
        <span class="s0">node.raws.before = </span><span class="s2">this</span><span class="s0">.spaces;</span>
        <span class="s2">this</span><span class="s0">.spaces = </span><span class="s1">''</span><span class="s0">;</span>
        <span class="s2">if </span><span class="s0">(node.type !== </span><span class="s1">'comment'</span><span class="s0">) </span><span class="s2">this</span><span class="s0">.semicolon = </span><span class="s2">false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">other(start) {</span>
        <span class="s2">let </span><span class="s0">end = </span><span class="s2">false</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">type = </span><span class="s2">null</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">colon = </span><span class="s2">false</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">bracket = </span><span class="s2">null</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">brackets = [];</span>
        <span class="s2">let </span><span class="s0">customProperty = start[</span><span class="s3">1</span><span class="s0">].startsWith(</span><span class="s1">'--'</span><span class="s0">);</span>
        <span class="s2">let </span><span class="s0">tokens = [];</span>
        <span class="s2">let </span><span class="s0">token = start;</span>
        <span class="s2">while</span><span class="s0">(token){</span>
            <span class="s0">type = token[</span><span class="s3">0</span><span class="s0">];</span>
            <span class="s0">tokens.push(token);</span>
            <span class="s2">if </span><span class="s0">(type === </span><span class="s1">'(' </span><span class="s0">|| type === </span><span class="s1">'['</span><span class="s0">) {</span>
                <span class="s2">if </span><span class="s0">(!bracket) bracket = token;</span>
                <span class="s0">brackets.push(type === </span><span class="s1">'(' </span><span class="s0">? </span><span class="s1">')' </span><span class="s0">: </span><span class="s1">']'</span><span class="s0">);</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(customProperty &amp;&amp; colon &amp;&amp; type === </span><span class="s1">'{'</span><span class="s0">) {</span>
                <span class="s2">if </span><span class="s0">(!bracket) bracket = token;</span>
                <span class="s0">brackets.push(</span><span class="s1">'}'</span><span class="s0">);</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(brackets.length === </span><span class="s3">0</span><span class="s0">) {</span>
                <span class="s2">if </span><span class="s0">(type === </span><span class="s1">';'</span><span class="s0">) {</span>
                    <span class="s2">if </span><span class="s0">(colon) {</span>
                        <span class="s2">this</span><span class="s0">.decl(tokens, customProperty);</span>
                        <span class="s2">return</span><span class="s0">;</span>
                    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                        <span class="s2">break</span><span class="s0">;</span>
                    <span class="s0">}</span>
                <span class="s0">} </span><span class="s2">else if </span><span class="s0">(type === </span><span class="s1">'{'</span><span class="s0">) {</span>
                    <span class="s2">this</span><span class="s0">.rule(tokens);</span>
                    <span class="s2">return</span><span class="s0">;</span>
                <span class="s0">} </span><span class="s2">else if </span><span class="s0">(type === </span><span class="s1">'}'</span><span class="s0">) {</span>
                    <span class="s2">this</span><span class="s0">.tokenizer.back(tokens.pop());</span>
                    <span class="s0">end = </span><span class="s2">true</span><span class="s0">;</span>
                    <span class="s2">break</span><span class="s0">;</span>
                <span class="s0">} </span><span class="s2">else if </span><span class="s0">(type === </span><span class="s1">':'</span><span class="s0">) {</span>
                    <span class="s0">colon = </span><span class="s2">true</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(type === brackets[brackets.length - </span><span class="s3">1</span><span class="s0">]) {</span>
                <span class="s0">brackets.pop();</span>
                <span class="s2">if </span><span class="s0">(brackets.length === </span><span class="s3">0</span><span class="s0">) bracket = </span><span class="s2">null</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">token = </span><span class="s2">this</span><span class="s0">.tokenizer.nextToken();</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.tokenizer.endOfFile()) end = </span><span class="s2">true</span><span class="s0">;</span>
        <span class="s2">if </span><span class="s0">(brackets.length &gt; </span><span class="s3">0</span><span class="s0">) </span><span class="s2">this</span><span class="s0">.unclosedBracket(bracket);</span>
        <span class="s2">if </span><span class="s0">(end &amp;&amp; colon) {</span>
            <span class="s2">if </span><span class="s0">(!customProperty) {</span>
                <span class="s2">while</span><span class="s0">(tokens.length){</span>
                    <span class="s0">token = tokens[tokens.length - </span><span class="s3">1</span><span class="s0">][</span><span class="s3">0</span><span class="s0">];</span>
                    <span class="s2">if </span><span class="s0">(token !== </span><span class="s1">'space' </span><span class="s0">&amp;&amp; token !== </span><span class="s1">'comment'</span><span class="s0">) </span><span class="s2">break</span><span class="s0">;</span>
                    <span class="s2">this</span><span class="s0">.tokenizer.back(tokens.pop());</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s2">this</span><span class="s0">.decl(tokens, customProperty);</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">this</span><span class="s0">.unknownWord(tokens);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">parse() {</span>
        <span class="s2">let </span><span class="s0">token;</span>
        <span class="s2">while</span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.tokenizer.endOfFile()){</span>
            <span class="s0">token = </span><span class="s2">this</span><span class="s0">.tokenizer.nextToken();</span>
            <span class="s2">switch</span><span class="s0">(token[</span><span class="s3">0</span><span class="s0">]){</span>
                <span class="s2">case </span><span class="s1">'space'</span><span class="s0">:</span>
                    <span class="s2">this</span><span class="s0">.spaces += token[</span><span class="s3">1</span><span class="s0">];</span>
                    <span class="s2">break</span><span class="s0">;</span>
                <span class="s2">case </span><span class="s1">';'</span><span class="s0">:</span>
                    <span class="s2">this</span><span class="s0">.freeSemicolon(token);</span>
                    <span class="s2">break</span><span class="s0">;</span>
                <span class="s2">case </span><span class="s1">'}'</span><span class="s0">:</span>
                    <span class="s2">this</span><span class="s0">.end(token);</span>
                    <span class="s2">break</span><span class="s0">;</span>
                <span class="s2">case </span><span class="s1">'comment'</span><span class="s0">:</span>
                    <span class="s2">this</span><span class="s0">.comment(token);</span>
                    <span class="s2">break</span><span class="s0">;</span>
                <span class="s2">case </span><span class="s1">'at-word'</span><span class="s0">:</span>
                    <span class="s2">this</span><span class="s0">.atrule(token);</span>
                    <span class="s2">break</span><span class="s0">;</span>
                <span class="s2">case </span><span class="s1">'{'</span><span class="s0">:</span>
                    <span class="s2">this</span><span class="s0">.emptyRule(token);</span>
                    <span class="s2">break</span><span class="s0">;</span>
                <span class="s2">default</span><span class="s0">:</span>
                    <span class="s2">this</span><span class="s0">.other(token);</span>
                    <span class="s2">break</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">this</span><span class="s0">.endFile();</span>
    <span class="s0">}</span>
    <span class="s0">precheckMissedSemicolon() {</span>
    <span class="s6">// Hook for Safe Parser</span>
    <span class="s0">}</span>
    <span class="s0">raw(node, prop, tokens, customProperty) {</span>
        <span class="s2">let </span><span class="s0">token, type;</span>
        <span class="s2">let </span><span class="s0">length = tokens.length;</span>
        <span class="s2">let </span><span class="s0">value = </span><span class="s1">''</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">clean = </span><span class="s2">true</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">next, prev;</span>
        <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; length; i += </span><span class="s3">1</span><span class="s0">){</span>
            <span class="s0">token = tokens[i];</span>
            <span class="s0">type = token[</span><span class="s3">0</span><span class="s0">];</span>
            <span class="s2">if </span><span class="s0">(type === </span><span class="s1">'space' </span><span class="s0">&amp;&amp; i === length - </span><span class="s3">1 </span><span class="s0">&amp;&amp; !customProperty) {</span>
                <span class="s0">clean = </span><span class="s2">false</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(type === </span><span class="s1">'comment'</span><span class="s0">) {</span>
                <span class="s0">prev = tokens[i - </span><span class="s3">1</span><span class="s0">] ? tokens[i - </span><span class="s3">1</span><span class="s0">][</span><span class="s3">0</span><span class="s0">] : </span><span class="s1">'empty'</span><span class="s0">;</span>
                <span class="s0">next = tokens[i + </span><span class="s3">1</span><span class="s0">] ? tokens[i + </span><span class="s3">1</span><span class="s0">][</span><span class="s3">0</span><span class="s0">] : </span><span class="s1">'empty'</span><span class="s0">;</span>
                <span class="s2">if </span><span class="s0">(!SAFE_COMMENT_NEIGHBOR[prev] &amp;&amp; !SAFE_COMMENT_NEIGHBOR[next]) {</span>
                    <span class="s2">if </span><span class="s0">(value.slice(-</span><span class="s3">1</span><span class="s0">) === </span><span class="s1">','</span><span class="s0">) {</span>
                        <span class="s0">clean = </span><span class="s2">false</span><span class="s0">;</span>
                    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                        <span class="s0">value += token[</span><span class="s3">1</span><span class="s0">];</span>
                    <span class="s0">}</span>
                <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                    <span class="s0">clean = </span><span class="s2">false</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                <span class="s0">value += token[</span><span class="s3">1</span><span class="s0">];</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(!clean) {</span>
            <span class="s2">let </span><span class="s0">raw = tokens.reduce((all, i)=&gt;all + i[</span><span class="s3">1</span><span class="s0">], </span><span class="s1">''</span><span class="s0">);</span>
            <span class="s0">node.raws[prop] = {</span>
                <span class="s0">raw,</span>
                <span class="s0">value</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s0">node[prop] = value;</span>
    <span class="s0">}</span>
    <span class="s0">rule(tokens) {</span>
        <span class="s0">tokens.pop();</span>
        <span class="s2">let </span><span class="s0">node = </span><span class="s2">new </span><span class="s0">Rule();</span>
        <span class="s2">this</span><span class="s0">.init(node, tokens[</span><span class="s3">0</span><span class="s0">][</span><span class="s3">2</span><span class="s0">]);</span>
        <span class="s0">node.raws.between = </span><span class="s2">this</span><span class="s0">.spacesAndCommentsFromEnd(tokens);</span>
        <span class="s2">this</span><span class="s0">.raw(node, </span><span class="s1">'selector'</span><span class="s0">, tokens);</span>
        <span class="s2">this</span><span class="s0">.current = node;</span>
    <span class="s0">}</span>
    <span class="s0">spacesAndCommentsFromEnd(tokens) {</span>
        <span class="s2">let </span><span class="s0">lastTokenType;</span>
        <span class="s2">let </span><span class="s0">spaces = </span><span class="s1">''</span><span class="s0">;</span>
        <span class="s2">while</span><span class="s0">(tokens.length){</span>
            <span class="s0">lastTokenType = tokens[tokens.length - </span><span class="s3">1</span><span class="s0">][</span><span class="s3">0</span><span class="s0">];</span>
            <span class="s2">if </span><span class="s0">(lastTokenType !== </span><span class="s1">'space' </span><span class="s0">&amp;&amp; lastTokenType !== </span><span class="s1">'comment'</span><span class="s0">) </span><span class="s2">break</span><span class="s0">;</span>
            <span class="s0">spaces = tokens.pop()[</span><span class="s3">1</span><span class="s0">] + spaces;</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">spaces;</span>
    <span class="s0">}</span>
    <span class="s6">// Errors</span>
    <span class="s0">spacesAndCommentsFromStart(tokens) {</span>
        <span class="s2">let </span><span class="s0">next;</span>
        <span class="s2">let </span><span class="s0">spaces = </span><span class="s1">''</span><span class="s0">;</span>
        <span class="s2">while</span><span class="s0">(tokens.length){</span>
            <span class="s0">next = tokens[</span><span class="s3">0</span><span class="s0">][</span><span class="s3">0</span><span class="s0">];</span>
            <span class="s2">if </span><span class="s0">(next !== </span><span class="s1">'space' </span><span class="s0">&amp;&amp; next !== </span><span class="s1">'comment'</span><span class="s0">) </span><span class="s2">break</span><span class="s0">;</span>
            <span class="s0">spaces += tokens.shift()[</span><span class="s3">1</span><span class="s0">];</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">spaces;</span>
    <span class="s0">}</span>
    <span class="s0">spacesFromEnd(tokens) {</span>
        <span class="s2">let </span><span class="s0">lastTokenType;</span>
        <span class="s2">let </span><span class="s0">spaces = </span><span class="s1">''</span><span class="s0">;</span>
        <span class="s2">while</span><span class="s0">(tokens.length){</span>
            <span class="s0">lastTokenType = tokens[tokens.length - </span><span class="s3">1</span><span class="s0">][</span><span class="s3">0</span><span class="s0">];</span>
            <span class="s2">if </span><span class="s0">(lastTokenType !== </span><span class="s1">'space'</span><span class="s0">) </span><span class="s2">break</span><span class="s0">;</span>
            <span class="s0">spaces = tokens.pop()[</span><span class="s3">1</span><span class="s0">] + spaces;</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">spaces;</span>
    <span class="s0">}</span>
    <span class="s0">stringFrom(tokens, from) {</span>
        <span class="s2">let </span><span class="s0">result = </span><span class="s1">''</span><span class="s0">;</span>
        <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">i = from; i &lt; tokens.length; i++){</span>
            <span class="s0">result += tokens[i][</span><span class="s3">1</span><span class="s0">];</span>
        <span class="s0">}</span>
        <span class="s0">tokens.splice(from, tokens.length - from);</span>
        <span class="s2">return </span><span class="s0">result;</span>
    <span class="s0">}</span>
    <span class="s0">unclosedBlock() {</span>
        <span class="s2">let </span><span class="s0">pos = </span><span class="s2">this</span><span class="s0">.current.source.start;</span>
        <span class="s2">throw this</span><span class="s0">.input.error(</span><span class="s1">'Unclosed block'</span><span class="s0">, pos.line, pos.column);</span>
    <span class="s0">}</span>
    <span class="s0">unclosedBracket(bracket) {</span>
        <span class="s2">throw this</span><span class="s0">.input.error(</span><span class="s1">'Unclosed bracket'</span><span class="s0">, {</span>
            <span class="s0">offset: bracket[</span><span class="s3">2</span><span class="s0">]</span>
        <span class="s0">}, {</span>
            <span class="s0">offset: bracket[</span><span class="s3">2</span><span class="s0">] + </span><span class="s3">1</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s0">unexpectedClose(token) {</span>
        <span class="s2">throw this</span><span class="s0">.input.error(</span><span class="s1">'Unexpected }'</span><span class="s0">, {</span>
            <span class="s0">offset: token[</span><span class="s3">2</span><span class="s0">]</span>
        <span class="s0">}, {</span>
            <span class="s0">offset: token[</span><span class="s3">2</span><span class="s0">] + </span><span class="s3">1</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s0">unknownWord(tokens) {</span>
        <span class="s2">throw this</span><span class="s0">.input.error(</span><span class="s1">'Unknown word ' </span><span class="s0">+ tokens[</span><span class="s3">0</span><span class="s0">][</span><span class="s3">1</span><span class="s0">], {</span>
            <span class="s0">offset: tokens[</span><span class="s3">0</span><span class="s0">][</span><span class="s3">2</span><span class="s0">]</span>
        <span class="s0">}, {</span>
            <span class="s0">offset: tokens[</span><span class="s3">0</span><span class="s0">][</span><span class="s3">2</span><span class="s0">] + tokens[</span><span class="s3">0</span><span class="s0">][</span><span class="s3">1</span><span class="s0">].length</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s0">unnamedAtrule(node, token) {</span>
        <span class="s2">throw this</span><span class="s0">.input.error(</span><span class="s1">'At-rule without name'</span><span class="s0">, {</span>
            <span class="s0">offset: token[</span><span class="s3">2</span><span class="s0">]</span>
        <span class="s0">}, {</span>
            <span class="s0">offset: token[</span><span class="s3">2</span><span class="s0">] + token[</span><span class="s3">1</span><span class="s0">].length</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">module.exports = Parser;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/parse.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">let </span><span class="s0">Container = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/container.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Input = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/input.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Parser = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/parser.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">function </span><span class="s0">parse(css, opts) {</span>
    <span class="s2">let </span><span class="s0">input = </span><span class="s2">new </span><span class="s0">Input(css, opts);</span>
    <span class="s2">let </span><span class="s0">parser = </span><span class="s2">new </span><span class="s0">Parser(input);</span>
    <span class="s2">try </span><span class="s0">{</span>
        <span class="s0">parser.parse();</span>
    <span class="s0">} </span><span class="s2">catch </span><span class="s0">(e) {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s1">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s0">) {</span>
            <span class="s2">if </span><span class="s0">(e.name === </span><span class="s1">'CssSyntaxError' </span><span class="s0">&amp;&amp; opts &amp;&amp; opts.from) {</span>
                <span class="s2">if </span><span class="s0">(</span><span class="s5">/\.scss$/i</span><span class="s0">.test(opts.from)) {</span>
                    <span class="s0">e.message += </span><span class="s1">'</span><span class="s4">\n</span><span class="s1">You tried to parse SCSS with ' </span><span class="s0">+ </span><span class="s1">'the standard CSS parser; ' </span><span class="s0">+ </span><span class="s1">'try again with the postcss-scss parser'</span><span class="s0">;</span>
                <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s5">/\.sass/i</span><span class="s0">.test(opts.from)) {</span>
                    <span class="s0">e.message += </span><span class="s1">'</span><span class="s4">\n</span><span class="s1">You tried to parse Sass with ' </span><span class="s0">+ </span><span class="s1">'the standard CSS parser; ' </span><span class="s0">+ </span><span class="s1">'try again with the postcss-sass parser'</span><span class="s0">;</span>
                <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s5">/\.less$/i</span><span class="s0">.test(opts.from)) {</span>
                    <span class="s0">e.message += </span><span class="s1">'</span><span class="s4">\n</span><span class="s1">You tried to parse Less with ' </span><span class="s0">+ </span><span class="s1">'the standard CSS parser; ' </span><span class="s0">+ </span><span class="s1">'try again with the postcss-less parser'</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">throw </span><span class="s0">e;</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">parser.root;</span>
<span class="s0">}</span>
<span class="s0">module.exports = parse;</span>
<span class="s0">parse.default = parse;</span>
<span class="s0">Container.registerParse(parse);</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/warning.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">class </span><span class="s0">Warning {</span>
    <span class="s0">constructor(text, opts = {}){</span>
        <span class="s2">this</span><span class="s0">.type = </span><span class="s1">'warning'</span><span class="s0">;</span>
        <span class="s2">this</span><span class="s0">.text = text;</span>
        <span class="s2">if </span><span class="s0">(opts.node &amp;&amp; opts.node.source) {</span>
            <span class="s2">let </span><span class="s0">range = opts.node.rangeBy(opts);</span>
            <span class="s2">this</span><span class="s0">.line = range.start.line;</span>
            <span class="s2">this</span><span class="s0">.column = range.start.column;</span>
            <span class="s2">this</span><span class="s0">.endLine = range.end.line;</span>
            <span class="s2">this</span><span class="s0">.endColumn = range.end.column;</span>
        <span class="s0">}</span>
        <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">opt </span><span class="s2">in </span><span class="s0">opts)</span><span class="s2">this</span><span class="s0">[opt] = opts[opt];</span>
    <span class="s0">}</span>
    <span class="s0">toString() {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.node) {</span>
            <span class="s2">return this</span><span class="s0">.node.error(</span><span class="s2">this</span><span class="s0">.text, {</span>
                <span class="s0">index: </span><span class="s2">this</span><span class="s0">.index,</span>
                <span class="s0">plugin: </span><span class="s2">this</span><span class="s0">.plugin,</span>
                <span class="s0">word: </span><span class="s2">this</span><span class="s0">.word</span>
            <span class="s0">}).message;</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.plugin) {</span>
            <span class="s2">return this</span><span class="s0">.plugin + </span><span class="s1">': ' </span><span class="s0">+ </span><span class="s2">this</span><span class="s0">.text;</span>
        <span class="s0">}</span>
        <span class="s2">return this</span><span class="s0">.text;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">module.exports = Warning;</span>
<span class="s0">Warning.default = Warning;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/result.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">let </span><span class="s0">Warning = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/warning.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">class </span><span class="s0">Result {</span>
    <span class="s0">get content() {</span>
        <span class="s2">return this</span><span class="s0">.css;</span>
    <span class="s0">}</span>
    <span class="s0">constructor(processor, root, opts){</span>
        <span class="s2">this</span><span class="s0">.processor = processor;</span>
        <span class="s2">this</span><span class="s0">.messages = [];</span>
        <span class="s2">this</span><span class="s0">.root = root;</span>
        <span class="s2">this</span><span class="s0">.opts = opts;</span>
        <span class="s2">this</span><span class="s0">.css = </span><span class="s1">''</span><span class="s0">;</span>
        <span class="s2">this</span><span class="s0">.map = undefined;</span>
    <span class="s0">}</span>
    <span class="s0">toString() {</span>
        <span class="s2">return this</span><span class="s0">.css;</span>
    <span class="s0">}</span>
    <span class="s0">warn(text, opts = {}) {</span>
        <span class="s2">if </span><span class="s0">(!opts.plugin) {</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.lastPlugin &amp;&amp; </span><span class="s2">this</span><span class="s0">.lastPlugin.postcssPlugin) {</span>
                <span class="s0">opts.plugin = </span><span class="s2">this</span><span class="s0">.lastPlugin.postcssPlugin;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">let </span><span class="s0">warning = </span><span class="s2">new </span><span class="s0">Warning(text, opts);</span>
        <span class="s2">this</span><span class="s0">.messages.push(warning);</span>
        <span class="s2">return </span><span class="s0">warning;</span>
    <span class="s0">}</span>
    <span class="s0">warnings() {</span>
        <span class="s2">return this</span><span class="s0">.messages.filter((i)=&gt;i.type === </span><span class="s1">'warning'</span><span class="s0">);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">module.exports = Result;</span>
<span class="s0">Result.default = Result;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/warn-once.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s6">/* eslint-disable no-console */ </span><span class="s2">let </span><span class="s0">printed = {};</span>
<span class="s0">module.exports = </span><span class="s2">function </span><span class="s0">warnOnce(message) {</span>
    <span class="s2">if </span><span class="s0">(printed[message]) </span><span class="s2">return</span><span class="s0">;</span>
    <span class="s0">printed[message] = </span><span class="s2">true</span><span class="s0">;</span>
    <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">console !== </span><span class="s1">'undefined' </span><span class="s0">&amp;&amp; console.warn) {</span>
        <span class="s0">console.warn(message);</span>
    <span class="s0">}</span>
<span class="s0">};</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/lazy-result.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">let </span><span class="s0">Container = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/container.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Document = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/document.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">MapGenerator = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/map-generator.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">parse = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/parse.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Result = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/result.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Root = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/root.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">stringify = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/stringify.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">{ isClean, my } = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/symbols.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">warnOnce = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/warn-once.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">const </span><span class="s0">TYPE_TO_CLASS_NAME = {</span>
    <span class="s0">atrule: </span><span class="s1">'AtRule'</span><span class="s0">,</span>
    <span class="s0">comment: </span><span class="s1">'Comment'</span><span class="s0">,</span>
    <span class="s0">decl: </span><span class="s1">'Declaration'</span><span class="s0">,</span>
    <span class="s0">document: </span><span class="s1">'Document'</span><span class="s0">,</span>
    <span class="s0">root: </span><span class="s1">'Root'</span><span class="s0">,</span>
    <span class="s0">rule: </span><span class="s1">'Rule'</span>
<span class="s0">};</span>
<span class="s2">const </span><span class="s0">PLUGIN_PROPS = {</span>
    <span class="s0">AtRule: </span><span class="s2">true</span><span class="s0">,</span>
    <span class="s0">AtRuleExit: </span><span class="s2">true</span><span class="s0">,</span>
    <span class="s0">Comment: </span><span class="s2">true</span><span class="s0">,</span>
    <span class="s0">CommentExit: </span><span class="s2">true</span><span class="s0">,</span>
    <span class="s0">Declaration: </span><span class="s2">true</span><span class="s0">,</span>
    <span class="s0">DeclarationExit: </span><span class="s2">true</span><span class="s0">,</span>
    <span class="s0">Document: </span><span class="s2">true</span><span class="s0">,</span>
    <span class="s0">DocumentExit: </span><span class="s2">true</span><span class="s0">,</span>
    <span class="s0">Once: </span><span class="s2">true</span><span class="s0">,</span>
    <span class="s0">OnceExit: </span><span class="s2">true</span><span class="s0">,</span>
    <span class="s0">postcssPlugin: </span><span class="s2">true</span><span class="s0">,</span>
    <span class="s0">prepare: </span><span class="s2">true</span><span class="s0">,</span>
    <span class="s0">Root: </span><span class="s2">true</span><span class="s0">,</span>
    <span class="s0">RootExit: </span><span class="s2">true</span><span class="s0">,</span>
    <span class="s0">Rule: </span><span class="s2">true</span><span class="s0">,</span>
    <span class="s0">RuleExit: </span><span class="s2">true</span>
<span class="s0">};</span>
<span class="s2">const </span><span class="s0">NOT_VISITORS = {</span>
    <span class="s0">Once: </span><span class="s2">true</span><span class="s0">,</span>
    <span class="s0">postcssPlugin: </span><span class="s2">true</span><span class="s0">,</span>
    <span class="s0">prepare: </span><span class="s2">true</span>
<span class="s0">};</span>
<span class="s2">const </span><span class="s0">CHILDREN = </span><span class="s3">0</span><span class="s0">;</span>
<span class="s2">function </span><span class="s0">isPromise(obj) {</span>
    <span class="s2">return typeof </span><span class="s0">obj === </span><span class="s1">'object' </span><span class="s0">&amp;&amp; </span><span class="s2">typeof </span><span class="s0">obj.then === </span><span class="s1">'function'</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s2">function </span><span class="s0">getEvents(node) {</span>
    <span class="s2">let </span><span class="s0">key = </span><span class="s2">false</span><span class="s0">;</span>
    <span class="s2">let </span><span class="s0">type = TYPE_TO_CLASS_NAME[node.type];</span>
    <span class="s2">if </span><span class="s0">(node.type === </span><span class="s1">'decl'</span><span class="s0">) {</span>
        <span class="s0">key = node.prop.toLowerCase();</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(node.type === </span><span class="s1">'atrule'</span><span class="s0">) {</span>
        <span class="s0">key = node.name.toLowerCase();</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(key &amp;&amp; node.append) {</span>
        <span class="s2">return </span><span class="s0">[</span>
            <span class="s0">type,</span>
            <span class="s0">type + </span><span class="s1">'-' </span><span class="s0">+ key,</span>
            <span class="s0">CHILDREN,</span>
            <span class="s0">type + </span><span class="s1">'Exit'</span><span class="s0">,</span>
            <span class="s0">type + </span><span class="s1">'Exit-' </span><span class="s0">+ key</span>
        <span class="s0">];</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(key) {</span>
        <span class="s2">return </span><span class="s0">[</span>
            <span class="s0">type,</span>
            <span class="s0">type + </span><span class="s1">'-' </span><span class="s0">+ key,</span>
            <span class="s0">type + </span><span class="s1">'Exit'</span><span class="s0">,</span>
            <span class="s0">type + </span><span class="s1">'Exit-' </span><span class="s0">+ key</span>
        <span class="s0">];</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(node.append) {</span>
        <span class="s2">return </span><span class="s0">[</span>
            <span class="s0">type,</span>
            <span class="s0">CHILDREN,</span>
            <span class="s0">type + </span><span class="s1">'Exit'</span>
        <span class="s0">];</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s2">return </span><span class="s0">[</span>
            <span class="s0">type,</span>
            <span class="s0">type + </span><span class="s1">'Exit'</span>
        <span class="s0">];</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s2">function </span><span class="s0">toStack(node) {</span>
    <span class="s2">let </span><span class="s0">events;</span>
    <span class="s2">if </span><span class="s0">(node.type === </span><span class="s1">'document'</span><span class="s0">) {</span>
        <span class="s0">events = [</span>
            <span class="s1">'Document'</span><span class="s0">,</span>
            <span class="s0">CHILDREN,</span>
            <span class="s1">'DocumentExit'</span>
        <span class="s0">];</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(node.type === </span><span class="s1">'root'</span><span class="s0">) {</span>
        <span class="s0">events = [</span>
            <span class="s1">'Root'</span><span class="s0">,</span>
            <span class="s0">CHILDREN,</span>
            <span class="s1">'RootExit'</span>
        <span class="s0">];</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s0">events = getEvents(node);</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">{</span>
        <span class="s0">eventIndex: </span><span class="s3">0</span><span class="s0">,</span>
        <span class="s0">events,</span>
        <span class="s0">iterator: </span><span class="s3">0</span><span class="s0">,</span>
        <span class="s0">node,</span>
        <span class="s0">visitorIndex: </span><span class="s3">0</span><span class="s0">,</span>
        <span class="s0">visitors: []</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s2">function </span><span class="s0">cleanMarks(node) {</span>
    <span class="s0">node[isClean] = </span><span class="s2">false</span><span class="s0">;</span>
    <span class="s2">if </span><span class="s0">(node.nodes) node.nodes.forEach((i)=&gt;cleanMarks(i));</span>
    <span class="s2">return </span><span class="s0">node;</span>
<span class="s0">}</span>
<span class="s2">let </span><span class="s0">postcss = {};</span>
<span class="s2">class </span><span class="s0">LazyResult {</span>
    <span class="s0">get content() {</span>
        <span class="s2">return this</span><span class="s0">.stringify().content;</span>
    <span class="s0">}</span>
    <span class="s0">get css() {</span>
        <span class="s2">return this</span><span class="s0">.stringify().css;</span>
    <span class="s0">}</span>
    <span class="s0">get map() {</span>
        <span class="s2">return this</span><span class="s0">.stringify().map;</span>
    <span class="s0">}</span>
    <span class="s0">get messages() {</span>
        <span class="s2">return this</span><span class="s0">.sync().messages;</span>
    <span class="s0">}</span>
    <span class="s0">get opts() {</span>
        <span class="s2">return this</span><span class="s0">.result.opts;</span>
    <span class="s0">}</span>
    <span class="s0">get processor() {</span>
        <span class="s2">return this</span><span class="s0">.result.processor;</span>
    <span class="s0">}</span>
    <span class="s0">get root() {</span>
        <span class="s2">return this</span><span class="s0">.sync().root;</span>
    <span class="s0">}</span>
    <span class="s0">get [Symbol.toStringTag]() {</span>
        <span class="s2">return </span><span class="s1">'LazyResult'</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">constructor(processor, css, opts){</span>
        <span class="s2">this</span><span class="s0">.stringified = </span><span class="s2">false</span><span class="s0">;</span>
        <span class="s2">this</span><span class="s0">.processed = </span><span class="s2">false</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">root;</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">css === </span><span class="s1">'object' </span><span class="s0">&amp;&amp; css !== </span><span class="s2">null </span><span class="s0">&amp;&amp; (css.type === </span><span class="s1">'root' </span><span class="s0">|| css.type === </span><span class="s1">'document'</span><span class="s0">)) {</span>
            <span class="s0">root = cleanMarks(css);</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(css </span><span class="s2">instanceof </span><span class="s0">LazyResult || css </span><span class="s2">instanceof </span><span class="s0">Result) {</span>
            <span class="s0">root = cleanMarks(css.root);</span>
            <span class="s2">if </span><span class="s0">(css.map) {</span>
                <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">opts.map === </span><span class="s1">'undefined'</span><span class="s0">) opts.map = {};</span>
                <span class="s2">if </span><span class="s0">(!opts.map.inline) opts.map.inline = </span><span class="s2">false</span><span class="s0">;</span>
                <span class="s0">opts.map.prev = css.map;</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">let </span><span class="s0">parser = parse;</span>
            <span class="s2">if </span><span class="s0">(opts.syntax) parser = opts.syntax.parse;</span>
            <span class="s2">if </span><span class="s0">(opts.parser) parser = opts.parser;</span>
            <span class="s2">if </span><span class="s0">(parser.parse) parser = parser.parse;</span>
            <span class="s2">try </span><span class="s0">{</span>
                <span class="s0">root = parser(css, opts);</span>
            <span class="s0">} </span><span class="s2">catch </span><span class="s0">(error) {</span>
                <span class="s2">this</span><span class="s0">.processed = </span><span class="s2">true</span><span class="s0">;</span>
                <span class="s2">this</span><span class="s0">.error = error;</span>
            <span class="s0">}</span>
            <span class="s2">if </span><span class="s0">(root &amp;&amp; !root[my]) {</span>
                <span class="s6">/* c8 ignore next 2 */ </span><span class="s0">Container.rebuild(root);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">this</span><span class="s0">.result = </span><span class="s2">new </span><span class="s0">Result(processor, root, opts);</span>
        <span class="s2">this</span><span class="s0">.helpers = {</span>
            <span class="s0">...postcss,</span>
            <span class="s0">postcss,</span>
            <span class="s0">result: </span><span class="s2">this</span><span class="s0">.result</span>
        <span class="s0">};</span>
        <span class="s2">this</span><span class="s0">.plugins = </span><span class="s2">this</span><span class="s0">.processor.plugins.map((plugin)=&gt;{</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">plugin === </span><span class="s1">'object' </span><span class="s0">&amp;&amp; plugin.prepare) {</span>
                <span class="s2">return </span><span class="s0">{</span>
                    <span class="s0">...plugin,</span>
                    <span class="s0">...plugin.prepare(</span><span class="s2">this</span><span class="s0">.result)</span>
                <span class="s0">};</span>
            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                <span class="s2">return </span><span class="s0">plugin;</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s0">async() {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.error) </span><span class="s2">return </span><span class="s0">Promise.reject(</span><span class="s2">this</span><span class="s0">.error);</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.processed) </span><span class="s2">return </span><span class="s0">Promise.resolve(</span><span class="s2">this</span><span class="s0">.result);</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.processing) {</span>
            <span class="s2">this</span><span class="s0">.processing = </span><span class="s2">this</span><span class="s0">.runAsync();</span>
        <span class="s0">}</span>
        <span class="s2">return this</span><span class="s0">.processing;</span>
    <span class="s0">}</span>
    <span class="s2">catch</span><span class="s0">(onRejected) {</span>
        <span class="s2">return this</span><span class="s0">.async().catch(onRejected);</span>
    <span class="s0">}</span>
    <span class="s2">finally</span><span class="s0">(onFinally) {</span>
        <span class="s2">return this</span><span class="s0">.async().then(onFinally, onFinally);</span>
    <span class="s0">}</span>
    <span class="s0">getAsyncError() {</span>
        <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">'Use process(css).then(cb) to work with async plugins'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s0">handleError(error, node) {</span>
        <span class="s2">let </span><span class="s0">plugin = </span><span class="s2">this</span><span class="s0">.result.lastPlugin;</span>
        <span class="s2">try </span><span class="s0">{</span>
            <span class="s2">if </span><span class="s0">(node) node.addToError(error);</span>
            <span class="s2">this</span><span class="s0">.error = error;</span>
            <span class="s2">if </span><span class="s0">(error.name === </span><span class="s1">'CssSyntaxError' </span><span class="s0">&amp;&amp; !error.plugin) {</span>
                <span class="s0">error.plugin = plugin.postcssPlugin;</span>
                <span class="s0">error.setMessage();</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(plugin.postcssVersion) {</span>
                <span class="s2">if </span><span class="s0">(</span><span class="s1">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s0">) {</span>
                    <span class="s2">let </span><span class="s0">pluginName = plugin.postcssPlugin;</span>
                    <span class="s2">let </span><span class="s0">pluginVer = plugin.postcssVersion;</span>
                    <span class="s2">let </span><span class="s0">runtimeVer = </span><span class="s2">this</span><span class="s0">.result.processor.version;</span>
                    <span class="s2">let </span><span class="s0">a = pluginVer.split(</span><span class="s1">'.'</span><span class="s0">);</span>
                    <span class="s2">let </span><span class="s0">b = runtimeVer.split(</span><span class="s1">'.'</span><span class="s0">);</span>
                    <span class="s2">if </span><span class="s0">(a[</span><span class="s3">0</span><span class="s0">] !== b[</span><span class="s3">0</span><span class="s0">] || parseInt(a[</span><span class="s3">1</span><span class="s0">]) &gt; parseInt(b[</span><span class="s3">1</span><span class="s0">])) {</span>
                        <span class="s6">// eslint-disable-next-line no-console</span>
                        <span class="s0">console.error(</span><span class="s1">'Unknown error from PostCSS plugin. Your current PostCSS ' </span><span class="s0">+ </span><span class="s1">'version is ' </span><span class="s0">+ runtimeVer + </span><span class="s1">', but ' </span><span class="s0">+ pluginName + </span><span class="s1">' uses ' </span><span class="s0">+ pluginVer + </span><span class="s1">'. Perhaps this is the source of the error below.'</span><span class="s0">);</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s2">catch </span><span class="s0">(err) {</span>
            <span class="s6">/* c8 ignore next 3 */ // eslint-disable-next-line no-console</span>
            <span class="s2">if </span><span class="s0">(console &amp;&amp; console.error) console.error(err);</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">error;</span>
    <span class="s0">}</span>
    <span class="s0">prepareVisitors() {</span>
        <span class="s2">this</span><span class="s0">.listeners = {};</span>
        <span class="s2">let </span><span class="s0">add = (plugin, type, cb)=&gt;{</span>
            <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.listeners[type]) </span><span class="s2">this</span><span class="s0">.listeners[type] = [];</span>
            <span class="s2">this</span><span class="s0">.listeners[type].push([</span>
                <span class="s0">plugin,</span>
                <span class="s0">cb</span>
            <span class="s0">]);</span>
        <span class="s0">};</span>
        <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">plugin of </span><span class="s2">this</span><span class="s0">.plugins){</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">plugin === </span><span class="s1">'object'</span><span class="s0">) {</span>
                <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">event </span><span class="s2">in </span><span class="s0">plugin){</span>
                    <span class="s2">if </span><span class="s0">(!PLUGIN_PROPS[event] &amp;&amp; </span><span class="s5">/^[A-Z]/</span><span class="s0">.test(event)) {</span>
                        <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">`Unknown event </span><span class="s0">${event} </span><span class="s1">in </span><span class="s0">${plugin.postcssPlugin}</span><span class="s1">. ` </span><span class="s0">+ </span><span class="s1">`Try to update PostCSS (</span><span class="s0">${</span><span class="s2">this</span><span class="s0">.processor.version} </span><span class="s1">now).`</span><span class="s0">);</span>
                    <span class="s0">}</span>
                    <span class="s2">if </span><span class="s0">(!NOT_VISITORS[event]) {</span>
                        <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">plugin[event] === </span><span class="s1">'object'</span><span class="s0">) {</span>
                            <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">filter </span><span class="s2">in </span><span class="s0">plugin[event]){</span>
                                <span class="s2">if </span><span class="s0">(filter === </span><span class="s1">'*'</span><span class="s0">) {</span>
                                    <span class="s0">add(plugin, event, plugin[event][filter]);</span>
                                <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                                    <span class="s0">add(plugin, event + </span><span class="s1">'-' </span><span class="s0">+ filter.toLowerCase(), plugin[event][filter]);</span>
                                <span class="s0">}</span>
                            <span class="s0">}</span>
                        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">plugin[event] === </span><span class="s1">'function'</span><span class="s0">) {</span>
                            <span class="s0">add(plugin, event, plugin[event]);</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">this</span><span class="s0">.hasListener = Object.keys(</span><span class="s2">this</span><span class="s0">.listeners).length &gt; </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">async runAsync() {</span>
        <span class="s2">this</span><span class="s0">.plugin = </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s2">for</span><span class="s0">(</span><span class="s2">let </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; </span><span class="s2">this</span><span class="s0">.plugins.length; i++){</span>
            <span class="s2">let </span><span class="s0">plugin = </span><span class="s2">this</span><span class="s0">.plugins[i];</span>
            <span class="s2">let </span><span class="s0">promise = </span><span class="s2">this</span><span class="s0">.runOnRoot(plugin);</span>
            <span class="s2">if </span><span class="s0">(isPromise(promise)) {</span>
                <span class="s2">try </span><span class="s0">{</span>
                    <span class="s2">await </span><span class="s0">promise;</span>
                <span class="s0">} </span><span class="s2">catch </span><span class="s0">(error) {</span>
                    <span class="s2">throw this</span><span class="s0">.handleError(error);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">this</span><span class="s0">.prepareVisitors();</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.hasListener) {</span>
            <span class="s2">let </span><span class="s0">root = </span><span class="s2">this</span><span class="s0">.result.root;</span>
            <span class="s2">while</span><span class="s0">(!root[isClean]){</span>
                <span class="s0">root[isClean] = </span><span class="s2">true</span><span class="s0">;</span>
                <span class="s2">let </span><span class="s0">stack = [</span>
                    <span class="s0">toStack(root)</span>
                <span class="s0">];</span>
                <span class="s2">while</span><span class="s0">(stack.length &gt; </span><span class="s3">0</span><span class="s0">){</span>
                    <span class="s2">let </span><span class="s0">promise = </span><span class="s2">this</span><span class="s0">.visitTick(stack);</span>
                    <span class="s2">if </span><span class="s0">(isPromise(promise)) {</span>
                        <span class="s2">try </span><span class="s0">{</span>
                            <span class="s2">await </span><span class="s0">promise;</span>
                        <span class="s0">} </span><span class="s2">catch </span><span class="s0">(e) {</span>
                            <span class="s2">let </span><span class="s0">node = stack[stack.length - </span><span class="s3">1</span><span class="s0">].node;</span>
                            <span class="s2">throw this</span><span class="s0">.handleError(e, node);</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.listeners.OnceExit) {</span>
                <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">[plugin, visitor] of </span><span class="s2">this</span><span class="s0">.listeners.OnceExit){</span>
                    <span class="s2">this</span><span class="s0">.result.lastPlugin = plugin;</span>
                    <span class="s2">try </span><span class="s0">{</span>
                        <span class="s2">if </span><span class="s0">(root.type === </span><span class="s1">'document'</span><span class="s0">) {</span>
                            <span class="s2">let </span><span class="s0">roots = root.nodes.map((subRoot)=&gt;visitor(subRoot, </span><span class="s2">this</span><span class="s0">.helpers));</span>
                            <span class="s2">await </span><span class="s0">Promise.all(roots);</span>
                        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                            <span class="s2">await </span><span class="s0">visitor(root, </span><span class="s2">this</span><span class="s0">.helpers);</span>
                        <span class="s0">}</span>
                    <span class="s0">} </span><span class="s2">catch </span><span class="s0">(e) {</span>
                        <span class="s2">throw this</span><span class="s0">.handleError(e);</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">this</span><span class="s0">.processed = </span><span class="s2">true</span><span class="s0">;</span>
        <span class="s2">return this</span><span class="s0">.stringify();</span>
    <span class="s0">}</span>
    <span class="s0">runOnRoot(plugin) {</span>
        <span class="s2">this</span><span class="s0">.result.lastPlugin = plugin;</span>
        <span class="s2">try </span><span class="s0">{</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">plugin === </span><span class="s1">'object' </span><span class="s0">&amp;&amp; plugin.Once) {</span>
                <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.result.root.type === </span><span class="s1">'document'</span><span class="s0">) {</span>
                    <span class="s2">let </span><span class="s0">roots = </span><span class="s2">this</span><span class="s0">.result.root.nodes.map((root)=&gt;plugin.Once(root, </span><span class="s2">this</span><span class="s0">.helpers));</span>
                    <span class="s2">if </span><span class="s0">(isPromise(roots[</span><span class="s3">0</span><span class="s0">])) {</span>
                        <span class="s2">return </span><span class="s0">Promise.all(roots);</span>
                    <span class="s0">}</span>
                    <span class="s2">return </span><span class="s0">roots;</span>
                <span class="s0">}</span>
                <span class="s2">return </span><span class="s0">plugin.Once(</span><span class="s2">this</span><span class="s0">.result.root, </span><span class="s2">this</span><span class="s0">.helpers);</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">plugin === </span><span class="s1">'function'</span><span class="s0">) {</span>
                <span class="s2">return </span><span class="s0">plugin(</span><span class="s2">this</span><span class="s0">.result.root, </span><span class="s2">this</span><span class="s0">.result);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s2">catch </span><span class="s0">(error) {</span>
            <span class="s2">throw this</span><span class="s0">.handleError(error);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">stringify() {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.error) </span><span class="s2">throw this</span><span class="s0">.error;</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.stringified) </span><span class="s2">return this</span><span class="s0">.result;</span>
        <span class="s2">this</span><span class="s0">.stringified = </span><span class="s2">true</span><span class="s0">;</span>
        <span class="s2">this</span><span class="s0">.sync();</span>
        <span class="s2">let </span><span class="s0">opts = </span><span class="s2">this</span><span class="s0">.result.opts;</span>
        <span class="s2">let </span><span class="s0">str = stringify;</span>
        <span class="s2">if </span><span class="s0">(opts.syntax) str = opts.syntax.stringify;</span>
        <span class="s2">if </span><span class="s0">(opts.stringifier) str = opts.stringifier;</span>
        <span class="s2">if </span><span class="s0">(str.stringify) str = str.stringify;</span>
        <span class="s2">let </span><span class="s0">map = </span><span class="s2">new </span><span class="s0">MapGenerator(str, </span><span class="s2">this</span><span class="s0">.result.root, </span><span class="s2">this</span><span class="s0">.result.opts);</span>
        <span class="s2">let </span><span class="s0">data = map.generate();</span>
        <span class="s2">this</span><span class="s0">.result.css = data[</span><span class="s3">0</span><span class="s0">];</span>
        <span class="s2">this</span><span class="s0">.result.map = data[</span><span class="s3">1</span><span class="s0">];</span>
        <span class="s2">return this</span><span class="s0">.result;</span>
    <span class="s0">}</span>
    <span class="s0">sync() {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.error) </span><span class="s2">throw this</span><span class="s0">.error;</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.processed) </span><span class="s2">return this</span><span class="s0">.result;</span>
        <span class="s2">this</span><span class="s0">.processed = </span><span class="s2">true</span><span class="s0">;</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.processing) {</span>
            <span class="s2">throw this</span><span class="s0">.getAsyncError();</span>
        <span class="s0">}</span>
        <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">plugin of </span><span class="s2">this</span><span class="s0">.plugins){</span>
            <span class="s2">let </span><span class="s0">promise = </span><span class="s2">this</span><span class="s0">.runOnRoot(plugin);</span>
            <span class="s2">if </span><span class="s0">(isPromise(promise)) {</span>
                <span class="s2">throw this</span><span class="s0">.getAsyncError();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">this</span><span class="s0">.prepareVisitors();</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.hasListener) {</span>
            <span class="s2">let </span><span class="s0">root = </span><span class="s2">this</span><span class="s0">.result.root;</span>
            <span class="s2">while</span><span class="s0">(!root[isClean]){</span>
                <span class="s0">root[isClean] = </span><span class="s2">true</span><span class="s0">;</span>
                <span class="s2">this</span><span class="s0">.walkSync(root);</span>
            <span class="s0">}</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.listeners.OnceExit) {</span>
                <span class="s2">if </span><span class="s0">(root.type === </span><span class="s1">'document'</span><span class="s0">) {</span>
                    <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">subRoot of root.nodes){</span>
                        <span class="s2">this</span><span class="s0">.visitSync(</span><span class="s2">this</span><span class="s0">.listeners.OnceExit, subRoot);</span>
                    <span class="s0">}</span>
                <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                    <span class="s2">this</span><span class="s0">.visitSync(</span><span class="s2">this</span><span class="s0">.listeners.OnceExit, root);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">return this</span><span class="s0">.result;</span>
    <span class="s0">}</span>
    <span class="s0">then(onFulfilled, onRejected) {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s1">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s0">) {</span>
            <span class="s2">if </span><span class="s0">(!(</span><span class="s1">'from' </span><span class="s2">in this</span><span class="s0">.opts)) {</span>
                <span class="s0">warnOnce(</span><span class="s1">'Without `from` option PostCSS could generate wrong source map ' </span><span class="s0">+ </span><span class="s1">'and will not find Browserslist config. Set it to CSS file path ' </span><span class="s0">+ </span><span class="s1">'or to `undefined` to prevent this warning.'</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">return this</span><span class="s0">.async().then(onFulfilled, onRejected);</span>
    <span class="s0">}</span>
    <span class="s0">toString() {</span>
        <span class="s2">return this</span><span class="s0">.css;</span>
    <span class="s0">}</span>
    <span class="s0">visitSync(visitors, node) {</span>
        <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">[plugin, visitor] of visitors){</span>
            <span class="s2">this</span><span class="s0">.result.lastPlugin = plugin;</span>
            <span class="s2">let </span><span class="s0">promise;</span>
            <span class="s2">try </span><span class="s0">{</span>
                <span class="s0">promise = visitor(node, </span><span class="s2">this</span><span class="s0">.helpers);</span>
            <span class="s0">} </span><span class="s2">catch </span><span class="s0">(e) {</span>
                <span class="s2">throw this</span><span class="s0">.handleError(e, node.proxyOf);</span>
            <span class="s0">}</span>
            <span class="s2">if </span><span class="s0">(node.type !== </span><span class="s1">'root' </span><span class="s0">&amp;&amp; node.type !== </span><span class="s1">'document' </span><span class="s0">&amp;&amp; !node.parent) {</span>
                <span class="s2">return true</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s2">if </span><span class="s0">(isPromise(promise)) {</span>
                <span class="s2">throw this</span><span class="s0">.getAsyncError();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">visitTick(stack) {</span>
        <span class="s2">let </span><span class="s0">visit = stack[stack.length - </span><span class="s3">1</span><span class="s0">];</span>
        <span class="s2">let </span><span class="s0">{ node, visitors } = visit;</span>
        <span class="s2">if </span><span class="s0">(node.type !== </span><span class="s1">'root' </span><span class="s0">&amp;&amp; node.type !== </span><span class="s1">'document' </span><span class="s0">&amp;&amp; !node.parent) {</span>
            <span class="s0">stack.pop();</span>
            <span class="s2">return</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(visitors.length &gt; </span><span class="s3">0 </span><span class="s0">&amp;&amp; visit.visitorIndex &lt; visitors.length) {</span>
            <span class="s2">let </span><span class="s0">[plugin, visitor] = visitors[visit.visitorIndex];</span>
            <span class="s0">visit.visitorIndex += </span><span class="s3">1</span><span class="s0">;</span>
            <span class="s2">if </span><span class="s0">(visit.visitorIndex === visitors.length) {</span>
                <span class="s0">visit.visitors = [];</span>
                <span class="s0">visit.visitorIndex = </span><span class="s3">0</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s2">this</span><span class="s0">.result.lastPlugin = plugin;</span>
            <span class="s2">try </span><span class="s0">{</span>
                <span class="s2">return </span><span class="s0">visitor(node.toProxy(), </span><span class="s2">this</span><span class="s0">.helpers);</span>
            <span class="s0">} </span><span class="s2">catch </span><span class="s0">(e) {</span>
                <span class="s2">throw this</span><span class="s0">.handleError(e, node);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(visit.iterator !== </span><span class="s3">0</span><span class="s0">) {</span>
            <span class="s2">let </span><span class="s0">iterator = visit.iterator;</span>
            <span class="s2">let </span><span class="s0">child;</span>
            <span class="s2">while</span><span class="s0">(child = node.nodes[node.indexes[iterator]]){</span>
                <span class="s0">node.indexes[iterator] += </span><span class="s3">1</span><span class="s0">;</span>
                <span class="s2">if </span><span class="s0">(!child[isClean]) {</span>
                    <span class="s0">child[isClean] = </span><span class="s2">true</span><span class="s0">;</span>
                    <span class="s0">stack.push(toStack(child));</span>
                    <span class="s2">return</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">visit.iterator = </span><span class="s3">0</span><span class="s0">;</span>
            <span class="s2">delete </span><span class="s0">node.indexes[iterator];</span>
        <span class="s0">}</span>
        <span class="s2">let </span><span class="s0">events = visit.events;</span>
        <span class="s2">while</span><span class="s0">(visit.eventIndex &lt; events.length){</span>
            <span class="s2">let </span><span class="s0">event = events[visit.eventIndex];</span>
            <span class="s0">visit.eventIndex += </span><span class="s3">1</span><span class="s0">;</span>
            <span class="s2">if </span><span class="s0">(event === CHILDREN) {</span>
                <span class="s2">if </span><span class="s0">(node.nodes &amp;&amp; node.nodes.length) {</span>
                    <span class="s0">node[isClean] = </span><span class="s2">true</span><span class="s0">;</span>
                    <span class="s0">visit.iterator = node.getIterator();</span>
                <span class="s0">}</span>
                <span class="s2">return</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.listeners[event]) {</span>
                <span class="s0">visit.visitors = </span><span class="s2">this</span><span class="s0">.listeners[event];</span>
                <span class="s2">return</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">stack.pop();</span>
    <span class="s0">}</span>
    <span class="s0">walkSync(node) {</span>
        <span class="s0">node[isClean] = </span><span class="s2">true</span><span class="s0">;</span>
        <span class="s2">let </span><span class="s0">events = getEvents(node);</span>
        <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">event of events){</span>
            <span class="s2">if </span><span class="s0">(event === CHILDREN) {</span>
                <span class="s2">if </span><span class="s0">(node.nodes) {</span>
                    <span class="s0">node.each((child)=&gt;{</span>
                        <span class="s2">if </span><span class="s0">(!child[isClean]) </span><span class="s2">this</span><span class="s0">.walkSync(child);</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                <span class="s2">let </span><span class="s0">visitors = </span><span class="s2">this</span><span class="s0">.listeners[event];</span>
                <span class="s2">if </span><span class="s0">(visitors) {</span>
                    <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.visitSync(visitors, node.toProxy())) </span><span class="s2">return</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">warnings() {</span>
        <span class="s2">return this</span><span class="s0">.sync().warnings();</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">LazyResult.registerPostcss = (dependant)=&gt;{</span>
    <span class="s0">postcss = dependant;</span>
<span class="s0">};</span>
<span class="s0">module.exports = LazyResult;</span>
<span class="s0">LazyResult.default = LazyResult;</span>
<span class="s0">Root.registerLazyResult(LazyResult);</span>
<span class="s0">Document.registerLazyResult(LazyResult);</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/no-work-result.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">let </span><span class="s0">MapGenerator = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/map-generator.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">parse = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/parse.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">const </span><span class="s0">Result = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/result.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">stringify = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/stringify.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">warnOnce = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/warn-once.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">class </span><span class="s0">NoWorkResult {</span>
    <span class="s0">get content() {</span>
        <span class="s2">return this</span><span class="s0">.result.css;</span>
    <span class="s0">}</span>
    <span class="s0">get css() {</span>
        <span class="s2">return this</span><span class="s0">.result.css;</span>
    <span class="s0">}</span>
    <span class="s0">get map() {</span>
        <span class="s2">return this</span><span class="s0">.result.map;</span>
    <span class="s0">}</span>
    <span class="s0">get messages() {</span>
        <span class="s2">return </span><span class="s0">[];</span>
    <span class="s0">}</span>
    <span class="s0">get opts() {</span>
        <span class="s2">return this</span><span class="s0">.result.opts;</span>
    <span class="s0">}</span>
    <span class="s0">get processor() {</span>
        <span class="s2">return this</span><span class="s0">.result.processor;</span>
    <span class="s0">}</span>
    <span class="s0">get root() {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">._root) {</span>
            <span class="s2">return this</span><span class="s0">._root;</span>
        <span class="s0">}</span>
        <span class="s2">let </span><span class="s0">root;</span>
        <span class="s2">let </span><span class="s0">parser = parse;</span>
        <span class="s2">try </span><span class="s0">{</span>
            <span class="s0">root = parser(</span><span class="s2">this</span><span class="s0">._css, </span><span class="s2">this</span><span class="s0">._opts);</span>
        <span class="s0">} </span><span class="s2">catch </span><span class="s0">(error) {</span>
            <span class="s2">this</span><span class="s0">.error = error;</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.error) {</span>
            <span class="s2">throw this</span><span class="s0">.error;</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">this</span><span class="s0">._root = root;</span>
            <span class="s2">return </span><span class="s0">root;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">get [Symbol.toStringTag]() {</span>
        <span class="s2">return </span><span class="s1">'NoWorkResult'</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">constructor(processor, css, opts){</span>
        <span class="s0">css = css.toString();</span>
        <span class="s2">this</span><span class="s0">.stringified = </span><span class="s2">false</span><span class="s0">;</span>
        <span class="s2">this</span><span class="s0">._processor = processor;</span>
        <span class="s2">this</span><span class="s0">._css = css;</span>
        <span class="s2">this</span><span class="s0">._opts = opts;</span>
        <span class="s2">this</span><span class="s0">._map = undefined;</span>
        <span class="s2">let </span><span class="s0">root;</span>
        <span class="s2">let </span><span class="s0">str = stringify;</span>
        <span class="s2">this</span><span class="s0">.result = </span><span class="s2">new </span><span class="s0">Result(</span><span class="s2">this</span><span class="s0">._processor, root, </span><span class="s2">this</span><span class="s0">._opts);</span>
        <span class="s2">this</span><span class="s0">.result.css = css;</span>
        <span class="s2">let </span><span class="s0">self = </span><span class="s2">this</span><span class="s0">;</span>
        <span class="s0">Object.defineProperty(</span><span class="s2">this</span><span class="s0">.result, </span><span class="s1">'root'</span><span class="s0">, {</span>
            <span class="s0">get () {</span>
                <span class="s2">return </span><span class="s0">self.root;</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s2">let </span><span class="s0">map = </span><span class="s2">new </span><span class="s0">MapGenerator(str, root, </span><span class="s2">this</span><span class="s0">._opts, css);</span>
        <span class="s2">if </span><span class="s0">(map.isMap()) {</span>
            <span class="s2">let </span><span class="s0">[generatedCSS, generatedMap] = map.generate();</span>
            <span class="s2">if </span><span class="s0">(generatedCSS) {</span>
                <span class="s2">this</span><span class="s0">.result.css = generatedCSS;</span>
            <span class="s0">}</span>
            <span class="s2">if </span><span class="s0">(generatedMap) {</span>
                <span class="s2">this</span><span class="s0">.result.map = generatedMap;</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s0">map.clearAnnotation();</span>
            <span class="s2">this</span><span class="s0">.result.css = map.css;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">async() {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.error) </span><span class="s2">return </span><span class="s0">Promise.reject(</span><span class="s2">this</span><span class="s0">.error);</span>
        <span class="s2">return </span><span class="s0">Promise.resolve(</span><span class="s2">this</span><span class="s0">.result);</span>
    <span class="s0">}</span>
    <span class="s2">catch</span><span class="s0">(onRejected) {</span>
        <span class="s2">return this</span><span class="s0">.async().catch(onRejected);</span>
    <span class="s0">}</span>
    <span class="s2">finally</span><span class="s0">(onFinally) {</span>
        <span class="s2">return this</span><span class="s0">.async().then(onFinally, onFinally);</span>
    <span class="s0">}</span>
    <span class="s0">sync() {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.error) </span><span class="s2">throw this</span><span class="s0">.error;</span>
        <span class="s2">return this</span><span class="s0">.result;</span>
    <span class="s0">}</span>
    <span class="s0">then(onFulfilled, onRejected) {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s1">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s0">) {</span>
            <span class="s2">if </span><span class="s0">(!(</span><span class="s1">'from' </span><span class="s2">in this</span><span class="s0">._opts)) {</span>
                <span class="s0">warnOnce(</span><span class="s1">'Without `from` option PostCSS could generate wrong source map ' </span><span class="s0">+ </span><span class="s1">'and will not find Browserslist config. Set it to CSS file path ' </span><span class="s0">+ </span><span class="s1">'or to `undefined` to prevent this warning.'</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">return this</span><span class="s0">.async().then(onFulfilled, onRejected);</span>
    <span class="s0">}</span>
    <span class="s0">toString() {</span>
        <span class="s2">return this</span><span class="s0">._css;</span>
    <span class="s0">}</span>
    <span class="s0">warnings() {</span>
        <span class="s2">return </span><span class="s0">[];</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">module.exports = NoWorkResult;</span>
<span class="s0">NoWorkResult.default = NoWorkResult;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/processor.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">let </span><span class="s0">Document = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/document.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">LazyResult = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/lazy-result.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">NoWorkResult = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/no-work-result.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Root = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/root.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">class </span><span class="s0">Processor {</span>
    <span class="s0">constructor(plugins = []){</span>
        <span class="s2">this</span><span class="s0">.version = </span><span class="s1">'8.5.6'</span><span class="s0">;</span>
        <span class="s2">this</span><span class="s0">.plugins = </span><span class="s2">this</span><span class="s0">.normalize(plugins);</span>
    <span class="s0">}</span>
    <span class="s0">normalize(plugins) {</span>
        <span class="s2">let </span><span class="s0">normalized = [];</span>
        <span class="s2">for </span><span class="s0">(</span><span class="s2">let </span><span class="s0">i of plugins){</span>
            <span class="s2">if </span><span class="s0">(i.postcss === </span><span class="s2">true</span><span class="s0">) {</span>
                <span class="s0">i = i();</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(i.postcss) {</span>
                <span class="s0">i = i.postcss;</span>
            <span class="s0">}</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">i === </span><span class="s1">'object' </span><span class="s0">&amp;&amp; Array.isArray(i.plugins)) {</span>
                <span class="s0">normalized = normalized.concat(i.plugins);</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">i === </span><span class="s1">'object' </span><span class="s0">&amp;&amp; i.postcssPlugin) {</span>
                <span class="s0">normalized.push(i);</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">i === </span><span class="s1">'function'</span><span class="s0">) {</span>
                <span class="s0">normalized.push(i);</span>
            <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">i === </span><span class="s1">'object' </span><span class="s0">&amp;&amp; (i.parse || i.stringify)) {</span>
                <span class="s2">if </span><span class="s0">(</span><span class="s1">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s0">) {</span>
                    <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">'PostCSS syntaxes cannot be used as plugins. Instead, please use ' </span><span class="s0">+ </span><span class="s1">'one of the syntax/parser/stringifier options as outlined ' </span><span class="s0">+ </span><span class="s1">'in your PostCSS runner documentation.'</span><span class="s0">);</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
                <span class="s2">throw new </span><span class="s0">Error(i + </span><span class="s1">' is not a PostCSS plugin'</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">normalized;</span>
    <span class="s0">}</span>
    <span class="s0">process(css, opts = {}) {</span>
        <span class="s2">if </span><span class="s0">(!</span><span class="s2">this</span><span class="s0">.plugins.length &amp;&amp; !opts.parser &amp;&amp; !opts.stringifier &amp;&amp; !opts.syntax) {</span>
            <span class="s2">return new </span><span class="s0">NoWorkResult(</span><span class="s2">this</span><span class="s0">, css, opts);</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">return new </span><span class="s0">LazyResult(</span><span class="s2">this</span><span class="s0">, css, opts);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">use(plugin) {</span>
        <span class="s2">this</span><span class="s0">.plugins = </span><span class="s2">this</span><span class="s0">.plugins.concat(</span><span class="s2">this</span><span class="s0">.normalize([</span>
            <span class="s0">plugin</span>
        <span class="s0">]));</span>
        <span class="s2">return this</span><span class="s0">;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">module.exports = Processor;</span>
<span class="s0">Processor.default = Processor;</span>
<span class="s0">Root.registerProcessor(Processor);</span>
<span class="s0">Document.registerProcessor(Processor);</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/postcss.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">let </span><span class="s0">AtRule = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/at-rule.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Comment = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/comment.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Container = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/container.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">CssSyntaxError = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/css-syntax-error.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Declaration = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/declaration.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Document = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/document.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">fromJSON = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/fromJSON.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Input = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/input.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">LazyResult = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/lazy-result.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">list = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/list.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Node = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/node.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">parse = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/parse.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Processor = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/processor.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Result = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/result.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Root = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/root.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Rule = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/rule.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">stringify = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/stringify.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">let </span><span class="s0">Warning = __turbopack_context__.r(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/warning.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">function </span><span class="s0">postcss(...plugins) {</span>
    <span class="s2">if </span><span class="s0">(plugins.length === </span><span class="s3">1 </span><span class="s0">&amp;&amp; Array.isArray(plugins[</span><span class="s3">0</span><span class="s0">])) {</span>
        <span class="s0">plugins = plugins[</span><span class="s3">0</span><span class="s0">];</span>
    <span class="s0">}</span>
    <span class="s2">return new </span><span class="s0">Processor(plugins);</span>
<span class="s0">}</span>
<span class="s0">postcss.plugin = </span><span class="s2">function </span><span class="s0">plugin(name, initializer) {</span>
    <span class="s2">let </span><span class="s0">warningPrinted = </span><span class="s2">false</span><span class="s0">;</span>
    <span class="s2">function </span><span class="s0">creator(...args) {</span>
        <span class="s6">// eslint-disable-next-line no-console</span>
        <span class="s2">if </span><span class="s0">(console &amp;&amp; console.warn &amp;&amp; !warningPrinted) {</span>
            <span class="s0">warningPrinted = </span><span class="s2">true</span><span class="s0">;</span>
            <span class="s6">// eslint-disable-next-line no-console</span>
            <span class="s0">console.warn(name + </span><span class="s1">': postcss.plugin was deprecated. Migration guide:</span><span class="s4">\n</span><span class="s1">' </span><span class="s0">+ </span><span class="s1">'https://evilmartians.com/chronicles/postcss-8-plugin-migration'</span><span class="s0">);</span>
            <span class="s2">if </span><span class="s0">(process.env.LANG &amp;&amp; process.env.LANG.startsWith(</span><span class="s1">'cn'</span><span class="s0">)) {</span>
                <span class="s6">/* c8 ignore next 7 */ // eslint-disable-next-line no-console</span>
                <span class="s0">console.warn(name + </span><span class="s1">':  postcss.plugin . :</span><span class="s4">\n</span><span class="s1">' </span><span class="s0">+ </span><span class="s1">'https://www.w3ctech.com/topic/2226'</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">let </span><span class="s0">transformer = initializer(...args);</span>
        <span class="s0">transformer.postcssPlugin = name;</span>
        <span class="s0">transformer.postcssVersion = </span><span class="s2">new </span><span class="s0">Processor().version;</span>
        <span class="s2">return </span><span class="s0">transformer;</span>
    <span class="s0">}</span>
    <span class="s2">let </span><span class="s0">cache;</span>
    <span class="s0">Object.defineProperty(creator, </span><span class="s1">'postcss'</span><span class="s0">, {</span>
        <span class="s0">get () {</span>
            <span class="s2">if </span><span class="s0">(!cache) cache = creator();</span>
            <span class="s2">return </span><span class="s0">cache;</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">creator.process = </span><span class="s2">function</span><span class="s0">(css, processOpts, pluginOpts) {</span>
        <span class="s2">return </span><span class="s0">postcss([</span>
            <span class="s0">creator(pluginOpts)</span>
        <span class="s0">]).process(css, processOpts);</span>
    <span class="s0">};</span>
    <span class="s2">return </span><span class="s0">creator;</span>
<span class="s0">};</span>
<span class="s0">postcss.stringify = stringify;</span>
<span class="s0">postcss.parse = parse;</span>
<span class="s0">postcss.fromJSON = fromJSON;</span>
<span class="s0">postcss.list = list;</span>
<span class="s0">postcss.comment = (defaults)=&gt;</span><span class="s2">new </span><span class="s0">Comment(defaults);</span>
<span class="s0">postcss.atRule = (defaults)=&gt;</span><span class="s2">new </span><span class="s0">AtRule(defaults);</span>
<span class="s0">postcss.decl = (defaults)=&gt;</span><span class="s2">new </span><span class="s0">Declaration(defaults);</span>
<span class="s0">postcss.rule = (defaults)=&gt;</span><span class="s2">new </span><span class="s0">Rule(defaults);</span>
<span class="s0">postcss.root = (defaults)=&gt;</span><span class="s2">new </span><span class="s0">Root(defaults);</span>
<span class="s0">postcss.document = (defaults)=&gt;</span><span class="s2">new </span><span class="s0">Document(defaults);</span>
<span class="s0">postcss.CssSyntaxError = CssSyntaxError;</span>
<span class="s0">postcss.Declaration = Declaration;</span>
<span class="s0">postcss.Container = Container;</span>
<span class="s0">postcss.Processor = Processor;</span>
<span class="s0">postcss.Document = Document;</span>
<span class="s0">postcss.Comment = Comment;</span>
<span class="s0">postcss.Warning = Warning;</span>
<span class="s0">postcss.AtRule = AtRule;</span>
<span class="s0">postcss.Result = Result;</span>
<span class="s0">postcss.Input = Input;</span>
<span class="s0">postcss.Rule = Rule;</span>
<span class="s0">postcss.Root = Root;</span>
<span class="s0">postcss.Node = Node;</span>
<span class="s0">LazyResult.registerPostcss(postcss);</span>
<span class="s0">module.exports = postcss;</span>
<span class="s0">postcss.default = postcss;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[project]/node_modules/postcss/lib/postcss.mjs [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">__turbopack_context__.s([</span>
    <span class="s1">&quot;AtRule&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;AtRule,</span>
    <span class="s1">&quot;Comment&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;Comment,</span>
    <span class="s1">&quot;Container&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;Container,</span>
    <span class="s1">&quot;CssSyntaxError&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;CssSyntaxError,</span>
    <span class="s1">&quot;Declaration&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;Declaration,</span>
    <span class="s1">&quot;Document&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;Document,</span>
    <span class="s1">&quot;Input&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;Input,</span>
    <span class="s1">&quot;Node&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;Node,</span>
    <span class="s1">&quot;Processor&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;Processor,</span>
    <span class="s1">&quot;Result&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;Result,</span>
    <span class="s1">&quot;Root&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;Root,</span>
    <span class="s1">&quot;Rule&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;Rule,</span>
    <span class="s1">&quot;Warning&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;Warning,</span>
    <span class="s1">&quot;atRule&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;atRule,</span>
    <span class="s1">&quot;comment&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;comment,</span>
    <span class="s1">&quot;decl&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;decl,</span>
    <span class="s1">&quot;default&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;__TURBOPACK__default__export__,</span>
    <span class="s1">&quot;document&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;document,</span>
    <span class="s1">&quot;fromJSON&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;fromJSON,</span>
    <span class="s1">&quot;list&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;list,</span>
    <span class="s1">&quot;parse&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;parse,</span>
    <span class="s1">&quot;plugin&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;plugin,</span>
    <span class="s1">&quot;root&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;root,</span>
    <span class="s1">&quot;rule&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;rule,</span>
    <span class="s1">&quot;stringify&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;stringify</span>
<span class="s0">]);</span>
<span class="s2">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i(</span><span class="s1">&quot;[project]/node_modules/postcss/lib/postcss.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s0">;</span>
<span class="s2">const </span><span class="s0">__TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">];</span>
<span class="s2">const </span><span class="s0">stringify = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">].stringify;</span>
<span class="s2">const </span><span class="s0">fromJSON = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">].fromJSON;</span>
<span class="s2">const </span><span class="s0">plugin = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">].plugin;</span>
<span class="s2">const </span><span class="s0">parse = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">].parse;</span>
<span class="s2">const </span><span class="s0">list = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">].list;</span>
<span class="s2">const </span><span class="s0">document = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">].document;</span>
<span class="s2">const </span><span class="s0">comment = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">].comment;</span>
<span class="s2">const </span><span class="s0">atRule = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">].atRule;</span>
<span class="s2">const </span><span class="s0">rule = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">].rule;</span>
<span class="s2">const </span><span class="s0">decl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">].decl;</span>
<span class="s2">const </span><span class="s0">root = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">].root;</span>
<span class="s2">const </span><span class="s0">CssSyntaxError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">].CssSyntaxError;</span>
<span class="s2">const </span><span class="s0">Declaration = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">].Declaration;</span>
<span class="s2">const </span><span class="s0">Container = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">].Container;</span>
<span class="s2">const </span><span class="s0">Processor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">].Processor;</span>
<span class="s2">const </span><span class="s0">Document = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">].Document;</span>
<span class="s2">const </span><span class="s0">Comment = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">].Comment;</span>
<span class="s2">const </span><span class="s0">Warning = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">].Warning;</span>
<span class="s2">const </span><span class="s0">AtRule = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">].AtRule;</span>
<span class="s2">const </span><span class="s0">Result = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">].Result;</span>
<span class="s2">const </span><span class="s0">Input = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">].Input;</span>
<span class="s2">const </span><span class="s0">Rule = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">].Rule;</span>
<span class="s2">const </span><span class="s0">Root = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">].Root;</span>
<span class="s2">const </span><span class="s0">Node = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;default&quot;</span><span class="s0">].Node;</span>
<span class="s0">}),</span>
<span class="s0">];</span>

<span class="s6">//# sourceMappingURL=node_modules_fe693df6._.js.map</span></pre>
</body>
</html>