<html>
<head>
<title>windows.cjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #8c8c8c; font-style: italic;}
.s3 { color: #0033b3;}
.s4 { color: #1750eb;}
.s5 { color: #8c8c8c; font-style: italic;}
.s6 { color: #264eff;}
.s7 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
windows.cjs</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// Copyright the Browserify authors. MIT License.</span>
<span class="s3">function </span><span class="s1">assertPath(path) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">path !== </span><span class="s0">&quot;string&quot;</span><span class="s1">) {</span>
    <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s0">`Path must be a string, received &quot;</span><span class="s1">${JSON.stringify(path)}</span><span class="s0">&quot;`</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s3">function </span><span class="s1">stripSuffix(name, suffix) {</span>
  <span class="s3">if </span><span class="s1">(suffix.length &gt;= name.length) {</span>
    <span class="s3">return </span><span class="s1">name;</span>
  <span class="s1">}</span>
  <span class="s3">const </span><span class="s1">lenDiff = name.length - suffix.length;</span>
  <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = suffix.length - </span><span class="s4">1</span><span class="s1">; i &gt;= </span><span class="s4">0</span><span class="s1">; --i){</span>
    <span class="s3">if </span><span class="s1">(name.charCodeAt(lenDiff + i) !== suffix.charCodeAt(i)) {</span>
      <span class="s3">return </span><span class="s1">name;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">name.slice(</span><span class="s4">0</span><span class="s1">, -suffix.length);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">lastPathSegment(path, isSep, start = </span><span class="s4">0</span><span class="s1">) {</span>
  <span class="s3">let </span><span class="s1">matchedNonSeparator = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">end = path.length;</span>
  <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = path.length - </span><span class="s4">1</span><span class="s1">; i &gt;= start; --i){</span>
    <span class="s3">if </span><span class="s1">(isSep(path.charCodeAt(i))) {</span>
      <span class="s3">if </span><span class="s1">(matchedNonSeparator) {</span>
        <span class="s1">start = i + </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!matchedNonSeparator) {</span>
      <span class="s1">matchedNonSeparator = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">end = i + </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">path.slice(start, end);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">assertArgs$1(path, suffix) {</span>
  <span class="s1">assertPath(path);</span>
  <span class="s3">if </span><span class="s1">(path.length === </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return </span><span class="s1">path;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">suffix !== </span><span class="s0">&quot;string&quot;</span><span class="s1">) {</span>
    <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s0">`Suffix must be a string, received &quot;</span><span class="s1">${JSON.stringify(suffix)}</span><span class="s0">&quot;`</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// Copyright the Browserify authors. MIT License.</span>
<span class="s2">// Ported from https://github.com/browserify/path-browserify/</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">// Alphabet chars.</span>
<span class="s3">const </span><span class="s1">CHAR_UPPERCASE_A = </span><span class="s4">65</span><span class="s1">; </span><span class="s2">/* A */ </span>
<span class="s3">const </span><span class="s1">CHAR_LOWERCASE_A = </span><span class="s4">97</span><span class="s1">; </span><span class="s2">/* a */ </span>
<span class="s3">const </span><span class="s1">CHAR_UPPERCASE_Z = </span><span class="s4">90</span><span class="s1">; </span><span class="s2">/* Z */ </span>
<span class="s3">const </span><span class="s1">CHAR_LOWERCASE_Z = </span><span class="s4">122</span><span class="s1">; </span><span class="s2">/* z */ </span>
<span class="s2">// Non-alphabetic chars.</span>
<span class="s3">const </span><span class="s1">CHAR_DOT = </span><span class="s4">46</span><span class="s1">; </span><span class="s2">/* . */ </span>
<span class="s3">const </span><span class="s1">CHAR_FORWARD_SLASH = </span><span class="s4">47</span><span class="s1">; </span><span class="s2">/* / */ </span>
<span class="s3">const </span><span class="s1">CHAR_BACKWARD_SLASH = </span><span class="s4">92</span><span class="s1">; </span><span class="s2">/* \ */ </span>
<span class="s3">const </span><span class="s1">CHAR_COLON = </span><span class="s4">58</span><span class="s1">; </span><span class="s2">/* : */ </span>
<span class="s3">const </span><span class="s1">CHAR_QUESTION_MARK = </span><span class="s4">63</span><span class="s1">; </span><span class="s2">/* ? */</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// Copyright the Browserify authors. MIT License.</span>
<span class="s2">// Ported from https://github.com/browserify/path-browserify/</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s3">function </span><span class="s1">stripTrailingSeparators(segment, isSep) {</span>
  <span class="s3">if </span><span class="s1">(segment.length &lt;= </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">segment;</span>
  <span class="s1">}</span>
  <span class="s3">let </span><span class="s1">end = segment.length;</span>
  <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = segment.length - </span><span class="s4">1</span><span class="s1">; i &gt; </span><span class="s4">0</span><span class="s1">; i--){</span>
    <span class="s3">if </span><span class="s1">(isSep(segment.charCodeAt(i))) {</span>
      <span class="s1">end = i;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">segment.slice(</span><span class="s4">0</span><span class="s1">, end);</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// Copyright the Browserify authors. MIT License.</span>
<span class="s2">// Ported from https://github.com/browserify/path-browserify/</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s3">function </span><span class="s1">isPosixPathSeparator(code) {</span>
  <span class="s3">return </span><span class="s1">code === CHAR_FORWARD_SLASH;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">isPathSeparator(code) {</span>
  <span class="s3">return </span><span class="s1">code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">isWindowsDeviceRoot(code) {</span>
  <span class="s3">return </span><span class="s1">code &gt;= CHAR_LOWERCASE_A &amp;&amp; code &lt;= CHAR_LOWERCASE_Z || code &gt;= CHAR_UPPERCASE_A &amp;&amp; code &lt;= CHAR_UPPERCASE_Z;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s3">function </span><span class="s1">assertArg$3(url) {</span>
  <span class="s1">url = url </span><span class="s3">instanceof </span><span class="s1">URL ? url : </span><span class="s3">new </span><span class="s1">URL(url);</span>
  <span class="s3">if </span><span class="s1">(url.protocol !== </span><span class="s0">&quot;file:&quot;</span><span class="s1">) {</span>
    <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s0">`URL must be a file URL: received &quot;</span><span class="s1">${url.protocol}</span><span class="s0">&quot;`</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">url;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Converts a file URL to a path string.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { fromFileUrl } from &quot;@std/path/windows/from-file-url&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* assertEquals(fromFileUrl(&quot;file:///home/foo&quot;), &quot;\\home\\foo&quot;);</span>
 <span class="s2">* assertEquals(fromFileUrl(&quot;file:///C:/Users/foo&quot;), &quot;C:\\Users\\foo&quot;);</span>
 <span class="s2">* assertEquals(fromFileUrl(&quot;file://localhost/home/foo&quot;), &quot;\\home\\foo&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">url The file URL to convert.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The path string.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">fromFileUrl(url) {</span>
  <span class="s1">url = assertArg$3(url);</span>
  <span class="s3">let </span><span class="s1">path = decodeURIComponent(url.pathname.replace(</span><span class="s6">/\//g</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">&quot;</span><span class="s1">).replace(</span><span class="s6">/%(?![0-9A-Fa-f]{2})/g</span><span class="s1">, </span><span class="s0">&quot;%25&quot;</span><span class="s1">)).replace(</span><span class="s6">/^\\*([A-Za-z]:)(\\|$)/</span><span class="s1">, </span><span class="s0">&quot;$1</span><span class="s7">\\</span><span class="s0">&quot;</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(url.hostname !== </span><span class="s0">&quot;&quot;</span><span class="s1">) {</span>
    <span class="s2">// Note: The `URL` implementation guarantees that the drive letter and</span>
    <span class="s2">// hostname are mutually exclusive. Otherwise it would not have been valid</span>
    <span class="s2">// to append the hostname and path like this.</span>
    <span class="s1">path = </span><span class="s0">`</span><span class="s7">\\\\</span><span class="s1">${url.hostname}${path}</span><span class="s0">`</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">path;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Return the last portion of a `path`.</span>
 <span class="s2">* Trailing directory separators are ignored, and optional suffix is removed.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { basename } from &quot;@std/path/windows/basename&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* assertEquals(basename(&quot;C:\\user\\Documents\\&quot;), &quot;Documents&quot;);</span>
 <span class="s2">* assertEquals(basename(&quot;C:\\user\\Documents\\image.png&quot;), &quot;image.png&quot;);</span>
 <span class="s2">* assertEquals(basename(&quot;C:\\user\\Documents\\image.png&quot;, &quot;.png&quot;), &quot;image&quot;);</span>
 <span class="s2">* assertEquals(basename(new URL(&quot;file:///C:/user/Documents/image.png&quot;)), &quot;image.png&quot;);</span>
 <span class="s2">* assertEquals(basename(new URL(&quot;file:///C:/user/Documents/image.png&quot;), &quot;.png&quot;), &quot;image&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">path The path to extract the name from.</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">suffix The suffix to remove from extracted name.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The extracted name.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">basename(path, suffix = </span><span class="s0">&quot;&quot;</span><span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(path </span><span class="s3">instanceof </span><span class="s1">URL) {</span>
    <span class="s1">path = fromFileUrl(path);</span>
  <span class="s1">}</span>
  <span class="s1">assertArgs$1(path, suffix);</span>
  <span class="s2">// Check for a drive letter prefix so as not to mistake the following</span>
  <span class="s2">// path separator as an extra separator at the end of the path that can be</span>
  <span class="s2">// disregarded</span>
  <span class="s3">let </span><span class="s1">start = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(path.length &gt;= </span><span class="s4">2</span><span class="s1">) {</span>
    <span class="s3">const </span><span class="s1">drive = path.charCodeAt(</span><span class="s4">0</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(isWindowsDeviceRoot(drive)) {</span>
      <span class="s3">if </span><span class="s1">(path.charCodeAt(</span><span class="s4">1</span><span class="s1">) === CHAR_COLON) start = </span><span class="s4">2</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">const </span><span class="s1">lastSegment = lastPathSegment(path, isPathSeparator, start);</span>
  <span class="s3">const </span><span class="s1">strippedSegment = stripTrailingSeparators(lastSegment, isPathSeparator);</span>
  <span class="s3">return </span><span class="s1">suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* The character used to separate entries in the PATH environment variable.</span>
 <span class="s2">*/ </span><span class="s3">const </span><span class="s1">DELIMITER = </span><span class="s0">&quot;;&quot;</span><span class="s1">;</span>
<span class="s2">/**</span>
 <span class="s2">* The character used to separate components of a file path.</span>
 <span class="s2">*/ </span><span class="s3">const </span><span class="s1">SEPARATOR = </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">&quot;</span><span class="s1">;</span>
<span class="s2">/**</span>
 <span class="s2">* A regular expression that matches one or more path separators.</span>
 <span class="s2">*/ </span><span class="s3">const </span><span class="s1">SEPARATOR_PATTERN = </span><span class="s6">/[\\/]+/</span><span class="s1">;</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s3">function </span><span class="s1">assertArg$2(path) {</span>
  <span class="s1">assertPath(path);</span>
  <span class="s3">if </span><span class="s1">(path.length === </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return </span><span class="s0">&quot;.&quot;</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Return the directory path of a `path`.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { dirname } from &quot;@std/path/windows/dirname&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* assertEquals(dirname(&quot;C:\\foo\\bar\\baz.ext&quot;), &quot;C:\\foo\\bar&quot;);</span>
 <span class="s2">* assertEquals(dirname(new URL(&quot;file:///C:/foo/bar/baz.ext&quot;)), &quot;C:\\foo\\bar&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">path The path to get the directory from.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The directory path.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">dirname(path) {</span>
  <span class="s3">if </span><span class="s1">(path </span><span class="s3">instanceof </span><span class="s1">URL) {</span>
    <span class="s1">path = fromFileUrl(path);</span>
  <span class="s1">}</span>
  <span class="s1">assertArg$2(path);</span>
  <span class="s3">const </span><span class="s1">len = path.length;</span>
  <span class="s3">let </span><span class="s1">rootEnd = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">end = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">matchedSlash = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">offset = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s1">code = path.charCodeAt(</span><span class="s4">0</span><span class="s1">);</span>
  <span class="s2">// Try to match a root</span>
  <span class="s3">if </span><span class="s1">(len &gt; </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(isPathSeparator(code)) {</span>
      <span class="s2">// Possible UNC root</span>
      <span class="s1">rootEnd = offset = </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s1">(isPathSeparator(path.charCodeAt(</span><span class="s4">1</span><span class="s1">))) {</span>
        <span class="s2">// Matched double path separator at beginning</span>
        <span class="s3">let </span><span class="s1">j = </span><span class="s4">2</span><span class="s1">;</span>
        <span class="s3">let </span><span class="s1">last = j;</span>
        <span class="s2">// Match 1 or more non-path separators</span>
        <span class="s3">for</span><span class="s1">(; j &lt; len; ++j){</span>
          <span class="s3">if </span><span class="s1">(isPathSeparator(path.charCodeAt(j))) </span><span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(j &lt; len &amp;&amp; j !== last) {</span>
          <span class="s2">// Matched!</span>
          <span class="s1">last = j;</span>
          <span class="s2">// Match 1 or more path separators</span>
          <span class="s3">for</span><span class="s1">(; j &lt; len; ++j){</span>
            <span class="s3">if </span><span class="s1">(!isPathSeparator(path.charCodeAt(j))) </span><span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s3">if </span><span class="s1">(j &lt; len &amp;&amp; j !== last) {</span>
            <span class="s2">// Matched!</span>
            <span class="s1">last = j;</span>
            <span class="s2">// Match 1 or more non-path separators</span>
            <span class="s3">for</span><span class="s1">(; j &lt; len; ++j){</span>
              <span class="s3">if </span><span class="s1">(isPathSeparator(path.charCodeAt(j))) </span><span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(j === len) {</span>
              <span class="s2">// We matched a UNC root only</span>
              <span class="s3">return </span><span class="s1">path;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(j !== last) {</span>
              <span class="s2">// We matched a UNC root with leftovers</span>
              <span class="s2">// Offset by 1 to include the separator after the UNC root to</span>
              <span class="s2">// treat it as a &quot;normal root&quot; on top of a (UNC) root</span>
              <span class="s1">rootEnd = offset = j + </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isWindowsDeviceRoot(code)) {</span>
      <span class="s2">// Possible device root</span>
      <span class="s3">if </span><span class="s1">(path.charCodeAt(</span><span class="s4">1</span><span class="s1">) === CHAR_COLON) {</span>
        <span class="s1">rootEnd = offset = </span><span class="s4">2</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(len &gt; </span><span class="s4">2</span><span class="s1">) {</span>
          <span class="s3">if </span><span class="s1">(isPathSeparator(path.charCodeAt(</span><span class="s4">2</span><span class="s1">))) rootEnd = offset = </span><span class="s4">3</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isPathSeparator(code)) {</span>
    <span class="s2">// `path` contains just a path separator, exit early to avoid</span>
    <span class="s2">// unnecessary work</span>
    <span class="s3">return </span><span class="s1">path;</span>
  <span class="s1">}</span>
  <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = len - </span><span class="s4">1</span><span class="s1">; i &gt;= offset; --i){</span>
    <span class="s3">if </span><span class="s1">(isPathSeparator(path.charCodeAt(i))) {</span>
      <span class="s3">if </span><span class="s1">(!matchedSlash) {</span>
        <span class="s1">end = i;</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s2">// We saw the first non-path separator</span>
      <span class="s1">matchedSlash = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(end === -</span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(rootEnd === -</span><span class="s4">1</span><span class="s1">) </span><span class="s3">return </span><span class="s0">&quot;.&quot;</span><span class="s1">;</span>
    <span class="s3">else </span><span class="s1">end = rootEnd;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">stripTrailingSeparators(path.slice(</span><span class="s4">0</span><span class="s1">, end), isPosixPathSeparator);</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Return the extension of the `path` with leading period.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { extname } from &quot;@std/path/windows/extname&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* assertEquals(extname(&quot;file.ts&quot;), &quot;.ts&quot;);</span>
 <span class="s2">* assertEquals(extname(new URL(&quot;file:///C:/foo/bar/baz.ext&quot;)), &quot;.ext&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">path The path to get the extension from.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The extension of the `path`.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">extname(path) {</span>
  <span class="s3">if </span><span class="s1">(path </span><span class="s3">instanceof </span><span class="s1">URL) {</span>
    <span class="s1">path = fromFileUrl(path);</span>
  <span class="s1">}</span>
  <span class="s1">assertPath(path);</span>
  <span class="s3">let </span><span class="s1">start = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">startDot = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">startPart = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">end = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">matchedSlash = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s2">// Track the state of characters (if any) we see before our first dot and</span>
  <span class="s2">// after any path separator we find</span>
  <span class="s3">let </span><span class="s1">preDotState = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">// Check for a drive letter prefix so as not to mistake the following</span>
  <span class="s2">// path separator as an extra separator at the end of the path that can be</span>
  <span class="s2">// disregarded</span>
  <span class="s3">if </span><span class="s1">(path.length &gt;= </span><span class="s4">2 </span><span class="s1">&amp;&amp; path.charCodeAt(</span><span class="s4">1</span><span class="s1">) === CHAR_COLON &amp;&amp; isWindowsDeviceRoot(path.charCodeAt(</span><span class="s4">0</span><span class="s1">))) {</span>
    <span class="s1">start = startPart = </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = path.length - </span><span class="s4">1</span><span class="s1">; i &gt;= start; --i){</span>
    <span class="s3">const </span><span class="s1">code = path.charCodeAt(i);</span>
    <span class="s3">if </span><span class="s1">(isPathSeparator(code)) {</span>
      <span class="s2">// If we reached a path separator that was not part of a set of path</span>
      <span class="s2">// separators at the end of the string, stop now</span>
      <span class="s3">if </span><span class="s1">(!matchedSlash) {</span>
        <span class="s1">startPart = i + </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">continue</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(end === -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">// We saw the first non-path separator, mark this as the end of our</span>
      <span class="s2">// extension</span>
      <span class="s1">matchedSlash = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">end = i + </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(code === CHAR_DOT) {</span>
      <span class="s2">// If this is our first dot, mark it as the start of our extension</span>
      <span class="s3">if </span><span class="s1">(startDot === -</span><span class="s4">1</span><span class="s1">) startDot = i;</span>
      <span class="s3">else if </span><span class="s1">(preDotState !== </span><span class="s4">1</span><span class="s1">) preDotState = </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(startDot !== -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">// We saw a non-dot and non-path separator before our dot, so we should</span>
      <span class="s2">// have a good chance at having a non-empty extension</span>
      <span class="s1">preDotState = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(startDot === -</span><span class="s4">1 </span><span class="s1">|| end === -</span><span class="s4">1 </span><span class="s1">|| </span><span class="s2">// We saw a non-dot character immediately before the dot</span>
  <span class="s1">preDotState === </span><span class="s4">0 </span><span class="s1">|| </span><span class="s2">// The (right-most) trimmed path component is exactly '..'</span>
  <span class="s1">preDotState === </span><span class="s4">1 </span><span class="s1">&amp;&amp; startDot === end - </span><span class="s4">1 </span><span class="s1">&amp;&amp; startDot === startPart + </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">path.slice(startDot, end);</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s3">function </span><span class="s1">_format(sep, pathObject) {</span>
  <span class="s3">const </span><span class="s1">dir = pathObject.dir || pathObject.root;</span>
  <span class="s3">const </span><span class="s1">base = pathObject.base || (pathObject.name ?? </span><span class="s0">&quot;&quot;</span><span class="s1">) + (pathObject.ext ?? </span><span class="s0">&quot;&quot;</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(!dir) </span><span class="s3">return </span><span class="s1">base;</span>
  <span class="s3">if </span><span class="s1">(base === sep) </span><span class="s3">return </span><span class="s1">dir;</span>
  <span class="s3">if </span><span class="s1">(dir === pathObject.root) </span><span class="s3">return </span><span class="s1">dir + base;</span>
  <span class="s3">return </span><span class="s1">dir + sep + base;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">assertArg$1(pathObject) {</span>
  <span class="s3">if </span><span class="s1">(pathObject === </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">pathObject !== </span><span class="s0">&quot;object&quot;</span><span class="s1">) {</span>
    <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s0">`The &quot;pathObject&quot; argument must be of type Object, received type &quot;</span><span class="s1">${</span><span class="s3">typeof </span><span class="s1">pathObject}</span><span class="s0">&quot;`</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Generate a path from `ParsedPath` object.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { format } from &quot;@std/path/windows/format&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* const path = format({</span>
 <span class="s2">*   root: &quot;C:\\&quot;,</span>
 <span class="s2">*   dir: &quot;C:\\path\\dir&quot;,</span>
 <span class="s2">*   base: &quot;file.txt&quot;,</span>
 <span class="s2">*   ext: &quot;.txt&quot;,</span>
 <span class="s2">*   name: &quot;file&quot;</span>
 <span class="s2">* });</span>
 <span class="s2">* assertEquals(path, &quot;C:\\path\\dir\\file.txt&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">pathObject The path object to format.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The formatted path.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">format(pathObject) {</span>
  <span class="s1">assertArg$1(pathObject);</span>
  <span class="s3">return </span><span class="s1">_format(</span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">&quot;</span><span class="s1">, pathObject);</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Verifies whether provided path is absolute.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { isAbsolute } from &quot;@std/path/windows/is-absolute&quot;;</span>
 <span class="s2">* import { assert, assertFalse } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* assert(isAbsolute(&quot;C:\\foo\\bar&quot;));</span>
 <span class="s2">* assertFalse(isAbsolute(&quot;..\\baz&quot;));</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">path The path to verify.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">`true` if the path is absolute, `false` otherwise.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">isAbsolute(path) {</span>
  <span class="s1">assertPath(path);</span>
  <span class="s3">const </span><span class="s1">len = path.length;</span>
  <span class="s3">if </span><span class="s1">(len === </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return false</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s1">code = path.charCodeAt(</span><span class="s4">0</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(isPathSeparator(code)) {</span>
    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isWindowsDeviceRoot(code)) {</span>
    <span class="s2">// Possible device root</span>
    <span class="s3">if </span><span class="s1">(len &gt; </span><span class="s4">2 </span><span class="s1">&amp;&amp; path.charCodeAt(</span><span class="s4">1</span><span class="s1">) === CHAR_COLON) {</span>
      <span class="s3">if </span><span class="s1">(isPathSeparator(path.charCodeAt(</span><span class="s4">2</span><span class="s1">))) </span><span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s3">function </span><span class="s1">assertArg(path) {</span>
  <span class="s1">assertPath(path);</span>
  <span class="s3">if </span><span class="s1">(path.length === </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return </span><span class="s0">&quot;.&quot;</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// Copyright the Browserify authors. MIT License.</span>
<span class="s2">// Ported from https://github.com/browserify/path-browserify/</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">// Resolves . and .. elements in a path with directory names</span>
<span class="s3">function </span><span class="s1">normalizeString(path, allowAboveRoot, separator, isPathSeparator) {</span>
  <span class="s3">let </span><span class="s1">res = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">lastSegmentLength = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">lastSlash = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">dots = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">code;</span>
  <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt;= path.length; ++i){</span>
    <span class="s3">if </span><span class="s1">(i &lt; path.length) code = path.charCodeAt(i);</span>
    <span class="s3">else if </span><span class="s1">(isPathSeparator(code)) </span><span class="s3">break</span><span class="s1">;</span>
    <span class="s3">else </span><span class="s1">code = CHAR_FORWARD_SLASH;</span>
    <span class="s3">if </span><span class="s1">(isPathSeparator(code)) {</span>
      <span class="s3">if </span><span class="s1">(lastSlash === i - </span><span class="s4">1 </span><span class="s1">|| dots === </span><span class="s4">1</span><span class="s1">) ; </span><span class="s3">else if </span><span class="s1">(lastSlash !== i - </span><span class="s4">1 </span><span class="s1">&amp;&amp; dots === </span><span class="s4">2</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(res.length &lt; </span><span class="s4">2 </span><span class="s1">|| lastSegmentLength !== </span><span class="s4">2 </span><span class="s1">|| res.charCodeAt(res.length - </span><span class="s4">1</span><span class="s1">) !== CHAR_DOT || res.charCodeAt(res.length - </span><span class="s4">2</span><span class="s1">) !== CHAR_DOT) {</span>
          <span class="s3">if </span><span class="s1">(res.length &gt; </span><span class="s4">2</span><span class="s1">) {</span>
            <span class="s3">const </span><span class="s1">lastSlashIndex = res.lastIndexOf(separator);</span>
            <span class="s3">if </span><span class="s1">(lastSlashIndex === -</span><span class="s4">1</span><span class="s1">) {</span>
              <span class="s1">res = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
              <span class="s1">lastSegmentLength = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s1">res = res.slice(</span><span class="s4">0</span><span class="s1">, lastSlashIndex);</span>
              <span class="s1">lastSegmentLength = res.length - </span><span class="s4">1 </span><span class="s1">- res.lastIndexOf(separator);</span>
            <span class="s1">}</span>
            <span class="s1">lastSlash = i;</span>
            <span class="s1">dots = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s3">continue</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s3">else if </span><span class="s1">(res.length === </span><span class="s4">2 </span><span class="s1">|| res.length === </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s1">res = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
            <span class="s1">lastSegmentLength = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">lastSlash = i;</span>
            <span class="s1">dots = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s3">continue</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(allowAboveRoot) {</span>
          <span class="s3">if </span><span class="s1">(res.length &gt; </span><span class="s4">0</span><span class="s1">) res += </span><span class="s0">`</span><span class="s1">${separator}</span><span class="s0">..`</span><span class="s1">;</span>
          <span class="s3">else </span><span class="s1">res = </span><span class="s0">&quot;..&quot;</span><span class="s1">;</span>
          <span class="s1">lastSegmentLength = </span><span class="s4">2</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(res.length &gt; </span><span class="s4">0</span><span class="s1">) res += separator + path.slice(lastSlash + </span><span class="s4">1</span><span class="s1">, i);</span>
        <span class="s3">else </span><span class="s1">res = path.slice(lastSlash + </span><span class="s4">1</span><span class="s1">, i);</span>
        <span class="s1">lastSegmentLength = i - lastSlash - </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">lastSlash = i;</span>
      <span class="s1">dots = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(code === CHAR_DOT &amp;&amp; dots !== -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">++dots;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">dots = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">res;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Normalize the `path`, resolving `'..'` and `'.'` segments.</span>
 <span class="s2">* Note that resolving these segments does not necessarily mean that all will be eliminated.</span>
 <span class="s2">* A `'..'` at the top-level will be preserved, and an empty path is canonically `'.'`.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { normalize } from &quot;@std/path/windows/normalize&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* assertEquals(normalize(&quot;C:\\foo\\..\\bar&quot;), &quot;C:\\bar&quot;);</span>
 <span class="s2">* assertEquals(normalize(new URL(&quot;file:///C:/foo/../bar&quot;)), &quot;C:\\bar&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">path The path to normalize</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The normalized path</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">normalize(path) {</span>
  <span class="s3">if </span><span class="s1">(path </span><span class="s3">instanceof </span><span class="s1">URL) {</span>
    <span class="s1">path = fromFileUrl(path);</span>
  <span class="s1">}</span>
  <span class="s1">assertArg(path);</span>
  <span class="s3">const </span><span class="s1">len = path.length;</span>
  <span class="s3">let </span><span class="s1">rootEnd = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">device;</span>
  <span class="s3">let </span><span class="s1">isAbsolute = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s1">code = path.charCodeAt(</span><span class="s4">0</span><span class="s1">);</span>
  <span class="s2">// Try to match a root</span>
  <span class="s3">if </span><span class="s1">(len &gt; </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(isPathSeparator(code)) {</span>
      <span class="s2">// Possible UNC root</span>
      <span class="s2">// If we started with a separator, we know we at least have an absolute</span>
      <span class="s2">// path of some kind (UNC or otherwise)</span>
      <span class="s1">isAbsolute = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s1">(isPathSeparator(path.charCodeAt(</span><span class="s4">1</span><span class="s1">))) {</span>
        <span class="s2">// Matched double path separator at beginning</span>
        <span class="s3">let </span><span class="s1">j = </span><span class="s4">2</span><span class="s1">;</span>
        <span class="s3">let </span><span class="s1">last = j;</span>
        <span class="s2">// Match 1 or more non-path separators</span>
        <span class="s3">for</span><span class="s1">(; j &lt; len; ++j){</span>
          <span class="s3">if </span><span class="s1">(isPathSeparator(path.charCodeAt(j))) </span><span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(j &lt; len &amp;&amp; j !== last) {</span>
          <span class="s3">const </span><span class="s1">firstPart = path.slice(last, j);</span>
          <span class="s2">// Matched!</span>
          <span class="s1">last = j;</span>
          <span class="s2">// Match 1 or more path separators</span>
          <span class="s3">for</span><span class="s1">(; j &lt; len; ++j){</span>
            <span class="s3">if </span><span class="s1">(!isPathSeparator(path.charCodeAt(j))) </span><span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s3">if </span><span class="s1">(j &lt; len &amp;&amp; j !== last) {</span>
            <span class="s2">// Matched!</span>
            <span class="s1">last = j;</span>
            <span class="s2">// Match 1 or more non-path separators</span>
            <span class="s3">for</span><span class="s1">(; j &lt; len; ++j){</span>
              <span class="s3">if </span><span class="s1">(isPathSeparator(path.charCodeAt(j))) </span><span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(j === len) {</span>
              <span class="s2">// We matched a UNC root only</span>
              <span class="s2">// Return the normalized version of the UNC root since there</span>
              <span class="s2">// is nothing left to process</span>
              <span class="s3">return </span><span class="s0">`</span><span class="s7">\\\\</span><span class="s1">${firstPart}</span><span class="s7">\\</span><span class="s1">${path.slice(last)}</span><span class="s7">\\</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(j !== last) {</span>
              <span class="s2">// We matched a UNC root with leftovers</span>
              <span class="s1">device = </span><span class="s0">`</span><span class="s7">\\\\</span><span class="s1">${firstPart}</span><span class="s7">\\</span><span class="s1">${path.slice(last, j)}</span><span class="s0">`</span><span class="s1">;</span>
              <span class="s1">rootEnd = j;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">rootEnd = </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isWindowsDeviceRoot(code)) {</span>
      <span class="s2">// Possible device root</span>
      <span class="s3">if </span><span class="s1">(path.charCodeAt(</span><span class="s4">1</span><span class="s1">) === CHAR_COLON) {</span>
        <span class="s1">device = path.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">2</span><span class="s1">);</span>
        <span class="s1">rootEnd = </span><span class="s4">2</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(len &gt; </span><span class="s4">2</span><span class="s1">) {</span>
          <span class="s3">if </span><span class="s1">(isPathSeparator(path.charCodeAt(</span><span class="s4">2</span><span class="s1">))) {</span>
            <span class="s2">// Treat separator following drive name as an absolute path</span>
            <span class="s2">// indicator</span>
            <span class="s1">isAbsolute = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">rootEnd = </span><span class="s4">3</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isPathSeparator(code)) {</span>
    <span class="s2">// `path` contains just a path separator, exit early to avoid unnecessary</span>
    <span class="s2">// work</span>
    <span class="s3">return </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">&quot;</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">let </span><span class="s1">tail;</span>
  <span class="s3">if </span><span class="s1">(rootEnd &lt; len) {</span>
    <span class="s1">tail = normalizeString(path.slice(rootEnd), !isAbsolute, </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">&quot;</span><span class="s1">, isPathSeparator);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">tail = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(tail.length === </span><span class="s4">0 </span><span class="s1">&amp;&amp; !isAbsolute) tail = </span><span class="s0">&quot;.&quot;</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(tail.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; isPathSeparator(path.charCodeAt(len - </span><span class="s4">1</span><span class="s1">))) {</span>
    <span class="s1">tail += </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">&quot;</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(device === undefined) {</span>
    <span class="s3">if </span><span class="s1">(isAbsolute) {</span>
      <span class="s3">if </span><span class="s1">(tail.length &gt; </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return </span><span class="s0">`</span><span class="s7">\\</span><span class="s1">${tail}</span><span class="s0">`</span><span class="s1">;</span>
      <span class="s3">else return </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">tail;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isAbsolute) {</span>
    <span class="s3">if </span><span class="s1">(tail.length &gt; </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return </span><span class="s0">`</span><span class="s1">${device}</span><span class="s7">\\</span><span class="s1">${tail}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s3">else return </span><span class="s0">`</span><span class="s1">${device}</span><span class="s7">\\</span><span class="s0">`</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">device + tail;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Join all given a sequence of `paths`,then normalizes the resulting path.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { join } from &quot;@std/path/windows/join&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* assertEquals(join(&quot;C:\\foo&quot;, &quot;bar&quot;, &quot;baz\\..&quot;), &quot;C:\\foo\\bar&quot;);</span>
 <span class="s2">* assertEquals(join(new URL(&quot;file:///C:/foo&quot;), &quot;bar&quot;, &quot;baz\\..&quot;), &quot;C:\\foo\\bar&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">path The path to join. This can be string or file URL.</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">paths The paths to join.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The joined path.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">join(path, ...paths) {</span>
  <span class="s3">if </span><span class="s1">(path </span><span class="s3">instanceof </span><span class="s1">URL) {</span>
    <span class="s1">path = fromFileUrl(path);</span>
  <span class="s1">}</span>
  <span class="s1">paths = path ? [</span>
    <span class="s1">path,</span>
    <span class="s1">...paths</span>
  <span class="s1">] : paths;</span>
  <span class="s1">paths.forEach((path)=&gt;assertPath(path));</span>
  <span class="s1">paths = paths.filter((path)=&gt;path.length &gt; </span><span class="s4">0</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(paths.length === </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return </span><span class="s0">&quot;.&quot;</span><span class="s1">;</span>
  <span class="s2">// Make sure that the joined path doesn't start with two slashes, because</span>
  <span class="s2">// normalize() will mistake it for an UNC path then.</span>
  <span class="s2">//</span>
  <span class="s2">// This step is skipped when it is very clear that the user actually</span>
  <span class="s2">// intended to point at an UNC path. This is assumed when the first</span>
  <span class="s2">// non-empty string arguments starts with exactly two slashes followed by</span>
  <span class="s2">// at least one more non-slash character.</span>
  <span class="s2">//</span>
  <span class="s2">// Note that for normalize() to treat a path as an UNC path it needs to</span>
  <span class="s2">// have at least 2 components, so we don't filter for that here.</span>
  <span class="s2">// This means that the user can use join to construct UNC paths from</span>
  <span class="s2">// a server name and a share name; for example:</span>
  <span class="s2">//   path.join('//server', 'share') -&gt; '\\\\server\\share\\'</span>
  <span class="s3">let </span><span class="s1">needsReplace = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">slashCount = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s1">firstPart = paths[</span><span class="s4">0</span><span class="s1">];</span>
  <span class="s3">if </span><span class="s1">(isPathSeparator(firstPart.charCodeAt(</span><span class="s4">0</span><span class="s1">))) {</span>
    <span class="s1">++slashCount;</span>
    <span class="s3">const </span><span class="s1">firstLen = firstPart.length;</span>
    <span class="s3">if </span><span class="s1">(firstLen &gt; </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(isPathSeparator(firstPart.charCodeAt(</span><span class="s4">1</span><span class="s1">))) {</span>
        <span class="s1">++slashCount;</span>
        <span class="s3">if </span><span class="s1">(firstLen &gt; </span><span class="s4">2</span><span class="s1">) {</span>
          <span class="s3">if </span><span class="s1">(isPathSeparator(firstPart.charCodeAt(</span><span class="s4">2</span><span class="s1">))) ++slashCount;</span>
          <span class="s3">else </span><span class="s1">{</span>
            <span class="s2">// We matched a UNC path in the first part</span>
            <span class="s1">needsReplace = </span><span class="s3">false</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">let </span><span class="s1">joined = paths.join(</span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">&quot;</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(needsReplace) {</span>
    <span class="s2">// Find any more consecutive slashes we need to replace</span>
    <span class="s3">for</span><span class="s1">(; slashCount &lt; joined.length; ++slashCount){</span>
      <span class="s3">if </span><span class="s1">(!isPathSeparator(joined.charCodeAt(slashCount))) </span><span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">// Replace the slashes if needed</span>
    <span class="s3">if </span><span class="s1">(slashCount &gt;= </span><span class="s4">2</span><span class="s1">) joined = </span><span class="s0">`</span><span class="s7">\\</span><span class="s1">${joined.slice(slashCount)}</span><span class="s0">`</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">normalize(joined);</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Return a `ParsedPath` object of the `path`.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { parse } from &quot;@std/path/windows/parse&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* const parsed = parse(&quot;C:\\foo\\bar\\baz.ext&quot;);</span>
 <span class="s2">* assertEquals(parsed, {</span>
 <span class="s2">*   root: &quot;C:\\&quot;,</span>
 <span class="s2">*   dir: &quot;C:\\foo\\bar&quot;,</span>
 <span class="s2">*   base: &quot;baz.ext&quot;,</span>
 <span class="s2">*   ext: &quot;.ext&quot;,</span>
 <span class="s2">*   name: &quot;baz&quot;,</span>
 <span class="s2">* });</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">path The path to parse.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The `ParsedPath` object.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">parse(path) {</span>
  <span class="s1">assertPath(path);</span>
  <span class="s3">const </span><span class="s1">ret = {</span>
    <span class="s1">root: </span><span class="s0">&quot;&quot;</span><span class="s1">,</span>
    <span class="s1">dir: </span><span class="s0">&quot;&quot;</span><span class="s1">,</span>
    <span class="s1">base: </span><span class="s0">&quot;&quot;</span><span class="s1">,</span>
    <span class="s1">ext: </span><span class="s0">&quot;&quot;</span><span class="s1">,</span>
    <span class="s1">name: </span><span class="s0">&quot;&quot;</span>
  <span class="s1">};</span>
  <span class="s3">const </span><span class="s1">len = path.length;</span>
  <span class="s3">if </span><span class="s1">(len === </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return </span><span class="s1">ret;</span>
  <span class="s3">let </span><span class="s1">rootEnd = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">code = path.charCodeAt(</span><span class="s4">0</span><span class="s1">);</span>
  <span class="s2">// Try to match a root</span>
  <span class="s3">if </span><span class="s1">(len &gt; </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(isPathSeparator(code)) {</span>
      <span class="s2">// Possible UNC root</span>
      <span class="s1">rootEnd = </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s1">(isPathSeparator(path.charCodeAt(</span><span class="s4">1</span><span class="s1">))) {</span>
        <span class="s2">// Matched double path separator at beginning</span>
        <span class="s3">let </span><span class="s1">j = </span><span class="s4">2</span><span class="s1">;</span>
        <span class="s3">let </span><span class="s1">last = j;</span>
        <span class="s2">// Match 1 or more non-path separators</span>
        <span class="s3">for</span><span class="s1">(; j &lt; len; ++j){</span>
          <span class="s3">if </span><span class="s1">(isPathSeparator(path.charCodeAt(j))) </span><span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(j &lt; len &amp;&amp; j !== last) {</span>
          <span class="s2">// Matched!</span>
          <span class="s1">last = j;</span>
          <span class="s2">// Match 1 or more path separators</span>
          <span class="s3">for</span><span class="s1">(; j &lt; len; ++j){</span>
            <span class="s3">if </span><span class="s1">(!isPathSeparator(path.charCodeAt(j))) </span><span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s3">if </span><span class="s1">(j &lt; len &amp;&amp; j !== last) {</span>
            <span class="s2">// Matched!</span>
            <span class="s1">last = j;</span>
            <span class="s2">// Match 1 or more non-path separators</span>
            <span class="s3">for</span><span class="s1">(; j &lt; len; ++j){</span>
              <span class="s3">if </span><span class="s1">(isPathSeparator(path.charCodeAt(j))) </span><span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(j === len) {</span>
              <span class="s2">// We matched a UNC root only</span>
              <span class="s1">rootEnd = j;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(j !== last) {</span>
              <span class="s2">// We matched a UNC root with leftovers</span>
              <span class="s1">rootEnd = j + </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isWindowsDeviceRoot(code)) {</span>
      <span class="s2">// Possible device root</span>
      <span class="s3">if </span><span class="s1">(path.charCodeAt(</span><span class="s4">1</span><span class="s1">) === CHAR_COLON) {</span>
        <span class="s1">rootEnd = </span><span class="s4">2</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(len &gt; </span><span class="s4">2</span><span class="s1">) {</span>
          <span class="s3">if </span><span class="s1">(isPathSeparator(path.charCodeAt(</span><span class="s4">2</span><span class="s1">))) {</span>
            <span class="s3">if </span><span class="s1">(len === </span><span class="s4">3</span><span class="s1">) {</span>
              <span class="s2">// `path` contains just a drive root, exit early to avoid</span>
              <span class="s2">// unnecessary work</span>
              <span class="s1">ret.root = ret.dir = path;</span>
              <span class="s1">ret.base = </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">&quot;</span><span class="s1">;</span>
              <span class="s3">return </span><span class="s1">ret;</span>
            <span class="s1">}</span>
            <span class="s1">rootEnd = </span><span class="s4">3</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s2">// `path` contains just a relative drive root, exit early to avoid</span>
          <span class="s2">// unnecessary work</span>
          <span class="s1">ret.root = ret.dir = path;</span>
          <span class="s3">return </span><span class="s1">ret;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isPathSeparator(code)) {</span>
    <span class="s2">// `path` contains just a path separator, exit early to avoid</span>
    <span class="s2">// unnecessary work</span>
    <span class="s1">ret.root = ret.dir = path;</span>
    <span class="s1">ret.base = </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">&quot;</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">ret;</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(rootEnd &gt; </span><span class="s4">0</span><span class="s1">) ret.root = path.slice(</span><span class="s4">0</span><span class="s1">, rootEnd);</span>
  <span class="s3">let </span><span class="s1">startDot = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">startPart = rootEnd;</span>
  <span class="s3">let </span><span class="s1">end = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">matchedSlash = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">i = path.length - </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">// Track the state of characters (if any) we see before our first dot and</span>
  <span class="s2">// after any path separator we find</span>
  <span class="s3">let </span><span class="s1">preDotState = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">// Get non-dir info</span>
  <span class="s3">for</span><span class="s1">(; i &gt;= rootEnd; --i){</span>
    <span class="s1">code = path.charCodeAt(i);</span>
    <span class="s3">if </span><span class="s1">(isPathSeparator(code)) {</span>
      <span class="s2">// If we reached a path separator that was not part of a set of path</span>
      <span class="s2">// separators at the end of the string, stop now</span>
      <span class="s3">if </span><span class="s1">(!matchedSlash) {</span>
        <span class="s1">startPart = i + </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">continue</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(end === -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">// We saw the first non-path separator, mark this as the end of our</span>
      <span class="s2">// extension</span>
      <span class="s1">matchedSlash = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">end = i + </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(code === CHAR_DOT) {</span>
      <span class="s2">// If this is our first dot, mark it as the start of our extension</span>
      <span class="s3">if </span><span class="s1">(startDot === -</span><span class="s4">1</span><span class="s1">) startDot = i;</span>
      <span class="s3">else if </span><span class="s1">(preDotState !== </span><span class="s4">1</span><span class="s1">) preDotState = </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(startDot !== -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">// We saw a non-dot and non-path separator before our dot, so we should</span>
      <span class="s2">// have a good chance at having a non-empty extension</span>
      <span class="s1">preDotState = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(startDot === -</span><span class="s4">1 </span><span class="s1">|| end === -</span><span class="s4">1 </span><span class="s1">|| </span><span class="s2">// We saw a non-dot character immediately before the dot</span>
  <span class="s1">preDotState === </span><span class="s4">0 </span><span class="s1">|| </span><span class="s2">// The (right-most) trimmed path component is exactly '..'</span>
  <span class="s1">preDotState === </span><span class="s4">1 </span><span class="s1">&amp;&amp; startDot === end - </span><span class="s4">1 </span><span class="s1">&amp;&amp; startDot === startPart + </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(end !== -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">ret.base = ret.name = path.slice(startPart, end);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">ret.name = path.slice(startPart, startDot);</span>
    <span class="s1">ret.base = path.slice(startPart, end);</span>
    <span class="s1">ret.ext = path.slice(startDot, end);</span>
  <span class="s1">}</span>
  <span class="s2">// Fallback to '\' in case there is no basename</span>
  <span class="s1">ret.base = ret.base || </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">&quot;</span><span class="s1">;</span>
  <span class="s2">// If the directory is the root, use the entire root as the `dir` including</span>
  <span class="s2">// the trailing slash if any (`C:\abc` -&gt; `C:\`). Otherwise, strip out the</span>
  <span class="s2">// trailing slash (`C:\abc\def` -&gt; `C:\abc`).</span>
  <span class="s3">if </span><span class="s1">(startPart &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; startPart !== rootEnd) {</span>
    <span class="s1">ret.dir = path.slice(</span><span class="s4">0</span><span class="s1">, startPart - </span><span class="s4">1</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">ret.dir = ret.root;</span>
  <span class="s3">return </span><span class="s1">ret;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Resolves path segments into a `path`.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { resolve } from &quot;@std/path/windows/resolve&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* const resolved = resolve(&quot;C:\\foo\\bar&quot;, &quot;..\\baz&quot;);</span>
 <span class="s2">* assertEquals(resolved, &quot;C:\\foo\\baz&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">pathSegments The path segments to process to path</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The resolved path</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">resolve(...pathSegments) {</span>
  <span class="s3">let </span><span class="s1">resolvedDevice = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">resolvedTail = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">resolvedAbsolute = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = pathSegments.length - </span><span class="s4">1</span><span class="s1">; i &gt;= -</span><span class="s4">1</span><span class="s1">; i--){</span>
    <span class="s3">let </span><span class="s1">path;</span>
    <span class="s2">// deno-lint-ignore no-explicit-any</span>
    <span class="s3">const </span><span class="s1">{ Deno } = globalThis;</span>
    <span class="s3">if </span><span class="s1">(i &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">path = pathSegments[i];</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!resolvedDevice) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">Deno?.cwd !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Resolved a drive-letter-less path without a current working directory (CWD)&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s1">path = Deno.cwd();</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">Deno?.env?.get !== </span><span class="s0">&quot;function&quot; </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">Deno?.cwd !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Resolved a relative path without a current working directory (CWD)&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s1">path = Deno.cwd();</span>
      <span class="s2">// Verify that a cwd was found and that it actually points</span>
      <span class="s2">// to our drive. If not, default to the drive's root.</span>
      <span class="s3">if </span><span class="s1">(path === undefined || path.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">3</span><span class="s1">).toLowerCase() !== </span><span class="s0">`</span><span class="s1">${resolvedDevice.toLowerCase()}</span><span class="s7">\\</span><span class="s0">`</span><span class="s1">) {</span>
        <span class="s1">path = </span><span class="s0">`</span><span class="s1">${resolvedDevice}</span><span class="s7">\\</span><span class="s0">`</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">assertPath(path);</span>
    <span class="s3">const </span><span class="s1">len = path.length;</span>
    <span class="s2">// Skip empty entries</span>
    <span class="s3">if </span><span class="s1">(len === </span><span class="s4">0</span><span class="s1">) </span><span class="s3">continue</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s1">rootEnd = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s1">device = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s1">isAbsolute = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s1">code = path.charCodeAt(</span><span class="s4">0</span><span class="s1">);</span>
    <span class="s2">// Try to match a root</span>
    <span class="s3">if </span><span class="s1">(len &gt; </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(isPathSeparator(code)) {</span>
        <span class="s2">// Possible UNC root</span>
        <span class="s2">// If we started with a separator, we know we at least have an</span>
        <span class="s2">// absolute path of some kind (UNC or otherwise)</span>
        <span class="s1">isAbsolute = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(isPathSeparator(path.charCodeAt(</span><span class="s4">1</span><span class="s1">))) {</span>
          <span class="s2">// Matched double path separator at beginning</span>
          <span class="s3">let </span><span class="s1">j = </span><span class="s4">2</span><span class="s1">;</span>
          <span class="s3">let </span><span class="s1">last = j;</span>
          <span class="s2">// Match 1 or more non-path separators</span>
          <span class="s3">for</span><span class="s1">(; j &lt; len; ++j){</span>
            <span class="s3">if </span><span class="s1">(isPathSeparator(path.charCodeAt(j))) </span><span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s3">if </span><span class="s1">(j &lt; len &amp;&amp; j !== last) {</span>
            <span class="s3">const </span><span class="s1">firstPart = path.slice(last, j);</span>
            <span class="s2">// Matched!</span>
            <span class="s1">last = j;</span>
            <span class="s2">// Match 1 or more path separators</span>
            <span class="s3">for</span><span class="s1">(; j &lt; len; ++j){</span>
              <span class="s3">if </span><span class="s1">(!isPathSeparator(path.charCodeAt(j))) </span><span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(j &lt; len &amp;&amp; j !== last) {</span>
              <span class="s2">// Matched!</span>
              <span class="s1">last = j;</span>
              <span class="s2">// Match 1 or more non-path separators</span>
              <span class="s3">for</span><span class="s1">(; j &lt; len; ++j){</span>
                <span class="s3">if </span><span class="s1">(isPathSeparator(path.charCodeAt(j))) </span><span class="s3">break</span><span class="s1">;</span>
              <span class="s1">}</span>
              <span class="s3">if </span><span class="s1">(j === len) {</span>
                <span class="s2">// We matched a UNC root only</span>
                <span class="s1">device = </span><span class="s0">`</span><span class="s7">\\\\</span><span class="s1">${firstPart}</span><span class="s7">\\</span><span class="s1">${path.slice(last)}</span><span class="s0">`</span><span class="s1">;</span>
                <span class="s1">rootEnd = j;</span>
              <span class="s1">} </span><span class="s3">else if </span><span class="s1">(j !== last) {</span>
                <span class="s2">// We matched a UNC root with leftovers</span>
                <span class="s1">device = </span><span class="s0">`</span><span class="s7">\\\\</span><span class="s1">${firstPart}</span><span class="s7">\\</span><span class="s1">${path.slice(last, j)}</span><span class="s0">`</span><span class="s1">;</span>
                <span class="s1">rootEnd = j;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">rootEnd = </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isWindowsDeviceRoot(code)) {</span>
        <span class="s2">// Possible device root</span>
        <span class="s3">if </span><span class="s1">(path.charCodeAt(</span><span class="s4">1</span><span class="s1">) === CHAR_COLON) {</span>
          <span class="s1">device = path.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">2</span><span class="s1">);</span>
          <span class="s1">rootEnd = </span><span class="s4">2</span><span class="s1">;</span>
          <span class="s3">if </span><span class="s1">(len &gt; </span><span class="s4">2</span><span class="s1">) {</span>
            <span class="s3">if </span><span class="s1">(isPathSeparator(path.charCodeAt(</span><span class="s4">2</span><span class="s1">))) {</span>
              <span class="s2">// Treat separator following drive name as an absolute path</span>
              <span class="s2">// indicator</span>
              <span class="s1">isAbsolute = </span><span class="s3">true</span><span class="s1">;</span>
              <span class="s1">rootEnd = </span><span class="s4">3</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isPathSeparator(code)) {</span>
      <span class="s2">// `path` contains just a path separator</span>
      <span class="s1">rootEnd = </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">isAbsolute = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(device.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; resolvedDevice.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; device.toLowerCase() !== resolvedDevice.toLowerCase()) {</span>
      <span class="s3">continue</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(resolvedDevice.length === </span><span class="s4">0 </span><span class="s1">&amp;&amp; device.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">resolvedDevice = device;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(!resolvedAbsolute) {</span>
      <span class="s1">resolvedTail = </span><span class="s0">`</span><span class="s1">${path.slice(rootEnd)}</span><span class="s7">\\</span><span class="s1">${resolvedTail}</span><span class="s0">`</span><span class="s1">;</span>
      <span class="s1">resolvedAbsolute = isAbsolute;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(resolvedAbsolute &amp;&amp; resolvedDevice.length &gt; </span><span class="s4">0</span><span class="s1">) </span><span class="s3">break</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">// At this point the path should be resolved to a full absolute path,</span>
  <span class="s2">// but handle relative paths to be safe (might happen when Deno.cwd()</span>
  <span class="s2">// fails)</span>
  <span class="s2">// Normalize the tail path</span>
  <span class="s1">resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">&quot;</span><span class="s1">, isPathSeparator);</span>
  <span class="s3">return </span><span class="s1">resolvedDevice + (resolvedAbsolute ? </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">&quot; </span><span class="s1">: </span><span class="s0">&quot;&quot;</span><span class="s1">) + resolvedTail || </span><span class="s0">&quot;.&quot;</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s3">function </span><span class="s1">assertArgs(from, to) {</span>
  <span class="s1">assertPath(from);</span>
  <span class="s1">assertPath(to);</span>
  <span class="s3">if </span><span class="s1">(from === to) </span><span class="s3">return </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Return the relative path from `from` to `to` based on current working directory.</span>
 <span class="s2">*</span>
 <span class="s2">* An example in windws, for instance:</span>
 <span class="s2">*  from = 'C:\\orandea\\test\\aaa'</span>
 <span class="s2">*  to = 'C:\\orandea\\impl\\bbb'</span>
 <span class="s2">* The output of the function should be: '..\\..\\impl\\bbb'</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { relative } from &quot;@std/path/windows/relative&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* const relativePath = relative(&quot;C:\\foobar\\test\\aaa&quot;, &quot;C:\\foobar\\impl\\bbb&quot;);</span>
 <span class="s2">* assertEquals(relativePath, &quot;..\\..\\impl\\bbb&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">from The path from which to calculate the relative path</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">to The path to which to calculate the relative path</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The relative path from `from` to `to`</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">relative(from, to) {</span>
  <span class="s1">assertArgs(from, to);</span>
  <span class="s3">const </span><span class="s1">fromOrig = resolve(from);</span>
  <span class="s3">const </span><span class="s1">toOrig = resolve(to);</span>
  <span class="s3">if </span><span class="s1">(fromOrig === toOrig) </span><span class="s3">return </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
  <span class="s1">from = fromOrig.toLowerCase();</span>
  <span class="s1">to = toOrig.toLowerCase();</span>
  <span class="s3">if </span><span class="s1">(from === to) </span><span class="s3">return </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
  <span class="s2">// Trim any leading backslashes</span>
  <span class="s3">let </span><span class="s1">fromStart = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">fromEnd = from.length;</span>
  <span class="s3">for</span><span class="s1">(; fromStart &lt; fromEnd; ++fromStart){</span>
    <span class="s3">if </span><span class="s1">(from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH) </span><span class="s3">break</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">// Trim trailing backslashes (applicable to UNC paths only)</span>
  <span class="s3">for</span><span class="s1">(; fromEnd - </span><span class="s4">1 </span><span class="s1">&gt; fromStart; --fromEnd){</span>
    <span class="s3">if </span><span class="s1">(from.charCodeAt(fromEnd - </span><span class="s4">1</span><span class="s1">) !== CHAR_BACKWARD_SLASH) </span><span class="s3">break</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">const </span><span class="s1">fromLen = fromEnd - fromStart;</span>
  <span class="s2">// Trim any leading backslashes</span>
  <span class="s3">let </span><span class="s1">toStart = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">toEnd = to.length;</span>
  <span class="s3">for</span><span class="s1">(; toStart &lt; toEnd; ++toStart){</span>
    <span class="s3">if </span><span class="s1">(to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH) </span><span class="s3">break</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">// Trim trailing backslashes (applicable to UNC paths only)</span>
  <span class="s3">for</span><span class="s1">(; toEnd - </span><span class="s4">1 </span><span class="s1">&gt; toStart; --toEnd){</span>
    <span class="s3">if </span><span class="s1">(to.charCodeAt(toEnd - </span><span class="s4">1</span><span class="s1">) !== CHAR_BACKWARD_SLASH) </span><span class="s3">break</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">const </span><span class="s1">toLen = toEnd - toStart;</span>
  <span class="s2">// Compare paths to find the longest common path from root</span>
  <span class="s3">const </span><span class="s1">length = fromLen &lt; toLen ? fromLen : toLen;</span>
  <span class="s3">let </span><span class="s1">lastCommonSep = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">for</span><span class="s1">(; i &lt;= length; ++i){</span>
    <span class="s3">if </span><span class="s1">(i === length) {</span>
      <span class="s3">if </span><span class="s1">(toLen &gt; length) {</span>
        <span class="s3">if </span><span class="s1">(to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {</span>
          <span class="s2">// We get here if `from` is the exact base path for `to`.</span>
          <span class="s2">// For example: from='C:\\foo\\bar'; to='C:\\foo\\bar\\baz'</span>
          <span class="s3">return </span><span class="s1">toOrig.slice(toStart + i + </span><span class="s4">1</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(i === </span><span class="s4">2</span><span class="s1">) {</span>
          <span class="s2">// We get here if `from` is the device root.</span>
          <span class="s2">// For example: from='C:\\'; to='C:\\foo'</span>
          <span class="s3">return </span><span class="s1">toOrig.slice(toStart + i);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(fromLen &gt; length) {</span>
        <span class="s3">if </span><span class="s1">(from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {</span>
          <span class="s2">// We get here if `to` is the exact base path for `from`.</span>
          <span class="s2">// For example: from='C:\\foo\\bar'; to='C:\\foo'</span>
          <span class="s1">lastCommonSep = i;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(i === </span><span class="s4">2</span><span class="s1">) {</span>
          <span class="s2">// We get here if `to` is the device root.</span>
          <span class="s2">// For example: from='C:\\foo\\bar'; to='C:\\'</span>
          <span class="s1">lastCommonSep = </span><span class="s4">3</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">const </span><span class="s1">fromCode = from.charCodeAt(fromStart + i);</span>
    <span class="s3">const </span><span class="s1">toCode = to.charCodeAt(toStart + i);</span>
    <span class="s3">if </span><span class="s1">(fromCode !== toCode) </span><span class="s3">break</span><span class="s1">;</span>
    <span class="s3">else if </span><span class="s1">(fromCode === CHAR_BACKWARD_SLASH) lastCommonSep = i;</span>
  <span class="s1">}</span>
  <span class="s2">// We found a mismatch before the first common path separator was seen, so</span>
  <span class="s2">// return the original `to`.</span>
  <span class="s3">if </span><span class="s1">(i !== length &amp;&amp; lastCommonSep === -</span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">toOrig;</span>
  <span class="s1">}</span>
  <span class="s3">let </span><span class="s1">out = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(lastCommonSep === -</span><span class="s4">1</span><span class="s1">) lastCommonSep = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">// Generate the relative path based on the path difference between `to` and</span>
  <span class="s2">// `from`</span>
  <span class="s3">for</span><span class="s1">(i = fromStart + lastCommonSep + </span><span class="s4">1</span><span class="s1">; i &lt;= fromEnd; ++i){</span>
    <span class="s3">if </span><span class="s1">(i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {</span>
      <span class="s3">if </span><span class="s1">(out.length === </span><span class="s4">0</span><span class="s1">) out += </span><span class="s0">&quot;..&quot;</span><span class="s1">;</span>
      <span class="s3">else </span><span class="s1">out += </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">..&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">// Lastly, append the rest of the destination (`to`) path that comes after</span>
  <span class="s2">// the common path parts</span>
  <span class="s3">if </span><span class="s1">(out.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">out + toOrig.slice(toStart + lastCommonSep, toEnd);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">toStart += lastCommonSep;</span>
    <span class="s3">if </span><span class="s1">(toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) ++toStart;</span>
    <span class="s3">return </span><span class="s1">toOrig.slice(toStart, toEnd);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s3">const </span><span class="s1">WHITESPACE_ENCODINGS = {</span>
  <span class="s0">&quot;</span><span class="s7">\u0009</span><span class="s0">&quot;</span><span class="s1">: </span><span class="s0">&quot;%09&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;</span><span class="s7">\u000A</span><span class="s0">&quot;</span><span class="s1">: </span><span class="s0">&quot;%0A&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;</span><span class="s7">\u000B</span><span class="s0">&quot;</span><span class="s1">: </span><span class="s0">&quot;%0B&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;</span><span class="s7">\u000C</span><span class="s0">&quot;</span><span class="s1">: </span><span class="s0">&quot;%0C&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;</span><span class="s7">\u000D</span><span class="s0">&quot;</span><span class="s1">: </span><span class="s0">&quot;%0D&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;</span><span class="s7">\u0020</span><span class="s0">&quot;</span><span class="s1">: </span><span class="s0">&quot;%20&quot;</span>
<span class="s1">};</span>
<span class="s3">function </span><span class="s1">encodeWhitespace(string) {</span>
  <span class="s3">return </span><span class="s1">string.replaceAll(</span><span class="s6">/[\s]/g</span><span class="s1">, (c)=&gt;{</span>
    <span class="s3">return </span><span class="s1">WHITESPACE_ENCODINGS[c] ?? c;</span>
  <span class="s1">});</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Converts a path string to a file URL.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { toFileUrl } from &quot;@std/path/windows/to-file-url&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* assertEquals(toFileUrl(&quot;\\home\\foo&quot;), new URL(&quot;file:///home/foo&quot;));</span>
 <span class="s2">* assertEquals(toFileUrl(&quot;C:\\Users\\foo&quot;), new URL(&quot;file:///C:/Users/foo&quot;));</span>
 <span class="s2">* assertEquals(toFileUrl(&quot;\\\\127.0.0.1\\home\\foo&quot;), new URL(&quot;file://127.0.0.1/home/foo&quot;));</span>
 <span class="s2">* ```</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">path The path to convert.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The file URL.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">toFileUrl(path) {</span>
  <span class="s3">if </span><span class="s1">(!isAbsolute(path)) {</span>
    <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s0">`Path must be absolute: received &quot;</span><span class="s1">${path}</span><span class="s0">&quot;`</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">const </span><span class="s1">[, hostname, pathname] = path.match(</span><span class="s6">/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/</span><span class="s1">);</span>
  <span class="s3">const </span><span class="s1">url = </span><span class="s3">new </span><span class="s1">URL(</span><span class="s0">&quot;file:///&quot;</span><span class="s1">);</span>
  <span class="s1">url.pathname = encodeWhitespace(pathname.replace(</span><span class="s6">/%/g</span><span class="s1">, </span><span class="s0">&quot;%25&quot;</span><span class="s1">));</span>
  <span class="s3">if </span><span class="s1">(hostname !== undefined &amp;&amp; hostname !== </span><span class="s0">&quot;localhost&quot;</span><span class="s1">) {</span>
    <span class="s1">url.hostname = hostname;</span>
    <span class="s3">if </span><span class="s1">(!url.hostname) {</span>
      <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s0">`Invalid hostname: &quot;</span><span class="s1">${url.hostname}</span><span class="s0">&quot;`</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">url;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Resolves path to a namespace path</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { toNamespacedPath } from &quot;@std/path/windows/to-namespaced-path&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* const namespaced = toNamespacedPath(&quot;C:\\foo\\bar&quot;);</span>
 <span class="s2">* assertEquals(namespaced, &quot;\\\\?\\C:\\foo\\bar&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">path The path to resolve to namespaced path</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The resolved namespaced path</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">toNamespacedPath(path) {</span>
  <span class="s2">// Note: this will *probably* throw somewhere.</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">path !== </span><span class="s0">&quot;string&quot;</span><span class="s1">) </span><span class="s3">return </span><span class="s1">path;</span>
  <span class="s3">if </span><span class="s1">(path.length === </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s1">resolvedPath = resolve(path);</span>
  <span class="s3">if </span><span class="s1">(resolvedPath.length &gt;= </span><span class="s4">3</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(resolvedPath.charCodeAt(</span><span class="s4">0</span><span class="s1">) === CHAR_BACKWARD_SLASH) {</span>
      <span class="s2">// Possible UNC root</span>
      <span class="s3">if </span><span class="s1">(resolvedPath.charCodeAt(</span><span class="s4">1</span><span class="s1">) === CHAR_BACKWARD_SLASH) {</span>
        <span class="s3">const </span><span class="s1">code = resolvedPath.charCodeAt(</span><span class="s4">2</span><span class="s1">);</span>
        <span class="s3">if </span><span class="s1">(code !== CHAR_QUESTION_MARK &amp;&amp; code !== CHAR_DOT) {</span>
          <span class="s2">// Matched non-long UNC root, convert the path to a long UNC path</span>
          <span class="s3">return </span><span class="s0">`</span><span class="s7">\\\\</span><span class="s0">?</span><span class="s7">\\</span><span class="s0">UNC</span><span class="s7">\\</span><span class="s1">${resolvedPath.slice(</span><span class="s4">2</span><span class="s1">)}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isWindowsDeviceRoot(resolvedPath.charCodeAt(</span><span class="s4">0</span><span class="s1">))) {</span>
      <span class="s2">// Possible device root</span>
      <span class="s3">if </span><span class="s1">(resolvedPath.charCodeAt(</span><span class="s4">1</span><span class="s1">) === CHAR_COLON &amp;&amp; resolvedPath.charCodeAt(</span><span class="s4">2</span><span class="s1">) === CHAR_BACKWARD_SLASH) {</span>
        <span class="s2">// Matched device root, convert the path to a long UNC path</span>
        <span class="s3">return </span><span class="s0">`</span><span class="s7">\\\\</span><span class="s0">?</span><span class="s7">\\</span><span class="s1">${resolvedPath}</span><span class="s0">`</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">path;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s3">function </span><span class="s1">common$1(paths, sep) {</span>
  <span class="s3">const </span><span class="s1">[first = </span><span class="s0">&quot;&quot;</span><span class="s1">, ...remaining] = paths;</span>
  <span class="s3">const </span><span class="s1">parts = first.split(sep);</span>
  <span class="s3">let </span><span class="s1">endOfPrefix = parts.length;</span>
  <span class="s3">let </span><span class="s1">append = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">path of remaining){</span>
    <span class="s3">const </span><span class="s1">compare = path.split(sep);</span>
    <span class="s3">if </span><span class="s1">(compare.length &lt;= endOfPrefix) {</span>
      <span class="s1">endOfPrefix = compare.length;</span>
      <span class="s1">append = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; endOfPrefix; i++){</span>
      <span class="s3">if </span><span class="s1">(compare[i] !== parts[i]) {</span>
        <span class="s1">endOfPrefix = i;</span>
        <span class="s1">append = i === </span><span class="s4">0 </span><span class="s1">? </span><span class="s0">&quot;&quot; </span><span class="s1">: sep;</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">parts.slice(</span><span class="s4">0</span><span class="s1">, endOfPrefix).join(sep) + append;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Determines the common path from a set of paths for Windows systems.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { common } from &quot;@std/path/windows/common&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* const path = common([</span>
 <span class="s2">*   &quot;C:\\foo\\bar&quot;,</span>
 <span class="s2">*   &quot;C:\\foo\\baz&quot;,</span>
 <span class="s2">* ]);</span>
 <span class="s2">* assertEquals(path, &quot;C:\\foo\\&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">paths The paths to compare.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The common path.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">common(paths) {</span>
  <span class="s3">return </span><span class="s1">common$1(paths, SEPARATOR);</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Options for {</span><span class="s5">@linkcode </span><span class="s2">globToRegExp}, {</span><span class="s5">@linkcode </span><span class="s2">joinGlobs},</span>
 <span class="s2">* {</span><span class="s5">@linkcode </span><span class="s2">normalizeGlob} and {</span><span class="s5">@linkcode </span><span class="s2">expandGlob}.</span>
 <span class="s2">*/ </span><span class="s3">const </span><span class="s1">REG_EXP_ESCAPE_CHARS = [</span>
  <span class="s0">&quot;!&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;$&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;(&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;)&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;*&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;+&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;.&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;=&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;?&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;[&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;^&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;{&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;|&quot;</span>
<span class="s1">];</span>
<span class="s3">const </span><span class="s1">RANGE_ESCAPE_CHARS = [</span>
  <span class="s0">&quot;-&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;]&quot;</span>
<span class="s1">];</span>
<span class="s3">function </span><span class="s1">_globToRegExp(c, glob, { extended = </span><span class="s3">true</span><span class="s1">, globstar: globstarOption = </span><span class="s3">true</span><span class="s1">, </span><span class="s2">// os = osType,</span>
<span class="s1">caseInsensitive = </span><span class="s3">false </span><span class="s1">} = {}) {</span>
  <span class="s3">if </span><span class="s1">(glob === </span><span class="s0">&quot;&quot;</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s6">/(?!)/</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">// Remove trailing separators.</span>
  <span class="s3">let </span><span class="s1">newLength = glob.length;</span>
  <span class="s3">for</span><span class="s1">(; newLength &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; c.seps.includes(glob[newLength - </span><span class="s4">1</span><span class="s1">]); newLength--);</span>
  <span class="s1">glob = glob.slice(</span><span class="s4">0</span><span class="s1">, newLength);</span>
  <span class="s3">let </span><span class="s1">regExpString = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
  <span class="s2">// Terminates correctly. Trust that `j` is incremented every iteration.</span>
  <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">j = </span><span class="s4">0</span><span class="s1">; j &lt; glob.length;){</span>
    <span class="s3">let </span><span class="s1">segment = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s1">groupStack = [];</span>
    <span class="s3">let </span><span class="s1">inRange = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s1">inEscape = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s1">endsWithSep = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s1">i = j;</span>
    <span class="s2">// Terminates with `i` at the non-inclusive end of the current segment.</span>
    <span class="s3">for</span><span class="s1">(; i &lt; glob.length &amp;&amp; !c.seps.includes(glob[i]); i++){</span>
      <span class="s3">if </span><span class="s1">(inEscape) {</span>
        <span class="s1">inEscape = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s3">const </span><span class="s1">escapeChars = inRange ? RANGE_ESCAPE_CHARS : REG_EXP_ESCAPE_CHARS;</span>
        <span class="s1">segment += escapeChars.includes(glob[i]) ? </span><span class="s0">`</span><span class="s7">\\</span><span class="s1">${glob[i]}</span><span class="s0">` </span><span class="s1">: glob[i];</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === c.escapePrefix) {</span>
        <span class="s1">inEscape = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === </span><span class="s0">&quot;[&quot;</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(!inRange) {</span>
          <span class="s1">inRange = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">segment += </span><span class="s0">&quot;[&quot;</span><span class="s1">;</span>
          <span class="s3">if </span><span class="s1">(glob[i + </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">&quot;!&quot;</span><span class="s1">) {</span>
            <span class="s1">i++;</span>
            <span class="s1">segment += </span><span class="s0">&quot;^&quot;</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s3">else if </span><span class="s1">(glob[i + </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">&quot;^&quot;</span><span class="s1">) {</span>
            <span class="s1">i++;</span>
            <span class="s1">segment += </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">^&quot;</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s3">continue</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(glob[i + </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">&quot;:&quot;</span><span class="s1">) {</span>
          <span class="s3">let </span><span class="s1">k = i + </span><span class="s4">1</span><span class="s1">;</span>
          <span class="s3">let </span><span class="s1">value = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
          <span class="s3">while</span><span class="s1">(glob[k + </span><span class="s4">1</span><span class="s1">] !== undefined &amp;&amp; glob[k + </span><span class="s4">1</span><span class="s1">] !== </span><span class="s0">&quot;:&quot;</span><span class="s1">){</span>
            <span class="s1">value += glob[k + </span><span class="s4">1</span><span class="s1">];</span>
            <span class="s1">k++;</span>
          <span class="s1">}</span>
          <span class="s3">if </span><span class="s1">(glob[k + </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">&quot;:&quot; </span><span class="s1">&amp;&amp; glob[k + </span><span class="s4">2</span><span class="s1">] === </span><span class="s0">&quot;]&quot;</span><span class="s1">) {</span>
            <span class="s1">i = k + </span><span class="s4">2</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(value === </span><span class="s0">&quot;alnum&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">dA-Za-z&quot;</span><span class="s1">;</span>
            <span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;alpha&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;A-Za-z&quot;</span><span class="s1">;</span>
            <span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;ascii&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;</span><span class="s7">\x00</span><span class="s0">-</span><span class="s7">\x7F</span><span class="s0">&quot;</span><span class="s1">;</span>
            <span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;blank&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;</span><span class="s7">\t </span><span class="s0">&quot;</span><span class="s1">;</span>
            <span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;cntrl&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;</span><span class="s7">\x00</span><span class="s0">-</span><span class="s7">\x1F\x7F</span><span class="s0">&quot;</span><span class="s1">;</span>
            <span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;digit&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">d&quot;</span><span class="s1">;</span>
            <span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;graph&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;</span><span class="s7">\x21</span><span class="s0">-</span><span class="s7">\x7E</span><span class="s0">&quot;</span><span class="s1">;</span>
            <span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;lower&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;a-z&quot;</span><span class="s1">;</span>
            <span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;print&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;</span><span class="s7">\x20</span><span class="s0">-</span><span class="s7">\x7E</span><span class="s0">&quot;</span><span class="s1">;</span>
            <span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;punct&quot;</span><span class="s1">) {</span>
              <span class="s1">segment += </span><span class="s0">&quot;!</span><span class="s7">\&quot;</span><span class="s0">#$%&amp;'()*+,</span><span class="s7">\\</span><span class="s0">-./:;&lt;=&gt;?@[</span><span class="s7">\\\\\\</span><span class="s0">]^_{|}~&quot;</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;space&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">s</span><span class="s7">\v</span><span class="s0">&quot;</span><span class="s1">;</span>
            <span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;upper&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;A-Z&quot;</span><span class="s1">;</span>
            <span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;word&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">w&quot;</span><span class="s1">;</span>
            <span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;xdigit&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">dA-Fa-f&quot;</span><span class="s1">;</span>
            <span class="s3">continue</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === </span><span class="s0">&quot;]&quot; </span><span class="s1">&amp;&amp; inRange) {</span>
        <span class="s1">inRange = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">segment += </span><span class="s0">&quot;]&quot;</span><span class="s1">;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(inRange) {</span>
        <span class="s1">segment += glob[i];</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === </span><span class="s0">&quot;)&quot; </span><span class="s1">&amp;&amp; groupStack.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; groupStack[groupStack.length - </span><span class="s4">1</span><span class="s1">] !== </span><span class="s0">&quot;BRACE&quot;</span><span class="s1">) {</span>
        <span class="s1">segment += </span><span class="s0">&quot;)&quot;</span><span class="s1">;</span>
        <span class="s3">const </span><span class="s1">type = groupStack.pop();</span>
        <span class="s3">if </span><span class="s1">(type === </span><span class="s0">&quot;!&quot;</span><span class="s1">) {</span>
          <span class="s1">segment += c.wildcard;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(type !== </span><span class="s0">&quot;@&quot;</span><span class="s1">) {</span>
          <span class="s1">segment += type;</span>
        <span class="s1">}</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === </span><span class="s0">&quot;|&quot; </span><span class="s1">&amp;&amp; groupStack.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; groupStack[groupStack.length - </span><span class="s4">1</span><span class="s1">] !== </span><span class="s0">&quot;BRACE&quot;</span><span class="s1">) {</span>
        <span class="s1">segment += </span><span class="s0">&quot;|&quot;</span><span class="s1">;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === </span><span class="s0">&quot;+&quot; </span><span class="s1">&amp;&amp; extended &amp;&amp; glob[i + </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">&quot;(&quot;</span><span class="s1">) {</span>
        <span class="s1">i++;</span>
        <span class="s1">groupStack.push(</span><span class="s0">&quot;+&quot;</span><span class="s1">);</span>
        <span class="s1">segment += </span><span class="s0">&quot;(?:&quot;</span><span class="s1">;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === </span><span class="s0">&quot;@&quot; </span><span class="s1">&amp;&amp; extended &amp;&amp; glob[i + </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">&quot;(&quot;</span><span class="s1">) {</span>
        <span class="s1">i++;</span>
        <span class="s1">groupStack.push(</span><span class="s0">&quot;@&quot;</span><span class="s1">);</span>
        <span class="s1">segment += </span><span class="s0">&quot;(?:&quot;</span><span class="s1">;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === </span><span class="s0">&quot;?&quot;</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(extended &amp;&amp; glob[i + </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">&quot;(&quot;</span><span class="s1">) {</span>
          <span class="s1">i++;</span>
          <span class="s1">groupStack.push(</span><span class="s0">&quot;?&quot;</span><span class="s1">);</span>
          <span class="s1">segment += </span><span class="s0">&quot;(?:&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">segment += </span><span class="s0">&quot;.&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === </span><span class="s0">&quot;!&quot; </span><span class="s1">&amp;&amp; extended &amp;&amp; glob[i + </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">&quot;(&quot;</span><span class="s1">) {</span>
        <span class="s1">i++;</span>
        <span class="s1">groupStack.push(</span><span class="s0">&quot;!&quot;</span><span class="s1">);</span>
        <span class="s1">segment += </span><span class="s0">&quot;(?!&quot;</span><span class="s1">;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === </span><span class="s0">&quot;{&quot;</span><span class="s1">) {</span>
        <span class="s1">groupStack.push(</span><span class="s0">&quot;BRACE&quot;</span><span class="s1">);</span>
        <span class="s1">segment += </span><span class="s0">&quot;(?:&quot;</span><span class="s1">;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === </span><span class="s0">&quot;}&quot; </span><span class="s1">&amp;&amp; groupStack[groupStack.length - </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">&quot;BRACE&quot;</span><span class="s1">) {</span>
        <span class="s1">groupStack.pop();</span>
        <span class="s1">segment += </span><span class="s0">&quot;)&quot;</span><span class="s1">;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === </span><span class="s0">&quot;,&quot; </span><span class="s1">&amp;&amp; groupStack[groupStack.length - </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">&quot;BRACE&quot;</span><span class="s1">) {</span>
        <span class="s1">segment += </span><span class="s0">&quot;|&quot;</span><span class="s1">;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === </span><span class="s0">&quot;*&quot;</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(extended &amp;&amp; glob[i + </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">&quot;(&quot;</span><span class="s1">) {</span>
          <span class="s1">i++;</span>
          <span class="s1">groupStack.push(</span><span class="s0">&quot;*&quot;</span><span class="s1">);</span>
          <span class="s1">segment += </span><span class="s0">&quot;(?:&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s3">const </span><span class="s1">prevChar = glob[i - </span><span class="s4">1</span><span class="s1">];</span>
          <span class="s3">let </span><span class="s1">numStars = </span><span class="s4">1</span><span class="s1">;</span>
          <span class="s3">while</span><span class="s1">(glob[i + </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">&quot;*&quot;</span><span class="s1">){</span>
            <span class="s1">i++;</span>
            <span class="s1">numStars++;</span>
          <span class="s1">}</span>
          <span class="s3">const </span><span class="s1">nextChar = glob[i + </span><span class="s4">1</span><span class="s1">];</span>
          <span class="s3">if </span><span class="s1">(globstarOption &amp;&amp; numStars === </span><span class="s4">2 </span><span class="s1">&amp;&amp; [</span>
            <span class="s1">...c.seps,</span>
            <span class="s1">undefined</span>
          <span class="s1">].includes(prevChar) &amp;&amp; [</span>
            <span class="s1">...c.seps,</span>
            <span class="s1">undefined</span>
          <span class="s1">].includes(nextChar)) {</span>
            <span class="s1">segment += c.globstar;</span>
            <span class="s1">endsWithSep = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">segment += c.wildcard;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">segment += REG_EXP_ESCAPE_CHARS.includes(glob[i]) ? </span><span class="s0">`</span><span class="s7">\\</span><span class="s1">${glob[i]}</span><span class="s0">` </span><span class="s1">: glob[i];</span>
    <span class="s1">}</span>
    <span class="s2">// Check for unclosed groups or a dangling backslash.</span>
    <span class="s3">if </span><span class="s1">(groupStack.length &gt; </span><span class="s4">0 </span><span class="s1">|| inRange || inEscape) {</span>
      <span class="s2">// Parse failure. Take all characters from this segment literally.</span>
      <span class="s1">segment = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">c of glob.slice(j, i)){</span>
        <span class="s1">segment += REG_EXP_ESCAPE_CHARS.includes(c) ? </span><span class="s0">`</span><span class="s7">\\</span><span class="s1">${c}</span><span class="s0">` </span><span class="s1">: c;</span>
        <span class="s1">endsWithSep = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">regExpString += segment;</span>
    <span class="s3">if </span><span class="s1">(!endsWithSep) {</span>
      <span class="s1">regExpString += i &lt; glob.length ? c.sep : c.sepMaybe;</span>
      <span class="s1">endsWithSep = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">// Terminates with `i` at the start of the next segment.</span>
    <span class="s3">while</span><span class="s1">(c.seps.includes(glob[i]))i++;</span>
    <span class="s1">j = i;</span>
  <span class="s1">}</span>
  <span class="s1">regExpString = </span><span class="s0">`^</span><span class="s1">${regExpString}</span><span class="s0">$`</span><span class="s1">;</span>
  <span class="s3">return new </span><span class="s1">RegExp(regExpString, caseInsensitive ? </span><span class="s0">&quot;i&quot; </span><span class="s1">: </span><span class="s0">&quot;&quot;</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s3">const </span><span class="s1">constants = {</span>
  <span class="s1">sep: </span><span class="s0">&quot;(?:</span><span class="s7">\\\\</span><span class="s0">|/)+&quot;</span><span class="s1">,</span>
  <span class="s1">sepMaybe: </span><span class="s0">&quot;(?:</span><span class="s7">\\\\</span><span class="s0">|/)*&quot;</span><span class="s1">,</span>
  <span class="s1">seps: [</span>
    <span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;/&quot;</span>
  <span class="s1">],</span>
  <span class="s1">globstar: </span><span class="s0">&quot;(?:[^</span><span class="s7">\\\\</span><span class="s0">/]*(?:</span><span class="s7">\\\\</span><span class="s0">|/|$)+)*&quot;</span><span class="s1">,</span>
  <span class="s1">wildcard: </span><span class="s0">&quot;[^</span><span class="s7">\\\\</span><span class="s0">/]*&quot;</span><span class="s1">,</span>
  <span class="s1">escapePrefix: </span><span class="s0">&quot;`&quot;</span>
<span class="s1">};</span>
<span class="s2">/** Convert a glob string to a regular expression.</span>
 <span class="s2">*</span>
 <span class="s2">* Tries to match bash glob expansion as closely as possible.</span>
 <span class="s2">*</span>
 <span class="s2">* Basic glob syntax:</span>
 <span class="s2">* - `*` - Matches everything without leaving the path segment.</span>
 <span class="s2">* - `?` - Matches any single character.</span>
 <span class="s2">* - `{foo,bar}` - Matches `foo` or `bar`.</span>
 <span class="s2">* - `[abcd]` - Matches `a`, `b`, `c` or `d`.</span>
 <span class="s2">* - `[a-d]` - Matches `a`, `b`, `c` or `d`.</span>
 <span class="s2">* - `[!abcd]` - Matches any single character besides `a`, `b`, `c` or `d`.</span>
 <span class="s2">* - `[[:&lt;class&gt;:]]` - Matches any character belonging to `&lt;class&gt;`.</span>
 <span class="s2">*     - `[[:alnum:]]` - Matches any digit or letter.</span>
 <span class="s2">*     - `[[:digit:]abc]` - Matches any digit, `a`, `b` or `c`.</span>
 <span class="s2">*     - See https://facelessuser.github.io/wcmatch/glob/#posix-character-classes</span>
 <span class="s2">*       for a complete list of supported character classes.</span>
 <span class="s2">* - `\` - Escapes the next character for an `os` other than `&quot;windows&quot;`.</span>
 <span class="s2">* - \` - Escapes the next character for `os` set to `&quot;windows&quot;`.</span>
 <span class="s2">* - `/` - Path separator.</span>
 <span class="s2">* - `\` - Additional path separator only for `os` set to `&quot;windows&quot;`.</span>
 <span class="s2">*</span>
 <span class="s2">* Extended syntax:</span>
 <span class="s2">* - Requires `{ extended: true }`.</span>
 <span class="s2">* - `?(foo|bar)` - Matches 0 or 1 instance of `{foo,bar}`.</span>
 <span class="s2">* - `@(foo|bar)` - Matches 1 instance of `{foo,bar}`. They behave the same.</span>
 <span class="s2">* - `*(foo|bar)` - Matches _n_ instances of `{foo,bar}`.</span>
 <span class="s2">* - `+(foo|bar)` - Matches _n &gt; 0_ instances of `{foo,bar}`.</span>
 <span class="s2">* - `!(foo|bar)` - Matches anything other than `{foo,bar}`.</span>
 <span class="s2">* - See https://www.linuxjournal.com/content/bash-extended-globbing.</span>
 <span class="s2">*</span>
 <span class="s2">* Globstar syntax:</span>
 <span class="s2">* - Requires `{ globstar: true }`.</span>
 <span class="s2">* - `**` - Matches any number of any path segments.</span>
 <span class="s2">*     - Must comprise its entire path segment in the provided glob.</span>
 <span class="s2">* - See https://www.linuxjournal.com/content/globstar-new-bash-globbing-option.</span>
 <span class="s2">*</span>
 <span class="s2">* Note the following properties:</span>
 <span class="s2">* - The generated `RegExp` is anchored at both start and end.</span>
 <span class="s2">* - Repeating and trailing separators are tolerated. Trailing separators in the</span>
 <span class="s2">*   provided glob have no meaning and are discarded.</span>
 <span class="s2">* - Absolute globs will only match absolute paths, etc.</span>
 <span class="s2">* - Empty globs will match nothing.</span>
 <span class="s2">* - Any special glob syntax must be contained to one path segment. For example,</span>
 <span class="s2">*   `?(foo|bar/baz)` is invalid. The separator will take precedence and the</span>
 <span class="s2">*   first segment ends with an unclosed group.</span>
 <span class="s2">* - If a path segment ends with unclosed groups or a dangling escape prefix, a</span>
 <span class="s2">*   parse error has occurred. Every character for that segment is taken</span>
 <span class="s2">*   literally in this event.</span>
 <span class="s2">*</span>
 <span class="s2">* Limitations:</span>
 <span class="s2">* - A negative group like `!(foo|bar)` will wrongly be converted to a negative</span>
 <span class="s2">*   look-ahead followed by a wildcard. This means that `!(foo).js` will wrongly</span>
 <span class="s2">*   fail to match `foobar.js`, even though `foobar` is not `foo`. Effectively,</span>
 <span class="s2">*   `!(foo|bar)` is treated like `!(@(foo|bar)*)`. This will work correctly if</span>
 <span class="s2">*   the group occurs not nested at the end of the segment.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { globToRegExp } from &quot;@std/path/windows/glob-to-regexp&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* assertEquals(globToRegExp(&quot;*.js&quot;), /^[^\\/]*\.js(?:\\|\/)*$/);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">glob Glob string to convert.</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">options Conversion options.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The regular expression equivalent to the glob.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">globToRegExp(glob, options = {}) {</span>
  <span class="s3">return </span><span class="s1">_globToRegExp(constants, glob, options);</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Test whether the given string is a glob.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { isGlob } from &quot;@std/path/is-glob&quot;;</span>
 <span class="s2">* import { assert } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* assert(!isGlob(&quot;foo/bar/../baz&quot;));</span>
 <span class="s2">* assert(isGlob(&quot;foo/*ar/../baz&quot;));</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">str String to test.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">`true` if the given string is a glob, otherwise `false`</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">isGlob(str) {</span>
  <span class="s3">const </span><span class="s1">chars = {</span>
    <span class="s0">&quot;{&quot;</span><span class="s1">: </span><span class="s0">&quot;}&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;(&quot;</span><span class="s1">: </span><span class="s0">&quot;)&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;[&quot;</span><span class="s1">: </span><span class="s0">&quot;]&quot;</span>
  <span class="s1">};</span>
  <span class="s3">const </span><span class="s1">regex = </span><span class="s6">/\\(.)|(^!|\*|\?|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(str === </span><span class="s0">&quot;&quot;</span><span class="s1">) {</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">let </span><span class="s1">match;</span>
  <span class="s3">while</span><span class="s1">(match = regex.exec(str)){</span>
    <span class="s3">if </span><span class="s1">(match[</span><span class="s4">2</span><span class="s1">]) </span><span class="s3">return true</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s1">idx = match.index + match[</span><span class="s4">0</span><span class="s1">].length;</span>
    <span class="s2">// if an open bracket/brace/paren is escaped,</span>
    <span class="s2">// set the index to the next closing character</span>
    <span class="s3">const </span><span class="s1">open = match[</span><span class="s4">1</span><span class="s1">];</span>
    <span class="s3">const </span><span class="s1">close = open ? chars[open] : </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(open &amp;&amp; close) {</span>
      <span class="s3">const </span><span class="s1">n = str.indexOf(close, idx);</span>
      <span class="s3">if </span><span class="s1">(n !== -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">idx = n + </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">str = str.slice(idx);</span>
  <span class="s1">}</span>
  <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Like normalize(), but doesn't collapse &quot;**\/..&quot; when `globstar` is true.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { normalizeGlob } from &quot;@std/path/windows/normalize-glob&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* const normalized = normalizeGlob(&quot;**\\foo\\..\\bar&quot;, { globstar: true });</span>
 <span class="s2">* assertEquals(normalized, &quot;**\\bar&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">glob The glob pattern to normalize.</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">options The options for glob pattern.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The normalized glob pattern.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">normalizeGlob(glob, options = {}) {</span>
  <span class="s3">const </span><span class="s1">{ globstar = </span><span class="s3">false </span><span class="s1">} = options;</span>
  <span class="s3">if </span><span class="s1">(glob.match(</span><span class="s6">/\0/g</span><span class="s1">)) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s0">`Glob contains invalid characters: &quot;</span><span class="s1">${glob}</span><span class="s0">&quot;`</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(!globstar) {</span>
    <span class="s3">return </span><span class="s1">normalize(glob);</span>
  <span class="s1">}</span>
  <span class="s3">const </span><span class="s1">s = SEPARATOR_PATTERN.source;</span>
  <span class="s3">const </span><span class="s1">badParentPattern = </span><span class="s3">new </span><span class="s1">RegExp(</span><span class="s0">`(?&lt;=(</span><span class="s1">${s}</span><span class="s0">|^)</span><span class="s7">\\</span><span class="s0">*</span><span class="s7">\\</span><span class="s0">*</span><span class="s1">${s}</span><span class="s0">)</span><span class="s7">\\</span><span class="s0">.</span><span class="s7">\\</span><span class="s0">.(?=</span><span class="s1">${s}</span><span class="s0">|$)`</span><span class="s1">, </span><span class="s0">&quot;g&quot;</span><span class="s1">);</span>
  <span class="s3">return </span><span class="s1">normalize(glob.replace(badParentPattern, </span><span class="s0">&quot;</span><span class="s7">\0</span><span class="s0">&quot;</span><span class="s1">)).replace(</span><span class="s6">/\0/g</span><span class="s1">, </span><span class="s0">&quot;..&quot;</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Like join(), but doesn't collapse &quot;**\/..&quot; when `globstar` is true.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">*</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { joinGlobs } from &quot;@std/path/windows/join-globs&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* const joined = joinGlobs([&quot;foo&quot;, &quot;**&quot;, &quot;bar&quot;], { globstar: true });</span>
 <span class="s2">* assertEquals(joined, &quot;foo\\**\\bar&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">globs The globs to join.</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">options The options for glob pattern.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The joined glob pattern.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">joinGlobs(globs, options = {}) {</span>
  <span class="s3">const </span><span class="s1">{ globstar = </span><span class="s3">false </span><span class="s1">} = options;</span>
  <span class="s3">if </span><span class="s1">(!globstar || globs.length === </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">join(...globs);</span>
  <span class="s1">}</span>
  <span class="s3">let </span><span class="s1">joined;</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">glob of globs){</span>
    <span class="s3">const </span><span class="s1">path = glob;</span>
    <span class="s3">if </span><span class="s1">(path.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(!joined) joined = path;</span>
      <span class="s3">else </span><span class="s1">joined += </span><span class="s0">`</span><span class="s1">${SEPARATOR}${path}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(!joined) </span><span class="s3">return </span><span class="s0">&quot;.&quot;</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">normalizeGlob(joined, {</span>
    <span class="s1">globstar</span>
  <span class="s1">});</span>
<span class="s1">}</span>

<span class="s1">exports.DELIMITER = DELIMITER;</span>
<span class="s1">exports.SEPARATOR = SEPARATOR;</span>
<span class="s1">exports.SEPARATOR_PATTERN = SEPARATOR_PATTERN;</span>
<span class="s1">exports.basename = basename;</span>
<span class="s1">exports.common = common;</span>
<span class="s1">exports.dirname = dirname;</span>
<span class="s1">exports.extname = extname;</span>
<span class="s1">exports.format = format;</span>
<span class="s1">exports.fromFileUrl = fromFileUrl;</span>
<span class="s1">exports.globToRegExp = globToRegExp;</span>
<span class="s1">exports.isAbsolute = isAbsolute;</span>
<span class="s1">exports.isGlob = isGlob;</span>
<span class="s1">exports.join = join;</span>
<span class="s1">exports.joinGlobs = joinGlobs;</span>
<span class="s1">exports.normalize = normalize;</span>
<span class="s1">exports.normalizeGlob = normalizeGlob;</span>
<span class="s1">exports.parse = parse;</span>
<span class="s1">exports.relative = relative;</span>
<span class="s1">exports.resolve = resolve;</span>
<span class="s1">exports.toFileUrl = toFileUrl;</span>
<span class="s1">exports.toNamespacedPath = toNamespacedPath;</span>
</pre>
</body>
</html>