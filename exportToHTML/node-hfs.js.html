<html>
<head>
<title>node-hfs.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #0033b3;}
.s4 { color: #067d17;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
node-hfs.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">The main file for the hfs package.</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Nicholas C. Zakas</span>
 <span class="s0">*/</span>
<span class="s0">/* global Buffer:readonly, URL */</span>

<span class="s0">//-----------------------------------------------------------------------------</span>
<span class="s0">// Types</span>
<span class="s0">//-----------------------------------------------------------------------------</span>

<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;@humanfs/types&quot;).HfsImpl} HfsImpl */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;@humanfs/types&quot;).HfsDirectoryEntry} HfsDirectoryEntry */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;node:fs/promises&quot;)} Fsp */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;fs&quot;).Dirent} Dirent */</span>

<span class="s0">//-----------------------------------------------------------------------------</span>
<span class="s0">// Imports</span>
<span class="s0">//-----------------------------------------------------------------------------</span>

<span class="s3">import </span><span class="s2">{ Hfs } from </span><span class="s4">&quot;@humanfs/core&quot;</span><span class="s2">;</span>
<span class="s3">import </span><span class="s2">path from </span><span class="s4">&quot;node:path&quot;</span><span class="s2">;</span>
<span class="s3">import </span><span class="s2">{ Retrier } from </span><span class="s4">&quot;@humanwhocodes/retry&quot;</span><span class="s2">;</span>
<span class="s3">import </span><span class="s2">nativeFsp from </span><span class="s4">&quot;node:fs/promises&quot;</span><span class="s2">;</span>
<span class="s3">import </span><span class="s2">{ fileURLToPath } from </span><span class="s4">&quot;node:url&quot;</span><span class="s2">;</span>

<span class="s0">//-----------------------------------------------------------------------------</span>
<span class="s0">// Constants</span>
<span class="s0">//-----------------------------------------------------------------------------</span>

<span class="s3">const </span><span class="s2">RETRY_ERROR_CODES = </span><span class="s3">new </span><span class="s2">Set([</span><span class="s4">&quot;ENFILE&quot;</span><span class="s2">, </span><span class="s4">&quot;EMFILE&quot;</span><span class="s2">]);</span>

<span class="s0">//-----------------------------------------------------------------------------</span>
<span class="s0">// Helpers</span>
<span class="s0">//-----------------------------------------------------------------------------</span>

<span class="s0">/**</span>
 <span class="s0">* A class representing a directory entry.</span>
 <span class="s0">* </span><span class="s1">@implements </span><span class="s0">{HfsDirectoryEntry}</span>
 <span class="s0">*/</span>
<span class="s3">class </span><span class="s2">NodeHfsDirectoryEntry {</span>
	<span class="s0">/**</span>
	 <span class="s0">* The name of the directory entry.</span>
	 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{string}</span>
	 <span class="s0">*/</span>
	<span class="s2">name;</span>

	<span class="s0">/**</span>
	 <span class="s0">* True if the entry is a file.</span>
	 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
	 <span class="s0">*/</span>
	<span class="s2">isFile;</span>

	<span class="s0">/**</span>
	 <span class="s0">* True if the entry is a directory.</span>
	 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
	 <span class="s0">*/</span>
	<span class="s2">isDirectory;</span>

	<span class="s0">/**</span>
	 <span class="s0">* True if the entry is a symbolic link.</span>
	 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
	 <span class="s0">*/</span>
	<span class="s2">isSymlink;</span>

	<span class="s0">/**</span>
	 <span class="s0">* Creates a new instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Dirent} dirent The directory entry to wrap.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor(dirent) {</span>
		<span class="s3">this</span><span class="s2">.name = dirent.name;</span>
		<span class="s3">this</span><span class="s2">.isFile = dirent.isFile();</span>
		<span class="s3">this</span><span class="s2">.isDirectory = dirent.isDirectory();</span>
		<span class="s3">this</span><span class="s2">.isSymlink = dirent.isSymbolicLink();</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">//-----------------------------------------------------------------------------</span>
<span class="s0">// Exports</span>
<span class="s0">//-----------------------------------------------------------------------------</span>

<span class="s0">/**</span>
 <span class="s0">* A class representing the Node.js implementation of Hfs.</span>
 <span class="s0">* </span><span class="s1">@implements </span><span class="s0">{HfsImpl}</span>
 <span class="s0">*/</span>
<span class="s3">export class </span><span class="s2">NodeHfsImpl {</span>
	<span class="s0">/**</span>
	 <span class="s0">* The file system module to use.</span>
	 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Fsp}</span>
	 <span class="s0">*/</span>
	<span class="s2">#fsp;</span>

	<span class="s0">/**</span>
	 <span class="s0">* The retryer object used for retrying operations.</span>
	 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Retrier}</span>
	 <span class="s0">*/</span>
	<span class="s2">#retrier;</span>

	<span class="s0">/**</span>
	 <span class="s0">* Creates a new instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{object} [options] The options for the instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Fsp} [options.fsp] The file system module to use.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor({ fsp = nativeFsp } = {}) {</span>
		<span class="s3">this</span><span class="s2">.#fsp = fsp;</span>
		<span class="s3">this</span><span class="s2">.#retrier = </span><span class="s3">new </span><span class="s2">Retrier(error =&gt; RETRY_ERROR_CODES.has(error.code));</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Reads a file and returns the contents as an Uint8Array.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} filePath The path to the file to read.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;Uint8Array|undefined&gt;} A promise that resolves with the contents</span>
	 <span class="s0">*    of the file or undefined if the file doesn't exist.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the file cannot be read.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the file path is not a string.</span>
	 <span class="s0">*/</span>
	<span class="s2">bytes(filePath) {</span>
		<span class="s3">return this</span><span class="s2">.#retrier</span>
			<span class="s2">.retry(() =&gt; </span><span class="s3">this</span><span class="s2">.#fsp.readFile(filePath))</span>
			<span class="s2">.then(buffer =&gt; </span><span class="s3">new </span><span class="s2">Uint8Array(buffer.buffer))</span>
			<span class="s2">.catch(error =&gt; {</span>
				<span class="s3">if </span><span class="s2">(error.code === </span><span class="s4">&quot;ENOENT&quot;</span><span class="s2">) {</span>
					<span class="s3">return </span><span class="s2">undefined;</span>
				<span class="s2">}</span>

				<span class="s3">throw </span><span class="s2">error;</span>
			<span class="s2">});</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Writes a value to a file. If the value is a string, UTF-8 encoding is used.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} filePath The path to the file to write.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Uint8Array} contents The contents to write to the</span>
	 <span class="s0">*   file.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the file is</span>
	 <span class="s0">*  written.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the file path is not a string.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the file cannot be written.</span>
	 <span class="s0">*/</span>
	<span class="s2">async write(filePath, contents) {</span>
		<span class="s3">const </span><span class="s2">value = Buffer.from(contents);</span>

		<span class="s3">return this</span><span class="s2">.#retrier</span>
			<span class="s2">.retry(() =&gt; </span><span class="s3">this</span><span class="s2">.#fsp.writeFile(filePath, value))</span>
			<span class="s2">.catch(error =&gt; {</span>
				<span class="s0">// the directory may not exist, so create it</span>
				<span class="s3">if </span><span class="s2">(error.code === </span><span class="s4">&quot;ENOENT&quot;</span><span class="s2">) {</span>
					<span class="s3">const </span><span class="s2">dirPath = path.dirname(</span>
						<span class="s2">filePath </span><span class="s3">instanceof </span><span class="s2">URL</span>
							<span class="s2">? fileURLToPath(filePath)</span>
							<span class="s2">: filePath,</span>
					<span class="s2">);</span>

					<span class="s3">return this</span><span class="s2">.#fsp</span>
						<span class="s2">.mkdir(dirPath, { recursive: </span><span class="s3">true </span><span class="s2">})</span>
						<span class="s2">.then(() =&gt; </span><span class="s3">this</span><span class="s2">.#fsp.writeFile(filePath, value));</span>
				<span class="s2">}</span>

				<span class="s3">throw </span><span class="s2">error;</span>
			<span class="s2">});</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Appends a value to a file. If the value is a string, UTF-8 encoding is used.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} filePath The path to the file to append to.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Uint8Array} contents The contents to append to the</span>
	 <span class="s0">*  file.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the file is</span>
	 <span class="s0">* written.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the file path is not a string.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the file cannot be appended to.</span>
	 <span class="s0">*/</span>
	<span class="s2">async append(filePath, contents) {</span>
		<span class="s3">const </span><span class="s2">value = Buffer.from(contents);</span>

		<span class="s3">return this</span><span class="s2">.#retrier</span>
			<span class="s2">.retry(() =&gt; </span><span class="s3">this</span><span class="s2">.#fsp.appendFile(filePath, value))</span>
			<span class="s2">.catch(error =&gt; {</span>
				<span class="s0">// the directory may not exist, so create it</span>
				<span class="s3">if </span><span class="s2">(error.code === </span><span class="s4">&quot;ENOENT&quot;</span><span class="s2">) {</span>
					<span class="s3">const </span><span class="s2">dirPath = path.dirname(</span>
						<span class="s2">filePath </span><span class="s3">instanceof </span><span class="s2">URL</span>
							<span class="s2">? fileURLToPath(filePath)</span>
							<span class="s2">: filePath,</span>
					<span class="s2">);</span>

					<span class="s3">return this</span><span class="s2">.#fsp</span>
						<span class="s2">.mkdir(dirPath, { recursive: </span><span class="s3">true </span><span class="s2">})</span>
						<span class="s2">.then(() =&gt; </span><span class="s3">this</span><span class="s2">.#fsp.appendFile(filePath, value));</span>
				<span class="s2">}</span>

				<span class="s3">throw </span><span class="s2">error;</span>
			<span class="s2">});</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Checks if a file exists.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} filePath The path to the file to check.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;boolean&gt;} A promise that resolves with true if the</span>
	 <span class="s0">*    file exists or false if it does not.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the operation fails with a code other than ENOENT.</span>
	 <span class="s0">*/</span>
	<span class="s2">isFile(filePath) {</span>
		<span class="s3">return this</span><span class="s2">.#fsp</span>
			<span class="s2">.stat(filePath)</span>
			<span class="s2">.then(stat =&gt; stat.isFile())</span>
			<span class="s2">.catch(error =&gt; {</span>
				<span class="s3">if </span><span class="s2">(error.code === </span><span class="s4">&quot;ENOENT&quot;</span><span class="s2">) {</span>
					<span class="s3">return false</span><span class="s2">;</span>
				<span class="s2">}</span>

				<span class="s3">throw </span><span class="s2">error;</span>
			<span class="s2">});</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Checks if a directory exists.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} dirPath The path to the directory to check.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;boolean&gt;} A promise that resolves with true if the</span>
	 <span class="s0">*    directory exists or false if it does not.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the operation fails with a code other than ENOENT.</span>
	 <span class="s0">*/</span>
	<span class="s2">isDirectory(dirPath) {</span>
		<span class="s3">return this</span><span class="s2">.#fsp</span>
			<span class="s2">.stat(dirPath)</span>
			<span class="s2">.then(stat =&gt; stat.isDirectory())</span>
			<span class="s2">.catch(error =&gt; {</span>
				<span class="s3">if </span><span class="s2">(error.code === </span><span class="s4">&quot;ENOENT&quot;</span><span class="s2">) {</span>
					<span class="s3">return false</span><span class="s2">;</span>
				<span class="s2">}</span>

				<span class="s3">throw </span><span class="s2">error;</span>
			<span class="s2">});</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Creates a directory recursively.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} dirPath The path to the directory to create.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the directory is</span>
	 <span class="s0">*   created.</span>
	 <span class="s0">*/</span>
	<span class="s2">async createDirectory(dirPath) {</span>
		<span class="s3">await this</span><span class="s2">.#fsp.mkdir(dirPath, { recursive: </span><span class="s3">true </span><span class="s2">});</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Deletes a file or empty directory.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} fileOrDirPath The path to the file or directory to</span>
	 <span class="s0">*   delete.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;boolean&gt;} A promise that resolves when the file or</span>
	 <span class="s0">*   directory is deleted, true if the file or directory is deleted, false</span>
	 <span class="s0">*   if the file or directory does not exist.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the file or directory path is not a string.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the file or directory cannot be deleted.</span>
	 <span class="s0">*/</span>
	<span class="s3">delete</span><span class="s2">(fileOrDirPath) {</span>
		<span class="s3">return this</span><span class="s2">.#fsp</span>
			<span class="s2">.rm(fileOrDirPath)</span>
			<span class="s2">.then(() =&gt; </span><span class="s3">true</span><span class="s2">)</span>
			<span class="s2">.catch(error =&gt; {</span>
				<span class="s3">if </span><span class="s2">(error.code === </span><span class="s4">&quot;ERR_FS_EISDIR&quot;</span><span class="s2">) {</span>
					<span class="s3">return this</span><span class="s2">.#fsp.rmdir(fileOrDirPath).then(() =&gt; </span><span class="s3">true</span><span class="s2">);</span>
				<span class="s2">}</span>

				<span class="s3">if </span><span class="s2">(error.code === </span><span class="s4">&quot;ENOENT&quot;</span><span class="s2">) {</span>
					<span class="s3">return false</span><span class="s2">;</span>
				<span class="s2">}</span>

				<span class="s3">throw </span><span class="s2">error;</span>
			<span class="s2">});</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Deletes a file or directory recursively.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} fileOrDirPath The path to the file or directory to</span>
	 <span class="s0">*   delete.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;boolean&gt;} A promise that resolves when the file or</span>
	 <span class="s0">*   directory is deleted, true if the file or directory is deleted, false</span>
	 <span class="s0">*   if the file or directory does not exist.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the file or directory path is not a string.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the file or directory cannot be deleted.</span>
	 <span class="s0">*/</span>
	<span class="s2">deleteAll(fileOrDirPath) {</span>
		<span class="s3">return this</span><span class="s2">.#fsp</span>
			<span class="s2">.rm(fileOrDirPath, { recursive: </span><span class="s3">true </span><span class="s2">})</span>
			<span class="s2">.then(() =&gt; </span><span class="s3">true</span><span class="s2">)</span>
			<span class="s2">.catch(error =&gt; {</span>
				<span class="s3">if </span><span class="s2">(error.code === </span><span class="s4">&quot;ENOENT&quot;</span><span class="s2">) {</span>
					<span class="s3">return false</span><span class="s2">;</span>
				<span class="s2">}</span>

				<span class="s3">throw </span><span class="s2">error;</span>
			<span class="s2">});</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Returns a list of directory entries for the given path.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} dirPath The path to the directory to read.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{AsyncIterable&lt;HfsDirectoryEntry&gt;} A promise that resolves with the</span>
	 <span class="s0">*   directory entries.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the directory path is not a string.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the directory cannot be read.</span>
	 <span class="s0">*/</span>
	<span class="s2">async *list(dirPath) {</span>
		<span class="s3">const </span><span class="s2">entries = </span><span class="s3">await this</span><span class="s2">.#fsp.readdir(dirPath, {</span>
			<span class="s2">withFileTypes: </span><span class="s3">true</span><span class="s2">,</span>
		<span class="s2">});</span>

		<span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">entry of entries) {</span>
			<span class="s3">yield new </span><span class="s2">NodeHfsDirectoryEntry(entry);</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Returns the size of a file. This method handles ENOENT errors</span>
	 <span class="s0">* and returns undefined in that case.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} filePath The path to the file to read.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;number|undefined&gt;} A promise that resolves with the size of the</span>
	 <span class="s0">*  file in bytes or undefined if the file doesn't exist.</span>
	 <span class="s0">*/</span>
	<span class="s2">size(filePath) {</span>
		<span class="s3">return this</span><span class="s2">.#fsp</span>
			<span class="s2">.stat(filePath)</span>
			<span class="s2">.then(stat =&gt; stat.size)</span>
			<span class="s2">.catch(error =&gt; {</span>
				<span class="s3">if </span><span class="s2">(error.code === </span><span class="s4">&quot;ENOENT&quot;</span><span class="s2">) {</span>
					<span class="s3">return </span><span class="s2">undefined;</span>
				<span class="s2">}</span>

				<span class="s3">throw </span><span class="s2">error;</span>
			<span class="s2">});</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Returns the last modified date of a file or directory. This method handles ENOENT errors</span>
	 <span class="s0">* and returns undefined in that case.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} fileOrDirPath The path to the file to read.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;Date|undefined&gt;} A promise that resolves with the last modified</span>
	 <span class="s0">* date of the file or directory, or undefined if the file doesn't exist.</span>
	 <span class="s0">*/</span>
	<span class="s2">lastModified(fileOrDirPath) {</span>
		<span class="s3">return this</span><span class="s2">.#fsp</span>
			<span class="s2">.stat(fileOrDirPath)</span>
			<span class="s2">.then(stat =&gt; stat.mtime)</span>
			<span class="s2">.catch(error =&gt; {</span>
				<span class="s3">if </span><span class="s2">(error.code === </span><span class="s4">&quot;ENOENT&quot;</span><span class="s2">) {</span>
					<span class="s3">return </span><span class="s2">undefined;</span>
				<span class="s2">}</span>

				<span class="s3">throw </span><span class="s2">error;</span>
			<span class="s2">});</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Copies a file from one location to another.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} source The path to the file to copy.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} destination The path to copy the file to.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the file is copied.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the source file does not exist.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the source file is a directory.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the destination file is a directory.</span>
	 <span class="s0">*/</span>
	<span class="s2">copy(source, destination) {</span>
		<span class="s3">return this</span><span class="s2">.#fsp.copyFile(source, destination);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Copies a file or directory from one location to another.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} source The path to the file or directory to copy.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} destination The path to copy the file or directory to.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the file or directory is</span>
	 <span class="s0">* copied.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the source file or directory does not exist.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the destination file or directory is a directory.</span>
	 <span class="s0">*/</span>
	<span class="s2">async copyAll(source, destination) {</span>
		<span class="s0">// for files use copy() and exit</span>
		<span class="s3">if </span><span class="s2">(</span><span class="s3">await this</span><span class="s2">.isFile(source)) {</span>
			<span class="s3">return this</span><span class="s2">.copy(source, destination);</span>
		<span class="s2">}</span>

		<span class="s3">const </span><span class="s2">sourceStr =</span>
			<span class="s2">source </span><span class="s3">instanceof </span><span class="s2">URL ? fileURLToPath(source) : source;</span>

		<span class="s3">const </span><span class="s2">destinationStr =</span>
			<span class="s2">destination </span><span class="s3">instanceof </span><span class="s2">URL</span>
				<span class="s2">? fileURLToPath(destination)</span>
				<span class="s2">: destination;</span>

		<span class="s0">// for directories, create the destination directory and copy each entry</span>
		<span class="s3">await this</span><span class="s2">.createDirectory(destination);</span>

		<span class="s3">for await </span><span class="s2">(</span><span class="s3">const </span><span class="s2">entry of </span><span class="s3">this</span><span class="s2">.list(source)) {</span>
			<span class="s3">const </span><span class="s2">fromEntryPath = path.join(sourceStr, entry.name);</span>
			<span class="s3">const </span><span class="s2">toEntryPath = path.join(destinationStr, entry.name);</span>

			<span class="s3">if </span><span class="s2">(entry.isDirectory) {</span>
				<span class="s3">await this</span><span class="s2">.copyAll(fromEntryPath, toEntryPath);</span>
			<span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
				<span class="s3">await this</span><span class="s2">.copy(fromEntryPath, toEntryPath);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Moves a file from the source path to the destination path.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} source The location of the file to move.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} destination The destination of the file to move.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the move is complete.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the file paths are not strings.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the file cannot be moved.</span>
	 <span class="s0">*/</span>
	<span class="s2">move(source, destination) {</span>
		<span class="s3">return this</span><span class="s2">.#fsp.stat(source).then(stat =&gt; {</span>
			<span class="s3">if </span><span class="s2">(stat.isDirectory()) {</span>
				<span class="s3">throw new </span><span class="s2">Error(</span>
					<span class="s4">`EISDIR: illegal operation on a directory, move '</span><span class="s2">${source}</span><span class="s4">' -&gt; '</span><span class="s2">${destination}</span><span class="s4">'`</span><span class="s2">,</span>
				<span class="s2">);</span>
			<span class="s2">}</span>

			<span class="s3">return this</span><span class="s2">.#fsp.rename(source, destination);</span>
		<span class="s2">});</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Moves a file or directory from the source path to the destination path.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} source The location of the file or directory to move.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} destination The destination of the file or directory to move.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the move is complete.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the file paths are not strings.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the file or directory cannot be moved.</span>
	 <span class="s0">*/</span>
	<span class="s2">async moveAll(source, destination) {</span>
		<span class="s3">return this</span><span class="s2">.#fsp.rename(source, destination);</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* A class representing a file system utility library.</span>
 <span class="s0">* </span><span class="s1">@implements </span><span class="s0">{HfsImpl}</span>
 <span class="s0">*/</span>
<span class="s3">export class </span><span class="s2">NodeHfs </span><span class="s3">extends </span><span class="s2">Hfs {</span>
	<span class="s0">/**</span>
	 <span class="s0">* Creates a new instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{object} [options] The options for the instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Fsp} [options.fsp] The file system module to use.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor({ fsp } = {}) {</span>
		<span class="s3">super</span><span class="s2">({ impl: </span><span class="s3">new </span><span class="s2">NodeHfsImpl({ fsp }) });</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s3">export const </span><span class="s2">hfs = </span><span class="s3">new </span><span class="s2">NodeHfs();</span>
</pre>
</body>
</html>