<html>
<head>
<title>propTypes.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #1750eb;}
.s6 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
propTypes.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">Common propTypes detection functionality.</span>
 <span class="s0">*/</span>

<span class="s3">'use strict'</span><span class="s2">;</span>

<span class="s4">const </span><span class="s2">flatMap = require(</span><span class="s3">'array.prototype.flatmap'</span><span class="s2">);</span>

<span class="s4">const </span><span class="s2">annotations = require(</span><span class="s3">'./annotations'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">propsUtil = require(</span><span class="s3">'./props'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">variableUtil = require(</span><span class="s3">'./variable'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">testFlowVersion = require(</span><span class="s3">'./version'</span><span class="s2">).testFlowVersion;</span>
<span class="s4">const </span><span class="s2">propWrapperUtil = require(</span><span class="s3">'./propWrapper'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">astUtil = require(</span><span class="s3">'./ast'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">isFirstLetterCapitalized = require(</span><span class="s3">'./isFirstLetterCapitalized'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">eslintUtil = require(</span><span class="s3">'./eslint'</span><span class="s2">);</span>

<span class="s4">const </span><span class="s2">getFirstTokens = eslintUtil.getFirstTokens;</span>
<span class="s4">const </span><span class="s2">getScope = eslintUtil.getScope;</span>
<span class="s4">const </span><span class="s2">getSourceCode = eslintUtil.getSourceCode;</span>
<span class="s4">const </span><span class="s2">getText = eslintUtil.getText;</span>

<span class="s0">/**</span>
 <span class="s0">* Check if node is function type.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean}</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isFunctionType(node) {</span>
  <span class="s4">if </span><span class="s2">(!node) </span><span class="s4">return false</span><span class="s2">;</span>
  <span class="s4">const </span><span class="s2">nodeType = node.type;</span>
  <span class="s4">return </span><span class="s2">nodeType === </span><span class="s3">'FunctionDeclaration'</span>
    <span class="s2">|| nodeType === </span><span class="s3">'FunctionExpression'</span>
    <span class="s2">|| nodeType === </span><span class="s3">'ArrowFunctionExpression'</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Checks if we are declaring a props as a generic type in a flow-annotated class.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node  the AST node being checked.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the node is a class with generic prop types, false if not.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isSuperTypeParameterPropsDeclaration(node) {</span>
  <span class="s4">if </span><span class="s2">(node &amp;&amp; (node.type === </span><span class="s3">'ClassDeclaration' </span><span class="s2">|| node.type === </span><span class="s3">'ClassExpression'</span><span class="s2">)) {</span>
    <span class="s4">const </span><span class="s2">parameters = propsUtil.getSuperTypeArguments(node);</span>
    <span class="s4">if </span><span class="s2">(parameters &amp;&amp; parameters.params.length &gt; </span><span class="s5">0</span><span class="s2">) {</span>
      <span class="s4">return true</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s4">return false</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Iterates through a properties node, like a customized forEach.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} context Array of properties to iterate.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object[]} properties Array of properties to iterate.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} fn Function to call on each property, receives property key</span>
    <span class="s0">and property value. (key, value) =&gt; void</span>
  <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [handleSpreadFn] Function to call on each ObjectTypeSpreadProperty, receives the</span>
    <span class="s0">argument</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">iterateProperties(context, properties, fn, handleSpreadFn) {</span>
  <span class="s4">if </span><span class="s2">(properties &amp;&amp; properties.length &amp;&amp; </span><span class="s4">typeof </span><span class="s2">fn === </span><span class="s3">'function'</span><span class="s2">) {</span>
    <span class="s4">for </span><span class="s2">(</span><span class="s4">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">, j = properties.length; i &lt; j; i++) {</span>
      <span class="s4">const </span><span class="s2">node = properties[i];</span>
      <span class="s4">const </span><span class="s2">key = astUtil.getKeyValue(context, node);</span>

      <span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">'ObjectTypeSpreadProperty' </span><span class="s2">&amp;&amp; </span><span class="s4">typeof </span><span class="s2">handleSpreadFn === </span><span class="s3">'function'</span><span class="s2">) {</span>
        <span class="s2">handleSpreadFn(node.argument);</span>
      <span class="s2">}</span>

      <span class="s4">const </span><span class="s2">value = node.value;</span>
      <span class="s2">fn(key, value, node);</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Checks if a node is inside a class body.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node the AST node being checked.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the node has a ClassBody ancestor, false if not.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isInsideClassBody(node) {</span>
  <span class="s4">let </span><span class="s2">parent = node.parent;</span>
  <span class="s4">while </span><span class="s2">(parent) {</span>
    <span class="s4">if </span><span class="s2">(parent.type === </span><span class="s3">'ClassBody'</span><span class="s2">) {</span>
      <span class="s4">return true</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s2">parent = parent.parent;</span>
  <span class="s2">}</span>
  <span class="s4">return false</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s4">function </span><span class="s2">startWithCapitalizedLetter(node) {</span>
  <span class="s4">return </span><span class="s2">(</span>
    <span class="s2">node.parent.type === </span><span class="s3">'VariableDeclarator'</span>
    <span class="s2">&amp;&amp; !isFirstLetterCapitalized(node.parent.id.name)</span>
  <span class="s2">);</span>
<span class="s2">}</span>

<span class="s2">module.exports = </span><span class="s4">function </span><span class="s2">propTypesInstructions(context, components, utils) {</span>
  <span class="s0">// Used to track the type annotations in scope.</span>
  <span class="s0">// Necessary because babel's scopes do not track type annotations.</span>
  <span class="s4">let </span><span class="s2">stack = </span><span class="s4">null</span><span class="s2">;</span>

  <span class="s4">const </span><span class="s2">classExpressions = [];</span>
  <span class="s4">const </span><span class="s2">defaults = { customValidators: [] };</span>
  <span class="s4">const </span><span class="s2">configuration = Object.assign({}, defaults, context.options[</span><span class="s5">0</span><span class="s2">] || {});</span>
  <span class="s4">const </span><span class="s2">customValidators = configuration.customValidators;</span>
  <span class="s4">const </span><span class="s2">allowedGenericTypes = </span><span class="s4">new </span><span class="s2">Set([</span><span class="s3">'ComponentProps'</span><span class="s2">, </span><span class="s3">'ComponentPropsWithRef'</span><span class="s2">, </span><span class="s3">'ComponentPropsWithoutRef'</span><span class="s2">, </span><span class="s3">'forwardRef'</span><span class="s2">, </span><span class="s3">'ForwardRefRenderFunction'</span><span class="s2">, </span><span class="s3">'VFC'</span><span class="s2">, </span><span class="s3">'VoidFunctionComponent'</span><span class="s2">, </span><span class="s3">'PropsWithChildren'</span><span class="s2">, </span><span class="s3">'SFC'</span><span class="s2">, </span><span class="s3">'StatelessComponent'</span><span class="s2">, </span><span class="s3">'FunctionComponent'</span><span class="s2">, </span><span class="s3">'FC'</span><span class="s2">]);</span>
  <span class="s4">const </span><span class="s2">genericTypeParamIndexWherePropsArePresent = {</span>
    <span class="s2">ComponentProps: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">ComponentPropsWithRef: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">ComponentPropsWithoutRef: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">ForwardRefRenderFunction: </span><span class="s5">1</span><span class="s2">,</span>
    <span class="s2">forwardRef: </span><span class="s5">1</span><span class="s2">,</span>
    <span class="s2">VoidFunctionComponent: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">VFC: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">PropsWithChildren: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">SFC: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">StatelessComponent: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">FunctionComponent: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">FC: </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">};</span>
  <span class="s4">const </span><span class="s2">genericReactTypesImport = </span><span class="s4">new </span><span class="s2">Set();</span>
  <span class="s0">// import { FC as X } from 'react' -&gt; localToImportedMap = { x: FC }</span>
  <span class="s4">const </span><span class="s2">localToImportedMap = {};</span>

  <span class="s0">/**</span>
   <span class="s0">* Returns the full scope.</span>
   <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Object} The whole scope.</span>
   <span class="s0">*/</span>
  <span class="s4">function </span><span class="s2">typeScope() {</span>
    <span class="s4">return </span><span class="s2">stack[stack.length - </span><span class="s5">1</span><span class="s2">];</span>
  <span class="s2">}</span>

  <span class="s0">/**</span>
   <span class="s0">* Gets a node from the scope.</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} key The name of the identifier to access.</span>
   <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ASTNode} The ASTNode associated with the given identifier.</span>
   <span class="s0">*/</span>
  <span class="s4">function </span><span class="s2">getInTypeScope(key) {</span>
    <span class="s4">return </span><span class="s2">stack[stack.length - </span><span class="s5">1</span><span class="s2">][key];</span>
  <span class="s2">}</span>

  <span class="s0">/**</span>
   <span class="s0">* Sets the new value in the scope.</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} key The name of the identifier to access</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} value The new value for the identifier.</span>
   <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ASTNode} The ASTNode associated with the given identifier.</span>
   <span class="s0">*/</span>
  <span class="s4">function </span><span class="s2">setInTypeScope(key, value) {</span>
    <span class="s2">stack[stack.length - </span><span class="s5">1</span><span class="s2">][key] = value;</span>
    <span class="s4">return </span><span class="s2">value;</span>
  <span class="s2">}</span>

  <span class="s0">/**</span>
   <span class="s0">* Checks if prop should be validated by plugin-react-proptypes</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} validator Name of validator to check.</span>
   <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if validator should be checked by custom validator.</span>
   <span class="s0">*/</span>
  <span class="s4">function </span><span class="s2">hasCustomValidator(validator) {</span>
    <span class="s4">return </span><span class="s2">customValidators.indexOf(validator) !== -</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">}</span>

  <span class="s0">/* eslint-disable no-use-before-define */</span>
  <span class="s0">/** </span><span class="s1">@type </span><span class="s0">{TypeDeclarationBuilders} */</span>
  <span class="s4">const </span><span class="s2">typeDeclarationBuilders = {</span>
    <span class="s2">GenericTypeAnnotation(annotation, parentName, seen) {</span>
      <span class="s4">if </span><span class="s2">(getInTypeScope(annotation.id.name)) {</span>
        <span class="s4">return </span><span class="s2">buildTypeAnnotationDeclarationTypes(getInTypeScope(annotation.id.name), parentName, seen);</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s2">{};</span>
    <span class="s2">},</span>

    <span class="s2">ObjectTypeAnnotation(annotation, parentName, seen) {</span>
      <span class="s4">let </span><span class="s2">containsUnresolvedObjectTypeSpread = </span><span class="s4">false</span><span class="s2">;</span>
      <span class="s4">let </span><span class="s2">containsSpread = </span><span class="s4">false</span><span class="s2">;</span>
      <span class="s4">const </span><span class="s2">containsIndexers = !!annotation.indexers &amp;&amp; annotation.indexers.length &gt; </span><span class="s5">0</span><span class="s2">;</span>
      <span class="s4">const </span><span class="s2">shapeTypeDefinition = {</span>
        <span class="s2">type: </span><span class="s3">'shape'</span><span class="s2">,</span>
        <span class="s2">children: {},</span>
      <span class="s2">};</span>
      <span class="s2">iterateProperties(</span>
        <span class="s2">context,</span>
        <span class="s2">annotation.properties,</span>
        <span class="s2">(childKey, childValue, propNode) =&gt; {</span>
          <span class="s4">const </span><span class="s2">fullName = [parentName, childKey].join(</span><span class="s3">'.'</span><span class="s2">);</span>
          <span class="s4">if </span><span class="s2">(childKey || childValue) {</span>
            <span class="s4">const </span><span class="s2">types = buildTypeAnnotationDeclarationTypes(childValue, fullName, seen);</span>
            <span class="s2">types.fullName = fullName;</span>
            <span class="s2">types.name = childKey;</span>
            <span class="s2">types.node = propNode;</span>
            <span class="s2">types.isRequired = !childValue.optional;</span>
            <span class="s2">shapeTypeDefinition.children[childKey] = types;</span>
          <span class="s2">}</span>
        <span class="s2">},</span>
        <span class="s2">(spreadNode) =&gt; {</span>
          <span class="s4">const </span><span class="s2">key = astUtil.getKeyValue(context, spreadNode);</span>
          <span class="s4">const </span><span class="s2">types = buildTypeAnnotationDeclarationTypes(spreadNode, key, seen);</span>
          <span class="s4">if </span><span class="s2">(!types.children) {</span>
            <span class="s2">containsUnresolvedObjectTypeSpread = </span><span class="s4">true</span><span class="s2">;</span>
          <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
            <span class="s2">Object.assign(shapeTypeDefinition, types.children);</span>
          <span class="s2">}</span>
          <span class="s2">containsSpread = </span><span class="s4">true</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">);</span>

      <span class="s0">// Mark if this shape has spread or an indexer. We will know to consider all props from this shape as having propTypes,</span>
      <span class="s0">// but still have the ability to detect unused children of this shape.</span>
      <span class="s2">shapeTypeDefinition.containsUnresolvedSpread = containsUnresolvedObjectTypeSpread;</span>
      <span class="s2">shapeTypeDefinition.containsIndexers = containsIndexers;</span>
      <span class="s0">// Deprecated: containsSpread is not used anymore in the codebase, ensure to keep API backward compatibility</span>
      <span class="s2">shapeTypeDefinition.containsSpread = containsSpread;</span>

      <span class="s4">return </span><span class="s2">shapeTypeDefinition;</span>
    <span class="s2">},</span>

    <span class="s2">UnionTypeAnnotation(annotation, parentName, seen) {</span>
      <span class="s0">/** </span><span class="s1">@type </span><span class="s0">{UnionTypeDefinition} */</span>
      <span class="s4">const </span><span class="s2">unionTypeDefinition = {</span>
        <span class="s2">type: </span><span class="s3">'union'</span><span class="s2">,</span>
        <span class="s2">children: annotation.types.map((type) =&gt; buildTypeAnnotationDeclarationTypes(type, parentName, seen)),</span>
      <span class="s2">};</span>
      <span class="s4">if </span><span class="s2">(unionTypeDefinition.children.length === </span><span class="s5">0</span><span class="s2">) {</span>
        <span class="s0">// no complex type found, simply accept everything</span>
        <span class="s4">return </span><span class="s2">{};</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s2">unionTypeDefinition;</span>
    <span class="s2">},</span>

    <span class="s2">ArrayTypeAnnotation(annotation, parentName, seen) {</span>
      <span class="s4">const </span><span class="s2">fullName = [parentName, </span><span class="s3">'*'</span><span class="s2">].join(</span><span class="s3">'.'</span><span class="s2">);</span>
      <span class="s4">const </span><span class="s2">child = buildTypeAnnotationDeclarationTypes(annotation.elementType, fullName, seen);</span>
      <span class="s2">child.fullName = fullName;</span>
      <span class="s2">child.name = </span><span class="s3">'__ANY_KEY__'</span><span class="s2">;</span>
      <span class="s2">child.node = annotation;</span>
      <span class="s4">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s3">'object'</span><span class="s2">,</span>
        <span class="s2">children: {</span>
          <span class="s2">__ANY_KEY__: child,</span>
        <span class="s2">},</span>
      <span class="s2">};</span>
    <span class="s2">},</span>
  <span class="s2">};</span>
  <span class="s0">/* eslint-enable no-use-before-define */</span>

  <span class="s0">/**</span>
   <span class="s0">* Resolve the type annotation for a given node.</span>
   <span class="s0">* Flow annotations are sometimes wrapped in outer `TypeAnnotation`</span>
   <span class="s0">* and `NullableTypeAnnotation` nodes which obscure the annotation we're</span>
   <span class="s0">* interested in.</span>
   <span class="s0">* This method also resolves type aliases where possible.</span>
   <span class="s0">*</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The annotation or a node containing the type annotation.</span>
   <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ASTNode} The resolved type annotation for the node.</span>
   <span class="s0">*/</span>
  <span class="s4">function </span><span class="s2">resolveTypeAnnotation(node) {</span>
    <span class="s4">let </span><span class="s2">annotation = (node.left &amp;&amp; node.left.typeAnnotation) || node.typeAnnotation || node;</span>
    <span class="s4">while </span><span class="s2">(annotation &amp;&amp; (annotation.type === </span><span class="s3">'TypeAnnotation' </span><span class="s2">|| annotation.type === </span><span class="s3">'NullableTypeAnnotation'</span><span class="s2">)) {</span>
      <span class="s2">annotation = annotation.typeAnnotation;</span>
    <span class="s2">}</span>
    <span class="s4">if </span><span class="s2">(annotation.type === </span><span class="s3">'GenericTypeAnnotation' </span><span class="s2">&amp;&amp; getInTypeScope(annotation.id.name)) {</span>
      <span class="s4">return </span><span class="s2">getInTypeScope(annotation.id.name);</span>
    <span class="s2">}</span>
    <span class="s4">return </span><span class="s2">annotation;</span>
  <span class="s2">}</span>

  <span class="s0">/**</span>
   <span class="s0">* Creates the representation of the React props type annotation for the component.</span>
   <span class="s0">* The representation is used to verify nested used properties.</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} annotation Type annotation for the props class property.</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} parentName</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Set&lt;ASTNode&gt;} [seen]</span>
   <span class="s0">* </span><span class="s1">@return </span><span class="s0">{Object} The representation of the declaration, empty object means</span>
   <span class="s0">*    the property is declared without the need for further analysis.</span>
   <span class="s0">*/</span>
  <span class="s4">function </span><span class="s2">buildTypeAnnotationDeclarationTypes(annotation, parentName, seen) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">seen === </span><span class="s3">'undefined'</span><span class="s2">) {</span>
      <span class="s0">// Keeps track of annotations we've already seen to</span>
      <span class="s0">// prevent problems with recursive types.</span>
      <span class="s2">seen = </span><span class="s4">new </span><span class="s2">Set();</span>
    <span class="s2">}</span>
    <span class="s4">if </span><span class="s2">(seen.has(annotation)) {</span>
      <span class="s0">// This must be a recursive type annotation, so just accept anything.</span>
      <span class="s4">return </span><span class="s2">{};</span>
    <span class="s2">}</span>
    <span class="s2">seen.add(annotation);</span>

    <span class="s4">if </span><span class="s2">(annotation.type </span><span class="s4">in </span><span class="s2">typeDeclarationBuilders) {</span>
      <span class="s4">return </span><span class="s2">typeDeclarationBuilders[annotation.type](annotation, parentName, seen);</span>
    <span class="s2">}</span>
    <span class="s4">return </span><span class="s2">{};</span>
  <span class="s2">}</span>

  <span class="s0">/**</span>
   <span class="s0">* Marks all props found inside ObjectTypeAnnotation as declared.</span>
   <span class="s0">*</span>
   <span class="s0">* Modifies the declaredProperties object</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} propTypes</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} declaredPropTypes</span>
   <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if propTypes should be ignored (e.g. when a type can't be resolved, when it is imported)</span>
   <span class="s0">*/</span>
  <span class="s4">function </span><span class="s2">declarePropTypesForObjectTypeAnnotation(propTypes, declaredPropTypes) {</span>
    <span class="s4">let </span><span class="s2">ignorePropsValidation = </span><span class="s4">false</span><span class="s2">;</span>

    <span class="s2">iterateProperties(context, propTypes.properties, (key, value, propNode) =&gt; {</span>
      <span class="s4">if </span><span class="s2">(!value) {</span>
        <span class="s2">ignorePropsValidation = ignorePropsValidation || propNode.type !== </span><span class="s3">'ObjectTypeSpreadProperty'</span><span class="s2">;</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s4">const </span><span class="s2">types = buildTypeAnnotationDeclarationTypes(value, key);</span>
      <span class="s2">types.fullName = key;</span>
      <span class="s2">types.name = key;</span>
      <span class="s2">types.node = propNode;</span>
      <span class="s2">types.isRequired = !propNode.optional;</span>
      <span class="s2">declaredPropTypes[key] = types;</span>
    <span class="s2">}, (spreadNode) =&gt; {</span>
      <span class="s4">const </span><span class="s2">key = astUtil.getKeyValue(context, spreadNode);</span>
      <span class="s4">const </span><span class="s2">spreadAnnotation = getInTypeScope(key);</span>
      <span class="s4">if </span><span class="s2">(!spreadAnnotation) {</span>
        <span class="s2">ignorePropsValidation = </span><span class="s4">true</span><span class="s2">;</span>
      <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
        <span class="s4">const </span><span class="s2">spreadIgnoreValidation = declarePropTypesForObjectTypeAnnotation(spreadAnnotation, declaredPropTypes);</span>
        <span class="s2">ignorePropsValidation = ignorePropsValidation || spreadIgnoreValidation;</span>
      <span class="s2">}</span>
    <span class="s2">});</span>

    <span class="s4">return </span><span class="s2">ignorePropsValidation;</span>
  <span class="s2">}</span>

  <span class="s0">/**</span>
   <span class="s0">* Marks all props found inside IntersectionTypeAnnotation as declared.</span>
   <span class="s0">* Since InterSectionTypeAnnotations can be nested, this handles recursively.</span>
   <span class="s0">*</span>
   <span class="s0">* Modifies the declaredPropTypes object</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} propTypes</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} declaredPropTypes</span>
   <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if propTypes should be ignored (e.g. when a type can't be resolved, when it is imported)</span>
   <span class="s0">*/</span>
  <span class="s4">function </span><span class="s2">declarePropTypesForIntersectionTypeAnnotation(propTypes, declaredPropTypes) {</span>
    <span class="s4">return </span><span class="s2">propTypes.types.some((annotation) =&gt; {</span>
      <span class="s4">if </span><span class="s2">(annotation.type === </span><span class="s3">'ObjectTypeAnnotation'</span><span class="s2">) {</span>
        <span class="s4">return </span><span class="s2">declarePropTypesForObjectTypeAnnotation(annotation, declaredPropTypes);</span>
      <span class="s2">}</span>

      <span class="s4">if </span><span class="s2">(annotation.type === </span><span class="s3">'UnionTypeAnnotation'</span><span class="s2">) {</span>
        <span class="s4">return true</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s0">// Type can't be resolved</span>
      <span class="s4">if </span><span class="s2">(!annotation.id) {</span>
        <span class="s4">return true</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s4">const </span><span class="s2">typeNode = getInTypeScope(annotation.id.name);</span>

      <span class="s4">if </span><span class="s2">(!typeNode) {</span>
        <span class="s4">return true</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(typeNode.type === </span><span class="s3">'IntersectionTypeAnnotation'</span><span class="s2">) {</span>
        <span class="s4">return </span><span class="s2">declarePropTypesForIntersectionTypeAnnotation(typeNode, declaredPropTypes);</span>
      <span class="s2">}</span>

      <span class="s4">return </span><span class="s2">declarePropTypesForObjectTypeAnnotation(typeNode, declaredPropTypes);</span>
    <span class="s2">});</span>
  <span class="s2">}</span>

  <span class="s0">/**</span>
   <span class="s0">* Resolve node of type Identifier when building declaration types.</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} rootNode</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} callback called with the resolved value only if resolved.</span>
   <span class="s0">*/</span>
  <span class="s4">function </span><span class="s2">resolveValueForIdentifierNode(node, rootNode, callback) {</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">rootNode</span>
      <span class="s2">&amp;&amp; node</span>
      <span class="s2">&amp;&amp; node.type === </span><span class="s3">'Identifier'</span>
    <span class="s2">) {</span>
      <span class="s4">const </span><span class="s2">scope = getScope(context, rootNode);</span>
      <span class="s4">const </span><span class="s2">identVariable = scope.variableScope.variables.find(</span>
        <span class="s2">(variable) =&gt; variable.name === node.name</span>
      <span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(identVariable) {</span>
        <span class="s4">const </span><span class="s2">definition = identVariable.defs[identVariable.defs.length - </span><span class="s5">1</span><span class="s2">];</span>
        <span class="s2">callback(definition.node.init);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s0">/**</span>
   <span class="s0">* Creates the representation of the React propTypes for the component.</span>
   <span class="s0">* The representation is used to verify nested used properties.</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} value Node of the PropTypes for the desired property</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} parentName</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} rootNode</span>
   <span class="s0">* </span><span class="s1">@return </span><span class="s0">{Object} The representation of the declaration, empty object means</span>
   <span class="s0">*    the property is declared without the need for further analysis.</span>
   <span class="s0">*/</span>
  <span class="s4">function </span><span class="s2">buildReactDeclarationTypes(value, parentName, rootNode) {</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">value</span>
      <span class="s2">&amp;&amp; value.callee</span>
      <span class="s2">&amp;&amp; value.callee.object</span>
      <span class="s2">&amp;&amp; hasCustomValidator(value.callee.object.name)</span>
    <span class="s2">) {</span>
      <span class="s4">return </span><span class="s2">{};</span>
    <span class="s2">}</span>

    <span class="s4">let </span><span class="s2">identNodeResolved = </span><span class="s4">false</span><span class="s2">;</span>
    <span class="s0">// Resolve identifier node for cases where isRequired is set in</span>
    <span class="s0">// the variable declaration or not at all.</span>
    <span class="s0">// const variableType = PropTypes.shape({ foo: ... }).isRequired</span>
    <span class="s0">// propTypes = {</span>
    <span class="s0">//   example: variableType</span>
    <span class="s0">// }</span>
    <span class="s0">// --------</span>
    <span class="s0">// const variableType = PropTypes.shape({ foo: ... })</span>
    <span class="s0">// propTypes = {</span>
    <span class="s0">//   example: variableType</span>
    <span class="s0">// }</span>
    <span class="s2">resolveValueForIdentifierNode(value, rootNode, (newValue) =&gt; {</span>
      <span class="s2">identNodeResolved = </span><span class="s4">true</span><span class="s2">;</span>
      <span class="s2">value = newValue;</span>
    <span class="s2">});</span>

    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">value</span>
      <span class="s2">&amp;&amp; value.type === </span><span class="s3">'MemberExpression'</span>
      <span class="s2">&amp;&amp; value.property</span>
      <span class="s2">&amp;&amp; value.property.name === </span><span class="s3">'isRequired'</span>
    <span class="s2">) {</span>
      <span class="s2">value = value.object;</span>
    <span class="s2">}</span>

    <span class="s0">// Resolve identifier node for cases where isRequired is set in</span>
    <span class="s0">// the prop types.</span>
    <span class="s0">// const variableType = PropTypes.shape({ foo: ... })</span>
    <span class="s0">// propTypes = {</span>
    <span class="s0">//   example: variableType.isRequired</span>
    <span class="s0">// }</span>
    <span class="s4">if </span><span class="s2">(!identNodeResolved) {</span>
      <span class="s2">resolveValueForIdentifierNode(value, rootNode, (newValue) =&gt; {</span>
        <span class="s2">value = newValue;</span>
      <span class="s2">});</span>
    <span class="s2">}</span>

    <span class="s0">// Verify PropTypes that are functions</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">astUtil.isCallExpression(value)</span>
      <span class="s2">&amp;&amp; value.callee</span>
      <span class="s2">&amp;&amp; value.callee.property</span>
      <span class="s2">&amp;&amp; value.callee.property.name</span>
      <span class="s2">&amp;&amp; value.arguments</span>
      <span class="s2">&amp;&amp; value.arguments.length &gt; </span><span class="s5">0</span>
    <span class="s2">) {</span>
      <span class="s4">const </span><span class="s2">callName = value.callee.property.name;</span>
      <span class="s4">const </span><span class="s2">argument = value.arguments[</span><span class="s5">0</span><span class="s2">];</span>
      <span class="s4">switch </span><span class="s2">(callName) {</span>
        <span class="s4">case </span><span class="s3">'shape'</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s3">'exact'</span><span class="s2">: {</span>
          <span class="s4">if </span><span class="s2">(argument.type !== </span><span class="s3">'ObjectExpression'</span><span class="s2">) {</span>
            <span class="s0">// Invalid proptype or cannot analyse statically</span>
            <span class="s4">return </span><span class="s2">{};</span>
          <span class="s2">}</span>
          <span class="s4">const </span><span class="s2">shapeTypeDefinition = {</span>
            <span class="s2">type: callName,</span>
            <span class="s2">children: {},</span>
          <span class="s2">};</span>
          <span class="s2">iterateProperties(context, argument.properties, (childKey, childValue, propNode) =&gt; {</span>
            <span class="s4">if </span><span class="s2">(childValue) { </span><span class="s0">// skip spread propTypes</span>
              <span class="s4">const </span><span class="s2">fullName = [parentName, childKey].join(</span><span class="s3">'.'</span><span class="s2">);</span>
              <span class="s4">const </span><span class="s2">types = buildReactDeclarationTypes(childValue, fullName, rootNode);</span>
              <span class="s2">types.fullName = fullName;</span>
              <span class="s2">types.name = childKey;</span>
              <span class="s2">types.node = propNode;</span>
              <span class="s2">shapeTypeDefinition.children[childKey] = types;</span>
            <span class="s2">}</span>
          <span class="s2">});</span>
          <span class="s4">return </span><span class="s2">shapeTypeDefinition;</span>
        <span class="s2">}</span>
        <span class="s4">case </span><span class="s3">'arrayOf'</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s3">'objectOf'</span><span class="s2">: {</span>
          <span class="s4">const </span><span class="s2">fullName = [parentName, </span><span class="s3">'*'</span><span class="s2">].join(</span><span class="s3">'.'</span><span class="s2">);</span>
          <span class="s4">const </span><span class="s2">child = buildReactDeclarationTypes(argument, fullName, rootNode);</span>
          <span class="s2">child.fullName = fullName;</span>
          <span class="s2">child.name = </span><span class="s3">'__ANY_KEY__'</span><span class="s2">;</span>
          <span class="s2">child.node = argument;</span>
          <span class="s4">return </span><span class="s2">{</span>
            <span class="s2">type: </span><span class="s3">'object'</span><span class="s2">,</span>
            <span class="s2">children: {</span>
              <span class="s2">__ANY_KEY__: child,</span>
            <span class="s2">},</span>
          <span class="s2">};</span>
        <span class="s2">}</span>
        <span class="s4">case </span><span class="s3">'oneOfType'</span><span class="s2">: {</span>
          <span class="s4">if </span><span class="s2">(</span>
            <span class="s2">!argument.elements</span>
            <span class="s2">|| argument.elements.length === </span><span class="s5">0</span>
          <span class="s2">) {</span>
            <span class="s0">// Invalid proptype or cannot analyse statically</span>
            <span class="s4">return </span><span class="s2">{};</span>
          <span class="s2">}</span>

          <span class="s0">/** </span><span class="s1">@type </span><span class="s0">{UnionTypeDefinition} */</span>
          <span class="s4">const </span><span class="s2">unionTypeDefinition = {</span>
            <span class="s2">type: </span><span class="s3">'union'</span><span class="s2">,</span>
            <span class="s2">children: argument.elements.map((element) =&gt; buildReactDeclarationTypes(element, parentName, rootNode)),</span>
          <span class="s2">};</span>
          <span class="s4">if </span><span class="s2">(unionTypeDefinition.children.length === </span><span class="s5">0</span><span class="s2">) {</span>
            <span class="s0">// no complex type found, simply accept everything</span>
            <span class="s4">return </span><span class="s2">{};</span>
          <span class="s2">}</span>
          <span class="s4">return </span><span class="s2">unionTypeDefinition;</span>
        <span class="s2">}</span>
        <span class="s4">default</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">{};</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s0">// Unknown property or accepts everything (any, object, ...)</span>
    <span class="s4">return </span><span class="s2">{};</span>
  <span class="s2">}</span>

  <span class="s4">function </span><span class="s2">isValidReactGenericTypeAnnotation(annotation) {</span>
    <span class="s4">if </span><span class="s2">(annotation.typeName) {</span>
      <span class="s4">if </span><span class="s2">(annotation.typeName.name) { </span><span class="s0">// if FC&lt;Props&gt;</span>
        <span class="s4">const </span><span class="s2">typeName = annotation.typeName.name;</span>
        <span class="s4">if </span><span class="s2">(!genericReactTypesImport.has(typeName)) {</span>
          <span class="s4">return false</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">} </span><span class="s4">else if </span><span class="s2">(annotation.typeName.right.name) { </span><span class="s0">// if React.FC&lt;Props&gt;</span>
        <span class="s4">const </span><span class="s2">right = annotation.typeName.right.name;</span>
        <span class="s4">const </span><span class="s2">left = annotation.typeName.left.name;</span>

        <span class="s4">if </span><span class="s2">(!genericReactTypesImport.has(left) || !allowedGenericTypes.has(right)) {</span>
          <span class="s4">return false</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">return true</span><span class="s2">;</span>
  <span class="s2">}</span>

  <span class="s0">/**</span>
   <span class="s0">* Returns the left most typeName of a node, e.g: FC&lt;Props&gt;, React.FC&lt;Props&gt;</span>
   <span class="s0">* The representation is used to verify nested used properties.</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node</span>
   <span class="s0">* </span><span class="s1">@return </span><span class="s0">{string | undefined}</span>
   <span class="s0">*/</span>
  <span class="s4">function </span><span class="s2">getLeftMostTypeName(node) {</span>
    <span class="s4">if </span><span class="s2">(node.name) </span><span class="s4">return </span><span class="s2">node.name;</span>
    <span class="s4">if </span><span class="s2">(node.left) </span><span class="s4">return </span><span class="s2">getLeftMostTypeName(node.left);</span>
  <span class="s2">}</span>

  <span class="s4">function </span><span class="s2">getRightMostTypeName(node) {</span>
    <span class="s4">if </span><span class="s2">(node.name) </span><span class="s4">return </span><span class="s2">node.name;</span>
    <span class="s4">if </span><span class="s2">(node.right) </span><span class="s4">return </span><span class="s2">getRightMostTypeName(node.right);</span>
  <span class="s2">}</span>

  <span class="s0">/**</span>
   <span class="s0">* Returns true if the node is either a interface or type alias declaration</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node</span>
   <span class="s0">* </span><span class="s1">@return </span><span class="s0">{boolean}</span>
   <span class="s0">*/</span>
  <span class="s4">function </span><span class="s2">filterInterfaceOrTypeAlias(node) {</span>
    <span class="s4">return </span><span class="s2">(</span>
      <span class="s2">astUtil.isTSInterfaceDeclaration(node) || astUtil.isTSTypeAliasDeclaration(node)</span>
    <span class="s2">);</span>
  <span class="s2">}</span>

  <span class="s0">/**</span>
   <span class="s0">* Returns true if the interface or type alias declaration node name matches the type-name str</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} typeName</span>
   <span class="s0">* </span><span class="s1">@return </span><span class="s0">{boolean}</span>
   <span class="s0">*/</span>
  <span class="s4">function </span><span class="s2">filterInterfaceOrAliasByName(node, typeName) {</span>
    <span class="s4">return </span><span class="s2">(</span>
      <span class="s2">node.id</span>
      <span class="s2">&amp;&amp; node.id.name === typeName</span>
    <span class="s2">) || (</span>
      <span class="s2">node.declaration</span>
      <span class="s2">&amp;&amp; node.declaration.id</span>
      <span class="s2">&amp;&amp; node.declaration.id.name === typeName</span>
    <span class="s2">);</span>
  <span class="s2">}</span>

  <span class="s4">class </span><span class="s2">DeclarePropTypesForTSTypeAnnotation {</span>
    <span class="s2">constructor(propTypes, declaredPropTypes, rootNode) {</span>
      <span class="s4">this</span><span class="s2">.propTypes = propTypes;</span>
      <span class="s4">this</span><span class="s2">.declaredPropTypes = declaredPropTypes;</span>
      <span class="s4">this</span><span class="s2">.foundDeclaredPropertiesList = [];</span>
      <span class="s4">this</span><span class="s2">.referenceNameMap = </span><span class="s4">new </span><span class="s2">Set();</span>
      <span class="s4">this</span><span class="s2">.sourceCode = getSourceCode(context);</span>
      <span class="s4">this</span><span class="s2">.shouldIgnorePropTypes = </span><span class="s4">false</span><span class="s2">;</span>
      <span class="s4">this</span><span class="s2">.rootNode = rootNode;</span>
      <span class="s4">this</span><span class="s2">.visitTSNode(</span><span class="s4">this</span><span class="s2">.propTypes);</span>
      <span class="s4">this</span><span class="s2">.endAndStructDeclaredPropTypes();</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* The node will be distribute to different function.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node</span>
     <span class="s0">*/</span>
    <span class="s2">visitTSNode(node) {</span>
      <span class="s4">if </span><span class="s2">(!node) </span><span class="s4">return</span><span class="s2">;</span>
      <span class="s4">if </span><span class="s2">(astUtil.isTSTypeAnnotation(node)) {</span>
        <span class="s4">const </span><span class="s2">typeAnnotation = node.typeAnnotation;</span>
        <span class="s4">this</span><span class="s2">.visitTSNode(typeAnnotation);</span>
      <span class="s2">} </span><span class="s4">else if </span><span class="s2">(astUtil.isTSTypeReference(node)) {</span>
        <span class="s4">this</span><span class="s2">.searchDeclarationByName(node);</span>
      <span class="s2">} </span><span class="s4">else if </span><span class="s2">(astUtil.isTSInterfaceHeritage(node)) {</span>
        <span class="s4">this</span><span class="s2">.searchDeclarationByName(node);</span>
      <span class="s2">} </span><span class="s4">else if </span><span class="s2">(astUtil.isTSTypeLiteral(node)) {</span>
        <span class="s0">// Check node is an object literal</span>
        <span class="s4">if </span><span class="s2">(Array.isArray(node.members)) {</span>
          <span class="s4">this</span><span class="s2">.foundDeclaredPropertiesList = </span><span class="s4">this</span><span class="s2">.foundDeclaredPropertiesList.concat(node.members);</span>
        <span class="s2">}</span>
      <span class="s2">} </span><span class="s4">else if </span><span class="s2">(astUtil.isTSIntersectionType(node)) {</span>
        <span class="s4">this</span><span class="s2">.convertIntersectionTypeToPropTypes(node);</span>
      <span class="s2">} </span><span class="s4">else if </span><span class="s2">(astUtil.isTSParenthesizedType(node)) {</span>
        <span class="s4">const </span><span class="s2">typeAnnotation = node.typeAnnotation;</span>
        <span class="s4">this</span><span class="s2">.visitTSNode(typeAnnotation);</span>
      <span class="s2">} </span><span class="s4">else if </span><span class="s2">(astUtil.isTSTypeParameterInstantiation(node)) {</span>
        <span class="s4">if </span><span class="s2">(Array.isArray(node.params)) {</span>
          <span class="s2">node.params.forEach((x) =&gt; </span><span class="s4">this</span><span class="s2">.visitTSNode(x));</span>
        <span class="s2">}</span>
      <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
        <span class="s4">this</span><span class="s2">.shouldIgnorePropTypes = </span><span class="s4">true</span><span class="s2">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Search TSInterfaceDeclaration or TSTypeAliasDeclaration,</span>
     <span class="s0">* by using TSTypeReference and TSInterfaceHeritage name.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node</span>
     <span class="s0">*/</span>
    <span class="s2">searchDeclarationByName(node) {</span>
      <span class="s4">let </span><span class="s2">typeName;</span>
      <span class="s4">if </span><span class="s2">(astUtil.isTSTypeReference(node)) {</span>
        <span class="s2">typeName = node.typeName.name;</span>
        <span class="s4">const </span><span class="s2">leftMostName = getLeftMostTypeName(node.typeName);</span>
        <span class="s4">const </span><span class="s2">shouldTraverseTypeParams = genericReactTypesImport.has(leftMostName);</span>
        <span class="s4">const </span><span class="s2">nodeTypeArguments = propsUtil.getTypeArguments(node);</span>
        <span class="s4">if </span><span class="s2">(shouldTraverseTypeParams &amp;&amp; nodeTypeArguments &amp;&amp; nodeTypeArguments.length !== </span><span class="s5">0</span><span class="s2">) {</span>
          <span class="s0">// All react Generic types are derived from:</span>
          <span class="s0">// type PropsWithChildren&lt;P&gt; = P &amp; { children?: ReactNode | undefined }</span>
          <span class="s0">// So we should construct an optional children prop</span>
          <span class="s4">this</span><span class="s2">.shouldSpecifyOptionalChildrenProps = </span><span class="s4">true</span><span class="s2">;</span>

          <span class="s4">const </span><span class="s2">rightMostName = getRightMostTypeName(node.typeName);</span>
          <span class="s4">if </span><span class="s2">(</span>
            <span class="s2">leftMostName === </span><span class="s3">'React'</span>
            <span class="s2">&amp;&amp; (</span>
              <span class="s2">rightMostName === </span><span class="s3">'HTMLAttributes'</span>
              <span class="s2">|| rightMostName === </span><span class="s3">'HTMLElement'</span>
              <span class="s2">|| rightMostName === </span><span class="s3">'HTMLProps'</span>
            <span class="s2">)</span>
          <span class="s2">) {</span>
            <span class="s4">this</span><span class="s2">.shouldSpecifyClassNameProp = </span><span class="s4">true</span><span class="s2">;</span>
          <span class="s2">}</span>

          <span class="s4">const </span><span class="s2">importedName = localToImportedMap[rightMostName];</span>
          <span class="s4">const </span><span class="s2">idx = genericTypeParamIndexWherePropsArePresent[</span>
            <span class="s2">leftMostName !== rightMostName ? rightMostName : importedName</span>
          <span class="s2">];</span>
          <span class="s4">const </span><span class="s2">nextNode = nodeTypeArguments.params[idx];</span>
          <span class="s4">this</span><span class="s2">.visitTSNode(nextNode);</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">} </span><span class="s4">else if </span><span class="s2">(astUtil.isTSInterfaceHeritage(node)) {</span>
        <span class="s4">if </span><span class="s2">(!node.expression &amp;&amp; node.id) {</span>
          <span class="s2">typeName = node.id.name;</span>
        <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
          <span class="s2">typeName = node.expression.name;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(!typeName) {</span>
        <span class="s4">this</span><span class="s2">.shouldIgnorePropTypes = </span><span class="s4">true</span><span class="s2">;</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(typeName === </span><span class="s3">'ReturnType'</span><span class="s2">) {</span>
        <span class="s4">this</span><span class="s2">.convertReturnTypeToPropTypes(node, </span><span class="s4">this</span><span class="s2">.rootNode);</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s0">// Prevent recursive inheritance will cause maximum callstack.</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">this</span><span class="s2">.referenceNameMap.has(typeName)) {</span>
        <span class="s4">this</span><span class="s2">.shouldIgnorePropTypes = </span><span class="s4">true</span><span class="s2">;</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s0">// Add typeName to Set and consider it as traversed.</span>
      <span class="s4">this</span><span class="s2">.referenceNameMap.add(typeName);</span>

      <span class="s0">/**</span>
       <span class="s0">* From line 577 to line 581, and line 588 to line 590 are trying to handle typescript-eslint-parser</span>
       <span class="s0">* Need to be deprecated after remove typescript-eslint-parser support.</span>
       <span class="s0">*/</span>
      <span class="s4">const </span><span class="s2">candidateTypes = </span><span class="s4">this</span><span class="s2">.sourceCode.ast.body.filter((item) =&gt; astUtil.isTSTypeDeclaration(item));</span>

      <span class="s4">const </span><span class="s2">declarations = flatMap(</span>
        <span class="s2">candidateTypes,</span>
        <span class="s2">(type) =&gt; (</span>
          <span class="s2">type.declarations</span>
          <span class="s2">|| (</span>
            <span class="s2">type.declaration</span>
            <span class="s2">&amp;&amp; type.declaration.declarations</span>
          <span class="s2">)</span>
          <span class="s2">|| type.declaration</span>
        <span class="s2">)</span>
      <span class="s2">);</span>

      <span class="s0">// we tried to find either an interface or a type with the TypeReference name</span>
      <span class="s4">const </span><span class="s2">typeDeclaration = declarations.filter((dec) =&gt; dec.id.name === typeName);</span>

      <span class="s4">const </span><span class="s2">interfaceDeclarations = </span><span class="s4">this</span><span class="s2">.sourceCode.ast.body</span>
        <span class="s2">.filter(filterInterfaceOrTypeAlias)</span>
        <span class="s2">.filter((item) =&gt; filterInterfaceOrAliasByName(item, typeName))</span>
        <span class="s2">.map((item) =&gt; (item.declaration || item));</span>

      <span class="s4">if </span><span class="s2">(typeDeclaration.length !== </span><span class="s5">0</span><span class="s2">) {</span>
        <span class="s2">typeDeclaration.map((t) =&gt; t.init || t.typeAnnotation).forEach(</span><span class="s4">this</span><span class="s2">.visitTSNode, </span><span class="s4">this</span><span class="s2">);</span>
      <span class="s2">} </span><span class="s4">else if </span><span class="s2">(interfaceDeclarations.length !== </span><span class="s5">0</span><span class="s2">) {</span>
        <span class="s2">interfaceDeclarations.forEach(</span><span class="s4">this</span><span class="s2">.traverseDeclaredInterfaceOrTypeAlias, </span><span class="s4">this</span><span class="s2">);</span>
      <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
        <span class="s4">this</span><span class="s2">.shouldIgnorePropTypes = </span><span class="s4">true</span><span class="s2">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Traverse TSInterfaceDeclaration and TSTypeAliasDeclaration</span>
     <span class="s0">* which retrieve from function searchDeclarationByName;</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node</span>
     <span class="s0">*/</span>
    <span class="s2">traverseDeclaredInterfaceOrTypeAlias(node) {</span>
      <span class="s4">if </span><span class="s2">(astUtil.isTSInterfaceDeclaration(node)) {</span>
        <span class="s0">// Handle TSInterfaceDeclaration interface Props { name: string, id: number}, should put in properties list directly;</span>
        <span class="s4">this</span><span class="s2">.foundDeclaredPropertiesList = </span><span class="s4">this</span><span class="s2">.foundDeclaredPropertiesList.concat(node.body.body);</span>
      <span class="s2">}</span>
      <span class="s0">// Handle TSTypeAliasDeclaration type Props = {name:string}</span>
      <span class="s4">if </span><span class="s2">(astUtil.isTSTypeAliasDeclaration(node)) {</span>
        <span class="s4">const </span><span class="s2">typeAnnotation = node.typeAnnotation;</span>
        <span class="s4">this</span><span class="s2">.visitTSNode(typeAnnotation);</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(Array.isArray(node.extends)) {</span>
        <span class="s2">node.extends.forEach((x) =&gt; </span><span class="s4">this</span><span class="s2">.visitTSNode(x));</span>
        <span class="s0">// This line is trying to handle typescript-eslint-parser</span>
        <span class="s0">// typescript-eslint-parser extension is name as heritage</span>
      <span class="s2">} </span><span class="s4">else if </span><span class="s2">(Array.isArray(node.heritage)) {</span>
        <span class="s2">node.heritage.forEach((x) =&gt; </span><span class="s4">this</span><span class="s2">.visitTSNode(x));</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s2">convertIntersectionTypeToPropTypes(node) {</span>
      <span class="s4">if </span><span class="s2">(!node) </span><span class="s4">return</span><span class="s2">;</span>
      <span class="s4">if </span><span class="s2">(Array.isArray(node.types)) {</span>
        <span class="s2">node.types.forEach((x) =&gt; </span><span class="s4">this</span><span class="s2">.visitTSNode(x));</span>
      <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
        <span class="s4">this</span><span class="s2">.shouldIgnorePropTypes = </span><span class="s4">true</span><span class="s2">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s2">convertReturnTypeToPropTypes(node, rootNode) {</span>
      <span class="s0">// ReturnType&lt;T&gt; should always have one parameter</span>
      <span class="s4">const </span><span class="s2">nodeTypeArguments = propsUtil.getTypeArguments(node);</span>
      <span class="s4">if </span><span class="s2">(nodeTypeArguments) {</span>
        <span class="s4">if </span><span class="s2">(nodeTypeArguments.params.length === </span><span class="s5">1</span><span class="s2">) {</span>
          <span class="s4">let </span><span class="s2">returnType = nodeTypeArguments.params[</span><span class="s5">0</span><span class="s2">];</span>
          <span class="s0">// This line is trying to handle typescript-eslint-parser</span>
          <span class="s0">// typescript-eslint-parser TSTypeQuery is wrapped by TSTypeReference</span>
          <span class="s4">if </span><span class="s2">(astUtil.isTSTypeReference(returnType)) {</span>
            <span class="s2">returnType = returnType.typeName;</span>
          <span class="s2">}</span>
          <span class="s0">// Handle ReturnType&lt;typeof mapStateToProps&gt;</span>
          <span class="s4">if </span><span class="s2">(astUtil.isTSTypeQuery(returnType)) {</span>
            <span class="s4">const </span><span class="s2">returnTypeFunction = flatMap(</span><span class="s4">this</span><span class="s2">.sourceCode.ast.body</span>
              <span class="s2">.filter((item) =&gt; item.type === </span><span class="s3">'VariableDeclaration'</span>
                <span class="s2">&amp;&amp; item.declarations.find((dec) =&gt; dec.id.name === returnType.exprName.name)</span>
              <span class="s2">), (type) =&gt; type.declarations).map((dec) =&gt; dec.init);</span>

            <span class="s4">if </span><span class="s2">(Array.isArray(returnTypeFunction)) {</span>
              <span class="s4">if </span><span class="s2">(returnTypeFunction.length === </span><span class="s5">0</span><span class="s2">) {</span>
                <span class="s0">// Cannot find identifier in current scope. It might be an exported type.</span>
                <span class="s4">this</span><span class="s2">.shouldIgnorePropTypes = </span><span class="s4">true</span><span class="s2">;</span>
                <span class="s4">return</span><span class="s2">;</span>
              <span class="s2">}</span>
              <span class="s2">returnTypeFunction.forEach((func) =&gt; {</span>
                <span class="s4">if </span><span class="s2">(isFunctionType(func)) {</span>
                  <span class="s4">let </span><span class="s2">res = func.body;</span>
                  <span class="s4">if </span><span class="s2">(res.type === </span><span class="s3">'BlockStatement'</span><span class="s2">) {</span>
                    <span class="s2">res = astUtil.findReturnStatement(func);</span>
                    <span class="s4">if </span><span class="s2">(res) {</span>
                      <span class="s2">res = res.argument;</span>
                    <span class="s2">}</span>
                  <span class="s2">}</span>
                  <span class="s4">switch </span><span class="s2">(res.type) {</span>
                    <span class="s4">case </span><span class="s3">'ObjectExpression'</span><span class="s2">:</span>
                      <span class="s2">iterateProperties(context, res.properties, (key, value, propNode) =&gt; {</span>
                        <span class="s4">if </span><span class="s2">(propNode &amp;&amp; astUtil.isCallExpression(propNode.argument)) {</span>
                          <span class="s4">const </span><span class="s2">propNodeTypeArguments = propsUtil.getTypeArguments(propNode.argument);</span>
                          <span class="s4">if </span><span class="s2">(propNodeTypeArguments) {</span>
                            <span class="s4">this</span><span class="s2">.visitTSNode(propNodeTypeArguments);</span>
                          <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
                            <span class="s0">// Ignore this CallExpression return value since it doesn't have any typeParameters to let us know it's types.</span>
                            <span class="s4">this</span><span class="s2">.shouldIgnorePropTypes = </span><span class="s4">true</span><span class="s2">;</span>
                            <span class="s4">return</span><span class="s2">;</span>
                          <span class="s2">}</span>
                        <span class="s2">}</span>
                        <span class="s4">if </span><span class="s2">(!value) {</span>
                          <span class="s4">this</span><span class="s2">.shouldIgnorePropTypes = </span><span class="s4">true</span><span class="s2">;</span>
                          <span class="s4">return</span><span class="s2">;</span>
                        <span class="s2">}</span>
                        <span class="s4">const </span><span class="s2">types = buildReactDeclarationTypes(value, key, rootNode);</span>
                        <span class="s2">types.fullName = key;</span>
                        <span class="s2">types.name = key;</span>
                        <span class="s2">types.node = propNode;</span>
                        <span class="s2">types.isRequired = propsUtil.isRequiredPropType(value);</span>
                        <span class="s4">this</span><span class="s2">.declaredPropTypes[key] = types;</span>
                      <span class="s2">});</span>
                      <span class="s4">break</span><span class="s2">;</span>
                    <span class="s4">case </span><span class="s3">'CallExpression'</span><span class="s2">:</span>
                      <span class="s4">if </span><span class="s2">(propsUtil.getTypeArguments(res)) {</span>
                        <span class="s4">this</span><span class="s2">.visitTSNode(propsUtil.getTypeArguments(res));</span>
                      <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
                        <span class="s0">// Ignore this CallExpression return value since it doesn't have any typeParameters to let us know it's types.</span>
                        <span class="s4">this</span><span class="s2">.shouldIgnorePropTypes = </span><span class="s4">true</span><span class="s2">;</span>
                      <span class="s2">}</span>
                      <span class="s4">break</span><span class="s2">;</span>
                    <span class="s4">default</span><span class="s2">:</span>
                  <span class="s2">}</span>
                <span class="s2">}</span>
              <span class="s2">});</span>
              <span class="s4">return</span><span class="s2">;</span>
            <span class="s2">}</span>
          <span class="s2">}</span>
          <span class="s0">// Handle ReturnType&lt;()=&gt;returnType&gt;</span>
          <span class="s4">if </span><span class="s2">(astUtil.isTSFunctionType(returnType)) {</span>
            <span class="s4">if </span><span class="s2">(astUtil.isTSTypeAnnotation(returnType.returnType)) {</span>
              <span class="s4">this</span><span class="s2">.visitTSNode(returnType.returnType);</span>
              <span class="s4">return</span><span class="s2">;</span>
            <span class="s2">}</span>
            <span class="s0">// This line is trying to handle typescript-eslint-parser</span>
            <span class="s0">// typescript-eslint-parser TSFunction name returnType as typeAnnotation</span>
            <span class="s4">if </span><span class="s2">(astUtil.isTSTypeAnnotation(returnType.typeAnnotation)) {</span>
              <span class="s4">this</span><span class="s2">.visitTSNode(returnType.typeAnnotation);</span>
              <span class="s4">return</span><span class="s2">;</span>
            <span class="s2">}</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s4">this</span><span class="s2">.shouldIgnorePropTypes = </span><span class="s4">true</span><span class="s2">;</span>
    <span class="s2">}</span>

    <span class="s2">endAndStructDeclaredPropTypes() {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">this</span><span class="s2">.shouldSpecifyOptionalChildrenProps) {</span>
        <span class="s4">this</span><span class="s2">.declaredPropTypes.children = {</span>
          <span class="s2">fullName: </span><span class="s3">'children'</span><span class="s2">,</span>
          <span class="s2">name: </span><span class="s3">'children'</span><span class="s2">,</span>
          <span class="s2">isRequired: </span><span class="s4">false</span><span class="s2">,</span>
        <span class="s2">};</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">this</span><span class="s2">.shouldSpecifyClassNameProp) {</span>
        <span class="s4">this</span><span class="s2">.declaredPropTypes.className = {</span>
          <span class="s2">fullName: </span><span class="s3">'className'</span><span class="s2">,</span>
          <span class="s2">name: </span><span class="s3">'className'</span><span class="s2">,</span>
          <span class="s2">isRequired: </span><span class="s4">false</span><span class="s2">,</span>
        <span class="s2">};</span>
      <span class="s2">}</span>

      <span class="s4">this</span><span class="s2">.foundDeclaredPropertiesList.forEach((tsInterfaceBody) =&gt; {</span>
        <span class="s4">if </span><span class="s2">(tsInterfaceBody &amp;&amp; (tsInterfaceBody.type === </span><span class="s3">'TSPropertySignature' </span><span class="s2">|| tsInterfaceBody.type === </span><span class="s3">'TSMethodSignature'</span><span class="s2">)) {</span>
          <span class="s4">let </span><span class="s2">accessor = </span><span class="s3">'name'</span><span class="s2">;</span>
          <span class="s4">if </span><span class="s2">(tsInterfaceBody.key.type === </span><span class="s3">'Literal'</span><span class="s2">) {</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">tsInterfaceBody.key.value === </span><span class="s3">'number'</span><span class="s2">) {</span>
              <span class="s2">accessor = </span><span class="s3">'raw'</span><span class="s2">;</span>
            <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
              <span class="s2">accessor = </span><span class="s3">'value'</span><span class="s2">;</span>
            <span class="s2">}</span>
          <span class="s2">}</span>
          <span class="s4">this</span><span class="s2">.declaredPropTypes[tsInterfaceBody.key[accessor]] = {</span>
            <span class="s2">fullName: tsInterfaceBody.key[accessor],</span>
            <span class="s2">name: tsInterfaceBody.key[accessor],</span>
            <span class="s2">node: tsInterfaceBody,</span>
            <span class="s2">isRequired: !tsInterfaceBody.optional,</span>
          <span class="s2">};</span>
        <span class="s2">}</span>
      <span class="s2">});</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s0">/**</span>
   <span class="s0">* Mark a prop type as declared</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node being checked.</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} propTypes The AST node containing the proptypes</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} rootNode</span>
   <span class="s0">*/</span>
  <span class="s4">function </span><span class="s2">markPropTypesAsDeclared(node, propTypes, rootNode) {</span>
    <span class="s4">let </span><span class="s2">componentNode = node;</span>
    <span class="s4">while </span><span class="s2">(componentNode &amp;&amp; !components.get(componentNode)) {</span>
      <span class="s2">componentNode = componentNode.parent;</span>
    <span class="s2">}</span>
    <span class="s4">const </span><span class="s2">component = components.get(componentNode);</span>
    <span class="s4">let </span><span class="s2">declaredPropTypes = (component &amp;&amp; component.declaredPropTypes) || {};</span>
    <span class="s4">let </span><span class="s2">ignorePropsValidation = (component &amp;&amp; component.ignorePropsValidation) || </span><span class="s4">false</span><span class="s2">;</span>
    <span class="s4">switch </span><span class="s2">(propTypes &amp;&amp; propTypes.type) {</span>
      <span class="s4">case </span><span class="s3">'ObjectTypeAnnotation'</span><span class="s2">:</span>
        <span class="s2">ignorePropsValidation = declarePropTypesForObjectTypeAnnotation(propTypes, declaredPropTypes);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s3">'ObjectExpression'</span><span class="s2">:</span>
        <span class="s2">iterateProperties(context, propTypes.properties, (key, value, propNode) =&gt; {</span>
          <span class="s4">if </span><span class="s2">(!value) {</span>
            <span class="s2">ignorePropsValidation = </span><span class="s4">true</span><span class="s2">;</span>
            <span class="s4">return</span><span class="s2">;</span>
          <span class="s2">}</span>
          <span class="s4">const </span><span class="s2">types = buildReactDeclarationTypes(value, key, rootNode);</span>
          <span class="s2">types.fullName = key;</span>
          <span class="s2">types.name = key;</span>
          <span class="s2">types.node = propNode;</span>
          <span class="s2">types.isRequired = propsUtil.isRequiredPropType(value);</span>
          <span class="s2">declaredPropTypes[key] = types;</span>
        <span class="s2">});</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s3">'MemberExpression'</span><span class="s2">: {</span>
        <span class="s4">let </span><span class="s2">curDeclaredPropTypes = declaredPropTypes;</span>
        <span class="s0">// Walk the list of properties, until we reach the assignment</span>
        <span class="s0">// ie: ClassX.propTypes.a.b.c = ...</span>
        <span class="s4">while </span><span class="s2">(</span>
          <span class="s2">propTypes</span>
          <span class="s2">&amp;&amp; propTypes.parent</span>
          <span class="s2">&amp;&amp; propTypes.parent.type !== </span><span class="s3">'AssignmentExpression'</span>
          <span class="s2">&amp;&amp; propTypes.property</span>
          <span class="s2">&amp;&amp; curDeclaredPropTypes</span>
        <span class="s2">) {</span>
          <span class="s4">const </span><span class="s2">propName = propTypes.property.name;</span>
          <span class="s4">if </span><span class="s2">(propName </span><span class="s4">in </span><span class="s2">curDeclaredPropTypes) {</span>
            <span class="s2">curDeclaredPropTypes = curDeclaredPropTypes[propName].children;</span>
            <span class="s2">propTypes = propTypes.parent;</span>
          <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
            <span class="s0">// This will crash at runtime because we haven't seen this key before</span>
            <span class="s0">// stop this and do not declare it</span>
            <span class="s2">propTypes = </span><span class="s4">null</span><span class="s2">;</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s4">if </span><span class="s2">(propTypes &amp;&amp; propTypes.parent &amp;&amp; propTypes.property) {</span>
          <span class="s4">if </span><span class="s2">(!(propTypes === propTypes.parent.left &amp;&amp; propTypes.parent.left.object)) {</span>
            <span class="s2">ignorePropsValidation = </span><span class="s4">true</span><span class="s2">;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s2">}</span>
          <span class="s4">const </span><span class="s2">parentProp = getText(context, propTypes.parent.left.object).replace(</span><span class="s6">/^.*\.propTypes\./</span><span class="s2">, </span><span class="s3">''</span><span class="s2">);</span>
          <span class="s4">const </span><span class="s2">types = buildReactDeclarationTypes(</span>
            <span class="s2">propTypes.parent.right,</span>
            <span class="s2">parentProp,</span>
            <span class="s2">rootNode</span>
          <span class="s2">);</span>

          <span class="s2">types.name = propTypes.property.name;</span>
          <span class="s2">types.fullName = [parentProp, propTypes.property.name].join(</span><span class="s3">'.'</span><span class="s2">);</span>
          <span class="s2">types.node = propTypes.parent;</span>
          <span class="s2">types.isRequired = propsUtil.isRequiredPropType(propTypes.parent.right);</span>
          <span class="s2">curDeclaredPropTypes[propTypes.property.name] = types;</span>
        <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
          <span class="s4">let </span><span class="s2">isUsedInPropTypes = </span><span class="s4">false</span><span class="s2">;</span>
          <span class="s4">let </span><span class="s2">n = propTypes;</span>
          <span class="s4">while </span><span class="s2">(n) {</span>
            <span class="s4">if </span><span class="s2">(((n.type === </span><span class="s3">'AssignmentExpression'</span><span class="s2">) &amp;&amp; propsUtil.isPropTypesDeclaration(n.left))</span>
              <span class="s2">|| ((n.type === </span><span class="s3">'ClassProperty' </span><span class="s2">|| n.type === </span><span class="s3">'PropertyDefinition' </span><span class="s2">|| n.type === </span><span class="s3">'Property'</span><span class="s2">) &amp;&amp; propsUtil.isPropTypesDeclaration(n))) {</span>
              <span class="s0">// Found a propType used inside of another propType. This is not considered usage, we'll still validate</span>
              <span class="s0">// this component.</span>
              <span class="s2">isUsedInPropTypes = </span><span class="s4">true</span><span class="s2">;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s2">}</span>
            <span class="s2">n = n.parent;</span>
          <span class="s2">}</span>
          <span class="s4">if </span><span class="s2">(!isUsedInPropTypes) {</span>
            <span class="s2">ignorePropsValidation = </span><span class="s4">true</span><span class="s2">;</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s4">case </span><span class="s3">'Identifier'</span><span class="s2">: {</span>
        <span class="s4">const </span><span class="s2">firstMatchingVariable = variableUtil.getVariableFromContext(context, node, propTypes.name);</span>
        <span class="s4">if </span><span class="s2">(firstMatchingVariable) {</span>
          <span class="s4">const </span><span class="s2">defInScope = firstMatchingVariable.defs[firstMatchingVariable.defs.length - </span><span class="s5">1</span><span class="s2">];</span>
          <span class="s2">markPropTypesAsDeclared(node, defInScope.node &amp;&amp; defInScope.node.init, rootNode);</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s2">ignorePropsValidation = </span><span class="s4">true</span><span class="s2">;</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s4">case </span><span class="s3">'CallExpression'</span><span class="s2">: {</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">propWrapperUtil.isPropWrapperFunction(</span>
            <span class="s2">context,</span>
            <span class="s2">getText(context, propTypes.callee)</span>
          <span class="s2">)</span>
          <span class="s2">&amp;&amp; propTypes.arguments &amp;&amp; propTypes.arguments[</span><span class="s5">0</span><span class="s2">]</span>
        <span class="s2">) {</span>
          <span class="s2">markPropTypesAsDeclared(node, propTypes.arguments[</span><span class="s5">0</span><span class="s2">], rootNode);</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s4">case </span><span class="s3">'IntersectionTypeAnnotation'</span><span class="s2">:</span>
        <span class="s2">ignorePropsValidation = declarePropTypesForIntersectionTypeAnnotation(propTypes, declaredPropTypes);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s3">'GenericTypeAnnotation'</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s2">(propTypes.id.name === </span><span class="s3">'$ReadOnly'</span><span class="s2">) {</span>
          <span class="s4">const </span><span class="s2">propTypeArguments = propsUtil.getTypeArguments(propTypes);</span>
          <span class="s2">ignorePropsValidation = declarePropTypesForObjectTypeAnnotation(</span>
            <span class="s2">propTypeArguments.params[</span><span class="s5">0</span><span class="s2">],</span>
            <span class="s2">declaredPropTypes</span>
          <span class="s2">);</span>
        <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
          <span class="s2">ignorePropsValidation = </span><span class="s4">true</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s3">'TSTypeReference'</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">'TSTypeAnnotation'</span><span class="s2">: {</span>
        <span class="s4">const </span><span class="s2">tsTypeAnnotation = </span><span class="s4">new </span><span class="s2">DeclarePropTypesForTSTypeAnnotation(propTypes, declaredPropTypes, rootNode);</span>
        <span class="s2">ignorePropsValidation = tsTypeAnnotation.shouldIgnorePropTypes;</span>
        <span class="s2">declaredPropTypes = tsTypeAnnotation.declaredPropTypes;</span>
      <span class="s2">}</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case null</span><span class="s2">:</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">default</span><span class="s2">:</span>
        <span class="s2">ignorePropsValidation = </span><span class="s4">true</span><span class="s2">;</span>
        <span class="s4">break</span><span class="s2">;</span>
    <span class="s2">}</span>

    <span class="s2">components.set(node, {</span>
      <span class="s2">declaredPropTypes,</span>
      <span class="s2">ignorePropsValidation,</span>
    <span class="s2">});</span>
  <span class="s2">}</span>

  <span class="s0">/**</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node We expect either an ArrowFunctionExpression,</span>
   <span class="s0">*   FunctionDeclaration, or FunctionExpression</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} rootNode</span>
   <span class="s0">*/</span>
  <span class="s4">function </span><span class="s2">markAnnotatedFunctionArgumentsAsDeclared(node, rootNode) {</span>
    <span class="s4">if </span><span class="s2">(!node.params || !node.params.length) {</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s2">}</span>

    <span class="s4">let </span><span class="s2">propTypesArguments = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">if </span><span class="s2">(node.parent) {</span>
      <span class="s2">propTypesArguments = propsUtil.getTypeArguments(node.parent);</span>
    <span class="s2">}</span>

    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">node.parent</span>
      <span class="s2">&amp;&amp; node.parent.callee</span>
      <span class="s2">&amp;&amp; propTypesArguments</span>
      <span class="s2">&amp;&amp; propTypesArguments.params</span>
      <span class="s2">&amp;&amp; (</span>
        <span class="s2">node.parent.callee.name === </span><span class="s3">'forwardRef' </span><span class="s2">|| (</span>
          <span class="s2">node.parent.callee.object</span>
          <span class="s2">&amp;&amp; node.parent.callee.property</span>
          <span class="s2">&amp;&amp; node.parent.callee.object.name === </span><span class="s3">'React'</span>
          <span class="s2">&amp;&amp; node.parent.callee.property.name === </span><span class="s3">'forwardRef'</span>
        <span class="s2">)</span>
      <span class="s2">)</span>
    <span class="s2">) {</span>
      <span class="s4">const </span><span class="s2">declaredPropTypes = {};</span>
      <span class="s4">const </span><span class="s2">obj = </span><span class="s4">new </span><span class="s2">DeclarePropTypesForTSTypeAnnotation(propTypesArguments.params[</span><span class="s5">1</span><span class="s2">], declaredPropTypes, rootNode);</span>
      <span class="s2">components.set(node, {</span>
        <span class="s2">declaredPropTypes: obj.declaredPropTypes,</span>
        <span class="s2">ignorePropsValidation: obj.shouldIgnorePropTypes,</span>
      <span class="s2">});</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s2">}</span>

    <span class="s4">const </span><span class="s2">siblingIdentifier = node.parent &amp;&amp; node.parent.id;</span>
    <span class="s4">const </span><span class="s2">siblingHasTypeAnnotation = siblingIdentifier &amp;&amp; siblingIdentifier.typeAnnotation;</span>
    <span class="s4">const </span><span class="s2">isNodeAnnotated = annotations.isAnnotatedFunctionPropsDeclaration(node, context);</span>

    <span class="s4">if </span><span class="s2">(!isNodeAnnotated &amp;&amp; !siblingHasTypeAnnotation) {</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s2">}</span>

    <span class="s0">// https://github.com/jsx-eslint/eslint-plugin-react/issues/2784</span>
    <span class="s4">if </span><span class="s2">(isInsideClassBody(node) &amp;&amp; !astUtil.isFunction(node)) {</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s2">}</span>

    <span class="s0">// Should ignore function that not return JSXElement</span>
    <span class="s4">if </span><span class="s2">(!utils.isReturningJSXOrNull(node) || startWithCapitalizedLetter(node)) {</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s2">}</span>

    <span class="s4">if </span><span class="s2">(isNodeAnnotated) {</span>
      <span class="s4">const </span><span class="s2">param = node.params[</span><span class="s5">0</span><span class="s2">];</span>
      <span class="s4">if </span><span class="s2">(param.typeAnnotation &amp;&amp; param.typeAnnotation.typeAnnotation &amp;&amp; param.typeAnnotation.typeAnnotation.type === </span><span class="s3">'UnionTypeAnnotation'</span><span class="s2">) {</span>
        <span class="s2">param.typeAnnotation.typeAnnotation.types.forEach((annotation) =&gt; {</span>
          <span class="s4">if </span><span class="s2">(annotation.type === </span><span class="s3">'GenericTypeAnnotation'</span><span class="s2">) {</span>
            <span class="s2">markPropTypesAsDeclared(node, resolveTypeAnnotation(annotation), rootNode);</span>
          <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
            <span class="s2">markPropTypesAsDeclared(node, annotation, rootNode);</span>
          <span class="s2">}</span>
        <span class="s2">});</span>
      <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
        <span class="s2">markPropTypesAsDeclared(node, resolveTypeAnnotation(param), rootNode);</span>
      <span class="s2">}</span>
    <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
      <span class="s0">// implements what's discussed here: https://github.com/jsx-eslint/eslint-plugin-react/issues/2777#issuecomment-683944481</span>
      <span class="s4">const </span><span class="s2">annotation = siblingIdentifier.typeAnnotation.typeAnnotation;</span>

      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">annotation</span>
        <span class="s2">&amp;&amp; annotation.type !== </span><span class="s3">'TSTypeReference'</span>
        <span class="s2">&amp;&amp; propsUtil.getTypeArguments(annotation) == </span><span class="s4">null</span>
      <span class="s2">) {</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s4">if </span><span class="s2">(!isValidReactGenericTypeAnnotation(annotation)) </span><span class="s4">return</span><span class="s2">;</span>

      <span class="s2">markPropTypesAsDeclared(node, resolveTypeAnnotation(siblingIdentifier), rootNode);</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s0">/**</span>
   <span class="s0">* Resolve the type annotation for a given class declaration node.</span>
   <span class="s0">*</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The annotation or a node containing the type annotation.</span>
   <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ASTNode} The resolved type annotation for the node.</span>
   <span class="s0">*/</span>
  <span class="s4">function </span><span class="s2">resolveSuperParameterPropsType(node) {</span>
    <span class="s4">let </span><span class="s2">propsParameterPosition;</span>
    <span class="s4">const </span><span class="s2">parameters = propsUtil.getSuperTypeArguments(node);</span>

    <span class="s4">try </span><span class="s2">{</span>
      <span class="s0">// Flow &lt;=0.52 had 3 required TypedParameters of which the second one is the Props.</span>
      <span class="s0">// Flow &gt;=0.53 has 2 optional TypedParameters of which the first one is the Props.</span>
      <span class="s2">propsParameterPosition = testFlowVersion(context, </span><span class="s3">'&gt;= 0.53.0'</span><span class="s2">) ? </span><span class="s5">0 </span><span class="s2">: </span><span class="s5">1</span><span class="s2">;</span>
    <span class="s2">} </span><span class="s4">catch </span><span class="s2">(e) {</span>
      <span class="s0">// In case there is no flow version defined, we can safely assume that when there are 3 Props we are dealing with version &lt;= 0.52</span>
      <span class="s2">propsParameterPosition = parameters.params.length &lt;= </span><span class="s5">2 </span><span class="s2">? </span><span class="s5">0 </span><span class="s2">: </span><span class="s5">1</span><span class="s2">;</span>
    <span class="s2">}</span>

    <span class="s4">let </span><span class="s2">annotation = parameters.params[propsParameterPosition];</span>
    <span class="s4">while </span><span class="s2">(annotation &amp;&amp; (annotation.type === </span><span class="s3">'TypeAnnotation' </span><span class="s2">|| annotation.type === </span><span class="s3">'NullableTypeAnnotation'</span><span class="s2">)) {</span>
      <span class="s2">annotation = annotation.typeAnnotation;</span>
    <span class="s2">}</span>

    <span class="s4">if </span><span class="s2">(annotation &amp;&amp; annotation.type === </span><span class="s3">'GenericTypeAnnotation' </span><span class="s2">&amp;&amp; getInTypeScope(annotation.id.name)) {</span>
      <span class="s4">return </span><span class="s2">getInTypeScope(annotation.id.name);</span>
    <span class="s2">}</span>
    <span class="s4">return </span><span class="s2">annotation;</span>
  <span class="s2">}</span>

  <span class="s0">/**</span>
   <span class="s0">* Checks if we are declaring a `props` class property with a flow type annotation.</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node being checked.</span>
   <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the node is a type annotated props declaration, false if not.</span>
   <span class="s0">*/</span>
  <span class="s4">function </span><span class="s2">isAnnotatedClassPropsDeclaration(node) {</span>
    <span class="s4">if </span><span class="s2">(node &amp;&amp; (node.type === </span><span class="s3">'ClassProperty' </span><span class="s2">|| node.type === </span><span class="s3">'PropertyDefinition'</span><span class="s2">)) {</span>
      <span class="s4">const </span><span class="s2">tokens = getFirstTokens(context, node, </span><span class="s5">2</span><span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">node.typeAnnotation &amp;&amp; (</span>
          <span class="s2">tokens[</span><span class="s5">0</span><span class="s2">].value === </span><span class="s3">'props'</span>
          <span class="s2">|| (tokens[</span><span class="s5">1</span><span class="s2">] &amp;&amp; tokens[</span><span class="s5">1</span><span class="s2">].value === </span><span class="s3">'props'</span><span class="s2">)</span>
        <span class="s2">)</span>
      <span class="s2">) {</span>
        <span class="s4">return true</span><span class="s2">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">return false</span><span class="s2">;</span>
  <span class="s2">}</span>

  <span class="s4">return </span><span class="s2">{</span>
    <span class="s2">ClassExpression(node) {</span>
      <span class="s0">// TypeParameterDeclaration need to be added to typeScope in order to handle ClassExpressions.</span>
      <span class="s0">// This visitor is executed before TypeParameterDeclaration are scoped, therefore we postpone</span>
      <span class="s0">// processing class expressions until when the program exists.</span>
      <span class="s2">classExpressions.push(node);</span>
    <span class="s2">},</span>

    <span class="s2">ClassDeclaration(node) {</span>
      <span class="s4">if </span><span class="s2">(isSuperTypeParameterPropsDeclaration(node)) {</span>
        <span class="s2">markPropTypesAsDeclared(node, resolveSuperParameterPropsType(node), node);</span>
      <span class="s2">}</span>
    <span class="s2">},</span>

    <span class="s3">'ClassProperty, PropertyDefinition'</span><span class="s2">(node) {</span>
      <span class="s4">if </span><span class="s2">(isAnnotatedClassPropsDeclaration(node)) {</span>
        <span class="s2">markPropTypesAsDeclared(node, resolveTypeAnnotation(node), node);</span>
      <span class="s2">} </span><span class="s4">else if </span><span class="s2">(propsUtil.isPropTypesDeclaration(node)) {</span>
        <span class="s2">markPropTypesAsDeclared(node, node.value, node);</span>
      <span class="s2">}</span>
    <span class="s2">},</span>

    <span class="s2">ObjectExpression(node) {</span>
      <span class="s0">// Search for the proptypes declaration</span>
      <span class="s2">node.properties.forEach((property) =&gt; {</span>
        <span class="s4">if </span><span class="s2">(!propsUtil.isPropTypesDeclaration(property)) {</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s2">markPropTypesAsDeclared(node, property.value, node);</span>
      <span class="s2">});</span>
    <span class="s2">},</span>

    <span class="s2">FunctionExpression(node) {</span>
      <span class="s4">if </span><span class="s2">(node.parent.type !== </span><span class="s3">'MethodDefinition'</span><span class="s2">) {</span>
        <span class="s2">markAnnotatedFunctionArgumentsAsDeclared(node, node);</span>
      <span class="s2">}</span>
    <span class="s2">},</span>

    <span class="s2">ImportDeclaration(node) {</span>
      <span class="s0">// parse `import ... from 'react`</span>
      <span class="s4">if </span><span class="s2">(node.source.value === </span><span class="s3">'react'</span><span class="s2">) {</span>
        <span class="s2">node.specifiers.forEach((specifier) =&gt; {</span>
          <span class="s4">if </span><span class="s2">(</span>
            <span class="s0">// handles import * as X from 'react'</span>
            <span class="s2">specifier.type === </span><span class="s3">'ImportNamespaceSpecifier'</span>
            <span class="s0">// handles import React from 'react'</span>
            <span class="s2">|| specifier.type === </span><span class="s3">'ImportDefaultSpecifier'</span>
          <span class="s2">) {</span>
            <span class="s2">genericReactTypesImport.add(specifier.local.name);</span>
          <span class="s2">}</span>

          <span class="s0">// handles import { FC } from 'react' or import { FC as X } from 'react'</span>
          <span class="s4">if </span><span class="s2">(specifier.type === </span><span class="s3">'ImportSpecifier' </span><span class="s2">&amp;&amp; allowedGenericTypes.has(specifier.imported.name)) {</span>
            <span class="s2">genericReactTypesImport.add(specifier.local.name);</span>
            <span class="s2">localToImportedMap[specifier.local.name] = specifier.imported.name;</span>
          <span class="s2">}</span>
        <span class="s2">});</span>
      <span class="s2">}</span>
    <span class="s2">},</span>

    <span class="s2">FunctionDeclaration: markAnnotatedFunctionArgumentsAsDeclared,</span>

    <span class="s2">ArrowFunctionExpression: markAnnotatedFunctionArgumentsAsDeclared,</span>

    <span class="s2">MemberExpression(node) {</span>
      <span class="s4">if </span><span class="s2">(propsUtil.isPropTypesDeclaration(node)) {</span>
        <span class="s4">const </span><span class="s2">component = utils.getRelatedComponent(node);</span>
        <span class="s4">if </span><span class="s2">(!component) {</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s2">markPropTypesAsDeclared(component.node, node.parent.right || node.parent, node);</span>
        <span class="s2">} </span><span class="s4">catch </span><span class="s2">(e) {</span>
          <span class="s4">if </span><span class="s2">(e.constructor !== RangeError) { </span><span class="s4">throw </span><span class="s2">e; }</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">},</span>

    <span class="s2">MethodDefinition(node) {</span>
      <span class="s4">if </span><span class="s2">(!node.static || node.kind !== </span><span class="s3">'get' </span><span class="s2">|| !propsUtil.isPropTypesDeclaration(node)) {</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s4">let </span><span class="s2">i = node.value.body.body.length - </span><span class="s5">1</span><span class="s2">;</span>
      <span class="s4">for </span><span class="s2">(; i &gt;= </span><span class="s5">0</span><span class="s2">; i--) {</span>
        <span class="s4">if </span><span class="s2">(node.value.body.body[i].type === </span><span class="s3">'ReturnStatement'</span><span class="s2">) {</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>

      <span class="s4">if </span><span class="s2">(i &gt;= </span><span class="s5">0</span><span class="s2">) {</span>
        <span class="s2">markPropTypesAsDeclared(node, node.value.body.body[i].argument, node);</span>
      <span class="s2">}</span>
    <span class="s2">},</span>

    <span class="s2">TypeAlias(node) {</span>
      <span class="s2">setInTypeScope(node.id.name, node.right);</span>
    <span class="s2">},</span>

    <span class="s2">TypeParameterDeclaration(node) {</span>
      <span class="s4">const </span><span class="s2">identifier = node.params[</span><span class="s5">0</span><span class="s2">];</span>

      <span class="s4">if </span><span class="s2">(identifier.typeAnnotation) {</span>
        <span class="s2">setInTypeScope(identifier.name, identifier.typeAnnotation.typeAnnotation);</span>
      <span class="s2">}</span>
    <span class="s2">},</span>

    <span class="s2">Program() {</span>
      <span class="s2">stack = [{}];</span>
    <span class="s2">},</span>

    <span class="s2">BlockStatement() {</span>
      <span class="s2">stack.push(Object.create(typeScope()));</span>
    <span class="s2">},</span>

    <span class="s3">'BlockStatement:exit'</span><span class="s2">() {</span>
      <span class="s2">stack.pop();</span>
    <span class="s2">},</span>

    <span class="s3">'Program:exit'</span><span class="s2">() {</span>
      <span class="s2">classExpressions.forEach((node) =&gt; {</span>
        <span class="s4">if </span><span class="s2">(isSuperTypeParameterPropsDeclaration(node)) {</span>
          <span class="s2">markPropTypesAsDeclared(node, resolveSuperParameterPropsType(node), node);</span>
        <span class="s2">}</span>
      <span class="s2">});</span>
    <span class="s2">},</span>
  <span class="s2">};</span>
<span class="s2">};</span>
</pre>
</body>
</html>