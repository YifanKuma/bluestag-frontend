<html>
<head>
<title>router-reducer-types.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
router-reducer-types.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/client/components/router-reducer/router-reducer-types.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">FlightSegmentPath,</span><span class="s3">\n</span><span class="s1">} from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import type { FetchServerResponseResult } from './fetch-server-response'</span><span class="s3">\n\n</span><span class="s1">export const ACTION_REFRESH = 'refresh'</span><span class="s3">\n</span><span class="s1">export const ACTION_NAVIGATE = 'navigate'</span><span class="s3">\n</span><span class="s1">export const ACTION_RESTORE = 'restore'</span><span class="s3">\n</span><span class="s1">export const ACTION_SERVER_PATCH = 'server-patch'</span><span class="s3">\n</span><span class="s1">export const ACTION_PREFETCH = 'prefetch'</span><span class="s3">\n</span><span class="s1">export const ACTION_HMR_REFRESH = 'hmr-refresh'</span><span class="s3">\n</span><span class="s1">export const ACTION_SERVER_ACTION = 'server-action'</span><span class="s3">\n\n</span><span class="s1">export type RouterChangeByServerResponse = ({</span><span class="s3">\n  </span><span class="s1">navigatedAt,</span><span class="s3">\n  </span><span class="s1">previousTree,</span><span class="s3">\n  </span><span class="s1">serverResponse,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">navigatedAt: number</span><span class="s3">\n  </span><span class="s1">previousTree: FlightRouterState</span><span class="s3">\n  </span><span class="s1">serverResponse: FetchServerResponseResult</span><span class="s3">\n</span><span class="s1">}) =&gt; void</span><span class="s3">\n\n</span><span class="s1">export interface Mutable {</span><span class="s3">\n  </span><span class="s1">mpaNavigation?: boolean</span><span class="s3">\n  </span><span class="s1">patchedTree?: FlightRouterState</span><span class="s3">\n  </span><span class="s1">canonicalUrl?: string</span><span class="s3">\n  </span><span class="s1">scrollableSegments?: FlightSegmentPath[]</span><span class="s3">\n  </span><span class="s1">pendingPush?: boolean</span><span class="s3">\n  </span><span class="s1">cache?: CacheNode</span><span class="s3">\n  </span><span class="s1">prefetchCache?: AppRouterState['prefetchCache']</span><span class="s3">\n  </span><span class="s1">hashFragment?: string</span><span class="s3">\n  </span><span class="s1">shouldScroll?: boolean</span><span class="s3">\n  </span><span class="s1">preserveCustomHistoryState?: boolean</span><span class="s3">\n  </span><span class="s1">onlyHashChange?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface ServerActionMutable extends Mutable {</span><span class="s3">\n  </span><span class="s1">inFlightServerAction?: Promise&lt;any&gt; | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Refresh triggers a refresh of the full page data.</span><span class="s3">\n </span><span class="s1">* - fetches the Flight data and fills rsc at the root of the cache.</span><span class="s3">\n </span><span class="s1">* - The router state is updated at the root.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface RefreshAction {</span><span class="s3">\n  </span><span class="s1">type: typeof ACTION_REFRESH</span><span class="s3">\n  </span><span class="s1">origin: Location['origin']</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface HmrRefreshAction {</span><span class="s3">\n  </span><span class="s1">type: typeof ACTION_HMR_REFRESH</span><span class="s3">\n  </span><span class="s1">origin: Location['origin']</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type ServerActionDispatcher = (</span><span class="s3">\n  </span><span class="s1">args: Omit&lt;</span><span class="s3">\n    </span><span class="s1">ServerActionAction,</span><span class="s3">\n    </span><span class="s1">'type' | 'mutable' | 'navigate' | 'changeByServerResponse' | 'cache'</span><span class="s3">\n  </span><span class="s1">&gt;</span><span class="s3">\n</span><span class="s1">) =&gt; void</span><span class="s3">\n\n</span><span class="s1">export interface ServerActionAction {</span><span class="s3">\n  </span><span class="s1">type: typeof ACTION_SERVER_ACTION</span><span class="s3">\n  </span><span class="s1">actionId: string</span><span class="s3">\n  </span><span class="s1">actionArgs: any[]</span><span class="s3">\n  </span><span class="s1">resolve: (value: any) =&gt; void</span><span class="s3">\n  </span><span class="s1">reject: (reason?: any) =&gt; void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Navigate triggers a navigation to the provided url. It supports two types: `push` and `replace`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* `navigateType`:</span><span class="s3">\n </span><span class="s1">* - `push` - pushes a new history entry in the browser history</span><span class="s3">\n </span><span class="s1">* - `replace` - replaces the current history entry in the browser history</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Navigate has multiple cache heuristics:</span><span class="s3">\n </span><span class="s1">* - page was prefetched</span><span class="s3">\n </span><span class="s1">*  - Apply router state tree from prefetch</span><span class="s3">\n </span><span class="s1">*  - Apply Flight data from prefetch to the cache</span><span class="s3">\n </span><span class="s1">*  - If Flight data is a string, it's a redirect and the state is updated to trigger a redirect</span><span class="s3">\n </span><span class="s1">*  - Check if hard navigation is needed</span><span class="s3">\n </span><span class="s1">*    - Hard navigation happens when a dynamic parameter below the common layout changed</span><span class="s3">\n </span><span class="s1">*    - When hard navigation is needed the cache is invalidated below the flightSegmentPath</span><span class="s3">\n </span><span class="s1">*    - The missing cache nodes of the page will be fetched in layout-router and trigger the SERVER_PATCH action</span><span class="s3">\n </span><span class="s1">*  - If hard navigation is not needed</span><span class="s3">\n </span><span class="s1">*    - The cache is reused</span><span class="s3">\n </span><span class="s1">*    - If any cache nodes are missing they'll be fetched in layout-router and trigger the SERVER_PATCH action</span><span class="s3">\n </span><span class="s1">* - page was not prefetched</span><span class="s3">\n </span><span class="s1">*  - The navigate was called from `next/router` (`router.push()` / `router.replace()`) / `next/link` without prefetched data available (e.g. the prefetch didn't come back from the server before clicking the link)</span><span class="s3">\n </span><span class="s1">*    - Flight data is fetched in the reducer (suspends the reducer)</span><span class="s3">\n </span><span class="s1">*    - Router state tree is created based on Flight data</span><span class="s3">\n </span><span class="s1">*    - Cache is filled based on the Flight data</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Above steps explain 3 cases:</span><span class="s3">\n </span><span class="s1">* - `soft` - Reuses the existing cache and fetches missing nodes in layout-router.</span><span class="s3">\n </span><span class="s1">* - `hard` - Creates a new cache where cache nodes are removed below the common layout and fetches missing nodes in layout-router.</span><span class="s3">\n </span><span class="s1">* - `optimistic` (explicit no prefetch) - Creates a new cache and kicks off the data fetch in the reducer. The data fetch is awaited in the layout-router.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface NavigateAction {</span><span class="s3">\n  </span><span class="s1">type: typeof ACTION_NAVIGATE</span><span class="s3">\n  </span><span class="s1">url: URL</span><span class="s3">\n  </span><span class="s1">isExternalUrl: boolean</span><span class="s3">\n  </span><span class="s1">locationSearch: Location['search']</span><span class="s3">\n  </span><span class="s1">navigateType: 'push' | 'replace'</span><span class="s3">\n  </span><span class="s1">shouldScroll: boolean</span><span class="s3">\n  </span><span class="s1">allowAliasing: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Restore applies the provided router state.</span><span class="s3">\n </span><span class="s1">* - Used for `popstate` (back/forward navigation) where a known router state has to be applied.</span><span class="s3">\n </span><span class="s1">* - Also used when syncing the router state with `pushState`/`replaceState` calls.</span><span class="s3">\n </span><span class="s1">* - Router state is applied as-is from the history state, if available.</span><span class="s3">\n </span><span class="s1">* - If the history state does not contain the router state, the existing router state is used.</span><span class="s3">\n </span><span class="s1">* - If any cache node is missing it will be fetched in layout-router during rendering and the server-patch case.</span><span class="s3">\n </span><span class="s1">* - If existing cache nodes match these are used.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface RestoreAction {</span><span class="s3">\n  </span><span class="s1">type: typeof ACTION_RESTORE</span><span class="s3">\n  </span><span class="s1">url: URL</span><span class="s3">\n  </span><span class="s1">tree: FlightRouterState | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Server-patch applies the provided Flight data to the cache and router tree.</span><span class="s3">\n </span><span class="s1">* - Only triggered in layout-router.</span><span class="s3">\n </span><span class="s1">* - Creates a new cache and router state with the Flight data applied.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface ServerPatchAction {</span><span class="s3">\n  </span><span class="s1">type: typeof ACTION_SERVER_PATCH</span><span class="s3">\n  </span><span class="s1">navigatedAt: number</span><span class="s3">\n  </span><span class="s1">serverResponse: FetchServerResponseResult</span><span class="s3">\n  </span><span class="s1">previousTree: FlightRouterState</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* PrefetchKind defines the type of prefetching that should be done.</span><span class="s3">\n </span><span class="s1">* - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.</span><span class="s3">\n </span><span class="s1">* - `full` - prefetch the page data fully.</span><span class="s3">\n </span><span class="s1">* - `temporary` - a temporary prefetch entry is added to the cache, this is used when prefetch={false} is used in next/link or when you push a route programmatically.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export enum PrefetchKind {</span><span class="s3">\n  </span><span class="s1">AUTO = 'auto',</span><span class="s3">\n  </span><span class="s1">FULL = 'full',</span><span class="s3">\n  </span><span class="s1">TEMPORARY = 'temporary',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Prefetch adds the provided FlightData to the prefetch cache</span><span class="s3">\n </span><span class="s1">* - Creates the router state tree based on the patch in FlightData</span><span class="s3">\n </span><span class="s1">* - Adds the FlightData to the prefetch cache</span><span class="s3">\n </span><span class="s1">* - In ACTION_NAVIGATE the prefetch cache is checked and the router state tree and FlightData are applied.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface PrefetchAction {</span><span class="s3">\n  </span><span class="s1">type: typeof ACTION_PREFETCH</span><span class="s3">\n  </span><span class="s1">url: URL</span><span class="s3">\n  </span><span class="s1">kind: PrefetchKind</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface PushRef {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If the app-router should push a new history entry in app-router's useEffect()</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pendingPush: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Multi-page navigation through location.href.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">mpaNavigation: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Skip applying the router state to the browser history state.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">preserveCustomHistoryState: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type FocusAndScrollRef = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If focus and scroll should be set in the layout-router's useEffect()</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">apply: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The hash fragment that should be scrolled to.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">hashFragment: string | null</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The paths of the segments that should be focused.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">segmentPaths: FlightSegmentPath[]</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If only the URLs hash fragment changed</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">onlyHashChange: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type PrefetchCacheEntry = {</span><span class="s3">\n  </span><span class="s1">treeAtTimeOfPrefetch: FlightRouterState</span><span class="s3">\n  </span><span class="s1">data: Promise&lt;FetchServerResponseResult&gt;</span><span class="s3">\n  </span><span class="s1">kind: PrefetchKind</span><span class="s3">\n  </span><span class="s1">prefetchTime: number</span><span class="s3">\n  </span><span class="s1">staleTime: number</span><span class="s3">\n  </span><span class="s1">lastUsedTime: number | null</span><span class="s3">\n  </span><span class="s1">key: string</span><span class="s3">\n  </span><span class="s1">status: PrefetchCacheEntryStatus</span><span class="s3">\n  </span><span class="s1">url: URL</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export enum PrefetchCacheEntryStatus {</span><span class="s3">\n  </span><span class="s1">fresh = 'fresh',</span><span class="s3">\n  </span><span class="s1">reusable = 'reusable',</span><span class="s3">\n  </span><span class="s1">expired = 'expired',</span><span class="s3">\n  </span><span class="s1">stale = 'stale',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Handles keeping the state of app-router.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type AppRouterState = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The router state, this is written into the history state in app-router using replaceState/pushState.</span><span class="s3">\n   </span><span class="s1">* - Has to be serializable as it is written into the history state.</span><span class="s3">\n   </span><span class="s1">* - Holds which segments and parallel routes are shown on the screen.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">tree: FlightRouterState</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The cache holds React nodes for every segment that is shown on screen as well as previously shown segments.</span><span class="s3">\n   </span><span class="s1">* It also holds in-progress data requests.</span><span class="s3">\n   </span><span class="s1">* Prefetched data is stored separately in `prefetchCache`, that is applied during ACTION_NAVIGATE.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">cache: CacheNode</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Cache that holds prefetched Flight responses keyed by url.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">prefetchCache: Map&lt;string, PrefetchCacheEntry&gt;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Decides if the update should create a new history entry and if the navigation has to trigger a browser navigation.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pushRef: PushRef</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Decides if the update should apply scroll and focus management.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">focusAndScrollRef: FocusAndScrollRef</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The canonical url that is pushed/replaced.</span><span class="s3">\n   </span><span class="s1">* - This is the url you see in the browser.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">canonicalUrl: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The underlying </span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot; </span><span class="s1">representing the UI state, which is used for intercepting routes.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">nextUrl: string | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type ReadonlyReducerState = Readonly&lt;AppRouterState&gt;</span><span class="s3">\n</span><span class="s1">export type ReducerState = Promise&lt;AppRouterState&gt; | AppRouterState</span><span class="s3">\n</span><span class="s1">export type ReducerActions = Readonly&lt;</span><span class="s3">\n  </span><span class="s1">| RefreshAction</span><span class="s3">\n  </span><span class="s1">| NavigateAction</span><span class="s3">\n  </span><span class="s1">| RestoreAction</span><span class="s3">\n  </span><span class="s1">| ServerPatchAction</span><span class="s3">\n  </span><span class="s1">| PrefetchAction</span><span class="s3">\n  </span><span class="s1">| HmrRefreshAction</span><span class="s3">\n  </span><span class="s1">| ServerActionAction</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;ACTION_HMR_REFRESH&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_NAVIGATE&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_PREFETCH&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_REFRESH&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_RESTORE&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_SERVER_ACTION&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_SERVER_PATCH&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchCacheEntryStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchKind&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;;;;;IAYaA,kBAAkB;eAAlBA;;IAJAC,eAAe;eAAfA;;IAGAC,eAAe;eAAfA;;IAJAC,cAAc;eAAdA;;IAEAC,cAAc;eAAdA;;IAIAC,oBAAoB;eAApBA;;IAHAC,mBAAmB;eAAnBA;;IAyMDC,wBAAwB;eAAxBA;;IAhEAC,YAAY;eAAZA;;;AA5IL,MAAML,iBAAiB;AACvB,MAAMF,kBAAkB;AACxB,MAAMG,iBAAiB;AACvB,MAAME,sBAAsB;AAC5B,MAAMJ,kBAAkB;AACxB,MAAMF,qBAAqB;AAC3B,MAAMK,uBAAuB;AAsI7B,IAAA,AAAKG,sCAAAA;;;;WAAAA;;AAgEL,IAAA,AAAKD,kDAAAA;;;;;WAAAA&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>