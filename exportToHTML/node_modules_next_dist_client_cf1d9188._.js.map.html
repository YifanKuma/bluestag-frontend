<html>
<head>
<title>node_modules_next_dist_client_cf1d9188._.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
.s4 { color: #0033b3;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
node_modules_next_dist_client_cf1d9188._.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span>
  <span class="s1">&quot;version&quot;</span><span class="s0">: </span><span class="s2">3</span><span class="s0">,</span>
  <span class="s1">&quot;sources&quot;</span><span class="s0">: [],</span>
  <span class="s1">&quot;sections&quot;</span><span class="s0">: [</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">4</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/set-attributes-from-props.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;const DOMAttributeNames: Record&lt;string, string&gt; = {</span><span class="s3">\n  </span><span class="s1">acceptCharset: 'accept-charset',</span><span class="s3">\n  </span><span class="s1">className: 'class',</span><span class="s3">\n  </span><span class="s1">htmlFor: 'for',</span><span class="s3">\n  </span><span class="s1">httpEquiv: 'http-equiv',</span><span class="s3">\n  </span><span class="s1">noModule: 'noModule',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const ignoreProps = [</span><span class="s3">\n  </span><span class="s1">'onLoad',</span><span class="s3">\n  </span><span class="s1">'onReady',</span><span class="s3">\n  </span><span class="s1">'dangerouslySetInnerHTML',</span><span class="s3">\n  </span><span class="s1">'children',</span><span class="s3">\n  </span><span class="s1">'onError',</span><span class="s3">\n  </span><span class="s1">'strategy',</span><span class="s3">\n  </span><span class="s1">'stylesheets',</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">function isBooleanScriptAttribute(</span><span class="s3">\n  </span><span class="s1">attr: string</span><span class="s3">\n</span><span class="s1">): attr is 'async' | 'defer' | 'noModule' {</span><span class="s3">\n  </span><span class="s1">return ['async', 'defer', 'noModule'].includes(attr)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function setAttributesFromProps(el: HTMLElement, props: object) {</span><span class="s3">\n  </span><span class="s1">for (const [p, value] of Object.entries(props)) {</span><span class="s3">\n    </span><span class="s1">if (!props.hasOwnProperty(p)) continue</span><span class="s3">\n    </span><span class="s1">if (ignoreProps.includes(p)) continue</span><span class="s3">\n\n    </span><span class="s1">// we don't render undefined props to the DOM</span><span class="s3">\n    </span><span class="s1">if (value === undefined) {</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const attr = DOMAttributeNames[p] || p.toLowerCase()</span><span class="s3">\n\n    </span><span class="s1">if (el.tagName === 'SCRIPT' &amp;&amp; isBooleanScriptAttribute(attr)) {</span><span class="s3">\n      </span><span class="s1">// Correctly assign boolean script attributes</span><span class="s3">\n      </span><span class="s1">// https://github.com/vercel/next.js/pull/20748</span><span class="s3">\n      </span><span class="s1">;(el as HTMLScriptElement)[attr] = !!value</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">el.setAttribute(attr, String(value))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Remove falsy non-zero boolean attributes so they are correctly interpreted</span><span class="s3">\n    </span><span class="s1">// (e.g. if we set them to false, this coerces to the string </span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot;</span><span class="s1">, which the browser interprets as true)</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">value === false ||</span><span class="s3">\n      </span><span class="s1">(el.tagName === 'SCRIPT' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isBooleanScriptAttribute(attr) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(!value || value === 'false'))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// Call setAttribute before, as we need to set and unset the attribute to override force async:</span><span class="s3">\n      </span><span class="s1">// https://html.spec.whatwg.org/multipage/scripting.html#script-force-async</span><span class="s3">\n      </span><span class="s1">el.setAttribute(attr, '')</span><span class="s3">\n      </span><span class="s1">el.removeAttribute(attr)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;setAttributesFromProps&quot;</span><span class="s0">,</span><span class="s1">&quot;DOMAttributeNames&quot;</span><span class="s0">,</span><span class="s1">&quot;acceptCharset&quot;</span><span class="s0">,</span><span class="s1">&quot;className&quot;</span><span class="s0">,</span><span class="s1">&quot;htmlFor&quot;</span><span class="s0">,</span><span class="s1">&quot;httpEquiv&quot;</span><span class="s0">,</span><span class="s1">&quot;noModule&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreProps&quot;</span><span class="s0">,</span><span class="s1">&quot;isBooleanScriptAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;attr&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;el&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;p&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;toLowerCase&quot;</span><span class="s0">,</span><span class="s1">&quot;tagName&quot;</span><span class="s0">,</span><span class="s1">&quot;setAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;removeAttribute&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAwBgBA,0BAAAA;;;eAAAA;;;AAxBhB,MAAMC,oBAA4C;IAChDC,eAAe;IACfC,WAAW;IACXC,SAAS;IACTC,WAAW;IACXC,UAAU;AACZ;AAEA,MAAMC,cAAc;IAClB;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAED,SAASC,yBACPC,IAAY;IAEZ,OAAO;QAAC;QAAS;QAAS;KAAW,CAACC,QAAQ,CAACD;AACjD;AAEO,SAAST,uBAAuBW,EAAe,EAAEC,KAAa;IACnE,KAAK,MAAM,CAACC,GAAGC,MAAM,IAAIC,OAAOC,OAAO,CAACJ,OAAQ;QAC9C,IAAI,CAACA,MAAMK,cAAc,CAACJ,IAAI;QAC9B,IAAIN,YAAYG,QAAQ,CAACG,IAAI;QAE7B,6CAA6C;QAC7C,IAAIC,UAAUI,WAAW;YACvB;QACF;QAEA,MAAMT,OAAOR,iBAAiB,CAACY,EAAE,IAAIA,EAAEM,WAAW;QAElD,IAAIR,GAAGS,OAAO,KAAK,YAAYZ,yBAAyBC,OAAO;YAC7D,6CAA6C;YAC7C,+CAA+C;;YAC7CE,EAAwB,CAACF,KAAK,GAAG,CAAC,CAACK;QACvC,OAAO;YACLH,GAAGU,YAAY,CAACZ,MAAMa,OAAOR;QAC/B;QAEA,6EAA6E;QAC7E,2GAA2G;QAC3G,IACEA,UAAU,SACTH,GAAGS,OAAO,KAAK,YACdZ,yBAAyBC,SACxB,CAAA,CAACK,SAASA,UAAU,OAAM,GAC7B;YACA,+FAA+F;YAC/F,2EAA2E;YAC3EH,GAAGU,YAAY,CAACZ,MAAM;YACtBE,GAAGY,eAAe,CAACd;QACrB;IACF;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">74</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/app-bootstrap.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Before starting the Next.js runtime and requiring any module, we need to make</span><span class="s3">\n </span><span class="s1">* sure the following scripts are executed in the correct order:</span><span class="s3">\n </span><span class="s1">* - Polyfills</span><span class="s3">\n </span><span class="s1">* - next/script with `beforeInteractive` strategy</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import { setAttributesFromProps } from './set-attributes-from-props'</span><span class="s3">\n\n</span><span class="s1">const version = process.env.__NEXT_VERSION</span><span class="s3">\n\n</span><span class="s1">window.next = {</span><span class="s3">\n  </span><span class="s1">version,</span><span class="s3">\n  </span><span class="s1">appDir: true,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function loadScriptsInSequence(</span><span class="s3">\n  </span><span class="s1">scripts: [src: string, props: { [prop: string]: any }][],</span><span class="s3">\n  </span><span class="s1">hydrate: () =&gt; void</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!scripts || !scripts.length) {</span><span class="s3">\n    </span><span class="s1">return hydrate()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return scripts</span><span class="s3">\n    </span><span class="s1">.reduce((promise, [src, props]) =&gt; {</span><span class="s3">\n      </span><span class="s1">return promise.then(() =&gt; {</span><span class="s3">\n        </span><span class="s1">return new Promise&lt;void&gt;((resolve, reject) =&gt; {</span><span class="s3">\n          </span><span class="s1">const el = document.createElement('script')</span><span class="s3">\n\n          </span><span class="s1">if (props) {</span><span class="s3">\n            </span><span class="s1">setAttributesFromProps(el, props)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (src) {</span><span class="s3">\n            </span><span class="s1">el.src = src</span><span class="s3">\n            </span><span class="s1">el.onload = () =&gt; resolve()</span><span class="s3">\n            </span><span class="s1">el.onerror = reject</span><span class="s3">\n          </span><span class="s1">} else if (props) {</span><span class="s3">\n            </span><span class="s1">el.innerHTML = props.children</span><span class="s3">\n            </span><span class="s1">setTimeout(resolve)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">document.head.appendChild(el)</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}, Promise.resolve())</span><span class="s3">\n    </span><span class="s1">.catch((err: Error) =&gt; {</span><span class="s3">\n      </span><span class="s1">console.error(err)</span><span class="s3">\n      </span><span class="s1">// Still try to hydrate even if there's an error.</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">.then(() =&gt; {</span><span class="s3">\n      </span><span class="s1">hydrate()</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function appBootstrap(hydrate: () =&gt; void) {</span><span class="s3">\n  </span><span class="s1">loadScriptsInSequence((self as any).__next_s, () =&gt; {</span><span class="s3">\n    </span><span class="s1">// If the static shell is being debugged, skip hydration if the</span><span class="s3">\n    </span><span class="s1">// `__nextppronly` query is present. This is only enabled when the</span><span class="s3">\n    </span><span class="s1">// environment variable `__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING` is</span><span class="s3">\n    </span><span class="s1">// set to `1`. Otherwise the following is optimized out.</span><span class="s3">\n    </span><span class="s1">if (process.env.__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING === '1') {</span><span class="s3">\n      </span><span class="s1">const search = new URLSearchParams(window.location.search)</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">search.get('__nextppronly') === 'fallback' ||</span><span class="s3">\n        </span><span class="s1">search.get('__nextppronly') === '1'</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">console.warn(</span><span class="s3">\n          </span><span class="s1">`Skipping hydration due to __nextppronly=${search.get('__nextppronly')}`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">hydrate()</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;appBootstrap&quot;</span><span class="s0">,</span><span class="s1">&quot;version&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_VERSION&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;appDir&quot;</span><span class="s0">,</span><span class="s1">&quot;loadScriptsInSequence&quot;</span><span class="s0">,</span><span class="s1">&quot;scripts&quot;</span><span class="s0">,</span><span class="s1">&quot;hydrate&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;reduce&quot;</span><span class="s0">,</span><span class="s1">&quot;promise&quot;</span><span class="s0">,</span><span class="s1">&quot;src&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;el&quot;</span><span class="s0">,</span><span class="s1">&quot;document&quot;</span><span class="s0">,</span><span class="s1">&quot;createElement&quot;</span><span class="s0">,</span><span class="s1">&quot;setAttributesFromProps&quot;</span><span class="s0">,</span><span class="s1">&quot;onload&quot;</span><span class="s0">,</span><span class="s1">&quot;onerror&quot;</span><span class="s0">,</span><span class="s1">&quot;innerHTML&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;setTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;appendChild&quot;</span><span class="s0">,</span><span class="s1">&quot;catch&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;self&quot;</span><span class="s0">,</span><span class="s1">&quot;__next_s&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;URLSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;warn&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;;;;CAKC,GAyDOE,QAAQC,GAAG,CAACkC,0CAA0C,KAAK,KAAK;AAzDvE;;;;+BAmDerC,gBAAAA;;;eAAAA;;;wCAjDuB;AAEvC,MAAMC,UAAUC,QAAQC,GAAG,CAACC,cAAc;AAE1CC,OAAOC,IAAI,GAAG;IACZL;IACAM,QAAQ;AACV;AAEA,SAASC,sBACPC,OAAwD,EACxDC,OAAmB;IAEnB,IAAI,CAACD,WAAW,CAACA,QAAQE,MAAM,EAAE;QAC/B,OAAOD;IACT;IAEA,OAAOD,QACJG,MAAM,CAAC,CAACC,SAAAA;YAAS,CAACC,KAAKC,MAAM,GAAA;QAC5B,OAAOF,QAAQG,IAAI,CAAC;YAClB,OAAO,IAAIC,QAAc,CAACC,SAASC;gBACjC,MAAMC,KAAKC,SAASC,aAAa,CAAC;gBAElC,IAAIP,OAAO;oBACTQ,CAAAA,GAAAA,wBAAAA,sBAAsB,EAACH,IAAIL;gBAC7B;gBAEA,IAAID,KAAK;oBACPM,GAAGN,GAAG,GAAGA;oBACTM,GAAGI,MAAM,GAAG,IAAMN;oBAClBE,GAAGK,OAAO,GAAGN;gBACf,OAAO,IAAIJ,OAAO;oBAChBK,GAAGM,SAAS,GAAGX,MAAMY,QAAQ;oBAC7BC,WAAWV;gBACb;gBAEAG,SAASQ,IAAI,CAACC,WAAW,CAACV;YAC5B;QACF;IACF,GAAGH,QAAQC,OAAO,IACjBa,KAAK,CAAC,CAACC;QACNC,QAAQC,KAAK,CAACF;IACd,iDAAiD;IACnD,GACChB,IAAI,CAAC;QACJN;IACF;AACJ;AAEO,SAASV,aAAaU,OAAmB;IAC9CF,sBAAuB2B,KAAaC,QAAQ,EAAE;QAC5C,+DAA+D;QAC/D,kEAAkE;QAClE,uEAAuE;QACvE,wDAAwD;QACxD;;QAaA1B;IACF;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">148</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/react-client-callbacks/report-global-error.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;export const reportGlobalError =</span><span class="s3">\n  </span><span class="s1">typeof reportError === 'function'</span><span class="s3">\n    </span><span class="s1">? // In modern browsers, reportError will dispatch an error event,</span><span class="s3">\n      </span><span class="s1">// emulating an uncaught JavaScript error.</span><span class="s3">\n      </span><span class="s1">reportError</span><span class="s3">\n    </span><span class="s1">: (error: unknown) =&gt; {</span><span class="s3">\n        </span><span class="s1">// TODO: Dispatch error event</span><span class="s3">\n        </span><span class="s1">globalThis.console.error(error)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;reportGlobalError&quot;</span><span class="s0">,</span><span class="s1">&quot;reportError&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;globalThis&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAAaA,qBAAAA;;;eAAAA;;;AAAN,MAAMA,oBACX,OAAOC,gBAAgB,aAEnB,AACAA,cACA,CAACC,2BAFyC;IAGxC,6BAA6B;IAC7BC,WAAWC,OAAO,CAACF,KAAK,CAACA;AAC3B&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">172</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/react-client-callbacks/on-recoverable-error.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// This module can be shared between both pages router and app router</span><span class="s3">\n\n</span><span class="s1">import type { HydrationOptions } from 'react-dom/client'</span><span class="s3">\n</span><span class="s1">import { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'</span><span class="s3">\n</span><span class="s1">import isError from '../../lib/is-error'</span><span class="s3">\n</span><span class="s1">import { reportGlobalError } from './report-global-error'</span><span class="s3">\n\n</span><span class="s1">const recoverableErrors = new WeakSet&lt;Error&gt;()</span><span class="s3">\n\n</span><span class="s1">export function isRecoverableError(error: Error): boolean {</span><span class="s3">\n  </span><span class="s1">return recoverableErrors.has(error)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const onRecoverableError: HydrationOptions['onRecoverableError'] = (</span><span class="s3">\n  </span><span class="s1">error</span><span class="s3">\n</span><span class="s1">) =&gt; {</span><span class="s3">\n  </span><span class="s1">// x-ref: https://github.com/facebook/react/pull/28736</span><span class="s3">\n  </span><span class="s1">let cause = isError(error) &amp;&amp; 'cause' in error ? error.cause : error</span><span class="s3">\n  </span><span class="s1">// Skip certain custom errors which are not expected to be reported on client</span><span class="s3">\n  </span><span class="s1">if (isBailoutToCSRError(cause)) return</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n    </span><span class="s1">const { decorateDevError } =</span><span class="s3">\n      </span><span class="s1">require('../../next-devtools/userspace/app/errors/stitched-error') as typeof import('../../next-devtools/userspace/app/errors/stitched-error')</span><span class="s3">\n    </span><span class="s1">const causeError = decorateDevError(cause)</span><span class="s3">\n    </span><span class="s1">recoverableErrors.add(causeError)</span><span class="s3">\n    </span><span class="s1">cause = causeError</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">reportGlobalError(cause)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;isRecoverableError&quot;</span><span class="s0">,</span><span class="s1">&quot;onRecoverableError&quot;</span><span class="s0">,</span><span class="s1">&quot;recoverableErrors&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakSet&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;cause&quot;</span><span class="s0">,</span><span class="s1">&quot;isError&quot;</span><span class="s0">,</span><span class="s1">&quot;isBailoutToCSRError&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;decorateDevError&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;causeError&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;reportGlobalError&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA,qEAAqE;AAqB/DS,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;;;;;;;;;;;;IAZfX,kBAAkB,EAAA;eAAlBA;;IAIHC,kBAAkB,EAAA;eAAlBA;;;;8BAVuB;kEAChB;mCACc;AAElC,MAAMC,oBAAoB,IAAIC;AAEvB,SAASH,mBAAmBI,KAAY;IAC7C,OAAOF,kBAAkBG,GAAG,CAACD;AAC/B;AAEO,MAAMH,qBAA6D,CACxEG;IAEA,sDAAsD;IACtD,IAAIE,QAAQC,CAAAA,GAAAA,SAAAA,OAAO,EAACH,UAAU,WAAWA,QAAQA,MAAME,KAAK,GAAGF;IAC/D,6EAA6E;IAC7E,IAAII,CAAAA,GAAAA,cAAAA,mBAAmB,EAACF,QAAQ;IAEhC,wCAA2C;QACzC,MAAM,EAAEM,gBAAgB,EAAE,GACxBC,QAAQ;QACV,MAAMC,aAAaF,iBAAiBN;QACpCJ,kBAAkBa,GAAG,CAACD;QACtBR,QAAQQ;IACV;IAEAE,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACV;AACpB&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">228</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/http-access-fallback/http-access-fallback.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;export const HTTPAccessErrorStatus = {</span><span class="s3">\n  </span><span class="s1">NOT_FOUND: 404,</span><span class="s3">\n  </span><span class="s1">FORBIDDEN: 403,</span><span class="s3">\n  </span><span class="s1">UNAUTHORIZED: 401,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus))</span><span class="s3">\n\n</span><span class="s1">export const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK'</span><span class="s3">\n\n</span><span class="s1">export type HTTPAccessFallbackError = Error &amp; {</span><span class="s3">\n  </span><span class="s1">digest: `${typeof HTTP_ERROR_FALLBACK_ERROR_CODE};${string}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks an error to determine if it's an error generated by</span><span class="s3">\n </span><span class="s1">* the HTTP navigation APIs `notFound()`, `forbidden()` or `unauthorized()`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param error the error that may reference a HTTP access error</span><span class="s3">\n </span><span class="s1">* @returns true if the error is a HTTP access error</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isHTTPAccessFallbackError(</span><span class="s3">\n  </span><span class="s1">error: unknown</span><span class="s3">\n</span><span class="s1">): error is HTTPAccessFallbackError {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">typeof error !== 'object' ||</span><span class="s3">\n    </span><span class="s1">error === null ||</span><span class="s3">\n    </span><span class="s1">!('digest' in error) ||</span><span class="s3">\n    </span><span class="s1">typeof error.digest !== 'string'</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const [prefix, httpStatus] = error.digest.split(';')</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">prefix === HTTP_ERROR_FALLBACK_ERROR_CODE &amp;&amp;</span><span class="s3">\n    </span><span class="s1">ALLOWED_CODES.has(Number(httpStatus))</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getAccessFallbackHTTPStatus(</span><span class="s3">\n  </span><span class="s1">error: HTTPAccessFallbackError</span><span class="s3">\n</span><span class="s1">): number {</span><span class="s3">\n  </span><span class="s1">const httpStatus = error.digest.split(';')[1]</span><span class="s3">\n  </span><span class="s1">return Number(httpStatus)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getAccessFallbackErrorTypeByStatus(</span><span class="s3">\n  </span><span class="s1">status: number</span><span class="s3">\n</span><span class="s1">): 'not-found' | 'forbidden' | 'unauthorized' | undefined {</span><span class="s3">\n  </span><span class="s1">switch (status) {</span><span class="s3">\n    </span><span class="s1">case 401:</span><span class="s3">\n      </span><span class="s1">return 'unauthorized'</span><span class="s3">\n    </span><span class="s1">case 403:</span><span class="s3">\n      </span><span class="s1">return 'forbidden'</span><span class="s3">\n    </span><span class="s1">case 404:</span><span class="s3">\n      </span><span class="s1">return 'not-found'</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;HTTPAccessErrorStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;HTTP_ERROR_FALLBACK_ERROR_CODE&quot;</span><span class="s0">,</span><span class="s1">&quot;getAccessFallbackErrorTypeByStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;getAccessFallbackHTTPStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;isHTTPAccessFallbackError&quot;</span><span class="s0">,</span><span class="s1">&quot;NOT_FOUND&quot;</span><span class="s0">,</span><span class="s1">&quot;FORBIDDEN&quot;</span><span class="s0">,</span><span class="s1">&quot;UNAUTHORIZED&quot;</span><span class="s0">,</span><span class="s1">&quot;ALLOWED_CODES&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;digest&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">,</span><span class="s1">&quot;httpStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;Number&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;IAAaA,qBAAqB,EAAA;eAArBA;;IAQAC,8BAA8B,EAAA;eAA9BA;;IAuCGC,kCAAkC,EAAA;eAAlCA;;IAPAC,2BAA2B,EAAA;eAA3BA;;IAnBAC,yBAAyB,EAAA;eAAzBA;;;AArBT,MAAMJ,wBAAwB;IACnCK,WAAW;IACXC,WAAW;IACXC,cAAc;AAChB;AAEA,MAAMC,gBAAgB,IAAIC,IAAIC,OAAOC,MAAM,CAACX;AAErC,MAAMC,iCAAiC;AAavC,SAASG,0BACdQ,KAAc;IAEd,IACE,OAAOA,UAAU,YACjBA,UAAU,QACV,CAAE,CAAA,YAAYA,KAAI,KAClB,OAAOA,MAAMC,MAAM,KAAK,UACxB;QACA,OAAO;IACT;IACA,MAAM,CAACC,QAAQC,WAAW,GAAGH,MAAMC,MAAM,CAACG,KAAK,CAAC;IAEhD,OACEF,WAAWb,kCACXO,cAAcS,GAAG,CAACC,OAAOH;AAE7B;AAEO,SAASZ,4BACdS,KAA8B;IAE9B,MAAMG,aAAaH,MAAMC,MAAM,CAACG,KAAK,CAAC,IAAI,CAAC,EAAE;IAC7C,OAAOE,OAAOH;AAChB;AAEO,SAASb,mCACdiB,MAAc;IAEd,OAAQA;QACN,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT;YACE;IACJ;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">302</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/redirect-status-code.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;export enum RedirectStatusCode {</span><span class="s3">\n  </span><span class="s1">SeeOther = 303,</span><span class="s3">\n  </span><span class="s1">TemporaryRedirect = 307,</span><span class="s3">\n  </span><span class="s1">PermanentRedirect = 308,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;RedirectStatusCode&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAAYA,sBAAAA;;;eAAAA;;;AAAL,IAAKA,qBAAAA,WAAAA,GAAAA,SAAAA,kBAAAA;;;;WAAAA&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">328</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/redirect-error.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { RedirectStatusCode } from './redirect-status-code'</span><span class="s3">\n\n</span><span class="s1">export const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT'</span><span class="s3">\n\n</span><span class="s1">export enum RedirectType {</span><span class="s3">\n  </span><span class="s1">push = 'push',</span><span class="s3">\n  </span><span class="s1">replace = 'replace',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RedirectError = Error &amp; {</span><span class="s3">\n  </span><span class="s1">digest: `${typeof REDIRECT_ERROR_CODE};${RedirectType};${string};${RedirectStatusCode};`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks an error to determine if it's an error generated by the</span><span class="s3">\n </span><span class="s1">* `redirect(url)` helper.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param error the error that may reference a redirect error</span><span class="s3">\n </span><span class="s1">* @returns true if the error is a redirect error</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isRedirectError(error: unknown): error is RedirectError {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">typeof error !== 'object' ||</span><span class="s3">\n    </span><span class="s1">error === null ||</span><span class="s3">\n    </span><span class="s1">!('digest' in error) ||</span><span class="s3">\n    </span><span class="s1">typeof error.digest !== 'string'</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const digest = error.digest.split(';')</span><span class="s3">\n  </span><span class="s1">const [errorCode, type] = digest</span><span class="s3">\n  </span><span class="s1">const destination = digest.slice(2, -2).join(';')</span><span class="s3">\n  </span><span class="s1">const status = digest.at(-2)</span><span class="s3">\n\n  </span><span class="s1">const statusCode = Number(status)</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">errorCode === REDIRECT_ERROR_CODE &amp;&amp;</span><span class="s3">\n    </span><span class="s1">(type === 'replace' || type === 'push') &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof destination === 'string' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!isNaN(statusCode) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">statusCode in RedirectStatusCode</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;REDIRECT_ERROR_CODE&quot;</span><span class="s0">,</span><span class="s1">&quot;RedirectType&quot;</span><span class="s0">,</span><span class="s1">&quot;isRedirectError&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;digest&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;errorCode&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;destination&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;at&quot;</span><span class="s0">,</span><span class="s1">&quot;statusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;Number&quot;</span><span class="s0">,</span><span class="s1">&quot;isNaN&quot;</span><span class="s0">,</span><span class="s1">&quot;RedirectStatusCode&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;IAEaA,mBAAmB,EAAA;eAAnBA;;IAEDC,YAAY,EAAA;eAAZA;;IAgBIC,eAAe,EAAA;eAAfA;;;oCApBmB;AAE5B,MAAMF,sBAAsB;AAE5B,IAAKC,eAAAA,WAAAA,GAAAA,SAAAA,YAAAA;;;WAAAA;;AAgBL,SAASC,gBAAgBC,KAAc;IAC5C,IACE,OAAOA,UAAU,YACjBA,UAAU,QACV,CAAE,CAAA,YAAYA,KAAI,KAClB,OAAOA,MAAMC,MAAM,KAAK,UACxB;QACA,OAAO;IACT;IAEA,MAAMA,SAASD,MAAMC,MAAM,CAACC,KAAK,CAAC;IAClC,MAAM,CAACC,WAAWC,KAAK,GAAGH;IAC1B,MAAMI,cAAcJ,OAAOK,KAAK,CAAC,GAAG,CAAC,GAAGC,IAAI,CAAC;IAC7C,MAAMC,SAASP,OAAOQ,EAAE,CAAC,CAAC;IAE1B,MAAMC,aAAaC,OAAOH;IAE1B,OACEL,cAAcN,uBACbO,CAAAA,SAAS,aAAaA,SAAS,MAAK,KACrC,OAAOC,gBAAgB,YACvB,CAACO,MAAMF,eACPA,cAAcG,oBAAAA,kBAAkB;AAEpC&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">382</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/is-next-router-error.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">isHTTPAccessFallbackError,</span><span class="s3">\n  </span><span class="s1">type HTTPAccessFallbackError,</span><span class="s3">\n</span><span class="s1">} from './http-access-fallback/http-access-fallback'</span><span class="s3">\n</span><span class="s1">import { isRedirectError, type RedirectError } from './redirect-error'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns true if the error is a navigation signal error. These errors are</span><span class="s3">\n </span><span class="s1">* thrown by user code to perform navigation operations and interrupt the React</span><span class="s3">\n </span><span class="s1">* render.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isNextRouterError(</span><span class="s3">\n  </span><span class="s1">error: unknown</span><span class="s3">\n</span><span class="s1">): error is RedirectError | HTTPAccessFallbackError {</span><span class="s3">\n  </span><span class="s1">return isRedirectError(error) || isHTTPAccessFallbackError(error)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;isNextRouterError&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;isRedirectError&quot;</span><span class="s0">,</span><span class="s1">&quot;isHTTPAccessFallbackError&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAWgBA,qBAAAA;;;eAAAA;;;oCART;+BAC6C;AAO7C,SAASA,kBACdC,KAAc;IAEd,OAAOC,CAAAA,GAAAA,eAAAA,eAAe,EAACD,UAAUE,CAAAA,GAAAA,oBAAAA,yBAAyB,EAACF;AAC7D&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">407</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/lib/console.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import isError from '../../lib/is-error'</span><span class="s3">\n\n</span><span class="s1">function formatObject(arg: unknown, depth: number) {</span><span class="s3">\n  </span><span class="s1">switch (typeof arg) {</span><span class="s3">\n    </span><span class="s1">case 'object':</span><span class="s3">\n      </span><span class="s1">if (arg === null) {</span><span class="s3">\n        </span><span class="s1">return 'null'</span><span class="s3">\n      </span><span class="s1">} else if (Array.isArray(arg)) {</span><span class="s3">\n        </span><span class="s1">let result = '['</span><span class="s3">\n        </span><span class="s1">if (depth &lt; 1) {</span><span class="s3">\n          </span><span class="s1">for (let i = 0; i &lt; arg.length; i++) {</span><span class="s3">\n            </span><span class="s1">if (result !== '[') {</span><span class="s3">\n              </span><span class="s1">result += ','</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (Object.prototype.hasOwnProperty.call(arg, i)) {</span><span class="s3">\n              </span><span class="s1">result += formatObject(arg[i], depth + 1)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">result += arg.length &gt; 0 ? '...' : ''</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">result += ']'</span><span class="s3">\n        </span><span class="s1">return result</span><span class="s3">\n      </span><span class="s1">} else if (arg instanceof Error) {</span><span class="s3">\n        </span><span class="s1">return arg + ''</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">const keys = Object.keys(arg)</span><span class="s3">\n        </span><span class="s1">let result = '{'</span><span class="s3">\n        </span><span class="s1">if (depth &lt; 1) {</span><span class="s3">\n          </span><span class="s1">for (let i = 0; i &lt; keys.length; i++) {</span><span class="s3">\n            </span><span class="s1">const key = keys[i]</span><span class="s3">\n            </span><span class="s1">const desc = Object.getOwnPropertyDescriptor(arg, 'key')</span><span class="s3">\n            </span><span class="s1">if (desc &amp;&amp; !desc.get &amp;&amp; !desc.set) {</span><span class="s3">\n              </span><span class="s1">const jsonKey = JSON.stringify(key)</span><span class="s3">\n              </span><span class="s1">if (jsonKey !== '</span><span class="s3">\&quot;</span><span class="s1">' + key + '</span><span class="s3">\&quot;</span><span class="s1">') {</span><span class="s3">\n                </span><span class="s1">result += jsonKey + ': '</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">result += key + ': '</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">result += formatObject(desc.value, depth + 1)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">result += keys.length &gt; 0 ? '...' : ''</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">result += '}'</span><span class="s3">\n        </span><span class="s1">return result</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case 'string':</span><span class="s3">\n      </span><span class="s1">return JSON.stringify(arg)</span><span class="s3">\n    </span><span class="s1">case 'number':</span><span class="s3">\n    </span><span class="s1">case 'bigint':</span><span class="s3">\n    </span><span class="s1">case 'boolean':</span><span class="s3">\n    </span><span class="s1">case 'symbol':</span><span class="s3">\n    </span><span class="s1">case 'undefined':</span><span class="s3">\n    </span><span class="s1">case 'function':</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">return String(arg)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function formatConsoleArgs(args: unknown[]): string {</span><span class="s3">\n  </span><span class="s1">let message: string</span><span class="s3">\n  </span><span class="s1">let idx: number</span><span class="s3">\n  </span><span class="s1">if (typeof args[0] === 'string') {</span><span class="s3">\n    </span><span class="s1">message = args[0]</span><span class="s3">\n    </span><span class="s1">idx = 1</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">message = ''</span><span class="s3">\n    </span><span class="s1">idx = 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">let result = ''</span><span class="s3">\n  </span><span class="s1">let startQuote = false</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; message.length; ++i) {</span><span class="s3">\n    </span><span class="s1">const char = message[i]</span><span class="s3">\n    </span><span class="s1">if (char !== '%' || i === message.length - 1 || idx &gt;= args.length) {</span><span class="s3">\n      </span><span class="s1">result += char</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const code = message[++i]</span><span class="s3">\n    </span><span class="s1">switch (code) {</span><span class="s3">\n      </span><span class="s1">case 'c': {</span><span class="s3">\n        </span><span class="s1">// TODO: We should colorize with HTML instead of turning into a string.</span><span class="s3">\n        </span><span class="s1">// Ignore for now.</span><span class="s3">\n        </span><span class="s1">result = startQuote ? `${result}]` : `[${result}`</span><span class="s3">\n        </span><span class="s1">startQuote = !startQuote</span><span class="s3">\n        </span><span class="s1">idx++</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'O':</span><span class="s3">\n      </span><span class="s1">case 'o': {</span><span class="s3">\n        </span><span class="s1">result += formatObject(args[idx++], 0)</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'd':</span><span class="s3">\n      </span><span class="s1">case 'i': {</span><span class="s3">\n        </span><span class="s1">result += parseInt(args[idx++] as any, 10)</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'f': {</span><span class="s3">\n        </span><span class="s1">result += parseFloat(args[idx++] as any)</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 's': {</span><span class="s3">\n        </span><span class="s1">result += String(args[idx++])</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">result += '%' + code</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (; idx &lt; args.length; idx++) {</span><span class="s3">\n    </span><span class="s1">result += (idx &gt; 0 ? ' ' : '') + formatObject(args[idx], 0)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return result</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function parseConsoleArgs(args: unknown[]): {</span><span class="s3">\n  </span><span class="s1">environmentName: string | null</span><span class="s3">\n  </span><span class="s1">error: Error | null</span><span class="s3">\n</span><span class="s1">} {</span><span class="s3">\n  </span><span class="s1">// See</span><span class="s3">\n  </span><span class="s1">// https://github.com/facebook/react/blob/65a56d0e99261481c721334a3ec4561d173594cd/packages/react-devtools-shared/src/backend/flight/renderer.js#L88-L93</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Logs replayed from the server look like this:</span><span class="s3">\n  </span><span class="s1">// [</span><span class="s3">\n  </span><span class="s1">//   </span><span class="s3">\&quot;</span><span class="s1">%c%s%c%o</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n%s</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n%s</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">//   </span><span class="s3">\&quot;</span><span class="s1">background: #e6e6e6; ...</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">//   </span><span class="s3">\&quot; </span><span class="s1">Server </span><span class="s3">\&quot;</span><span class="s1">, // can also be e.g. </span><span class="s3">\&quot; </span><span class="s1">Prerender </span><span class="s3">\&quot;\n  </span><span class="s1">//   </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">//   Error,</span><span class="s3">\n  </span><span class="s1">//   </span><span class="s3">\&quot;</span><span class="s1">The above error occurred in the &lt;Page&gt; component.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">//   ...</span><span class="s3">\n  </span><span class="s1">// ]</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">args.length &gt; 3 &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof args[0] === 'string' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">args[0].startsWith('%c%s%c') &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof args[1] === 'string' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof args[2] === 'string' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof args[3] === 'string'</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const environmentName = args[2]</span><span class="s3">\n    </span><span class="s1">const maybeError = args[4]</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">environmentName: environmentName.trim(),</span><span class="s3">\n      </span><span class="s1">error: isError(maybeError) ? maybeError : null,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">environmentName: null,</span><span class="s3">\n    </span><span class="s1">error: null,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;formatConsoleArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;parseConsoleArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;formatObject&quot;</span><span class="s0">,</span><span class="s1">&quot;arg&quot;</span><span class="s0">,</span><span class="s1">&quot;depth&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;desc&quot;</span><span class="s0">,</span><span class="s1">&quot;getOwnPropertyDescriptor&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;jsonKey&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;idx&quot;</span><span class="s0">,</span><span class="s1">&quot;startQuote&quot;</span><span class="s0">,</span><span class="s1">&quot;char&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;parseInt&quot;</span><span class="s0">,</span><span class="s1">&quot;parseFloat&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;environmentName&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeError&quot;</span><span class="s0">,</span><span class="s1">&quot;trim&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;isError&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">586</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/app-globals.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// imports polyfill from `@next/polyfill-module` after build.</span><span class="s3">\n</span><span class="s1">import '../build/polyfills/polyfill-module'</span><span class="s3">\n\n</span><span class="s1">// Only setup devtools in development</span><span class="s3">\n</span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n  </span><span class="s1">require('../next-devtools/userspace/app/app-dev-overlay-setup') as typeof import('../next-devtools/userspace/app/app-dev-overlay-setup')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA,6DAA6D;AAIzDA,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;;AAD7B,qCAAqC;AACrC,wCAA2C;;AAE3C&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">608</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/app-router-headers.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;export const RSC_HEADER = 'rsc' as const</span><span class="s3">\n</span><span class="s1">export const ACTION_HEADER = 'next-action' as const</span><span class="s3">\n</span><span class="s1">// TODO: Instead of sending the full router state, we only need to send the</span><span class="s3">\n</span><span class="s1">// segment path. Saves bytes. Then we could also use this field for segment</span><span class="s3">\n</span><span class="s1">// prefetches, which also need to specify a particular segment.</span><span class="s3">\n</span><span class="s1">export const NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch' as const</span><span class="s3">\n</span><span class="s1">// This contains the path to the segment being prefetched.</span><span class="s3">\n</span><span class="s1">// TODO: If we change next-router-state-tree to be a segment path, we can use</span><span class="s3">\n</span><span class="s1">// that instead. Then next-router-prefetch and next-router-segment-prefetch can</span><span class="s3">\n</span><span class="s1">// be merged into a single enum.</span><span class="s3">\n</span><span class="s1">export const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER =</span><span class="s3">\n  </span><span class="s1">'next-router-segment-prefetch' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_URL = 'next-url' as const</span><span class="s3">\n</span><span class="s1">export const RSC_CONTENT_TYPE_HEADER = 'text/x-component' as const</span><span class="s3">\n\n</span><span class="s1">export const FLIGHT_HEADERS = [</span><span class="s3">\n  </span><span class="s1">RSC_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_STATE_TREE_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_PREFETCH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_HMR_REFRESH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,</span><span class="s3">\n</span><span class="s1">] as const</span><span class="s3">\n\n</span><span class="s1">export const NEXT_RSC_UNION_QUERY = '_rsc' as const</span><span class="s3">\n\n</span><span class="s1">export const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found' as const</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;ACTION_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;FLIGHT_HEADERS&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ACTION_NOT_FOUND_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_DID_POSTPONE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_HMR_REFRESH_HASH_COOKIE&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_HMR_REFRESH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_IS_PRERENDER_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_REWRITTEN_PATH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_REWRITTEN_QUERY_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_PREFETCH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_SEGMENT_PREFETCH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_STALE_TIME_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_STATE_TREE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_RSC_UNION_QUERY&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_URL&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_CONTENT_TYPE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_HEADER&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IACaA,aAAa,EAAA;eAAbA;;IAiBAC,cAAc,EAAA;eAAdA;;IAeAC,4BAA4B,EAAA;eAA5BA;;IAJAC,wBAAwB,EAAA;eAAxBA;;IAfAC,4BAA4B,EAAA;eAA5BA;;IADAC,uBAAuB,EAAA;eAAvBA;;IAmBAC,wBAAwB,EAAA;eAAxBA;;IAFAC,0BAA0B,EAAA;eAA1BA;;IACAC,2BAA2B,EAAA;eAA3BA;;IAzBAC,2BAA2B,EAAA;eAA3BA;;IAKAC,mCAAmC,EAAA;eAAnCA;;IAiBAC,6BAA6B,EAAA;eAA7BA;;IAvBAC,6BAA6B,EAAA;eAA7BA;;IAqBAC,oBAAoB,EAAA;eAApBA;;IAXAC,QAAQ,EAAA;eAARA;;IACAC,uBAAuB,EAAA;eAAvBA;;IAhBAC,UAAU,EAAA;eAAVA;;;AAAN,MAAMA,aAAa;AACnB,MAAMhB,gBAAgB;AAItB,MAAMY,gCAAgC;AACtC,MAAMH,8BAA8B;AAKpC,MAAMC,sCACX;AACK,MAAML,0BAA0B;AAChC,MAAMD,+BAA+B;AACrC,MAAMU,WAAW;AACjB,MAAMC,0BAA0B;AAEhC,MAAMd,iBAAiB;IAC5Be;IACAJ;IACAH;IACAJ;IACAK;CACD;AAEM,MAAMG,uBAAuB;AAE7B,MAAMF,gCAAgC;AACtC,MAAMR,2BAA2B;AACjC,MAAMI,6BAA6B;AACnC,MAAMC,8BAA8B;AACpC,MAAMF,2BAA2B;AACjC,MAAMJ,+BAA+B&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">723</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/navigation-untracked.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { useContext } from 'react'</span><span class="s3">\n</span><span class="s1">import { PathnameContext } from '../../shared/lib/hooks-client-context.shared-runtime'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This checks to see if the current render has any unknown route parameters.</span><span class="s3">\n </span><span class="s1">* It's used to trigger a different render path in the error boundary.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @returns true if there are any unknown route parameters, false otherwise</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function hasFallbackRouteParams(): boolean {</span><span class="s3">\n  </span><span class="s1">if (typeof window === 'undefined') {</span><span class="s3">\n    </span><span class="s1">// AsyncLocalStorage should not be included in the client bundle.</span><span class="s3">\n    </span><span class="s1">const { workUnitAsyncStorage } =</span><span class="s3">\n      </span><span class="s1">require('../../server/app-render/work-unit-async-storage.external') as typeof import('../../server/app-render/work-unit-async-storage.external')</span><span class="s3">\n\n    </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n    </span><span class="s1">if (!workUnitStore) return false</span><span class="s3">\n\n    </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n      </span><span class="s1">case 'prerender':</span><span class="s3">\n      </span><span class="s1">case 'prerender-client':</span><span class="s3">\n      </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n        </span><span class="s1">const fallbackParams = workUnitStore.fallbackRouteParams</span><span class="s3">\n        </span><span class="s1">return fallbackParams ? fallbackParams.size &gt; 0 : false</span><span class="s3">\n      </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n      </span><span class="s1">case 'request':</span><span class="s3">\n      </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n      </span><span class="s1">case 'cache':</span><span class="s3">\n      </span><span class="s1">case 'private-cache':</span><span class="s3">\n      </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This returns a `null` value if there are any unknown route parameters, and</span><span class="s3">\n </span><span class="s1">* otherwise returns the pathname from the context. This is an alternative to</span><span class="s3">\n </span><span class="s1">* `usePathname` that is used in the error boundary to avoid rendering the</span><span class="s3">\n </span><span class="s1">* error boundary when there are unknown route parameters. This doesn't throw</span><span class="s3">\n </span><span class="s1">* when accessed with unknown route parameters.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @returns</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @internal</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function useUntrackedPathname(): string | null {</span><span class="s3">\n  </span><span class="s1">// If there are any unknown route parameters we would typically throw</span><span class="s3">\n  </span><span class="s1">// an error, but this internal method allows us to return a null value instead</span><span class="s3">\n  </span><span class="s1">// for components that do not propagate the pathname to the static shell (like</span><span class="s3">\n  </span><span class="s1">// the error boundary).</span><span class="s3">\n  </span><span class="s1">if (hasFallbackRouteParams()) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// This shouldn't cause any issues related to conditional rendering because</span><span class="s3">\n  </span><span class="s1">// the environment will be consistent for the render.</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line react-hooks/rules-of-hooks</span><span class="s3">\n  </span><span class="s1">return useContext(PathnameContext)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;useUntrackedPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;hasFallbackRouteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitStore&quot;</span><span class="s0">,</span><span class="s1">&quot;getStore&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackParams&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackRouteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;useContext&quot;</span><span class="s0">,</span><span class="s1">&quot;PathnameContext&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAoDgBA,wBAAAA;;;eAAAA;;;uBApDW;iDACK;AAEhC;;;;;CAKC,GACD,SAASC;IACP,IAAI,OAAOC,WAAW,aAAa;QACjC,iEAAiE;QACjE,MAAM,EAAEC,oBAAoB,EAAE,GAC5BC,QAAQ;QAEV,MAAMC,gBAAgBF,qBAAqBG,QAAQ;QACnD,IAAI,CAACD,eAAe,OAAO;QAE3B,OAAQA,cAAcE,IAAI;YACxB,KAAK;YACL,KAAK;YACL,KAAK;gBACH,MAAMC,iBAAiBH,cAAcI,mBAAmB;gBACxD,OAAOD,iBAAiBA,eAAeE,IAAI,GAAG,IAAI;YACpD,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBACH;YACF;gBACEL;QACJ;QAEA,OAAO;IACT;IAEA,OAAO;AACT;AAaO,SAASL;IACd,qEAAqE;IACrE,8EAA8E;IAC9E,8EAA8E;IAC9E,uBAAuB;IACvB,IAAIC,0BAA0B;QAC5B,OAAO;IACT;IAEA,2EAA2E;IAC3E,qDAAqD;IACrD,sDAAsD;IACtD,OAAOU,CAAAA,GAAAA,OAAAA,UAAU,EAACC,iCAAAA,eAAe;AACnC&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">789</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/create-href-from-url.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;export function createHrefFromUrl(</span><span class="s3">\n  </span><span class="s1">url: Pick&lt;URL, 'pathname' | 'search' | 'hash'&gt;,</span><span class="s3">\n  </span><span class="s1">includeHash: boolean = true</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">return url.pathname + url.search + (includeHash ? url.hash : '')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;createHrefFromUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;includeHash&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;hash&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAAgBA,qBAAAA;;;eAAAA;;;AAAT,SAASA,kBACdC,GAA8C,EAC9CC,WAA2B;IAA3BA,IAAAA,gBAAAA,KAAAA,GAAAA,cAAuB;IAEvB,OAAOD,IAAIE,QAAQ,GAAGF,IAAIG,MAAM,GAAIF,CAAAA,cAAcD,IAAII,IAAI,GAAG,EAAC;AAChE&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">813</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/nav-failure-handler.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { useEffect } from 'react'</span><span class="s3">\n</span><span class="s1">import { createHrefFromUrl } from './router-reducer/create-href-from-url'</span><span class="s3">\n\n</span><span class="s1">export function handleHardNavError(error: unknown): boolean {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">error &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof window !== 'undefined' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">window.next.__pendingUrl &amp;&amp;</span><span class="s3">\n    </span><span class="s1">createHrefFromUrl(new URL(window.location.href)) !==</span><span class="s3">\n      </span><span class="s1">createHrefFromUrl(window.next.__pendingUrl)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">console.error(</span><span class="s3">\n      </span><span class="s1">`Error occurred during navigation, falling back to hard navigation`,</span><span class="s3">\n      </span><span class="s1">error</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">window.location.href = window.next.__pendingUrl.toString()</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function useNavFailureHandler() {</span><span class="s3">\n  </span><span class="s1">if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {</span><span class="s3">\n    </span><span class="s1">// this if is only for DCE of the feature flag not conditional</span><span class="s3">\n    </span><span class="s1">// eslint-disable-next-line react-hooks/rules-of-hooks</span><span class="s3">\n    </span><span class="s1">useEffect(() =&gt; {</span><span class="s3">\n      </span><span class="s1">const uncaughtExceptionHandler = (</span><span class="s3">\n        </span><span class="s1">evt: ErrorEvent | PromiseRejectionEvent</span><span class="s3">\n      </span><span class="s1">) =&gt; {</span><span class="s3">\n        </span><span class="s1">const error = 'reason' in evt ? evt.reason : evt.error</span><span class="s3">\n        </span><span class="s1">// if we have an unhandled exception/rejection during</span><span class="s3">\n        </span><span class="s1">// a navigation we fall back to a hard navigation to</span><span class="s3">\n        </span><span class="s1">// attempt recovering to a good state</span><span class="s3">\n        </span><span class="s1">handleHardNavError(error)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">window.addEventListener('unhandledrejection', uncaughtExceptionHandler)</span><span class="s3">\n      </span><span class="s1">window.addEventListener('error', uncaughtExceptionHandler)</span><span class="s3">\n      </span><span class="s1">return () =&gt; {</span><span class="s3">\n        </span><span class="s1">window.removeEventListener('error', uncaughtExceptionHandler)</span><span class="s3">\n        </span><span class="s1">window.removeEventListener(</span><span class="s3">\n          </span><span class="s1">'unhandledrejection',</span><span class="s3">\n          </span><span class="s1">uncaughtExceptionHandler</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, [])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;handleHardNavError&quot;</span><span class="s0">,</span><span class="s1">&quot;useNavFailureHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;__pendingUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;createHrefFromUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_APP_NAV_FAIL_HANDLING&quot;</span><span class="s0">,</span><span class="s1">&quot;useEffect&quot;</span><span class="s0">,</span><span class="s1">&quot;uncaughtExceptionHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;evt&quot;</span><span class="s0">,</span><span class="s1">&quot;reason&quot;</span><span class="s0">,</span><span class="s1">&quot;addEventListener&quot;</span><span class="s0">,</span><span class="s1">&quot;removeEventListener&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAsBMY,QAAQC,GAAG,CAACC,4BAA4B,EAAE;;;;;;;;;;;;;;;;IAnBhCd,kBAAkB,EAAA;eAAlBA;;IAkBAC,oBAAoB,EAAA;eAApBA;;;uBArBU;mCACQ;AAE3B,SAASD,mBAAmBE,KAAc;IAC/C,IACEA,SACA,OAAOC,WAAW,eAClBA,OAAOC,IAAI,CAACC,YAAY,IACxBC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAAC,IAAIC,IAAIJ,OAAOK,QAAQ,CAACC,IAAI,OAC5CH,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACH,OAAOC,IAAI,CAACC,YAAY,GAC5C;QACAK,QAAQR,KAAK,CACV,qEACDA;QAEFC,OAAOK,QAAQ,CAACC,IAAI,GAAGN,OAAOC,IAAI,CAACC,YAAY,CAACM,QAAQ;QACxD,OAAO;IACT;IACA,OAAO;AACT;AAEO,SAASV;IACd;;AAwBF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">861</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/handle-isr-error.tsx&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;const workAsyncStorage =</span><span class="s3">\n  </span><span class="s1">typeof window === 'undefined'</span><span class="s3">\n    </span><span class="s1">? (</span><span class="s3">\n        </span><span class="s1">require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')</span><span class="s3">\n      </span><span class="s1">).workAsyncStorage</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n\n</span><span class="s1">// if we are revalidating we want to re-throw the error so the</span><span class="s3">\n</span><span class="s1">// function crashes so we can maintain our previous cache</span><span class="s3">\n</span><span class="s1">// instead of caching the error page</span><span class="s3">\n</span><span class="s1">export function HandleISRError({ error }: { error: any }) {</span><span class="s3">\n  </span><span class="s1">if (workAsyncStorage) {</span><span class="s3">\n    </span><span class="s1">const store = workAsyncStorage.getStore()</span><span class="s3">\n    </span><span class="s1">if (store?.isRevalidate || store?.isStaticGeneration) {</span><span class="s3">\n      </span><span class="s1">console.error(error)</span><span class="s3">\n      </span><span class="s1">throw error</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;HandleISRError&quot;</span><span class="s0">,</span><span class="s1">&quot;workAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;store&quot;</span><span class="s0">,</span><span class="s1">&quot;getStore&quot;</span><span class="s0">,</span><span class="s1">&quot;isRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;isStaticGeneration&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAUgBA,kBAAAA;;;eAAAA;;;AAVhB,MAAMC,mBACJ,OAAOC,WAAW,cAEZC,QAAQ,+HACRF,gBAAgB,GAClBG;AAKC,SAASJ,eAAe,KAAyB;IAAzB,IAAA,EAAEK,KAAK,EAAkB,GAAzB;IAC7B,IAAIJ,kBAAkB;QACpB,MAAMK,QAAQL,iBAAiBM,QAAQ;QACvC,IAAID,CAAAA,SAAAA,OAAAA,KAAAA,IAAAA,MAAOE,YAAY,KAAA,CAAIF,SAAAA,OAAAA,KAAAA,IAAAA,MAAOG,kBAAkB,GAAE;YACpDC,QAAQL,KAAK,CAACA;YACd,MAAMA;QACR;IACF;IAEA,OAAO;AACT&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">893</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/error-boundary.tsx&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;'use client'</span><span class="s3">\n\n</span><span class="s1">import React, { type JSX } from 'react'</span><span class="s3">\n</span><span class="s1">import { useUntrackedPathname } from './navigation-untracked'</span><span class="s3">\n</span><span class="s1">import { isNextRouterError } from './is-next-router-error'</span><span class="s3">\n</span><span class="s1">import { handleHardNavError } from './nav-failure-handler'</span><span class="s3">\n</span><span class="s1">import { HandleISRError } from './handle-isr-error'</span><span class="s3">\n</span><span class="s1">import { isBot } from '../../shared/lib/router/utils/is-bot'</span><span class="s3">\n\n</span><span class="s1">const isBotUserAgent =</span><span class="s3">\n  </span><span class="s1">typeof window !== 'undefined' &amp;&amp; isBot(window.navigator.userAgent)</span><span class="s3">\n\n</span><span class="s1">export type ErrorComponent = React.ComponentType&lt;{</span><span class="s3">\n  </span><span class="s1">error: Error</span><span class="s3">\n  </span><span class="s1">// global-error, there's no `reset` function;</span><span class="s3">\n  </span><span class="s1">// regular error boundary, there's a `reset` function.</span><span class="s3">\n  </span><span class="s1">reset?: () =&gt; void</span><span class="s3">\n</span><span class="s1">}&gt;</span><span class="s3">\n\n</span><span class="s1">export interface ErrorBoundaryProps {</span><span class="s3">\n  </span><span class="s1">children?: React.ReactNode</span><span class="s3">\n  </span><span class="s1">errorComponent: ErrorComponent | undefined</span><span class="s3">\n  </span><span class="s1">errorStyles?: React.ReactNode | undefined</span><span class="s3">\n  </span><span class="s1">errorScripts?: React.ReactNode | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface ErrorBoundaryHandlerProps extends ErrorBoundaryProps {</span><span class="s3">\n  </span><span class="s1">pathname: string | null</span><span class="s3">\n  </span><span class="s1">errorComponent: ErrorComponent</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface ErrorBoundaryHandlerState {</span><span class="s3">\n  </span><span class="s1">error: Error | null</span><span class="s3">\n  </span><span class="s1">previousPathname: string | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class ErrorBoundaryHandler extends React.Component&lt;</span><span class="s3">\n  </span><span class="s1">ErrorBoundaryHandlerProps,</span><span class="s3">\n  </span><span class="s1">ErrorBoundaryHandlerState</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">constructor(props: ErrorBoundaryHandlerProps) {</span><span class="s3">\n    </span><span class="s1">super(props)</span><span class="s3">\n    </span><span class="s1">this.state = { error: null, previousPathname: this.props.pathname }</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static getDerivedStateFromError(error: Error) {</span><span class="s3">\n    </span><span class="s1">if (isNextRouterError(error)) {</span><span class="s3">\n      </span><span class="s1">// Re-throw if an expected internal Next.js router error occurs</span><span class="s3">\n      </span><span class="s1">// this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)</span><span class="s3">\n      </span><span class="s1">throw error</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return { error }</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static getDerivedStateFromProps(</span><span class="s3">\n    </span><span class="s1">props: ErrorBoundaryHandlerProps,</span><span class="s3">\n    </span><span class="s1">state: ErrorBoundaryHandlerState</span><span class="s3">\n  </span><span class="s1">): ErrorBoundaryHandlerState | null {</span><span class="s3">\n    </span><span class="s1">const { error } = state</span><span class="s3">\n\n    </span><span class="s1">// if we encounter an error while</span><span class="s3">\n    </span><span class="s1">// a navigation is pending we shouldn't render</span><span class="s3">\n    </span><span class="s1">// the error boundary and instead should fallback</span><span class="s3">\n    </span><span class="s1">// to a hard navigation to attempt recovering</span><span class="s3">\n    </span><span class="s1">if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {</span><span class="s3">\n      </span><span class="s1">if (error &amp;&amp; handleHardNavError(error)) {</span><span class="s3">\n        </span><span class="s1">// clear error so we don't render anything</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">error: null,</span><span class="s3">\n          </span><span class="s1">previousPathname: props.pathname,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handles reset of the error boundary when a navigation happens.</span><span class="s3">\n     </span><span class="s1">* Ensures the error boundary does not stay enabled when navigating to a new page.</span><span class="s3">\n     </span><span class="s1">* Approach of setState in render is safe as it checks the previous pathname and then overrides</span><span class="s3">\n     </span><span class="s1">* it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (props.pathname !== state.previousPathname &amp;&amp; state.error) {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">error: null,</span><span class="s3">\n        </span><span class="s1">previousPathname: props.pathname,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">error: state.error,</span><span class="s3">\n      </span><span class="s1">previousPathname: props.pathname,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">reset = () =&gt; {</span><span class="s3">\n    </span><span class="s1">this.setState({ error: null })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.</span><span class="s3">\n  </span><span class="s1">render(): React.ReactNode {</span><span class="s3">\n    </span><span class="s1">//When it's bot request, segment level error boundary will keep rendering the children,</span><span class="s3">\n    </span><span class="s1">// the final error will be caught by the root error boundary and determine wether need to apply graceful degrade.</span><span class="s3">\n    </span><span class="s1">if (this.state.error &amp;&amp; !isBotUserAgent) {</span><span class="s3">\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">&lt;&gt;</span><span class="s3">\n          </span><span class="s1">&lt;HandleISRError error={this.state.error} /&gt;</span><span class="s3">\n          </span><span class="s1">{this.props.errorStyles}</span><span class="s3">\n          </span><span class="s1">{this.props.errorScripts}</span><span class="s3">\n          </span><span class="s1">&lt;this.props.errorComponent</span><span class="s3">\n            </span><span class="s1">error={this.state.error}</span><span class="s3">\n            </span><span class="s1">reset={this.reset}</span><span class="s3">\n          </span><span class="s1">/&gt;</span><span class="s3">\n        </span><span class="s1">&lt;/&gt;</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.props.children</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Handles errors through `getDerivedStateFromError`.</span><span class="s3">\n </span><span class="s1">* Renders the provided error component and provides a way to `reset` the error boundary state.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Renders error boundary with the provided </span><span class="s3">\&quot;</span><span class="s1">errorComponent</span><span class="s3">\&quot; </span><span class="s1">property as the fallback.</span><span class="s3">\n </span><span class="s1">* If no </span><span class="s3">\&quot;</span><span class="s1">errorComponent</span><span class="s3">\&quot; </span><span class="s1">property is provided it renders the children without an error boundary.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function ErrorBoundary({</span><span class="s3">\n  </span><span class="s1">errorComponent,</span><span class="s3">\n  </span><span class="s1">errorStyles,</span><span class="s3">\n  </span><span class="s1">errorScripts,</span><span class="s3">\n  </span><span class="s1">children,</span><span class="s3">\n</span><span class="s1">}: ErrorBoundaryProps &amp; {</span><span class="s3">\n  </span><span class="s1">children: React.ReactNode</span><span class="s3">\n</span><span class="s1">}): JSX.Element {</span><span class="s3">\n  </span><span class="s1">// When we're rendering the missing params shell, this will return null. This</span><span class="s3">\n  </span><span class="s1">// is because we won't be rendering any not found boundaries or error</span><span class="s3">\n  </span><span class="s1">// boundaries for the missing params shell. When this runs on the client</span><span class="s3">\n  </span><span class="s1">// (where these errors can occur), we will get the correct pathname.</span><span class="s3">\n  </span><span class="s1">const pathname = useUntrackedPathname()</span><span class="s3">\n  </span><span class="s1">if (errorComponent) {</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">&lt;ErrorBoundaryHandler</span><span class="s3">\n        </span><span class="s1">pathname={pathname}</span><span class="s3">\n        </span><span class="s1">errorComponent={errorComponent}</span><span class="s3">\n        </span><span class="s1">errorStyles={errorStyles}</span><span class="s3">\n        </span><span class="s1">errorScripts={errorScripts}</span><span class="s3">\n      </span><span class="s1">&gt;</span><span class="s3">\n        </span><span class="s1">{children}</span><span class="s3">\n      </span><span class="s1">&lt;/ErrorBoundaryHandler&gt;</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return &lt;&gt;{children}&lt;/&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;ErrorBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;ErrorBoundaryHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;isBotUserAgent&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;isBot&quot;</span><span class="s0">,</span><span class="s1">&quot;navigator&quot;</span><span class="s0">,</span><span class="s1">&quot;userAgent&quot;</span><span class="s0">,</span><span class="s1">&quot;React&quot;</span><span class="s0">,</span><span class="s1">&quot;Component&quot;</span><span class="s0">,</span><span class="s1">&quot;getDerivedStateFromError&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;isNextRouterError&quot;</span><span class="s0">,</span><span class="s1">&quot;getDerivedStateFromProps&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_APP_NAV_FAIL_HANDLING&quot;</span><span class="s0">,</span><span class="s1">&quot;handleHardNavError&quot;</span><span class="s0">,</span><span class="s1">&quot;previousPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;render&quot;</span><span class="s0">,</span><span class="s1">&quot;HandleISRError&quot;</span><span class="s0">,</span><span class="s1">&quot;errorStyles&quot;</span><span class="s0">,</span><span class="s1">&quot;errorScripts&quot;</span><span class="s0">,</span><span class="s1">&quot;this&quot;</span><span class="s0">,</span><span class="s1">&quot;errorComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;reset&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;setState&quot;</span><span class="s0">,</span><span class="s1">&quot;useUntrackedPathname&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAiEQe,QAAQC,GAAG,CAACC,4BAA4B,EAAE;AAjElD;;;;;;;;;;;;;;;;IAgIgBjB,aAAa,EAAA;eAAbA;;IA5FHC,oBAAoB,EAAA;eAApBA;;;;;gEAlCmB;qCACK;mCACH;mCACC;gCACJ;uBACT;AAEtB,MAAMC,iBACJ,OAAOC,WAAW,eAAeC,CAAAA,GAAAA,OAAAA,KAAK,EAACD,OAAOE,SAAS,CAACC,SAAS;AA0B5D,MAAML,6BAA6BM,OAAAA,OAAK,CAACC,SAAS;IASvD,OAAOC,yBAAyBC,KAAY,EAAE;QAC5C,IAAIC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACD,QAAQ;YAC5B,+DAA+D;YAC/D,4GAA4G;YAC5G,MAAMA;QACR;QAEA,OAAO;YAAEA;QAAM;IACjB;IAEA,OAAOE,yBACLC,KAAgC,EAChCC,KAAgC,EACE;QAClC,MAAM,EAAEJ,KAAK,EAAE,GAAGI;QAElB,iCAAiC;QACjC,8CAA8C;QAC9C,iDAAiD;QACjD,6CAA6C;QAC7C;;QAUA;;;;;KAKC,GACD,IAAID,MAAMO,QAAQ,KAAKN,MAAMK,gBAAgB,IAAIL,MAAMJ,KAAK,EAAE;YAC5D,OAAO;gBACLA,OAAO;gBACPS,kBAAkBN,MAAMO,QAAQ;YAClC;QACF;QACA,OAAO;YACLV,OAAOI,MAAMJ,KAAK;YAClBS,kBAAkBN,MAAMO,QAAQ;QAClC;IACF;IAMA,yIAAyI;IACzIC,SAA0B;QACxB,uFAAuF;QACvF,iHAAiH;QACjH,IAAI,IAAI,CAACP,KAAK,CAACJ,KAAK,IAAI,CAACR,gBAAgB;YACvC,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,IAAA,EAAA,YAAA,QAAA,EAAA;;kCACE,CAAA,GAAA,YAAA,GAAA,EAACoB,gBAAAA,cAAc,EAAA;wBAACZ,OAAO,IAAI,CAACI,KAAK,CAACJ,KAAK;;oBACtC,IAAI,CAACG,KAAK,CAACU,WAAW;oBACtB,IAAI,CAACV,KAAK,CAACW,YAAY;kCACxB,CAAA,GAAA,YAAA,GAAA,EAACC,IAAI,CAACZ,KAAK,CAACa,cAAc,EAAA;wBACxBhB,OAAO,IAAI,CAACI,KAAK,CAACJ,KAAK;wBACvBiB,OAAO,IAAI,CAACA,KAAK;;;;QAIzB;QAEA,OAAO,IAAI,CAACd,KAAK,CAACe,QAAQ;IAC5B;IA5EAC,YAAYhB,KAAgC,CAAE;QAC5C,KAAK,CAACA,QAAAA,IAAAA,CAoDRc,KAAAA,GAAQ;YACN,IAAI,CAACG,QAAQ,CAAC;gBAAEpB,OAAO;YAAK;QAC9B;QArDE,IAAI,CAACI,KAAK,GAAG;YAAEJ,OAAO;YAAMS,kBAAkB,IAAI,CAACN,KAAK,CAACO,QAAQ;QAAC;IACpE;AA0EF;AAWO,SAASpB,cAAc,KAO7B;IAP6B,IAAA,EAC5B0B,cAAc,EACdH,WAAW,EACXC,YAAY,EACZI,QAAQ,EAGT,GAP6B;IAQ5B,6EAA6E;IAC7E,qEAAqE;IACrE,wEAAwE;IACxE,oEAAoE;IACpE,MAAMR,WAAWW,CAAAA,GAAAA,qBAAAA,oBAAoB;IACrC,IAAIL,gBAAgB;QAClB,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACzB,sBAAAA;YACCmB,UAAUA;YACVM,gBAAgBA;YAChBH,aAAaA;YACbC,cAAcA;sBAEbI;;IAGP;IAEA,OAAA,WAAA,GAAO,CAAA,GAAA,YAAA,GAAA,EAAA,YAAA,QAAA,EAAA;kBAAGA;;AACZ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1025</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/builtin/global-error.tsx&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;'use client'</span><span class="s3">\n\n</span><span class="s1">import { HandleISRError } from '../handle-isr-error'</span><span class="s3">\n\n</span><span class="s1">const styles = {</span><span class="s3">\n  </span><span class="s1">error: {</span><span class="s3">\n    </span><span class="s1">// https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52</span><span class="s3">\n    </span><span class="s1">fontFamily:</span><span class="s3">\n      </span><span class="s1">'system-ui,</span><span class="s3">\&quot;</span><span class="s1">Segoe UI</span><span class="s3">\&quot;</span><span class="s1">,Roboto,Helvetica,Arial,sans-serif,</span><span class="s3">\&quot;</span><span class="s1">Apple Color Emoji</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">Segoe UI Emoji</span><span class="s3">\&quot;</span><span class="s1">',</span><span class="s3">\n    </span><span class="s1">height: '100vh',</span><span class="s3">\n    </span><span class="s1">textAlign: 'center',</span><span class="s3">\n    </span><span class="s1">display: 'flex',</span><span class="s3">\n    </span><span class="s1">flexDirection: 'column',</span><span class="s3">\n    </span><span class="s1">alignItems: 'center',</span><span class="s3">\n    </span><span class="s1">justifyContent: 'center',</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">text: {</span><span class="s3">\n    </span><span class="s1">fontSize: '14px',</span><span class="s3">\n    </span><span class="s1">fontWeight: 400,</span><span class="s3">\n    </span><span class="s1">lineHeight: '28px',</span><span class="s3">\n    </span><span class="s1">margin: '0 8px',</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">export type GlobalErrorComponent = React.ComponentType&lt;{</span><span class="s3">\n  </span><span class="s1">error: any</span><span class="s3">\n</span><span class="s1">}&gt;</span><span class="s3">\n</span><span class="s1">function DefaultGlobalError({ error }: { error: any }) {</span><span class="s3">\n  </span><span class="s1">const digest: string | undefined = error?.digest</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">&lt;html id=</span><span class="s3">\&quot;</span><span class="s1">__next_error__</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\n      </span><span class="s1">&lt;head&gt;&lt;/head&gt;</span><span class="s3">\n      </span><span class="s1">&lt;body&gt;</span><span class="s3">\n        </span><span class="s1">&lt;HandleISRError error={error} /&gt;</span><span class="s3">\n        </span><span class="s1">&lt;div style={styles.error}&gt;</span><span class="s3">\n          </span><span class="s1">&lt;div&gt;</span><span class="s3">\n            </span><span class="s1">&lt;h2 style={styles.text}&gt;</span><span class="s3">\n              </span><span class="s1">Application error: a {digest ? 'server' : 'client'}-side exception</span><span class="s3">\n              </span><span class="s1">has occurred while loading {window.location.hostname} (see the{' '}</span><span class="s3">\n              </span><span class="s1">{digest ? 'server logs' : 'browser console'} for more</span><span class="s3">\n              </span><span class="s1">information).</span><span class="s3">\n            </span><span class="s1">&lt;/h2&gt;</span><span class="s3">\n            </span><span class="s1">{digest ? &lt;p style={styles.text}&gt;{`Digest: ${digest}`}&lt;/p&gt; : null}</span><span class="s3">\n          </span><span class="s1">&lt;/div&gt;</span><span class="s3">\n        </span><span class="s1">&lt;/div&gt;</span><span class="s3">\n      </span><span class="s1">&lt;/body&gt;</span><span class="s3">\n    </span><span class="s1">&lt;/html&gt;</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Exported so that the import signature in the loaders can be identical to user</span><span class="s3">\n</span><span class="s1">// supplied custom global error signatures.</span><span class="s3">\n</span><span class="s1">export default DefaultGlobalError</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;styles&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;fontFamily&quot;</span><span class="s0">,</span><span class="s1">&quot;height&quot;</span><span class="s0">,</span><span class="s1">&quot;textAlign&quot;</span><span class="s0">,</span><span class="s1">&quot;display&quot;</span><span class="s0">,</span><span class="s1">&quot;flexDirection&quot;</span><span class="s0">,</span><span class="s1">&quot;alignItems&quot;</span><span class="s0">,</span><span class="s1">&quot;justifyContent&quot;</span><span class="s0">,</span><span class="s1">&quot;text&quot;</span><span class="s0">,</span><span class="s1">&quot;fontSize&quot;</span><span class="s0">,</span><span class="s1">&quot;fontWeight&quot;</span><span class="s0">,</span><span class="s1">&quot;lineHeight&quot;</span><span class="s0">,</span><span class="s1">&quot;margin&quot;</span><span class="s0">,</span><span class="s1">&quot;DefaultGlobalError&quot;</span><span class="s0">,</span><span class="s1">&quot;digest&quot;</span><span class="s0">,</span><span class="s1">&quot;html&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;HandleISRError&quot;</span><span class="s0">,</span><span class="s1">&quot;div&quot;</span><span class="s0">,</span><span class="s1">&quot;style&quot;</span><span class="s0">,</span><span class="s1">&quot;h2&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;hostname&quot;</span><span class="s0">,</span><span class="s1">&quot;p&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAmDA,AADA,2CAC2C,qCADqC;AAEhF,WAAA;;;eAAA;;;;gCAlD+B;AAE/B,MAAMA,SAAS;IACbC,OAAO;QACL,0FAA0F;QAC1FC,YACE;QACFC,QAAQ;QACRC,WAAW;QACXC,SAAS;QACTC,eAAe;QACfC,YAAY;QACZC,gBAAgB;IAClB;IACAC,MAAM;QACJC,UAAU;QACVC,YAAY;QACZC,YAAY;QACZC,QAAQ;IACV;AACF;AAKA,SAASC,mBAAmB,KAAyB;IAAzB,IAAA,EAAEb,KAAK,EAAkB,GAAzB;IAC1B,MAAMc,SAA6Bd,SAAAA,OAAAA,KAAAA,IAAAA,MAAOc,MAAM;IAChD,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,IAAA,EAACC,QAAAA;QAAKC,IAAG;;0BACP,CAAA,GAAA,YAAA,GAAA,EAACC,QAAAA,CAAAA;0BACD,CAAA,GAAA,YAAA,IAAA,EAACC,QAAAA;;kCACC,CAAA,GAAA,YAAA,GAAA,EAACC,gBAAAA,cAAc,EAAA;wBAACnB,OAAOA;;kCACvB,CAAA,GAAA,YAAA,GAAA,EAACoB,OAAAA;wBAAIC,OAAOtB,OAAOC,KAAK;kCACtB,WAAA,GAAA,CAAA,GAAA,YAAA,IAAA,EAACoB,OAAAA;;8CACC,CAAA,GAAA,YAAA,IAAA,EAACE,MAAAA;oCAAGD,OAAOtB,OAAOS,IAAI;;wCAAE;wCACAM,SAAS,WAAW;wCAAS;wCACvBS,OAAOC,QAAQ,CAACC,QAAQ;wCAAC;wCAAU;wCAC9DX,SAAS,gBAAgB;wCAAkB;;;gCAG7CA,SAAAA,WAAAA,GAAS,CAAA,GAAA,YAAA,GAAA,EAACY,KAAAA;oCAAEL,OAAOtB,OAAOS,IAAI;8CAAI,aAAUM;qCAAgB;;;;;;;;AAMzE;MAIA,WAAeD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1108</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/dev/runtime-error-handler.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;export const RuntimeErrorHandler = {</span><span class="s3">\n  </span><span class="s1">hadRuntimeError: false,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;RuntimeErrorHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;hadRuntimeError&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAAaA,uBAAAA;;;eAAAA;;;AAAN,MAAMA,sBAAsB;IACjCC,iBAAiB;AACnB&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1131</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/not-found.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">HTTP_ERROR_FALLBACK_ERROR_CODE,</span><span class="s3">\n  </span><span class="s1">type HTTPAccessFallbackError,</span><span class="s3">\n</span><span class="s1">} from './http-access-fallback/http-access-fallback'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function allows you to render the [not-found.js file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)</span><span class="s3">\n </span><span class="s1">* within a route segment as well as inject a tag.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* `notFound()` can be used in</span><span class="s3">\n </span><span class="s1">* [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),</span><span class="s3">\n </span><span class="s1">* [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and</span><span class="s3">\n </span><span class="s1">* [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* - In a Server Component, this will insert a `&lt;meta name=</span><span class="s3">\&quot;</span><span class="s1">robots</span><span class="s3">\&quot; </span><span class="s1">content=</span><span class="s3">\&quot;</span><span class="s1">noindex</span><span class="s3">\&quot; </span><span class="s1">/&gt;` meta tag and set the status code to 404.</span><span class="s3">\n </span><span class="s1">* - In a Route Handler or Server Action, it will serve a 404 to the caller.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Read more: [Next.js Docs: `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">const DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};404`</span><span class="s3">\n\n</span><span class="s1">export function notFound(): never {</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line no-throw-literal</span><span class="s3">\n  </span><span class="s1">const error = new Error(DIGEST) as HTTPAccessFallbackError</span><span class="s3">\n  </span><span class="s1">;(error as HTTPAccessFallbackError).digest = DIGEST</span><span class="s3">\n\n  </span><span class="s1">throw error</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;notFound&quot;</span><span class="s0">,</span><span class="s1">&quot;DIGEST&quot;</span><span class="s0">,</span><span class="s1">&quot;HTTP_ERROR_FALLBACK_ERROR_CODE&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;digest&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAsBgBA,YAAAA;;;eAAAA;;;oCAnBT;AAEP;;;;;;;;;;;;;CAaC,GAED,MAAMC,SAAU,KAAEC,oBAAAA,8BAA8B,GAAC;AAE1C,SAASF;IACd,4CAA4C;IAC5C,MAAMG,QAAQ,OAAA,cAAiB,CAAjB,IAAIC,MAAMH,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BE,MAAkCE,MAAM,GAAGJ;IAE7C,MAAME;AACR&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1176</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/react-client-callbacks/error-boundary-callbacks.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// This file is only used in app router due to the specific error state handling.</span><span class="s3">\n\n</span><span class="s1">import type { ErrorInfo } from 'react'</span><span class="s3">\n</span><span class="s1">import { isNextRouterError } from '../components/is-next-router-error'</span><span class="s3">\n</span><span class="s1">import { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'</span><span class="s3">\n</span><span class="s1">import { reportGlobalError } from './report-global-error'</span><span class="s3">\n</span><span class="s1">import { ErrorBoundaryHandler } from '../components/error-boundary'</span><span class="s3">\n</span><span class="s1">import DefaultErrorBoundary from '../components/builtin/global-error'</span><span class="s3">\n\n</span><span class="s1">const devToolErrorMod: typeof import('../../next-devtools/userspace/app/errors') =</span><span class="s3">\n  </span><span class="s1">process.env.NODE_ENV !== 'production'</span><span class="s3">\n    </span><span class="s1">? (require('../../next-devtools/userspace/app/errors') as typeof import('../../next-devtools/userspace/app/errors'))</span><span class="s3">\n    </span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">decorateDevError: (error: unknown) =&gt; error as Error,</span><span class="s3">\n        </span><span class="s1">handleClientError: () =&gt; {},</span><span class="s3">\n        </span><span class="s1">originConsoleError: console.error.bind(console),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function onCaughtError(</span><span class="s3">\n  </span><span class="s1">thrownValue: unknown,</span><span class="s3">\n  </span><span class="s1">errorInfo: ErrorInfo &amp; { errorBoundary?: React.Component }</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const errorBoundaryComponent = errorInfo.errorBoundary?.constructor</span><span class="s3">\n\n  </span><span class="s1">let isImplicitErrorBoundary</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n    </span><span class="s1">const { AppDevOverlayErrorBoundary } =</span><span class="s3">\n      </span><span class="s1">require('../../next-devtools/userspace/app/app-dev-overlay-error-boundary') as typeof import('../../next-devtools/userspace/app/app-dev-overlay-error-boundary')</span><span class="s3">\n\n    </span><span class="s1">isImplicitErrorBoundary =</span><span class="s3">\n      </span><span class="s1">errorBoundaryComponent === AppDevOverlayErrorBoundary</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">isImplicitErrorBoundary =</span><span class="s3">\n    </span><span class="s1">isImplicitErrorBoundary ||</span><span class="s3">\n    </span><span class="s1">(errorBoundaryComponent === ErrorBoundaryHandler &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(errorInfo.errorBoundary! as InstanceType&lt;typeof ErrorBoundaryHandler&gt;)</span><span class="s3">\n        </span><span class="s1">.props.errorComponent === DefaultErrorBoundary)</span><span class="s3">\n\n  </span><span class="s1">// Skip the segment explorer triggered error</span><span class="s3">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n    </span><span class="s1">const { SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE } =</span><span class="s3">\n      </span><span class="s1">require('../../next-devtools/userspace/app/segment-explorer-node') as typeof import('../../next-devtools/userspace/app/segment-explorer-node')</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">thrownValue instanceof Error &amp;&amp;</span><span class="s3">\n      </span><span class="s1">thrownValue.message === SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (isImplicitErrorBoundary) {</span><span class="s3">\n    </span><span class="s1">// We don't consider errors caught unless they're caught by an explicit error</span><span class="s3">\n    </span><span class="s1">// boundary. The built-in ones are considered implicit.</span><span class="s3">\n    </span><span class="s1">// This mimics how the same app would behave without Next.js.</span><span class="s3">\n    </span><span class="s1">return onUncaughtError(thrownValue)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Skip certain custom errors which are not expected to be reported on client</span><span class="s3">\n  </span><span class="s1">if (isBailoutToCSRError(thrownValue) || isNextRouterError(thrownValue)) return</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n    </span><span class="s1">const errorBoundaryName =</span><span class="s3">\n      </span><span class="s1">// read react component displayName</span><span class="s3">\n      </span><span class="s1">(errorBoundaryComponent as any)?.displayName ||</span><span class="s3">\n      </span><span class="s1">errorBoundaryComponent?.name ||</span><span class="s3">\n      </span><span class="s1">'Unknown'</span><span class="s3">\n\n    </span><span class="s1">const componentThatErroredFrame = errorInfo?.componentStack?.split('</span><span class="s3">\\</span><span class="s1">n')[1]</span><span class="s3">\n\n    </span><span class="s1">// Match chrome or safari stack trace</span><span class="s3">\n    </span><span class="s1">const matches =</span><span class="s3">\n      </span><span class="s1">// regex to match the function name in the stack trace</span><span class="s3">\n      </span><span class="s1">// example 1: at Page (http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1)</span><span class="s3">\n      </span><span class="s1">// example 2: Page@http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1</span><span class="s3">\n      </span><span class="s1">componentThatErroredFrame?.match(/</span><span class="s3">\\</span><span class="s1">s+at (</span><span class="s3">\\</span><span class="s1">w+)</span><span class="s3">\\</span><span class="s1">s+|(</span><span class="s3">\\</span><span class="s1">w+)@/) ?? []</span><span class="s3">\n    </span><span class="s1">const componentThatErroredName = matches[1] || matches[2] || 'Unknown'</span><span class="s3">\n\n    </span><span class="s1">// Create error location with errored component and error boundary, to match the behavior of default React onCaughtError handler.</span><span class="s3">\n    </span><span class="s1">const errorBoundaryMessage = `It was handled by the &lt;${errorBoundaryName}&gt; error boundary.`</span><span class="s3">\n    </span><span class="s1">const componentErrorMessage = componentThatErroredName</span><span class="s3">\n      </span><span class="s1">? `The above error occurred in the &lt;${componentThatErroredName}&gt; component.`</span><span class="s3">\n      </span><span class="s1">: `The above error occurred in one of your components.`</span><span class="s3">\n\n    </span><span class="s1">const errorLocation = `${componentErrorMessage} ${errorBoundaryMessage}`</span><span class="s3">\n    </span><span class="s1">const error = devToolErrorMod.decorateDevError(thrownValue)</span><span class="s3">\n\n    </span><span class="s1">// Log and report the error with location but without modifying the error stack</span><span class="s3">\n    </span><span class="s1">devToolErrorMod.originConsoleError('%o</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n%s', thrownValue, errorLocation)</span><span class="s3">\n\n    </span><span class="s1">devToolErrorMod.handleClientError(error)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">devToolErrorMod.originConsoleError(thrownValue)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function onUncaughtError(thrownValue: unknown) {</span><span class="s3">\n  </span><span class="s1">// Skip certain custom errors which are not expected to be reported on client</span><span class="s3">\n  </span><span class="s1">if (isBailoutToCSRError(thrownValue) || isNextRouterError(thrownValue)) return</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n    </span><span class="s1">const error = devToolErrorMod.decorateDevError(thrownValue)</span><span class="s3">\n\n    </span><span class="s1">// TODO: Add an adendum to the overlay telling people about custom error boundaries.</span><span class="s3">\n    </span><span class="s1">reportGlobalError(error)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">reportGlobalError(thrownValue)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;onCaughtError&quot;</span><span class="s0">,</span><span class="s1">&quot;onUncaughtError&quot;</span><span class="s0">,</span><span class="s1">&quot;devToolErrorMod&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;decorateDevError&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;handleClientError&quot;</span><span class="s0">,</span><span class="s1">&quot;originConsoleError&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;thrownValue&quot;</span><span class="s0">,</span><span class="s1">&quot;errorInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;errorBoundaryComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;errorBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;isImplicitErrorBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;AppDevOverlayErrorBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;ErrorBoundaryHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;errorComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;DefaultErrorBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;isBailoutToCSRError&quot;</span><span class="s0">,</span><span class="s1">&quot;isNextRouterError&quot;</span><span class="s0">,</span><span class="s1">&quot;errorBoundaryName&quot;</span><span class="s0">,</span><span class="s1">&quot;displayName&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;componentThatErroredFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;componentStack&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;matches&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;componentThatErroredName&quot;</span><span class="s0">,</span><span class="s1">&quot;errorBoundaryMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;componentErrorMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;errorLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;reportGlobalError&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA,iFAAiF;AAU/EG,QAAQC,GAAG,CAACC,QAAQ,KAAK,eACpBC,QAAQ;;;;;;;;;;;;;;;;IAOCN,aAAa,EAAA;eAAbA;;IA+EAC,eAAe,EAAA;eAAfA;;;;mCA9FkB;8BACE;mCACF;+BACG;sEACJ;AAEjC,MAAMC,6LAGA;AAMC,SAASF,cACda,WAAoB,EACpBC,SAA0D;QAE3BA;IAA/B,MAAMC,yBAAAA,CAAyBD,2BAAAA,UAAUE,aAAa,KAAA,OAAA,KAAA,IAAvBF,yBAAyBG,WAAW;IAEnE,IAAIC;IAEJ,IAAIf,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;QACzC,MAAM,EAAEc,0BAA0B,EAAE,GAClCb,QAAQ;QAEVY,0BACEH,2BAA2BI;IAC/B;IAEAD,0BACEA,2BACCH,2BAA2BK,eAAAA,oBAAoB,IAC7CN,UAAUE,aAAa,CACrBK,KAAK,CAACC,cAAc,KAAKC,aAAAA,OAAoB;IAEpD,4CAA4C;IAC5C,IAAIpB,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;QACzC,MAAM,EAAEmB,wCAAwC,EAAE,GAChDlB,QAAQ;QACV,IACEO,uBAAuBY,SACvBZ,YAAYa,OAAO,KAAKF,0CACxB;YACA;QACF;IACF;IAEA,IAAIN,yBAAyB;QAC3B,6EAA6E;QAC7E,uDAAuD;QACvD,6DAA6D;QAC7D,OAAOjB,gBAAgBY;IACzB;IAEA,6EAA6E;IAC7E,IAAIc,CAAAA,GAAAA,cAAAA,mBAAmB,EAACd,gBAAgBe,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACf,cAAc;IAExE,IAAIV,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;YAOPS;QANlC,MAAMe,oBAEJ,CADA,AACCd,0BAAAA,OAAAA,EADkC,GAClCA,IAAAA,uBAAgCe,WAAW,KAAA,CAC5Cf,0BAAAA,OAAAA,KAAAA,IAAAA,uBAAwBgB,IAAI,KAC5B;QAEF,MAAMC,4BAA4BlB,aAAAA,OAAAA,KAAAA,IAAAA,CAAAA,4BAAAA,UAAWmB,cAAc,KAAA,OAAA,KAAA,IAAzBnB,0BAA2BoB,KAAK,CAAC,KAAK,CAAC,EAAE;YAIzE,AACA,sDADsD,+CAC+C;QACrG,gGAAgG;QAChGF;QALF,qCAAqC;QACrC,MAAMG,UAIJH,CAAAA,mCAAAA,6BAAAA,OAAAA,KAAAA,IAAAA,0BAA2BI,KAAK,CAAC,wBAAA,KAAA,OAAjCJ,mCAA6D,EAAE;QACjE,MAAMK,2BAA2BF,OAAO,CAAC,EAAE,IAAIA,OAAO,CAAC,EAAE,IAAI;QAE7D,iIAAiI;QACjI,MAAMG,uBAAwB,4BAAyBT,oBAAkB;QACzE,MAAMU,wBAAwBF,uCACzB,sCAAmCA,2BAAyB,iBAC5D;QAEL,MAAMG,gBAAmBD,wBAAsB,MAAGD;QAClD,MAAM9B,QAAQN,gBAAgBK,gBAAgB,CAACM;QAE/C,+EAA+E;QAC/EX,gBAAgBQ,kBAAkB,CAAC,YAAYG,aAAa2B;QAE5DtC,gBAAgBO,iBAAiB,CAACD;IACpC,OAAO;;AAGT;AAEO,SAASP,gBAAgBY,WAAoB;IAClD,6EAA6E;IAC7E,IAAIc,CAAAA,GAAAA,cAAAA,mBAAmB,EAACd,gBAAgBe,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACf,cAAc;IAExE,IAAIV,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;QACzC,MAAMG,QAAQN,gBAAgBK,gBAAgB,CAACM;QAE/C,oFAAoF;QACpF4B,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACjC;IACpB,OAAO;;AAGT&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1273</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/router-reducer-types.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">FlightSegmentPath,</span><span class="s3">\n</span><span class="s1">} from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import type { FetchServerResponseResult } from './fetch-server-response'</span><span class="s3">\n\n</span><span class="s1">export const ACTION_REFRESH = 'refresh'</span><span class="s3">\n</span><span class="s1">export const ACTION_NAVIGATE = 'navigate'</span><span class="s3">\n</span><span class="s1">export const ACTION_RESTORE = 'restore'</span><span class="s3">\n</span><span class="s1">export const ACTION_SERVER_PATCH = 'server-patch'</span><span class="s3">\n</span><span class="s1">export const ACTION_PREFETCH = 'prefetch'</span><span class="s3">\n</span><span class="s1">export const ACTION_HMR_REFRESH = 'hmr-refresh'</span><span class="s3">\n</span><span class="s1">export const ACTION_SERVER_ACTION = 'server-action'</span><span class="s3">\n\n</span><span class="s1">export type RouterChangeByServerResponse = ({</span><span class="s3">\n  </span><span class="s1">navigatedAt,</span><span class="s3">\n  </span><span class="s1">previousTree,</span><span class="s3">\n  </span><span class="s1">serverResponse,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">navigatedAt: number</span><span class="s3">\n  </span><span class="s1">previousTree: FlightRouterState</span><span class="s3">\n  </span><span class="s1">serverResponse: FetchServerResponseResult</span><span class="s3">\n</span><span class="s1">}) =&gt; void</span><span class="s3">\n\n</span><span class="s1">export interface Mutable {</span><span class="s3">\n  </span><span class="s1">mpaNavigation?: boolean</span><span class="s3">\n  </span><span class="s1">patchedTree?: FlightRouterState</span><span class="s3">\n  </span><span class="s1">canonicalUrl?: string</span><span class="s3">\n  </span><span class="s1">scrollableSegments?: FlightSegmentPath[]</span><span class="s3">\n  </span><span class="s1">pendingPush?: boolean</span><span class="s3">\n  </span><span class="s1">cache?: CacheNode</span><span class="s3">\n  </span><span class="s1">prefetchCache?: AppRouterState['prefetchCache']</span><span class="s3">\n  </span><span class="s1">hashFragment?: string</span><span class="s3">\n  </span><span class="s1">shouldScroll?: boolean</span><span class="s3">\n  </span><span class="s1">preserveCustomHistoryState?: boolean</span><span class="s3">\n  </span><span class="s1">onlyHashChange?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface ServerActionMutable extends Mutable {</span><span class="s3">\n  </span><span class="s1">inFlightServerAction?: Promise&lt;any&gt; | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Refresh triggers a refresh of the full page data.</span><span class="s3">\n </span><span class="s1">* - fetches the Flight data and fills rsc at the root of the cache.</span><span class="s3">\n </span><span class="s1">* - The router state is updated at the root.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface RefreshAction {</span><span class="s3">\n  </span><span class="s1">type: typeof ACTION_REFRESH</span><span class="s3">\n  </span><span class="s1">origin: Location['origin']</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface HmrRefreshAction {</span><span class="s3">\n  </span><span class="s1">type: typeof ACTION_HMR_REFRESH</span><span class="s3">\n  </span><span class="s1">origin: Location['origin']</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type ServerActionDispatcher = (</span><span class="s3">\n  </span><span class="s1">args: Omit&lt;</span><span class="s3">\n    </span><span class="s1">ServerActionAction,</span><span class="s3">\n    </span><span class="s1">'type' | 'mutable' | 'navigate' | 'changeByServerResponse' | 'cache'</span><span class="s3">\n  </span><span class="s1">&gt;</span><span class="s3">\n</span><span class="s1">) =&gt; void</span><span class="s3">\n\n</span><span class="s1">export interface ServerActionAction {</span><span class="s3">\n  </span><span class="s1">type: typeof ACTION_SERVER_ACTION</span><span class="s3">\n  </span><span class="s1">actionId: string</span><span class="s3">\n  </span><span class="s1">actionArgs: any[]</span><span class="s3">\n  </span><span class="s1">resolve: (value: any) =&gt; void</span><span class="s3">\n  </span><span class="s1">reject: (reason?: any) =&gt; void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Navigate triggers a navigation to the provided url. It supports two types: `push` and `replace`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* `navigateType`:</span><span class="s3">\n </span><span class="s1">* - `push` - pushes a new history entry in the browser history</span><span class="s3">\n </span><span class="s1">* - `replace` - replaces the current history entry in the browser history</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Navigate has multiple cache heuristics:</span><span class="s3">\n </span><span class="s1">* - page was prefetched</span><span class="s3">\n </span><span class="s1">*  - Apply router state tree from prefetch</span><span class="s3">\n </span><span class="s1">*  - Apply Flight data from prefetch to the cache</span><span class="s3">\n </span><span class="s1">*  - If Flight data is a string, it's a redirect and the state is updated to trigger a redirect</span><span class="s3">\n </span><span class="s1">*  - Check if hard navigation is needed</span><span class="s3">\n </span><span class="s1">*    - Hard navigation happens when a dynamic parameter below the common layout changed</span><span class="s3">\n </span><span class="s1">*    - When hard navigation is needed the cache is invalidated below the flightSegmentPath</span><span class="s3">\n </span><span class="s1">*    - The missing cache nodes of the page will be fetched in layout-router and trigger the SERVER_PATCH action</span><span class="s3">\n </span><span class="s1">*  - If hard navigation is not needed</span><span class="s3">\n </span><span class="s1">*    - The cache is reused</span><span class="s3">\n </span><span class="s1">*    - If any cache nodes are missing they'll be fetched in layout-router and trigger the SERVER_PATCH action</span><span class="s3">\n </span><span class="s1">* - page was not prefetched</span><span class="s3">\n </span><span class="s1">*  - The navigate was called from `next/router` (`router.push()` / `router.replace()`) / `next/link` without prefetched data available (e.g. the prefetch didn't come back from the server before clicking the link)</span><span class="s3">\n </span><span class="s1">*    - Flight data is fetched in the reducer (suspends the reducer)</span><span class="s3">\n </span><span class="s1">*    - Router state tree is created based on Flight data</span><span class="s3">\n </span><span class="s1">*    - Cache is filled based on the Flight data</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Above steps explain 3 cases:</span><span class="s3">\n </span><span class="s1">* - `soft` - Reuses the existing cache and fetches missing nodes in layout-router.</span><span class="s3">\n </span><span class="s1">* - `hard` - Creates a new cache where cache nodes are removed below the common layout and fetches missing nodes in layout-router.</span><span class="s3">\n </span><span class="s1">* - `optimistic` (explicit no prefetch) - Creates a new cache and kicks off the data fetch in the reducer. The data fetch is awaited in the layout-router.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface NavigateAction {</span><span class="s3">\n  </span><span class="s1">type: typeof ACTION_NAVIGATE</span><span class="s3">\n  </span><span class="s1">url: URL</span><span class="s3">\n  </span><span class="s1">isExternalUrl: boolean</span><span class="s3">\n  </span><span class="s1">locationSearch: Location['search']</span><span class="s3">\n  </span><span class="s1">navigateType: 'push' | 'replace'</span><span class="s3">\n  </span><span class="s1">shouldScroll: boolean</span><span class="s3">\n  </span><span class="s1">allowAliasing: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Restore applies the provided router state.</span><span class="s3">\n </span><span class="s1">* - Used for `popstate` (back/forward navigation) where a known router state has to be applied.</span><span class="s3">\n </span><span class="s1">* - Also used when syncing the router state with `pushState`/`replaceState` calls.</span><span class="s3">\n </span><span class="s1">* - Router state is applied as-is from the history state, if available.</span><span class="s3">\n </span><span class="s1">* - If the history state does not contain the router state, the existing router state is used.</span><span class="s3">\n </span><span class="s1">* - If any cache node is missing it will be fetched in layout-router during rendering and the server-patch case.</span><span class="s3">\n </span><span class="s1">* - If existing cache nodes match these are used.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface RestoreAction {</span><span class="s3">\n  </span><span class="s1">type: typeof ACTION_RESTORE</span><span class="s3">\n  </span><span class="s1">url: URL</span><span class="s3">\n  </span><span class="s1">tree: FlightRouterState | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Server-patch applies the provided Flight data to the cache and router tree.</span><span class="s3">\n </span><span class="s1">* - Only triggered in layout-router.</span><span class="s3">\n </span><span class="s1">* - Creates a new cache and router state with the Flight data applied.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface ServerPatchAction {</span><span class="s3">\n  </span><span class="s1">type: typeof ACTION_SERVER_PATCH</span><span class="s3">\n  </span><span class="s1">navigatedAt: number</span><span class="s3">\n  </span><span class="s1">serverResponse: FetchServerResponseResult</span><span class="s3">\n  </span><span class="s1">previousTree: FlightRouterState</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* PrefetchKind defines the type of prefetching that should be done.</span><span class="s3">\n </span><span class="s1">* - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.</span><span class="s3">\n </span><span class="s1">* - `full` - prefetch the page data fully.</span><span class="s3">\n </span><span class="s1">* - `temporary` - a temporary prefetch entry is added to the cache, this is used when prefetch={false} is used in next/link or when you push a route programmatically.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export enum PrefetchKind {</span><span class="s3">\n  </span><span class="s1">AUTO = 'auto',</span><span class="s3">\n  </span><span class="s1">FULL = 'full',</span><span class="s3">\n  </span><span class="s1">TEMPORARY = 'temporary',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Prefetch adds the provided FlightData to the prefetch cache</span><span class="s3">\n </span><span class="s1">* - Creates the router state tree based on the patch in FlightData</span><span class="s3">\n </span><span class="s1">* - Adds the FlightData to the prefetch cache</span><span class="s3">\n </span><span class="s1">* - In ACTION_NAVIGATE the prefetch cache is checked and the router state tree and FlightData are applied.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface PrefetchAction {</span><span class="s3">\n  </span><span class="s1">type: typeof ACTION_PREFETCH</span><span class="s3">\n  </span><span class="s1">url: URL</span><span class="s3">\n  </span><span class="s1">kind: PrefetchKind</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface PushRef {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If the app-router should push a new history entry in app-router's useEffect()</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pendingPush: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Multi-page navigation through location.href.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">mpaNavigation: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Skip applying the router state to the browser history state.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">preserveCustomHistoryState: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type FocusAndScrollRef = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If focus and scroll should be set in the layout-router's useEffect()</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">apply: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The hash fragment that should be scrolled to.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">hashFragment: string | null</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The paths of the segments that should be focused.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">segmentPaths: FlightSegmentPath[]</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If only the URLs hash fragment changed</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">onlyHashChange: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type PrefetchCacheEntry = {</span><span class="s3">\n  </span><span class="s1">treeAtTimeOfPrefetch: FlightRouterState</span><span class="s3">\n  </span><span class="s1">data: Promise&lt;FetchServerResponseResult&gt;</span><span class="s3">\n  </span><span class="s1">kind: PrefetchKind</span><span class="s3">\n  </span><span class="s1">prefetchTime: number</span><span class="s3">\n  </span><span class="s1">staleTime: number</span><span class="s3">\n  </span><span class="s1">lastUsedTime: number | null</span><span class="s3">\n  </span><span class="s1">key: string</span><span class="s3">\n  </span><span class="s1">status: PrefetchCacheEntryStatus</span><span class="s3">\n  </span><span class="s1">url: URL</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export enum PrefetchCacheEntryStatus {</span><span class="s3">\n  </span><span class="s1">fresh = 'fresh',</span><span class="s3">\n  </span><span class="s1">reusable = 'reusable',</span><span class="s3">\n  </span><span class="s1">expired = 'expired',</span><span class="s3">\n  </span><span class="s1">stale = 'stale',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Handles keeping the state of app-router.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type AppRouterState = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The router state, this is written into the history state in app-router using replaceState/pushState.</span><span class="s3">\n   </span><span class="s1">* - Has to be serializable as it is written into the history state.</span><span class="s3">\n   </span><span class="s1">* - Holds which segments and parallel routes are shown on the screen.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">tree: FlightRouterState</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The cache holds React nodes for every segment that is shown on screen as well as previously shown segments.</span><span class="s3">\n   </span><span class="s1">* It also holds in-progress data requests.</span><span class="s3">\n   </span><span class="s1">* Prefetched data is stored separately in `prefetchCache`, that is applied during ACTION_NAVIGATE.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">cache: CacheNode</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Cache that holds prefetched Flight responses keyed by url.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">prefetchCache: Map&lt;string, PrefetchCacheEntry&gt;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Decides if the update should create a new history entry and if the navigation has to trigger a browser navigation.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pushRef: PushRef</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Decides if the update should apply scroll and focus management.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">focusAndScrollRef: FocusAndScrollRef</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The canonical url that is pushed/replaced.</span><span class="s3">\n   </span><span class="s1">* - This is the url you see in the browser.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">canonicalUrl: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The underlying </span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot; </span><span class="s1">representing the UI state, which is used for intercepting routes.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">nextUrl: string | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type ReadonlyReducerState = Readonly&lt;AppRouterState&gt;</span><span class="s3">\n</span><span class="s1">export type ReducerState = Promise&lt;AppRouterState&gt; | AppRouterState</span><span class="s3">\n</span><span class="s1">export type ReducerActions = Readonly&lt;</span><span class="s3">\n  </span><span class="s1">| RefreshAction</span><span class="s3">\n  </span><span class="s1">| NavigateAction</span><span class="s3">\n  </span><span class="s1">| RestoreAction</span><span class="s3">\n  </span><span class="s1">| ServerPatchAction</span><span class="s3">\n  </span><span class="s1">| PrefetchAction</span><span class="s3">\n  </span><span class="s1">| HmrRefreshAction</span><span class="s3">\n  </span><span class="s1">| ServerActionAction</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;ACTION_HMR_REFRESH&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_NAVIGATE&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_PREFETCH&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_REFRESH&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_RESTORE&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_SERVER_ACTION&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_SERVER_PATCH&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchCacheEntryStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchKind&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;;;;IAYaA,kBAAkB,EAAA;eAAlBA;;IAJAC,eAAe,EAAA;eAAfA;;IAGAC,eAAe,EAAA;eAAfA;;IAJAC,cAAc,EAAA;eAAdA;;IAEAC,cAAc,EAAA;eAAdA;;IAIAC,oBAAoB,EAAA;eAApBA;;IAHAC,mBAAmB,EAAA;eAAnBA;;IAyMDC,wBAAwB,EAAA;eAAxBA;;IAhEAC,YAAY,EAAA;eAAZA;;;AA5IL,MAAML,iBAAiB;AACvB,MAAMF,kBAAkB;AACxB,MAAMG,iBAAiB;AACvB,MAAME,sBAAsB;AAC5B,MAAMJ,kBAAkB;AACxB,MAAMF,qBAAqB;AAC3B,MAAMK,uBAAuB;AAsI7B,IAAKG,eAAAA,WAAAA,GAAAA,SAAAA,YAAAA;;;;WAAAA;;AAgEL,IAAKD,2BAAAA,WAAAA,GAAAA,SAAAA,wBAAAA;;;;;WAAAA&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1353</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/use-action-queue.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { Dispatch } from 'react'</span><span class="s3">\n</span><span class="s1">import React, { use } from 'react'</span><span class="s3">\n</span><span class="s1">import { isThenable } from '../../shared/lib/is-thenable'</span><span class="s3">\n</span><span class="s1">import type { AppRouterActionQueue } from './app-router-instance'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">AppRouterState,</span><span class="s3">\n  </span><span class="s1">ReducerActions,</span><span class="s3">\n  </span><span class="s1">ReducerState,</span><span class="s3">\n</span><span class="s1">} from './router-reducer/router-reducer-types'</span><span class="s3">\n\n</span><span class="s1">// The app router state lives outside of React, so we can import the dispatch</span><span class="s3">\n</span><span class="s1">// method directly wherever we need it, rather than passing it around via props</span><span class="s3">\n</span><span class="s1">// or context.</span><span class="s3">\n</span><span class="s1">let dispatch: Dispatch&lt;ReducerActions&gt; | null = null</span><span class="s3">\n\n</span><span class="s1">export function dispatchAppRouterAction(action: ReducerActions) {</span><span class="s3">\n  </span><span class="s1">if (dispatch === null) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">'Internal Next.js error: Router action dispatched before initialization.'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">dispatch(action)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function useActionQueue(</span><span class="s3">\n  </span><span class="s1">actionQueue: AppRouterActionQueue</span><span class="s3">\n</span><span class="s1">): AppRouterState {</span><span class="s3">\n  </span><span class="s1">const [state, setState] = React.useState&lt;ReducerState&gt;(actionQueue.state)</span><span class="s3">\n\n  </span><span class="s1">// Because of a known issue that requires to decode Flight streams inside the</span><span class="s3">\n  </span><span class="s1">// render phase, we have to be a bit clever and assign the dispatch method to</span><span class="s3">\n  </span><span class="s1">// a module-level variable upon initialization. The useState hook in this</span><span class="s3">\n  </span><span class="s1">// module only exists to synchronize state that lives outside of React.</span><span class="s3">\n  </span><span class="s1">// Ideally, what we'd do instead is pass the state as a prop to root.render;</span><span class="s3">\n  </span><span class="s1">// this is conceptually how we're modeling the app router state, despite the</span><span class="s3">\n  </span><span class="s1">// weird implementation details.</span><span class="s3">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n    </span><span class="s1">const { useAppDevRenderingIndicator } =</span><span class="s3">\n      </span><span class="s1">require('../../next-devtools/userspace/use-app-dev-rendering-indicator') as typeof import('../../next-devtools/userspace/use-app-dev-rendering-indicator')</span><span class="s3">\n    </span><span class="s1">// eslint-disable-next-line react-hooks/rules-of-hooks</span><span class="s3">\n    </span><span class="s1">const appDevRenderingIndicator = useAppDevRenderingIndicator()</span><span class="s3">\n\n    </span><span class="s1">dispatch = (action: ReducerActions) =&gt; {</span><span class="s3">\n      </span><span class="s1">appDevRenderingIndicator(() =&gt; {</span><span class="s3">\n        </span><span class="s1">actionQueue.dispatch(action, setState)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">dispatch = (action: ReducerActions) =&gt;</span><span class="s3">\n      </span><span class="s1">actionQueue.dispatch(action, setState)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return isThenable(state) ? use(state) : state</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;dispatchAppRouterAction&quot;</span><span class="s0">,</span><span class="s1">&quot;useActionQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;dispatch&quot;</span><span class="s0">,</span><span class="s1">&quot;action&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;actionQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;setState&quot;</span><span class="s0">,</span><span class="s1">&quot;React&quot;</span><span class="s0">,</span><span class="s1">&quot;useState&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;useAppDevRenderingIndicator&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;appDevRenderingIndicator&quot;</span><span class="s0">,</span><span class="s1">&quot;isThenable&quot;</span><span class="s0">,</span><span class="s1">&quot;use&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAoCMU,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;;;;;;;;;;;;IArBfZ,uBAAuB,EAAA;eAAvBA;;IASAC,cAAc,EAAA;eAAdA;;;;iEAvBW;4BACA;AAQ3B,6EAA6E;AAC7E,+EAA+E;AAC/E,cAAc;AACd,IAAIC,WAA4C;AAEzC,SAASF,wBAAwBG,MAAsB;IAC5D,IAAID,aAAa,MAAM;QACrB,MAAM,OAAA,cAEL,CAFK,IAAIE,MACR,4EADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IACAF,SAASC;AACX;AAEO,SAASF,eACdI,WAAiC;IAEjC,MAAM,CAACC,OAAOC,SAAS,GAAGC,OAAAA,OAAK,CAACC,QAAQ,CAAeJ,YAAYC,KAAK;IAExE,6EAA6E;IAC7E,6EAA6E;IAC7E,yEAAyE;IACzE,uEAAuE;IACvE,4EAA4E;IAC5E,4EAA4E;IAC5E,gCAAgC;IAChC,wCAA2C;QACzC,MAAM,EAAEO,2BAA2B,EAAE,GACnCC,QAAQ;QACV,sDAAsD;QACtD,MAAMC,2BAA2BF;QAEjCX,WAAW,CAACC;YACVY,yBAAyB;gBACvBV,YAAYH,QAAQ,CAACC,QAAQI;YAC/B;QACF;IACF,OAAO;;IAKP,OAAOS,CAAAA,GAAAA,YAAAA,UAAU,EAACV,SAASW,CAAAA,GAAAA,OAAAA,GAAG,EAACX,SAASA;AAC1C&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1426</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/app-call-server.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { startTransition } from 'react'</span><span class="s3">\n</span><span class="s1">import { ACTION_SERVER_ACTION } from './components/router-reducer/router-reducer-types'</span><span class="s3">\n</span><span class="s1">import { dispatchAppRouterAction } from './components/use-action-queue'</span><span class="s3">\n\n</span><span class="s1">export async function callServer(actionId: string, actionArgs: any[]) {</span><span class="s3">\n  </span><span class="s1">return new Promise((resolve, reject) =&gt; {</span><span class="s3">\n    </span><span class="s1">startTransition(() =&gt; {</span><span class="s3">\n      </span><span class="s1">dispatchAppRouterAction({</span><span class="s3">\n        </span><span class="s1">type: ACTION_SERVER_ACTION,</span><span class="s3">\n        </span><span class="s1">actionId,</span><span class="s3">\n        </span><span class="s1">actionArgs,</span><span class="s3">\n        </span><span class="s1">resolve,</span><span class="s3">\n        </span><span class="s1">reject,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;callServer&quot;</span><span class="s0">,</span><span class="s1">&quot;actionId&quot;</span><span class="s0">,</span><span class="s1">&quot;actionArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;startTransition&quot;</span><span class="s0">,</span><span class="s1">&quot;dispatchAppRouterAction&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_SERVER_ACTION&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAIsBA,cAAAA;;;eAAAA;;;uBAJU;oCACK;gCACG;AAEjC,eAAeA,WAAWC,QAAgB,EAAEC,UAAiB;IAClE,OAAO,IAAIC,QAAQ,CAACC,SAASC;QAC3BC,CAAAA,GAAAA,OAAAA,eAAe,EAAC;YACdC,CAAAA,GAAAA,gBAAAA,uBAAuB,EAAC;gBACtBC,MAAMC,oBAAAA,oBAAoB;gBAC1BR;gBACAC;gBACAE;gBACAC;YACF;QACF;IACF;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1462</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/app-find-source-map-url.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;const basePath = process.env.__NEXT_ROUTER_BASEPATH || ''</span><span class="s3">\n</span><span class="s1">const pathname = `${basePath}/__nextjs_source-map`</span><span class="s3">\n\n</span><span class="s1">export const findSourceMapURL =</span><span class="s3">\n  </span><span class="s1">process.env.NODE_ENV === 'development'</span><span class="s3">\n    </span><span class="s1">? function findSourceMapURL(filename: string): string | null {</span><span class="s3">\n        </span><span class="s1">if (filename === '') {</span><span class="s3">\n          </span><span class="s1">return null</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">filename.startsWith(document.location.origin) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">filename.includes('/_next/static')</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">// This is a request for a client chunk. This can only happen when</span><span class="s3">\n          </span><span class="s1">// using Turbopack. In this case, since we control how those source</span><span class="s3">\n          </span><span class="s1">// maps are generated, we can safely assume that the sourceMappingURL</span><span class="s3">\n          </span><span class="s1">// is relative to the filename, with an added `.map` extension. The</span><span class="s3">\n          </span><span class="s1">// browser can just request this file, and it gets served through the</span><span class="s3">\n          </span><span class="s1">// normal dev server, without the need to route this through</span><span class="s3">\n          </span><span class="s1">// the `/__nextjs_source-map` dev middleware.</span><span class="s3">\n          </span><span class="s1">return `${filename}.map`</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const url = new URL(pathname, document.location.origin)</span><span class="s3">\n        </span><span class="s1">url.searchParams.set('filename', filename)</span><span class="s3">\n\n        </span><span class="s1">return url.href</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;findSourceMapURL&quot;</span><span class="s0">,</span><span class="s1">&quot;basePath&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_ROUTER_BASEPATH&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;filename&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;document&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAiBE,QAAQC,GAAG,CAACC,sBAAsB;;;;;+BAGtCJ,oBAAAA;;;eAAAA;;;AAHb,MAAMC,mDAAiD;AACvD,MAAMI,WAAY,KAAEJ,WAAS;AAEtB,MAAMD,mBACXE,QAAQC,GAAG,CAACG,QAAQ,KAAK,cACrB,SAASN,iBAAiBO,QAAgB;IACxC,IAAIA,aAAa,IAAI;QACnB,OAAO;IACT;IAEA,IACEA,SAASC,UAAU,CAACC,SAASC,QAAQ,CAACC,MAAM,KAC5CJ,SAASK,QAAQ,CAAC,kBAClB;QACA,kEAAkE;QAClE,mEAAmE;QACnE,qEAAqE;QACrE,mEAAmE;QACnE,qEAAqE;QACrE,4DAA4D;QAC5D,6CAA6C;QAC7C,OAAQ,KAAEL,WAAS;IACrB;IAEA,MAAMM,MAAM,IAAIC,IAAIT,UAAUI,SAASC,QAAQ,CAACC,MAAM;IACtDE,IAAIE,YAAY,CAACC,GAAG,CAAC,YAAYT;IAEjC,OAAOM,IAAII,IAAI;AACjB,IACAC&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1504</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/flight-data-helpers.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">CacheNodeSeedData,</span><span class="s3">\n  </span><span class="s1">FlightData,</span><span class="s3">\n  </span><span class="s1">FlightDataPath,</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">FlightSegmentPath,</span><span class="s3">\n  </span><span class="s1">Segment,</span><span class="s3">\n</span><span class="s1">} from '../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import type { HeadData } from '../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { PAGE_SEGMENT_KEY } from '../shared/lib/segment'</span><span class="s3">\n\n</span><span class="s1">export type NormalizedFlightData = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The full `FlightSegmentPath` inclusive of the final `Segment`</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">segmentPath: FlightSegmentPath</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The `FlightSegmentPath` exclusive of the final `Segment`</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pathToSegment: FlightSegmentPath</span><span class="s3">\n  </span><span class="s1">segment: Segment</span><span class="s3">\n  </span><span class="s1">tree: FlightRouterState</span><span class="s3">\n  </span><span class="s1">seedData: CacheNodeSeedData | null</span><span class="s3">\n  </span><span class="s1">head: HeadData</span><span class="s3">\n  </span><span class="s1">isHeadPartial: boolean</span><span class="s3">\n  </span><span class="s1">isRootRender: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// TODO: We should only have to export `normalizeFlightData`, however because the initial flight data</span><span class="s3">\n</span><span class="s1">// that gets passed to `createInitialRouterState` doesn't conform to the `FlightDataPath` type (it's missing the root segment)</span><span class="s3">\n</span><span class="s1">// we're currently exporting it so we can use it directly. This should be fixed as part of the unification of</span><span class="s3">\n</span><span class="s1">// the different ways we express `FlightSegmentPath`.</span><span class="s3">\n</span><span class="s1">export function getFlightDataPartsFromPath(</span><span class="s3">\n  </span><span class="s1">flightDataPath: FlightDataPath</span><span class="s3">\n</span><span class="s1">): NormalizedFlightData {</span><span class="s3">\n  </span><span class="s1">// Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].</span><span class="s3">\n  </span><span class="s1">const flightDataPathLength = 4</span><span class="s3">\n  </span><span class="s1">// tree, seedData, and head are *always* the last three items in the `FlightDataPath`.</span><span class="s3">\n  </span><span class="s1">const [tree, seedData, head, isHeadPartial] =</span><span class="s3">\n    </span><span class="s1">flightDataPath.slice(-flightDataPathLength)</span><span class="s3">\n  </span><span class="s1">// The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.</span><span class="s3">\n  </span><span class="s1">const segmentPath = flightDataPath.slice(0, -flightDataPathLength)</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">// TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment (</span><span class="s3">\&quot;\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">// to the start of the segment path in some places which makes it hard to use solely the segment path.</span><span class="s3">\n    </span><span class="s1">// Look for </span><span class="s3">\&quot;</span><span class="s1">// TODO-APP: remove ''</span><span class="s3">\&quot; </span><span class="s1">in the codebase.</span><span class="s3">\n    </span><span class="s1">pathToSegment: segmentPath.slice(0, -1),</span><span class="s3">\n    </span><span class="s1">segmentPath,</span><span class="s3">\n    </span><span class="s1">// if the `FlightDataPath` corresponds with the root, there'll be no segment path,</span><span class="s3">\n    </span><span class="s1">// in which case we default to ''.</span><span class="s3">\n    </span><span class="s1">segment: segmentPath[segmentPath.length - 1] ?? '',</span><span class="s3">\n    </span><span class="s1">tree,</span><span class="s3">\n    </span><span class="s1">seedData,</span><span class="s3">\n    </span><span class="s1">head,</span><span class="s3">\n    </span><span class="s1">isHeadPartial,</span><span class="s3">\n    </span><span class="s1">isRootRender: flightDataPath.length === flightDataPathLength,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getNextFlightSegmentPath(</span><span class="s3">\n  </span><span class="s1">flightSegmentPath: FlightSegmentPath</span><span class="s3">\n</span><span class="s1">): FlightSegmentPath {</span><span class="s3">\n  </span><span class="s1">// Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items</span><span class="s3">\n  </span><span class="s1">// to get the next segment path.</span><span class="s3">\n  </span><span class="s1">return flightSegmentPath.slice(2)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function normalizeFlightData(</span><span class="s3">\n  </span><span class="s1">flightData: FlightData</span><span class="s3">\n</span><span class="s1">): NormalizedFlightData[] | string {</span><span class="s3">\n  </span><span class="s1">// FlightData can be a string when the server didn't respond with a proper flight response,</span><span class="s3">\n  </span><span class="s1">// or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.</span><span class="s3">\n  </span><span class="s1">if (typeof flightData === 'string') {</span><span class="s3">\n    </span><span class="s1">return flightData</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return flightData.map((flightDataPath) =&gt;</span><span class="s3">\n    </span><span class="s1">getFlightDataPartsFromPath(flightDataPath)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function is used to prepare the flight router state for the request.</span><span class="s3">\n </span><span class="s1">* It removes markers that are not needed by the server, and are purely used</span><span class="s3">\n </span><span class="s1">* for stashing state on the client.</span><span class="s3">\n </span><span class="s1">* @param flightRouterState - The flight router state to prepare.</span><span class="s3">\n </span><span class="s1">* @param isHmrRefresh - Whether this is an HMR refresh request.</span><span class="s3">\n </span><span class="s1">* @returns The prepared flight router state.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function prepareFlightRouterStateForRequest(</span><span class="s3">\n  </span><span class="s1">flightRouterState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">isHmrRefresh?: boolean</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">// HMR requests need the complete, unmodified state for proper functionality</span><span class="s3">\n  </span><span class="s1">if (isHmrRefresh) {</span><span class="s3">\n    </span><span class="s1">return encodeURIComponent(JSON.stringify(flightRouterState))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return encodeURIComponent(</span><span class="s3">\n    </span><span class="s1">JSON.stringify(stripClientOnlyDataFromFlightRouterState(flightRouterState))</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Recursively strips client-only data from FlightRouterState while preserving</span><span class="s3">\n </span><span class="s1">* server-needed information for proper rendering decisions.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function stripClientOnlyDataFromFlightRouterState(</span><span class="s3">\n  </span><span class="s1">flightRouterState: FlightRouterState</span><span class="s3">\n</span><span class="s1">): FlightRouterState {</span><span class="s3">\n  </span><span class="s1">const [</span><span class="s3">\n    </span><span class="s1">segment,</span><span class="s3">\n    </span><span class="s1">parallelRoutes,</span><span class="s3">\n    </span><span class="s1">_url, // Intentionally unused - URLs are client-only</span><span class="s3">\n    </span><span class="s1">refreshMarker,</span><span class="s3">\n    </span><span class="s1">isRootLayout,</span><span class="s3">\n    </span><span class="s1">hasLoadingBoundary,</span><span class="s3">\n  </span><span class="s1">] = flightRouterState</span><span class="s3">\n\n  </span><span class="s1">// __PAGE__ segments are always fetched from the server, so there's</span><span class="s3">\n  </span><span class="s1">// no need to send them up</span><span class="s3">\n  </span><span class="s1">const cleanedSegment = stripSearchParamsFromPageSegment(segment)</span><span class="s3">\n\n  </span><span class="s1">// Recursively process parallel routes</span><span class="s3">\n  </span><span class="s1">const cleanedParallelRoutes: { [key: string]: FlightRouterState } = {}</span><span class="s3">\n  </span><span class="s1">for (const [key, childState] of Object.entries(parallelRoutes)) {</span><span class="s3">\n    </span><span class="s1">cleanedParallelRoutes[key] =</span><span class="s3">\n      </span><span class="s1">stripClientOnlyDataFromFlightRouterState(childState)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const result: FlightRouterState = [</span><span class="s3">\n    </span><span class="s1">cleanedSegment,</span><span class="s3">\n    </span><span class="s1">cleanedParallelRoutes,</span><span class="s3">\n    </span><span class="s1">null, // URLs omitted - server reconstructs paths from segments</span><span class="s3">\n    </span><span class="s1">shouldPreserveRefreshMarker(refreshMarker) ? refreshMarker : null,</span><span class="s3">\n  </span><span class="s1">]</span><span class="s3">\n\n  </span><span class="s1">// Append optional fields if present</span><span class="s3">\n  </span><span class="s1">if (isRootLayout !== undefined) {</span><span class="s3">\n    </span><span class="s1">result[4] = isRootLayout</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (hasLoadingBoundary !== undefined) {</span><span class="s3">\n    </span><span class="s1">result[5] = hasLoadingBoundary</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return result</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Strips search parameters from __PAGE__ segments to prevent sensitive</span><span class="s3">\n </span><span class="s1">* client-side data from being sent to the server.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function stripSearchParamsFromPageSegment(segment: Segment): Segment {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">typeof segment === 'string' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">segment.startsWith(PAGE_SEGMENT_KEY + '?')</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return PAGE_SEGMENT_KEY</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return segment</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Determines whether the refresh marker should be sent to the server</span><span class="s3">\n </span><span class="s1">* Client-only markers like 'refresh' are stripped, while server-needed markers</span><span class="s3">\n </span><span class="s1">* like 'refetch' and 'inside-shared-layout' are preserved.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function shouldPreserveRefreshMarker(</span><span class="s3">\n  </span><span class="s1">refreshMarker: FlightRouterState[3]</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return Boolean(refreshMarker &amp;&amp; refreshMarker !== 'refresh')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;getFlightDataPartsFromPath&quot;</span><span class="s0">,</span><span class="s1">&quot;getNextFlightSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;prepareFlightRouterStateForRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;flightDataPath&quot;</span><span class="s0">,</span><span class="s1">&quot;flightDataPathLength&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;seedData&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;isHeadPartial&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;pathToSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootRender&quot;</span><span class="s0">,</span><span class="s1">&quot;flightSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;isHmrRefresh&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;stripClientOnlyDataFromFlightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;_url&quot;</span><span class="s0">,</span><span class="s1">&quot;refreshMarker&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;hasLoadingBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanedSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;stripSearchParamsFromPageSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanedParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;childState&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldPreserveRefreshMarker&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;PAGE_SEGMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;IAgCgBA,0BAA0B,EAAA;eAA1BA;;IA4BAC,wBAAwB,EAAA;eAAxBA;;IAQAC,mBAAmB,EAAA;eAAnBA;;IAsBAC,kCAAkC,EAAA;eAAlCA;;;yBAjFiB;AAuB1B,SAASH,2BACdI,cAA8B;IAE9B,wGAAwG;IACxG,MAAMC,uBAAuB;IAC7B,sFAAsF;IACtF,MAAM,CAACC,MAAMC,UAAUC,MAAMC,cAAc,GACzCL,eAAeM,KAAK,CAAC,CAACL;IACxB,6GAA6G;IAC7G,MAAMM,cAAcP,eAAeM,KAAK,CAAC,GAAG,CAACL;QAUlCM;IARX,OAAO;QACL,kGAAkG;QAClG,sGAAsG;QACtG,qDAAqD;QACrDC,eAAeD,YAAYD,KAAK,CAAC,GAAG,CAAC;QACrCC;QACA,kFAAkF;QAClF,kCAAkC;QAClCE,SAASF,CAAAA,gBAAAA,WAAW,CAACA,YAAYG,MAAM,GAAG,EAAE,KAAA,OAAnCH,gBAAuC;QAChDL;QACAC;QACAC;QACAC;QACAM,cAAcX,eAAeU,MAAM,KAAKT;IAC1C;AACF;AAEO,SAASJ,yBACde,iBAAoC;IAEpC,4GAA4G;IAC5G,gCAAgC;IAChC,OAAOA,kBAAkBN,KAAK,CAAC;AACjC;AAEO,SAASR,oBACde,UAAsB;IAEtB,2FAA2F;IAC3F,kGAAkG;IAClG,IAAI,OAAOA,eAAe,UAAU;QAClC,OAAOA;IACT;IAEA,OAAOA,WAAWC,GAAG,CAAC,CAACd,iBACrBJ,2BAA2BI;AAE/B;AAUO,SAASD,mCACdgB,iBAAoC,EACpCC,YAAsB;IAEtB,4EAA4E;IAC5E,IAAIA,cAAc;QAChB,OAAOC,mBAAmBC,KAAKC,SAAS,CAACJ;IAC3C;IAEA,OAAOE,mBACLC,KAAKC,SAAS,CAACC,yCAAyCL;AAE5D;AAEA;;;CAGC,GACD,SAASK,yCACPL,iBAAoC;IAEpC,MAAM,CACJN,SACAY,gBACAC,MACAC,eACAC,cACAC,mBACD,GAAGV;IAEJ,mEAAmE;IACnE,0BAA0B;IAC1B,MAAMW,iBAAiBC,iCAAiClB;IAExD,sCAAsC;IACtC,MAAMmB,wBAA8D,CAAC;IACrE,KAAK,MAAM,CAACC,KAAKC,WAAW,IAAIC,OAAOC,OAAO,CAACX,gBAAiB;QAC9DO,qBAAqB,CAACC,IAAI,GACxBT,yCAAyCU;IAC7C;IAEA,MAAMG,SAA4B;QAChCP;QACAE;QACA;QACAM,4BAA4BX,iBAAiBA,gBAAgB;KAC9D;IAED,oCAAoC;IACpC,IAAIC,iBAAiBW,WAAW;QAC9BF,MAAM,CAAC,EAAE,GAAGT;IACd;IACA,IAAIC,uBAAuBU,WAAW;QACpCF,MAAM,CAAC,EAAE,GAAGR;IACd;IAEA,OAAOQ;AACT;AAEA;;;CAGC,GACD,SAASN,iCAAiClB,OAAgB;IACxD,IACE,OAAOA,YAAY,YACnBA,QAAQ2B,UAAU,CAACC,SAAAA,gBAAgB,GAAG,MACtC;QACA,OAAOA,SAAAA,gBAAgB;IACzB;IACA,OAAO5B;AACT;AAEA;;;;CAIC,GACD,SAASyB,4BACPX,aAAmC;IAEnC,OAAOe,QAAQf,iBAAiBA,kBAAkB;AACpD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1633</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/app-build-id.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// This gets assigned as a side-effect during app initialization. Because it</span><span class="s3">\n</span><span class="s1">// represents the build used to create the JS bundle, it should never change</span><span class="s3">\n</span><span class="s1">// after being set, so we store it in a global variable.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// When performing RSC requests, if the incoming data has a different build ID,</span><span class="s3">\n</span><span class="s1">// we perform an MPA navigation/refresh to load the updated build and ensure</span><span class="s3">\n</span><span class="s1">// that the client and server in sync.</span><span class="s3">\n\n</span><span class="s1">// Starts as an empty string. In practice, because setAppBuildId is called</span><span class="s3">\n</span><span class="s1">// during initialization before hydration starts, this will always get</span><span class="s3">\n</span><span class="s1">// reassigned to the actual build ID before it's ever needed by a navigation.</span><span class="s3">\n</span><span class="s1">// If for some reasons it didn't, due to a bug or race condition, then on</span><span class="s3">\n</span><span class="s1">// navigation the build comparision would fail and trigger an MPA navigation.</span><span class="s3">\n</span><span class="s1">let globalBuildId: string = ''</span><span class="s3">\n\n</span><span class="s1">export function setAppBuildId(buildId: string) {</span><span class="s3">\n  </span><span class="s1">globalBuildId = buildId</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getAppBuildId(): string {</span><span class="s3">\n  </span><span class="s1">return globalBuildId</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;getAppBuildId&quot;</span><span class="s0">,</span><span class="s1">&quot;setAppBuildId&quot;</span><span class="s0">,</span><span class="s1">&quot;globalBuildId&quot;</span><span class="s0">,</span><span class="s1">&quot;buildId&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA,4EAA4E;AAC5E,4EAA4E;AAC5E,wDAAwD;AACxD,EAAE;AACF,+EAA+E;AAC/E,4EAA4E;AAC5E,sCAAsC;AAEtC,0EAA0E;AAC1E,sEAAsE;AACtE,6EAA6E;AAC7E,yEAAyE;AACzE,6EAA6E;;;;;;;;;;;;;;;IAO7DA,aAAa,EAAA;eAAbA;;IAJAC,aAAa,EAAA;eAAbA;;;AAFhB,IAAIC,gBAAwB;AAErB,SAASD,cAAcE,OAAe;IAC3CD,gBAAgBC;AAClB;AAEO,SAASH;IACd,OAAOE;AACT&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1684</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/set-cache-busting-search-param.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;'use client'</span><span class="s3">\n\n</span><span class="s1">import { computeCacheBustingSearchParam } from '../../../shared/lib/router/utils/cache-busting-search-param'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_PREFETCH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_STATE_TREE_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_URL,</span><span class="s3">\n  </span><span class="s1">NEXT_RSC_UNION_QUERY,</span><span class="s3">\n</span><span class="s1">} from '../app-router-headers'</span><span class="s3">\n</span><span class="s1">import type { RequestHeaders } from './fetch-server-response'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Mutates the provided URL by adding a cache-busting search parameter for CDNs that don't</span><span class="s3">\n </span><span class="s1">* support custom headers. This helps avoid caching conflicts by making each request unique.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Rather than relying on the Vary header which some CDNs ignore, we append a search param</span><span class="s3">\n </span><span class="s1">* to create a unique URL that forces a fresh request.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Example:</span><span class="s3">\n </span><span class="s1">* URL before: https://example.com/path?query=1</span><span class="s3">\n </span><span class="s1">* URL after: https://example.com/path?query=1&amp;_rsc=abc123</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Note: This function mutates the input URL directly and does not return anything.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* TODO: Since we need to use a search param anyway, we could simplify by removing the custom</span><span class="s3">\n </span><span class="s1">* headers approach entirely and just use search params.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const setCacheBustingSearchParam = (</span><span class="s3">\n  </span><span class="s1">url: URL,</span><span class="s3">\n  </span><span class="s1">headers: RequestHeaders</span><span class="s3">\n</span><span class="s1">): void =&gt; {</span><span class="s3">\n  </span><span class="s1">const uniqueCacheKey = computeCacheBustingSearchParam(</span><span class="s3">\n    </span><span class="s1">headers[NEXT_ROUTER_PREFETCH_HEADER],</span><span class="s3">\n    </span><span class="s1">headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER],</span><span class="s3">\n    </span><span class="s1">headers[NEXT_ROUTER_STATE_TREE_HEADER],</span><span class="s3">\n    </span><span class="s1">headers[NEXT_URL]</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">setCacheBustingSearchParamWithHash(url, uniqueCacheKey)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sets a cache-busting search parameter on a URL using a provided hash value.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This function performs the same logic as `setCacheBustingSearchParam` but accepts</span><span class="s3">\n </span><span class="s1">* a pre-computed hash instead of computing it from headers.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Example:</span><span class="s3">\n </span><span class="s1">* URL before: https://example.com/path?query=1</span><span class="s3">\n </span><span class="s1">* hash: </span><span class="s3">\&quot;</span><span class="s1">abc123</span><span class="s3">\&quot;\n </span><span class="s1">* URL after: https://example.com/path?query=1&amp;_rsc=abc123</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* If the hash is null, we will set `_rsc` search param without a value.</span><span class="s3">\n </span><span class="s1">* Like this: https://example.com/path?query=1&amp;_rsc</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Note: This function mutates the input URL directly and does not return anything.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const setCacheBustingSearchParamWithHash = (</span><span class="s3">\n  </span><span class="s1">url: URL,</span><span class="s3">\n  </span><span class="s1">hash: string</span><span class="s3">\n</span><span class="s1">): void =&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Note that we intentionally do not use `url.searchParams.set` here:</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* const url = new URL('https://example.com/search?q=custom%20spacing');</span><span class="s3">\n   </span><span class="s1">* url.searchParams.set('_rsc', 'abc123');</span><span class="s3">\n   </span><span class="s1">* console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&amp;_rsc=abc123</span><span class="s3">\n   </span><span class="s1">*                                                                             ^ &lt;--- this is causing confusion</span><span class="s3">\n   </span><span class="s1">* This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but</span><span class="s3">\n   </span><span class="s1">* we want to preserve the %20 as %20 if that's what the user passed in, hence the custom</span><span class="s3">\n   </span><span class="s1">* logic below.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const existingSearch = url.search</span><span class="s3">\n  </span><span class="s1">const rawQuery = existingSearch.startsWith('?')</span><span class="s3">\n    </span><span class="s1">? existingSearch.slice(1)</span><span class="s3">\n    </span><span class="s1">: existingSearch</span><span class="s3">\n\n  </span><span class="s1">// Always remove any existing cache busting param and add a fresh one to ensure</span><span class="s3">\n  </span><span class="s1">// we have the correct value based on current request headers</span><span class="s3">\n  </span><span class="s1">const pairs = rawQuery</span><span class="s3">\n    </span><span class="s1">.split('&amp;')</span><span class="s3">\n    </span><span class="s1">.filter((pair) =&gt; pair &amp;&amp; !pair.startsWith(`${NEXT_RSC_UNION_QUERY}=`))</span><span class="s3">\n\n  </span><span class="s1">if (hash.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">pairs.push(`${NEXT_RSC_UNION_QUERY}=${hash}`)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">pairs.push(`${NEXT_RSC_UNION_QUERY}`)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">url.search = pairs.length ? `?${pairs.join('&amp;')}` : ''</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;setCacheBustingSearchParam&quot;</span><span class="s0">,</span><span class="s1">&quot;setCacheBustingSearchParamWithHash&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;uniqueCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;computeCacheBustingSearchParam&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_PREFETCH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_SEGMENT_PREFETCH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_STATE_TREE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_URL&quot;</span><span class="s0">,</span><span class="s1">&quot;hash&quot;</span><span class="s0">,</span><span class="s1">&quot;existingSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;rawQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;pairs&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;pair&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_RSC_UNION_QUERY&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;IA4BaA,0BAA0B,EAAA;eAA1BA;;IA6BAC,kCAAkC,EAAA;eAAlCA;;;yCAvDkC;kCAOxC;AAmBA,MAAMD,6BAA6B,CACxCE,KACAC;IAEA,MAAMC,iBAAiBC,CAAAA,GAAAA,yBAAAA,8BAA8B,EACnDF,OAAO,CAACG,kBAAAA,2BAA2B,CAAC,EACpCH,OAAO,CAACI,kBAAAA,mCAAmC,CAAC,EAC5CJ,OAAO,CAACK,kBAAAA,6BAA6B,CAAC,EACtCL,OAAO,CAACM,kBAAAA,QAAQ,CAAC;IAEnBR,mCAAmCC,KAAKE;AAC1C;AAkBO,MAAMH,qCAAqC,CAChDC,KACAQ;IAEA;;;;;;;;;;GAUC,GACD,MAAMC,iBAAiBT,IAAIU,MAAM;IACjC,MAAMC,WAAWF,eAAeG,UAAU,CAAC,OACvCH,eAAeI,KAAK,CAAC,KACrBJ;IAEJ,+EAA+E;IAC/E,6DAA6D;IAC7D,MAAMK,QAAQH,SACXI,KAAK,CAAC,KACNC,MAAM,CAAC,CAACC,OAASA,QAAQ,CAACA,KAAKL,UAAU,CAAE,KAAEM,kBAAAA,oBAAoB,GAAC;IAErE,IAAIV,KAAKW,MAAM,GAAG,GAAG;QACnBL,MAAMM,IAAI,CAAIF,kBAAAA,oBAAoB,GAAC,MAAGV;IACxC,OAAO;QACLM,MAAMM,IAAI,CAAE,KAAEF,kBAAAA,oBAAoB;IACpC;IACAlB,IAAIU,MAAM,GAAGI,MAAMK,MAAM,GAAI,MAAGL,MAAMO,IAAI,CAAC,OAAS;AACtD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1745</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/route-params.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { DynamicParamTypesShort } from '../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">addSearchParamsIfPageSegment,</span><span class="s3">\n  </span><span class="s1">DEFAULT_SEGMENT_KEY,</span><span class="s3">\n  </span><span class="s1">PAGE_SEGMENT_KEY,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/segment'</span><span class="s3">\n</span><span class="s1">import { ROOT_SEGMENT_REQUEST_KEY } from '../shared/lib/segment-cache/segment-value-encoding'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NEXT_REWRITTEN_PATH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_REWRITTEN_QUERY_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_RSC_UNION_QUERY,</span><span class="s3">\n</span><span class="s1">} from './components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import type { NormalizedSearch } from './components/segment-cache'</span><span class="s3">\n</span><span class="s1">import type { RSCResponse } from './components/router-reducer/fetch-server-response'</span><span class="s3">\n\n</span><span class="s1">export type RouteParamValue = string | Array&lt;string&gt; | null</span><span class="s3">\n\n</span><span class="s1">export type RouteParam = {</span><span class="s3">\n  </span><span class="s1">name: string</span><span class="s3">\n  </span><span class="s1">value: RouteParamValue</span><span class="s3">\n  </span><span class="s1">type: DynamicParamTypesShort</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getRenderedSearch(response: RSCResponse): NormalizedSearch {</span><span class="s3">\n  </span><span class="s1">// If the server performed a rewrite, the search params used to render the</span><span class="s3">\n  </span><span class="s1">// page will be different from the params in the request URL. In this case,</span><span class="s3">\n  </span><span class="s1">// the response will include a header that gives the rewritten search query.</span><span class="s3">\n  </span><span class="s1">const rewrittenQuery = response.headers.get(NEXT_REWRITTEN_QUERY_HEADER)</span><span class="s3">\n  </span><span class="s1">if (rewrittenQuery !== null) {</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">rewrittenQuery === '' ? '' : '?' + rewrittenQuery</span><span class="s3">\n    </span><span class="s1">) as NormalizedSearch</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// If the header is not present, there was no rewrite, so we use the search</span><span class="s3">\n  </span><span class="s1">// query of the response URL.</span><span class="s3">\n  </span><span class="s1">return urlToUrlWithoutFlightMarker(new URL(response.url))</span><span class="s3">\n    </span><span class="s1">.search as NormalizedSearch</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getRenderedPathname(response: RSCResponse): string {</span><span class="s3">\n  </span><span class="s1">// If the server performed a rewrite, the pathname used to render the</span><span class="s3">\n  </span><span class="s1">// page will be different from the pathname in the request URL. In this case,</span><span class="s3">\n  </span><span class="s1">// the response will include a header that gives the rewritten pathname.</span><span class="s3">\n  </span><span class="s1">const rewrittenPath = response.headers.get(NEXT_REWRITTEN_PATH_HEADER)</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">rewrittenPath ?? urlToUrlWithoutFlightMarker(new URL(response.url)).pathname</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function parseDynamicParamFromURLPart(</span><span class="s3">\n  </span><span class="s1">paramType: DynamicParamTypesShort,</span><span class="s3">\n  </span><span class="s1">pathnameParts: Array&lt;string&gt;,</span><span class="s3">\n  </span><span class="s1">partIndex: number</span><span class="s3">\n</span><span class="s1">): RouteParamValue {</span><span class="s3">\n  </span><span class="s1">// This needs to match the behavior in get-dynamic-param.ts.</span><span class="s3">\n  </span><span class="s1">switch (paramType) {</span><span class="s3">\n    </span><span class="s1">// Catchalls</span><span class="s3">\n    </span><span class="s1">case 'c':</span><span class="s3">\n    </span><span class="s1">case 'ci': {</span><span class="s3">\n      </span><span class="s1">// Catchalls receive all the remaining URL parts. If there are no</span><span class="s3">\n      </span><span class="s1">// remaining pathname parts, return an empty array.</span><span class="s3">\n      </span><span class="s1">return partIndex &lt; pathnameParts.length</span><span class="s3">\n        </span><span class="s1">? pathnameParts.slice(partIndex).map((s) =&gt; encodeURIComponent(s))</span><span class="s3">\n        </span><span class="s1">: []</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Optional catchalls</span><span class="s3">\n    </span><span class="s1">case 'oc': {</span><span class="s3">\n      </span><span class="s1">// Optional catchalls receive all the remaining URL parts, unless this is</span><span class="s3">\n      </span><span class="s1">// the end of the pathname, in which case they return null.</span><span class="s3">\n      </span><span class="s1">return partIndex &lt; pathnameParts.length</span><span class="s3">\n        </span><span class="s1">? pathnameParts.slice(partIndex).map((s) =&gt; encodeURIComponent(s))</span><span class="s3">\n        </span><span class="s1">: null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Dynamic</span><span class="s3">\n    </span><span class="s1">case 'd':</span><span class="s3">\n    </span><span class="s1">case 'di': {</span><span class="s3">\n      </span><span class="s1">if (partIndex &gt;= pathnameParts.length) {</span><span class="s3">\n        </span><span class="s1">// The route tree expected there to be more parts in the URL than there</span><span class="s3">\n        </span><span class="s1">// actually are. This could happen if the x-nextjs-rewritten-path header</span><span class="s3">\n        </span><span class="s1">// is incorrectly set, or potentially due to bug in Next.js. TODO:</span><span class="s3">\n        </span><span class="s1">// Should this be a hard error? During a prefetch, we can just abort.</span><span class="s3">\n        </span><span class="s1">// During a client navigation, we could trigger a hard refresh. But if</span><span class="s3">\n        </span><span class="s1">// it happens during initial render, we don't really have any</span><span class="s3">\n        </span><span class="s1">// recovery options.</span><span class="s3">\n        </span><span class="s1">return ''</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return encodeURIComponent(pathnameParts[partIndex])</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">paramType satisfies never</span><span class="s3">\n      </span><span class="s1">return ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function doesStaticSegmentAppearInURL(segment: string): boolean {</span><span class="s3">\n  </span><span class="s1">// This is not a parameterized segment; however, we need to determine</span><span class="s3">\n  </span><span class="s1">// whether or not this segment appears in the URL. For example, this route</span><span class="s3">\n  </span><span class="s1">// groups do not appear in the URL, so they should be skipped. Any other</span><span class="s3">\n  </span><span class="s1">// special cases must be handled here.</span><span class="s3">\n  </span><span class="s1">// TODO: Consider encoding this directly into the router tree instead of</span><span class="s3">\n  </span><span class="s1">// inferring it on the client based on the segment type. Something like</span><span class="s3">\n  </span><span class="s1">// a `doesAppearInURL` flag in FlightRouterState.</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">segment === ROOT_SEGMENT_REQUEST_KEY ||</span><span class="s3">\n    </span><span class="s1">// For some reason, the loader tree sometimes includes extra __PAGE__</span><span class="s3">\n    </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">layouts</span><span class="s3">\&quot; </span><span class="s1">when part of a parallel route. But it's not a leaf node.</span><span class="s3">\n    </span><span class="s1">// Otherwise, we wouldn't need this special case because pages are</span><span class="s3">\n    </span><span class="s1">// always leaf nodes.</span><span class="s3">\n    </span><span class="s1">// TODO: Investigate why the loader produces these fake page segments.</span><span class="s3">\n    </span><span class="s1">segment.startsWith(PAGE_SEGMENT_KEY) ||</span><span class="s3">\n    </span><span class="s1">// Route groups.</span><span class="s3">\n    </span><span class="s1">(segment[0] === '(' &amp;&amp; segment.endsWith(')')) ||</span><span class="s3">\n    </span><span class="s1">segment === DEFAULT_SEGMENT_KEY ||</span><span class="s3">\n    </span><span class="s1">segment === '/_not-found'</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// All other segment types appear in the URL</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getCacheKeyForDynamicParam(</span><span class="s3">\n  </span><span class="s1">paramValue: RouteParamValue,</span><span class="s3">\n  </span><span class="s1">renderedSearch: NormalizedSearch</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">// This needs to match the logic in get-dynamic-param.ts, until we're able to</span><span class="s3">\n  </span><span class="s1">// unify the various implementations so that these are always computed on</span><span class="s3">\n  </span><span class="s1">// the client.</span><span class="s3">\n  </span><span class="s1">if (typeof paramValue === 'string') {</span><span class="s3">\n    </span><span class="s1">// TODO: Refactor or remove this helper function to accept a string rather</span><span class="s3">\n    </span><span class="s1">// than the whole segment type. Also we can probably just append the</span><span class="s3">\n    </span><span class="s1">// search string instead of turning it into JSON.</span><span class="s3">\n    </span><span class="s1">const pageSegmentWithSearchParams = addSearchParamsIfPageSegment(</span><span class="s3">\n      </span><span class="s1">paramValue,</span><span class="s3">\n      </span><span class="s1">Object.fromEntries(new URLSearchParams(renderedSearch))</span><span class="s3">\n    </span><span class="s1">) as string</span><span class="s3">\n    </span><span class="s1">return pageSegmentWithSearchParams</span><span class="s3">\n  </span><span class="s1">} else if (paramValue === null) {</span><span class="s3">\n    </span><span class="s1">return ''</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return paramValue.join('/')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function urlToUrlWithoutFlightMarker(url: URL): URL {</span><span class="s3">\n  </span><span class="s1">const urlWithoutFlightParameters = new URL(url)</span><span class="s3">\n  </span><span class="s1">urlWithoutFlightParameters.searchParams.delete(NEXT_RSC_UNION_QUERY)</span><span class="s3">\n  </span><span class="s1">if (process.env.NODE_ENV === 'production') {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">process.env.__NEXT_CONFIG_OUTPUT === 'export' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">urlWithoutFlightParameters.pathname.endsWith('.txt')</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const { pathname } = urlWithoutFlightParameters</span><span class="s3">\n      </span><span class="s1">const length = pathname.endsWith('/index.txt') ? 10 : 4</span><span class="s3">\n      </span><span class="s1">// Slice off `/index.txt` or `.txt` from the end of the pathname</span><span class="s3">\n      </span><span class="s1">urlWithoutFlightParameters.pathname = pathname.slice(0, -length)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return urlWithoutFlightParameters</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getParamValueFromCacheKey(</span><span class="s3">\n  </span><span class="s1">paramCacheKey: string,</span><span class="s3">\n  </span><span class="s1">paramType: DynamicParamTypesShort</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// Turn the cache key string sent by the server (as part of FlightRouterState)</span><span class="s3">\n  </span><span class="s1">// into a value that can be passed to `useParams` and client components.</span><span class="s3">\n  </span><span class="s1">const isCatchAll = paramType === 'c' || paramType === 'oc'</span><span class="s3">\n  </span><span class="s1">if (isCatchAll) {</span><span class="s3">\n    </span><span class="s1">// Catch-all param keys are a concatenation of the path segments.</span><span class="s3">\n    </span><span class="s1">// See equivalent logic in `getSelectedParams`.</span><span class="s3">\n    </span><span class="s1">// TODO: We should just pass the array directly, rather than concatenate</span><span class="s3">\n    </span><span class="s1">// it to a string and then split it back to an array. It needs to be an</span><span class="s3">\n    </span><span class="s1">// array in some places, like when passing a key React, but we can convert</span><span class="s3">\n    </span><span class="s1">// it at runtime in those places.</span><span class="s3">\n    </span><span class="s1">return paramCacheKey.split('/')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return paramCacheKey</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;doesStaticSegmentAppearInURL&quot;</span><span class="s0">,</span><span class="s1">&quot;getCacheKeyForDynamicParam&quot;</span><span class="s0">,</span><span class="s1">&quot;getParamValueFromCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;getRenderedPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;getRenderedSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;parseDynamicParamFromURLPart&quot;</span><span class="s0">,</span><span class="s1">&quot;urlToUrlWithoutFlightMarker&quot;</span><span class="s0">,</span><span class="s1">&quot;response&quot;</span><span class="s0">,</span><span class="s1">&quot;rewrittenQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_REWRITTEN_QUERY_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;rewrittenPath&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_REWRITTEN_PATH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;paramType&quot;</span><span class="s0">,</span><span class="s1">&quot;pathnameParts&quot;</span><span class="s0">,</span><span class="s1">&quot;partIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;s&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;ROOT_SEGMENT_REQUEST_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;PAGE_SEGMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;DEFAULT_SEGMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;paramValue&quot;</span><span class="s0">,</span><span class="s1">&quot;renderedSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;pageSegmentWithSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;addSearchParamsIfPageSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;fromEntries&quot;</span><span class="s0">,</span><span class="s1">&quot;URLSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;urlWithoutFlightParameters&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_RSC_UNION_QUERY&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CONFIG_OUTPUT&quot;</span><span class="s0">,</span><span class="s1">&quot;paramCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;isCatchAll&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1919</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/fetch-server-response.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;'use client'</span><span class="s3">\n\n</span><span class="s1">// TODO: Explicitly import from client.browser</span><span class="s3">\n</span><span class="s1">// eslint-disable-next-line import/no-extraneous-dependencies</span><span class="s3">\n</span><span class="s1">import { createFromReadableStream as createFromReadableStreamBrowser } from 'react-server-dom-webpack/client'</span><span class="s3">\n\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">NavigationFlightResponse,</span><span class="s3">\n</span><span class="s1">} from '../../../server/app-render/types'</span><span class="s3">\n\n</span><span class="s1">import type { NEXT_ROUTER_SEGMENT_PREFETCH_HEADER } from '../app-router-headers'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_PREFETCH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_STATE_TREE_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_RSC_UNION_QUERY,</span><span class="s3">\n  </span><span class="s1">NEXT_URL,</span><span class="s3">\n  </span><span class="s1">RSC_HEADER,</span><span class="s3">\n  </span><span class="s1">RSC_CONTENT_TYPE_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_HMR_REFRESH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_DID_POSTPONE_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_STALE_TIME_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../app-router-headers'</span><span class="s3">\n</span><span class="s1">import { callServer } from '../../app-call-server'</span><span class="s3">\n</span><span class="s1">import { findSourceMapURL } from '../../app-find-source-map-url'</span><span class="s3">\n</span><span class="s1">import { PrefetchKind } from './router-reducer-types'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">normalizeFlightData,</span><span class="s3">\n  </span><span class="s1">prepareFlightRouterStateForRequest,</span><span class="s3">\n  </span><span class="s1">type NormalizedFlightData,</span><span class="s3">\n</span><span class="s1">} from '../../flight-data-helpers'</span><span class="s3">\n</span><span class="s1">import { getAppBuildId } from '../../app-build-id'</span><span class="s3">\n</span><span class="s1">import { setCacheBustingSearchParam } from './set-cache-busting-search-param'</span><span class="s3">\n</span><span class="s1">import { urlToUrlWithoutFlightMarker } from '../../route-params'</span><span class="s3">\n\n</span><span class="s1">const createFromReadableStream =</span><span class="s3">\n  </span><span class="s1">createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']</span><span class="s3">\n\n</span><span class="s1">export interface FetchServerResponseOptions {</span><span class="s3">\n  </span><span class="s1">readonly flightRouterState: FlightRouterState</span><span class="s3">\n  </span><span class="s1">readonly nextUrl: string | null</span><span class="s3">\n  </span><span class="s1">readonly prefetchKind?: PrefetchKind</span><span class="s3">\n  </span><span class="s1">readonly isHmrRefresh?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type FetchServerResponseResult = {</span><span class="s3">\n  </span><span class="s1">flightData: NormalizedFlightData[] | string</span><span class="s3">\n  </span><span class="s1">canonicalUrl: URL | undefined</span><span class="s3">\n  </span><span class="s1">couldBeIntercepted: boolean</span><span class="s3">\n  </span><span class="s1">prerendered: boolean</span><span class="s3">\n  </span><span class="s1">postponed: boolean</span><span class="s3">\n  </span><span class="s1">staleTime: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RequestHeaders = {</span><span class="s3">\n  </span><span class="s1">[RSC_HEADER]?: '1'</span><span class="s3">\n  </span><span class="s1">[NEXT_ROUTER_STATE_TREE_HEADER]?: string</span><span class="s3">\n  </span><span class="s1">[NEXT_URL]?: string</span><span class="s3">\n  </span><span class="s1">[NEXT_ROUTER_PREFETCH_HEADER]?: '1' | '2'</span><span class="s3">\n  </span><span class="s1">[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]?: string</span><span class="s3">\n  </span><span class="s1">'x-deployment-id'?: string</span><span class="s3">\n  </span><span class="s1">[NEXT_HMR_REFRESH_HEADER]?: '1'</span><span class="s3">\n  </span><span class="s1">// A header that is only added in test mode to assert on fetch priority</span><span class="s3">\n  </span><span class="s1">'Next-Test-Fetch-Priority'?: RequestInit['priority']</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function doMpaNavigation(url: string): FetchServerResponseResult {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">flightData: urlToUrlWithoutFlightMarker(</span><span class="s3">\n      </span><span class="s1">new URL(url, location.origin)</span><span class="s3">\n    </span><span class="s1">).toString(),</span><span class="s3">\n    </span><span class="s1">canonicalUrl: undefined,</span><span class="s3">\n    </span><span class="s1">couldBeIntercepted: false,</span><span class="s3">\n    </span><span class="s1">prerendered: false,</span><span class="s3">\n    </span><span class="s1">postponed: false,</span><span class="s3">\n    </span><span class="s1">staleTime: -1,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">let abortController = new AbortController()</span><span class="s3">\n\n</span><span class="s1">if (typeof window !== 'undefined') {</span><span class="s3">\n  </span><span class="s1">// Abort any in-flight requests when the page is unloaded, e.g. due to</span><span class="s3">\n  </span><span class="s1">// reloading the page or performing hard navigations. This allows us to ignore</span><span class="s3">\n  </span><span class="s1">// what would otherwise be a thrown TypeError when the browser cancels the</span><span class="s3">\n  </span><span class="s1">// requests.</span><span class="s3">\n  </span><span class="s1">window.addEventListener('pagehide', () =&gt; {</span><span class="s3">\n    </span><span class="s1">abortController.abort()</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">// Use a fresh AbortController instance on pageshow, e.g. when navigating back</span><span class="s3">\n  </span><span class="s1">// and the JavaScript execution context is restored by the browser.</span><span class="s3">\n  </span><span class="s1">window.addEventListener('pageshow', () =&gt; {</span><span class="s3">\n    </span><span class="s1">abortController = new AbortController()</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Fetch the flight data for the provided url. Takes in the current router state</span><span class="s3">\n </span><span class="s1">* to decide what to render server-side.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export async function fetchServerResponse(</span><span class="s3">\n  </span><span class="s1">url: URL,</span><span class="s3">\n  </span><span class="s1">options: FetchServerResponseOptions</span><span class="s3">\n</span><span class="s1">): Promise&lt;FetchServerResponseResult&gt; {</span><span class="s3">\n  </span><span class="s1">const { flightRouterState, nextUrl, prefetchKind } = options</span><span class="s3">\n\n  </span><span class="s1">const headers: RequestHeaders = {</span><span class="s3">\n    </span><span class="s1">// Enable flight response</span><span class="s3">\n    </span><span class="s1">[RSC_HEADER]: '1',</span><span class="s3">\n    </span><span class="s1">// Provide the current router state</span><span class="s3">\n    </span><span class="s1">[NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(</span><span class="s3">\n      </span><span class="s1">flightRouterState,</span><span class="s3">\n      </span><span class="s1">options.isHmrRefresh</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Three cases:</span><span class="s3">\n   </span><span class="s1">* - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully</span><span class="s3">\n   </span><span class="s1">* - `prefetchKind` is `full` - we want to prefetch the whole page so same as above</span><span class="s3">\n   </span><span class="s1">* - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">if (prefetchKind === PrefetchKind.AUTO) {</span><span class="s3">\n    </span><span class="s1">headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NODE_ENV === 'development' &amp;&amp; options.isHmrRefresh) {</span><span class="s3">\n    </span><span class="s1">headers[NEXT_HMR_REFRESH_HEADER] = '1'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (nextUrl) {</span><span class="s3">\n    </span><span class="s1">headers[NEXT_URL] = nextUrl</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">// When creating a </span><span class="s3">\&quot;</span><span class="s1">temporary</span><span class="s3">\&quot; </span><span class="s1">prefetch (the </span><span class="s3">\&quot;</span><span class="s1">on-demand</span><span class="s3">\&quot; </span><span class="s1">prefetch that gets created on navigation, if one doesn't exist)</span><span class="s3">\n    </span><span class="s1">// we send the request with a </span><span class="s3">\&quot;</span><span class="s1">high</span><span class="s3">\&quot; </span><span class="s1">priority as it's in response to a user interaction that could be blocking a transition.</span><span class="s3">\n    </span><span class="s1">// Otherwise, all other prefetches are sent with a </span><span class="s3">\&quot;</span><span class="s1">low</span><span class="s3">\&quot; </span><span class="s1">priority.</span><span class="s3">\n    </span><span class="s1">// We use </span><span class="s3">\&quot;</span><span class="s1">auto</span><span class="s3">\&quot; </span><span class="s1">for in all other cases to match the existing default, as this function is shared outside of prefetching.</span><span class="s3">\n    </span><span class="s1">const fetchPriority = prefetchKind</span><span class="s3">\n      </span><span class="s1">? prefetchKind === PrefetchKind.TEMPORARY</span><span class="s3">\n        </span><span class="s1">? 'high'</span><span class="s3">\n        </span><span class="s1">: 'low'</span><span class="s3">\n      </span><span class="s1">: 'auto'</span><span class="s3">\n\n    </span><span class="s1">if (process.env.NODE_ENV === 'production') {</span><span class="s3">\n      </span><span class="s1">if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {</span><span class="s3">\n        </span><span class="s1">// In </span><span class="s3">\&quot;</span><span class="s1">output: export</span><span class="s3">\&quot; </span><span class="s1">mode, we can't rely on headers to distinguish</span><span class="s3">\n        </span><span class="s1">// between HTML and RSC requests. Instead, we append an extra prefix</span><span class="s3">\n        </span><span class="s1">// to the request.</span><span class="s3">\n        </span><span class="s1">url = new URL(url)</span><span class="s3">\n        </span><span class="s1">if (url.pathname.endsWith('/')) {</span><span class="s3">\n          </span><span class="s1">url.pathname += 'index.txt'</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">url.pathname += '.txt'</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const res = await createFetch(</span><span class="s3">\n      </span><span class="s1">url,</span><span class="s3">\n      </span><span class="s1">headers,</span><span class="s3">\n      </span><span class="s1">fetchPriority,</span><span class="s3">\n      </span><span class="s1">abortController.signal</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const responseUrl = urlToUrlWithoutFlightMarker(new URL(res.url))</span><span class="s3">\n    </span><span class="s1">const canonicalUrl = res.redirected ? responseUrl : undefined</span><span class="s3">\n\n    </span><span class="s1">const contentType = res.headers.get('content-type') || ''</span><span class="s3">\n    </span><span class="s1">const interception = !!res.headers.get('vary')?.includes(NEXT_URL)</span><span class="s3">\n    </span><span class="s1">const postponed = !!res.headers.get(NEXT_DID_POSTPONE_HEADER)</span><span class="s3">\n    </span><span class="s1">const staleTimeHeaderSeconds = res.headers.get(</span><span class="s3">\n      </span><span class="s1">NEXT_ROUTER_STALE_TIME_HEADER</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">const staleTime =</span><span class="s3">\n      </span><span class="s1">staleTimeHeaderSeconds !== null</span><span class="s3">\n        </span><span class="s1">? parseInt(staleTimeHeaderSeconds, 10) * 1000</span><span class="s3">\n        </span><span class="s1">: -1</span><span class="s3">\n    </span><span class="s1">let isFlightResponse = contentType.startsWith(RSC_CONTENT_TYPE_HEADER)</span><span class="s3">\n\n    </span><span class="s1">if (process.env.NODE_ENV === 'production') {</span><span class="s3">\n      </span><span class="s1">if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {</span><span class="s3">\n        </span><span class="s1">if (!isFlightResponse) {</span><span class="s3">\n          </span><span class="s1">isFlightResponse = contentType.startsWith('text/plain')</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If fetch returns something different than flight response handle it like a mpa navigation</span><span class="s3">\n    </span><span class="s1">// If the fetch was not 200, we also handle it like a mpa navigation</span><span class="s3">\n    </span><span class="s1">if (!isFlightResponse || !res.ok || !res.body) {</span><span class="s3">\n      </span><span class="s1">// in case the original URL came with a hash, preserve it before redirecting to the new URL</span><span class="s3">\n      </span><span class="s1">if (url.hash) {</span><span class="s3">\n        </span><span class="s1">responseUrl.hash = url.hash</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return doMpaNavigation(responseUrl.toString())</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// We may navigate to a page that requires a different Webpack runtime.</span><span class="s3">\n    </span><span class="s1">// In prod, every page will have the same Webpack runtime.</span><span class="s3">\n    </span><span class="s1">// In dev, the Webpack runtime is minimal for each page.</span><span class="s3">\n    </span><span class="s1">// We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.</span><span class="s3">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !process.env.TURBOPACK) {</span><span class="s3">\n      </span><span class="s1">await (</span><span class="s3">\n        </span><span class="s1">require('../../dev/hot-reloader/app/hot-reloader-app') as typeof import('../../dev/hot-reloader/app/hot-reloader-app')</span><span class="s3">\n      </span><span class="s1">).waitForWebpackRuntimeHotUpdate()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Handle the `fetch` readable stream that can be unwrapped by `React.use`.</span><span class="s3">\n    </span><span class="s1">const flightStream = postponed</span><span class="s3">\n      </span><span class="s1">? createUnclosingPrefetchStream(res.body)</span><span class="s3">\n      </span><span class="s1">: res.body</span><span class="s3">\n    </span><span class="s1">const response = await (createFromNextReadableStream(</span><span class="s3">\n      </span><span class="s1">flightStream</span><span class="s3">\n    </span><span class="s1">) as Promise&lt;NavigationFlightResponse&gt;)</span><span class="s3">\n\n    </span><span class="s1">if (getAppBuildId() !== response.b) {</span><span class="s3">\n      </span><span class="s1">return doMpaNavigation(res.url)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">flightData: normalizeFlightData(response.f),</span><span class="s3">\n      </span><span class="s1">canonicalUrl: canonicalUrl,</span><span class="s3">\n      </span><span class="s1">couldBeIntercepted: interception,</span><span class="s3">\n      </span><span class="s1">prerendered: response.S,</span><span class="s3">\n      </span><span class="s1">postponed,</span><span class="s3">\n      </span><span class="s1">staleTime,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">if (!abortController.signal.aborted) {</span><span class="s3">\n      </span><span class="s1">console.error(</span><span class="s3">\n        </span><span class="s1">`Failed to fetch RSC payload for ${url}. Falling back to browser navigation.`,</span><span class="s3">\n        </span><span class="s1">err</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If fetch fails handle it like a mpa navigation</span><span class="s3">\n    </span><span class="s1">// TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.</span><span class="s3">\n    </span><span class="s1">// See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">flightData: url.toString(),</span><span class="s3">\n      </span><span class="s1">canonicalUrl: undefined,</span><span class="s3">\n      </span><span class="s1">couldBeIntercepted: false,</span><span class="s3">\n      </span><span class="s1">prerendered: false,</span><span class="s3">\n      </span><span class="s1">postponed: false,</span><span class="s3">\n      </span><span class="s1">staleTime: -1,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// This is a subset of the standard Response type. We use a custom type for</span><span class="s3">\n</span><span class="s1">// this so we can limit which details about the response leak into the rest of</span><span class="s3">\n</span><span class="s1">// the codebase. For example, there's some custom logic for manually following</span><span class="s3">\n</span><span class="s1">// redirects, so </span><span class="s3">\&quot;</span><span class="s1">redirected</span><span class="s3">\&quot; </span><span class="s1">in this type could be a composite of multiple</span><span class="s3">\n</span><span class="s1">// browser fetch calls; however, this fact should not leak to the caller.</span><span class="s3">\n</span><span class="s1">export type RSCResponse = {</span><span class="s3">\n  </span><span class="s1">ok: boolean</span><span class="s3">\n  </span><span class="s1">redirected: boolean</span><span class="s3">\n  </span><span class="s1">headers: Headers</span><span class="s3">\n  </span><span class="s1">body: ReadableStream&lt;Uint8Array&gt; | null</span><span class="s3">\n  </span><span class="s1">status: number</span><span class="s3">\n  </span><span class="s1">url: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function createFetch(</span><span class="s3">\n  </span><span class="s1">url: URL,</span><span class="s3">\n  </span><span class="s1">headers: RequestHeaders,</span><span class="s3">\n  </span><span class="s1">fetchPriority: 'auto' | 'high' | 'low' | null,</span><span class="s3">\n  </span><span class="s1">signal?: AbortSignal</span><span class="s3">\n</span><span class="s1">): Promise&lt;RSCResponse&gt; {</span><span class="s3">\n  </span><span class="s1">// TODO: In output: </span><span class="s3">\&quot;</span><span class="s1">export</span><span class="s3">\&quot; </span><span class="s1">mode, the headers do nothing. Omit them (and the</span><span class="s3">\n  </span><span class="s1">// cache busting search param) from the request so they're</span><span class="s3">\n  </span><span class="s1">// maximally cacheable.</span><span class="s3">\n\n  </span><span class="s1">if (process.env.__NEXT_TEST_MODE &amp;&amp; fetchPriority !== null) {</span><span class="s3">\n    </span><span class="s1">headers['Next-Test-Fetch-Priority'] = fetchPriority</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NEXT_DEPLOYMENT_ID) {</span><span class="s3">\n    </span><span class="s1">headers['x-deployment-id'] = process.env.NEXT_DEPLOYMENT_ID</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const fetchOptions: RequestInit = {</span><span class="s3">\n    </span><span class="s1">// Backwards compat for older browsers. `same-origin` is the default in modern browsers.</span><span class="s3">\n    </span><span class="s1">credentials: 'same-origin',</span><span class="s3">\n    </span><span class="s1">headers,</span><span class="s3">\n    </span><span class="s1">priority: fetchPriority || undefined,</span><span class="s3">\n    </span><span class="s1">signal,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// `fetchUrl` is slightly different from `url` because we add a cache-busting</span><span class="s3">\n  </span><span class="s1">// search param to it. This should not leak outside of this function, so we</span><span class="s3">\n  </span><span class="s1">// track them separately.</span><span class="s3">\n  </span><span class="s1">let fetchUrl = new URL(url)</span><span class="s3">\n  </span><span class="s1">setCacheBustingSearchParam(fetchUrl, headers)</span><span class="s3">\n  </span><span class="s1">let browserResponse = await fetch(fetchUrl, fetchOptions)</span><span class="s3">\n\n  </span><span class="s1">// If the server responds with a redirect (e.g. 307), and the redirected</span><span class="s3">\n  </span><span class="s1">// location does not contain the cache busting search param set in the</span><span class="s3">\n  </span><span class="s1">// original request, the response is likely invalid  when following the</span><span class="s3">\n  </span><span class="s1">// redirect, the browser forwards the request headers, but since the cache</span><span class="s3">\n  </span><span class="s1">// busting search param is missing, the server will reject the request due to</span><span class="s3">\n  </span><span class="s1">// a mismatch.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Ideally, we would be able to intercept the redirect response and perform it</span><span class="s3">\n  </span><span class="s1">// manually, instead of letting the browser automatically follow it, but this</span><span class="s3">\n  </span><span class="s1">// is not allowed by the fetch API.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// So instead, we must </span><span class="s3">\&quot;</span><span class="s1">replay</span><span class="s3">\&quot; </span><span class="s1">the redirect by fetching the new location</span><span class="s3">\n  </span><span class="s1">// again, but this time we'll append the cache busting search param to prevent</span><span class="s3">\n  </span><span class="s1">// a mismatch.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// TODO: We can optimize Next.js's built-in middleware APIs by returning a</span><span class="s3">\n  </span><span class="s1">// custom status code, to prevent the browser from automatically following it.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// This does not affect Server Action-based redirects; those are encoded</span><span class="s3">\n  </span><span class="s1">// differently, as part of the Flight body. It only affects redirects that</span><span class="s3">\n  </span><span class="s1">// occur in a middleware or a third-party proxy.</span><span class="s3">\n\n  </span><span class="s1">let redirected = browserResponse.redirected</span><span class="s3">\n  </span><span class="s1">if (process.env.__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS) {</span><span class="s3">\n    </span><span class="s1">// This is to prevent a redirect loop. Same limit used by Chrome.</span><span class="s3">\n    </span><span class="s1">const MAX_REDIRECTS = 20</span><span class="s3">\n    </span><span class="s1">for (let n = 0; n &lt; MAX_REDIRECTS; n++) {</span><span class="s3">\n      </span><span class="s1">if (!browserResponse.redirected) {</span><span class="s3">\n        </span><span class="s1">// The server did not perform a redirect.</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const responseUrl = new URL(browserResponse.url, fetchUrl)</span><span class="s3">\n      </span><span class="s1">if (responseUrl.origin !== fetchUrl.origin) {</span><span class="s3">\n        </span><span class="s1">// The server redirected to an external URL. The rest of the logic below</span><span class="s3">\n        </span><span class="s1">// is not relevant, because it only applies to internal redirects.</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">responseUrl.searchParams.get(NEXT_RSC_UNION_QUERY) ===</span><span class="s3">\n        </span><span class="s1">fetchUrl.searchParams.get(NEXT_RSC_UNION_QUERY)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// The redirected URL already includes the cache busting search param.</span><span class="s3">\n        </span><span class="s1">// This was probably intentional. Regardless, there's no reason to</span><span class="s3">\n        </span><span class="s1">// issue another request to this URL because it already has the param</span><span class="s3">\n        </span><span class="s1">// value that we would have added below.</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// The RSC request was redirected. Assume the response is invalid.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// Append the cache busting search param to the redirected URL and</span><span class="s3">\n      </span><span class="s1">// fetch again.</span><span class="s3">\n      </span><span class="s1">fetchUrl = new URL(responseUrl)</span><span class="s3">\n      </span><span class="s1">setCacheBustingSearchParam(fetchUrl, headers)</span><span class="s3">\n      </span><span class="s1">browserResponse = await fetch(fetchUrl, fetchOptions)</span><span class="s3">\n      </span><span class="s1">// We just performed a manual redirect, so this is now true.</span><span class="s3">\n      </span><span class="s1">redirected = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Remove the cache busting search param from the response URL, to prevent it</span><span class="s3">\n  </span><span class="s1">// from leaking outside of this function.</span><span class="s3">\n  </span><span class="s1">const responseUrl = new URL(browserResponse.url, fetchUrl)</span><span class="s3">\n  </span><span class="s1">responseUrl.searchParams.delete(NEXT_RSC_UNION_QUERY)</span><span class="s3">\n\n  </span><span class="s1">const rscResponse: RSCResponse = {</span><span class="s3">\n    </span><span class="s1">url: responseUrl.href,</span><span class="s3">\n\n    </span><span class="s1">// This is true if any redirects occurred, either automatically by the</span><span class="s3">\n    </span><span class="s1">// browser, or manually by us. So it's different from</span><span class="s3">\n    </span><span class="s1">// `browserResponse.redirected`, which only tells us whether the browser</span><span class="s3">\n    </span><span class="s1">// followed a redirect, and only for the last response in the chain.</span><span class="s3">\n    </span><span class="s1">redirected,</span><span class="s3">\n\n    </span><span class="s1">// These can be copied from the last browser response we received. We</span><span class="s3">\n    </span><span class="s1">// intentionally only expose the subset of fields that are actually used</span><span class="s3">\n    </span><span class="s1">// elsewhere in the codebase.</span><span class="s3">\n    </span><span class="s1">ok: browserResponse.ok,</span><span class="s3">\n    </span><span class="s1">headers: browserResponse.headers,</span><span class="s3">\n    </span><span class="s1">body: browserResponse.body,</span><span class="s3">\n    </span><span class="s1">status: browserResponse.status,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return rscResponse</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createFromNextReadableStream(</span><span class="s3">\n  </span><span class="s1">flightStream: ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n</span><span class="s1">): Promise&lt;unknown&gt; {</span><span class="s3">\n  </span><span class="s1">return createFromReadableStream(flightStream, {</span><span class="s3">\n    </span><span class="s1">callServer,</span><span class="s3">\n    </span><span class="s1">findSourceMapURL,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createUnclosingPrefetchStream(</span><span class="s3">\n  </span><span class="s1">originalFlightStream: ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n</span><span class="s1">): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">// When PPR is enabled, prefetch streams may contain references that never</span><span class="s3">\n  </span><span class="s1">// resolve, because that's how we encode dynamic data access. In the decoded</span><span class="s3">\n  </span><span class="s1">// object returned by the Flight client, these are reified into hanging</span><span class="s3">\n  </span><span class="s1">// promises that suspend during render, which is effectively what we want.</span><span class="s3">\n  </span><span class="s1">// The UI resolves when it switches to the dynamic data stream</span><span class="s3">\n  </span><span class="s1">// (via useDeferredValue(dynamic, static)).</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// However, the Flight implementation currently errors if the server closes</span><span class="s3">\n  </span><span class="s1">// the response before all the references are resolved. As a cheat to work</span><span class="s3">\n  </span><span class="s1">// around this, we wrap the original stream in a new stream that never closes,</span><span class="s3">\n  </span><span class="s1">// and therefore doesn't error.</span><span class="s3">\n  </span><span class="s1">const reader = originalFlightStream.getReader()</span><span class="s3">\n  </span><span class="s1">return new ReadableStream({</span><span class="s3">\n    </span><span class="s1">async pull(controller) {</span><span class="s3">\n      </span><span class="s1">while (true) {</span><span class="s3">\n        </span><span class="s1">const { done, value } = await reader.read()</span><span class="s3">\n        </span><span class="s1">if (!done) {</span><span class="s3">\n          </span><span class="s1">// Pass to the target stream and keep consuming the Flight response</span><span class="s3">\n          </span><span class="s1">// from the server.</span><span class="s3">\n          </span><span class="s1">controller.enqueue(value)</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// The server stream has closed. Exit, but intentionally do not close</span><span class="s3">\n        </span><span class="s1">// the target stream.</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;createFetch&quot;</span><span class="s0">,</span><span class="s1">&quot;createFromNextReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchServerResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;createFromReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;createFromReadableStreamBrowser&quot;</span><span class="s0">,</span><span class="s1">&quot;doMpaNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;urlToUrlWithoutFlightMarker&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;couldBeIntercepted&quot;</span><span class="s0">,</span><span class="s1">&quot;prerendered&quot;</span><span class="s0">,</span><span class="s1">&quot;postponed&quot;</span><span class="s0">,</span><span class="s1">&quot;staleTime&quot;</span><span class="s0">,</span><span class="s1">&quot;abortController&quot;</span><span class="s0">,</span><span class="s1">&quot;AbortController&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;addEventListener&quot;</span><span class="s0">,</span><span class="s1">&quot;abort&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchKind&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_STATE_TREE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;prepareFlightRouterStateForRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;isHmrRefresh&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchKind&quot;</span><span class="s0">,</span><span class="s1">&quot;AUTO&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_PREFETCH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_HMR_REFRESH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_URL&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchPriority&quot;</span><span class="s0">,</span><span class="s1">&quot;TEMPORARY&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CONFIG_OUTPUT&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;signal&quot;</span><span class="s0">,</span><span class="s1">&quot;responseUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;redirected&quot;</span><span class="s0">,</span><span class="s1">&quot;contentType&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;interception&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_DID_POSTPONE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;staleTimeHeaderSeconds&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_STALE_TIME_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;parseInt&quot;</span><span class="s0">,</span><span class="s1">&quot;isFlightResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_CONTENT_TYPE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;ok&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;hash&quot;</span><span class="s0">,</span><span class="s1">&quot;TURBOPACK&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;waitForWebpackRuntimeHotUpdate&quot;</span><span class="s0">,</span><span class="s1">&quot;flightStream&quot;</span><span class="s0">,</span><span class="s1">&quot;createUnclosingPrefetchStream&quot;</span><span class="s0">,</span><span class="s1">&quot;response&quot;</span><span class="s0">,</span><span class="s1">&quot;getAppBuildId&quot;</span><span class="s0">,</span><span class="s1">&quot;b&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;f&quot;</span><span class="s0">,</span><span class="s1">&quot;S&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;aborted&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_TEST_MODE&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_DEPLOYMENT_ID&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;credentials&quot;</span><span class="s0">,</span><span class="s1">&quot;priority&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;setCacheBustingSearchParam&quot;</span><span class="s0">,</span><span class="s1">&quot;browserResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;fetch&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS&quot;</span><span class="s0">,</span><span class="s1">&quot;MAX_REDIRECTS&quot;</span><span class="s0">,</span><span class="s1">&quot;n&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_RSC_UNION_QUERY&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;rscResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;callServer&quot;</span><span class="s0">,</span><span class="s1">&quot;findSourceMapURL&quot;</span><span class="s0">,</span><span class="s1">&quot;originalFlightStream&quot;</span><span class="s0">,</span><span class="s1">&quot;reader&quot;</span><span class="s0">,</span><span class="s1">&quot;getReader&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;pull&quot;</span><span class="s0">,</span><span class="s1">&quot;controller&quot;</span><span class="s0">,</span><span class="s1">&quot;done&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;read&quot;</span><span class="s0">,</span><span class="s1">&quot;enqueue&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2183</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/create-router-cache-key.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { Segment } from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'</span><span class="s3">\n\n</span><span class="s1">export function createRouterCacheKey(</span><span class="s3">\n  </span><span class="s1">segment: Segment,</span><span class="s3">\n  </span><span class="s1">withoutSearchParameters: boolean = false</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// if the segment is an array, it means it's a dynamic segment</span><span class="s3">\n  </span><span class="s1">// for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.</span><span class="s3">\n  </span><span class="s1">if (Array.isArray(segment)) {</span><span class="s3">\n    </span><span class="s1">return `${segment[0]}|${segment[1]}|${segment[2]}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Page segments might have search parameters, ie __PAGE__?foo=bar</span><span class="s3">\n  </span><span class="s1">// When `withoutSearchParameters` is true, we only want to return the page segment</span><span class="s3">\n  </span><span class="s1">if (withoutSearchParameters &amp;&amp; segment.startsWith(PAGE_SEGMENT_KEY)) {</span><span class="s3">\n    </span><span class="s1">return PAGE_SEGMENT_KEY</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return segment</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;createRouterCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;withoutSearchParameters&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;PAGE_SEGMENT_KEY&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAGgBA,wBAAAA;;;eAAAA;;;yBAFiB;AAE1B,SAASA,qBACdC,OAAgB,EAChBC,uBAAwC;IAAxCA,IAAAA,4BAAAA,KAAAA,GAAAA,0BAAmC;IAEnC,8DAA8D;IAC9D,uGAAuG;IACvG,IAAIC,MAAMC,OAAO,CAACH,UAAU;QAC1B,OAAUA,OAAO,CAAC,EAAE,GAAC,MAAGA,OAAO,CAAC,EAAE,GAAC,MAAGA,OAAO,CAAC,EAAE;IAClD;IAEA,kEAAkE;IAClE,kFAAkF;IAClF,IAAIC,2BAA2BD,QAAQI,UAAU,CAACC,SAAAA,gBAAgB,GAAG;QACnE,OAAOA,SAAAA,gBAAgB;IACzB;IAEA,OAAOL;AACT&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2218</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type { FlightSegmentPath } from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { createRouterCacheKey } from './create-router-cache-key'</span><span class="s3">\n</span><span class="s1">import { getNextFlightSegmentPath } from '../../flight-data-helpers'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Fill cache up to the end of the flightSegmentPath, invalidating anything below it.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function invalidateCacheBelowFlightSegmentPath(</span><span class="s3">\n  </span><span class="s1">newCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">existingCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">flightSegmentPath: FlightSegmentPath</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const isLastEntry = flightSegmentPath.length &lt;= 2</span><span class="s3">\n  </span><span class="s1">const [parallelRouteKey, segment] = flightSegmentPath</span><span class="s3">\n\n  </span><span class="s1">const cacheKey = createRouterCacheKey(segment)</span><span class="s3">\n\n  </span><span class="s1">const existingChildSegmentMap =</span><span class="s3">\n    </span><span class="s1">existingCache.parallelRoutes.get(parallelRouteKey)</span><span class="s3">\n\n  </span><span class="s1">if (!existingChildSegmentMap) {</span><span class="s3">\n    </span><span class="s1">// Bailout because the existing cache does not have the path to the leaf node</span><span class="s3">\n    </span><span class="s1">// Will trigger lazy fetch in layout-router because of missing segment</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey)</span><span class="s3">\n  </span><span class="s1">if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {</span><span class="s3">\n    </span><span class="s1">childSegmentMap = new Map(existingChildSegmentMap)</span><span class="s3">\n    </span><span class="s1">newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// In case of last entry don't copy further down.</span><span class="s3">\n  </span><span class="s1">if (isLastEntry) {</span><span class="s3">\n    </span><span class="s1">childSegmentMap.delete(cacheKey)</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const existingChildCacheNode = existingChildSegmentMap.get(cacheKey)</span><span class="s3">\n  </span><span class="s1">let childCacheNode = childSegmentMap.get(cacheKey)</span><span class="s3">\n\n  </span><span class="s1">if (!childCacheNode || !existingChildCacheNode) {</span><span class="s3">\n    </span><span class="s1">// Bailout because the existing cache does not have the path to the leaf node</span><span class="s3">\n    </span><span class="s1">// Will trigger lazy fetch in layout-router because of missing segment</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (childCacheNode === existingChildCacheNode) {</span><span class="s3">\n    </span><span class="s1">childCacheNode = {</span><span class="s3">\n      </span><span class="s1">lazyData: childCacheNode.lazyData,</span><span class="s3">\n      </span><span class="s1">rsc: childCacheNode.rsc,</span><span class="s3">\n      </span><span class="s1">prefetchRsc: childCacheNode.prefetchRsc,</span><span class="s3">\n      </span><span class="s1">head: childCacheNode.head,</span><span class="s3">\n      </span><span class="s1">prefetchHead: childCacheNode.prefetchHead,</span><span class="s3">\n      </span><span class="s1">parallelRoutes: new Map(childCacheNode.parallelRoutes),</span><span class="s3">\n    </span><span class="s1">} as CacheNode</span><span class="s3">\n    </span><span class="s1">childSegmentMap.set(cacheKey, childCacheNode)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">invalidateCacheBelowFlightSegmentPath(</span><span class="s3">\n    </span><span class="s1">childCacheNode,</span><span class="s3">\n    </span><span class="s1">existingChildCacheNode,</span><span class="s3">\n    </span><span class="s1">getNextFlightSegmentPath(flightSegmentPath)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;invalidateCacheBelowFlightSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;newCache&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCache&quot;</span><span class="s0">,</span><span class="s1">&quot;flightSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isLastEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;createRouterCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;existingChildSegmentMap&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;childSegmentMap&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;existingChildCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;childCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyData&quot;</span><span class="s0">,</span><span class="s1">&quot;rsc&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchHead&quot;</span><span class="s0">,</span><span class="s1">&quot;getNextFlightSegmentPath&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAQgBA,yCAAAA;;;eAAAA;;;sCANqB;mCACI;AAKlC,SAASA,sCACdC,QAAmB,EACnBC,aAAwB,EACxBC,iBAAoC;IAEpC,MAAMC,cAAcD,kBAAkBE,MAAM,IAAI;IAChD,MAAM,CAACC,kBAAkBC,QAAQ,GAAGJ;IAEpC,MAAMK,WAAWC,CAAAA,GAAAA,sBAAAA,oBAAoB,EAACF;IAEtC,MAAMG,0BACJR,cAAcS,cAAc,CAACC,GAAG,CAACN;IAEnC,IAAI,CAACI,yBAAyB;QAC5B,6EAA6E;QAC7E,sEAAsE;QACtE;IACF;IAEA,IAAIG,kBAAkBZ,SAASU,cAAc,CAACC,GAAG,CAACN;IAClD,IAAI,CAACO,mBAAmBA,oBAAoBH,yBAAyB;QACnEG,kBAAkB,IAAIC,IAAIJ;QAC1BT,SAASU,cAAc,CAACI,GAAG,CAACT,kBAAkBO;IAChD;IAEA,iDAAiD;IACjD,IAAIT,aAAa;QACfS,gBAAgBG,MAAM,CAACR;QACvB;IACF;IAEA,MAAMS,yBAAyBP,wBAAwBE,GAAG,CAACJ;IAC3D,IAAIU,iBAAiBL,gBAAgBD,GAAG,CAACJ;IAEzC,IAAI,CAACU,kBAAkB,CAACD,wBAAwB;QAC9C,6EAA6E;QAC7E,sEAAsE;QACtE;IACF;IAEA,IAAIC,mBAAmBD,wBAAwB;QAC7CC,iBAAiB;YACfC,UAAUD,eAAeC,QAAQ;YACjCC,KAAKF,eAAeE,GAAG;YACvBC,aAAaH,eAAeG,WAAW;YACvCC,MAAMJ,eAAeI,IAAI;YACzBC,cAAcL,eAAeK,YAAY;YACzCZ,gBAAgB,IAAIG,IAAII,eAAeP,cAAc;QACvD;QACAE,gBAAgBE,GAAG,CAACP,UAAUU;IAChC;IAEAlB,sCACEkB,gBACAD,wBACAO,CAAAA,GAAAA,mBAAAA,wBAAwB,EAACrB;AAE7B&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2280</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/match-segments.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { Segment } from '../../server/app-render/types'</span><span class="s3">\n\n</span><span class="s1">export const matchSegment = (</span><span class="s3">\n  </span><span class="s1">existingSegment: Segment,</span><span class="s3">\n  </span><span class="s1">segment: Segment</span><span class="s3">\n</span><span class="s1">): boolean =&gt; {</span><span class="s3">\n  </span><span class="s1">// segment is either Array or string</span><span class="s3">\n  </span><span class="s1">if (typeof existingSegment === 'string') {</span><span class="s3">\n    </span><span class="s1">if (typeof segment === 'string') {</span><span class="s3">\n      </span><span class="s1">// Common case: segment is just a string</span><span class="s3">\n      </span><span class="s1">return existingSegment === segment</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (typeof segment === 'string') {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return existingSegment[0] === segment[0] &amp;&amp; existingSegment[1] === segment[1]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;matchSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;existingSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAEaA,gBAAAA;;;eAAAA;;;AAAN,MAAMA,eAAe,CAC1BC,iBACAC;IAEA,oCAAoC;IACpC,IAAI,OAAOD,oBAAoB,UAAU;QACvC,IAAI,OAAOC,YAAY,UAAU;YAC/B,wCAAwC;YACxC,OAAOD,oBAAoBC;QAC7B;QACA,OAAO;IACT;IAEA,IAAI,OAAOA,YAAY,UAAU;QAC/B,OAAO;IACT;IACA,OAAOD,eAAe,CAAC,EAAE,KAAKC,OAAO,CAAC,EAAE,IAAID,eAAe,CAAC,EAAE,KAAKC,OAAO,CAAC,EAAE;AAC/E&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2314</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">CacheNodeSeedData,</span><span class="s3">\n</span><span class="s1">} from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { createRouterCacheKey } from './create-router-cache-key'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">PrefetchCacheEntryStatus,</span><span class="s3">\n  </span><span class="s1">type PrefetchCacheEntry,</span><span class="s3">\n</span><span class="s1">} from './router-reducer-types'</span><span class="s3">\n\n</span><span class="s1">export function fillLazyItemsTillLeafWithHead(</span><span class="s3">\n  </span><span class="s1">navigatedAt: number,</span><span class="s3">\n  </span><span class="s1">newCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">existingCache: CacheNode | undefined,</span><span class="s3">\n  </span><span class="s1">routerState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">cacheNodeSeedData: CacheNodeSeedData | null,</span><span class="s3">\n  </span><span class="s1">head: React.ReactNode,</span><span class="s3">\n  </span><span class="s1">prefetchEntry: PrefetchCacheEntry | undefined</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const isLastSegment = Object.keys(routerState[1]).length === 0</span><span class="s3">\n  </span><span class="s1">if (isLastSegment) {</span><span class="s3">\n    </span><span class="s1">newCache.head = head</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Remove segment that we got data for so that it is filled in during rendering of rsc.</span><span class="s3">\n  </span><span class="s1">for (const key in routerState[1]) {</span><span class="s3">\n    </span><span class="s1">const parallelRouteState = routerState[1][key]</span><span class="s3">\n    </span><span class="s1">const segmentForParallelRoute = parallelRouteState[0]</span><span class="s3">\n    </span><span class="s1">const cacheKey = createRouterCacheKey(segmentForParallelRoute)</span><span class="s3">\n\n    </span><span class="s1">// TODO: We should traverse the cacheNodeSeedData tree instead of the router</span><span class="s3">\n    </span><span class="s1">// state tree. Ideally, they would always be the same shape, but because of</span><span class="s3">\n    </span><span class="s1">// the loading.js pattern, cacheNodeSeedData sometimes only represents a</span><span class="s3">\n    </span><span class="s1">// partial tree. That's why this node is sometimes null. Once PPR lands,</span><span class="s3">\n    </span><span class="s1">// loading.js will no longer have special behavior and we can traverse the</span><span class="s3">\n    </span><span class="s1">// data tree instead.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// We should also consider merging the router state tree and the data tree</span><span class="s3">\n    </span><span class="s1">// in the response format, so that we don't have to send the keys twice.</span><span class="s3">\n    </span><span class="s1">// Then the client can convert them into separate representations.</span><span class="s3">\n    </span><span class="s1">const parallelSeedData =</span><span class="s3">\n      </span><span class="s1">cacheNodeSeedData !== null &amp;&amp; cacheNodeSeedData[2][key] !== undefined</span><span class="s3">\n        </span><span class="s1">? cacheNodeSeedData[2][key]</span><span class="s3">\n        </span><span class="s1">: null</span><span class="s3">\n    </span><span class="s1">if (existingCache) {</span><span class="s3">\n      </span><span class="s1">const existingParallelRoutesCacheNode =</span><span class="s3">\n        </span><span class="s1">existingCache.parallelRoutes.get(key)</span><span class="s3">\n      </span><span class="s1">if (existingParallelRoutesCacheNode) {</span><span class="s3">\n        </span><span class="s1">const hasReusablePrefetch =</span><span class="s3">\n          </span><span class="s1">prefetchEntry?.kind === 'auto' &amp;&amp;</span><span class="s3">\n          </span><span class="s1">prefetchEntry.status === PrefetchCacheEntryStatus.reusable</span><span class="s3">\n\n        </span><span class="s1">let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode)</span><span class="s3">\n        </span><span class="s1">const existingCacheNode = parallelRouteCacheNode.get(cacheKey)</span><span class="s3">\n        </span><span class="s1">let newCacheNode: CacheNode</span><span class="s3">\n        </span><span class="s1">if (parallelSeedData !== null) {</span><span class="s3">\n          </span><span class="s1">// New data was sent from the server.</span><span class="s3">\n          </span><span class="s1">const seedNode = parallelSeedData[1]</span><span class="s3">\n          </span><span class="s1">const loading = parallelSeedData[3]</span><span class="s3">\n          </span><span class="s1">newCacheNode = {</span><span class="s3">\n            </span><span class="s1">lazyData: null,</span><span class="s3">\n            </span><span class="s1">rsc: seedNode,</span><span class="s3">\n            </span><span class="s1">// This is a PPR-only field. When PPR is enabled, we shouldn't hit</span><span class="s3">\n            </span><span class="s1">// this path during a navigation, but until PPR is fully implemented</span><span class="s3">\n            </span><span class="s1">// yet it's possible the existing node does have a non-null</span><span class="s3">\n            </span><span class="s1">// `prefetchRsc`. As an incremental step, we'll just de-opt to the</span><span class="s3">\n            </span><span class="s1">// old behavior  no PPR value.</span><span class="s3">\n            </span><span class="s1">prefetchRsc: null,</span><span class="s3">\n            </span><span class="s1">head: null,</span><span class="s3">\n            </span><span class="s1">prefetchHead: null,</span><span class="s3">\n            </span><span class="s1">loading,</span><span class="s3">\n            </span><span class="s1">parallelRoutes: new Map(existingCacheNode?.parallelRoutes),</span><span class="s3">\n            </span><span class="s1">navigatedAt,</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (hasReusablePrefetch &amp;&amp; existingCacheNode) {</span><span class="s3">\n          </span><span class="s1">// No new data was sent from the server, but the existing cache node</span><span class="s3">\n          </span><span class="s1">// was prefetched, so we should reuse that.</span><span class="s3">\n          </span><span class="s1">newCacheNode = {</span><span class="s3">\n            </span><span class="s1">lazyData: existingCacheNode.lazyData,</span><span class="s3">\n            </span><span class="s1">rsc: existingCacheNode.rsc,</span><span class="s3">\n            </span><span class="s1">// This is a PPR-only field. Unlike the previous branch, since we're</span><span class="s3">\n            </span><span class="s1">// just cloning the existing cache node, we might as well keep the</span><span class="s3">\n            </span><span class="s1">// PPR value, if it exists.</span><span class="s3">\n            </span><span class="s1">prefetchRsc: existingCacheNode.prefetchRsc,</span><span class="s3">\n            </span><span class="s1">head: existingCacheNode.head,</span><span class="s3">\n            </span><span class="s1">prefetchHead: existingCacheNode.prefetchHead,</span><span class="s3">\n            </span><span class="s1">parallelRoutes: new Map(existingCacheNode.parallelRoutes),</span><span class="s3">\n            </span><span class="s1">loading: existingCacheNode.loading,</span><span class="s3">\n          </span><span class="s1">} as CacheNode</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// No data available for this node. This will trigger a lazy fetch</span><span class="s3">\n          </span><span class="s1">// during render.</span><span class="s3">\n          </span><span class="s1">newCacheNode = {</span><span class="s3">\n            </span><span class="s1">lazyData: null,</span><span class="s3">\n            </span><span class="s1">rsc: null,</span><span class="s3">\n            </span><span class="s1">prefetchRsc: null,</span><span class="s3">\n            </span><span class="s1">head: null,</span><span class="s3">\n            </span><span class="s1">prefetchHead: null,</span><span class="s3">\n            </span><span class="s1">parallelRoutes: new Map(existingCacheNode?.parallelRoutes),</span><span class="s3">\n            </span><span class="s1">loading: null,</span><span class="s3">\n            </span><span class="s1">navigatedAt,</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Overrides the cache key with the new cache node.</span><span class="s3">\n        </span><span class="s1">parallelRouteCacheNode.set(cacheKey, newCacheNode)</span><span class="s3">\n        </span><span class="s1">// Traverse deeper to apply the head / fill lazy items till the head.</span><span class="s3">\n        </span><span class="s1">fillLazyItemsTillLeafWithHead(</span><span class="s3">\n          </span><span class="s1">navigatedAt,</span><span class="s3">\n          </span><span class="s1">newCacheNode,</span><span class="s3">\n          </span><span class="s1">existingCacheNode,</span><span class="s3">\n          </span><span class="s1">parallelRouteState,</span><span class="s3">\n          </span><span class="s1">parallelSeedData ? parallelSeedData : null,</span><span class="s3">\n          </span><span class="s1">head,</span><span class="s3">\n          </span><span class="s1">prefetchEntry</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">newCache.parallelRoutes.set(key, parallelRouteCacheNode)</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let newCacheNode: CacheNode</span><span class="s3">\n    </span><span class="s1">if (parallelSeedData !== null) {</span><span class="s3">\n      </span><span class="s1">// New data was sent from the server.</span><span class="s3">\n      </span><span class="s1">const seedNode = parallelSeedData[1]</span><span class="s3">\n      </span><span class="s1">const loading = parallelSeedData[3]</span><span class="s3">\n      </span><span class="s1">newCacheNode = {</span><span class="s3">\n        </span><span class="s1">lazyData: null,</span><span class="s3">\n        </span><span class="s1">rsc: seedNode,</span><span class="s3">\n        </span><span class="s1">prefetchRsc: null,</span><span class="s3">\n        </span><span class="s1">head: null,</span><span class="s3">\n        </span><span class="s1">prefetchHead: null,</span><span class="s3">\n        </span><span class="s1">parallelRoutes: new Map(),</span><span class="s3">\n        </span><span class="s1">loading,</span><span class="s3">\n        </span><span class="s1">navigatedAt,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// No data available for this node. This will trigger a lazy fetch</span><span class="s3">\n      </span><span class="s1">// during render.</span><span class="s3">\n      </span><span class="s1">newCacheNode = {</span><span class="s3">\n        </span><span class="s1">lazyData: null,</span><span class="s3">\n        </span><span class="s1">rsc: null,</span><span class="s3">\n        </span><span class="s1">prefetchRsc: null,</span><span class="s3">\n        </span><span class="s1">head: null,</span><span class="s3">\n        </span><span class="s1">prefetchHead: null,</span><span class="s3">\n        </span><span class="s1">parallelRoutes: new Map(),</span><span class="s3">\n        </span><span class="s1">loading: null,</span><span class="s3">\n        </span><span class="s1">navigatedAt,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const existingParallelRoutes = newCache.parallelRoutes.get(key)</span><span class="s3">\n    </span><span class="s1">if (existingParallelRoutes) {</span><span class="s3">\n      </span><span class="s1">existingParallelRoutes.set(cacheKey, newCacheNode)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">newCache.parallelRoutes.set(key, new Map([[cacheKey, newCacheNode]]))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">fillLazyItemsTillLeafWithHead(</span><span class="s3">\n      </span><span class="s1">navigatedAt,</span><span class="s3">\n      </span><span class="s1">newCacheNode,</span><span class="s3">\n      </span><span class="s1">undefined,</span><span class="s3">\n      </span><span class="s1">parallelRouteState,</span><span class="s3">\n      </span><span class="s1">parallelSeedData,</span><span class="s3">\n      </span><span class="s1">head,</span><span class="s3">\n      </span><span class="s1">prefetchEntry</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;fillLazyItemsTillLeafWithHead&quot;</span><span class="s0">,</span><span class="s1">&quot;navigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;newCache&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCache&quot;</span><span class="s0">,</span><span class="s1">&quot;routerState&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheNodeSeedData&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;isLastSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteState&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentForParallelRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;createRouterCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelSeedData&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;existingParallelRoutesCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;hasReusablePrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchCacheEntryStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;reusable&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;newCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;seedNode&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyData&quot;</span><span class="s0">,</span><span class="s1">&quot;rsc&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchHead&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;existingParallelRoutes&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2464</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/invalidate-cache-by-router-state.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type { FlightRouterState } from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { createRouterCacheKey } from './create-router-cache-key'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Invalidate cache one level down from the router state.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function invalidateCacheByRouterState(</span><span class="s3">\n  </span><span class="s1">newCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">existingCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">routerState: FlightRouterState</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">// Remove segment that we got data for so that it is filled in during rendering of rsc.</span><span class="s3">\n  </span><span class="s1">for (const key in routerState[1]) {</span><span class="s3">\n    </span><span class="s1">const segmentForParallelRoute = routerState[1][key][0]</span><span class="s3">\n    </span><span class="s1">const cacheKey = createRouterCacheKey(segmentForParallelRoute)</span><span class="s3">\n    </span><span class="s1">const existingParallelRoutesCacheNode =</span><span class="s3">\n      </span><span class="s1">existingCache.parallelRoutes.get(key)</span><span class="s3">\n    </span><span class="s1">if (existingParallelRoutesCacheNode) {</span><span class="s3">\n      </span><span class="s1">let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode)</span><span class="s3">\n      </span><span class="s1">parallelRouteCacheNode.delete(cacheKey)</span><span class="s3">\n      </span><span class="s1">newCache.parallelRoutes.set(key, parallelRouteCacheNode)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;invalidateCacheByRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;newCache&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCache&quot;</span><span class="s0">,</span><span class="s1">&quot;routerState&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentForParallelRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;createRouterCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;existingParallelRoutesCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAOgBA,gCAAAA;;;eAAAA;;;sCALqB;AAK9B,SAASA,6BACdC,QAAmB,EACnBC,aAAwB,EACxBC,WAA8B;IAE9B,uFAAuF;IACvF,IAAK,MAAMC,OAAOD,WAAW,CAAC,EAAE,CAAE;QAChC,MAAME,0BAA0BF,WAAW,CAAC,EAAE,CAACC,IAAI,CAAC,EAAE;QACtD,MAAME,WAAWC,CAAAA,GAAAA,sBAAAA,oBAAoB,EAACF;QACtC,MAAMG,kCACJN,cAAcO,cAAc,CAACC,GAAG,CAACN;QACnC,IAAII,iCAAiC;YACnC,IAAIG,yBAAyB,IAAIC,IAAIJ;YACrCG,uBAAuBE,MAAM,CAACP;YAC9BL,SAASQ,cAAc,CAACK,GAAG,CAACV,KAAKO;QACnC;IACF;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2498</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/fill-cache-with-new-subtree-data.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type { Segment } from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { invalidateCacheByRouterState } from './invalidate-cache-by-router-state'</span><span class="s3">\n</span><span class="s1">import { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'</span><span class="s3">\n</span><span class="s1">import { createRouterCacheKey } from './create-router-cache-key'</span><span class="s3">\n</span><span class="s1">import type { PrefetchCacheEntry } from './router-reducer-types'</span><span class="s3">\n</span><span class="s1">import { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'</span><span class="s3">\n</span><span class="s1">import type { NormalizedFlightData } from '../../flight-data-helpers'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Common logic for filling cache with new sub tree data.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function fillCacheHelper(</span><span class="s3">\n  </span><span class="s1">navigatedAt: number,</span><span class="s3">\n  </span><span class="s1">newCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">existingCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">flightData: NormalizedFlightData,</span><span class="s3">\n  </span><span class="s1">prefetchEntry: PrefetchCacheEntry | undefined,</span><span class="s3">\n  </span><span class="s1">fillLazyItems: boolean</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">segmentPath,</span><span class="s3">\n    </span><span class="s1">seedData: cacheNodeSeedData,</span><span class="s3">\n    </span><span class="s1">tree: treePatch,</span><span class="s3">\n    </span><span class="s1">head,</span><span class="s3">\n  </span><span class="s1">} = flightData</span><span class="s3">\n  </span><span class="s1">let newCacheNode = newCache</span><span class="s3">\n  </span><span class="s1">let existingCacheNode = existingCache</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; segmentPath.length; i += 2) {</span><span class="s3">\n    </span><span class="s1">const parallelRouteKey: string = segmentPath[i]</span><span class="s3">\n    </span><span class="s1">const segment: Segment = segmentPath[i + 1]</span><span class="s3">\n\n    </span><span class="s1">// segmentPath is a repeating tuple of parallelRouteKey and segment</span><span class="s3">\n    </span><span class="s1">// we know we've hit the last entry we've reached our final pair</span><span class="s3">\n    </span><span class="s1">const isLastEntry = i === segmentPath.length - 2</span><span class="s3">\n    </span><span class="s1">const cacheKey = createRouterCacheKey(segment)</span><span class="s3">\n\n    </span><span class="s1">const existingChildSegmentMap =</span><span class="s3">\n      </span><span class="s1">existingCacheNode.parallelRoutes.get(parallelRouteKey)</span><span class="s3">\n\n    </span><span class="s1">if (!existingChildSegmentMap) {</span><span class="s3">\n      </span><span class="s1">// Bailout because the existing cache does not have the path to the leaf node</span><span class="s3">\n      </span><span class="s1">// Will trigger lazy fetch in layout-router because of missing segment</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let childSegmentMap = newCacheNode.parallelRoutes.get(parallelRouteKey)</span><span class="s3">\n    </span><span class="s1">if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {</span><span class="s3">\n      </span><span class="s1">childSegmentMap = new Map(existingChildSegmentMap)</span><span class="s3">\n      </span><span class="s1">newCacheNode.parallelRoutes.set(parallelRouteKey, childSegmentMap)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const existingChildCacheNode = existingChildSegmentMap.get(cacheKey)</span><span class="s3">\n    </span><span class="s1">let childCacheNode = childSegmentMap.get(cacheKey)</span><span class="s3">\n\n    </span><span class="s1">if (isLastEntry) {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">cacheNodeSeedData &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(!childCacheNode ||</span><span class="s3">\n          </span><span class="s1">!childCacheNode.lazyData ||</span><span class="s3">\n          </span><span class="s1">childCacheNode === existingChildCacheNode)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">const incomingSegment = cacheNodeSeedData[0]</span><span class="s3">\n        </span><span class="s1">const rsc = cacheNodeSeedData[1]</span><span class="s3">\n        </span><span class="s1">const loading = cacheNodeSeedData[3]</span><span class="s3">\n\n        </span><span class="s1">childCacheNode = {</span><span class="s3">\n          </span><span class="s1">lazyData: null,</span><span class="s3">\n          </span><span class="s1">// When `fillLazyItems` is false, we only want to fill the RSC data for the layout,</span><span class="s3">\n          </span><span class="s1">// not the page segment.</span><span class="s3">\n          </span><span class="s1">rsc:</span><span class="s3">\n            </span><span class="s1">fillLazyItems || incomingSegment !== PAGE_SEGMENT_KEY ? rsc : null,</span><span class="s3">\n          </span><span class="s1">prefetchRsc: null,</span><span class="s3">\n          </span><span class="s1">head: null,</span><span class="s3">\n          </span><span class="s1">prefetchHead: null,</span><span class="s3">\n          </span><span class="s1">loading,</span><span class="s3">\n          </span><span class="s1">parallelRoutes:</span><span class="s3">\n            </span><span class="s1">fillLazyItems &amp;&amp; existingChildCacheNode</span><span class="s3">\n              </span><span class="s1">? new Map(existingChildCacheNode.parallelRoutes)</span><span class="s3">\n              </span><span class="s1">: new Map(),</span><span class="s3">\n          </span><span class="s1">navigatedAt,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (existingChildCacheNode &amp;&amp; fillLazyItems) {</span><span class="s3">\n          </span><span class="s1">invalidateCacheByRouterState(</span><span class="s3">\n            </span><span class="s1">childCacheNode,</span><span class="s3">\n            </span><span class="s1">existingChildCacheNode,</span><span class="s3">\n            </span><span class="s1">treePatch</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (fillLazyItems) {</span><span class="s3">\n          </span><span class="s1">fillLazyItemsTillLeafWithHead(</span><span class="s3">\n            </span><span class="s1">navigatedAt,</span><span class="s3">\n            </span><span class="s1">childCacheNode,</span><span class="s3">\n            </span><span class="s1">existingChildCacheNode,</span><span class="s3">\n            </span><span class="s1">treePatch,</span><span class="s3">\n            </span><span class="s1">cacheNodeSeedData,</span><span class="s3">\n            </span><span class="s1">head,</span><span class="s3">\n            </span><span class="s1">prefetchEntry</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">childSegmentMap.set(cacheKey, childCacheNode)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!childCacheNode || !existingChildCacheNode) {</span><span class="s3">\n      </span><span class="s1">// Bailout because the existing cache does not have the path to the leaf node</span><span class="s3">\n      </span><span class="s1">// Will trigger lazy fetch in layout-router because of missing segment</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (childCacheNode === existingChildCacheNode) {</span><span class="s3">\n      </span><span class="s1">childCacheNode = {</span><span class="s3">\n        </span><span class="s1">lazyData: childCacheNode.lazyData,</span><span class="s3">\n        </span><span class="s1">rsc: childCacheNode.rsc,</span><span class="s3">\n        </span><span class="s1">prefetchRsc: childCacheNode.prefetchRsc,</span><span class="s3">\n        </span><span class="s1">head: childCacheNode.head,</span><span class="s3">\n        </span><span class="s1">prefetchHead: childCacheNode.prefetchHead,</span><span class="s3">\n        </span><span class="s1">parallelRoutes: new Map(childCacheNode.parallelRoutes),</span><span class="s3">\n        </span><span class="s1">loading: childCacheNode.loading,</span><span class="s3">\n      </span><span class="s1">} as CacheNode</span><span class="s3">\n      </span><span class="s1">childSegmentMap.set(cacheKey, childCacheNode)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Move deeper into the cache nodes</span><span class="s3">\n    </span><span class="s1">newCacheNode = childCacheNode</span><span class="s3">\n    </span><span class="s1">existingCacheNode = existingChildCacheNode</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Fill cache with rsc based on flightDataPath</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function fillCacheWithNewSubTreeData(</span><span class="s3">\n  </span><span class="s1">navigatedAt: number,</span><span class="s3">\n  </span><span class="s1">newCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">existingCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">flightData: NormalizedFlightData,</span><span class="s3">\n  </span><span class="s1">prefetchEntry?: PrefetchCacheEntry</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">fillCacheHelper(</span><span class="s3">\n    </span><span class="s1">navigatedAt,</span><span class="s3">\n    </span><span class="s1">newCache,</span><span class="s3">\n    </span><span class="s1">existingCache,</span><span class="s3">\n    </span><span class="s1">flightData,</span><span class="s3">\n    </span><span class="s1">prefetchEntry,</span><span class="s3">\n    </span><span class="s1">true</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function fillCacheWithNewSubTreeDataButOnlyLoading(</span><span class="s3">\n  </span><span class="s1">navigatedAt: number,</span><span class="s3">\n  </span><span class="s1">newCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">existingCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">flightData: NormalizedFlightData,</span><span class="s3">\n  </span><span class="s1">prefetchEntry?: PrefetchCacheEntry</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">fillCacheHelper(</span><span class="s3">\n    </span><span class="s1">navigatedAt,</span><span class="s3">\n    </span><span class="s1">newCache,</span><span class="s3">\n    </span><span class="s1">existingCache,</span><span class="s3">\n    </span><span class="s1">flightData,</span><span class="s3">\n    </span><span class="s1">prefetchEntry,</span><span class="s3">\n    </span><span class="s1">false</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;fillCacheWithNewSubTreeData&quot;</span><span class="s0">,</span><span class="s1">&quot;fillCacheWithNewSubTreeDataButOnlyLoading&quot;</span><span class="s0">,</span><span class="s1">&quot;fillCacheHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;navigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;newCache&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCache&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;fillLazyItems&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;seedData&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheNodeSeedData&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;treePatch&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;newCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;isLastEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;createRouterCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;existingChildSegmentMap&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;childSegmentMap&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;existingChildCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;childCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyData&quot;</span><span class="s0">,</span><span class="s1">&quot;incomingSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;rsc&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;PAGE_SEGMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchHead&quot;</span><span class="s0">,</span><span class="s1">&quot;invalidateCacheByRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;fillLazyItemsTillLeafWithHead&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2611</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/apply-flight-data.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'</span><span class="s3">\n</span><span class="s1">import { fillCacheWithNewSubTreeData } from './fill-cache-with-new-subtree-data'</span><span class="s3">\n</span><span class="s1">import type { PrefetchCacheEntry } from './router-reducer-types'</span><span class="s3">\n</span><span class="s1">import type { NormalizedFlightData } from '../../flight-data-helpers'</span><span class="s3">\n\n</span><span class="s1">export function applyFlightData(</span><span class="s3">\n  </span><span class="s1">navigatedAt: number,</span><span class="s3">\n  </span><span class="s1">existingCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">cache: CacheNode,</span><span class="s3">\n  </span><span class="s1">flightData: NormalizedFlightData,</span><span class="s3">\n  </span><span class="s1">prefetchEntry?: PrefetchCacheEntry</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">// The one before last item is the router state tree patch</span><span class="s3">\n  </span><span class="s1">const { tree: treePatch, seedData, head, isRootRender } = flightData</span><span class="s3">\n\n  </span><span class="s1">// Handles case where prefetch only returns the router tree patch without rendered components.</span><span class="s3">\n  </span><span class="s1">if (seedData === null) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (isRootRender) {</span><span class="s3">\n    </span><span class="s1">const rsc = seedData[1]</span><span class="s3">\n    </span><span class="s1">const loading = seedData[3]</span><span class="s3">\n    </span><span class="s1">cache.loading = loading</span><span class="s3">\n    </span><span class="s1">cache.rsc = rsc</span><span class="s3">\n    </span><span class="s1">// This is a PPR-only field. When PPR is enabled, we shouldn't hit</span><span class="s3">\n    </span><span class="s1">// this path during a navigation, but until PPR is fully implemented</span><span class="s3">\n    </span><span class="s1">// yet it's possible the existing node does have a non-null</span><span class="s3">\n    </span><span class="s1">// `prefetchRsc`. As an incremental step, we'll just de-opt to the</span><span class="s3">\n    </span><span class="s1">// old behavior  no PPR value.</span><span class="s3">\n    </span><span class="s1">cache.prefetchRsc = null</span><span class="s3">\n    </span><span class="s1">fillLazyItemsTillLeafWithHead(</span><span class="s3">\n      </span><span class="s1">navigatedAt,</span><span class="s3">\n      </span><span class="s1">cache,</span><span class="s3">\n      </span><span class="s1">existingCache,</span><span class="s3">\n      </span><span class="s1">treePatch,</span><span class="s3">\n      </span><span class="s1">seedData,</span><span class="s3">\n      </span><span class="s1">head,</span><span class="s3">\n      </span><span class="s1">prefetchEntry</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// Copy rsc for the root node of the cache.</span><span class="s3">\n    </span><span class="s1">cache.rsc = existingCache.rsc</span><span class="s3">\n    </span><span class="s1">// This is a PPR-only field. Unlike the previous branch, since we're</span><span class="s3">\n    </span><span class="s1">// just cloning the existing cache node, we might as well keep the</span><span class="s3">\n    </span><span class="s1">// PPR value, if it exists.</span><span class="s3">\n    </span><span class="s1">cache.prefetchRsc = existingCache.prefetchRsc</span><span class="s3">\n    </span><span class="s1">cache.parallelRoutes = new Map(existingCache.parallelRoutes)</span><span class="s3">\n    </span><span class="s1">cache.loading = existingCache.loading</span><span class="s3">\n    </span><span class="s1">// Create a copy of the existing cache with the rsc applied.</span><span class="s3">\n    </span><span class="s1">fillCacheWithNewSubTreeData(</span><span class="s3">\n      </span><span class="s1">navigatedAt,</span><span class="s3">\n      </span><span class="s1">cache,</span><span class="s3">\n      </span><span class="s1">existingCache,</span><span class="s3">\n      </span><span class="s1">flightData,</span><span class="s3">\n      </span><span class="s1">prefetchEntry</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;applyFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;navigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCache&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;treePatch&quot;</span><span class="s0">,</span><span class="s1">&quot;seedData&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootRender&quot;</span><span class="s0">,</span><span class="s1">&quot;rsc&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;fillLazyItemsTillLeafWithHead&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;fillCacheWithNewSubTreeData&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAMgBA,mBAAAA;;;eAAAA;;;+CAL8B;6CACF;AAIrC,SAASA,gBACdC,WAAmB,EACnBC,aAAwB,EACxBC,KAAgB,EAChBC,UAAgC,EAChCC,aAAkC;IAElC,0DAA0D;IAC1D,MAAM,EAAEC,MAAMC,SAAS,EAAEC,QAAQ,EAAEC,IAAI,EAAEC,YAAY,EAAE,GAAGN;IAE1D,8FAA8F;IAC9F,IAAII,aAAa,MAAM;QACrB,OAAO;IACT;IAEA,IAAIE,cAAc;QAChB,MAAMC,MAAMH,QAAQ,CAAC,EAAE;QACvB,MAAMI,UAAUJ,QAAQ,CAAC,EAAE;QAC3BL,MAAMS,OAAO,GAAGA;QAChBT,MAAMQ,GAAG,GAAGA;QACZ,kEAAkE;QAClE,oEAAoE;QACpE,2DAA2D;QAC3D,kEAAkE;QAClE,+BAA+B;QAC/BR,MAAMU,WAAW,GAAG;QACpBC,CAAAA,GAAAA,+BAAAA,6BAA6B,EAC3Bb,aACAE,OACAD,eACAK,WACAC,UACAC,MACAJ;IAEJ,OAAO;QACL,2CAA2C;QAC3CF,MAAMQ,GAAG,GAAGT,cAAcS,GAAG;QAC7B,oEAAoE;QACpE,kEAAkE;QAClE,2BAA2B;QAC3BR,MAAMU,WAAW,GAAGX,cAAcW,WAAW;QAC7CV,MAAMY,cAAc,GAAG,IAAIC,IAAId,cAAca,cAAc;QAC3DZ,MAAMS,OAAO,GAAGV,cAAcU,OAAO;QACrC,4DAA4D;QAC5DK,CAAAA,GAAAA,6BAAAA,2BAA2B,EACzBhB,aACAE,OACAD,eACAE,YACAC;IAEJ;IAEA,OAAO;AACT&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2666</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/refetch-inactive-parallel-segments.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { FlightRouterState } from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type { AppRouterState } from './router-reducer-types'</span><span class="s3">\n</span><span class="s1">import { applyFlightData } from './apply-flight-data'</span><span class="s3">\n</span><span class="s1">import { fetchServerResponse } from './fetch-server-response'</span><span class="s3">\n</span><span class="s1">import { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'</span><span class="s3">\n\n</span><span class="s1">interface RefreshInactiveParallelSegments {</span><span class="s3">\n  </span><span class="s1">navigatedAt: number</span><span class="s3">\n  </span><span class="s1">state: AppRouterState</span><span class="s3">\n  </span><span class="s1">updatedTree: FlightRouterState</span><span class="s3">\n  </span><span class="s1">updatedCache: CacheNode</span><span class="s3">\n  </span><span class="s1">includeNextUrl: boolean</span><span class="s3">\n  </span><span class="s1">canonicalUrl: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Refreshes inactive segments that are still in the current FlightRouterState.</span><span class="s3">\n </span><span class="s1">* A segment is considered </span><span class="s3">\&quot;</span><span class="s1">inactive</span><span class="s3">\&quot; </span><span class="s1">when the server response indicates it didn't match to a page component.</span><span class="s3">\n </span><span class="s1">* This happens during a soft-navigation, where the server will want to patch in the segment</span><span class="s3">\n </span><span class="s1">* with the </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">component, but we explicitly ignore the server in this case</span><span class="s3">\n </span><span class="s1">* and keep the existing state for that segment. New data for inactive segments are inherently</span><span class="s3">\n </span><span class="s1">* not part of the server response when we patch the tree, because they were associated with a response</span><span class="s3">\n </span><span class="s1">* from an earlier navigation/request. For each segment, once it becomes </span><span class="s3">\&quot;</span><span class="s1">active</span><span class="s3">\&quot;</span><span class="s1">, we encode the URL that provided</span><span class="s3">\n </span><span class="s1">* the data for it. This function traverses parallel routes looking for these markers so that it can re-fetch</span><span class="s3">\n </span><span class="s1">* and patch the new data into the tree.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export async function refreshInactiveParallelSegments(</span><span class="s3">\n  </span><span class="s1">options: RefreshInactiveParallelSegments</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const fetchedSegments = new Set&lt;string&gt;()</span><span class="s3">\n  </span><span class="s1">await refreshInactiveParallelSegmentsImpl({</span><span class="s3">\n    </span><span class="s1">...options,</span><span class="s3">\n    </span><span class="s1">rootTree: options.updatedTree,</span><span class="s3">\n    </span><span class="s1">fetchedSegments,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function refreshInactiveParallelSegmentsImpl({</span><span class="s3">\n  </span><span class="s1">navigatedAt,</span><span class="s3">\n  </span><span class="s1">state,</span><span class="s3">\n  </span><span class="s1">updatedTree,</span><span class="s3">\n  </span><span class="s1">updatedCache,</span><span class="s3">\n  </span><span class="s1">includeNextUrl,</span><span class="s3">\n  </span><span class="s1">fetchedSegments,</span><span class="s3">\n  </span><span class="s1">rootTree = updatedTree,</span><span class="s3">\n  </span><span class="s1">canonicalUrl,</span><span class="s3">\n</span><span class="s1">}: RefreshInactiveParallelSegments &amp; {</span><span class="s3">\n  </span><span class="s1">fetchedSegments: Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">rootTree: FlightRouterState</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree</span><span class="s3">\n  </span><span class="s1">const fetchPromises = []</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">refetchPath &amp;&amp;</span><span class="s3">\n    </span><span class="s1">refetchPath !== canonicalUrl &amp;&amp;</span><span class="s3">\n    </span><span class="s1">refetchMarker === 'refresh' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">// it's possible for the tree to contain multiple segments that contain data at the same URL</span><span class="s3">\n    </span><span class="s1">// we keep track of them so we can dedupe the requests</span><span class="s3">\n    </span><span class="s1">!fetchedSegments.has(refetchPath)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">fetchedSegments.add(refetchPath) // Mark this URL as fetched</span><span class="s3">\n\n    </span><span class="s1">// Eagerly kick off the fetch for the refetch path &amp; the parallel routes. This should be fine to do as they each operate</span><span class="s3">\n    </span><span class="s1">// independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.</span><span class="s3">\n    </span><span class="s1">const fetchPromise = fetchServerResponse(</span><span class="s3">\n      </span><span class="s1">new URL(refetchPath, location.origin),</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">// refetch from the root of the updated tree, otherwise it will be scoped to the current segment</span><span class="s3">\n        </span><span class="s1">// and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)</span><span class="s3">\n        </span><span class="s1">flightRouterState: [rootTree[0], rootTree[1], rootTree[2], 'refetch'],</span><span class="s3">\n        </span><span class="s1">nextUrl: includeNextUrl ? state.nextUrl : null,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">).then(({ flightData }) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (typeof flightData !== 'string') {</span><span class="s3">\n        </span><span class="s1">for (const flightDataPath of flightData) {</span><span class="s3">\n          </span><span class="s1">// we only pass the new cache as this function is called after clearing the router cache</span><span class="s3">\n          </span><span class="s1">// and filling in the new page data from the server. Meaning the existing cache is actually the cache that's</span><span class="s3">\n          </span><span class="s1">// just been created &amp; has been written to, but hasn't been </span><span class="s3">\&quot;</span><span class="s1">committed</span><span class="s3">\&quot; </span><span class="s1">yet.</span><span class="s3">\n          </span><span class="s1">applyFlightData(</span><span class="s3">\n            </span><span class="s1">navigatedAt,</span><span class="s3">\n            </span><span class="s1">updatedCache,</span><span class="s3">\n            </span><span class="s1">updatedCache,</span><span class="s3">\n            </span><span class="s1">flightDataPath</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// When flightData is a string, it suggests that the server response should have triggered an MPA navigation</span><span class="s3">\n        </span><span class="s1">// I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect</span><span class="s3">\n        </span><span class="s1">// when refreshing on-screen data, so handling this has been ommitted.</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">fetchPromises.push(fetchPromise)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const key in parallelRoutes) {</span><span class="s3">\n    </span><span class="s1">const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({</span><span class="s3">\n      </span><span class="s1">navigatedAt,</span><span class="s3">\n      </span><span class="s1">state,</span><span class="s3">\n      </span><span class="s1">updatedTree: parallelRoutes[key],</span><span class="s3">\n      </span><span class="s1">updatedCache,</span><span class="s3">\n      </span><span class="s1">includeNextUrl,</span><span class="s3">\n      </span><span class="s1">fetchedSegments,</span><span class="s3">\n      </span><span class="s1">rootTree,</span><span class="s3">\n      </span><span class="s1">canonicalUrl,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">fetchPromises.push(parallelFetchPromise)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">await Promise.all(fetchPromises)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Walks the current parallel segments to determine if they are </span><span class="s3">\&quot;</span><span class="s1">active</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n </span><span class="s1">* An active parallel route will have a `__PAGE__` segment in the FlightRouterState.</span><span class="s3">\n </span><span class="s1">* As opposed to a `__DEFAULT__` segment, which means there was no match for that parallel route.</span><span class="s3">\n </span><span class="s1">* We add a special marker here so that we know how to refresh its data when the router is revalidated.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function addRefreshMarkerToActiveParallelSegments(</span><span class="s3">\n  </span><span class="s1">tree: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">path: string</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const [segment, parallelRoutes, , refetchMarker] = tree</span><span class="s3">\n  </span><span class="s1">// a page segment might also contain concatenated search params, so we do a partial match on the key</span><span class="s3">\n  </span><span class="s1">if (segment.includes(PAGE_SEGMENT_KEY) &amp;&amp; refetchMarker !== 'refresh') {</span><span class="s3">\n    </span><span class="s1">tree[2] = path</span><span class="s3">\n    </span><span class="s1">tree[3] = 'refresh'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const key in parallelRoutes) {</span><span class="s3">\n    </span><span class="s1">addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;addRefreshMarkerToActiveParallelSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;refreshInactiveParallelSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchedSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;refreshInactiveParallelSegmentsImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;rootTree&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedTree&quot;</span><span class="s0">,</span><span class="s1">&quot;navigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedCache&quot;</span><span class="s0">,</span><span class="s1">&quot;includeNextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;refetchPath&quot;</span><span class="s0">,</span><span class="s1">&quot;refetchMarker&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchPromises&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchServerResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;flightDataPath&quot;</span><span class="s0">,</span><span class="s1">&quot;applyFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelFetchPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;all&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;PAGE_SEGMENT_KEY&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;IAyHgBA,wCAAwC,EAAA;eAAxCA;;IA9FMC,+BAA+B,EAAA;eAA/BA;;;iCAxBU;qCACI;yBACH;AAsB1B,eAAeA,gCACpBC,OAAwC;IAExC,MAAMC,kBAAkB,IAAIC;IAC5B,MAAMC,oCAAoC;QACxC,GAAGH,OAAO;QACVI,UAAUJ,QAAQK,WAAW;QAC7BJ;IACF;AACF;AAEA,eAAeE,oCAAoC,KAYlD;IAZkD,IAAA,EACjDG,WAAW,EACXC,KAAK,EACLF,WAAW,EACXG,YAAY,EACZC,cAAc,EACdR,eAAe,EACfG,WAAWC,WAAW,EACtBK,YAAY,EAIb,GAZkD;IAajD,MAAM,GAAGC,gBAAgBC,aAAaC,cAAc,GAAGR;IACvD,MAAMS,gBAAgB,EAAE;IAExB,IACEF,eACAA,gBAAgBF,gBAChBG,kBAAkB,aAClB,4FAA4F;IAC5F,sDAAsD;IACtD,CAACZ,gBAAgBc,GAAG,CAACH,cACrB;QACAX,gBAAgBe,GAAG,CAACJ,aAAa,2BAA2B;;QAE5D,wHAAwH;QACxH,kIAAkI;QAClI,MAAMK,eAAeC,CAAAA,GAAAA,qBAAAA,mBAAmB,EACtC,IAAIC,IAAIP,aAAaQ,SAASC,MAAM,GACpC;YACE,gGAAgG;YAChG,8HAA8H;YAC9HC,mBAAmB;gBAAClB,QAAQ,CAAC,EAAE;gBAAEA,QAAQ,CAAC,EAAE;gBAAEA,QAAQ,CAAC,EAAE;gBAAE;aAAU;YACrEmB,SAASd,iBAAiBF,MAAMgB,OAAO,GAAG;QAC5C,GACAC,IAAI,CAAC,CAAA;gBAAC,EAAEC,UAAU,EAAE,GAAA;YACpB,IAAI,OAAOA,eAAe,UAAU;gBAClC,KAAK,MAAMC,kBAAkBD,WAAY;oBACvC,wFAAwF;oBACxF,4GAA4G;oBAC5G,4EAA4E;oBAC5EE,CAAAA,GAAAA,iBAAAA,eAAe,EACbrB,aACAE,cACAA,cACAkB;gBAEJ;YACF,OAAO;YACL,4GAA4G;YAC5G,+GAA+G;YAC/G,sEAAsE;YACxE;QACF;QAEAZ,cAAcc,IAAI,CAACX;IACrB;IAEA,IAAK,MAAMY,OAAOlB,eAAgB;QAChC,MAAMmB,uBAAuB3B,oCAAoC;YAC/DG;YACAC;YACAF,aAAaM,cAAc,CAACkB,IAAI;YAChCrB;YACAC;YACAR;YACAG;YACAM;QACF;QAEAI,cAAcc,IAAI,CAACE;IACrB;IAEA,MAAMC,QAAQC,GAAG,CAAClB;AACpB;AAQO,SAAShB,yCACdmC,IAAuB,EACvBC,IAAY;IAEZ,MAAM,CAACC,SAASxB,kBAAkBE,cAAc,GAAGoB;IACnD,oGAAoG;IACpG,IAAIE,QAAQC,QAAQ,CAACC,SAAAA,gBAAgB,KAAKxB,kBAAkB,WAAW;QACrEoB,IAAI,CAAC,EAAE,GAAGC;QACVD,IAAI,CAAC,EAAE,GAAG;IACZ;IAEA,IAAK,MAAMJ,OAAOlB,eAAgB;QAChCb,yCAAyCa,cAAc,CAACkB,IAAI,EAAEK;IAChE;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2773</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/apply-router-state-patch-to-tree.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">FlightSegmentPath,</span><span class="s3">\n</span><span class="s1">} from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'</span><span class="s3">\n</span><span class="s1">import { getNextFlightSegmentPath } from '../../flight-data-helpers'</span><span class="s3">\n</span><span class="s1">import { matchSegment } from '../match-segments'</span><span class="s3">\n</span><span class="s1">import { addRefreshMarkerToActiveParallelSegments } from './refetch-inactive-parallel-segments'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function applyPatch(</span><span class="s3">\n  </span><span class="s1">initialTree: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">patchTree: FlightRouterState</span><span class="s3">\n</span><span class="s1">): FlightRouterState {</span><span class="s3">\n  </span><span class="s1">const [initialSegment, initialParallelRoutes] = initialTree</span><span class="s3">\n  </span><span class="s1">const [patchSegment, patchParallelRoutes] = patchTree</span><span class="s3">\n\n  </span><span class="s1">// if the applied patch segment is __DEFAULT__ then it can be ignored in favor of the initial tree</span><span class="s3">\n  </span><span class="s1">// this is because the __DEFAULT__ segment is used as a placeholder on navigation</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">patchSegment === DEFAULT_SEGMENT_KEY &amp;&amp;</span><span class="s3">\n    </span><span class="s1">initialSegment !== DEFAULT_SEGMENT_KEY</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return initialTree</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (matchSegment(initialSegment, patchSegment)) {</span><span class="s3">\n    </span><span class="s1">const newParallelRoutes: FlightRouterState[1] = {}</span><span class="s3">\n    </span><span class="s1">for (const key in initialParallelRoutes) {</span><span class="s3">\n      </span><span class="s1">const isInPatchTreeParallelRoutes =</span><span class="s3">\n        </span><span class="s1">typeof patchParallelRoutes[key] !== 'undefined'</span><span class="s3">\n      </span><span class="s1">if (isInPatchTreeParallelRoutes) {</span><span class="s3">\n        </span><span class="s1">newParallelRoutes[key] = applyPatch(</span><span class="s3">\n          </span><span class="s1">initialParallelRoutes[key],</span><span class="s3">\n          </span><span class="s1">patchParallelRoutes[key]</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">newParallelRoutes[key] = initialParallelRoutes[key]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const key in patchParallelRoutes) {</span><span class="s3">\n      </span><span class="s1">if (newParallelRoutes[key]) {</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">newParallelRoutes[key] = patchParallelRoutes[key]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const tree: FlightRouterState = [initialSegment, newParallelRoutes]</span><span class="s3">\n\n    </span><span class="s1">// Copy over the existing tree</span><span class="s3">\n    </span><span class="s1">if (initialTree[2]) {</span><span class="s3">\n      </span><span class="s1">tree[2] = initialTree[2]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (initialTree[3]) {</span><span class="s3">\n      </span><span class="s1">tree[3] = initialTree[3]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (initialTree[4]) {</span><span class="s3">\n      </span><span class="s1">tree[4] = initialTree[4]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return tree</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return patchTree</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Apply the router state from the Flight response, but skip patching default segments.</span><span class="s3">\n </span><span class="s1">* Useful for patching the router cache when navigating, where we persist the existing default segment if there isn't a new one.</span><span class="s3">\n </span><span class="s1">* Creates a new router state tree.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function applyRouterStatePatchToTree(</span><span class="s3">\n  </span><span class="s1">flightSegmentPath: FlightSegmentPath,</span><span class="s3">\n  </span><span class="s1">flightRouterState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">treePatch: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">path: string</span><span class="s3">\n</span><span class="s1">): FlightRouterState | null {</span><span class="s3">\n  </span><span class="s1">const [segment, parallelRoutes, url, refetch, isRootLayout] =</span><span class="s3">\n    </span><span class="s1">flightRouterState</span><span class="s3">\n\n  </span><span class="s1">// Root refresh</span><span class="s3">\n  </span><span class="s1">if (flightSegmentPath.length === 1) {</span><span class="s3">\n    </span><span class="s1">const tree: FlightRouterState = applyPatch(flightRouterState, treePatch)</span><span class="s3">\n\n    </span><span class="s1">addRefreshMarkerToActiveParallelSegments(tree, path)</span><span class="s3">\n\n    </span><span class="s1">return tree</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const [currentSegment, parallelRouteKey] = flightSegmentPath</span><span class="s3">\n\n  </span><span class="s1">// Tree path returned from the server should always match up with the current tree in the browser</span><span class="s3">\n  </span><span class="s1">if (!matchSegment(currentSegment, segment)) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const lastSegment = flightSegmentPath.length === 2</span><span class="s3">\n\n  </span><span class="s1">let parallelRoutePatch</span><span class="s3">\n  </span><span class="s1">if (lastSegment) {</span><span class="s3">\n    </span><span class="s1">parallelRoutePatch = applyPatch(parallelRoutes[parallelRouteKey], treePatch)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">parallelRoutePatch = applyRouterStatePatchToTree(</span><span class="s3">\n      </span><span class="s1">getNextFlightSegmentPath(flightSegmentPath),</span><span class="s3">\n      </span><span class="s1">parallelRoutes[parallelRouteKey],</span><span class="s3">\n      </span><span class="s1">treePatch,</span><span class="s3">\n      </span><span class="s1">path</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">if (parallelRoutePatch === null) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const tree: FlightRouterState = [</span><span class="s3">\n    </span><span class="s1">flightSegmentPath[0],</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">...parallelRoutes,</span><span class="s3">\n      </span><span class="s1">[parallelRouteKey]: parallelRoutePatch,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">refetch,</span><span class="s3">\n  </span><span class="s1">]</span><span class="s3">\n\n  </span><span class="s1">// Current segment is the root layout</span><span class="s3">\n  </span><span class="s1">if (isRootLayout) {</span><span class="s3">\n    </span><span class="s1">tree[4] = true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">addRefreshMarkerToActiveParallelSegments(tree, path)</span><span class="s3">\n\n  </span><span class="s1">return tree</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;applyRouterStatePatchToTree&quot;</span><span class="s0">,</span><span class="s1">&quot;applyPatch&quot;</span><span class="s0">,</span><span class="s1">&quot;initialTree&quot;</span><span class="s0">,</span><span class="s1">&quot;patchTree&quot;</span><span class="s0">,</span><span class="s1">&quot;initialSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;initialParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;patchSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;patchParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;DEFAULT_SEGMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;matchSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;newParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;isInPatchTreeParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;flightSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;treePatch&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;refetch&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;addRefreshMarkerToActiveParallelSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;currentSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;lastSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutePatch&quot;</span><span class="s0">,</span><span class="s1">&quot;getNextFlightSegmentPath&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BA6EgBA,+BAAAA;;;eAAAA;;;yBAzEoB;mCACK;+BACZ;iDAC4B;AAEzD;;CAEC,GACD,SAASC,WACPC,WAA8B,EAC9BC,SAA4B;IAE5B,MAAM,CAACC,gBAAgBC,sBAAsB,GAAGH;IAChD,MAAM,CAACI,cAAcC,oBAAoB,GAAGJ;IAE5C,kGAAkG;IAClG,iFAAiF;IACjF,IACEG,iBAAiBE,SAAAA,mBAAmB,IACpCJ,mBAAmBI,SAAAA,mBAAmB,EACtC;QACA,OAAON;IACT;IAEA,IAAIO,CAAAA,GAAAA,eAAAA,YAAY,EAACL,gBAAgBE,eAAe;QAC9C,MAAMI,oBAA0C,CAAC;QACjD,IAAK,MAAMC,OAAON,sBAAuB;YACvC,MAAMO,8BACJ,OAAOL,mBAAmB,CAACI,IAAI,KAAK;YACtC,IAAIC,6BAA6B;gBAC/BF,iBAAiB,CAACC,IAAI,GAAGV,WACvBI,qBAAqB,CAACM,IAAI,EAC1BJ,mBAAmB,CAACI,IAAI;YAE5B,OAAO;gBACLD,iBAAiB,CAACC,IAAI,GAAGN,qBAAqB,CAACM,IAAI;YACrD;QACF;QAEA,IAAK,MAAMA,OAAOJ,oBAAqB;YACrC,IAAIG,iBAAiB,CAACC,IAAI,EAAE;gBAC1B;YACF;YAEAD,iBAAiB,CAACC,IAAI,GAAGJ,mBAAmB,CAACI,IAAI;QACnD;QAEA,MAAME,OAA0B;YAACT;YAAgBM;SAAkB;QAEnE,8BAA8B;QAC9B,IAAIR,WAAW,CAAC,EAAE,EAAE;YAClBW,IAAI,CAAC,EAAE,GAAGX,WAAW,CAAC,EAAE;QAC1B;QAEA,IAAIA,WAAW,CAAC,EAAE,EAAE;YAClBW,IAAI,CAAC,EAAE,GAAGX,WAAW,CAAC,EAAE;QAC1B;QAEA,IAAIA,WAAW,CAAC,EAAE,EAAE;YAClBW,IAAI,CAAC,EAAE,GAAGX,WAAW,CAAC,EAAE;QAC1B;QAEA,OAAOW;IACT;IAEA,OAAOV;AACT;AAOO,SAASH,4BACdc,iBAAoC,EACpCC,iBAAoC,EACpCC,SAA4B,EAC5BC,IAAY;IAEZ,MAAM,CAACC,SAASC,gBAAgBC,KAAKC,SAASC,aAAa,GACzDP;IAEF,eAAe;IACf,IAAID,kBAAkBS,MAAM,KAAK,GAAG;QAClC,MAAMV,OAA0BZ,WAAWc,mBAAmBC;QAE9DQ,CAAAA,GAAAA,iCAAAA,wCAAwC,EAACX,MAAMI;QAE/C,OAAOJ;IACT;IAEA,MAAM,CAACY,gBAAgBC,iBAAiB,GAAGZ;IAE3C,iGAAiG;IACjG,IAAI,CAACL,CAAAA,GAAAA,eAAAA,YAAY,EAACgB,gBAAgBP,UAAU;QAC1C,OAAO;IACT;IAEA,MAAMS,cAAcb,kBAAkBS,MAAM,KAAK;IAEjD,IAAIK;IACJ,IAAID,aAAa;QACfC,qBAAqB3B,WAAWkB,cAAc,CAACO,iBAAiB,EAAEV;IACpE,OAAO;QACLY,qBAAqB5B,4BACnB6B,CAAAA,GAAAA,mBAAAA,wBAAwB,EAACf,oBACzBK,cAAc,CAACO,iBAAiB,EAChCV,WACAC;QAGF,IAAIW,uBAAuB,MAAM;YAC/B,OAAO;QACT;IACF;IAEA,MAAMf,OAA0B;QAC9BC,iBAAiB,CAAC,EAAE;QACpB;YACE,GAAGK,cAAc;YACjB,CAACO,iBAAiB,EAAEE;QACtB;QACAR;QACAC;KACD;IAED,qCAAqC;IACrC,IAAIC,cAAc;QAChBT,IAAI,CAAC,EAAE,GAAG;IACZ;IAEAW,CAAAA,GAAAA,iCAAAA,wCAAwC,EAACX,MAAMI;IAE/C,OAAOJ;AACT&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2880</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/should-hard-navigate.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">FlightDataPath,</span><span class="s3">\n  </span><span class="s1">Segment,</span><span class="s3">\n</span><span class="s1">} from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { getNextFlightSegmentPath } from '../../flight-data-helpers'</span><span class="s3">\n</span><span class="s1">import { matchSegment } from '../match-segments'</span><span class="s3">\n\n</span><span class="s1">// TODO-APP: flightSegmentPath will be empty in case of static response, needs to be handled.</span><span class="s3">\n</span><span class="s1">export function shouldHardNavigate(</span><span class="s3">\n  </span><span class="s1">flightSegmentPath: FlightDataPath,</span><span class="s3">\n  </span><span class="s1">flightRouterState: FlightRouterState</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">const [segment, parallelRoutes] = flightRouterState</span><span class="s3">\n  </span><span class="s1">// TODO-APP: Check if `as` can be replaced.</span><span class="s3">\n  </span><span class="s1">const [currentSegment, parallelRouteKey] = flightSegmentPath as [</span><span class="s3">\n    </span><span class="s1">Segment,</span><span class="s3">\n    </span><span class="s1">string,</span><span class="s3">\n  </span><span class="s1">]</span><span class="s3">\n\n  </span><span class="s1">// Check if current segment matches the existing segment.</span><span class="s3">\n  </span><span class="s1">if (!matchSegment(currentSegment, segment)) {</span><span class="s3">\n    </span><span class="s1">// If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(currentSegment)) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If the existing segment did not match soft navigation is triggered.</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const lastSegment = flightSegmentPath.length &lt;= 2</span><span class="s3">\n\n  </span><span class="s1">if (lastSegment) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return shouldHardNavigate(</span><span class="s3">\n    </span><span class="s1">getNextFlightSegmentPath(flightSegmentPath),</span><span class="s3">\n    </span><span class="s1">parallelRoutes[parallelRouteKey]</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;shouldHardNavigate&quot;</span><span class="s0">,</span><span class="s1">&quot;flightSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;currentSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;matchSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;lastSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;getNextFlightSegmentPath&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BASgBA,sBAAAA;;;eAAAA;;;mCAJyB;+BACZ;AAGtB,SAASA,mBACdC,iBAAiC,EACjCC,iBAAoC;IAEpC,MAAM,CAACC,SAASC,eAAe,GAAGF;IAClC,2CAA2C;IAC3C,MAAM,CAACG,gBAAgBC,iBAAiB,GAAGL;IAK3C,yDAAyD;IACzD,IAAI,CAACM,CAAAA,GAAAA,eAAAA,YAAY,EAACF,gBAAgBF,UAAU;QAC1C,kGAAkG;QAClG,IAAIK,MAAMC,OAAO,CAACJ,iBAAiB;YACjC,OAAO;QACT;QAEA,sEAAsE;QACtE,OAAO;IACT;IACA,MAAMK,cAAcT,kBAAkBU,MAAM,IAAI;IAEhD,IAAID,aAAa;QACf,OAAO;IACT;IAEA,OAAOV,mBACLY,CAAAA,GAAAA,mBAAAA,wBAAwB,EAACX,oBACzBG,cAAc,CAACE,iBAAiB;AAEpC&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2921</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/is-navigating-to-new-root-layout.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { FlightRouterState } from '../../../server/app-render/types'</span><span class="s3">\n\n</span><span class="s1">export function isNavigatingToNewRootLayout(</span><span class="s3">\n  </span><span class="s1">currentTree: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">nextTree: FlightRouterState</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">// Compare segments</span><span class="s3">\n  </span><span class="s1">const currentTreeSegment = currentTree[0]</span><span class="s3">\n  </span><span class="s1">const nextTreeSegment = nextTree[0]</span><span class="s3">\n\n  </span><span class="s1">// If any segment is different before we find the root layout, the root layout has changed.</span><span class="s3">\n  </span><span class="s1">// E.g. /same/(group1)/layout.js -&gt; /same/(group2)/layout.js</span><span class="s3">\n  </span><span class="s1">// First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.</span><span class="s3">\n  </span><span class="s1">if (Array.isArray(currentTreeSegment) &amp;&amp; Array.isArray(nextTreeSegment)) {</span><span class="s3">\n    </span><span class="s1">// Compare dynamic param name and type but ignore the value, different values would not affect the current root layout</span><span class="s3">\n    </span><span class="s1">// /[name] - /slug1 and /slug2, both values (slug1 &amp; slug2) still has the same layout /[name]/layout.js</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">currentTreeSegment[0] !== nextTreeSegment[0] ||</span><span class="s3">\n      </span><span class="s1">currentTreeSegment[2] !== nextTreeSegment[2]</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (currentTreeSegment !== nextTreeSegment) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Current tree root layout found</span><span class="s3">\n  </span><span class="s1">if (currentTree[4]) {</span><span class="s3">\n    </span><span class="s1">// If the next tree doesn't have the root layout flag, it must have changed.</span><span class="s3">\n    </span><span class="s1">return !nextTree[4]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Current tree didn't have its root layout here, must have changed.</span><span class="s3">\n  </span><span class="s1">if (nextTree[4]) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`</span><span class="s3">\n  </span><span class="s1">// But it's not possible to be more than one parallelRoutes before the root layout is found</span><span class="s3">\n  </span><span class="s1">// TODO-APP: change to traverse all parallel routes</span><span class="s3">\n  </span><span class="s1">const currentTreeChild = Object.values(currentTree[1])[0]</span><span class="s3">\n  </span><span class="s1">const nextTreeChild = Object.values(nextTree[1])[0]</span><span class="s3">\n  </span><span class="s1">if (!currentTreeChild || !nextTreeChild) return true</span><span class="s3">\n  </span><span class="s1">return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;isNavigatingToNewRootLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;currentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;nextTree&quot;</span><span class="s0">,</span><span class="s1">&quot;currentTreeSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;nextTreeSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;currentTreeChild&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;nextTreeChild&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAEgBA,+BAAAA;;;eAAAA;;;AAAT,SAASA,4BACdC,WAA8B,EAC9BC,QAA2B;IAE3B,mBAAmB;IACnB,MAAMC,qBAAqBF,WAAW,CAAC,EAAE;IACzC,MAAMG,kBAAkBF,QAAQ,CAAC,EAAE;IAEnC,2FAA2F;IAC3F,4DAA4D;IAC5D,uIAAuI;IACvI,IAAIG,MAAMC,OAAO,CAACH,uBAAuBE,MAAMC,OAAO,CAACF,kBAAkB;QACvE,sHAAsH;QACtH,uGAAuG;QACvG,IACED,kBAAkB,CAAC,EAAE,KAAKC,eAAe,CAAC,EAAE,IAC5CD,kBAAkB,CAAC,EAAE,KAAKC,eAAe,CAAC,EAAE,EAC5C;YACA,OAAO;QACT;IACF,OAAO,IAAID,uBAAuBC,iBAAiB;QACjD,OAAO;IACT;IAEA,iCAAiC;IACjC,IAAIH,WAAW,CAAC,EAAE,EAAE;QAClB,4EAA4E;QAC5E,OAAO,CAACC,QAAQ,CAAC,EAAE;IACrB;IACA,oEAAoE;IACpE,IAAIA,QAAQ,CAAC,EAAE,EAAE;QACf,OAAO;IACT;IACA,4GAA4G;IAC5G,2FAA2F;IAC3F,mDAAmD;IACnD,MAAMK,mBAAmBC,OAAOC,MAAM,CAACR,WAAW,CAAC,EAAE,CAAC,CAAC,EAAE;IACzD,MAAMS,gBAAgBF,OAAOC,MAAM,CAACP,QAAQ,CAAC,EAAE,CAAC,CAAC,EAAE;IACnD,IAAI,CAACK,oBAAoB,CAACG,eAAe,OAAO;IAChD,OAAOV,4BAA4BO,kBAAkBG;AACvD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2974</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/compute-changed-path.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">Segment,</span><span class="s3">\n</span><span class="s1">} from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { INTERCEPTION_ROUTE_MARKERS } from '../../../shared/lib/router/utils/interception-routes'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../../../server/request/params'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">isGroupSegment,</span><span class="s3">\n  </span><span class="s1">DEFAULT_SEGMENT_KEY,</span><span class="s3">\n  </span><span class="s1">PAGE_SEGMENT_KEY,</span><span class="s3">\n</span><span class="s1">} from '../../../shared/lib/segment'</span><span class="s3">\n</span><span class="s1">import { matchSegment } from '../match-segments'</span><span class="s3">\n\n</span><span class="s1">const removeLeadingSlash = (segment: string): string =&gt; {</span><span class="s3">\n  </span><span class="s1">return segment[0] === '/' ? segment.slice(1) : segment</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const segmentToPathname = (segment: Segment): string =&gt; {</span><span class="s3">\n  </span><span class="s1">if (typeof segment === 'string') {</span><span class="s3">\n    </span><span class="s1">// 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page</span><span class="s3">\n    </span><span class="s1">// if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.</span><span class="s3">\n    </span><span class="s1">if (segment === 'children') return ''</span><span class="s3">\n\n    </span><span class="s1">return segment</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return segment[1]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function normalizeSegments(segments: string[]): string {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">segments.reduce((acc, segment) =&gt; {</span><span class="s3">\n      </span><span class="s1">segment = removeLeadingSlash(segment)</span><span class="s3">\n      </span><span class="s1">if (segment === '' || isGroupSegment(segment)) {</span><span class="s3">\n        </span><span class="s1">return acc</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return `${acc}/${segment}`</span><span class="s3">\n    </span><span class="s1">}, '') || '/'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function extractPathFromFlightRouterState(</span><span class="s3">\n  </span><span class="s1">flightRouterState: FlightRouterState</span><span class="s3">\n</span><span class="s1">): string | undefined {</span><span class="s3">\n  </span><span class="s1">const segment = Array.isArray(flightRouterState[0])</span><span class="s3">\n    </span><span class="s1">? flightRouterState[0][1]</span><span class="s3">\n    </span><span class="s1">: flightRouterState[0]</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">segment === DEFAULT_SEGMENT_KEY ||</span><span class="s3">\n    </span><span class="s1">INTERCEPTION_ROUTE_MARKERS.some((m) =&gt; segment.startsWith(m))</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n\n  </span><span class="s1">if (segment.startsWith(PAGE_SEGMENT_KEY)) return ''</span><span class="s3">\n\n  </span><span class="s1">const segments = [segmentToPathname(segment)]</span><span class="s3">\n  </span><span class="s1">const parallelRoutes = flightRouterState[1] ?? {}</span><span class="s3">\n\n  </span><span class="s1">const childrenPath = parallelRoutes.children</span><span class="s3">\n    </span><span class="s1">? extractPathFromFlightRouterState(parallelRoutes.children)</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n\n  </span><span class="s1">if (childrenPath !== undefined) {</span><span class="s3">\n    </span><span class="s1">segments.push(childrenPath)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">for (const [key, value] of Object.entries(parallelRoutes)) {</span><span class="s3">\n      </span><span class="s1">if (key === 'children') continue</span><span class="s3">\n\n      </span><span class="s1">const childPath = extractPathFromFlightRouterState(value)</span><span class="s3">\n\n      </span><span class="s1">if (childPath !== undefined) {</span><span class="s3">\n        </span><span class="s1">segments.push(childPath)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return normalizeSegments(segments)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function computeChangedPathImpl(</span><span class="s3">\n  </span><span class="s1">treeA: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">treeB: FlightRouterState</span><span class="s3">\n</span><span class="s1">): string | null {</span><span class="s3">\n  </span><span class="s1">const [segmentA, parallelRoutesA] = treeA</span><span class="s3">\n  </span><span class="s1">const [segmentB, parallelRoutesB] = treeB</span><span class="s3">\n\n  </span><span class="s1">const normalizedSegmentA = segmentToPathname(segmentA)</span><span class="s3">\n  </span><span class="s1">const normalizedSegmentB = segmentToPathname(segmentB)</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">INTERCEPTION_ROUTE_MARKERS.some(</span><span class="s3">\n      </span><span class="s1">(m) =&gt;</span><span class="s3">\n        </span><span class="s1">normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!matchSegment(segmentA, segmentB)) {</span><span class="s3">\n    </span><span class="s1">// once we find where the tree changed, we compute the rest of the path by traversing the tree</span><span class="s3">\n    </span><span class="s1">return extractPathFromFlightRouterState(treeB) ?? ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const parallelRouterKey in parallelRoutesA) {</span><span class="s3">\n    </span><span class="s1">if (parallelRoutesB[parallelRouterKey]) {</span><span class="s3">\n      </span><span class="s1">const changedPath = computeChangedPathImpl(</span><span class="s3">\n        </span><span class="s1">parallelRoutesA[parallelRouterKey],</span><span class="s3">\n        </span><span class="s1">parallelRoutesB[parallelRouterKey]</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">if (changedPath !== null) {</span><span class="s3">\n        </span><span class="s1">return `${segmentToPathname(segmentB)}/${changedPath}`</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function computeChangedPath(</span><span class="s3">\n  </span><span class="s1">treeA: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">treeB: FlightRouterState</span><span class="s3">\n</span><span class="s1">): string | null {</span><span class="s3">\n  </span><span class="s1">const changedPath = computeChangedPathImpl(treeA, treeB)</span><span class="s3">\n\n  </span><span class="s1">if (changedPath == null || changedPath === '/') {</span><span class="s3">\n    </span><span class="s1">return changedPath</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// lightweight normalization to remove route groups</span><span class="s3">\n  </span><span class="s1">return normalizeSegments(changedPath.split('/'))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Recursively extracts dynamic parameters from FlightRouterState.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getSelectedParams(</span><span class="s3">\n  </span><span class="s1">currentTree: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">params: Params = {}</span><span class="s3">\n</span><span class="s1">): Params {</span><span class="s3">\n  </span><span class="s1">const parallelRoutes = currentTree[1]</span><span class="s3">\n\n  </span><span class="s1">for (const parallelRoute of Object.values(parallelRoutes)) {</span><span class="s3">\n    </span><span class="s1">const segment = parallelRoute[0]</span><span class="s3">\n    </span><span class="s1">const isDynamicParameter = Array.isArray(segment)</span><span class="s3">\n    </span><span class="s1">const segmentValue = isDynamicParameter ? segment[1] : segment</span><span class="s3">\n    </span><span class="s1">if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) continue</span><span class="s3">\n\n    </span><span class="s1">// Ensure catchAll and optional catchall are turned into an array</span><span class="s3">\n    </span><span class="s1">const isCatchAll =</span><span class="s3">\n      </span><span class="s1">isDynamicParameter &amp;&amp; (segment[2] === 'c' || segment[2] === 'oc')</span><span class="s3">\n\n    </span><span class="s1">if (isCatchAll) {</span><span class="s3">\n      </span><span class="s1">params[segment[0]] = segment[1].split('/')</span><span class="s3">\n    </span><span class="s1">} else if (isDynamicParameter) {</span><span class="s3">\n      </span><span class="s1">params[segment[0]] = segment[1]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">params = getSelectedParams(parallelRoute, params)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return params</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;computeChangedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;extractPathFromFlightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;getSelectedParams&quot;</span><span class="s0">,</span><span class="s1">&quot;removeLeadingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentToPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;segments&quot;</span><span class="s0">,</span><span class="s1">&quot;reduce&quot;</span><span class="s0">,</span><span class="s1">&quot;acc&quot;</span><span class="s0">,</span><span class="s1">&quot;isGroupSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;DEFAULT_SEGMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;INTERCEPTION_ROUTE_MARKERS&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;m&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;PAGE_SEGMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;childrenPath&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;childPath&quot;</span><span class="s0">,</span><span class="s1">&quot;computeChangedPathImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;treeA&quot;</span><span class="s0">,</span><span class="s1">&quot;treeB&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentA&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutesA&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentB&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutesB&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedSegmentA&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedSegmentB&quot;</span><span class="s0">,</span><span class="s1">&quot;matchSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouterKey&quot;</span><span class="s0">,</span><span class="s1">&quot;changedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;currentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicParameter&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentValue&quot;</span><span class="s0">,</span><span class="s1">&quot;isCatchAll&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3107</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/handle-mutable.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { computeChangedPath } from './compute-changed-path'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">Mutable,</span><span class="s3">\n  </span><span class="s1">ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">ReducerState,</span><span class="s3">\n</span><span class="s1">} from './router-reducer-types'</span><span class="s3">\n\n</span><span class="s1">function isNotUndefined&lt;T&gt;(value: T): value is Exclude&lt;T, undefined&gt; {</span><span class="s3">\n  </span><span class="s1">return typeof value !== 'undefined'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function handleMutable(</span><span class="s3">\n  </span><span class="s1">state: ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">mutable: Mutable</span><span class="s3">\n</span><span class="s1">): ReducerState {</span><span class="s3">\n  </span><span class="s1">// shouldScroll is true by default, can override to false.</span><span class="s3">\n  </span><span class="s1">const shouldScroll = mutable.shouldScroll ?? true</span><span class="s3">\n\n  </span><span class="s1">let nextUrl = state.nextUrl</span><span class="s3">\n\n  </span><span class="s1">if (isNotUndefined(mutable.patchedTree)) {</span><span class="s3">\n    </span><span class="s1">// If we received a patched tree, we need to compute the changed path.</span><span class="s3">\n    </span><span class="s1">const changedPath = computeChangedPath(state.tree, mutable.patchedTree)</span><span class="s3">\n    </span><span class="s1">if (changedPath) {</span><span class="s3">\n      </span><span class="s1">// If the tree changed, we need to update the nextUrl</span><span class="s3">\n      </span><span class="s1">nextUrl = changedPath</span><span class="s3">\n    </span><span class="s1">} else if (!nextUrl) {</span><span class="s3">\n      </span><span class="s1">// if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl</span><span class="s3">\n      </span><span class="s1">nextUrl = state.canonicalUrl</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// otherwise this will be a no-op and continue to use the existing nextUrl</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">// Set href.</span><span class="s3">\n    </span><span class="s1">canonicalUrl: isNotUndefined(mutable.canonicalUrl)</span><span class="s3">\n      </span><span class="s1">? mutable.canonicalUrl === state.canonicalUrl</span><span class="s3">\n        </span><span class="s1">? state.canonicalUrl</span><span class="s3">\n        </span><span class="s1">: mutable.canonicalUrl</span><span class="s3">\n      </span><span class="s1">: state.canonicalUrl,</span><span class="s3">\n    </span><span class="s1">pushRef: {</span><span class="s3">\n      </span><span class="s1">pendingPush: isNotUndefined(mutable.pendingPush)</span><span class="s3">\n        </span><span class="s1">? mutable.pendingPush</span><span class="s3">\n        </span><span class="s1">: state.pushRef.pendingPush,</span><span class="s3">\n      </span><span class="s1">mpaNavigation: isNotUndefined(mutable.mpaNavigation)</span><span class="s3">\n        </span><span class="s1">? mutable.mpaNavigation</span><span class="s3">\n        </span><span class="s1">: state.pushRef.mpaNavigation,</span><span class="s3">\n      </span><span class="s1">preserveCustomHistoryState: isNotUndefined(</span><span class="s3">\n        </span><span class="s1">mutable.preserveCustomHistoryState</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">? mutable.preserveCustomHistoryState</span><span class="s3">\n        </span><span class="s1">: state.pushRef.preserveCustomHistoryState,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">// All navigation requires scroll and focus management to trigger.</span><span class="s3">\n    </span><span class="s1">focusAndScrollRef: {</span><span class="s3">\n      </span><span class="s1">apply: shouldScroll</span><span class="s3">\n        </span><span class="s1">? isNotUndefined(mutable?.scrollableSegments)</span><span class="s3">\n          </span><span class="s1">? true</span><span class="s3">\n          </span><span class="s1">: state.focusAndScrollRef.apply</span><span class="s3">\n        </span><span class="s1">: // If shouldScroll is false then we should not apply scroll and focus management.</span><span class="s3">\n          </span><span class="s1">false,</span><span class="s3">\n      </span><span class="s1">onlyHashChange: mutable.onlyHashChange || false,</span><span class="s3">\n      </span><span class="s1">hashFragment: shouldScroll</span><span class="s3">\n        </span><span class="s1">? // Empty hash should trigger default behavior of scrolling layout into view.</span><span class="s3">\n          </span><span class="s1">// #top is handled in layout-router.</span><span class="s3">\n          </span><span class="s1">mutable.hashFragment &amp;&amp; mutable.hashFragment !== ''</span><span class="s3">\n          </span><span class="s1">? // Remove leading # and decode hash to make non-latin hashes work.</span><span class="s3">\n            </span><span class="s1">decodeURIComponent(mutable.hashFragment.slice(1))</span><span class="s3">\n          </span><span class="s1">: state.focusAndScrollRef.hashFragment</span><span class="s3">\n        </span><span class="s1">: // If shouldScroll is false then we should not apply scroll and focus management.</span><span class="s3">\n          </span><span class="s1">null,</span><span class="s3">\n      </span><span class="s1">segmentPaths: shouldScroll</span><span class="s3">\n        </span><span class="s1">? mutable?.scrollableSegments ?? state.focusAndScrollRef.segmentPaths</span><span class="s3">\n        </span><span class="s1">: // If shouldScroll is false then we should not apply scroll and focus management.</span><span class="s3">\n          </span><span class="s1">[],</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">// Apply cache.</span><span class="s3">\n    </span><span class="s1">cache: mutable.cache ? mutable.cache : state.cache,</span><span class="s3">\n    </span><span class="s1">prefetchCache: mutable.prefetchCache</span><span class="s3">\n      </span><span class="s1">? mutable.prefetchCache</span><span class="s3">\n      </span><span class="s1">: state.prefetchCache,</span><span class="s3">\n    </span><span class="s1">// Apply patched router state.</span><span class="s3">\n    </span><span class="s1">tree: isNotUndefined(mutable.patchedTree)</span><span class="s3">\n      </span><span class="s1">? mutable.patchedTree</span><span class="s3">\n      </span><span class="s1">: state.tree,</span><span class="s3">\n    </span><span class="s1">nextUrl,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;handleMutable&quot;</span><span class="s0">,</span><span class="s1">&quot;isNotUndefined&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;mutable&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldScroll&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;patchedTree&quot;</span><span class="s0">,</span><span class="s1">&quot;changedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;computeChangedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;pushRef&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingPush&quot;</span><span class="s0">,</span><span class="s1">&quot;mpaNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;preserveCustomHistoryState&quot;</span><span class="s0">,</span><span class="s1">&quot;focusAndScrollRef&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;scrollableSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;onlyHashChange&quot;</span><span class="s0">,</span><span class="s1">&quot;hashFragment&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchCache&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAWgBA,iBAAAA;;;eAAAA;;;oCAXmB;AAOnC,SAASC,eAAkBC,KAAQ;IACjC,OAAO,OAAOA,UAAU;AAC1B;AAEO,SAASF,cACdG,KAA2B,EAC3BC,OAAgB;QAGKA;IADrB,0DAA0D;IAC1D,MAAMC,eAAeD,CAAAA,wBAAAA,QAAQC,YAAY,KAAA,OAApBD,wBAAwB;IAE7C,IAAIE,UAAUH,MAAMG,OAAO;IAE3B,IAAIL,eAAeG,QAAQG,WAAW,GAAG;QACvC,sEAAsE;QACtE,MAAMC,cAAcC,CAAAA,GAAAA,oBAAAA,kBAAkB,EAACN,MAAMO,IAAI,EAAEN,QAAQG,WAAW;QACtE,IAAIC,aAAa;YACf,qDAAqD;YACrDF,UAAUE;QACZ,OAAO,IAAI,CAACF,SAAS;YACnB,6HAA6H;YAC7HA,UAAUH,MAAMQ,YAAY;QAC9B;IACA,0EAA0E;IAC5E;QAyCQP;IAvCR,OAAO;QACL,YAAY;QACZO,cAAcV,eAAeG,QAAQO,YAAY,IAC7CP,QAAQO,YAAY,KAAKR,MAAMQ,YAAY,GACzCR,MAAMQ,YAAY,GAClBP,QAAQO,YAAY,GACtBR,MAAMQ,YAAY;QACtBC,SAAS;YACPC,aAAaZ,eAAeG,QAAQS,WAAW,IAC3CT,QAAQS,WAAW,GACnBV,MAAMS,OAAO,CAACC,WAAW;YAC7BC,eAAeb,eAAeG,QAAQU,aAAa,IAC/CV,QAAQU,aAAa,GACrBX,MAAMS,OAAO,CAACE,aAAa;YAC/BC,4BAA4Bd,eAC1BG,QAAQW,0BAA0B,IAEhCX,QAAQW,0BAA0B,GAClCZ,MAAMS,OAAO,CAACG,0BAA0B;QAC9C;QACA,kEAAkE;QAClEC,mBAAmB;YACjBC,OAAOZ,eACHJ,eAAeG,WAAAA,OAAAA,KAAAA,IAAAA,QAASc,kBAAkB,IACxC,OACAf,MAAMa,iBAAiB,CAACC,KAAK,GAE/B;YACJE,gBAAgBf,QAAQe,cAAc,IAAI;YAC1CC,cAAcf,eAGVD,AADA,QACQgB,YAAY,IAAIhB,QAAQgB,IADI,QACQ,KAAK,KAE/CC,mBAAmBjB,QAAQgB,YAAY,CAACE,KAAK,CAAC,MAC9CnB,MAAMa,iBAAiB,CAACI,YAAY,GAEtC;YACJG,cAAclB,eACVD,CAAAA,8BAAAA,WAAAA,OAAAA,KAAAA,IAAAA,QAASc,kBAAkB,KAAA,OAA3Bd,8BAA+BD,MAAMa,iBAAiB,CAACO,YAAY,GAEnE,EAAE;QACR;QACA,eAAe;QACfC,OAAOpB,QAAQoB,KAAK,GAAGpB,QAAQoB,KAAK,GAAGrB,MAAMqB,KAAK;QAClDC,eAAerB,QAAQqB,aAAa,GAChCrB,QAAQqB,aAAa,GACrBtB,MAAMsB,aAAa;QACvB,8BAA8B;QAC9Bf,MAAMT,eAAeG,QAAQG,WAAW,IACpCH,QAAQG,WAAW,GACnBJ,MAAMO,IAAI;QACdJ;IACF;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3172</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/promise-queue.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/*</span><span class="s3">\n    </span><span class="s1">This is a simple promise queue that allows you to limit the number of concurrent promises</span><span class="s3">\n    </span><span class="s1">that are running at any given time. It's used to limit the number of concurrent</span><span class="s3">\n    </span><span class="s1">prefetch requests that are being made to the server but could be used for other</span><span class="s3">\n    </span><span class="s1">things as well.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class PromiseQueue {</span><span class="s3">\n  </span><span class="s1">#maxConcurrency: number</span><span class="s3">\n  </span><span class="s1">#runningCount: number</span><span class="s3">\n  </span><span class="s1">#queue: Array&lt;{</span><span class="s3">\n    </span><span class="s1">promiseFn: Promise&lt;any&gt;</span><span class="s3">\n    </span><span class="s1">task: () =&gt; void</span><span class="s3">\n  </span><span class="s1">}&gt;</span><span class="s3">\n\n  </span><span class="s1">constructor(maxConcurrency = 5) {</span><span class="s3">\n    </span><span class="s1">this.#maxConcurrency = maxConcurrency</span><span class="s3">\n    </span><span class="s1">this.#runningCount = 0</span><span class="s3">\n    </span><span class="s1">this.#queue = []</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">enqueue&lt;T&gt;(promiseFn: () =&gt; Promise&lt;T&gt;): Promise&lt;T&gt; {</span><span class="s3">\n    </span><span class="s1">let taskResolve: (value: T | PromiseLike&lt;T&gt;) =&gt; void</span><span class="s3">\n    </span><span class="s1">let taskReject: (reason?: any) =&gt; void</span><span class="s3">\n\n    </span><span class="s1">const taskPromise = new Promise((resolve, reject) =&gt; {</span><span class="s3">\n      </span><span class="s1">taskResolve = resolve</span><span class="s3">\n      </span><span class="s1">taskReject = reject</span><span class="s3">\n    </span><span class="s1">}) as Promise&lt;T&gt;</span><span class="s3">\n\n    </span><span class="s1">const task = async () =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">this.#runningCount++</span><span class="s3">\n        </span><span class="s1">const result = await promiseFn()</span><span class="s3">\n        </span><span class="s1">taskResolve(result)</span><span class="s3">\n      </span><span class="s1">} catch (error) {</span><span class="s3">\n        </span><span class="s1">taskReject(error)</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">this.#runningCount--</span><span class="s3">\n        </span><span class="s1">this.#processNext()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const enqueueResult = { promiseFn: taskPromise, task }</span><span class="s3">\n    </span><span class="s1">// wonder if we should take a LIFO approach here</span><span class="s3">\n    </span><span class="s1">this.#queue.push(enqueueResult)</span><span class="s3">\n    </span><span class="s1">this.#processNext()</span><span class="s3">\n\n    </span><span class="s1">return taskPromise</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">bump(promiseFn: Promise&lt;any&gt;) {</span><span class="s3">\n    </span><span class="s1">const index = this.#queue.findIndex((item) =&gt; item.promiseFn === promiseFn)</span><span class="s3">\n\n    </span><span class="s1">if (index &gt; -1) {</span><span class="s3">\n      </span><span class="s1">const bumpedItem = this.#queue.splice(index, 1)[0]</span><span class="s3">\n      </span><span class="s1">this.#queue.unshift(bumpedItem)</span><span class="s3">\n      </span><span class="s1">this.#processNext(true)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">#processNext(forced = false) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(this.#runningCount &lt; this.#maxConcurrency || forced) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.#queue.length &gt; 0</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this.#queue.shift()?.task()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;PromiseQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;enqueue&quot;</span><span class="s0">,</span><span class="s1">&quot;promiseFn&quot;</span><span class="s0">,</span><span class="s1">&quot;taskResolve&quot;</span><span class="s0">,</span><span class="s1">&quot;taskReject&quot;</span><span class="s0">,</span><span class="s1">&quot;taskPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;task&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;enqueueResult&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;bump&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;findIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;item&quot;</span><span class="s0">,</span><span class="s1">&quot;bumpedItem&quot;</span><span class="s0">,</span><span class="s1">&quot;splice&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;maxConcurrency&quot;</span><span class="s0">,</span><span class="s1">&quot;forced&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;shift&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;;;;AAKA;;;+BACaA,gBAAAA;;;eAAAA;;;;;IACX,kBAAA,WAAA,GAAA,+BAAA,CAAA,CAAA,oBACA,gBAAA,WAAA,GAAA,+BAAA,CAAA,CAAA,kBACA,SAAA,WAAA,GAAA,+BAAA,CAAA,CAAA,WAmDA,eAAA,WAAA,GAAA,+BAAA,CAAA,CAAA;AAtDK,MAAMA;IAcXC,QAAWC,SAA2B,EAAc;QAClD,IAAIC;QACJ,IAAIC;QAEJ,MAAMC,cAAc,IAAIC,QAAQ,CAACC,SAASC;YACxCL,cAAcI;YACdH,aAAaI;QACf;QAEA,MAAMC,OAAO;YACX,IAAI;gBACF,gCAAA,CAAA,CAAA,IAAI,EAAC,cAAA,CAAA,cAAA;gBACL,MAAMC,SAAS,MAAMR;gBACrBC,YAAYO;YACd,EAAE,OAAOC,OAAO;gBACdP,WAAWO;YACb,SAAU;gBACR,gCAAA,CAAA,CAAA,IAAI,EAAC,cAAA,CAAA,cAAA;gBACL,gCAAA,CAAA,CAAA,IAAI,EAAC,aAAA,CAAA,aAAA;YACP;QACF;QAEA,MAAMC,gBAAgB;YAAEV,WAAWG;YAAaI;QAAK;QACrD,gDAAgD;QAChD,gCAAA,CAAA,CAAA,IAAI,EAAC,OAAA,CAAA,OAAA,CAAOI,IAAI,CAACD;QACjB,gCAAA,CAAA,CAAA,IAAI,EAAC,aAAA,CAAA,aAAA;QAEL,OAAOP;IACT;IAEAS,KAAKZ,SAAuB,EAAE;QAC5B,MAAMa,QAAQ,gCAAA,CAAA,CAAA,IAAI,EAAC,OAAA,CAAA,OAAA,CAAOC,SAAS,CAAC,CAACC,OAASA,KAAKf,SAAS,KAAKA;QAEjE,IAAIa,QAAQ,CAAC,GAAG;YACd,MAAMG,aAAa,gCAAA,CAAA,CAAA,IAAI,EAAC,OAAA,CAAA,OAAA,CAAOC,MAAM,CAACJ,OAAO,EAAE,CAAC,EAAE;YAClD,gCAAA,CAAA,CAAA,IAAI,EAAC,OAAA,CAAA,OAAA,CAAOK,OAAO,CAACF;YACpB,gCAAA,CAAA,CAAA,IAAI,EAAC,aAAA,CAAA,aAAA,CAAa;QACpB;IACF;IA5CAG,YAAYC,iBAAiB,CAAC,CAAE;QA8ChC,OAAA,cAAA,CAAA,IAAA,EAAA,cAAA;mBAAA;;QArDA,OAAA,cAAA,CAAA,IAAA,EAAA,iBAAA;;mBAAA,KAAA;;QACA,OAAA,cAAA,CAAA,IAAA,EAAA,eAAA;;mBAAA,KAAA;;QACA,OAAA,cAAA,CAAA,IAAA,EAAA,QAAA;;mBAAA,KAAA;;QAME,gCAAA,CAAA,CAAA,IAAI,EAAC,gBAAA,CAAA,gBAAA,GAAkBA;QACvB,gCAAA,CAAA,CAAA,IAAI,EAAC,cAAA,CAAA,cAAA,GAAgB;QACrB,gCAAA,CAAA,CAAA,IAAI,EAAC,OAAA,CAAA,OAAA,GAAS,EAAE;IAClB;AAkDF;AARE,SAAA,YAAaC,MAAc;IAAdA,IAAAA,WAAAA,KAAAA,GAAAA,SAAS;IACpB,IACG,CAAA,gCAAA,CAAA,CAAA,IAAI,EAAC,cAAA,CAAA,cAAA,GAAgB,gCAAA,CAAA,CAAA,IAAI,EAAC,gBAAA,CAAA,gBAAA,IAAmBA,MAAK,KACnD,gCAAA,CAAA,CAAA,IAAI,EAAC,OAAA,CAAA,OAAA,CAAOC,MAAM,GAAG,GACrB;YACA;SAAA,+CAAA,gCAAA,CAAA,CAAA,IAAI,EAAC,OAAA,CAAA,OAAA,CAAOC,KAAK,EAAA,KAAA,OAAA,KAAA,IAAjB,6CAAqBhB,IAAI;IAC3B;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3265</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/prefetch-cache-utils.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">fetchServerResponse,</span><span class="s3">\n  </span><span class="s1">type FetchServerResponseResult,</span><span class="s3">\n</span><span class="s1">} from './fetch-server-response'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">PrefetchCacheEntryStatus,</span><span class="s3">\n  </span><span class="s1">type PrefetchCacheEntry,</span><span class="s3">\n  </span><span class="s1">PrefetchKind,</span><span class="s3">\n  </span><span class="s1">type ReadonlyReducerState,</span><span class="s3">\n</span><span class="s1">} from './router-reducer-types'</span><span class="s3">\n</span><span class="s1">import { prefetchQueue } from './reducers/prefetch-reducer'</span><span class="s3">\n\n</span><span class="s1">const INTERCEPTION_CACHE_KEY_MARKER = '%'</span><span class="s3">\n\n</span><span class="s1">export type AliasedPrefetchCacheEntry = PrefetchCacheEntry &amp; {</span><span class="s3">\n  </span><span class="s1">/** This is a special property that indicates a prefetch entry associated with a different URL</span><span class="s3">\n   </span><span class="s1">* was returned rather than the requested URL. This signals to the router that it should only</span><span class="s3">\n   </span><span class="s1">* apply the part that doesn't depend on searchParams (specifically the loading state).</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">aliased?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a cache key for the router prefetch cache</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param url - The URL being navigated to</span><span class="s3">\n </span><span class="s1">* @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.</span><span class="s3">\n </span><span class="s1">* @return The generated prefetch cache key.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createPrefetchCacheKeyImpl(</span><span class="s3">\n  </span><span class="s1">url: URL,</span><span class="s3">\n  </span><span class="s1">includeSearchParams: boolean,</span><span class="s3">\n  </span><span class="s1">prefix?: string | null</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// Initially we only use the pathname as the cache key. We don't want to include</span><span class="s3">\n  </span><span class="s1">// search params so that multiple URLs with the same search parameter can re-use</span><span class="s3">\n  </span><span class="s1">// loading states.</span><span class="s3">\n  </span><span class="s1">let pathnameFromUrl = url.pathname</span><span class="s3">\n\n  </span><span class="s1">// RSC responses can differ based on search params, specifically in the case where we aren't</span><span class="s3">\n  </span><span class="s1">// returning a partial response (ie with `PrefetchKind.AUTO`).</span><span class="s3">\n  </span><span class="s1">// In the auto case, since loading.js &amp; layout.js won't have access to search params,</span><span class="s3">\n  </span><span class="s1">// we can safely re-use that cache entry. But for full prefetches, we should not</span><span class="s3">\n  </span><span class="s1">// re-use the cache entry as the response may differ.</span><span class="s3">\n  </span><span class="s1">if (includeSearchParams) {</span><span class="s3">\n    </span><span class="s1">// if we have a full prefetch, we can include the search param in the key,</span><span class="s3">\n    </span><span class="s1">// as we'll be getting back a full response. The server might have read the search</span><span class="s3">\n    </span><span class="s1">// params when generating the full response.</span><span class="s3">\n    </span><span class="s1">pathnameFromUrl += url.search</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (prefix) {</span><span class="s3">\n    </span><span class="s1">return `${prefix}${INTERCEPTION_CACHE_KEY_MARKER}${pathnameFromUrl}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return pathnameFromUrl</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createPrefetchCacheKey(</span><span class="s3">\n  </span><span class="s1">url: URL,</span><span class="s3">\n  </span><span class="s1">kind: PrefetchKind | undefined,</span><span class="s3">\n  </span><span class="s1">nextUrl?: string | null</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return createPrefetchCacheKeyImpl(url, kind === PrefetchKind.FULL, nextUrl)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getExistingCacheEntry(</span><span class="s3">\n  </span><span class="s1">url: URL,</span><span class="s3">\n  </span><span class="s1">kind: PrefetchKind = PrefetchKind.TEMPORARY,</span><span class="s3">\n  </span><span class="s1">nextUrl: string | null,</span><span class="s3">\n  </span><span class="s1">prefetchCache: Map&lt;string, PrefetchCacheEntry&gt;,</span><span class="s3">\n  </span><span class="s1">allowAliasing: boolean</span><span class="s3">\n</span><span class="s1">): AliasedPrefetchCacheEntry | undefined {</span><span class="s3">\n  </span><span class="s1">// We first check if there's a more specific interception route prefetch entry</span><span class="s3">\n  </span><span class="s1">// This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)</span><span class="s3">\n  </span><span class="s1">// to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.</span><span class="s3">\n  </span><span class="s1">for (const maybeNextUrl of [nextUrl, null]) {</span><span class="s3">\n    </span><span class="s1">const cacheKeyWithParams = createPrefetchCacheKeyImpl(</span><span class="s3">\n      </span><span class="s1">url,</span><span class="s3">\n      </span><span class="s1">true,</span><span class="s3">\n      </span><span class="s1">maybeNextUrl</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">const cacheKeyWithoutParams = createPrefetchCacheKeyImpl(</span><span class="s3">\n      </span><span class="s1">url,</span><span class="s3">\n      </span><span class="s1">false,</span><span class="s3">\n      </span><span class="s1">maybeNextUrl</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">// First, we check if we have a cache entry that exactly matches the URL</span><span class="s3">\n    </span><span class="s1">const cacheKeyToUse = url.search</span><span class="s3">\n      </span><span class="s1">? cacheKeyWithParams</span><span class="s3">\n      </span><span class="s1">: cacheKeyWithoutParams</span><span class="s3">\n\n    </span><span class="s1">const existingEntry = prefetchCache.get(cacheKeyToUse)</span><span class="s3">\n    </span><span class="s1">if (existingEntry &amp;&amp; allowAliasing) {</span><span class="s3">\n      </span><span class="s1">// We know we're returning an aliased entry when the pathname matches but the search params don't,</span><span class="s3">\n      </span><span class="s1">const isAliased =</span><span class="s3">\n        </span><span class="s1">existingEntry.url.pathname === url.pathname &amp;&amp;</span><span class="s3">\n        </span><span class="s1">existingEntry.url.search !== url.search</span><span class="s3">\n\n      </span><span class="s1">if (isAliased) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">...existingEntry,</span><span class="s3">\n          </span><span class="s1">aliased: true,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return existingEntry</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If the request contains search params, and we're not doing a full prefetch, we can return the</span><span class="s3">\n    </span><span class="s1">// param-less entry if it exists.</span><span class="s3">\n    </span><span class="s1">// This is technically covered by the check at the bottom of this function, which iterates over cache entries,</span><span class="s3">\n    </span><span class="s1">// but lets us arrive there quicker in the param-full case.</span><span class="s3">\n    </span><span class="s1">const entryWithoutParams = prefetchCache.get(cacheKeyWithoutParams)</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">process.env.NODE_ENV !== 'development' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">allowAliasing &amp;&amp;</span><span class="s3">\n      </span><span class="s1">url.search &amp;&amp;</span><span class="s3">\n      </span><span class="s1">kind !== PrefetchKind.FULL &amp;&amp;</span><span class="s3">\n      </span><span class="s1">entryWithoutParams &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// We shouldn't return the aliased entry if it was relocated to a new cache key.</span><span class="s3">\n      </span><span class="s1">// Since it's rewritten, it could respond with a completely different loading state.</span><span class="s3">\n      </span><span class="s1">!entryWithoutParams.key.includes(INTERCEPTION_CACHE_KEY_MARKER)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return { ...entryWithoutParams, aliased: true }</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If we've gotten to this point, we didn't find a specific cache entry that matched</span><span class="s3">\n  </span><span class="s1">// the request URL.</span><span class="s3">\n  </span><span class="s1">// We attempt a partial match by checking if there's a cache entry with the same pathname.</span><span class="s3">\n  </span><span class="s1">// Regardless of what we find, since it doesn't correspond with the requested URL, we'll mark it </span><span class="s3">\&quot;</span><span class="s1">aliased</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n  </span><span class="s1">// This will signal to the router that it should only apply the loading state on the prefetched data.</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">process.env.NODE_ENV !== 'development' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">kind !== PrefetchKind.FULL &amp;&amp;</span><span class="s3">\n    </span><span class="s1">allowAliasing</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">for (const cacheEntry of prefetchCache.values()) {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">cacheEntry.url.pathname === url.pathname &amp;&amp;</span><span class="s3">\n        </span><span class="s1">// We shouldn't return the aliased entry if it was relocated to a new cache key.</span><span class="s3">\n        </span><span class="s1">// Since it's rewritten, it could respond with a completely different loading state.</span><span class="s3">\n        </span><span class="s1">!cacheEntry.key.includes(INTERCEPTION_CACHE_KEY_MARKER)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return { ...cacheEntry, aliased: true }</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns a prefetch cache entry if one exists. Otherwise creates a new one and enqueues a fetch request</span><span class="s3">\n </span><span class="s1">* to retrieve the prefetch data from the server.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getOrCreatePrefetchCacheEntry({</span><span class="s3">\n  </span><span class="s1">url,</span><span class="s3">\n  </span><span class="s1">nextUrl,</span><span class="s3">\n  </span><span class="s1">tree,</span><span class="s3">\n  </span><span class="s1">prefetchCache,</span><span class="s3">\n  </span><span class="s1">kind,</span><span class="s3">\n  </span><span class="s1">allowAliasing = true,</span><span class="s3">\n</span><span class="s1">}: Pick&lt;ReadonlyReducerState, 'nextUrl' | 'prefetchCache' | 'tree'&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">url: URL</span><span class="s3">\n  </span><span class="s1">kind?: PrefetchKind</span><span class="s3">\n  </span><span class="s1">allowAliasing: boolean</span><span class="s3">\n</span><span class="s1">}): AliasedPrefetchCacheEntry {</span><span class="s3">\n  </span><span class="s1">const existingCacheEntry = getExistingCacheEntry(</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">kind,</span><span class="s3">\n    </span><span class="s1">nextUrl,</span><span class="s3">\n    </span><span class="s1">prefetchCache,</span><span class="s3">\n    </span><span class="s1">allowAliasing</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (existingCacheEntry) {</span><span class="s3">\n    </span><span class="s1">// Grab the latest status of the cache entry and update it</span><span class="s3">\n    </span><span class="s1">existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry)</span><span class="s3">\n\n    </span><span class="s1">// when `kind` is provided, an explicit prefetch was requested.</span><span class="s3">\n    </span><span class="s1">// if the requested prefetch is </span><span class="s3">\&quot;</span><span class="s1">full</span><span class="s3">\&quot; </span><span class="s1">and the current cache entry wasn't, we want to re-prefetch with the new intent</span><span class="s3">\n    </span><span class="s1">const switchedToFullPrefetch =</span><span class="s3">\n      </span><span class="s1">existingCacheEntry.kind !== PrefetchKind.FULL &amp;&amp;</span><span class="s3">\n      </span><span class="s1">kind === PrefetchKind.FULL</span><span class="s3">\n\n    </span><span class="s1">if (switchedToFullPrefetch) {</span><span class="s3">\n      </span><span class="s1">// If we switched to a full prefetch, validate that the existing cache entry contained partial data.</span><span class="s3">\n      </span><span class="s1">// It's possible that the cache entry was seeded with full data but has a cache type of </span><span class="s3">\&quot;</span><span class="s1">auto</span><span class="s3">\&quot; </span><span class="s1">(ie when cache entries</span><span class="s3">\n      </span><span class="s1">// are seeded but without a prefetch intent)</span><span class="s3">\n      </span><span class="s1">existingCacheEntry.data.then((prefetchResponse) =&gt; {</span><span class="s3">\n        </span><span class="s1">const isFullPrefetch =</span><span class="s3">\n          </span><span class="s1">Array.isArray(prefetchResponse.flightData) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">prefetchResponse.flightData.some((flightData) =&gt; {</span><span class="s3">\n            </span><span class="s1">// If we started rendering from the root and we returned RSC data (seedData), we already had a full prefetch.</span><span class="s3">\n            </span><span class="s1">return flightData.isRootRender &amp;&amp; flightData.seedData !== null</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">if (!isFullPrefetch) {</span><span class="s3">\n          </span><span class="s1">return createLazyPrefetchEntry({</span><span class="s3">\n            </span><span class="s1">tree,</span><span class="s3">\n            </span><span class="s1">url,</span><span class="s3">\n            </span><span class="s1">nextUrl,</span><span class="s3">\n            </span><span class="s1">prefetchCache,</span><span class="s3">\n            </span><span class="s1">// If we didn't get an explicit prefetch kind, we want to set a temporary kind</span><span class="s3">\n            </span><span class="s1">// rather than assuming the same intent as the previous entry, to be consistent with how we</span><span class="s3">\n            </span><span class="s1">// lazily create prefetch entries when intent is left unspecified.</span><span class="s3">\n            </span><span class="s1">kind: kind ?? PrefetchKind.TEMPORARY,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,</span><span class="s3">\n    </span><span class="s1">// where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.</span><span class="s3">\n    </span><span class="s1">if (kind &amp;&amp; existingCacheEntry.kind === PrefetchKind.TEMPORARY) {</span><span class="s3">\n      </span><span class="s1">existingCacheEntry.kind = kind</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// We've determined that the existing entry we found is still valid, so we return it.</span><span class="s3">\n    </span><span class="s1">return existingCacheEntry</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If we didn't return an entry, create a new one.</span><span class="s3">\n  </span><span class="s1">return createLazyPrefetchEntry({</span><span class="s3">\n    </span><span class="s1">tree,</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">nextUrl,</span><span class="s3">\n    </span><span class="s1">prefetchCache,</span><span class="s3">\n    </span><span class="s1">kind: kind || PrefetchKind.TEMPORARY,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Used to take an existing cache entry and prefix it with the nextUrl, if it exists.</span><span class="s3">\n </span><span class="s1">* This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function prefixExistingPrefetchCacheEntry({</span><span class="s3">\n  </span><span class="s1">url,</span><span class="s3">\n  </span><span class="s1">nextUrl,</span><span class="s3">\n  </span><span class="s1">prefetchCache,</span><span class="s3">\n  </span><span class="s1">existingCacheKey,</span><span class="s3">\n</span><span class="s1">}: Pick&lt;ReadonlyReducerState, 'nextUrl' | 'prefetchCache'&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">url: URL</span><span class="s3">\n  </span><span class="s1">existingCacheKey: string</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">const existingCacheEntry = prefetchCache.get(existingCacheKey)</span><span class="s3">\n  </span><span class="s1">if (!existingCacheEntry) {</span><span class="s3">\n    </span><span class="s1">// no-op -- there wasn't an entry to move</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const newCacheKey = createPrefetchCacheKey(</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">existingCacheEntry.kind,</span><span class="s3">\n    </span><span class="s1">nextUrl</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">prefetchCache.set(newCacheKey, { ...existingCacheEntry, key: newCacheKey })</span><span class="s3">\n  </span><span class="s1">prefetchCache.delete(existingCacheKey)</span><span class="s3">\n\n  </span><span class="s1">return newCacheKey</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Use to seed the prefetch cache with data that has already been fetched.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function createSeededPrefetchCacheEntry({</span><span class="s3">\n  </span><span class="s1">nextUrl,</span><span class="s3">\n  </span><span class="s1">tree,</span><span class="s3">\n  </span><span class="s1">prefetchCache,</span><span class="s3">\n  </span><span class="s1">url,</span><span class="s3">\n  </span><span class="s1">data,</span><span class="s3">\n  </span><span class="s1">kind,</span><span class="s3">\n</span><span class="s1">}: Pick&lt;ReadonlyReducerState, 'nextUrl' | 'tree' | 'prefetchCache'&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">url: URL</span><span class="s3">\n  </span><span class="s1">data: FetchServerResponseResult</span><span class="s3">\n  </span><span class="s1">kind: PrefetchKind</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">// The initial cache entry technically includes full data, but it isn't explicitly prefetched -- we just seed the</span><span class="s3">\n  </span><span class="s1">// prefetch cache so that we can skip an extra prefetch request later, since we already have the data.</span><span class="s3">\n  </span><span class="s1">// if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key</span><span class="s3">\n  </span><span class="s1">const prefetchCacheKey = data.couldBeIntercepted</span><span class="s3">\n    </span><span class="s1">? createPrefetchCacheKey(url, kind, nextUrl)</span><span class="s3">\n    </span><span class="s1">: createPrefetchCacheKey(url, kind)</span><span class="s3">\n\n  </span><span class="s1">const prefetchEntry = {</span><span class="s3">\n    </span><span class="s1">treeAtTimeOfPrefetch: tree,</span><span class="s3">\n    </span><span class="s1">data: Promise.resolve(data),</span><span class="s3">\n    </span><span class="s1">kind,</span><span class="s3">\n    </span><span class="s1">prefetchTime: Date.now(),</span><span class="s3">\n    </span><span class="s1">lastUsedTime: Date.now(),</span><span class="s3">\n    </span><span class="s1">staleTime: data.staleTime,</span><span class="s3">\n    </span><span class="s1">key: prefetchCacheKey,</span><span class="s3">\n    </span><span class="s1">status: PrefetchCacheEntryStatus.fresh,</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n  </span><span class="s1">} satisfies PrefetchCacheEntry</span><span class="s3">\n\n  </span><span class="s1">prefetchCache.set(prefetchCacheKey, prefetchEntry)</span><span class="s3">\n\n  </span><span class="s1">return prefetchEntry</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createLazyPrefetchEntry({</span><span class="s3">\n  </span><span class="s1">url,</span><span class="s3">\n  </span><span class="s1">kind,</span><span class="s3">\n  </span><span class="s1">tree,</span><span class="s3">\n  </span><span class="s1">nextUrl,</span><span class="s3">\n  </span><span class="s1">prefetchCache,</span><span class="s3">\n</span><span class="s1">}: Pick&lt;ReadonlyReducerState, 'nextUrl' | 'tree' | 'prefetchCache'&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">url: URL</span><span class="s3">\n  </span><span class="s1">kind: PrefetchKind</span><span class="s3">\n</span><span class="s1">}): PrefetchCacheEntry {</span><span class="s3">\n  </span><span class="s1">const prefetchCacheKey = createPrefetchCacheKey(url, kind)</span><span class="s3">\n\n  </span><span class="s1">// initiates the fetch request for the prefetch and attaches a listener</span><span class="s3">\n  </span><span class="s1">// to the promise to update the prefetch cache entry when the promise resolves (if necessary)</span><span class="s3">\n  </span><span class="s1">const data = prefetchQueue.enqueue(() =&gt;</span><span class="s3">\n    </span><span class="s1">fetchServerResponse(url, {</span><span class="s3">\n      </span><span class="s1">flightRouterState: tree,</span><span class="s3">\n      </span><span class="s1">nextUrl,</span><span class="s3">\n      </span><span class="s1">prefetchKind: kind,</span><span class="s3">\n    </span><span class="s1">}).then((prefetchResponse) =&gt; {</span><span class="s3">\n      </span><span class="s1">// TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations</span><span class="s3">\n      </span><span class="s1">// to avoid drift between this cache key prefixing logic</span><span class="s3">\n      </span><span class="s1">// (which is currently directly influenced by the server response)</span><span class="s3">\n      </span><span class="s1">let newCacheKey</span><span class="s3">\n\n      </span><span class="s1">if (prefetchResponse.couldBeIntercepted) {</span><span class="s3">\n        </span><span class="s1">// Determine if we need to prefix the cache key with the nextUrl</span><span class="s3">\n        </span><span class="s1">newCacheKey = prefixExistingPrefetchCacheEntry({</span><span class="s3">\n          </span><span class="s1">url,</span><span class="s3">\n          </span><span class="s1">existingCacheKey: prefetchCacheKey,</span><span class="s3">\n          </span><span class="s1">nextUrl,</span><span class="s3">\n          </span><span class="s1">prefetchCache,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// If the prefetch was a cache hit, we want to update the existing cache entry to reflect that it was a full prefetch.</span><span class="s3">\n      </span><span class="s1">// This is because we know that a static response will contain the full RSC payload, and can be updated to respect the `static`</span><span class="s3">\n      </span><span class="s1">// staleTime.</span><span class="s3">\n      </span><span class="s1">if (prefetchResponse.prerendered) {</span><span class="s3">\n        </span><span class="s1">const existingCacheEntry = prefetchCache.get(</span><span class="s3">\n          </span><span class="s1">// if we prefixed the cache key due to route interception, we want to use the new key. Otherwise we use the original key</span><span class="s3">\n          </span><span class="s1">newCacheKey ?? prefetchCacheKey</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">if (existingCacheEntry) {</span><span class="s3">\n          </span><span class="s1">existingCacheEntry.kind = PrefetchKind.FULL</span><span class="s3">\n          </span><span class="s1">if (prefetchResponse.staleTime !== -1) {</span><span class="s3">\n            </span><span class="s1">// This is the stale time that was collected by the server during</span><span class="s3">\n            </span><span class="s1">// static generation. Use this in place of the default stale time.</span><span class="s3">\n            </span><span class="s1">existingCacheEntry.staleTime = prefetchResponse.staleTime</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return prefetchResponse</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const prefetchEntry = {</span><span class="s3">\n    </span><span class="s1">treeAtTimeOfPrefetch: tree,</span><span class="s3">\n    </span><span class="s1">data,</span><span class="s3">\n    </span><span class="s1">kind,</span><span class="s3">\n    </span><span class="s1">prefetchTime: Date.now(),</span><span class="s3">\n    </span><span class="s1">lastUsedTime: null,</span><span class="s3">\n    </span><span class="s1">staleTime: -1,</span><span class="s3">\n    </span><span class="s1">key: prefetchCacheKey,</span><span class="s3">\n    </span><span class="s1">status: PrefetchCacheEntryStatus.fresh,</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">prefetchCache.set(prefetchCacheKey, prefetchEntry)</span><span class="s3">\n\n  </span><span class="s1">return prefetchEntry</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function prunePrefetchCache(</span><span class="s3">\n  </span><span class="s1">prefetchCache: ReadonlyReducerState['prefetchCache']</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">for (const [href, prefetchCacheEntry] of prefetchCache) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">getPrefetchEntryCacheStatus(prefetchCacheEntry) ===</span><span class="s3">\n      </span><span class="s1">PrefetchCacheEntryStatus.expired</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">prefetchCache.delete(href)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)</span><span class="s3">\n</span><span class="s1">// and default to 5 minutes (static) / 0 seconds (dynamic)</span><span class="s3">\n</span><span class="s1">export const DYNAMIC_STALETIME_MS =</span><span class="s3">\n  </span><span class="s1">Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000</span><span class="s3">\n\n</span><span class="s1">export const STATIC_STALETIME_MS =</span><span class="s3">\n  </span><span class="s1">Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME) * 1000</span><span class="s3">\n\n</span><span class="s1">function getPrefetchEntryCacheStatus({</span><span class="s3">\n  </span><span class="s1">kind,</span><span class="s3">\n  </span><span class="s1">prefetchTime,</span><span class="s3">\n  </span><span class="s1">lastUsedTime,</span><span class="s3">\n</span><span class="s1">}: PrefetchCacheEntry): PrefetchCacheEntryStatus {</span><span class="s3">\n  </span><span class="s1">// We will re-use the cache entry data for up to the `dynamic` staletime window.</span><span class="s3">\n  </span><span class="s1">if (Date.now() &lt; (lastUsedTime ?? prefetchTime) + DYNAMIC_STALETIME_MS) {</span><span class="s3">\n    </span><span class="s1">return lastUsedTime</span><span class="s3">\n      </span><span class="s1">? PrefetchCacheEntryStatus.reusable</span><span class="s3">\n      </span><span class="s1">: PrefetchCacheEntryStatus.fresh</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// For </span><span class="s3">\&quot;</span><span class="s1">auto</span><span class="s3">\&quot; </span><span class="s1">prefetching, we'll re-use only the loading boundary for up to `static` staletime window.</span><span class="s3">\n  </span><span class="s1">// A stale entry will only re-use the `loading` boundary, not the full data.</span><span class="s3">\n  </span><span class="s1">// This will trigger a </span><span class="s3">\&quot;</span><span class="s1">lazy fetch</span><span class="s3">\&quot; </span><span class="s1">for the full data.</span><span class="s3">\n  </span><span class="s1">if (kind === PrefetchKind.AUTO) {</span><span class="s3">\n    </span><span class="s1">if (Date.now() &lt; prefetchTime + STATIC_STALETIME_MS) {</span><span class="s3">\n      </span><span class="s1">return PrefetchCacheEntryStatus.stale</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// for </span><span class="s3">\&quot;</span><span class="s1">full</span><span class="s3">\&quot; </span><span class="s1">prefetching, we'll re-use the cache entry data for up to `static` staletime window.</span><span class="s3">\n  </span><span class="s1">if (kind === PrefetchKind.FULL) {</span><span class="s3">\n    </span><span class="s1">if (Date.now() &lt; prefetchTime + STATIC_STALETIME_MS) {</span><span class="s3">\n      </span><span class="s1">return PrefetchCacheEntryStatus.reusable</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return PrefetchCacheEntryStatus.expired</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;DYNAMIC_STALETIME_MS&quot;</span><span class="s0">,</span><span class="s1">&quot;STATIC_STALETIME_MS&quot;</span><span class="s0">,</span><span class="s1">&quot;createSeededPrefetchCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;getOrCreatePrefetchCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;prunePrefetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;INTERCEPTION_CACHE_KEY_MARKER&quot;</span><span class="s0">,</span><span class="s1">&quot;createPrefetchCacheKeyImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;includeSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">,</span><span class="s1">&quot;pathnameFromUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;createPrefetchCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchKind&quot;</span><span class="s0">,</span><span class="s1">&quot;FULL&quot;</span><span class="s0">,</span><span class="s1">&quot;getExistingCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;allowAliasing&quot;</span><span class="s0">,</span><span class="s1">&quot;TEMPORARY&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeNextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKeyWithParams&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKeyWithoutParams&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKeyToUse&quot;</span><span class="s0">,</span><span class="s1">&quot;existingEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;isAliased&quot;</span><span class="s0">,</span><span class="s1">&quot;aliased&quot;</span><span class="s0">,</span><span class="s1">&quot;entryWithoutParams&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;getPrefetchEntryCacheStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;switchedToFullPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;isFullPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootRender&quot;</span><span class="s0">,</span><span class="s1">&quot;seedData&quot;</span><span class="s0">,</span><span class="s1">&quot;createLazyPrefetchEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;prefixExistingPrefetchCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;newCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;couldBeIntercepted&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;treeAtTimeOfPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchTime&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;lastUsedTime&quot;</span><span class="s0">,</span><span class="s1">&quot;staleTime&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchCacheEntryStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;fresh&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;enqueue&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchServerResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchKind&quot;</span><span class="s0">,</span><span class="s1">&quot;prerendered&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;expired&quot;</span><span class="s0">,</span><span class="s1">&quot;Number&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CLIENT_ROUTER_STATIC_STALETIME&quot;</span><span class="s0">,</span><span class="s1">&quot;reusable&quot;</span><span class="s0">,</span><span class="s1">&quot;AUTO&quot;</span><span class="s0">,</span><span class="s1">&quot;stale&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3562</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/reducers/prefetch-reducer.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">PrefetchAction,</span><span class="s3">\n  </span><span class="s1">ReducerState,</span><span class="s3">\n  </span><span class="s1">ReadonlyReducerState,</span><span class="s3">\n</span><span class="s1">} from '../router-reducer-types'</span><span class="s3">\n</span><span class="s1">import { PromiseQueue } from '../../promise-queue'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getOrCreatePrefetchCacheEntry,</span><span class="s3">\n  </span><span class="s1">prunePrefetchCache,</span><span class="s3">\n</span><span class="s1">} from '../prefetch-cache-utils'</span><span class="s3">\n</span><span class="s1">export const prefetchQueue = new PromiseQueue(5)</span><span class="s3">\n\n</span><span class="s1">export const prefetchReducer = process.env.__NEXT_CLIENT_SEGMENT_CACHE</span><span class="s3">\n  </span><span class="s1">? identityReducerWhenSegmentCacheIsEnabled</span><span class="s3">\n  </span><span class="s1">: prefetchReducerImpl</span><span class="s3">\n\n</span><span class="s1">function identityReducerWhenSegmentCacheIsEnabled&lt;T&gt;(state: T): T {</span><span class="s3">\n  </span><span class="s1">// Unlike the old implementation, the Segment Cache doesn't store its data in</span><span class="s3">\n  </span><span class="s1">// the router reducer state.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// This shouldn't be reachable because we wrap the prefetch API in a check,</span><span class="s3">\n  </span><span class="s1">// too, which prevents the action from being dispatched. But it's here for</span><span class="s3">\n  </span><span class="s1">// clarity + code elimination.</span><span class="s3">\n  </span><span class="s1">return state</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function prefetchReducerImpl(</span><span class="s3">\n  </span><span class="s1">state: ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">action: PrefetchAction</span><span class="s3">\n</span><span class="s1">): ReducerState {</span><span class="s3">\n  </span><span class="s1">// let's prune the prefetch cache before we do anything else</span><span class="s3">\n  </span><span class="s1">prunePrefetchCache(state.prefetchCache)</span><span class="s3">\n\n  </span><span class="s1">const { url } = action</span><span class="s3">\n\n  </span><span class="s1">getOrCreatePrefetchCacheEntry({</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">nextUrl: state.nextUrl,</span><span class="s3">\n    </span><span class="s1">prefetchCache: state.prefetchCache,</span><span class="s3">\n    </span><span class="s1">kind: action.kind,</span><span class="s3">\n    </span><span class="s1">tree: state.tree,</span><span class="s3">\n    </span><span class="s1">allowAliasing: true,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">return state</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;prefetchQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchReducer&quot;</span><span class="s0">,</span><span class="s1">&quot;PromiseQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CLIENT_SEGMENT_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;identityReducerWhenSegmentCacheIsEnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchReducerImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;action&quot;</span><span class="s0">,</span><span class="s1">&quot;prunePrefetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;getOrCreatePrefetchCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;allowAliasing&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAY+BG,QAAQC,GAAG,CAACC,2BAA2B;;;;;;;;;;;;;;;;IAFzDL,aAAa,EAAA;eAAbA;;IAEAC,eAAe,EAAA;eAAfA;;;8BAPgB;oCAItB;AACA,MAAMD,gBAAgB,IAAIE,cAAAA,YAAY,CAAC;AAEvC,MAAMD,wDACTK,0BACAC;AAEJ,SAASD,yCAA4CE,KAAQ;IAC3D,6EAA6E;IAC7E,4BAA4B;IAC5B,EAAE;IACF,2EAA2E;IAC3E,0EAA0E;IAC1E,8BAA8B;IAC9B,OAAOA;AACT;AAEA,SAASD,oBACPC,KAA2B,EAC3BC,MAAsB;IAEtB,4DAA4D;IAC5DC,CAAAA,GAAAA,oBAAAA,kBAAkB,EAACF,MAAMG,aAAa;IAEtC,MAAM,EAAEC,GAAG,EAAE,GAAGH;IAEhBI,CAAAA,GAAAA,oBAAAA,6BAA6B,EAAC;QAC5BD;QACAE,SAASN,MAAMM,OAAO;QACtBH,eAAeH,MAAMG,aAAa;QAClCI,MAAMN,OAAOM,IAAI;QACjBC,MAAMR,MAAMQ,IAAI;QAChBC,eAAe;IACjB;IAEA,OAAOT;AACT&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3623</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/normalize-trailing-slash.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'</span><span class="s3">\n</span><span class="s1">import { parsePath } from '../shared/lib/router/utils/parse-path'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Normalizes the trailing slash of a path according to the `trailingSlash` option</span><span class="s3">\n </span><span class="s1">* in `next.config.js`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const normalizePathTrailingSlash = (path: string) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (!path.startsWith('/') || process.env.__NEXT_MANUAL_TRAILING_SLASH) {</span><span class="s3">\n    </span><span class="s1">return path</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { pathname, query, hash } = parsePath(path)</span><span class="s3">\n  </span><span class="s1">if (process.env.__NEXT_TRAILING_SLASH) {</span><span class="s3">\n    </span><span class="s1">if (/</span><span class="s3">\\</span><span class="s1">.[^/]+</span><span class="s3">\\</span><span class="s1">/?$/.test(pathname)) {</span><span class="s3">\n      </span><span class="s1">return `${removeTrailingSlash(pathname)}${query}${hash}`</span><span class="s3">\n    </span><span class="s1">} else if (pathname.endsWith('/')) {</span><span class="s3">\n      </span><span class="s1">return `${pathname}${query}${hash}`</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return `${pathname}/${query}${hash}`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return `${removeTrailingSlash(pathname)}${query}${hash}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;normalizePathTrailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_MANUAL_TRAILING_SLASH&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;query&quot;</span><span class="s0">,</span><span class="s1">&quot;hash&quot;</span><span class="s0">,</span><span class="s1">&quot;parsePath&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_TRAILING_SLASH&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;removeTrailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAQ+BG,QAAQC,GAAG,CAACC,4BAA4B;;;;;+BAD1DL,8BAAAA;;;eAAAA;;;qCAPuB;2BACV;AAMnB,MAAMA,6BAA6B,CAACC;IACzC,IAAI,CAACA,KAAKC,UAAU,CAAC,kDAAkD;QACrE,OAAOD;IACT;IAEA,MAAM,EAAEK,QAAQ,EAAEC,KAAK,EAAEC,IAAI,EAAE,GAAGC,CAAAA,GAAAA,WAAAA,SAAS,EAACR;IAC5C,IAAIE,QAAQC,GAAG,CAACM,qBAAqB,EAAE;;IAUvC,OAAQ,KAAEE,CAAAA,GAAAA,qBAAAA,mBAAmB,EAACN,YAAYC,QAAQC;AACpD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3656</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/add-base-path.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { addPathPrefix } from '../shared/lib/router/utils/add-path-prefix'</span><span class="s3">\n</span><span class="s1">import { normalizePathTrailingSlash } from './normalize-trailing-slash'</span><span class="s3">\n\n</span><span class="s1">const basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''</span><span class="s3">\n\n</span><span class="s1">export function addBasePath(path: string, required?: boolean): string {</span><span class="s3">\n  </span><span class="s1">return normalizePathTrailingSlash(</span><span class="s3">\n    </span><span class="s1">process.env.__NEXT_MANUAL_CLIENT_BASE_PATH &amp;&amp; !required</span><span class="s3">\n      </span><span class="s1">? path</span><span class="s3">\n      </span><span class="s1">: addPathPrefix(path, basePath)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;addBasePath&quot;</span><span class="s0">,</span><span class="s1">&quot;basePath&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_ROUTER_BASEPATH&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;required&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizePathTrailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_MANUAL_CLIENT_BASE_PATH&quot;</span><span class="s0">,</span><span class="s1">&quot;addPathPrefix&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAGkBE,QAAQC,GAAG,CAACC,sBAAsB;;;;;+BAEpCJ,eAAAA;;;eAAAA;;;+BALc;wCACa;AAE3C,MAAMC,mDAA6D;AAE5D,SAASD,YAAYK,IAAY,EAAEC,QAAkB;IAC1D,OAAOC,CAAAA,GAAAA,wBAAAA,0BAA0B,EAC/BL,QAAQC,GAAG,CAACK,0BACRH,IADsC,IAAI,CAACC,iBAE3CG,CAAAA,GAAAA,eAAAA,aAAa,EAACJ,MAAMJ;AAE5B&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3684</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/app-router-announcer.tsx&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { useEffect, useRef, useState } from 'react'</span><span class="s3">\n</span><span class="s1">import { createPortal } from 'react-dom'</span><span class="s3">\n</span><span class="s1">import type { FlightRouterState } from '../../server/app-render/types'</span><span class="s3">\n\n</span><span class="s1">const ANNOUNCER_TYPE = 'next-route-announcer'</span><span class="s3">\n</span><span class="s1">const ANNOUNCER_ID = '__next-route-announcer__'</span><span class="s3">\n\n</span><span class="s1">function getAnnouncerNode() {</span><span class="s3">\n  </span><span class="s1">const existingAnnouncer = document.getElementsByName(ANNOUNCER_TYPE)[0]</span><span class="s3">\n  </span><span class="s1">if (existingAnnouncer?.shadowRoot?.childNodes[0]) {</span><span class="s3">\n    </span><span class="s1">return existingAnnouncer.shadowRoot.childNodes[0] as HTMLElement</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">const container = document.createElement(ANNOUNCER_TYPE)</span><span class="s3">\n    </span><span class="s1">container.style.cssText = 'position:absolute'</span><span class="s3">\n    </span><span class="s1">const announcer = document.createElement('div')</span><span class="s3">\n    </span><span class="s1">announcer.ariaLive = 'assertive'</span><span class="s3">\n    </span><span class="s1">announcer.id = ANNOUNCER_ID</span><span class="s3">\n    </span><span class="s1">announcer.role = 'alert'</span><span class="s3">\n    </span><span class="s1">announcer.style.cssText =</span><span class="s3">\n      </span><span class="s1">'position:absolute;border:0;height:1px;margin:-1px;padding:0;width:1px;clip:rect(0 0 0 0);overflow:hidden;white-space:nowrap;word-wrap:normal'</span><span class="s3">\n\n    </span><span class="s1">// Use shadow DOM here to avoid any potential CSS bleed</span><span class="s3">\n    </span><span class="s1">const shadow = container.attachShadow({ mode: 'open' })</span><span class="s3">\n    </span><span class="s1">shadow.appendChild(announcer)</span><span class="s3">\n    </span><span class="s1">document.body.appendChild(container)</span><span class="s3">\n    </span><span class="s1">return announcer</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function AppRouterAnnouncer({ tree }: { tree: FlightRouterState }) {</span><span class="s3">\n  </span><span class="s1">const [portalNode, setPortalNode] = useState&lt;HTMLElement | null&gt;(null)</span><span class="s3">\n\n  </span><span class="s1">useEffect(() =&gt; {</span><span class="s3">\n    </span><span class="s1">const announcer = getAnnouncerNode()</span><span class="s3">\n    </span><span class="s1">setPortalNode(announcer)</span><span class="s3">\n    </span><span class="s1">return () =&gt; {</span><span class="s3">\n      </span><span class="s1">const container = document.getElementsByTagName(ANNOUNCER_TYPE)[0]</span><span class="s3">\n      </span><span class="s1">if (container?.isConnected) {</span><span class="s3">\n        </span><span class="s1">document.body.removeChild(container)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, [])</span><span class="s3">\n\n  </span><span class="s1">const [routeAnnouncement, setRouteAnnouncement] = useState('')</span><span class="s3">\n  </span><span class="s1">const previousTitle = useRef&lt;string | undefined&gt;(undefined)</span><span class="s3">\n\n  </span><span class="s1">useEffect(() =&gt; {</span><span class="s3">\n    </span><span class="s1">let currentTitle = ''</span><span class="s3">\n    </span><span class="s1">if (document.title) {</span><span class="s3">\n      </span><span class="s1">currentTitle = document.title</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const pageHeader = document.querySelector('h1')</span><span class="s3">\n      </span><span class="s1">if (pageHeader) {</span><span class="s3">\n        </span><span class="s1">currentTitle = pageHeader.innerText || pageHeader.textContent || ''</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Only announce the title change, but not for the first load because screen</span><span class="s3">\n    </span><span class="s1">// readers do that automatically.</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">previousTitle.current !== undefined &amp;&amp;</span><span class="s3">\n      </span><span class="s1">previousTitle.current !== currentTitle</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">setRouteAnnouncement(currentTitle)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">previousTitle.current = currentTitle</span><span class="s3">\n  </span><span class="s1">}, [tree])</span><span class="s3">\n\n  </span><span class="s1">return portalNode ? createPortal(routeAnnouncement, portalNode) : null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;AppRouterAnnouncer&quot;</span><span class="s0">,</span><span class="s1">&quot;ANNOUNCER_TYPE&quot;</span><span class="s0">,</span><span class="s1">&quot;ANNOUNCER_ID&quot;</span><span class="s0">,</span><span class="s1">&quot;getAnnouncerNode&quot;</span><span class="s0">,</span><span class="s1">&quot;existingAnnouncer&quot;</span><span class="s0">,</span><span class="s1">&quot;document&quot;</span><span class="s0">,</span><span class="s1">&quot;getElementsByName&quot;</span><span class="s0">,</span><span class="s1">&quot;shadowRoot&quot;</span><span class="s0">,</span><span class="s1">&quot;childNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;container&quot;</span><span class="s0">,</span><span class="s1">&quot;createElement&quot;</span><span class="s0">,</span><span class="s1">&quot;style&quot;</span><span class="s0">,</span><span class="s1">&quot;cssText&quot;</span><span class="s0">,</span><span class="s1">&quot;announcer&quot;</span><span class="s0">,</span><span class="s1">&quot;ariaLive&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;role&quot;</span><span class="s0">,</span><span class="s1">&quot;shadow&quot;</span><span class="s0">,</span><span class="s1">&quot;attachShadow&quot;</span><span class="s0">,</span><span class="s1">&quot;mode&quot;</span><span class="s0">,</span><span class="s1">&quot;appendChild&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;portalNode&quot;</span><span class="s0">,</span><span class="s1">&quot;setPortalNode&quot;</span><span class="s0">,</span><span class="s1">&quot;useState&quot;</span><span class="s0">,</span><span class="s1">&quot;useEffect&quot;</span><span class="s0">,</span><span class="s1">&quot;getElementsByTagName&quot;</span><span class="s0">,</span><span class="s1">&quot;isConnected&quot;</span><span class="s0">,</span><span class="s1">&quot;removeChild&quot;</span><span class="s0">,</span><span class="s1">&quot;routeAnnouncement&quot;</span><span class="s0">,</span><span class="s1">&quot;setRouteAnnouncement&quot;</span><span class="s0">,</span><span class="s1">&quot;previousTitle&quot;</span><span class="s0">,</span><span class="s1">&quot;useRef&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;currentTitle&quot;</span><span class="s0">,</span><span class="s1">&quot;title&quot;</span><span class="s0">,</span><span class="s1">&quot;pageHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;querySelector&quot;</span><span class="s0">,</span><span class="s1">&quot;innerText&quot;</span><span class="s0">,</span><span class="s1">&quot;textContent&quot;</span><span class="s0">,</span><span class="s1">&quot;current&quot;</span><span class="s0">,</span><span class="s1">&quot;createPortal&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BA6BgBA,sBAAAA;;;eAAAA;;;uBA7B4B;0BACf;AAG7B,MAAMC,iBAAiB;AACvB,MAAMC,eAAe;AAErB,SAASC;QAEHC;IADJ,MAAMA,oBAAoBC,SAASC,iBAAiB,CAACL,eAAe,CAAC,EAAE;IACvE,IAAIG,qBAAAA,OAAAA,KAAAA,IAAAA,CAAAA,gCAAAA,kBAAmBG,UAAU,KAAA,OAAA,KAAA,IAA7BH,8BAA+BI,UAAU,CAAC,EAAE,EAAE;QAChD,OAAOJ,kBAAkBG,UAAU,CAACC,UAAU,CAAC,EAAE;IACnD,OAAO;QACL,MAAMC,YAAYJ,SAASK,aAAa,CAACT;QACzCQ,UAAUE,KAAK,CAACC,OAAO,GAAG;QAC1B,MAAMC,YAAYR,SAASK,aAAa,CAAC;QACzCG,UAAUC,QAAQ,GAAG;QACrBD,UAAUE,EAAE,GAAGb;QACfW,UAAUG,IAAI,GAAG;QACjBH,UAAUF,KAAK,CAACC,OAAO,GACrB;QAEF,uDAAuD;QACvD,MAAMK,SAASR,UAAUS,YAAY,CAAC;YAAEC,MAAM;QAAO;QACrDF,OAAOG,WAAW,CAACP;QACnBR,SAASgB,IAAI,CAACD,WAAW,CAACX;QAC1B,OAAOI;IACT;AACF;AAEO,SAASb,mBAAmB,KAAqC;IAArC,IAAA,EAAEsB,IAAI,EAA+B,GAArC;IACjC,MAAM,CAACC,YAAYC,cAAc,GAAGC,CAAAA,GAAAA,OAAAA,QAAQ,EAAqB;IAEjEC,CAAAA,GAAAA,OAAAA,SAAS,EAAC;QACR,MAAMb,YAAYV;QAClBqB,cAAcX;QACd,OAAO;YACL,MAAMJ,YAAYJ,SAASsB,oBAAoB,CAAC1B,eAAe,CAAC,EAAE;YAClE,IAAIQ,aAAAA,OAAAA,KAAAA,IAAAA,UAAWmB,WAAW,EAAE;gBAC1BvB,SAASgB,IAAI,CAACQ,WAAW,CAACpB;YAC5B;QACF;IACF,GAAG,EAAE;IAEL,MAAM,CAACqB,mBAAmBC,qBAAqB,GAAGN,CAAAA,GAAAA,OAAAA,QAAQ,EAAC;IAC3D,MAAMO,gBAAgBC,CAAAA,GAAAA,OAAAA,MAAM,EAAqBC;IAEjDR,CAAAA,GAAAA,OAAAA,SAAS,EAAC;QACR,IAAIS,eAAe;QACnB,IAAI9B,SAAS+B,KAAK,EAAE;YAClBD,eAAe9B,SAAS+B,KAAK;QAC/B,OAAO;YACL,MAAMC,aAAahC,SAASiC,aAAa,CAAC;YAC1C,IAAID,YAAY;gBACdF,eAAeE,WAAWE,SAAS,IAAIF,WAAWG,WAAW,IAAI;YACnE;QACF;QAEA,4EAA4E;QAC5E,iCAAiC;QACjC,IACER,cAAcS,OAAO,KAAKP,aAC1BF,cAAcS,OAAO,KAAKN,cAC1B;YACAJ,qBAAqBI;QACvB;QACAH,cAAcS,OAAO,GAAGN;IAC1B,GAAG;QAACb;KAAK;IAET,OAAOC,aAAAA,WAAAA,GAAamB,CAAAA,GAAAA,UAAAA,YAAY,EAACZ,mBAAmBP,cAAc;AACpE&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3766</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/reducers/get-segment-value.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { Segment } from '../../../../server/app-render/types'</span><span class="s3">\n\n</span><span class="s1">export function getSegmentValue(segment: Segment) {</span><span class="s3">\n  </span><span class="s1">return Array.isArray(segment) ? segment[1] : segment</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;getSegmentValue&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAEgBA,mBAAAA;;;eAAAA;;;AAAT,SAASA,gBAAgBC,OAAgB;IAC9C,OAAOC,MAAMC,OAAO,CAACF,WAAWA,OAAO,CAAC,EAAE,GAAGA;AAC/C&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3789</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/redirect.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { RedirectStatusCode } from './redirect-status-code'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">RedirectType,</span><span class="s3">\n  </span><span class="s1">type RedirectError,</span><span class="s3">\n  </span><span class="s1">isRedirectError,</span><span class="s3">\n  </span><span class="s1">REDIRECT_ERROR_CODE,</span><span class="s3">\n</span><span class="s1">} from './redirect-error'</span><span class="s3">\n\n</span><span class="s1">const actionAsyncStorage =</span><span class="s3">\n  </span><span class="s1">typeof window === 'undefined'</span><span class="s3">\n    </span><span class="s1">? (</span><span class="s3">\n        </span><span class="s1">require('../../server/app-render/action-async-storage.external') as typeof import('../../server/app-render/action-async-storage.external')</span><span class="s3">\n      </span><span class="s1">).actionAsyncStorage</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n\n</span><span class="s1">export function getRedirectError(</span><span class="s3">\n  </span><span class="s1">url: string,</span><span class="s3">\n  </span><span class="s1">type: RedirectType,</span><span class="s3">\n  </span><span class="s1">statusCode: RedirectStatusCode = RedirectStatusCode.TemporaryRedirect</span><span class="s3">\n</span><span class="s1">): RedirectError {</span><span class="s3">\n  </span><span class="s1">const error = new Error(REDIRECT_ERROR_CODE) as RedirectError</span><span class="s3">\n  </span><span class="s1">error.digest = `${REDIRECT_ERROR_CODE};${type};${url};${statusCode};`</span><span class="s3">\n  </span><span class="s1">return error</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function allows you to redirect the user to another URL. It can be used in</span><span class="s3">\n </span><span class="s1">* [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),</span><span class="s3">\n </span><span class="s1">* [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and</span><span class="s3">\n </span><span class="s1">* [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* - In a Server Component, this will insert a meta tag to redirect the user to the target page.</span><span class="s3">\n </span><span class="s1">* - In a Route Handler or Server Action, it will serve a 307/303 to the caller.</span><span class="s3">\n </span><span class="s1">* - In a Server Action, type defaults to 'push' and 'replace' elsewhere.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function redirect(</span><span class="s3">\n  </span><span class="s1">/** The URL to redirect to */</span><span class="s3">\n  </span><span class="s1">url: string,</span><span class="s3">\n  </span><span class="s1">type?: RedirectType</span><span class="s3">\n</span><span class="s1">): never {</span><span class="s3">\n  </span><span class="s1">type ??= actionAsyncStorage?.getStore()?.isAction</span><span class="s3">\n    </span><span class="s1">? RedirectType.push</span><span class="s3">\n    </span><span class="s1">: RedirectType.replace</span><span class="s3">\n\n  </span><span class="s1">throw getRedirectError(url, type, RedirectStatusCode.TemporaryRedirect)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function allows you to redirect the user to another URL. It can be used in</span><span class="s3">\n </span><span class="s1">* [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),</span><span class="s3">\n </span><span class="s1">* [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and</span><span class="s3">\n </span><span class="s1">* [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* - In a Server Component, this will insert a meta tag to redirect the user to the target page.</span><span class="s3">\n </span><span class="s1">* - In a Route Handler or Server Action, it will serve a 308/303 to the caller.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function permanentRedirect(</span><span class="s3">\n  </span><span class="s1">/** The URL to redirect to */</span><span class="s3">\n  </span><span class="s1">url: string,</span><span class="s3">\n  </span><span class="s1">type: RedirectType = RedirectType.replace</span><span class="s3">\n</span><span class="s1">): never {</span><span class="s3">\n  </span><span class="s1">throw getRedirectError(url, type, RedirectStatusCode.PermanentRedirect)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the encoded URL from the error if it's a RedirectError, null</span><span class="s3">\n </span><span class="s1">* otherwise. Note that this does not validate the URL returned.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param error the error that may be a redirect error</span><span class="s3">\n </span><span class="s1">* @return the url if the error was a redirect error</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getURLFromRedirectError(error: RedirectError): string</span><span class="s3">\n</span><span class="s1">export function getURLFromRedirectError(error: unknown): string | null {</span><span class="s3">\n  </span><span class="s1">if (!isRedirectError(error)) return null</span><span class="s3">\n\n  </span><span class="s1">// Slices off the beginning of the digest that contains the code and the</span><span class="s3">\n  </span><span class="s1">// separating ';'.</span><span class="s3">\n  </span><span class="s1">return error.digest.split(';').slice(2, -2).join(';')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getRedirectTypeFromError(error: RedirectError): RedirectType {</span><span class="s3">\n  </span><span class="s1">if (!isRedirectError(error)) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Not a redirect error')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return error.digest.split(';', 2)[1] as RedirectType</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getRedirectStatusCodeFromError(error: RedirectError): number {</span><span class="s3">\n  </span><span class="s1">if (!isRedirectError(error)) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Not a redirect error')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return Number(error.digest.split(';').at(-2))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;getRedirectError&quot;</span><span class="s0">,</span><span class="s1">&quot;getRedirectStatusCodeFromError&quot;</span><span class="s0">,</span><span class="s1">&quot;getRedirectTypeFromError&quot;</span><span class="s0">,</span><span class="s1">&quot;getURLFromRedirectError&quot;</span><span class="s0">,</span><span class="s1">&quot;permanentRedirect&quot;</span><span class="s0">,</span><span class="s1">&quot;redirect&quot;</span><span class="s0">,</span><span class="s1">&quot;actionAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;statusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;RedirectStatusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;TemporaryRedirect&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;REDIRECT_ERROR_CODE&quot;</span><span class="s0">,</span><span class="s1">&quot;digest&quot;</span><span class="s0">,</span><span class="s1">&quot;getStore&quot;</span><span class="s0">,</span><span class="s1">&quot;isAction&quot;</span><span class="s0">,</span><span class="s1">&quot;RedirectType&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;PermanentRedirect&quot;</span><span class="s0">,</span><span class="s1">&quot;isRedirectError&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;Number&quot;</span><span class="s0">,</span><span class="s1">&quot;at&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;IAegBA,gBAAgB,EAAA;eAAhBA;;IA6EAC,8BAA8B,EAAA;eAA9BA;;IARAC,wBAAwB,EAAA;eAAxBA;;IARAC,uBAAuB,EAAA;eAAvBA;;IAhBAC,iBAAiB,EAAA;eAAjBA;;IAvBAC,QAAQ,EAAA;eAARA;;;oCArCmB;+BAM5B;AAEP,MAAMC,qBACJ,OAAOC,WAAW,cAEZC,QAAQ,iIACRF,kBAAkB,GACpBG;AAEC,SAAST,iBACdU,GAAW,EACXC,IAAkB,EAClBC,UAAqE;IAArEA,IAAAA,eAAAA,KAAAA,GAAAA,aAAiCC,oBAAAA,kBAAkB,CAACC,iBAAiB;IAErE,MAAMC,QAAQ,OAAA,cAA8B,CAA9B,IAAIC,MAAMC,eAAAA,mBAAmB,GAA7B,qBAAA;eAAA;oBAAA;sBAAA;IAA6B;IAC3CF,MAAMG,MAAM,GAAMD,eAAAA,mBAAmB,GAAC,MAAGN,OAAK,MAAGD,MAAI,MAAGE,aAAW;IACnE,OAAOG;AACT;AAcO,SAASV,SACd,2BAA2B,GAC3BK,GAAW,EACXC,IAAmB;QAEVL;IAATK,QAAAA,OAAAA,OAAAA,OAASL,CAAAA,sBAAAA,OAAAA,KAAAA,IAAAA,CAAAA,+BAAAA,mBAAoBa,QAAQ,EAAA,KAAA,OAAA,KAAA,IAA5Bb,6BAAgCc,QAAQ,IAC7CC,eAAAA,YAAY,CAACC,IAAI,GACjBD,eAAAA,YAAY,CAACE,OAAO;IAExB,MAAMvB,iBAAiBU,KAAKC,MAAME,oBAAAA,kBAAkB,CAACC,iBAAiB;AACxE;AAaO,SAASV,kBACd,2BAA2B,GAC3BM,GAAW,EACXC,IAAyC;IAAzCA,IAAAA,SAAAA,KAAAA,GAAAA,OAAqBU,eAAAA,YAAY,CAACE,OAAO;IAEzC,MAAMvB,iBAAiBU,KAAKC,MAAME,oBAAAA,kBAAkB,CAACW,iBAAiB;AACxE;AAUO,SAASrB,wBAAwBY,KAAc;IACpD,IAAI,CAACU,CAAAA,GAAAA,eAAAA,eAAe,EAACV,QAAQ,OAAO;IAEpC,wEAAwE;IACxE,kBAAkB;IAClB,OAAOA,MAAMG,MAAM,CAACQ,KAAK,CAAC,KAAKC,KAAK,CAAC,GAAG,CAAC,GAAGC,IAAI,CAAC;AACnD;AAEO,SAAS1B,yBAAyBa,KAAoB;IAC3D,IAAI,CAACU,CAAAA,GAAAA,eAAAA,eAAe,EAACV,QAAQ;QAC3B,MAAM,OAAA,cAAiC,CAAjC,IAAIC,MAAM,yBAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAgC;IACxC;IAEA,OAAOD,MAAMG,MAAM,CAACQ,KAAK,CAAC,KAAK,EAAE,CAAC,EAAE;AACtC;AAEO,SAASzB,+BAA+Bc,KAAoB;IACjE,IAAI,CAACU,CAAAA,GAAAA,eAAAA,eAAe,EAACV,QAAQ;QAC3B,MAAM,OAAA,cAAiC,CAAjC,IAAIC,MAAM,yBAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAgC;IACxC;IAEA,OAAOa,OAAOd,MAAMG,MAAM,CAACQ,KAAK,CAAC,KAAKI,EAAE,CAAC,CAAC;AAC5C&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3885</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/forbidden.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">HTTP_ERROR_FALLBACK_ERROR_CODE,</span><span class="s3">\n  </span><span class="s1">type HTTPAccessFallbackError,</span><span class="s3">\n</span><span class="s1">} from './http-access-fallback/http-access-fallback'</span><span class="s3">\n\n</span><span class="s1">// TODO: Add `forbidden` docs</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @experimental</span><span class="s3">\n </span><span class="s1">* This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)</span><span class="s3">\n </span><span class="s1">* within a route segment as well as inject a tag.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* `forbidden()` can be used in</span><span class="s3">\n </span><span class="s1">* [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),</span><span class="s3">\n </span><span class="s1">* [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and</span><span class="s3">\n </span><span class="s1">* [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">const DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};403`</span><span class="s3">\n\n</span><span class="s1">export function forbidden(): never {</span><span class="s3">\n  </span><span class="s1">if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`forbidden()</span><span class="s3">\\</span><span class="s1">` is experimental and only allowed to be enabled when </span><span class="s3">\\</span><span class="s1">`experimental.authInterrupts</span><span class="s3">\\</span><span class="s1">` is enabled.`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// eslint-disable-next-line no-throw-literal</span><span class="s3">\n  </span><span class="s1">const error = new Error(DIGEST) as HTTPAccessFallbackError</span><span class="s3">\n  </span><span class="s1">;(error as HTTPAccessFallbackError).digest = DIGEST</span><span class="s3">\n  </span><span class="s1">throw error</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;forbidden&quot;</span><span class="s0">,</span><span class="s1">&quot;DIGEST&quot;</span><span class="s0">,</span><span class="s1">&quot;HTTP_ERROR_FALLBACK_ERROR_CODE&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;digest&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAsBOG,QAAQC,GAAG,CAACC,mCAAmC;;;;;+BADtCL,aAAAA;;;eAAAA;;;oCAlBT;AAEP,6BAA6B;AAC7B;;;;;;;;;;;CAWC,GAED,MAAMC,SAAU,KAAEC,oBAAAA,8BAA8B,GAAC;AAE1C,SAASF;IACd,IAAI,oCAAkD;QACpD,MAAM,OAAA,cAEL,CAFK,IAAIM,MACP,gHADG,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,4CAA4C;IAC5C,MAAMC,QAAQ,OAAA,cAAiB,CAAjB,IAAID,MAAML,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BM,MAAkCC,MAAM,GAAGP;IAC7C,MAAMM;AACR&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3938</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/unauthorized.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">HTTP_ERROR_FALLBACK_ERROR_CODE,</span><span class="s3">\n  </span><span class="s1">type HTTPAccessFallbackError,</span><span class="s3">\n</span><span class="s1">} from './http-access-fallback/http-access-fallback'</span><span class="s3">\n\n</span><span class="s1">// TODO: Add `unauthorized` docs</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @experimental</span><span class="s3">\n </span><span class="s1">* This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)</span><span class="s3">\n </span><span class="s1">* within a route segment as well as inject a tag.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* `unauthorized()` can be used in</span><span class="s3">\n </span><span class="s1">* [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),</span><span class="s3">\n </span><span class="s1">* [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and</span><span class="s3">\n </span><span class="s1">* [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">const DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};401`</span><span class="s3">\n\n</span><span class="s1">export function unauthorized(): never {</span><span class="s3">\n  </span><span class="s1">if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`unauthorized()</span><span class="s3">\\</span><span class="s1">` is experimental and only allowed to be used when </span><span class="s3">\\</span><span class="s1">`experimental.authInterrupts</span><span class="s3">\\</span><span class="s1">` is enabled.`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// eslint-disable-next-line no-throw-literal</span><span class="s3">\n  </span><span class="s1">const error = new Error(DIGEST) as HTTPAccessFallbackError</span><span class="s3">\n  </span><span class="s1">;(error as HTTPAccessFallbackError).digest = DIGEST</span><span class="s3">\n  </span><span class="s1">throw error</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;unauthorized&quot;</span><span class="s0">,</span><span class="s1">&quot;DIGEST&quot;</span><span class="s0">,</span><span class="s1">&quot;HTTP_ERROR_FALLBACK_ERROR_CODE&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;digest&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAuBOG,QAAQC,GAAG,CAACC,mCAAmC;;;;;+BADtCL,gBAAAA;;;eAAAA;;;oCAnBT;AAEP,gCAAgC;AAChC;;;;;;;;;;;;CAYC,GAED,MAAMC,SAAU,KAAEC,oBAAAA,8BAA8B,GAAC;AAE1C,SAASF;IACd,IAAI,oCAAkD;QACpD,MAAM,OAAA,cAEL,CAFK,IAAIM,MACP,gHADG,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,4CAA4C;IAC5C,MAAMC,QAAQ,OAAA,cAAiB,CAAjB,IAAID,MAAML,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BM,MAAkCC,MAAM,GAAGP;IAC7C,MAAMM;AACR&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3992</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/unstable-rethrow.browser.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'</span><span class="s3">\n</span><span class="s1">import { isNextRouterError } from './is-next-router-error'</span><span class="s3">\n\n</span><span class="s1">export function unstable_rethrow(error: unknown): void {</span><span class="s3">\n  </span><span class="s1">if (isNextRouterError(error) || isBailoutToCSRError(error)) {</span><span class="s3">\n    </span><span class="s1">throw error</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (error instanceof Error &amp;&amp; 'cause' in error) {</span><span class="s3">\n    </span><span class="s1">unstable_rethrow(error.cause)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;unstable_rethrow&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;isNextRouterError&quot;</span><span class="s0">,</span><span class="s1">&quot;isBailoutToCSRError&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;cause&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAGgBA,oBAAAA;;;eAAAA;;;8BAHoB;mCACF;AAE3B,SAASA,iBAAiBC,KAAc;IAC7C,IAAIC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACD,UAAUE,CAAAA,GAAAA,cAAAA,mBAAmB,EAACF,QAAQ;QAC1D,MAAMA;IACR;IAEA,IAAIA,iBAAiBG,SAAS,WAAWH,OAAO;QAC9CD,iBAAiBC,MAAMI,KAAK;IAC9B;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">4022</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/hooks-server-context.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE'</span><span class="s3">\n\n</span><span class="s1">export class DynamicServerError extends Error {</span><span class="s3">\n  </span><span class="s1">digest: typeof DYNAMIC_ERROR_CODE = DYNAMIC_ERROR_CODE</span><span class="s3">\n\n  </span><span class="s1">constructor(public readonly description: string) {</span><span class="s3">\n    </span><span class="s1">super(`Dynamic server usage: ${description}`)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isDynamicServerError(err: unknown): err is DynamicServerError {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">typeof err !== 'object' ||</span><span class="s3">\n    </span><span class="s1">err === null ||</span><span class="s3">\n    </span><span class="s1">!('digest' in err) ||</span><span class="s3">\n    </span><span class="s1">typeof err.digest !== 'string'</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return err.digest === DYNAMIC_ERROR_CODE</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;DynamicServerError&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicServerError&quot;</span><span class="s0">,</span><span class="s1">&quot;DYNAMIC_ERROR_CODE&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;description&quot;</span><span class="s0">,</span><span class="s1">&quot;digest&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;IAEaA,kBAAkB,EAAA;eAAlBA;;IAQGC,oBAAoB,EAAA;eAApBA;;;AAVhB,MAAMC,qBAAqB;AAEpB,MAAMF,2BAA2BG;IAGtCC,YAA4BC,WAAmB,CAAE;QAC/C,KAAK,CAAE,2BAAwBA,cAAAA,IAAAA,CADLA,WAAAA,GAAAA,aAAAA,IAAAA,CAF5BC,MAAAA,GAAoCJ;IAIpC;AACF;AAEO,SAASD,qBAAqBM,GAAY;IAC/C,IACE,OAAOA,QAAQ,YACfA,QAAQ,QACR,CAAE,CAAA,YAAYA,GAAE,KAChB,OAAOA,IAAID,MAAM,KAAK,UACtB;QACA,OAAO;IACT;IAEA,OAAOC,IAAID,MAAM,KAAKJ;AACxB&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">4066</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/static-generation-bailout.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT'</span><span class="s3">\n\n</span><span class="s1">export class StaticGenBailoutError extends Error {</span><span class="s3">\n  </span><span class="s1">public readonly code = NEXT_STATIC_GEN_BAILOUT</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isStaticGenBailoutError(</span><span class="s3">\n  </span><span class="s1">error: unknown</span><span class="s3">\n</span><span class="s1">): error is StaticGenBailoutError {</span><span class="s3">\n  </span><span class="s1">if (typeof error !== 'object' || error === null || !('code' in error)) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return error.code === NEXT_STATIC_GEN_BAILOUT</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;StaticGenBailoutError&quot;</span><span class="s0">,</span><span class="s1">&quot;isStaticGenBailoutError&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_STATIC_GEN_BAILOUT&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;IAEaA,qBAAqB,EAAA;eAArBA;;IAIGC,uBAAuB,EAAA;eAAvBA;;;AANhB,MAAMC,0BAA0B;AAEzB,MAAMF,8BAA8BG;;QAApC,KAAA,IAAA,OAAA,IAAA,CACWC,IAAAA,GAAOF;;AACzB;AAEO,SAASD,wBACdI,KAAc;IAEd,IAAI,OAAOA,UAAU,YAAYA,UAAU,QAAQ,CAAE,CAAA,UAAUA,KAAI,GAAI;QACrE,OAAO;IACT;IAEA,OAAOA,MAAMD,IAAI,KAAKF;AACxB&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">4110</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/unstable-rethrow.server.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { isHangingPromiseRejectionError } from '../../server/dynamic-rendering-utils'</span><span class="s3">\n</span><span class="s1">import { isPostpone } from '../../server/lib/router-utils/is-postpone'</span><span class="s3">\n</span><span class="s1">import { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'</span><span class="s3">\n</span><span class="s1">import { isNextRouterError } from './is-next-router-error'</span><span class="s3">\n</span><span class="s1">import { isDynamicPostpone } from '../../server/app-render/dynamic-rendering'</span><span class="s3">\n</span><span class="s1">import { isDynamicServerError } from './hooks-server-context'</span><span class="s3">\n\n</span><span class="s1">export function unstable_rethrow(error: unknown): void {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">isNextRouterError(error) ||</span><span class="s3">\n    </span><span class="s1">isBailoutToCSRError(error) ||</span><span class="s3">\n    </span><span class="s1">isDynamicServerError(error) ||</span><span class="s3">\n    </span><span class="s1">isDynamicPostpone(error) ||</span><span class="s3">\n    </span><span class="s1">isPostpone(error) ||</span><span class="s3">\n    </span><span class="s1">isHangingPromiseRejectionError(error)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw error</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (error instanceof Error &amp;&amp; 'cause' in error) {</span><span class="s3">\n    </span><span class="s1">unstable_rethrow(error.cause)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;unstable_rethrow&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;isNextRouterError&quot;</span><span class="s0">,</span><span class="s1">&quot;isBailoutToCSRError&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicServerError&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicPostpone&quot;</span><span class="s0">,</span><span class="s1">&quot;isPostpone&quot;</span><span class="s0">,</span><span class="s1">&quot;isHangingPromiseRejectionError&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;cause&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAOgBA,oBAAAA;;;eAAAA;;;uCAP+B;4BACpB;8BACS;mCACF;kCACA;oCACG;AAE9B,SAASA,iBAAiBC,KAAc;IAC7C,IACEC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACD,UAClBE,CAAAA,GAAAA,cAAAA,mBAAmB,EAACF,UACpBG,CAAAA,GAAAA,oBAAAA,oBAAoB,EAACH,UACrBI,CAAAA,GAAAA,kBAAAA,iBAAiB,EAACJ,UAClBK,CAAAA,GAAAA,YAAAA,UAAU,EAACL,UACXM,CAAAA,GAAAA,uBAAAA,8BAA8B,EAACN,QAC/B;QACA,MAAMA;IACR;IAEA,IAAIA,iBAAiBO,SAAS,WAAWP,OAAO;QAC9CD,iBAAiBC,MAAMQ,KAAK;IAC9B;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">4144</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/unstable-rethrow.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.</span><span class="s3">\n </span><span class="s1">* When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.</span><span class="s3">\n </span><span class="s1">* This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const unstable_rethrow =</span><span class="s3">\n  </span><span class="s1">typeof window === 'undefined'</span><span class="s3">\n    </span><span class="s1">? (</span><span class="s3">\n        </span><span class="s1">require('./unstable-rethrow.server') as typeof import('./unstable-rethrow.server')</span><span class="s3">\n      </span><span class="s1">).unstable_rethrow</span><span class="s3">\n    </span><span class="s1">: (</span><span class="s3">\n        </span><span class="s1">require('./unstable-rethrow.browser') as typeof import('./unstable-rethrow.browser')</span><span class="s3">\n      </span><span class="s1">).unstable_rethrow</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;unstable_rethrow&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;;;;;CAMC;;;+BACYA,oBAAAA;;;eAAAA;;;AAAN,MAAMA,mBACX,OAAOC,WAAW,cAEZC,QAAQ,2HACRF,gBAAgB,GAEhBE,QAAQ,4HACRF,gBAAgB&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">4171</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/navigation.react-server.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/** @internal */</span><span class="s3">\n</span><span class="s1">class ReadonlyURLSearchParamsError extends Error {</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">super(</span><span class="s3">\n      </span><span class="s1">'Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class ReadonlyURLSearchParams extends URLSearchParams {</span><span class="s3">\n  </span><span class="s1">/** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */</span><span class="s3">\n  </span><span class="s1">append() {</span><span class="s3">\n    </span><span class="s1">throw new ReadonlyURLSearchParamsError()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */</span><span class="s3">\n  </span><span class="s1">delete() {</span><span class="s3">\n    </span><span class="s1">throw new ReadonlyURLSearchParamsError()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */</span><span class="s3">\n  </span><span class="s1">set() {</span><span class="s3">\n    </span><span class="s1">throw new ReadonlyURLSearchParamsError()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */</span><span class="s3">\n  </span><span class="s1">sort() {</span><span class="s3">\n    </span><span class="s1">throw new ReadonlyURLSearchParamsError()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function unstable_isUnrecognizedActionError(): boolean {</span><span class="s3">\n  </span><span class="s1">throw new Error(</span><span class="s3">\n    </span><span class="s1">'`unstable_isUnrecognizedActionError` can only be used on the client.'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { redirect, permanentRedirect } from './redirect'</span><span class="s3">\n</span><span class="s1">export { RedirectType } from './redirect-error'</span><span class="s3">\n</span><span class="s1">export { notFound } from './not-found'</span><span class="s3">\n</span><span class="s1">export { forbidden } from './forbidden'</span><span class="s3">\n</span><span class="s1">export { unauthorized } from './unauthorized'</span><span class="s3">\n</span><span class="s1">export { unstable_rethrow } from './unstable-rethrow'</span><span class="s3">\n</span><span class="s1">export { ReadonlyURLSearchParams }</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;ReadonlyURLSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;RedirectType&quot;</span><span class="s0">,</span><span class="s1">&quot;forbidden&quot;</span><span class="s0">,</span><span class="s1">&quot;notFound&quot;</span><span class="s0">,</span><span class="s1">&quot;permanentRedirect&quot;</span><span class="s0">,</span><span class="s1">&quot;redirect&quot;</span><span class="s0">,</span><span class="s1">&quot;unauthorized&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_isUnrecognizedActionError&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_rethrow&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadonlyURLSearchParamsError&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;URLSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;append&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;sort&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA,cAAc;;;;;;;;;;;;;;;;;;;;;IAwCLA,uBAAuB,EAAA;eAAvBA;;IALAC,YAAY,EAAA;eAAZA,eAAAA,YAAY;;IAEZC,SAAS,EAAA;eAATA,WAAAA,SAAS;;IADTC,QAAQ,EAAA;eAARA,UAAAA,QAAQ;;IAFEC,iBAAiB,EAAA;eAAjBA,UAAAA,iBAAiB;;IAA3BC,QAAQ,EAAA;eAARA,UAAAA,QAAQ;;IAIRC,YAAY,EAAA;eAAZA,cAAAA,YAAY;;IAVLC,kCAAkC,EAAA;eAAlCA;;IAWPC,gBAAgB,EAAA;eAAhBA,iBAAAA,gBAAgB;;;0BALmB;+BACf;0BACJ;2BACC;8BACG;iCACI;AAtCjC,MAAMC,qCAAqCC;IACzCC,aAAc;QACZ,KAAK,CACH;IAEJ;AACF;AAEA,MAAMX,gCAAgCY;IACpC,wKAAwK,GACxKC,SAAS;QACP,MAAM,IAAIJ;IACZ;IACA,wKAAwK,GACxKK,SAAS;QACP,MAAM,IAAIL;IACZ;IACA,wKAAwK,GACxKM,MAAM;QACJ,MAAM,IAAIN;IACZ;IACA,wKAAwK,GACxKO,OAAO;QACL,MAAM,IAAIP;IACZ;AACF;AAEO,SAASF;IACd,MAAM,OAAA,cAEL,CAFK,IAAIG,MACR,yEADI,qBAAA;eAAA;oBAAA;sBAAA;IAEN;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">4263</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/unrecognized-action-error.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;export class UnrecognizedActionError extends Error {</span><span class="s3">\n  </span><span class="s1">constructor(...args: ConstructorParameters&lt;typeof Error&gt;) {</span><span class="s3">\n    </span><span class="s1">super(...args)</span><span class="s3">\n    </span><span class="s1">this.name = 'UnrecognizedActionError'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check whether a server action call failed because the server action was not recognized by the server.</span><span class="s3">\n </span><span class="s1">* This can happen if the client and the server are not from the same deployment.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Example usage:</span><span class="s3">\n </span><span class="s1">* ```ts</span><span class="s3">\n </span><span class="s1">* try {</span><span class="s3">\n </span><span class="s1">*   await myServerAction();</span><span class="s3">\n </span><span class="s1">* } catch (err) {</span><span class="s3">\n </span><span class="s1">*   if (unstable_isUnrecognizedActionError(err)) {</span><span class="s3">\n </span><span class="s1">*     // The client is from a different deployment than the server.</span><span class="s3">\n </span><span class="s1">*     // Reloading the page will fix this mismatch.</span><span class="s3">\n </span><span class="s1">*     window.alert(</span><span class="s3">\&quot;</span><span class="s1">Please refresh the page and try again</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n </span><span class="s1">*     return;</span><span class="s3">\n </span><span class="s1">*   }</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">* */</span><span class="s3">\n</span><span class="s1">export function unstable_isUnrecognizedActionError(</span><span class="s3">\n  </span><span class="s1">error: unknown</span><span class="s3">\n</span><span class="s1">): error is UnrecognizedActionError {</span><span class="s3">\n  </span><span class="s1">return !!(</span><span class="s3">\n    </span><span class="s1">error &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof error === 'object' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">error instanceof UnrecognizedActionError</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;UnrecognizedActionError&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_isUnrecognizedActionError&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;IAAaA,uBAAuB,EAAA;eAAvBA;;IAyBGC,kCAAkC,EAAA;eAAlCA;;;AAzBT,MAAMD,gCAAgCE;IAC3CC,YAAY,GAAGC,IAAyC,CAAE;QACxD,KAAK,IAAIA;QACT,IAAI,CAACC,IAAI,GAAG;IACd;AACF;AAoBO,SAASJ,mCACdK,KAAc;IAEd,OAAO,CAAC,CACNA,CAAAA,SACA,OAAOA,UAAU,YACjBA,iBAAiBN,uBAAsB;AAE3C&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">4304</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/bailout-to-client-rendering.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { BailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'</span><span class="s3">\n</span><span class="s1">import { workAsyncStorage } from '../../server/app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { workUnitAsyncStorage } from '../../server/app-render/work-unit-async-storage.external'</span><span class="s3">\n\n</span><span class="s1">export function bailoutToClientRendering(reason: string): void | never {</span><span class="s3">\n  </span><span class="s1">const workStore = workAsyncStorage.getStore()</span><span class="s3">\n\n  </span><span class="s1">if (workStore?.forceStatic) return</span><span class="s3">\n\n  </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n\n  </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n    </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n      </span><span class="s1">case 'prerender':</span><span class="s3">\n      </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n      </span><span class="s1">case 'prerender-client':</span><span class="s3">\n      </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n      </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n        </span><span class="s1">throw new BailoutToCSRError(reason)</span><span class="s3">\n      </span><span class="s1">case 'request':</span><span class="s3">\n      </span><span class="s1">case 'cache':</span><span class="s3">\n      </span><span class="s1">case 'private-cache':</span><span class="s3">\n      </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;bailoutToClientRendering&quot;</span><span class="s0">,</span><span class="s1">&quot;reason&quot;</span><span class="s0">,</span><span class="s1">&quot;workStore&quot;</span><span class="s0">,</span><span class="s1">&quot;workAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;getStore&quot;</span><span class="s0">,</span><span class="s1">&quot;forceStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitStore&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;BailoutToCSRError&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAIgBA,4BAAAA;;;eAAAA;;;8BAJkB;0CACD;8CACI;AAE9B,SAASA,yBAAyBC,MAAc;IACrD,MAAMC,YAAYC,0BAAAA,gBAAgB,CAACC,QAAQ;IAE3C,IAAIF,aAAAA,OAAAA,KAAAA,IAAAA,UAAWG,WAAW,EAAE;IAE5B,MAAMC,gBAAgBC,8BAAAA,oBAAoB,CAACH,QAAQ;IAEnD,IAAIE,eAAe;QACjB,OAAQA,cAAcE,IAAI;YACxB,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBACH,MAAM,OAAA,cAA6B,CAA7B,IAAIC,cAAAA,iBAAiB,CAACR,SAAtB,qBAAA;2BAAA;gCAAA;kCAAA;gBAA4B;YACpC,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBACH;YACF;gBACEK;QACJ;IACF;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">4353</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/navigation.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { FlightRouterState } from '../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../../server/request/params'</span><span class="s3">\n\n</span><span class="s1">import { useContext, useMemo } from 'react'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">AppRouterContext,</span><span class="s3">\n  </span><span class="s1">LayoutRouterContext,</span><span class="s3">\n  </span><span class="s1">type AppRouterInstance,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">SearchParamsContext,</span><span class="s3">\n  </span><span class="s1">PathnameContext,</span><span class="s3">\n  </span><span class="s1">PathParamsContext,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/hooks-client-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { getSegmentValue } from './router-reducer/reducers/get-segment-value'</span><span class="s3">\n</span><span class="s1">import { PAGE_SEGMENT_KEY, DEFAULT_SEGMENT_KEY } from '../../shared/lib/segment'</span><span class="s3">\n</span><span class="s1">import { ReadonlyURLSearchParams } from './navigation.react-server'</span><span class="s3">\n\n</span><span class="s1">const useDynamicRouteParams =</span><span class="s3">\n  </span><span class="s1">typeof window === 'undefined'</span><span class="s3">\n    </span><span class="s1">? (</span><span class="s3">\n        </span><span class="s1">require('../../server/app-render/dynamic-rendering') as typeof import('../../server/app-render/dynamic-rendering')</span><span class="s3">\n      </span><span class="s1">).useDynamicRouteParams</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook</span><span class="s3">\n </span><span class="s1">* that lets you *read* the current URL's search parameters.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Learn more about [`URLSearchParams` on MDN](https://developer.mozilla.org/docs/Web/API/URLSearchParams)</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">* ```ts</span><span class="s3">\n </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;\n </span><span class="s1">* import { useSearchParams } from 'next/navigation'</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* export default function Page() {</span><span class="s3">\n </span><span class="s1">*   const searchParams = useSearchParams()</span><span class="s3">\n </span><span class="s1">*   searchParams.get('foo') // returns 'bar' when ?foo=bar</span><span class="s3">\n </span><span class="s1">*   // ...</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Read more: [Next.js Docs: `useSearchParams`](https://nextjs.org/docs/app/api-reference/functions/use-search-params)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">// Client components API</span><span class="s3">\n</span><span class="s1">export function useSearchParams(): ReadonlyURLSearchParams {</span><span class="s3">\n  </span><span class="s1">const searchParams = useContext(SearchParamsContext)</span><span class="s3">\n\n  </span><span class="s1">// In the case where this is `null`, the compat types added in</span><span class="s3">\n  </span><span class="s1">// `next-env.d.ts` will add a new overload that changes the return type to</span><span class="s3">\n  </span><span class="s1">// include `null`.</span><span class="s3">\n  </span><span class="s1">const readonlySearchParams = useMemo(() =&gt; {</span><span class="s3">\n    </span><span class="s1">if (!searchParams) {</span><span class="s3">\n      </span><span class="s1">// When the router is not ready in pages, we won't have the search params</span><span class="s3">\n      </span><span class="s1">// available.</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return new ReadonlyURLSearchParams(searchParams)</span><span class="s3">\n  </span><span class="s1">}, [searchParams]) as ReadonlyURLSearchParams</span><span class="s3">\n\n  </span><span class="s1">if (typeof window === 'undefined') {</span><span class="s3">\n    </span><span class="s1">// AsyncLocalStorage should not be included in the client bundle.</span><span class="s3">\n    </span><span class="s1">const { bailoutToClientRendering } =</span><span class="s3">\n      </span><span class="s1">require('./bailout-to-client-rendering') as typeof import('./bailout-to-client-rendering')</span><span class="s3">\n    </span><span class="s1">// TODO-APP: handle dynamic = 'force-static' here and on the client</span><span class="s3">\n    </span><span class="s1">bailoutToClientRendering('useSearchParams()')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return readonlySearchParams</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook</span><span class="s3">\n </span><span class="s1">* that lets you read the current URL's pathname.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">* ```ts</span><span class="s3">\n </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;\n </span><span class="s1">* import { usePathname } from 'next/navigation'</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* export default function Page() {</span><span class="s3">\n </span><span class="s1">*  const pathname = usePathname() // returns </span><span class="s3">\&quot;</span><span class="s1">/dashboard</span><span class="s3">\&quot; </span><span class="s1">on /dashboard?foo=bar</span><span class="s3">\n </span><span class="s1">*  // ...</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Read more: [Next.js Docs: `usePathname`](https://nextjs.org/docs/app/api-reference/functions/use-pathname)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">// Client components API</span><span class="s3">\n</span><span class="s1">export function usePathname(): string {</span><span class="s3">\n  </span><span class="s1">useDynamicRouteParams?.('usePathname()')</span><span class="s3">\n\n  </span><span class="s1">// In the case where this is `null`, the compat types added in `next-env.d.ts`</span><span class="s3">\n  </span><span class="s1">// will add a new overload that changes the return type to include `null`.</span><span class="s3">\n  </span><span class="s1">return useContext(PathnameContext) as string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Client components API</span><span class="s3">\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">ServerInsertedHTMLContext,</span><span class="s3">\n  </span><span class="s1">useServerInsertedHTML,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/server-inserted-html.shared-runtime'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This hook allows you to programmatically change routes inside [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">* ```ts</span><span class="s3">\n </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;\n </span><span class="s1">* import { useRouter } from 'next/navigation'</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* export default function Page() {</span><span class="s3">\n </span><span class="s1">*  const router = useRouter()</span><span class="s3">\n </span><span class="s1">*  // ...</span><span class="s3">\n </span><span class="s1">*  router.push('/dashboard') // Navigate to /dashboard</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Read more: [Next.js Docs: `useRouter`](https://nextjs.org/docs/app/api-reference/functions/use-router)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">// Client components API</span><span class="s3">\n</span><span class="s1">export function useRouter(): AppRouterInstance {</span><span class="s3">\n  </span><span class="s1">const router = useContext(AppRouterContext)</span><span class="s3">\n  </span><span class="s1">if (router === null) {</span><span class="s3">\n    </span><span class="s1">throw new Error('invariant expected app router to be mounted')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return router</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook</span><span class="s3">\n </span><span class="s1">* that lets you read a route's dynamic params filled in by the current URL.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">* ```ts</span><span class="s3">\n </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;\n </span><span class="s1">* import { useParams } from 'next/navigation'</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* export default function Page() {</span><span class="s3">\n </span><span class="s1">*   // on /dashboard/[team] where pathname is /dashboard/nextjs</span><span class="s3">\n </span><span class="s1">*   const { team } = useParams() // team === </span><span class="s3">\&quot;</span><span class="s1">nextjs</span><span class="s3">\&quot;\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Read more: [Next.js Docs: `useParams`](https://nextjs.org/docs/app/api-reference/functions/use-params)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">// Client components API</span><span class="s3">\n</span><span class="s1">export function useParams&lt;T extends Params = Params&gt;(): T {</span><span class="s3">\n  </span><span class="s1">useDynamicRouteParams?.('useParams()')</span><span class="s3">\n\n  </span><span class="s1">return useContext(PathParamsContext) as T</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/** Get the canonical parameters from the current level to the leaf node. */</span><span class="s3">\n</span><span class="s1">// Client components API</span><span class="s3">\n</span><span class="s1">function getSelectedLayoutSegmentPath(</span><span class="s3">\n  </span><span class="s1">tree: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">parallelRouteKey: string,</span><span class="s3">\n  </span><span class="s1">first = true,</span><span class="s3">\n  </span><span class="s1">segmentPath: string[] = []</span><span class="s3">\n</span><span class="s1">): string[] {</span><span class="s3">\n  </span><span class="s1">let node: FlightRouterState</span><span class="s3">\n  </span><span class="s1">if (first) {</span><span class="s3">\n    </span><span class="s1">// Use the provided parallel route key on the first parallel route</span><span class="s3">\n    </span><span class="s1">node = tree[1][parallelRouteKey]</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// After first parallel route prefer children, if there's no children pick the first parallel route.</span><span class="s3">\n    </span><span class="s1">const parallelRoutes = tree[1]</span><span class="s3">\n    </span><span class="s1">node = parallelRoutes.children ?? Object.values(parallelRoutes)[0]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!node) return segmentPath</span><span class="s3">\n  </span><span class="s1">const segment = node[0]</span><span class="s3">\n\n  </span><span class="s1">let segmentValue = getSegmentValue(segment)</span><span class="s3">\n\n  </span><span class="s1">if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) {</span><span class="s3">\n    </span><span class="s1">return segmentPath</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">segmentPath.push(segmentValue)</span><span class="s3">\n\n  </span><span class="s1">return getSelectedLayoutSegmentPath(</span><span class="s3">\n    </span><span class="s1">node,</span><span class="s3">\n    </span><span class="s1">parallelRouteKey,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">segmentPath</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook</span><span class="s3">\n </span><span class="s1">* that lets you read the active route segments **below** the Layout it is called from.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">* ```ts</span><span class="s3">\n </span><span class="s1">* 'use client'</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* import { useSelectedLayoutSegments } from 'next/navigation'</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* export default function ExampleClientComponent() {</span><span class="s3">\n </span><span class="s1">*   const segments = useSelectedLayoutSegments()</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   return (</span><span class="s3">\n </span><span class="s1">*     &lt;ul&gt;</span><span class="s3">\n </span><span class="s1">*       {segments.map((segment, index) =&gt; (</span><span class="s3">\n </span><span class="s1">*         &lt;li key={index}&gt;{segment}&lt;/li&gt;</span><span class="s3">\n </span><span class="s1">*       ))}</span><span class="s3">\n </span><span class="s1">*     &lt;/ul&gt;</span><span class="s3">\n </span><span class="s1">*   )</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Read more: [Next.js Docs: `useSelectedLayoutSegments`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segments)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">// Client components API</span><span class="s3">\n</span><span class="s1">export function useSelectedLayoutSegments(</span><span class="s3">\n  </span><span class="s1">parallelRouteKey: string = 'children'</span><span class="s3">\n</span><span class="s1">): string[] {</span><span class="s3">\n  </span><span class="s1">useDynamicRouteParams?.('useSelectedLayoutSegments()')</span><span class="s3">\n\n  </span><span class="s1">const context = useContext(LayoutRouterContext)</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error This only happens in `pages`. Type is overwritten in navigation.d.ts</span><span class="s3">\n  </span><span class="s1">if (!context) return null</span><span class="s3">\n\n  </span><span class="s1">return getSelectedLayoutSegmentPath(context.parentTree, parallelRouteKey)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook</span><span class="s3">\n </span><span class="s1">* that lets you read the active route segment **one level below** the Layout it is called from.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">* ```ts</span><span class="s3">\n </span><span class="s1">* 'use client'</span><span class="s3">\n </span><span class="s1">* import { useSelectedLayoutSegment } from 'next/navigation'</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* export default function ExampleClientComponent() {</span><span class="s3">\n </span><span class="s1">*   const segment = useSelectedLayoutSegment()</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   return &lt;p&gt;Active segment: {segment}&lt;/p&gt;</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Read more: [Next.js Docs: `useSelectedLayoutSegment`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segment)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">// Client components API</span><span class="s3">\n</span><span class="s1">export function useSelectedLayoutSegment(</span><span class="s3">\n  </span><span class="s1">parallelRouteKey: string = 'children'</span><span class="s3">\n</span><span class="s1">): string | null {</span><span class="s3">\n  </span><span class="s1">useDynamicRouteParams?.('useSelectedLayoutSegment()')</span><span class="s3">\n\n  </span><span class="s1">const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey)</span><span class="s3">\n\n  </span><span class="s1">if (!selectedLayoutSegments || selectedLayoutSegments.length === 0) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const selectedLayoutSegment =</span><span class="s3">\n    </span><span class="s1">parallelRouteKey === 'children'</span><span class="s3">\n      </span><span class="s1">? selectedLayoutSegments[0]</span><span class="s3">\n      </span><span class="s1">: selectedLayoutSegments[selectedLayoutSegments.length - 1]</span><span class="s3">\n\n  </span><span class="s1">// if the default slot is showing, we return null since it's not technically </span><span class="s3">\&quot;</span><span class="s1">selected</span><span class="s3">\&quot; </span><span class="s1">(it's a fallback)</span><span class="s3">\n  </span><span class="s1">// and returning an internal value like `__DEFAULT__` would be confusing.</span><span class="s3">\n  </span><span class="s1">return selectedLayoutSegment === DEFAULT_SEGMENT_KEY</span><span class="s3">\n    </span><span class="s1">? null</span><span class="s3">\n    </span><span class="s1">: selectedLayoutSegment</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { unstable_isUnrecognizedActionError } from './unrecognized-action-error'</span><span class="s3">\n\n</span><span class="s1">// Shared components APIs</span><span class="s3">\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">notFound,</span><span class="s3">\n  </span><span class="s1">forbidden,</span><span class="s3">\n  </span><span class="s1">unauthorized,</span><span class="s3">\n  </span><span class="s1">redirect,</span><span class="s3">\n  </span><span class="s1">permanentRedirect,</span><span class="s3">\n  </span><span class="s1">RedirectType,</span><span class="s3">\n  </span><span class="s1">ReadonlyURLSearchParams,</span><span class="s3">\n  </span><span class="s1">unstable_rethrow,</span><span class="s3">\n</span><span class="s1">} from './navigation.react-server'</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;ReadonlyURLSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;RedirectType&quot;</span><span class="s0">,</span><span class="s1">&quot;ServerInsertedHTMLContext&quot;</span><span class="s0">,</span><span class="s1">&quot;forbidden&quot;</span><span class="s0">,</span><span class="s1">&quot;notFound&quot;</span><span class="s0">,</span><span class="s1">&quot;permanentRedirect&quot;</span><span class="s0">,</span><span class="s1">&quot;redirect&quot;</span><span class="s0">,</span><span class="s1">&quot;unauthorized&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_isUnrecognizedActionError&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_rethrow&quot;</span><span class="s0">,</span><span class="s1">&quot;useParams&quot;</span><span class="s0">,</span><span class="s1">&quot;usePathname&quot;</span><span class="s0">,</span><span class="s1">&quot;useRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;useSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;useSelectedLayoutSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;useSelectedLayoutSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;useServerInsertedHTML&quot;</span><span class="s0">,</span><span class="s1">&quot;useDynamicRouteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;useContext&quot;</span><span class="s0">,</span><span class="s1">&quot;SearchParamsContext&quot;</span><span class="s0">,</span><span class="s1">&quot;readonlySearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;useMemo&quot;</span><span class="s0">,</span><span class="s1">&quot;bailoutToClientRendering&quot;</span><span class="s0">,</span><span class="s1">&quot;PathnameContext&quot;</span><span class="s0">,</span><span class="s1">&quot;router&quot;</span><span class="s0">,</span><span class="s1">&quot;AppRouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;PathParamsContext&quot;</span><span class="s0">,</span><span class="s1">&quot;getSelectedLayoutSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;first&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentValue&quot;</span><span class="s0">,</span><span class="s1">&quot;getSegmentValue&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;PAGE_SEGMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;context&quot;</span><span class="s0">,</span><span class="s1">&quot;LayoutRouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;parentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;selectedLayoutSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;selectedLayoutSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;DEFAULT_SEGMENT_KEY&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">4541</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/redirect-boundary.tsx&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;'use client'</span><span class="s3">\n</span><span class="s1">import React, { useEffect } from 'react'</span><span class="s3">\n</span><span class="s1">import type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { useRouter } from './navigation'</span><span class="s3">\n</span><span class="s1">import { getRedirectTypeFromError, getURLFromRedirectError } from './redirect'</span><span class="s3">\n</span><span class="s1">import { RedirectType, isRedirectError } from './redirect-error'</span><span class="s3">\n\n</span><span class="s1">interface RedirectBoundaryProps {</span><span class="s3">\n  </span><span class="s1">router: AppRouterInstance</span><span class="s3">\n  </span><span class="s1">children: React.ReactNode</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function HandleRedirect({</span><span class="s3">\n  </span><span class="s1">redirect,</span><span class="s3">\n  </span><span class="s1">reset,</span><span class="s3">\n  </span><span class="s1">redirectType,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">redirect: string</span><span class="s3">\n  </span><span class="s1">redirectType: RedirectType</span><span class="s3">\n  </span><span class="s1">reset: () =&gt; void</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">const router = useRouter()</span><span class="s3">\n\n  </span><span class="s1">useEffect(() =&gt; {</span><span class="s3">\n    </span><span class="s1">React.startTransition(() =&gt; {</span><span class="s3">\n      </span><span class="s1">if (redirectType === RedirectType.push) {</span><span class="s3">\n        </span><span class="s1">router.push(redirect, {})</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">router.replace(redirect, {})</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">reset()</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}, [redirect, redirectType, reset, router])</span><span class="s3">\n\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class RedirectErrorBoundary extends React.Component&lt;</span><span class="s3">\n  </span><span class="s1">RedirectBoundaryProps,</span><span class="s3">\n  </span><span class="s1">{ redirect: string | null; redirectType: RedirectType | null }</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">constructor(props: RedirectBoundaryProps) {</span><span class="s3">\n    </span><span class="s1">super(props)</span><span class="s3">\n    </span><span class="s1">this.state = { redirect: null, redirectType: null }</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static getDerivedStateFromError(error: any) {</span><span class="s3">\n    </span><span class="s1">if (isRedirectError(error)) {</span><span class="s3">\n      </span><span class="s1">const url = getURLFromRedirectError(error)</span><span class="s3">\n      </span><span class="s1">const redirectType = getRedirectTypeFromError(error)</span><span class="s3">\n      </span><span class="s1">return { redirect: url, redirectType }</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Re-throw if error is not for redirect</span><span class="s3">\n    </span><span class="s1">throw error</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.</span><span class="s3">\n  </span><span class="s1">render(): React.ReactNode {</span><span class="s3">\n    </span><span class="s1">const { redirect, redirectType } = this.state</span><span class="s3">\n    </span><span class="s1">if (redirect !== null &amp;&amp; redirectType !== null) {</span><span class="s3">\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">&lt;HandleRedirect</span><span class="s3">\n          </span><span class="s1">redirect={redirect}</span><span class="s3">\n          </span><span class="s1">redirectType={redirectType}</span><span class="s3">\n          </span><span class="s1">reset={() =&gt; this.setState({ redirect: null })}</span><span class="s3">\n        </span><span class="s1">/&gt;</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.props.children</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function RedirectBoundary({ children }: { children: React.ReactNode }) {</span><span class="s3">\n  </span><span class="s1">const router = useRouter()</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">&lt;RedirectErrorBoundary router={router}&gt;{children}&lt;/RedirectErrorBoundary&gt;</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;RedirectBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;RedirectErrorBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;HandleRedirect&quot;</span><span class="s0">,</span><span class="s1">&quot;redirect&quot;</span><span class="s0">,</span><span class="s1">&quot;reset&quot;</span><span class="s0">,</span><span class="s1">&quot;redirectType&quot;</span><span class="s0">,</span><span class="s1">&quot;router&quot;</span><span class="s0">,</span><span class="s1">&quot;useRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;useEffect&quot;</span><span class="s0">,</span><span class="s1">&quot;React&quot;</span><span class="s0">,</span><span class="s1">&quot;startTransition&quot;</span><span class="s0">,</span><span class="s1">&quot;RedirectType&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;Component&quot;</span><span class="s0">,</span><span class="s1">&quot;getDerivedStateFromError&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;isRedirectError&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;getURLFromRedirectError&quot;</span><span class="s0">,</span><span class="s1">&quot;getRedirectTypeFromError&quot;</span><span class="s0">,</span><span class="s1">&quot;render&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;setState&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;IAyEgBA,gBAAgB,EAAA;eAAhBA;;IApCHC,qBAAqB,EAAA;eAArBA;;;;;iEApCoB;4BAEP;0BACwC;+BACpB;AAO9C,SAASC,eAAe,KAQvB;IARuB,IAAA,EACtBC,QAAQ,EACRC,KAAK,EACLC,YAAY,EAKb,GARuB;IAStB,MAAMC,SAASC,CAAAA,GAAAA,YAAAA,SAAS;IAExBC,CAAAA,GAAAA,OAAAA,SAAS,EAAC;QACRC,OAAAA,OAAK,CAACC,eAAe,CAAC;YACpB,IAAIL,iBAAiBM,eAAAA,YAAY,CAACC,IAAI,EAAE;gBACtCN,OAAOM,IAAI,CAACT,UAAU,CAAC;YACzB,OAAO;gBACLG,OAAOO,OAAO,CAACV,UAAU,CAAC;YAC5B;YACAC;QACF;IACF,GAAG;QAACD;QAAUE;QAAcD;QAAOE;KAAO;IAE1C,OAAO;AACT;AAEO,MAAML,8BAA8BQ,OAAAA,OAAK,CAACK,SAAS;IASxD,OAAOC,yBAAyBC,KAAU,EAAE;QAC1C,IAAIC,CAAAA,GAAAA,eAAAA,eAAe,EAACD,QAAQ;YAC1B,MAAME,MAAMC,CAAAA,GAAAA,UAAAA,uBAAuB,EAACH;YACpC,MAAMX,eAAee,CAAAA,GAAAA,UAAAA,wBAAwB,EAACJ;YAC9C,OAAO;gBAAEb,UAAUe;gBAAKb;YAAa;QACvC;QACA,wCAAwC;QACxC,MAAMW;IACR;IAEA,yIAAyI;IACzIK,SAA0B;QACxB,MAAM,EAAElB,QAAQ,EAAEE,YAAY,EAAE,GAAG,IAAI,CAACiB,KAAK;QAC7C,IAAInB,aAAa,QAAQE,iBAAiB,MAAM;YAC9C,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACH,gBAAAA;gBACCC,UAAUA;gBACVE,cAAcA;gBACdD,OAAO,IAAM,IAAI,CAACmB,QAAQ,CAAC;wBAAEpB,UAAU;oBAAK;;QAGlD;QAEA,OAAO,IAAI,CAACqB,KAAK,CAACC,QAAQ;IAC5B;IA7BAC,YAAYF,KAA4B,CAAE;QACxC,KAAK,CAACA;QACN,IAAI,CAACF,KAAK,GAAG;YAAEnB,UAAU;YAAME,cAAc;QAAK;IACpD;AA2BF;AAEO,SAASL,iBAAiB,KAA2C;IAA3C,IAAA,EAAEyB,QAAQ,EAAiC,GAA3C;IAC/B,MAAMnB,SAASC,CAAAA,GAAAA,YAAAA,SAAS;IACxB,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACN,uBAAAA;QAAsBK,QAAQA;kBAASmB;;AAE5C&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">4642</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/reducers/find-head-in-cache.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { FlightRouterState } from '../../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { DEFAULT_SEGMENT_KEY } from '../../../../shared/lib/segment'</span><span class="s3">\n</span><span class="s1">import { createRouterCacheKey } from '../create-router-cache-key'</span><span class="s3">\n\n</span><span class="s1">export function findHeadInCache(</span><span class="s3">\n  </span><span class="s1">cache: CacheNode,</span><span class="s3">\n  </span><span class="s1">parallelRoutes: FlightRouterState[1]</span><span class="s3">\n</span><span class="s1">): [CacheNode, string, string] | null {</span><span class="s3">\n  </span><span class="s1">return findHeadInCacheImpl(cache, parallelRoutes, '', '')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function findHeadInCacheImpl(</span><span class="s3">\n  </span><span class="s1">cache: CacheNode,</span><span class="s3">\n  </span><span class="s1">parallelRoutes: FlightRouterState[1],</span><span class="s3">\n  </span><span class="s1">keyPrefix: string,</span><span class="s3">\n  </span><span class="s1">keyPrefixWithoutSearchParams: string</span><span class="s3">\n</span><span class="s1">): [CacheNode, string, string] | null {</span><span class="s3">\n  </span><span class="s1">const isLastItem = Object.keys(parallelRoutes).length === 0</span><span class="s3">\n  </span><span class="s1">if (isLastItem) {</span><span class="s3">\n    </span><span class="s1">// Returns the entire Cache Node of the segment whose head we will render.</span><span class="s3">\n    </span><span class="s1">return [cache, keyPrefix, keyPrefixWithoutSearchParams]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// First try the 'children' parallel route if it exists</span><span class="s3">\n  </span><span class="s1">// when starting from the </span><span class="s3">\&quot;</span><span class="s1">root</span><span class="s3">\&quot;</span><span class="s1">, this corresponds with the main page component</span><span class="s3">\n  </span><span class="s1">const parallelRoutesKeys = Object.keys(parallelRoutes).filter(</span><span class="s3">\n    </span><span class="s1">(key) =&gt; key !== 'children'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// if we are at the root, we need to check the children slot first</span><span class="s3">\n  </span><span class="s1">if ('children' in parallelRoutes) {</span><span class="s3">\n    </span><span class="s1">parallelRoutesKeys.unshift('children')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const key of parallelRoutesKeys) {</span><span class="s3">\n    </span><span class="s1">const [segment, childParallelRoutes] = parallelRoutes[key]</span><span class="s3">\n    </span><span class="s1">// If the parallel is not matched and using the default segment,</span><span class="s3">\n    </span><span class="s1">// skip searching the head from it.</span><span class="s3">\n    </span><span class="s1">if (segment === DEFAULT_SEGMENT_KEY) {</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const childSegmentMap = cache.parallelRoutes.get(key)</span><span class="s3">\n    </span><span class="s1">if (!childSegmentMap) {</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const cacheKey = createRouterCacheKey(segment)</span><span class="s3">\n    </span><span class="s1">const cacheKeyWithoutSearchParams = createRouterCacheKey(segment, true)</span><span class="s3">\n\n    </span><span class="s1">const cacheNode = childSegmentMap.get(cacheKey)</span><span class="s3">\n    </span><span class="s1">if (!cacheNode) {</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const item = findHeadInCacheImpl(</span><span class="s3">\n      </span><span class="s1">cacheNode,</span><span class="s3">\n      </span><span class="s1">childParallelRoutes,</span><span class="s3">\n      </span><span class="s1">keyPrefix + '/' + cacheKey,</span><span class="s3">\n      </span><span class="s1">keyPrefix + '/' + cacheKeyWithoutSearchParams</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">if (item) {</span><span class="s3">\n      </span><span class="s1">return item</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;findHeadInCache&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;findHeadInCacheImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;keyPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;keyPrefixWithoutSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;isLastItem&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutesKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;childParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;DEFAULT_SEGMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;childSegmentMap&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;createRouterCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKeyWithoutSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;item&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAKgBA,mBAAAA;;;eAAAA;;;yBAHoB;sCACC;AAE9B,SAASA,gBACdC,KAAgB,EAChBC,cAAoC;IAEpC,OAAOC,oBAAoBF,OAAOC,gBAAgB,IAAI;AACxD;AAEA,SAASC,oBACPF,KAAgB,EAChBC,cAAoC,EACpCE,SAAiB,EACjBC,4BAAoC;IAEpC,MAAMC,aAAaC,OAAOC,IAAI,CAACN,gBAAgBO,MAAM,KAAK;IAC1D,IAAIH,YAAY;QACd,0EAA0E;QAC1E,OAAO;YAACL;YAAOG;YAAWC;SAA6B;IACzD;IAEA,uDAAuD;IACvD,+EAA+E;IAC/E,MAAMK,qBAAqBH,OAAOC,IAAI,CAACN,gBAAgBS,MAAM,CAC3D,CAACC,MAAQA,QAAQ;IAGnB,kEAAkE;IAClE,IAAI,cAAcV,gBAAgB;QAChCQ,mBAAmBG,OAAO,CAAC;IAC7B;IAEA,KAAK,MAAMD,OAAOF,mBAAoB;QACpC,MAAM,CAACI,SAASC,oBAAoB,GAAGb,cAAc,CAACU,IAAI;QAC1D,gEAAgE;QAChE,mCAAmC;QACnC,IAAIE,YAAYE,SAAAA,mBAAmB,EAAE;YACnC;QACF;QACA,MAAMC,kBAAkBhB,MAAMC,cAAc,CAACgB,GAAG,CAACN;QACjD,IAAI,CAACK,iBAAiB;YACpB;QACF;QAEA,MAAME,WAAWC,CAAAA,GAAAA,sBAAAA,oBAAoB,EAACN;QACtC,MAAMO,8BAA8BD,CAAAA,GAAAA,sBAAAA,oBAAoB,EAACN,SAAS;QAElE,MAAMQ,YAAYL,gBAAgBC,GAAG,CAACC;QACtC,IAAI,CAACG,WAAW;YACd;QACF;QAEA,MAAMC,OAAOpB,oBACXmB,WACAP,qBACAX,YAAY,MAAMe,UAClBf,YAAY,MAAMiB;QAGpB,IAAIE,MAAM;YACR,OAAOA;QACT;IACF;IAEA,OAAO;AACT&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">4708</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/unresolved-thenable.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Create a </span><span class="s3">\&quot;</span><span class="s1">Thenable</span><span class="s3">\&quot; </span><span class="s1">that does not resolve. This is used to suspend indefinitely when data is not available yet.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const unresolvedThenable = {</span><span class="s3">\n  </span><span class="s1">then: () =&gt; {},</span><span class="s3">\n</span><span class="s1">} as PromiseLike&lt;void&gt;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;unresolvedThenable&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;CAEC;;;+BACYA,sBAAAA;;;eAAAA;;;AAAN,MAAMA,qBAAqB;IAChCC,MAAM,KAAO;AACf&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">4733</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/has-base-path.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { pathHasPrefix } from '../shared/lib/router/utils/path-has-prefix'</span><span class="s3">\n\n</span><span class="s1">const basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''</span><span class="s3">\n\n</span><span class="s1">export function hasBasePath(path: string): boolean {</span><span class="s3">\n  </span><span class="s1">return pathHasPrefix(path, basePath)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;hasBasePath&quot;</span><span class="s0">,</span><span class="s1">&quot;basePath&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_ROUTER_BASEPATH&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;pathHasPrefix&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAEkBE,QAAQC,GAAG,CAACC,sBAAsB;;;;;+BAEpCJ,eAAAA;;;eAAAA;;;+BAJc;AAE9B,MAAMC,mDAA6D;AAE5D,SAASD,YAAYK,IAAY;IACtC,OAAOC,CAAAA,GAAAA,eAAAA,aAAa,EAACD,MAAMJ;AAC7B&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">4760</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/remove-base-path.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { hasBasePath } from './has-base-path'</span><span class="s3">\n\n</span><span class="s1">const basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''</span><span class="s3">\n\n</span><span class="s1">export function removeBasePath(path: string): string {</span><span class="s3">\n  </span><span class="s1">if (process.env.__NEXT_MANUAL_CLIENT_BASE_PATH) {</span><span class="s3">\n    </span><span class="s1">if (!hasBasePath(path)) {</span><span class="s3">\n      </span><span class="s1">return path</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Can't trim the basePath if it has zero length!</span><span class="s3">\n  </span><span class="s1">if (basePath.length === 0) return path</span><span class="s3">\n\n  </span><span class="s1">path = path.slice(basePath.length)</span><span class="s3">\n  </span><span class="s1">if (!path.startsWith('/')) path = `/${path}`</span><span class="s3">\n  </span><span class="s1">return path</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;removeBasePath&quot;</span><span class="s0">,</span><span class="s1">&quot;basePath&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_ROUTER_BASEPATH&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_MANUAL_CLIENT_BASE_PATH&quot;</span><span class="s0">,</span><span class="s1">&quot;hasBasePath&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAEkBE,QAAQC,GAAG,CAACC,sBAAsB;;;;;+BAEpCJ,kBAAAA;;;eAAAA;;;6BAJY;AAE5B,MAAMC,mDAA6D;AAE5D,SAASD,eAAeK,IAAY;IACzC,IAAIH,QAAQC,GAAG,CAACG,8BAA8B,EAAE;;IAMhD,iDAAiD;IACjD,IAAIL,SAASO,MAAM,KAAK,GAAG,OAAOH;IAElCA,OAAOA,KAAKI,KAAK,CAACR,SAASO,MAAM;IACjC,IAAI,CAACH,KAAKK,UAAU,CAAC,MAAML,OAAQ,MAAGA;IACtC,OAAOA;AACT&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">4793</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/segment-cache.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Entry point to the Segment Cache implementation.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* All code related to the Segment Cache lives `segment-cache-impl` directory.</span><span class="s3">\n </span><span class="s1">* Callers access it through this indirection.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This is to ensure the code is dead code eliminated from the bundle if the</span><span class="s3">\n </span><span class="s1">* flag is disabled.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* TODO: This is super tedious. Since experimental flags are an essential part</span><span class="s3">\n </span><span class="s1">* of our workflow, we should establish a better pattern for dead code</span><span class="s3">\n </span><span class="s1">* elimination. Ideally it would be done at the bundler level, like how React's</span><span class="s3">\n </span><span class="s1">* build process works. In the React repo, you don't even need to add any extra</span><span class="s3">\n </span><span class="s1">* configuration per experiment  if the code is not reachable, it gets stripped</span><span class="s3">\n </span><span class="s1">* from the build automatically by Rollup. Or, shorter term, we could stub out</span><span class="s3">\n </span><span class="s1">* experimental modules at build time by updating the build config, i.e. a more</span><span class="s3">\n </span><span class="s1">* automated version of what I'm doing manually in this file.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export type { NavigationResult } from './segment-cache-impl/navigation'</span><span class="s3">\n</span><span class="s1">export type { PrefetchTask } from './segment-cache-impl/scheduler'</span><span class="s3">\n</span><span class="s1">export type { NormalizedSearch } from './segment-cache-impl/cache-key'</span><span class="s3">\n\n</span><span class="s1">const notEnabled: any = () =&gt; {</span><span class="s3">\n  </span><span class="s1">throw new Error(</span><span class="s3">\n    </span><span class="s1">'Segment Cache experiment is not enabled. This is a bug in Next.js.'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const prefetch: typeof import('./segment-cache-impl/prefetch').prefetch =</span><span class="s3">\n  </span><span class="s1">process.env.__NEXT_CLIENT_SEGMENT_CACHE</span><span class="s3">\n    </span><span class="s1">? function (...args) {</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">require('./segment-cache-impl/prefetch') as typeof import('./segment-cache-impl/prefetch')</span><span class="s3">\n        </span><span class="s1">).prefetch(...args)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">: notEnabled</span><span class="s3">\n\n</span><span class="s1">export const navigate: typeof import('./segment-cache-impl/navigation').navigate =</span><span class="s3">\n  </span><span class="s1">process.env.__NEXT_CLIENT_SEGMENT_CACHE</span><span class="s3">\n    </span><span class="s1">? function (...args) {</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">require('./segment-cache-impl/navigation') as typeof import('./segment-cache-impl/navigation')</span><span class="s3">\n        </span><span class="s1">).navigate(...args)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">: notEnabled</span><span class="s3">\n\n</span><span class="s1">export const revalidateEntireCache: typeof import('./segment-cache-impl/cache').revalidateEntireCache =</span><span class="s3">\n  </span><span class="s1">process.env.__NEXT_CLIENT_SEGMENT_CACHE</span><span class="s3">\n    </span><span class="s1">? function (...args) {</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">require('./segment-cache-impl/cache') as typeof import('./segment-cache-impl/cache')</span><span class="s3">\n        </span><span class="s1">).revalidateEntireCache(...args)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">: notEnabled</span><span class="s3">\n\n</span><span class="s1">export const getCurrentCacheVersion: typeof import('./segment-cache-impl/cache').getCurrentCacheVersion =</span><span class="s3">\n  </span><span class="s1">process.env.__NEXT_CLIENT_SEGMENT_CACHE</span><span class="s3">\n    </span><span class="s1">? function (...args) {</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">require('./segment-cache-impl/cache') as typeof import('./segment-cache-impl/cache')</span><span class="s3">\n        </span><span class="s1">).getCurrentCacheVersion(...args)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">: notEnabled</span><span class="s3">\n\n</span><span class="s1">export const schedulePrefetchTask: typeof import('./segment-cache-impl/scheduler').schedulePrefetchTask =</span><span class="s3">\n  </span><span class="s1">process.env.__NEXT_CLIENT_SEGMENT_CACHE</span><span class="s3">\n    </span><span class="s1">? function (...args) {</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">require('./segment-cache-impl/scheduler') as typeof import('./segment-cache-impl/scheduler')</span><span class="s3">\n        </span><span class="s1">).schedulePrefetchTask(...args)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">: notEnabled</span><span class="s3">\n\n</span><span class="s1">export const cancelPrefetchTask: typeof import('./segment-cache-impl/scheduler').cancelPrefetchTask =</span><span class="s3">\n  </span><span class="s1">process.env.__NEXT_CLIENT_SEGMENT_CACHE</span><span class="s3">\n    </span><span class="s1">? function (...args) {</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">require('./segment-cache-impl/scheduler') as typeof import('./segment-cache-impl/scheduler')</span><span class="s3">\n        </span><span class="s1">).cancelPrefetchTask(...args)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">: notEnabled</span><span class="s3">\n\n</span><span class="s1">export const reschedulePrefetchTask: typeof import('./segment-cache-impl/scheduler').reschedulePrefetchTask =</span><span class="s3">\n  </span><span class="s1">process.env.__NEXT_CLIENT_SEGMENT_CACHE</span><span class="s3">\n    </span><span class="s1">? function (...args) {</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">require('./segment-cache-impl/scheduler') as typeof import('./segment-cache-impl/scheduler')</span><span class="s3">\n        </span><span class="s1">).reschedulePrefetchTask(...args)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">: notEnabled</span><span class="s3">\n\n</span><span class="s1">export const isPrefetchTaskDirty: typeof import('./segment-cache-impl/scheduler').isPrefetchTaskDirty =</span><span class="s3">\n  </span><span class="s1">process.env.__NEXT_CLIENT_SEGMENT_CACHE</span><span class="s3">\n    </span><span class="s1">? function (...args) {</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">require('./segment-cache-impl/scheduler') as typeof import('./segment-cache-impl/scheduler')</span><span class="s3">\n        </span><span class="s1">).isPrefetchTaskDirty(...args)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">: notEnabled</span><span class="s3">\n\n</span><span class="s1">export const createCacheKey: typeof import('./segment-cache-impl/cache-key').createCacheKey =</span><span class="s3">\n  </span><span class="s1">process.env.__NEXT_CLIENT_SEGMENT_CACHE</span><span class="s3">\n    </span><span class="s1">? function (...args) {</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">require('./segment-cache-impl/cache-key') as typeof import('./segment-cache-impl/cache-key')</span><span class="s3">\n        </span><span class="s1">).createCacheKey(...args)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">: notEnabled</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Below are public constants. They're small enough that we don't need to</span><span class="s3">\n </span><span class="s1">* DCE them.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export const enum NavigationResultTag {</span><span class="s3">\n  </span><span class="s1">MPA,</span><span class="s3">\n  </span><span class="s1">Success,</span><span class="s3">\n  </span><span class="s1">NoOp,</span><span class="s3">\n  </span><span class="s1">Async,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The priority of the prefetch task. Higher numbers are higher priority.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const enum PrefetchPriority {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Assigned to the most recently hovered/touched link. Special network</span><span class="s3">\n   </span><span class="s1">* bandwidth is reserved for this task only. There's only ever one Intent-</span><span class="s3">\n   </span><span class="s1">* priority task at a time; when a new Intent task is scheduled, the previous</span><span class="s3">\n   </span><span class="s1">* one is bumped down to Default.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">Intent = 2,</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The default priority for prefetch tasks.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">Default = 1,</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Assigned to tasks when they spawn non-blocking background work, like</span><span class="s3">\n   </span><span class="s1">* revalidating a partially cached entry to see if more data is available.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">Background = 0,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const enum FetchStrategy {</span><span class="s3">\n  </span><span class="s1">// Deliberately ordered so we can easily compare two segments</span><span class="s3">\n  </span><span class="s1">// and determine if one segment is </span><span class="s3">\&quot;</span><span class="s1">more specific</span><span class="s3">\&quot; </span><span class="s1">than another</span><span class="s3">\n  </span><span class="s1">// (i.e. if it's likely that it contains more data)</span><span class="s3">\n  </span><span class="s1">LoadingBoundary = 0,</span><span class="s3">\n  </span><span class="s1">PPR = 1,</span><span class="s3">\n  </span><span class="s1">PPRRuntime = 2,</span><span class="s3">\n  </span><span class="s1">Full = 3,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A subset of fetch strategies used for prefetch tasks.</span><span class="s3">\n </span><span class="s1">* A prefetch task can't know if it should use `PPR` or `LoadingBoundary`</span><span class="s3">\n </span><span class="s1">* until we complete the initial tree prefetch request, so we use `PPR` to signal both cases</span><span class="s3">\n </span><span class="s1">* and adjust it based on the route when actually fetching.</span><span class="s3">\n </span><span class="s1">* */</span><span class="s3">\n</span><span class="s1">export type PrefetchTaskFetchStrategy =</span><span class="s3">\n  </span><span class="s1">| FetchStrategy.PPR</span><span class="s3">\n  </span><span class="s1">| FetchStrategy.PPRRuntime</span><span class="s3">\n  </span><span class="s1">| FetchStrategy.Full</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;FetchStrategy&quot;</span><span class="s0">,</span><span class="s1">&quot;NavigationResultTag&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchPriority&quot;</span><span class="s0">,</span><span class="s1">&quot;cancelPrefetchTask&quot;</span><span class="s0">,</span><span class="s1">&quot;createCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;getCurrentCacheVersion&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrefetchTaskDirty&quot;</span><span class="s0">,</span><span class="s1">&quot;navigate&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;reschedulePrefetchTask&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateEntireCache&quot;</span><span class="s0">,</span><span class="s1">&quot;schedulePrefetchTask&quot;</span><span class="s0">,</span><span class="s1">&quot;notEnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CLIENT_SEGMENT_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;;;;;;;;;;;;;;;;CAiBC,GAaCc,QAAQC,GAAG,CAACC,2BAA2B;AAbxC;;;;;;;;;;;;;;;;;;;;;;;;;IA+HiBhB,aAAa,EAAA;eAAbA;;IA7BAC,mBAAmB,EAAA;eAAnBA;;IAUAC,gBAAgB,EAAA;eAAhBA;;IAnDLC,kBAAkB,EAAA;eAAlBA;;IA2BAC,cAAc,EAAA;eAAdA;;IA7CAC,sBAAsB,EAAA;eAAtBA;;IAoCAC,mBAAmB,EAAA;eAAnBA;;IAtDAC,QAAQ,EAAA;eAARA;;IATAC,QAAQ,EAAA;eAARA;;IAsDAC,sBAAsB,EAAA;eAAtBA;;IApCAC,qBAAqB,EAAA;eAArBA;;IAkBAC,oBAAoB,EAAA;eAApBA;;;AA1Cb,MAAMC,aAAkB;IACtB,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,uEADI,qBAAA;eAAA;oBAAA;sBAAA;IAEN;AACF;AAEO,MAAML,iDAEP,0BAKAI;AAEC,MAAML,WACXO,QAAQC,GAAG,CAACC,0BACR,CADmC,yBAMnCJ;AAEC,MAAMF,wBACXI,QAAQC,GAAG,CAACC,0BACR,CADmC,yBAMnCJ;AAEC,MAAMP,yBACXS,QAAQC,GAAG,CAACC,0BACR,CADmC,yBAMnCJ;AAEC,MAAMD,uBACXG,QAAQC,GAAG,CAACC,0BACR,CADmC,yBAMnCJ;AAEC,MAAMT,qBACXW,QAAQC,GAAG,CAACC,0BACR,CADmC,yBAMnCJ;AAEC,MAAMH,yBACXK,QAAQC,GAAG,CAACC,0BACR,CADmC,yBAMnCJ;AAEC,MAAMN,sBACXQ,QAAQC,GAAG,CAACC,0BACR,CADmC,yBAMnCJ;AAEC,MAAMR,iBACXU,QAAQC,GAAG,CAACC,0BACR,CADmC,yBAMnCJ;AAOC,IAAWX,sBAAAA,WAAAA,GAAAA,SAAAA,mBAAAA;;;;;WAAAA;;AAUX,IAAWC,mBAAAA,WAAAA,GAAAA,SAAAA,gBAAAA;IAChB;;;;;GAKC,GAAA,gBAAA,CAAA,gBAAA,CAAA,SAAA,GAAA,EAAA,GAAA;IAED;;GAEC,GAAA,gBAAA,CAAA,gBAAA,CAAA,UAAA,GAAA,EAAA,GAAA;IAED;;;GAGC,GAAA,gBAAA,CAAA,gBAAA,CAAA,aAAA,GAAA,EAAA,GAAA;WAfeA;;AAmBX,IAAWF,gBAAAA,WAAAA,GAAAA,SAAAA,aAAAA;IAChB,6DAA6D;IAC7D,+DAA+D;IAC/D,mDAAmD;;;;;WAHnCA&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">4933</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/links.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { FlightRouterState } from '../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { getCurrentAppRouterState } from './app-router-instance'</span><span class="s3">\n</span><span class="s1">import { createPrefetchURL } from './app-router'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">FetchStrategy,</span><span class="s3">\n  </span><span class="s1">isPrefetchTaskDirty,</span><span class="s3">\n  </span><span class="s1">type PrefetchTaskFetchStrategy,</span><span class="s3">\n</span><span class="s1">} from './segment-cache'</span><span class="s3">\n</span><span class="s1">import { createCacheKey } from './segment-cache'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">type PrefetchTask,</span><span class="s3">\n  </span><span class="s1">PrefetchPriority,</span><span class="s3">\n  </span><span class="s1">schedulePrefetchTask as scheduleSegmentPrefetchTask,</span><span class="s3">\n  </span><span class="s1">cancelPrefetchTask,</span><span class="s3">\n  </span><span class="s1">reschedulePrefetchTask,</span><span class="s3">\n</span><span class="s1">} from './segment-cache'</span><span class="s3">\n</span><span class="s1">import { startTransition } from 'react'</span><span class="s3">\n</span><span class="s1">import { PrefetchKind } from './router-reducer/router-reducer-types'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../../shared/lib/invariant-error'</span><span class="s3">\n\n</span><span class="s1">type LinkElement = HTMLAnchorElement | SVGAElement</span><span class="s3">\n\n</span><span class="s1">type Element = LinkElement | HTMLFormElement</span><span class="s3">\n\n</span><span class="s1">// Properties that are shared between Link and Form instances. We use the same</span><span class="s3">\n</span><span class="s1">// shape for both to prevent a polymorphic de-opt in the VM.</span><span class="s3">\n</span><span class="s1">type LinkOrFormInstanceShared = {</span><span class="s3">\n  </span><span class="s1">router: AppRouterInstance</span><span class="s3">\n  </span><span class="s1">fetchStrategy: PrefetchTaskFetchStrategy</span><span class="s3">\n\n  </span><span class="s1">isVisible: boolean</span><span class="s3">\n\n  </span><span class="s1">// The most recently initiated prefetch task. It may or may not have</span><span class="s3">\n  </span><span class="s1">// already completed. The same prefetch task object can be reused across</span><span class="s3">\n  </span><span class="s1">// multiple prefetches of the same link.</span><span class="s3">\n  </span><span class="s1">prefetchTask: PrefetchTask | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type FormInstance = LinkOrFormInstanceShared &amp; {</span><span class="s3">\n  </span><span class="s1">prefetchHref: string</span><span class="s3">\n  </span><span class="s1">setOptimisticLinkStatus: null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type PrefetchableLinkInstance = LinkOrFormInstanceShared &amp; {</span><span class="s3">\n  </span><span class="s1">prefetchHref: string</span><span class="s3">\n  </span><span class="s1">setOptimisticLinkStatus: (status: { pending: boolean }) =&gt; void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type NonPrefetchableLinkInstance = LinkOrFormInstanceShared &amp; {</span><span class="s3">\n  </span><span class="s1">prefetchHref: null</span><span class="s3">\n  </span><span class="s1">setOptimisticLinkStatus: (status: { pending: boolean }) =&gt; void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type PrefetchableInstance = PrefetchableLinkInstance | FormInstance</span><span class="s3">\n\n</span><span class="s1">export type LinkInstance =</span><span class="s3">\n  </span><span class="s1">| PrefetchableLinkInstance</span><span class="s3">\n  </span><span class="s1">| NonPrefetchableLinkInstance</span><span class="s3">\n\n</span><span class="s1">// Tracks the most recently navigated link instance. When null, indicates</span><span class="s3">\n</span><span class="s1">// the current navigation was not initiated by a link click.</span><span class="s3">\n</span><span class="s1">let linkForMostRecentNavigation: LinkInstance | null = null</span><span class="s3">\n\n</span><span class="s1">// Status object indicating link is pending</span><span class="s3">\n</span><span class="s1">export const PENDING_LINK_STATUS = { pending: true }</span><span class="s3">\n\n</span><span class="s1">// Status object indicating link is idle</span><span class="s3">\n</span><span class="s1">export const IDLE_LINK_STATUS = { pending: false }</span><span class="s3">\n\n</span><span class="s1">// Updates the loading state when navigating between links</span><span class="s3">\n</span><span class="s1">// - Resets the previous link's loading state</span><span class="s3">\n</span><span class="s1">// - Sets the new link's loading state</span><span class="s3">\n</span><span class="s1">// - Updates tracking of current navigation</span><span class="s3">\n</span><span class="s1">export function setLinkForCurrentNavigation(link: LinkInstance | null) {</span><span class="s3">\n  </span><span class="s1">startTransition(() =&gt; {</span><span class="s3">\n    </span><span class="s1">linkForMostRecentNavigation?.setOptimisticLinkStatus(IDLE_LINK_STATUS)</span><span class="s3">\n    </span><span class="s1">link?.setOptimisticLinkStatus(PENDING_LINK_STATUS)</span><span class="s3">\n    </span><span class="s1">linkForMostRecentNavigation = link</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Unmounts the current link instance from navigation tracking</span><span class="s3">\n</span><span class="s1">export function unmountLinkForCurrentNavigation(link: LinkInstance) {</span><span class="s3">\n  </span><span class="s1">if (linkForMostRecentNavigation === link) {</span><span class="s3">\n    </span><span class="s1">linkForMostRecentNavigation = null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Use a WeakMap to associate a Link instance with its DOM element. This is</span><span class="s3">\n</span><span class="s1">// used by the IntersectionObserver to track the link's visibility.</span><span class="s3">\n</span><span class="s1">const prefetchable:</span><span class="s3">\n  </span><span class="s1">| WeakMap&lt;Element, PrefetchableInstance&gt;</span><span class="s3">\n  </span><span class="s1">| Map&lt;Element, PrefetchableInstance&gt; =</span><span class="s3">\n  </span><span class="s1">typeof WeakMap === 'function' ? new WeakMap() : new Map()</span><span class="s3">\n\n</span><span class="s1">// A Set of the currently visible links. We re-prefetch visible links after a</span><span class="s3">\n</span><span class="s1">// cache invalidation, or when the current URL changes. It's a separate data</span><span class="s3">\n</span><span class="s1">// structure from the WeakMap above because only the visible links need to</span><span class="s3">\n</span><span class="s1">// be enumerated.</span><span class="s3">\n</span><span class="s1">const prefetchableAndVisible: Set&lt;PrefetchableInstance&gt; = new Set()</span><span class="s3">\n\n</span><span class="s1">// A single IntersectionObserver instance shared by all &lt;Link&gt; components.</span><span class="s3">\n</span><span class="s1">const observer: IntersectionObserver | null =</span><span class="s3">\n  </span><span class="s1">typeof IntersectionObserver === 'function'</span><span class="s3">\n    </span><span class="s1">? new IntersectionObserver(handleIntersect, {</span><span class="s3">\n        </span><span class="s1">rootMargin: '200px',</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">: null</span><span class="s3">\n\n</span><span class="s1">function observeVisibility(element: Element, instance: PrefetchableInstance) {</span><span class="s3">\n  </span><span class="s1">const existingInstance = prefetchable.get(element)</span><span class="s3">\n  </span><span class="s1">if (existingInstance !== undefined) {</span><span class="s3">\n    </span><span class="s1">// This shouldn't happen because each &lt;Link&gt; component should have its own</span><span class="s3">\n    </span><span class="s1">// anchor tag instance, but it's defensive coding to avoid a memory leak in</span><span class="s3">\n    </span><span class="s1">// case there's a logical error somewhere else.</span><span class="s3">\n    </span><span class="s1">unmountPrefetchableInstance(element)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Only track prefetchable links that have a valid prefetch URL</span><span class="s3">\n  </span><span class="s1">prefetchable.set(element, instance)</span><span class="s3">\n  </span><span class="s1">if (observer !== null) {</span><span class="s3">\n    </span><span class="s1">observer.observe(element)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function coercePrefetchableUrl(href: string): URL | null {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return createPrefetchURL(href)</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">// createPrefetchURL sometimes throws an error if an invalid URL is</span><span class="s3">\n    </span><span class="s1">// provided, though I'm not sure if it's actually necessary.</span><span class="s3">\n    </span><span class="s1">// TODO: Consider removing the throw from the inner function, or change it</span><span class="s3">\n    </span><span class="s1">// to reportError. Or maybe the error isn't even necessary for automatic</span><span class="s3">\n    </span><span class="s1">// prefetches, just navigations.</span><span class="s3">\n    </span><span class="s1">const reportErrorFn =</span><span class="s3">\n      </span><span class="s1">typeof reportError === 'function' ? reportError : console.error</span><span class="s3">\n    </span><span class="s1">reportErrorFn(</span><span class="s3">\n      </span><span class="s1">`Cannot prefetch '${href}' because it cannot be converted to a URL.`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function mountLinkInstance(</span><span class="s3">\n  </span><span class="s1">element: LinkElement,</span><span class="s3">\n  </span><span class="s1">href: string,</span><span class="s3">\n  </span><span class="s1">router: AppRouterInstance,</span><span class="s3">\n  </span><span class="s1">fetchStrategy: PrefetchTaskFetchStrategy,</span><span class="s3">\n  </span><span class="s1">prefetchEnabled: boolean,</span><span class="s3">\n  </span><span class="s1">setOptimisticLinkStatus: (status: { pending: boolean }) =&gt; void</span><span class="s3">\n</span><span class="s1">): LinkInstance {</span><span class="s3">\n  </span><span class="s1">if (prefetchEnabled) {</span><span class="s3">\n    </span><span class="s1">const prefetchURL = coercePrefetchableUrl(href)</span><span class="s3">\n    </span><span class="s1">if (prefetchURL !== null) {</span><span class="s3">\n      </span><span class="s1">const instance: PrefetchableLinkInstance = {</span><span class="s3">\n        </span><span class="s1">router,</span><span class="s3">\n        </span><span class="s1">fetchStrategy,</span><span class="s3">\n        </span><span class="s1">isVisible: false,</span><span class="s3">\n        </span><span class="s1">prefetchTask: null,</span><span class="s3">\n        </span><span class="s1">prefetchHref: prefetchURL.href,</span><span class="s3">\n        </span><span class="s1">setOptimisticLinkStatus,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// We only observe the link's visibility if it's prefetchable. For</span><span class="s3">\n      </span><span class="s1">// example, this excludes links to external URLs.</span><span class="s3">\n      </span><span class="s1">observeVisibility(element, instance)</span><span class="s3">\n      </span><span class="s1">return instance</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// If the link is not prefetchable, we still create an instance so we can</span><span class="s3">\n  </span><span class="s1">// track its optimistic state (i.e. useLinkStatus).</span><span class="s3">\n  </span><span class="s1">const instance: NonPrefetchableLinkInstance = {</span><span class="s3">\n    </span><span class="s1">router,</span><span class="s3">\n    </span><span class="s1">fetchStrategy,</span><span class="s3">\n    </span><span class="s1">isVisible: false,</span><span class="s3">\n    </span><span class="s1">prefetchTask: null,</span><span class="s3">\n    </span><span class="s1">prefetchHref: null,</span><span class="s3">\n    </span><span class="s1">setOptimisticLinkStatus,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return instance</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function mountFormInstance(</span><span class="s3">\n  </span><span class="s1">element: HTMLFormElement,</span><span class="s3">\n  </span><span class="s1">href: string,</span><span class="s3">\n  </span><span class="s1">router: AppRouterInstance,</span><span class="s3">\n  </span><span class="s1">fetchStrategy: PrefetchTaskFetchStrategy</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const prefetchURL = coercePrefetchableUrl(href)</span><span class="s3">\n  </span><span class="s1">if (prefetchURL === null) {</span><span class="s3">\n    </span><span class="s1">// This href is not prefetchable, so we don't track it.</span><span class="s3">\n    </span><span class="s1">// TODO: We currently observe/unobserve a form every time its href changes.</span><span class="s3">\n    </span><span class="s1">// For Links, this isn't a big deal because the href doesn't usually change,</span><span class="s3">\n    </span><span class="s1">// but for forms it's extremely common. We should optimize this.</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const instance: FormInstance = {</span><span class="s3">\n    </span><span class="s1">router,</span><span class="s3">\n    </span><span class="s1">fetchStrategy,</span><span class="s3">\n    </span><span class="s1">isVisible: false,</span><span class="s3">\n    </span><span class="s1">prefetchTask: null,</span><span class="s3">\n    </span><span class="s1">prefetchHref: prefetchURL.href,</span><span class="s3">\n    </span><span class="s1">setOptimisticLinkStatus: null,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">observeVisibility(element, instance)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function unmountPrefetchableInstance(element: Element) {</span><span class="s3">\n  </span><span class="s1">const instance = prefetchable.get(element)</span><span class="s3">\n  </span><span class="s1">if (instance !== undefined) {</span><span class="s3">\n    </span><span class="s1">prefetchable.delete(element)</span><span class="s3">\n    </span><span class="s1">prefetchableAndVisible.delete(instance)</span><span class="s3">\n    </span><span class="s1">const prefetchTask = instance.prefetchTask</span><span class="s3">\n    </span><span class="s1">if (prefetchTask !== null) {</span><span class="s3">\n      </span><span class="s1">cancelPrefetchTask(prefetchTask)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (observer !== null) {</span><span class="s3">\n    </span><span class="s1">observer.unobserve(element)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function handleIntersect(entries: Array&lt;IntersectionObserverEntry&gt;) {</span><span class="s3">\n  </span><span class="s1">for (const entry of entries) {</span><span class="s3">\n    </span><span class="s1">// Some extremely old browsers or polyfills don't reliably support</span><span class="s3">\n    </span><span class="s1">// isIntersecting so we check intersectionRatio instead. (Do we care? Not</span><span class="s3">\n    </span><span class="s1">// really. But whatever this is fine.)</span><span class="s3">\n    </span><span class="s1">const isVisible = entry.intersectionRatio &gt; 0</span><span class="s3">\n    </span><span class="s1">onLinkVisibilityChanged(entry.target as HTMLAnchorElement, isVisible)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function onLinkVisibilityChanged(element: Element, isVisible: boolean) {</span><span class="s3">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n    </span><span class="s1">// Prefetching on viewport is disabled in development for performance</span><span class="s3">\n    </span><span class="s1">// reasons, because it requires compiling the target page.</span><span class="s3">\n    </span><span class="s1">// TODO: Investigate re-enabling this.</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const instance = prefetchable.get(element)</span><span class="s3">\n  </span><span class="s1">if (instance === undefined) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">instance.isVisible = isVisible</span><span class="s3">\n  </span><span class="s1">if (isVisible) {</span><span class="s3">\n    </span><span class="s1">prefetchableAndVisible.add(instance)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">prefetchableAndVisible.delete(instance)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">rescheduleLinkPrefetch(instance, PrefetchPriority.Default)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function onNavigationIntent(</span><span class="s3">\n  </span><span class="s1">element: HTMLAnchorElement | SVGAElement,</span><span class="s3">\n  </span><span class="s1">unstable_upgradeToDynamicPrefetch: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const instance = prefetchable.get(element)</span><span class="s3">\n  </span><span class="s1">if (instance === undefined) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Prefetch the link on hover/touchstart.</span><span class="s3">\n  </span><span class="s1">if (instance !== undefined) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">process.env.__NEXT_DYNAMIC_ON_HOVER &amp;&amp;</span><span class="s3">\n      </span><span class="s1">unstable_upgradeToDynamicPrefetch</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// Switch to a full prefetch</span><span class="s3">\n      </span><span class="s1">instance.fetchStrategy = FetchStrategy.Full</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">rescheduleLinkPrefetch(instance, PrefetchPriority.Intent)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function rescheduleLinkPrefetch(</span><span class="s3">\n  </span><span class="s1">instance: PrefetchableInstance,</span><span class="s3">\n  </span><span class="s1">priority: PrefetchPriority.Default | PrefetchPriority.Intent</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const existingPrefetchTask = instance.prefetchTask</span><span class="s3">\n\n  </span><span class="s1">if (!instance.isVisible) {</span><span class="s3">\n    </span><span class="s1">// Cancel any in-progress prefetch task. (If it already finished then this</span><span class="s3">\n    </span><span class="s1">// is a no-op.)</span><span class="s3">\n    </span><span class="s1">if (existingPrefetchTask !== null) {</span><span class="s3">\n      </span><span class="s1">cancelPrefetchTask(existingPrefetchTask)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// We don't need to reset the prefetchTask to null upon cancellation; an</span><span class="s3">\n    </span><span class="s1">// old task object can be rescheduled with reschedulePrefetchTask. This is a</span><span class="s3">\n    </span><span class="s1">// micro-optimization but also makes the code simpler (don't need to</span><span class="s3">\n    </span><span class="s1">// worry about whether an old task object is stale).</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!process.env.__NEXT_CLIENT_SEGMENT_CACHE) {</span><span class="s3">\n    </span><span class="s1">// The old prefetch implementation does not have different priority levels.</span><span class="s3">\n    </span><span class="s1">// Just schedule a new prefetch task.</span><span class="s3">\n    </span><span class="s1">prefetchWithOldCacheImplementation(instance)</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const appRouterState = getCurrentAppRouterState()</span><span class="s3">\n  </span><span class="s1">if (appRouterState !== null) {</span><span class="s3">\n    </span><span class="s1">const treeAtTimeOfPrefetch = appRouterState.tree</span><span class="s3">\n    </span><span class="s1">if (existingPrefetchTask === null) {</span><span class="s3">\n      </span><span class="s1">// Initiate a prefetch task.</span><span class="s3">\n      </span><span class="s1">const nextUrl = appRouterState.nextUrl</span><span class="s3">\n      </span><span class="s1">const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)</span><span class="s3">\n      </span><span class="s1">instance.prefetchTask = scheduleSegmentPrefetchTask(</span><span class="s3">\n        </span><span class="s1">cacheKey,</span><span class="s3">\n        </span><span class="s1">treeAtTimeOfPrefetch,</span><span class="s3">\n        </span><span class="s1">instance.fetchStrategy,</span><span class="s3">\n        </span><span class="s1">priority,</span><span class="s3">\n        </span><span class="s1">null</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// We already have an old task object that we can reschedule. This is</span><span class="s3">\n      </span><span class="s1">// effectively the same as canceling the old task and creating a new one.</span><span class="s3">\n      </span><span class="s1">reschedulePrefetchTask(</span><span class="s3">\n        </span><span class="s1">existingPrefetchTask,</span><span class="s3">\n        </span><span class="s1">treeAtTimeOfPrefetch,</span><span class="s3">\n        </span><span class="s1">instance.fetchStrategy,</span><span class="s3">\n        </span><span class="s1">priority</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function pingVisibleLinks(</span><span class="s3">\n  </span><span class="s1">nextUrl: string | null,</span><span class="s3">\n  </span><span class="s1">tree: FlightRouterState</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// For each currently visible link, cancel the existing prefetch task (if it</span><span class="s3">\n  </span><span class="s1">// exists) and schedule a new one. This is effectively the same as if all the</span><span class="s3">\n  </span><span class="s1">// visible links left and then re-entered the viewport.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// This is called when the Next-Url or the base tree changes, since those</span><span class="s3">\n  </span><span class="s1">// may affect the result of a prefetch task. It's also called after a</span><span class="s3">\n  </span><span class="s1">// cache invalidation.</span><span class="s3">\n  </span><span class="s1">for (const instance of prefetchableAndVisible) {</span><span class="s3">\n    </span><span class="s1">const task = instance.prefetchTask</span><span class="s3">\n    </span><span class="s1">if (task !== null &amp;&amp; !isPrefetchTaskDirty(task, nextUrl, tree)) {</span><span class="s3">\n      </span><span class="s1">// The cache has not been invalidated, and none of the inputs have</span><span class="s3">\n      </span><span class="s1">// changed. Bail out.</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Something changed. Cancel the existing prefetch task and schedule a</span><span class="s3">\n    </span><span class="s1">// new one.</span><span class="s3">\n    </span><span class="s1">if (task !== null) {</span><span class="s3">\n      </span><span class="s1">cancelPrefetchTask(task)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)</span><span class="s3">\n    </span><span class="s1">instance.prefetchTask = scheduleSegmentPrefetchTask(</span><span class="s3">\n      </span><span class="s1">cacheKey,</span><span class="s3">\n      </span><span class="s1">tree,</span><span class="s3">\n      </span><span class="s1">instance.fetchStrategy,</span><span class="s3">\n      </span><span class="s1">PrefetchPriority.Default,</span><span class="s3">\n      </span><span class="s1">null</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function prefetchWithOldCacheImplementation(instance: PrefetchableInstance) {</span><span class="s3">\n  </span><span class="s1">// This is the path used when the Segment Cache is not enabled.</span><span class="s3">\n  </span><span class="s1">if (typeof window === 'undefined') {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const doPrefetch = async () =&gt; {</span><span class="s3">\n    </span><span class="s1">// note that `appRouter.prefetch()` is currently sync,</span><span class="s3">\n    </span><span class="s1">// so we have to wrap this call in an async function to be able to catch() errors below.</span><span class="s3">\n\n    </span><span class="s1">let prefetchKind: PrefetchKind</span><span class="s3">\n    </span><span class="s1">switch (instance.fetchStrategy) {</span><span class="s3">\n      </span><span class="s1">case FetchStrategy.PPR: {</span><span class="s3">\n        </span><span class="s1">prefetchKind = PrefetchKind.AUTO</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case FetchStrategy.Full: {</span><span class="s3">\n        </span><span class="s1">prefetchKind = PrefetchKind.FULL</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case FetchStrategy.PPRRuntime: {</span><span class="s3">\n        </span><span class="s1">// We can only get here if Client Segment Cache is off, and in that case</span><span class="s3">\n        </span><span class="s1">// it shouldn't be possible for a link to request a runtime prefetch.</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">'FetchStrategy.PPRRuntime should never be used when `experimental.clientSegmentCache` is disabled'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">default: {</span><span class="s3">\n        </span><span class="s1">instance.fetchStrategy satisfies never</span><span class="s3">\n        </span><span class="s1">// Unreachable, but otherwise typescript will consider the variable unassigned</span><span class="s3">\n        </span><span class="s1">prefetchKind = undefined!</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return instance.router.prefetch(instance.prefetchHref, {</span><span class="s3">\n      </span><span class="s1">kind: prefetchKind,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Prefetch the page if asked (only in the client)</span><span class="s3">\n  </span><span class="s1">// We need to handle a prefetch error here since we may be</span><span class="s3">\n  </span><span class="s1">// loading with priority which can reject but we don't</span><span class="s3">\n  </span><span class="s1">// want to force navigation since this is only a prefetch</span><span class="s3">\n  </span><span class="s1">doPrefetch().catch((err) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n      </span><span class="s1">// rethrow to show invalid URL errors</span><span class="s3">\n      </span><span class="s1">throw err</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;IDLE_LINK_STATUS&quot;</span><span class="s0">,</span><span class="s1">&quot;PENDING_LINK_STATUS&quot;</span><span class="s0">,</span><span class="s1">&quot;mountFormInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;mountLinkInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;onLinkVisibilityChanged&quot;</span><span class="s0">,</span><span class="s1">&quot;onNavigationIntent&quot;</span><span class="s0">,</span><span class="s1">&quot;pingVisibleLinks&quot;</span><span class="s0">,</span><span class="s1">&quot;setLinkForCurrentNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;unmountLinkForCurrentNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;unmountPrefetchableInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;linkForMostRecentNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;pending&quot;</span><span class="s0">,</span><span class="s1">&quot;link&quot;</span><span class="s0">,</span><span class="s1">&quot;startTransition&quot;</span><span class="s0">,</span><span class="s1">&quot;setOptimisticLinkStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchable&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakMap&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchableAndVisible&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;observer&quot;</span><span class="s0">,</span><span class="s1">&quot;IntersectionObserver&quot;</span><span class="s0">,</span><span class="s1">&quot;handleIntersect&quot;</span><span class="s0">,</span><span class="s1">&quot;rootMargin&quot;</span><span class="s0">,</span><span class="s1">&quot;observeVisibility&quot;</span><span class="s0">,</span><span class="s1">&quot;element&quot;</span><span class="s0">,</span><span class="s1">&quot;instance&quot;</span><span class="s0">,</span><span class="s1">&quot;existingInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;observe&quot;</span><span class="s0">,</span><span class="s1">&quot;coercePrefetchableUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;createPrefetchURL&quot;</span><span class="s0">,</span><span class="s1">&quot;reportErrorFn&quot;</span><span class="s0">,</span><span class="s1">&quot;reportError&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;router&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchStrategy&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchEnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchURL&quot;</span><span class="s0">,</span><span class="s1">&quot;isVisible&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchTask&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchHref&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;cancelPrefetchTask&quot;</span><span class="s0">,</span><span class="s1">&quot;unobserve&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;entry&quot;</span><span class="s0">,</span><span class="s1">&quot;intersectionRatio&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;rescheduleLinkPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchPriority&quot;</span><span class="s0">,</span><span class="s1">&quot;Default&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_upgradeToDynamicPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_DYNAMIC_ON_HOVER&quot;</span><span class="s0">,</span><span class="s1">&quot;FetchStrategy&quot;</span><span class="s0">,</span><span class="s1">&quot;Full&quot;</span><span class="s0">,</span><span class="s1">&quot;Intent&quot;</span><span class="s0">,</span><span class="s1">&quot;priority&quot;</span><span class="s0">,</span><span class="s1">&quot;existingPrefetchTask&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CLIENT_SEGMENT_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchWithOldCacheImplementation&quot;</span><span class="s0">,</span><span class="s1">&quot;appRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;getCurrentAppRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;treeAtTimeOfPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;createCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;scheduleSegmentPrefetchTask&quot;</span><span class="s0">,</span><span class="s1">&quot;reschedulePrefetchTask&quot;</span><span class="s0">,</span><span class="s1">&quot;task&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrefetchTaskDirty&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;doPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchKind&quot;</span><span class="s0">,</span><span class="s1">&quot;PPR&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchKind&quot;</span><span class="s0">,</span><span class="s1">&quot;AUTO&quot;</span><span class="s0">,</span><span class="s1">&quot;FULL&quot;</span><span class="s0">,</span><span class="s1">&quot;PPRRuntime&quot;</span><span class="s0">,</span><span class="s1">&quot;InvariantError&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;catch&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">5259</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/errors/graceful-degrade-boundary.tsx&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;'use client'</span><span class="s3">\n\n</span><span class="s1">import { Component, createRef, type ReactNode } from 'react'</span><span class="s3">\n\n</span><span class="s1">interface ErrorBoundaryProps {</span><span class="s3">\n  </span><span class="s1">children: ReactNode</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface ErrorBoundaryState {</span><span class="s3">\n  </span><span class="s1">hasError: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getDomNodeAttributes(node: HTMLElement): Record&lt;string, string&gt; {</span><span class="s3">\n  </span><span class="s1">const result: Record&lt;string, string&gt; = {}</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; node.attributes.length; i++) {</span><span class="s3">\n    </span><span class="s1">const attr = node.attributes[i]</span><span class="s3">\n    </span><span class="s1">result[attr.name] = attr.value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class GracefulDegradeBoundary extends Component&lt;</span><span class="s3">\n  </span><span class="s1">ErrorBoundaryProps,</span><span class="s3">\n  </span><span class="s1">ErrorBoundaryState</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">private rootHtml: string</span><span class="s3">\n  </span><span class="s1">private htmlAttributes: Record&lt;string, string&gt;</span><span class="s3">\n  </span><span class="s1">private htmlRef: React.RefObject&lt;HTMLHtmlElement | null&gt;</span><span class="s3">\n\n  </span><span class="s1">constructor(props: ErrorBoundaryProps) {</span><span class="s3">\n    </span><span class="s1">super(props)</span><span class="s3">\n    </span><span class="s1">this.state = { hasError: false }</span><span class="s3">\n    </span><span class="s1">this.rootHtml = ''</span><span class="s3">\n    </span><span class="s1">this.htmlAttributes = {}</span><span class="s3">\n    </span><span class="s1">this.htmlRef = createRef&lt;HTMLHtmlElement&gt;()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static getDerivedStateFromError(_: unknown): ErrorBoundaryState {</span><span class="s3">\n    </span><span class="s1">return { hasError: true }</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">componentDidMount() {</span><span class="s3">\n    </span><span class="s1">const htmlNode = this.htmlRef.current</span><span class="s3">\n    </span><span class="s1">if (this.state.hasError &amp;&amp; htmlNode) {</span><span class="s3">\n      </span><span class="s1">// Reapply the cached HTML attributes to the root element</span><span class="s3">\n      </span><span class="s1">Object.entries(this.htmlAttributes).forEach(([key, value]) =&gt; {</span><span class="s3">\n        </span><span class="s1">htmlNode.setAttribute(key, value)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">render() {</span><span class="s3">\n    </span><span class="s1">const { hasError } = this.state</span><span class="s3">\n    </span><span class="s1">// Cache the root HTML content on the first render</span><span class="s3">\n    </span><span class="s1">if (typeof window !== 'undefined' &amp;&amp; !this.rootHtml) {</span><span class="s3">\n      </span><span class="s1">this.rootHtml = document.documentElement.innerHTML</span><span class="s3">\n      </span><span class="s1">this.htmlAttributes = getDomNodeAttributes(document.documentElement)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (hasError) {</span><span class="s3">\n      </span><span class="s1">// Render the current HTML content without hydration</span><span class="s3">\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">&lt;html</span><span class="s3">\n          </span><span class="s1">ref={this.htmlRef}</span><span class="s3">\n          </span><span class="s1">suppressHydrationWarning</span><span class="s3">\n          </span><span class="s1">dangerouslySetInnerHTML={{</span><span class="s3">\n            </span><span class="s1">__html: this.rootHtml,</span><span class="s3">\n          </span><span class="s1">}}</span><span class="s3">\n        </span><span class="s1">/&gt;</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.props.children</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default GracefulDegradeBoundary</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;GracefulDegradeBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;getDomNodeAttributes&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;attributes&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;attr&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;Component&quot;</span><span class="s0">,</span><span class="s1">&quot;getDerivedStateFromError&quot;</span><span class="s0">,</span><span class="s1">&quot;_&quot;</span><span class="s0">,</span><span class="s1">&quot;hasError&quot;</span><span class="s0">,</span><span class="s1">&quot;componentDidMount&quot;</span><span class="s0">,</span><span class="s1">&quot;htmlNode&quot;</span><span class="s0">,</span><span class="s1">&quot;htmlRef&quot;</span><span class="s0">,</span><span class="s1">&quot;current&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;htmlAttributes&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;setAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;render&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;rootHtml&quot;</span><span class="s0">,</span><span class="s1">&quot;document&quot;</span><span class="s0">,</span><span class="s1">&quot;documentElement&quot;</span><span class="s0">,</span><span class="s1">&quot;innerHTML&quot;</span><span class="s0">,</span><span class="s1">&quot;html&quot;</span><span class="s0">,</span><span class="s1">&quot;ref&quot;</span><span class="s0">,</span><span class="s1">&quot;suppressHydrationWarning&quot;</span><span class="s0">,</span><span class="s1">&quot;dangerouslySetInnerHTML&quot;</span><span class="s0">,</span><span class="s1">&quot;__html&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;createRef&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;IAqBaA,uBAAuB,EAAA;eAAvBA;;IAuDb,OAAsC,EAAA;eAAtC;;;;uBA1EqD;AAUrD,SAASC,qBAAqBC,IAAiB;IAC7C,MAAMC,SAAiC,CAAC;IACxC,IAAK,IAAIC,IAAI,GAAGA,IAAIF,KAAKG,UAAU,CAACC,MAAM,EAAEF,IAAK;QAC/C,MAAMG,OAAOL,KAAKG,UAAU,CAACD,EAAE;QAC/BD,MAAM,CAACI,KAAKC,IAAI,CAAC,GAAGD,KAAKE,KAAK;IAChC;IACA,OAAON;AACT;AAEO,MAAMH,gCAAgCU,OAAAA,SAAS;IAgBpD,OAAOC,yBAAyBC,CAAU,EAAsB;QAC9D,OAAO;YAAEC,UAAU;QAAK;IAC1B;IAEAC,oBAAoB;QAClB,MAAMC,WAAW,IAAI,CAACC,OAAO,CAACC,OAAO;QACrC,IAAI,IAAI,CAACC,KAAK,CAACL,QAAQ,IAAIE,UAAU;YACnC,yDAAyD;YACzDI,OAAOC,OAAO,CAAC,IAAI,CAACC,cAAc,EAAEC,OAAO,CAAC,CAAA;oBAAC,CAACC,KAAKd,MAAM,GAAA;gBACvDM,SAASS,YAAY,CAACD,KAAKd;YAC7B;QACF;IACF;IAEAgB,SAAS;QACP,MAAM,EAAEZ,QAAQ,EAAE,GAAG,IAAI,CAACK,KAAK;QAC/B,kDAAkD;QAClD,IAAI,OAAOQ,WAAW,eAAe,CAAC,IAAI,CAACC,QAAQ,EAAE;YACnD,IAAI,CAACA,QAAQ,GAAGC,SAASC,eAAe,CAACC,SAAS;YAClD,IAAI,CAACT,cAAc,GAAGpB,qBAAqB2B,SAASC,eAAe;QACrE;QAEA,IAAIhB,UAAU;YACZ,oDAAoD;YACpD,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACkB,QAAAA;gBACCC,KAAK,IAAI,CAAChB,OAAO;gBACjBiB,wBAAwB,EAAA;gBACxBC,yBAAyB;oBACvBC,QAAQ,IAAI,CAACR,QAAQ;gBACvB;;QAGN;QAEA,OAAO,IAAI,CAACS,KAAK,CAACC,QAAQ;IAC5B;IA5CAC,YAAYF,KAAyB,CAAE;QACrC,KAAK,CAACA;QACN,IAAI,CAAClB,KAAK,GAAG;YAAEL,UAAU;QAAM;QAC/B,IAAI,CAACc,QAAQ,GAAG;QAChB,IAAI,CAACN,cAAc,GAAG,CAAC;QACvB,IAAI,CAACL,OAAO,GAAA,WAAA,GAAGuB,CAAAA,GAAAA,OAAAA,SAAS;IAC1B;AAuCF;MAEA,WAAevC&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">5347</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/errors/root-error-boundary.tsx&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;'use client'</span><span class="s3">\n\n</span><span class="s1">import React, { type JSX } from 'react'</span><span class="s3">\n</span><span class="s1">import GracefulDegradeBoundary from './graceful-degrade-boundary'</span><span class="s3">\n</span><span class="s1">import { ErrorBoundary, type ErrorBoundaryProps } from '../error-boundary'</span><span class="s3">\n</span><span class="s1">import { isBot } from '../../../shared/lib/router/utils/is-bot'</span><span class="s3">\n\n</span><span class="s1">const isBotUserAgent =</span><span class="s3">\n  </span><span class="s1">typeof window !== 'undefined' &amp;&amp; isBot(window.navigator.userAgent)</span><span class="s3">\n\n</span><span class="s1">export default function RootErrorBoundary({</span><span class="s3">\n  </span><span class="s1">children,</span><span class="s3">\n  </span><span class="s1">errorComponent,</span><span class="s3">\n  </span><span class="s1">errorStyles,</span><span class="s3">\n  </span><span class="s1">errorScripts,</span><span class="s3">\n</span><span class="s1">}: ErrorBoundaryProps &amp; { children: React.ReactNode }): JSX.Element {</span><span class="s3">\n  </span><span class="s1">if (isBotUserAgent) {</span><span class="s3">\n    </span><span class="s1">// Preserve existing DOM/HTML for bots to avoid replacing content with an error UI</span><span class="s3">\n    </span><span class="s1">// and to keep the original SSR output intact.</span><span class="s3">\n    </span><span class="s1">return &lt;GracefulDegradeBoundary&gt;{children}&lt;/GracefulDegradeBoundary&gt;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">&lt;ErrorBoundary</span><span class="s3">\n      </span><span class="s1">errorComponent={errorComponent}</span><span class="s3">\n      </span><span class="s1">errorStyles={errorStyles}</span><span class="s3">\n      </span><span class="s1">errorScripts={errorScripts}</span><span class="s3">\n    </span><span class="s1">&gt;</span><span class="s3">\n      </span><span class="s1">{children}</span><span class="s3">\n    </span><span class="s1">&lt;/ErrorBoundary&gt;</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;RootErrorBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;isBotUserAgent&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;isBot&quot;</span><span class="s0">,</span><span class="s1">&quot;navigator&quot;</span><span class="s0">,</span><span class="s1">&quot;userAgent&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;errorComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;errorStyles&quot;</span><span class="s0">,</span><span class="s1">&quot;errorScripts&quot;</span><span class="s0">,</span><span class="s1">&quot;GracefulDegradeBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;ErrorBoundary&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAUA,WAAA;;;eAAwBA;;;;;gEARQ;kFACI;+BACmB;uBACjC;AAEtB,MAAMC,iBACJ,OAAOC,WAAW,eAAeC,CAAAA,GAAAA,OAAAA,KAAK,EAACD,OAAOE,SAAS,CAACC,SAAS;AAEpD,SAASL,kBAAkB,KAKW;IALX,IAAA,EACxCM,QAAQ,EACRC,cAAc,EACdC,WAAW,EACXC,YAAY,EACuC,GALX;IAMxC,IAAIR,gBAAgB;QAClB,kFAAkF;QAClF,8CAA8C;QAC9C,OAAA,WAAA,GAAO,CAAA,GAAA,YAAA,GAAA,EAACS,yBAAAA,OAAuB,EAAA;sBAAEJ;;IACnC;IAEA,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACK,eAAAA,aAAa,EAAA;QACZJ,gBAAgBA;QAChBC,aAAaA;QACbC,cAAcA;kBAEbH;;AAGP&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">5390</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/http-access-fallback/error-boundary.tsx&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;'use client'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* HTTPAccessFallbackBoundary is a boundary that catches errors and renders a</span><span class="s3">\n </span><span class="s1">* fallback component for HTTP errors.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* It receives the status code, and determine if it should render fallbacks for few HTTP 4xx errors.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* e.g. 404</span><span class="s3">\n </span><span class="s1">* 404 represents not found, and the fallback component pair contains the component and its styles.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import React, { useContext } from 'react'</span><span class="s3">\n</span><span class="s1">import { useUntrackedPathname } from '../navigation-untracked'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">HTTPAccessErrorStatus,</span><span class="s3">\n  </span><span class="s1">getAccessFallbackHTTPStatus,</span><span class="s3">\n  </span><span class="s1">getAccessFallbackErrorTypeByStatus,</span><span class="s3">\n  </span><span class="s1">isHTTPAccessFallbackError,</span><span class="s3">\n</span><span class="s1">} from './http-access-fallback'</span><span class="s3">\n</span><span class="s1">import { warnOnce } from '../../../shared/lib/utils/warn-once'</span><span class="s3">\n</span><span class="s1">import { MissingSlotContext } from '../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n\n</span><span class="s1">interface HTTPAccessFallbackBoundaryProps {</span><span class="s3">\n  </span><span class="s1">notFound?: React.ReactNode</span><span class="s3">\n  </span><span class="s1">forbidden?: React.ReactNode</span><span class="s3">\n  </span><span class="s1">unauthorized?: React.ReactNode</span><span class="s3">\n  </span><span class="s1">children: React.ReactNode</span><span class="s3">\n  </span><span class="s1">missingSlots?: Set&lt;string&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface HTTPAccessFallbackErrorBoundaryProps</span><span class="s3">\n  </span><span class="s1">extends HTTPAccessFallbackBoundaryProps {</span><span class="s3">\n  </span><span class="s1">pathname: string | null</span><span class="s3">\n  </span><span class="s1">missingSlots?: Set&lt;string&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface HTTPAccessBoundaryState {</span><span class="s3">\n  </span><span class="s1">triggeredStatus: number | undefined</span><span class="s3">\n  </span><span class="s1">previousPathname: string | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class HTTPAccessFallbackErrorBoundary extends React.Component&lt;</span><span class="s3">\n  </span><span class="s1">HTTPAccessFallbackErrorBoundaryProps,</span><span class="s3">\n  </span><span class="s1">HTTPAccessBoundaryState</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">constructor(props: HTTPAccessFallbackErrorBoundaryProps) {</span><span class="s3">\n    </span><span class="s1">super(props)</span><span class="s3">\n    </span><span class="s1">this.state = {</span><span class="s3">\n      </span><span class="s1">triggeredStatus: undefined,</span><span class="s3">\n      </span><span class="s1">previousPathname: props.pathname,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">componentDidCatch(): void {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">process.env.NODE_ENV === 'development' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.props.missingSlots &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.props.missingSlots.size &gt; 0 &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// A missing children slot is the typical not-found case, so no need to warn</span><span class="s3">\n      </span><span class="s1">!this.props.missingSlots.has('children')</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">let warningMessage =</span><span class="s3">\n        </span><span class="s1">'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.</span><span class="s3">\\</span><span class="s1">n' +</span><span class="s3">\n        </span><span class="s1">'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n'</span><span class="s3">\n\n      </span><span class="s1">const formattedSlots = Array.from(this.props.missingSlots)</span><span class="s3">\n        </span><span class="s1">.sort((a, b) =&gt; a.localeCompare(b))</span><span class="s3">\n        </span><span class="s1">.map((slot) =&gt; `@${slot}`)</span><span class="s3">\n        </span><span class="s1">.join(', ')</span><span class="s3">\n\n      </span><span class="s1">warningMessage += 'Missing slots: ' + formattedSlots</span><span class="s3">\n\n      </span><span class="s1">warnOnce(warningMessage)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static getDerivedStateFromError(error: any) {</span><span class="s3">\n    </span><span class="s1">if (isHTTPAccessFallbackError(error)) {</span><span class="s3">\n      </span><span class="s1">const httpStatus = getAccessFallbackHTTPStatus(error)</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">triggeredStatus: httpStatus,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Re-throw if error is not for 404</span><span class="s3">\n    </span><span class="s1">throw error</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static getDerivedStateFromProps(</span><span class="s3">\n    </span><span class="s1">props: HTTPAccessFallbackErrorBoundaryProps,</span><span class="s3">\n    </span><span class="s1">state: HTTPAccessBoundaryState</span><span class="s3">\n  </span><span class="s1">): HTTPAccessBoundaryState | null {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handles reset of the error boundary when a navigation happens.</span><span class="s3">\n     </span><span class="s1">* Ensures the error boundary does not stay enabled when navigating to a new page.</span><span class="s3">\n     </span><span class="s1">* Approach of setState in render is safe as it checks the previous pathname and then overrides</span><span class="s3">\n     </span><span class="s1">* it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (props.pathname !== state.previousPathname &amp;&amp; state.triggeredStatus) {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">triggeredStatus: undefined,</span><span class="s3">\n        </span><span class="s1">previousPathname: props.pathname,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">triggeredStatus: state.triggeredStatus,</span><span class="s3">\n      </span><span class="s1">previousPathname: props.pathname,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">render() {</span><span class="s3">\n    </span><span class="s1">const { notFound, forbidden, unauthorized, children } = this.props</span><span class="s3">\n    </span><span class="s1">const { triggeredStatus } = this.state</span><span class="s3">\n    </span><span class="s1">const errorComponents = {</span><span class="s3">\n      </span><span class="s1">[HTTPAccessErrorStatus.NOT_FOUND]: notFound,</span><span class="s3">\n      </span><span class="s1">[HTTPAccessErrorStatus.FORBIDDEN]: forbidden,</span><span class="s3">\n      </span><span class="s1">[HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (triggeredStatus) {</span><span class="s3">\n      </span><span class="s1">const isNotFound =</span><span class="s3">\n        </span><span class="s1">triggeredStatus === HTTPAccessErrorStatus.NOT_FOUND &amp;&amp; notFound</span><span class="s3">\n      </span><span class="s1">const isForbidden =</span><span class="s3">\n        </span><span class="s1">triggeredStatus === HTTPAccessErrorStatus.FORBIDDEN &amp;&amp; forbidden</span><span class="s3">\n      </span><span class="s1">const isUnauthorized =</span><span class="s3">\n        </span><span class="s1">triggeredStatus === HTTPAccessErrorStatus.UNAUTHORIZED &amp;&amp; unauthorized</span><span class="s3">\n\n      </span><span class="s1">// If there's no matched boundary in this layer, keep throwing the error by rendering the children</span><span class="s3">\n      </span><span class="s1">if (!(isNotFound || isForbidden || isUnauthorized)) {</span><span class="s3">\n        </span><span class="s1">return children</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">&lt;&gt;</span><span class="s3">\n          </span><span class="s1">&lt;meta name=</span><span class="s3">\&quot;</span><span class="s1">robots</span><span class="s3">\&quot; </span><span class="s1">content=</span><span class="s3">\&quot;</span><span class="s1">noindex</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n          </span><span class="s1">{process.env.NODE_ENV === 'development' &amp;&amp; (</span><span class="s3">\n            </span><span class="s1">&lt;meta</span><span class="s3">\n              </span><span class="s1">name=</span><span class="s3">\&quot;</span><span class="s1">boundary-next-error</span><span class="s3">\&quot;\n              </span><span class="s1">content={getAccessFallbackErrorTypeByStatus(triggeredStatus)}</span><span class="s3">\n            </span><span class="s1">/&gt;</span><span class="s3">\n          </span><span class="s1">)}</span><span class="s3">\n          </span><span class="s1">{errorComponents[triggeredStatus]}</span><span class="s3">\n        </span><span class="s1">&lt;/&gt;</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return children</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function HTTPAccessFallbackBoundary({</span><span class="s3">\n  </span><span class="s1">notFound,</span><span class="s3">\n  </span><span class="s1">forbidden,</span><span class="s3">\n  </span><span class="s1">unauthorized,</span><span class="s3">\n  </span><span class="s1">children,</span><span class="s3">\n</span><span class="s1">}: HTTPAccessFallbackBoundaryProps) {</span><span class="s3">\n  </span><span class="s1">// When we're rendering the missing params shell, this will return null. This</span><span class="s3">\n  </span><span class="s1">// is because we won't be rendering any not found boundaries or error</span><span class="s3">\n  </span><span class="s1">// boundaries for the missing params shell. When this runs on the client</span><span class="s3">\n  </span><span class="s1">// (where these error can occur), we will get the correct pathname.</span><span class="s3">\n  </span><span class="s1">const pathname = useUntrackedPathname()</span><span class="s3">\n  </span><span class="s1">const missingSlots = useContext(MissingSlotContext)</span><span class="s3">\n  </span><span class="s1">const hasErrorFallback = !!(notFound || forbidden || unauthorized)</span><span class="s3">\n\n  </span><span class="s1">if (hasErrorFallback) {</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">&lt;HTTPAccessFallbackErrorBoundary</span><span class="s3">\n        </span><span class="s1">pathname={pathname}</span><span class="s3">\n        </span><span class="s1">notFound={notFound}</span><span class="s3">\n        </span><span class="s1">forbidden={forbidden}</span><span class="s3">\n        </span><span class="s1">unauthorized={unauthorized}</span><span class="s3">\n        </span><span class="s1">missingSlots={missingSlots}</span><span class="s3">\n      </span><span class="s1">&gt;</span><span class="s3">\n        </span><span class="s1">{children}</span><span class="s3">\n      </span><span class="s1">&lt;/HTTPAccessFallbackErrorBoundary&gt;</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return &lt;&gt;{children}&lt;/&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;HTTPAccessFallbackBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;HTTPAccessFallbackErrorBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;React&quot;</span><span class="s0">,</span><span class="s1">&quot;Component&quot;</span><span class="s0">,</span><span class="s1">&quot;componentDidCatch&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;missingSlots&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;warningMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;formattedSlots&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;sort&quot;</span><span class="s0">,</span><span class="s1">&quot;a&quot;</span><span class="s0">,</span><span class="s1">&quot;b&quot;</span><span class="s0">,</span><span class="s1">&quot;localeCompare&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;slot&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;warnOnce&quot;</span><span class="s0">,</span><span class="s1">&quot;getDerivedStateFromError&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;isHTTPAccessFallbackError&quot;</span><span class="s0">,</span><span class="s1">&quot;httpStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;getAccessFallbackHTTPStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;triggeredStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;getDerivedStateFromProps&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;previousPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;render&quot;</span><span class="s0">,</span><span class="s1">&quot;notFound&quot;</span><span class="s0">,</span><span class="s1">&quot;forbidden&quot;</span><span class="s0">,</span><span class="s1">&quot;unauthorized&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;errorComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;HTTPAccessErrorStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;NOT_FOUND&quot;</span><span class="s0">,</span><span class="s1">&quot;FORBIDDEN&quot;</span><span class="s0">,</span><span class="s1">&quot;UNAUTHORIZED&quot;</span><span class="s0">,</span><span class="s1">&quot;isNotFound&quot;</span><span class="s0">,</span><span class="s1">&quot;isForbidden&quot;</span><span class="s0">,</span><span class="s1">&quot;isUnauthorized&quot;</span><span class="s0">,</span><span class="s1">&quot;meta&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;content&quot;</span><span class="s0">,</span><span class="s1">&quot;getAccessFallbackErrorTypeByStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;useUntrackedPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;useContext&quot;</span><span class="s0">,</span><span class="s1">&quot;MissingSlotContext&quot;</span><span class="s0">,</span><span class="s1">&quot;hasErrorFallback&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">5520</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/dev-root-http-access-fallback-boundary.tsx&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;'use client'</span><span class="s3">\n\n</span><span class="s1">import React from 'react'</span><span class="s3">\n</span><span class="s1">import { HTTPAccessFallbackBoundary } from './http-access-fallback/error-boundary'</span><span class="s3">\n\n</span><span class="s1">// TODO: error on using forbidden and unauthorized in root layout</span><span class="s3">\n</span><span class="s1">export function bailOnRootNotFound() {</span><span class="s3">\n  </span><span class="s1">throw new Error('notFound() is not allowed to use in root layout')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function NotAllowedRootHTTPFallbackError() {</span><span class="s3">\n  </span><span class="s1">bailOnRootNotFound()</span><span class="s3">\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function DevRootHTTPAccessFallbackBoundary({</span><span class="s3">\n  </span><span class="s1">children,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">children: React.ReactNode</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">&lt;HTTPAccessFallbackBoundary notFound={&lt;NotAllowedRootHTTPFallbackError /&gt;}&gt;</span><span class="s3">\n      </span><span class="s1">{children}</span><span class="s3">\n    </span><span class="s1">&lt;/HTTPAccessFallbackBoundary&gt;</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;DevRootHTTPAccessFallbackBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;bailOnRootNotFound&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;NotAllowedRootHTTPFallbackError&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;HTTPAccessFallbackBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;notFound&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;IAegBA,iCAAiC,EAAA;eAAjCA;;IATAC,kBAAkB,EAAA;eAAlBA;;;;;gEAJE;+BACyB;AAGpC,SAASA;IACd,MAAM,OAAA,cAA4D,CAA5D,IAAIC,MAAM,oDAAV,qBAAA;eAAA;oBAAA;sBAAA;IAA2D;AACnE;AAEA,SAASC;IACPF;IACA,OAAO;AACT;AAEO,SAASD,kCAAkC,KAIjD;IAJiD,IAAA,EAChDI,QAAQ,EAGT,GAJiD;IAKhD,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACC,eAAAA,0BAA0B,EAAA;QAACC,UAAAA,WAAAA,GAAU,CAAA,GAAA,YAAA,GAAA,EAACH,iCAAAA,CAAAA;kBACpCC;;AAGP&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">5574</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/dev/hot-reloader/shared.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { HMR_ACTION_TYPES } from '../../../server/dev/hot-reloader-types'</span><span class="s3">\n\n</span><span class="s1">export const REACT_REFRESH_FULL_RELOAD =</span><span class="s3">\n  </span><span class="s1">'[Fast Refresh] performing full reload</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n' +</span><span class="s3">\n  \&quot;</span><span class="s1">Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n  </span><span class="s1">'You might have a file which exports a React component but also exports a value that is imported by a non-React component file.</span><span class="s3">\\</span><span class="s1">n' +</span><span class="s3">\n  </span><span class="s1">'Consider migrating the non-React component export to a separate file and importing it into both files.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n' +</span><span class="s3">\n  </span><span class="s1">'It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.</span><span class="s3">\\</span><span class="s1">n' +</span><span class="s3">\n  </span><span class="s1">'Fast Refresh requires at least one parent function component in your React tree.'</span><span class="s3">\n\n</span><span class="s1">export const REACT_REFRESH_FULL_RELOAD_FROM_ERROR =</span><span class="s3">\n  </span><span class="s1">'[Fast Refresh] performing full reload because your application had an unrecoverable error'</span><span class="s3">\n\n</span><span class="s1">export function reportInvalidHmrMessage(</span><span class="s3">\n  </span><span class="s1">message: HMR_ACTION_TYPES | MessageEvent&lt;unknown&gt;,</span><span class="s3">\n  </span><span class="s1">err: unknown</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">console.warn(</span><span class="s3">\n    </span><span class="s1">'[HMR] Invalid message: ' +</span><span class="s3">\n      </span><span class="s1">JSON.stringify(message) +</span><span class="s3">\n      </span><span class="s1">'</span><span class="s3">\\</span><span class="s1">n' +</span><span class="s3">\n      </span><span class="s1">((err instanceof Error &amp;&amp; err?.stack) || '')</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;REACT_REFRESH_FULL_RELOAD&quot;</span><span class="s0">,</span><span class="s1">&quot;REACT_REFRESH_FULL_RELOAD_FROM_ERROR&quot;</span><span class="s0">,</span><span class="s1">&quot;reportInvalidHmrMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;warn&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;stack&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;IAEaA,yBAAyB,EAAA;eAAzBA;;IAQAC,oCAAoC,EAAA;eAApCA;;IAGGC,uBAAuB,EAAA;eAAvBA;;;AAXT,MAAMF,4BACX,8CACA,mIACA,qIACA,+GACA,8HACA;AAEK,MAAMC,uCACX;AAEK,SAASC,wBACdC,OAAiD,EACjDC,GAAY;IAEZC,QAAQC,IAAI,CACV,4BACEC,KAAKC,SAAS,CAACL,WACf,OACC,CAACC,eAAeK,SAAAA,CAASL,OAAAA,OAAAA,KAAAA,IAAAA,IAAKM,KAAK,KAAK,EAAC;AAEhD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">5615</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/dev/hot-reloader/get-socket-url.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { normalizedAssetPrefix } from '../../../shared/lib/normalized-asset-prefix'</span><span class="s3">\n\n</span><span class="s1">function getSocketProtocol(assetPrefix: string): string {</span><span class="s3">\n  </span><span class="s1">let protocol = window.location.protocol</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">// assetPrefix is a url</span><span class="s3">\n    </span><span class="s1">protocol = new URL(assetPrefix).protocol</span><span class="s3">\n  </span><span class="s1">} catch {}</span><span class="s3">\n\n  </span><span class="s1">return protocol === 'http:' ? 'ws:' : 'wss:'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getSocketUrl(assetPrefix: string | undefined): string {</span><span class="s3">\n  </span><span class="s1">const prefix = normalizedAssetPrefix(assetPrefix)</span><span class="s3">\n  </span><span class="s1">const protocol = getSocketProtocol(assetPrefix || '')</span><span class="s3">\n\n  </span><span class="s1">if (URL.canParse(prefix)) {</span><span class="s3">\n    </span><span class="s1">// since normalized asset prefix is ensured to be a URL format,</span><span class="s3">\n    </span><span class="s1">// we can safely replace the protocol</span><span class="s3">\n    </span><span class="s1">return prefix.replace(/^http/, 'ws')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { hostname, port } = window.location</span><span class="s3">\n  </span><span class="s1">return `${protocol}//${hostname}${port ? `:${port}` : ''}${prefix}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;getSocketUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;getSocketProtocol&quot;</span><span class="s0">,</span><span class="s1">&quot;assetPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;protocol&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedAssetPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;canParse&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;hostname&quot;</span><span class="s0">,</span><span class="s1">&quot;port&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAagBA,gBAAAA;;;eAAAA;;;uCAbsB;AAEtC,SAASC,kBAAkBC,WAAmB;IAC5C,IAAIC,WAAWC,OAAOC,QAAQ,CAACF,QAAQ;IAEvC,IAAI;QACF,uBAAuB;QACvBA,WAAW,IAAIG,IAAIJ,aAAaC,QAAQ;IAC1C,EAAE,OAAA,GAAM,CAAC;IAET,OAAOA,aAAa,UAAU,QAAQ;AACxC;AAEO,SAASH,aAAaE,WAA+B;IAC1D,MAAMK,SAASC,CAAAA,GAAAA,uBAAAA,qBAAqB,EAACN;IACrC,MAAMC,WAAWF,kBAAkBC,eAAe;IAElD,IAAII,IAAIG,QAAQ,CAACF,SAAS;QACxB,+DAA+D;QAC/D,qCAAqC;QACrC,OAAOA,OAAOG,OAAO,CAAC,SAAS;IACjC;IAEA,MAAM,EAAEC,QAAQ,EAAEC,IAAI,EAAE,GAAGR,OAAOC,QAAQ;IAC1C,OAAUF,WAAS,OAAIQ,WAAWC,CAAAA,OAAQ,MAAGA,OAAS,EAAC,IAAIL;AAC7D&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">5655</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/dev/hot-reloader/app/use-websocket.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { useCallback, useContext, useEffect, useRef } from 'react'</span><span class="s3">\n</span><span class="s1">import { GlobalLayoutRouterContext } from '../../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { getSocketUrl } from '../get-socket-url'</span><span class="s3">\n</span><span class="s1">import type { TurbopackMsgToBrowser } from '../../../../server/dev/hot-reloader-types'</span><span class="s3">\n\n</span><span class="s1">export function useWebsocket(assetPrefix: string) {</span><span class="s3">\n  </span><span class="s1">const webSocketRef = useRef&lt;WebSocket&gt;(undefined)</span><span class="s3">\n\n  </span><span class="s1">useEffect(() =&gt; {</span><span class="s3">\n    </span><span class="s1">if (webSocketRef.current) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const url = getSocketUrl(assetPrefix)</span><span class="s3">\n\n    </span><span class="s1">webSocketRef.current = new window.WebSocket(`${url}/_next/webpack-hmr`)</span><span class="s3">\n  </span><span class="s1">}, [assetPrefix])</span><span class="s3">\n\n  </span><span class="s1">return webSocketRef</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function useSendMessage(webSocketRef: ReturnType&lt;typeof useWebsocket&gt;) {</span><span class="s3">\n  </span><span class="s1">const sendMessage = useCallback(</span><span class="s3">\n    </span><span class="s1">(data: string) =&gt; {</span><span class="s3">\n      </span><span class="s1">const socket = webSocketRef.current</span><span class="s3">\n      </span><span class="s1">if (!socket || socket.readyState !== socket.OPEN) {</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return socket.send(data)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">[webSocketRef]</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">return sendMessage</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function useTurbopack(</span><span class="s3">\n  </span><span class="s1">sendMessage: ReturnType&lt;typeof useSendMessage&gt;,</span><span class="s3">\n  </span><span class="s1">onUpdateError: (err: unknown) =&gt; void</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const turbopackState = useRef&lt;{</span><span class="s3">\n    </span><span class="s1">init: boolean</span><span class="s3">\n    </span><span class="s1">queue: Array&lt;TurbopackMsgToBrowser&gt; | undefined</span><span class="s3">\n    </span><span class="s1">callback: ((msg: TurbopackMsgToBrowser) =&gt; void) | undefined</span><span class="s3">\n  </span><span class="s1">}&gt;({</span><span class="s3">\n    </span><span class="s1">init: false,</span><span class="s3">\n    </span><span class="s1">// Until the dynamic import resolves, queue any turbopack messages which will be replayed.</span><span class="s3">\n    </span><span class="s1">queue: [],</span><span class="s3">\n    </span><span class="s1">callback: undefined,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const processTurbopackMessage = useCallback((msg: TurbopackMsgToBrowser) =&gt; {</span><span class="s3">\n    </span><span class="s1">const { callback, queue } = turbopackState.current</span><span class="s3">\n    </span><span class="s1">if (callback) {</span><span class="s3">\n      </span><span class="s1">callback(msg)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">queue!.push(msg)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, [])</span><span class="s3">\n\n  </span><span class="s1">useEffect(() =&gt; {</span><span class="s3">\n    </span><span class="s1">const { current: initCurrent } = turbopackState</span><span class="s3">\n    </span><span class="s1">// TODO(WEB-1589): only install if `process.turbopack` set.</span><span class="s3">\n    </span><span class="s1">if (initCurrent.init) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">initCurrent.init = true</span><span class="s3">\n\n    </span><span class="s1">import(</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error requires </span><span class="s3">\&quot;</span><span class="s1">moduleResolution</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">node16</span><span class="s3">\&quot; </span><span class="s1">in tsconfig.json and not .ts extension</span><span class="s3">\n      </span><span class="s1">'@vercel/turbopack-ecmascript-runtime/browser/dev/hmr-client/hmr-client.ts'</span><span class="s3">\n    </span><span class="s1">).then(({ connect }) =&gt; {</span><span class="s3">\n      </span><span class="s1">const { current } = turbopackState</span><span class="s3">\n      </span><span class="s1">connect({</span><span class="s3">\n        </span><span class="s1">addMessageListener(cb: (msg: TurbopackMsgToBrowser) =&gt; void) {</span><span class="s3">\n          </span><span class="s1">current.callback = cb</span><span class="s3">\n\n          </span><span class="s1">// Replay all Turbopack messages before we were able to establish the HMR client.</span><span class="s3">\n          </span><span class="s1">for (const msg of current.queue!) {</span><span class="s3">\n            </span><span class="s1">cb(msg)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">current.queue = undefined</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">sendMessage,</span><span class="s3">\n        </span><span class="s1">onUpdateError,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}, [sendMessage, onUpdateError])</span><span class="s3">\n\n  </span><span class="s1">return processTurbopackMessage</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function useWebsocketPing(</span><span class="s3">\n  </span><span class="s1">websocketRef: ReturnType&lt;typeof useWebsocket&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const sendMessage = useSendMessage(websocketRef)</span><span class="s3">\n  </span><span class="s1">const { tree } = useContext(GlobalLayoutRouterContext)</span><span class="s3">\n\n  </span><span class="s1">useEffect(() =&gt; {</span><span class="s3">\n    </span><span class="s1">// Never send pings when using Turbopack as it's not used.</span><span class="s3">\n    </span><span class="s1">// Pings were originally used to keep track of active routes in on-demand-entries with webpack.</span><span class="s3">\n    </span><span class="s1">if (process.env.TURBOPACK) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Taken from on-demand-entries-client.js</span><span class="s3">\n    </span><span class="s1">const interval = setInterval(() =&gt; {</span><span class="s3">\n      </span><span class="s1">sendMessage(</span><span class="s3">\n        </span><span class="s1">JSON.stringify({</span><span class="s3">\n          </span><span class="s1">event: 'ping',</span><span class="s3">\n          </span><span class="s1">tree,</span><span class="s3">\n          </span><span class="s1">appDirRoute: true,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}, 2500)</span><span class="s3">\n    </span><span class="s1">return () =&gt; clearInterval(interval)</span><span class="s3">\n  </span><span class="s1">}, [tree, sendMessage])</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;useSendMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;useTurbopack&quot;</span><span class="s0">,</span><span class="s1">&quot;useWebsocket&quot;</span><span class="s0">,</span><span class="s1">&quot;useWebsocketPing&quot;</span><span class="s0">,</span><span class="s1">&quot;assetPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;webSocketRef&quot;</span><span class="s0">,</span><span class="s1">&quot;useRef&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;useEffect&quot;</span><span class="s0">,</span><span class="s1">&quot;current&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;getSocketUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;WebSocket&quot;</span><span class="s0">,</span><span class="s1">&quot;sendMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;useCallback&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;socket&quot;</span><span class="s0">,</span><span class="s1">&quot;readyState&quot;</span><span class="s0">,</span><span class="s1">&quot;OPEN&quot;</span><span class="s0">,</span><span class="s1">&quot;send&quot;</span><span class="s0">,</span><span class="s1">&quot;onUpdateError&quot;</span><span class="s0">,</span><span class="s1">&quot;turbopackState&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;queue&quot;</span><span class="s0">,</span><span class="s1">&quot;callback&quot;</span><span class="s0">,</span><span class="s1">&quot;processTurbopackMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;msg&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;initCurrent&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;connect&quot;</span><span class="s0">,</span><span class="s1">&quot;addMessageListener&quot;</span><span class="s0">,</span><span class="s1">&quot;cb&quot;</span><span class="s0">,</span><span class="s1">&quot;websocketRef&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;useContext&quot;</span><span class="s0">,</span><span class="s1">&quot;GlobalLayoutRouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;TURBOPACK&quot;</span><span class="s0">,</span><span class="s1">&quot;interval&quot;</span><span class="s0">,</span><span class="s1">&quot;setInterval&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;event&quot;</span><span class="s0">,</span><span class="s1">&quot;appDirRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;clearInterval&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAoGQsC,QAAQC,GAAG,CAACC,SAAS;;;;;;;;;;;;;;;;;;IA/EbxC,cAAc,EAAA;eAAdA;;IAcAC,YAAY,EAAA;eAAZA;;IA9BAC,YAAY,EAAA;eAAZA;;IAsFAC,gBAAgB,EAAA;eAAhBA;;;uBA3F2C;+CACjB;8BACb;AAGtB,SAASD,aAAaE,WAAmB;IAC9C,MAAMC,eAAeC,CAAAA,GAAAA,OAAAA,MAAM,EAAYC;IAEvCC,CAAAA,GAAAA,OAAAA,SAAS,EAAC;QACR,IAAIH,aAAaI,OAAO,EAAE;YACxB;QACF;QAEA,MAAMC,MAAMC,CAAAA,GAAAA,cAAAA,YAAY,EAACP;QAEzBC,aAAaI,OAAO,GAAG,IAAIG,OAAOC,SAAS,CAAE,KAAEH,MAAI;IACrD,GAAG;QAACN;KAAY;IAEhB,OAAOC;AACT;AAEO,SAASL,eAAeK,YAA6C;IAC1E,MAAMS,cAAcC,CAAAA,GAAAA,OAAAA,WAAW,EAC7B,CAACC;QACC,MAAMC,SAASZ,aAAaI,OAAO;QACnC,IAAI,CAACQ,UAAUA,OAAOC,UAAU,KAAKD,OAAOE,IAAI,EAAE;YAChD;QACF;QACA,OAAOF,OAAOG,IAAI,CAACJ;IACrB,GACA;QAACX;KAAa;IAEhB,OAAOS;AACT;AAEO,SAASb,aACda,WAA8C,EAC9CO,aAAqC;IAErC,MAAMC,iBAAiBhB,CAAAA,GAAAA,OAAAA,MAAM,EAI1B;QACDiB,MAAM;QACN,0FAA0F;QAC1FC,OAAO,EAAE;QACTC,UAAUlB;IACZ;IAEA,MAAMmB,0BAA0BX,CAAAA,GAAAA,OAAAA,WAAW,EAAC,CAACY;QAC3C,MAAM,EAAEF,QAAQ,EAAED,KAAK,EAAE,GAAGF,eAAeb,OAAO;QAClD,IAAIgB,UAAU;YACZA,SAASE;QACX,OAAO;YACLH,MAAOI,IAAI,CAACD;QACd;IACF,GAAG,EAAE;IAELnB,CAAAA,GAAAA,OAAAA,SAAS,EAAC;QACR,MAAM,EAAEC,SAASoB,WAAW,EAAE,GAAGP;QACjC,2DAA2D;QAC3D,IAAIO,YAAYN,IAAI,EAAE;YACpB;QACF;QACAM,YAAYN,IAAI,GAAG;QAEnB,MAAM,CACJ,gGAAgG,aAEhGO,IAAI,CAAC,CAAA;gBAAC,EAAEC,OAAO,EAAE,GAAA;YACjB,MAAM,EAAEtB,OAAO,EAAE,GAAGa;YACpBS,QAAQ;gBACNC,oBAAmBC,EAAwC;oBACzDxB,QAAQgB,QAAQ,GAAGQ;oBAEnB,iFAAiF;oBACjF,KAAK,MAAMN,OAAOlB,QAAQe,KAAK,CAAG;wBAChCS,GAAGN;oBACL;oBACAlB,QAAQe,KAAK,GAAGjB;gBAClB;gBACAO;gBACAO;YACF;QACF;IACF,GAAG;QAACP;QAAaO;KAAc;IAE/B,OAAOK;AACT;AAEO,SAASvB,iBACd+B,YAA6C;IAE7C,MAAMpB,cAAcd,eAAekC;IACnC,MAAM,EAAEC,IAAI,EAAE,GAAGC,CAAAA,GAAAA,OAAAA,UAAU,EAACC,+BAAAA,yBAAyB;IAErD7B,CAAAA,GAAAA,OAAAA,SAAS,EAAC;QACR,0DAA0D;QAC1D,+FAA+F;QAC/F,wCAA2B;YACzB;QACF;;;QAEA,yCAAyC;QACzC,MAAMiC,WAAWC,YAAY;IAU/B,GAAG;QAACP;QAAMrB;KAAY;AACxB&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">5787</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/dev/report-hmr-latency.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;declare global {</span><span class="s3">\n  </span><span class="s1">interface Window {</span><span class="s3">\n    </span><span class="s1">__NEXT_HMR_LATENCY_CB: ((latencyMs: number) =&gt; void) | undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Logs information about a completed HMR to the console, the server (via a</span><span class="s3">\n </span><span class="s1">* `client-hmr-latency` event), and to `self.__NEXT_HMR_LATENCY_CB` (a debugging</span><span class="s3">\n </span><span class="s1">* hook).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param hasUpdate Set this to `false` to avoid reporting the HMR event via a</span><span class="s3">\n </span><span class="s1">*   `client-hmr-latency` event or to `self.__NEXT_HMR_LATENCY_CB`. Used by</span><span class="s3">\n </span><span class="s1">*   turbopack when we must report a message to the browser console (because we</span><span class="s3">\n </span><span class="s1">*   already logged a </span><span class="s3">\&quot;</span><span class="s1">rebuilding</span><span class="s3">\&quot; </span><span class="s1">message), but it's not a real HMR, so we</span><span class="s3">\n </span><span class="s1">*   don't want to impact our telemetry.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function reportHmrLatency(</span><span class="s3">\n  </span><span class="s1">sendMessage: (message: string) =&gt; void,</span><span class="s3">\n  </span><span class="s1">updatedModules: ReadonlyArray&lt;string | number&gt;,</span><span class="s3">\n  </span><span class="s1">startMsSinceEpoch: number,</span><span class="s3">\n  </span><span class="s1">endMsSinceEpoch: number,</span><span class="s3">\n  </span><span class="s1">hasUpdate: boolean = true</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const latencyMs = endMsSinceEpoch - startMsSinceEpoch</span><span class="s3">\n  </span><span class="s1">console.log(`[Fast Refresh] done in ${latencyMs}ms`)</span><span class="s3">\n  </span><span class="s1">if (!hasUpdate) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">sendMessage(</span><span class="s3">\n    </span><span class="s1">JSON.stringify({</span><span class="s3">\n      </span><span class="s1">event: 'client-hmr-latency',</span><span class="s3">\n      </span><span class="s1">id: window.__nextDevClientId,</span><span class="s3">\n      </span><span class="s1">startTime: startMsSinceEpoch,</span><span class="s3">\n      </span><span class="s1">endTime: endMsSinceEpoch,</span><span class="s3">\n      </span><span class="s1">page: window.location.pathname,</span><span class="s3">\n      </span><span class="s1">updatedModules,</span><span class="s3">\n      </span><span class="s1">// Whether the page (tab) was hidden at the time the event occurred.</span><span class="s3">\n      </span><span class="s1">// This can impact the accuracy of the event's timing.</span><span class="s3">\n      </span><span class="s1">isPageHidden: document.visibilityState === 'hidden',</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">if (self.__NEXT_HMR_LATENCY_CB) {</span><span class="s3">\n    </span><span class="s1">self.__NEXT_HMR_LATENCY_CB(latencyMs)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;reportHmrLatency&quot;</span><span class="s0">,</span><span class="s1">&quot;sendMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedModules&quot;</span><span class="s0">,</span><span class="s1">&quot;startMsSinceEpoch&quot;</span><span class="s0">,</span><span class="s1">&quot;endMsSinceEpoch&quot;</span><span class="s0">,</span><span class="s1">&quot;hasUpdate&quot;</span><span class="s0">,</span><span class="s1">&quot;latencyMs&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;log&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;event&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;__nextDevClientId&quot;</span><span class="s0">,</span><span class="s1">&quot;startTime&quot;</span><span class="s0">,</span><span class="s1">&quot;endTime&quot;</span><span class="s0">,</span><span class="s1">&quot;page&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;isPageHidden&quot;</span><span class="s0">,</span><span class="s1">&quot;document&quot;</span><span class="s0">,</span><span class="s1">&quot;visibilityState&quot;</span><span class="s0">,</span><span class="s1">&quot;self&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_HMR_LATENCY_CB&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAMA;;;;;;;;;;CAUC,GACD,WAAA;;;eAAwBA;;;AAAT,SAASA,iBACtBC,WAAsC,EACtCC,cAA8C,EAC9CC,iBAAyB,EACzBC,eAAuB,EACvBC,SAAyB;IAAzBA,IAAAA,cAAAA,KAAAA,GAAAA,YAAqB;IAErB,MAAMC,YAAYF,kBAAkBD;IACpCI,QAAQC,GAAG,CAAE,4BAAyBF,YAAU;IAChD,IAAI,CAACD,WAAW;QACd;IACF;IACAJ,YACEQ,KAAKC,SAAS,CAAC;QACbC,OAAO;QACPC,IAAIC,OAAOC,iBAAiB;QAC5BC,WAAWZ;QACXa,SAASZ;QACTa,MAAMJ,OAAOK,QAAQ,CAACC,QAAQ;QAC9BjB;QACA,oEAAoE;QACpE,sDAAsD;QACtDkB,cAAcC,SAASC,eAAe,KAAK;IAC7C;IAEF,IAAIC,KAAKC,qBAAqB,EAAE;QAC9BD,KAAKC,qBAAqB,CAAClB;IAC7B;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">5839</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/dev/hot-reloader/turbopack-hot-reloader-common.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { TurbopackMessageAction } from '../../../server/dev/hot-reloader-types'</span><span class="s3">\n</span><span class="s1">import type { Update as TurbopackUpdate } from '../../../build/swc/types'</span><span class="s3">\n\n</span><span class="s1">declare global {</span><span class="s3">\n  </span><span class="s1">interface Window {</span><span class="s3">\n    </span><span class="s1">__NEXT_HMR_TURBOPACK_REPORT_NOISY_NOOP_EVENTS: boolean | undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// How long to wait before reporting the HMR start, used to suppress irrelevant</span><span class="s3">\n</span><span class="s1">// `BUILDING` events. Does not impact reported latency.</span><span class="s3">\n</span><span class="s1">const TURBOPACK_HMR_START_DELAY_MS = 100</span><span class="s3">\n\n</span><span class="s1">interface HmrUpdate {</span><span class="s3">\n  </span><span class="s1">hasUpdates: boolean</span><span class="s3">\n  </span><span class="s1">updatedModules: Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">startMsSinceEpoch: number</span><span class="s3">\n  </span><span class="s1">endMsSinceEpoch: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class TurbopackHmr {</span><span class="s3">\n  </span><span class="s1">#updatedModules: Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">#startMsSinceEpoch: number | undefined</span><span class="s3">\n  </span><span class="s1">#lastUpdateMsSinceEpoch: number | undefined</span><span class="s3">\n  </span><span class="s1">#deferredReportHmrStartId: ReturnType&lt;typeof setTimeout&gt; | undefined</span><span class="s3">\n  </span><span class="s1">#reportedHmrStart: boolean</span><span class="s3">\n\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">this.#updatedModules = new Set()</span><span class="s3">\n    </span><span class="s1">this.#reportedHmrStart = false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// HACK: Turbopack tends to generate a lot of irrelevant </span><span class="s3">\&quot;</span><span class="s1">BUILDING</span><span class="s3">\&quot; </span><span class="s1">actions,</span><span class="s3">\n  </span><span class="s1">// as it reports *any* compilation, including fully no-op/cached compilations</span><span class="s3">\n  </span><span class="s1">// and those unrelated to HMR. Fixing this would require significant</span><span class="s3">\n  </span><span class="s1">// architectural changes.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Work around this by deferring any </span><span class="s3">\&quot;</span><span class="s1">rebuilding</span><span class="s3">\&quot; </span><span class="s1">message by 100ms. If we get</span><span class="s3">\n  </span><span class="s1">// a BUILT event within that threshold and nothing has changed, just suppress</span><span class="s3">\n  </span><span class="s1">// the message entirely.</span><span class="s3">\n  </span><span class="s1">#runDeferredReportHmrStart() {</span><span class="s3">\n    </span><span class="s1">if (this.#deferredReportHmrStartId != null) {</span><span class="s3">\n      </span><span class="s1">console.log('[Fast Refresh] rebuilding')</span><span class="s3">\n      </span><span class="s1">this.#reportedHmrStart = true</span><span class="s3">\n      </span><span class="s1">this.#cancelDeferredReportHmrStart()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">#cancelDeferredReportHmrStart() {</span><span class="s3">\n    </span><span class="s1">clearTimeout(this.#deferredReportHmrStartId)</span><span class="s3">\n    </span><span class="s1">this.#deferredReportHmrStartId = undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">onBuilding() {</span><span class="s3">\n    </span><span class="s1">this.#lastUpdateMsSinceEpoch = undefined</span><span class="s3">\n    </span><span class="s1">this.#cancelDeferredReportHmrStart()</span><span class="s3">\n    </span><span class="s1">this.#startMsSinceEpoch = Date.now()</span><span class="s3">\n\n    </span><span class="s1">// report the HMR start after a short delay</span><span class="s3">\n    </span><span class="s1">this.#deferredReportHmrStartId = setTimeout(</span><span class="s3">\n      </span><span class="s1">() =&gt; this.#runDeferredReportHmrStart(),</span><span class="s3">\n      </span><span class="s1">// debugging feature: don't defer/suppress noisy no-op HMR update messages</span><span class="s3">\n      </span><span class="s1">self.__NEXT_HMR_TURBOPACK_REPORT_NOISY_NOOP_EVENTS</span><span class="s3">\n        </span><span class="s1">? 0</span><span class="s3">\n        </span><span class="s1">: TURBOPACK_HMR_START_DELAY_MS</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/** Helper for other `onEvent` methods. */</span><span class="s3">\n  </span><span class="s1">#onUpdate() {</span><span class="s3">\n    </span><span class="s1">this.#runDeferredReportHmrStart()</span><span class="s3">\n    </span><span class="s1">this.#lastUpdateMsSinceEpoch = Date.now()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">onTurbopackMessage(msg: TurbopackMessageAction) {</span><span class="s3">\n    </span><span class="s1">this.#onUpdate()</span><span class="s3">\n    </span><span class="s1">const updatedModules = extractModulesFromTurbopackMessage(msg.data)</span><span class="s3">\n    </span><span class="s1">for (const module of updatedModules) {</span><span class="s3">\n      </span><span class="s1">this.#updatedModules.add(module)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">onServerComponentChanges() {</span><span class="s3">\n    </span><span class="s1">this.#onUpdate()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">onReloadPage() {</span><span class="s3">\n    </span><span class="s1">this.#onUpdate()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">onPageAddRemove() {</span><span class="s3">\n    </span><span class="s1">this.#onUpdate()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @returns `null` if the caller should ignore the update entirely. Returns an</span><span class="s3">\n   </span><span class="s1">*   object with `hasUpdates: false` if the caller should report the end of</span><span class="s3">\n   </span><span class="s1">*   the HMR in the browser console, but the HMR was a no-op.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">onBuilt(): HmrUpdate | null {</span><span class="s3">\n    </span><span class="s1">// Check that we got *any* `TurbopackMessageAction`, even if</span><span class="s3">\n    </span><span class="s1">// `updatedModules` is empty (not everything gets recorded there).</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// There's also a case where `onBuilt` gets called before `onBuilding`,</span><span class="s3">\n    </span><span class="s1">// which can happen during initial page load. Ignore that too!</span><span class="s3">\n    </span><span class="s1">const hasUpdates =</span><span class="s3">\n      </span><span class="s1">this.#lastUpdateMsSinceEpoch != null &amp;&amp; this.#startMsSinceEpoch != null</span><span class="s3">\n    </span><span class="s1">if (!hasUpdates &amp;&amp; !this.#reportedHmrStart) {</span><span class="s3">\n      </span><span class="s1">// suppress the update entirely</span><span class="s3">\n      </span><span class="s1">this.#cancelDeferredReportHmrStart()</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.#runDeferredReportHmrStart()</span><span class="s3">\n\n    </span><span class="s1">const result = {</span><span class="s3">\n      </span><span class="s1">hasUpdates,</span><span class="s3">\n      </span><span class="s1">updatedModules: this.#updatedModules,</span><span class="s3">\n      </span><span class="s1">startMsSinceEpoch: this.#startMsSinceEpoch!,</span><span class="s3">\n      </span><span class="s1">endMsSinceEpoch: this.#lastUpdateMsSinceEpoch ?? Date.now(),</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.#updatedModules = new Set()</span><span class="s3">\n    </span><span class="s1">this.#reportedHmrStart = false</span><span class="s3">\n    </span><span class="s1">return result</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function extractModulesFromTurbopackMessage(</span><span class="s3">\n  </span><span class="s1">data: TurbopackUpdate | TurbopackUpdate[]</span><span class="s3">\n</span><span class="s1">): Set&lt;string&gt; {</span><span class="s3">\n  </span><span class="s1">const updatedModules: Set&lt;string&gt; = new Set()</span><span class="s3">\n\n  </span><span class="s1">const updates = Array.isArray(data) ? data : [data]</span><span class="s3">\n  </span><span class="s1">for (const update of updates) {</span><span class="s3">\n    </span><span class="s1">// TODO this won't capture changes to CSS since they don't result in a </span><span class="s3">\&quot;</span><span class="s1">merged</span><span class="s3">\&quot; </span><span class="s1">update</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">update.type !== 'partial' ||</span><span class="s3">\n      </span><span class="s1">update.instruction.type !== 'ChunkListUpdate' ||</span><span class="s3">\n      </span><span class="s1">update.instruction.merged === undefined</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const mergedUpdate of update.instruction.merged) {</span><span class="s3">\n      </span><span class="s1">for (const name of Object.keys(mergedUpdate.entries)) {</span><span class="s3">\n        </span><span class="s1">const res = /(.*)</span><span class="s3">\\</span><span class="s1">s+</span><span class="s3">\\</span><span class="s1">[.*/.exec(name)</span><span class="s3">\n        </span><span class="s1">if (res === null) {</span><span class="s3">\n          </span><span class="s1">console.error(</span><span class="s3">\n            </span><span class="s1">'[Turbopack HMR] Expected module to match pattern: ' + name</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">updatedModules.add(res[1])</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return updatedModules</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;TurbopackHmr&quot;</span><span class="s0">,</span><span class="s1">&quot;TURBOPACK_HMR_START_DELAY_MS&quot;</span><span class="s0">,</span><span class="s1">&quot;onBuilding&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;setTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;self&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_HMR_TURBOPACK_REPORT_NOISY_NOOP_EVENTS&quot;</span><span class="s0">,</span><span class="s1">&quot;onTurbopackMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;msg&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedModules&quot;</span><span class="s0">,</span><span class="s1">&quot;extractModulesFromTurbopackMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;module&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;onServerComponentChanges&quot;</span><span class="s0">,</span><span class="s1">&quot;onReloadPage&quot;</span><span class="s0">,</span><span class="s1">&quot;onPageAddRemove&quot;</span><span class="s0">,</span><span class="s1">&quot;onBuilt&quot;</span><span class="s0">,</span><span class="s1">&quot;hasUpdates&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;startMsSinceEpoch&quot;</span><span class="s0">,</span><span class="s1">&quot;endMsSinceEpoch&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;log&quot;</span><span class="s0">,</span><span class="s1">&quot;clearTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;updates&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;update&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;instruction&quot;</span><span class="s0">,</span><span class="s1">&quot;merged&quot;</span><span class="s0">,</span><span class="s1">&quot;mergedUpdate&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;exec&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">5996</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/dev/hot-reloader/app/hot-reloader-app.tsx&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/// &lt;reference types=</span><span class="s3">\&quot;</span><span class="s1">webpack/module.d.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n\n</span><span class="s1">import type { ReactNode } from 'react'</span><span class="s3">\n</span><span class="s1">import { useEffect, startTransition, useRef } from 'react'</span><span class="s3">\n</span><span class="s1">import stripAnsi from 'next/dist/compiled/strip-ansi'</span><span class="s3">\n</span><span class="s1">import formatWebpackMessages from '../../../../shared/lib/format-webpack-messages'</span><span class="s3">\n</span><span class="s1">import { useRouter } from '../../../components/navigation'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">REACT_REFRESH_FULL_RELOAD,</span><span class="s3">\n  </span><span class="s1">REACT_REFRESH_FULL_RELOAD_FROM_ERROR,</span><span class="s3">\n  </span><span class="s1">reportInvalidHmrMessage,</span><span class="s3">\n</span><span class="s1">} from '../shared'</span><span class="s3">\n</span><span class="s1">import { dispatcher } from 'next/dist/compiled/next-devtools'</span><span class="s3">\n</span><span class="s1">import { ReplaySsrOnlyErrors } from '../../../../next-devtools/userspace/app/errors/replay-ssr-only-errors'</span><span class="s3">\n</span><span class="s1">import { AppDevOverlayErrorBoundary } from '../../../../next-devtools/userspace/app/app-dev-overlay-error-boundary'</span><span class="s3">\n</span><span class="s1">import { useErrorHandler } from '../../../../next-devtools/userspace/app/errors/use-error-handler'</span><span class="s3">\n</span><span class="s1">import { RuntimeErrorHandler } from '../../runtime-error-handler'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">useSendMessage,</span><span class="s3">\n  </span><span class="s1">useTurbopack,</span><span class="s3">\n  </span><span class="s1">useWebsocket,</span><span class="s3">\n  </span><span class="s1">useWebsocketPing,</span><span class="s3">\n</span><span class="s1">} from './use-websocket'</span><span class="s3">\n</span><span class="s1">import { HMR_ACTIONS_SENT_TO_BROWSER } from '../../../../server/dev/hot-reloader-types'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">HMR_ACTION_TYPES,</span><span class="s3">\n  </span><span class="s1">TurbopackMsgToBrowser,</span><span class="s3">\n</span><span class="s1">} from '../../../../server/dev/hot-reloader-types'</span><span class="s3">\n</span><span class="s1">import { useUntrackedPathname } from '../../../components/navigation-untracked'</span><span class="s3">\n</span><span class="s1">import reportHmrLatency from '../../report-hmr-latency'</span><span class="s3">\n</span><span class="s1">import { TurbopackHmr } from '../turbopack-hot-reloader-common'</span><span class="s3">\n</span><span class="s1">import { NEXT_HMR_REFRESH_HASH_COOKIE } from '../../../components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import type { GlobalErrorState } from '../../../components/app-router-instance'</span><span class="s3">\n</span><span class="s1">import { useForwardConsoleLog } from '../../../../next-devtools/userspace/app/errors/use-forward-console-log'</span><span class="s3">\n\n</span><span class="s1">let mostRecentCompilationHash: any = null</span><span class="s3">\n</span><span class="s1">let __nextDevClientId = Math.round(Math.random() * 100 + Date.now())</span><span class="s3">\n</span><span class="s1">let reloading = false</span><span class="s3">\n</span><span class="s1">let webpackStartMsSinceEpoch: number | null = null</span><span class="s3">\n</span><span class="s1">const turbopackHmr: TurbopackHmr | null = process.env.TURBOPACK</span><span class="s3">\n  </span><span class="s1">? new TurbopackHmr()</span><span class="s3">\n  </span><span class="s1">: null</span><span class="s3">\n\n</span><span class="s1">let pendingHotUpdateWebpack = Promise.resolve()</span><span class="s3">\n</span><span class="s1">let resolvePendingHotUpdateWebpack: () =&gt; void = () =&gt; {}</span><span class="s3">\n</span><span class="s1">function setPendingHotUpdateWebpack() {</span><span class="s3">\n  </span><span class="s1">pendingHotUpdateWebpack = new Promise((resolve) =&gt; {</span><span class="s3">\n    </span><span class="s1">resolvePendingHotUpdateWebpack = () =&gt; {</span><span class="s3">\n      </span><span class="s1">resolve()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function waitForWebpackRuntimeHotUpdate() {</span><span class="s3">\n  </span><span class="s1">return pendingHotUpdateWebpack</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// There is a newer version of the code available.</span><span class="s3">\n</span><span class="s1">function handleAvailableHash(hash: string) {</span><span class="s3">\n  </span><span class="s1">// Update last known compilation hash.</span><span class="s3">\n  </span><span class="s1">mostRecentCompilationHash = hash</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Is there a newer version of this code available?</span><span class="s3">\n </span><span class="s1">* For webpack: Check if the hash changed compared to __webpack_hash__</span><span class="s3">\n </span><span class="s1">* For Turbopack: Always true because it doesn't have __webpack_hash__</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isUpdateAvailable() {</span><span class="s3">\n  </span><span class="s1">if (process.env.TURBOPACK) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/* globals __webpack_hash__ */</span><span class="s3">\n  </span><span class="s1">// __webpack_hash__ is the hash of the current compilation.</span><span class="s3">\n  </span><span class="s1">// It's a global variable injected by Webpack.</span><span class="s3">\n  </span><span class="s1">return mostRecentCompilationHash !== __webpack_hash__</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Webpack disallows updates in other states.</span><span class="s3">\n</span><span class="s1">function canApplyUpdates() {</span><span class="s3">\n  </span><span class="s1">return module.hot.status() === 'idle'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function afterApplyUpdates(fn: any) {</span><span class="s3">\n  </span><span class="s1">if (canApplyUpdates()) {</span><span class="s3">\n    </span><span class="s1">fn()</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">function handler(status: any) {</span><span class="s3">\n      </span><span class="s1">if (status === 'idle') {</span><span class="s3">\n        </span><span class="s1">module.hot.removeStatusHandler(handler)</span><span class="s3">\n        </span><span class="s1">fn()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">module.hot.addStatusHandler(handler)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function performFullReload(err: any, sendMessage: any) {</span><span class="s3">\n  </span><span class="s1">const stackTrace =</span><span class="s3">\n    </span><span class="s1">err &amp;&amp;</span><span class="s3">\n    </span><span class="s1">((err.stack &amp;&amp; err.stack.split('</span><span class="s3">\\</span><span class="s1">n').slice(0, 5).join('</span><span class="s3">\\</span><span class="s1">n')) ||</span><span class="s3">\n      </span><span class="s1">err.message ||</span><span class="s3">\n      </span><span class="s1">err + '')</span><span class="s3">\n\n  </span><span class="s1">sendMessage(</span><span class="s3">\n    </span><span class="s1">JSON.stringify({</span><span class="s3">\n      </span><span class="s1">event: 'client-full-reload',</span><span class="s3">\n      </span><span class="s1">stackTrace,</span><span class="s3">\n      </span><span class="s1">hadRuntimeError: !!RuntimeErrorHandler.hadRuntimeError,</span><span class="s3">\n      </span><span class="s1">dependencyChain: err ? err.dependencyChain : undefined,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (reloading) return</span><span class="s3">\n  </span><span class="s1">reloading = true</span><span class="s3">\n  </span><span class="s1">window.location.reload()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Attempt to update code on the fly, fall back to a hard reload.</span><span class="s3">\n</span><span class="s1">function tryApplyUpdatesWebpack(sendMessage: (message: string) =&gt; void) {</span><span class="s3">\n  </span><span class="s1">if (!isUpdateAvailable() || !canApplyUpdates()) {</span><span class="s3">\n    </span><span class="s1">resolvePendingHotUpdateWebpack()</span><span class="s3">\n    </span><span class="s1">dispatcher.onBuildOk()</span><span class="s3">\n    </span><span class="s1">reportHmrLatency(sendMessage, [], webpackStartMsSinceEpoch!, Date.now())</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function handleApplyUpdates(</span><span class="s3">\n    </span><span class="s1">err: any,</span><span class="s3">\n    </span><span class="s1">updatedModules: (string | number)[] | null</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (err || RuntimeErrorHandler.hadRuntimeError || updatedModules == null) {</span><span class="s3">\n      </span><span class="s1">if (err) {</span><span class="s3">\n        </span><span class="s1">console.warn(REACT_REFRESH_FULL_RELOAD)</span><span class="s3">\n      </span><span class="s1">} else if (RuntimeErrorHandler.hadRuntimeError) {</span><span class="s3">\n        </span><span class="s1">console.warn(REACT_REFRESH_FULL_RELOAD_FROM_ERROR)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">performFullReload(err, sendMessage)</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">dispatcher.onBuildOk()</span><span class="s3">\n\n    </span><span class="s1">if (isUpdateAvailable()) {</span><span class="s3">\n      </span><span class="s1">// While we were updating, there was a new update! Do it again.</span><span class="s3">\n      </span><span class="s1">tryApplyUpdatesWebpack(sendMessage)</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">dispatcher.onRefresh()</span><span class="s3">\n    </span><span class="s1">resolvePendingHotUpdateWebpack()</span><span class="s3">\n    </span><span class="s1">reportHmrLatency(</span><span class="s3">\n      </span><span class="s1">sendMessage,</span><span class="s3">\n      </span><span class="s1">updatedModules,</span><span class="s3">\n      </span><span class="s1">webpackStartMsSinceEpoch!,</span><span class="s3">\n      </span><span class="s1">Date.now()</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">if (process.env.__NEXT_TEST_MODE) {</span><span class="s3">\n      </span><span class="s1">afterApplyUpdates(() =&gt; {</span><span class="s3">\n        </span><span class="s1">if (self.__NEXT_HMR_CB) {</span><span class="s3">\n          </span><span class="s1">self.__NEXT_HMR_CB()</span><span class="s3">\n          </span><span class="s1">self.__NEXT_HMR_CB = null</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// https://webpack.js.org/api/hot-module-replacement/#check</span><span class="s3">\n  </span><span class="s1">module.hot</span><span class="s3">\n    </span><span class="s1">.check(/* autoApply */ false)</span><span class="s3">\n    </span><span class="s1">.then((updatedModules: (string | number)[] | null) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (updatedModules == null) {</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// We should always handle an update, even if updatedModules is empty (but</span><span class="s3">\n      </span><span class="s1">// non-null) for any reason. That's what webpack would normally do:</span><span class="s3">\n      </span><span class="s1">// https://github.com/webpack/webpack/blob/3aa6b6bc3a64/lib/hmr/HotModuleReplacement.runtime.js#L296-L298</span><span class="s3">\n      </span><span class="s1">dispatcher.onBeforeRefresh()</span><span class="s3">\n      </span><span class="s1">// https://webpack.js.org/api/hot-module-replacement/#apply</span><span class="s3">\n      </span><span class="s1">return module.hot.apply()</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">.then(</span><span class="s3">\n      </span><span class="s1">(updatedModules: (string | number)[] | null) =&gt; {</span><span class="s3">\n        </span><span class="s1">handleApplyUpdates(null, updatedModules)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">(err: any) =&gt; {</span><span class="s3">\n        </span><span class="s1">handleApplyUpdates(err, null)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/** Handles messages from the server for the App Router. */</span><span class="s3">\n</span><span class="s1">function processMessage(</span><span class="s3">\n  </span><span class="s1">obj: HMR_ACTION_TYPES,</span><span class="s3">\n  </span><span class="s1">sendMessage: (message: string) =&gt; void,</span><span class="s3">\n  </span><span class="s1">processTurbopackMessage: (msg: TurbopackMsgToBrowser) =&gt; void,</span><span class="s3">\n  </span><span class="s1">router: ReturnType&lt;typeof useRouter&gt;,</span><span class="s3">\n  </span><span class="s1">appIsrManifestRef: ReturnType&lt;typeof useRef&gt;,</span><span class="s3">\n  </span><span class="s1">pathnameRef: ReturnType&lt;typeof useRef&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!('action' in obj)) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function handleErrors(errors: ReadonlyArray&lt;unknown&gt;) {</span><span class="s3">\n    </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">Massage</span><span class="s3">\&quot; </span><span class="s1">webpack messages.</span><span class="s3">\n    </span><span class="s1">const formatted = formatWebpackMessages({</span><span class="s3">\n      </span><span class="s1">errors: errors,</span><span class="s3">\n      </span><span class="s1">warnings: [],</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">// Only show the first error.</span><span class="s3">\n    </span><span class="s1">dispatcher.onBuildError(formatted.errors[0])</span><span class="s3">\n\n    </span><span class="s1">// Also log them to the console.</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; formatted.errors.length; i++) {</span><span class="s3">\n      </span><span class="s1">console.error(stripAnsi(formatted.errors[i]))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Do not attempt to reload now.</span><span class="s3">\n    </span><span class="s1">// We will reload on next success instead.</span><span class="s3">\n    </span><span class="s1">if (process.env.__NEXT_TEST_MODE) {</span><span class="s3">\n      </span><span class="s1">if (self.__NEXT_HMR_CB) {</span><span class="s3">\n        </span><span class="s1">self.__NEXT_HMR_CB(formatted.errors[0])</span><span class="s3">\n        </span><span class="s1">self.__NEXT_HMR_CB = null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function handleHotUpdate() {</span><span class="s3">\n    </span><span class="s1">if (process.env.TURBOPACK) {</span><span class="s3">\n      </span><span class="s1">const hmrUpdate = turbopackHmr!.onBuilt()</span><span class="s3">\n      </span><span class="s1">if (hmrUpdate != null) {</span><span class="s3">\n        </span><span class="s1">reportHmrLatency(</span><span class="s3">\n          </span><span class="s1">sendMessage,</span><span class="s3">\n          </span><span class="s1">[...hmrUpdate.updatedModules],</span><span class="s3">\n          </span><span class="s1">hmrUpdate.startMsSinceEpoch,</span><span class="s3">\n          </span><span class="s1">hmrUpdate.endMsSinceEpoch,</span><span class="s3">\n          </span><span class="s1">// suppress the `client-hmr-latency` event if the update was a no-op:</span><span class="s3">\n          </span><span class="s1">hmrUpdate.hasUpdates</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">dispatcher.onBuildOk()</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">tryApplyUpdatesWebpack(sendMessage)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">switch (obj.action) {</span><span class="s3">\n    </span><span class="s1">case HMR_ACTIONS_SENT_TO_BROWSER.ISR_MANIFEST: {</span><span class="s3">\n      </span><span class="s1">if (process.env.__NEXT_DEV_INDICATOR) {</span><span class="s3">\n        </span><span class="s1">if (appIsrManifestRef) {</span><span class="s3">\n          </span><span class="s1">appIsrManifestRef.current = obj.data</span><span class="s3">\n\n          </span><span class="s1">// handle initial status on receiving manifest</span><span class="s3">\n          </span><span class="s1">// navigation is handled in useEffect for pathname changes</span><span class="s3">\n          </span><span class="s1">// as we'll receive the updated manifest before usePathname</span><span class="s3">\n          </span><span class="s1">// triggers for new value</span><span class="s3">\n          </span><span class="s1">if ((pathnameRef.current as string) in obj.data) {</span><span class="s3">\n            </span><span class="s1">dispatcher.onStaticIndicator(true)</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">dispatcher.onStaticIndicator(false)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case HMR_ACTIONS_SENT_TO_BROWSER.BUILDING: {</span><span class="s3">\n      </span><span class="s1">dispatcher.buildingIndicatorShow()</span><span class="s3">\n\n      </span><span class="s1">if (process.env.TURBOPACK) {</span><span class="s3">\n        </span><span class="s1">turbopackHmr!.onBuilding()</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">webpackStartMsSinceEpoch = Date.now()</span><span class="s3">\n        </span><span class="s1">setPendingHotUpdateWebpack()</span><span class="s3">\n        </span><span class="s1">console.log('[Fast Refresh] rebuilding')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case HMR_ACTIONS_SENT_TO_BROWSER.BUILT:</span><span class="s3">\n    </span><span class="s1">case HMR_ACTIONS_SENT_TO_BROWSER.SYNC: {</span><span class="s3">\n      </span><span class="s1">dispatcher.buildingIndicatorHide()</span><span class="s3">\n\n      </span><span class="s1">if (obj.hash) {</span><span class="s3">\n        </span><span class="s1">handleAvailableHash(obj.hash)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const { errors, warnings } = obj</span><span class="s3">\n\n      </span><span class="s1">// Is undefined when it's a 'built' event</span><span class="s3">\n      </span><span class="s1">if ('versionInfo' in obj) dispatcher.onVersionInfo(obj.versionInfo)</span><span class="s3">\n      </span><span class="s1">if ('debug' in obj &amp;&amp; obj.debug) dispatcher.onDebugInfo(obj.debug)</span><span class="s3">\n      </span><span class="s1">if ('devIndicator' in obj) dispatcher.onDevIndicator(obj.devIndicator)</span><span class="s3">\n      </span><span class="s1">if ('devToolsConfig' in obj)</span><span class="s3">\n        </span><span class="s1">dispatcher.onDevToolsConfig(obj.devToolsConfig)</span><span class="s3">\n\n      </span><span class="s1">const hasErrors = Boolean(errors &amp;&amp; errors.length)</span><span class="s3">\n      </span><span class="s1">// Compilation with errors (e.g. syntax error or missing modules).</span><span class="s3">\n      </span><span class="s1">if (hasErrors) {</span><span class="s3">\n        </span><span class="s1">sendMessage(</span><span class="s3">\n          </span><span class="s1">JSON.stringify({</span><span class="s3">\n            </span><span class="s1">event: 'client-error',</span><span class="s3">\n            </span><span class="s1">errorCount: errors.length,</span><span class="s3">\n            </span><span class="s1">clientId: __nextDevClientId,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">handleErrors(errors)</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const hasWarnings = Boolean(warnings &amp;&amp; warnings.length)</span><span class="s3">\n      </span><span class="s1">if (hasWarnings) {</span><span class="s3">\n        </span><span class="s1">sendMessage(</span><span class="s3">\n          </span><span class="s1">JSON.stringify({</span><span class="s3">\n            </span><span class="s1">event: 'client-warning',</span><span class="s3">\n            </span><span class="s1">warningCount: warnings.length,</span><span class="s3">\n            </span><span class="s1">clientId: __nextDevClientId,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// Print warnings to the console.</span><span class="s3">\n        </span><span class="s1">const formattedMessages = formatWebpackMessages({</span><span class="s3">\n          </span><span class="s1">warnings: warnings,</span><span class="s3">\n          </span><span class="s1">errors: [],</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">for (let i = 0; i &lt; formattedMessages.warnings.length; i++) {</span><span class="s3">\n          </span><span class="s1">if (i === 5) {</span><span class="s3">\n            </span><span class="s1">console.warn(</span><span class="s3">\n              </span><span class="s1">'There were more warnings in other files.</span><span class="s3">\\</span><span class="s1">n' +</span><span class="s3">\n                </span><span class="s1">'You can find a complete log in the terminal.'</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">console.warn(stripAnsi(formattedMessages.warnings[i]))</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// No early return here as we need to apply modules in the same way between warnings only and compiles without warnings</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">sendMessage(</span><span class="s3">\n        </span><span class="s1">JSON.stringify({</span><span class="s3">\n          </span><span class="s1">event: 'client-success',</span><span class="s3">\n          </span><span class="s1">clientId: __nextDevClientId,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">if (obj.action === HMR_ACTIONS_SENT_TO_BROWSER.BUILT) {</span><span class="s3">\n        </span><span class="s1">handleHotUpdate()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED: {</span><span class="s3">\n      </span><span class="s1">processTurbopackMessage({</span><span class="s3">\n        </span><span class="s1">type: HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED,</span><span class="s3">\n        </span><span class="s1">data: {</span><span class="s3">\n          </span><span class="s1">sessionId: obj.data.sessionId,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE: {</span><span class="s3">\n      </span><span class="s1">turbopackHmr!.onTurbopackMessage(obj)</span><span class="s3">\n      </span><span class="s1">dispatcher.onBeforeRefresh()</span><span class="s3">\n      </span><span class="s1">processTurbopackMessage({</span><span class="s3">\n        </span><span class="s1">type: HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE,</span><span class="s3">\n        </span><span class="s1">data: obj.data,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">if (RuntimeErrorHandler.hadRuntimeError) {</span><span class="s3">\n        </span><span class="s1">console.warn(REACT_REFRESH_FULL_RELOAD_FROM_ERROR)</span><span class="s3">\n        </span><span class="s1">performFullReload(null, sendMessage)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">dispatcher.onRefresh()</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// TODO-APP: make server component change more granular</span><span class="s3">\n    </span><span class="s1">case HMR_ACTIONS_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES: {</span><span class="s3">\n      </span><span class="s1">turbopackHmr?.onServerComponentChanges()</span><span class="s3">\n      </span><span class="s1">sendMessage(</span><span class="s3">\n        </span><span class="s1">JSON.stringify({</span><span class="s3">\n          </span><span class="s1">event: 'server-component-reload-page',</span><span class="s3">\n          </span><span class="s1">clientId: __nextDevClientId,</span><span class="s3">\n          </span><span class="s1">hash: obj.hash,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">// Store the latest hash in a session cookie so that it's sent back to the</span><span class="s3">\n      </span><span class="s1">// server with any subsequent requests.</span><span class="s3">\n      </span><span class="s1">document.cookie = `${NEXT_HMR_REFRESH_HASH_COOKIE}=${obj.hash};path=/`</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">RuntimeErrorHandler.hadRuntimeError ||</span><span class="s3">\n        </span><span class="s1">document.documentElement.id === '__next_error__'</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">if (reloading) return</span><span class="s3">\n        </span><span class="s1">reloading = true</span><span class="s3">\n        </span><span class="s1">return window.location.reload()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">startTransition(() =&gt; {</span><span class="s3">\n        </span><span class="s1">router.hmrRefresh()</span><span class="s3">\n        </span><span class="s1">dispatcher.onRefresh()</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">if (process.env.__NEXT_TEST_MODE) {</span><span class="s3">\n        </span><span class="s1">if (self.__NEXT_HMR_CB) {</span><span class="s3">\n          </span><span class="s1">self.__NEXT_HMR_CB()</span><span class="s3">\n          </span><span class="s1">self.__NEXT_HMR_CB = null</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE: {</span><span class="s3">\n      </span><span class="s1">turbopackHmr?.onReloadPage()</span><span class="s3">\n      </span><span class="s1">sendMessage(</span><span class="s3">\n        </span><span class="s1">JSON.stringify({</span><span class="s3">\n          </span><span class="s1">event: 'client-reload-page',</span><span class="s3">\n          </span><span class="s1">clientId: __nextDevClientId,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">if (reloading) return</span><span class="s3">\n      </span><span class="s1">reloading = true</span><span class="s3">\n      </span><span class="s1">return window.location.reload()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case HMR_ACTIONS_SENT_TO_BROWSER.ADDED_PAGE:</span><span class="s3">\n    </span><span class="s1">case HMR_ACTIONS_SENT_TO_BROWSER.REMOVED_PAGE: {</span><span class="s3">\n      </span><span class="s1">turbopackHmr?.onPageAddRemove()</span><span class="s3">\n      </span><span class="s1">// TODO-APP: potentially only refresh if the currently viewed page was added/removed.</span><span class="s3">\n      </span><span class="s1">return router.hmrRefresh()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case HMR_ACTIONS_SENT_TO_BROWSER.SERVER_ERROR: {</span><span class="s3">\n      </span><span class="s1">const { errorJSON } = obj</span><span class="s3">\n      </span><span class="s1">if (errorJSON) {</span><span class="s3">\n        </span><span class="s1">const { message, stack } = JSON.parse(errorJSON)</span><span class="s3">\n        </span><span class="s1">const error = new Error(message)</span><span class="s3">\n        </span><span class="s1">error.stack = stack</span><span class="s3">\n        </span><span class="s1">handleErrors([error])</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case HMR_ACTIONS_SENT_TO_BROWSER.DEV_PAGES_MANIFEST_UPDATE: {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case HMR_ACTIONS_SENT_TO_BROWSER.DEVTOOLS_CONFIG: {</span><span class="s3">\n      </span><span class="s1">dispatcher.onDevToolsConfig(obj.data)</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">default: {</span><span class="s3">\n      </span><span class="s1">obj satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default function HotReload({</span><span class="s3">\n  </span><span class="s1">assetPrefix,</span><span class="s3">\n  </span><span class="s1">children,</span><span class="s3">\n  </span><span class="s1">globalError,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">assetPrefix: string</span><span class="s3">\n  </span><span class="s1">children: ReactNode</span><span class="s3">\n  </span><span class="s1">globalError: GlobalErrorState</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">useErrorHandler(dispatcher.onUnhandledError, dispatcher.onUnhandledRejection)</span><span class="s3">\n\n  </span><span class="s1">const webSocketRef = useWebsocket(assetPrefix)</span><span class="s3">\n\n  </span><span class="s1">useWebsocketPing(webSocketRef)</span><span class="s3">\n  </span><span class="s1">const sendMessage = useSendMessage(webSocketRef)</span><span class="s3">\n  </span><span class="s1">useForwardConsoleLog(webSocketRef)</span><span class="s3">\n  </span><span class="s1">const processTurbopackMessage = useTurbopack(sendMessage, (err) =&gt;</span><span class="s3">\n    </span><span class="s1">performFullReload(err, sendMessage)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const router = useRouter()</span><span class="s3">\n\n  </span><span class="s1">// We don't want access of the pathname for the dev tools to trigger a dynamic</span><span class="s3">\n  </span><span class="s1">// access (as the dev overlay will never be present in production).</span><span class="s3">\n  </span><span class="s1">const pathname = useUntrackedPathname()</span><span class="s3">\n  </span><span class="s1">const appIsrManifestRef = useRef&lt;Record&lt;string, false | number&gt;&gt;({})</span><span class="s3">\n  </span><span class="s1">const pathnameRef = useRef(pathname)</span><span class="s3">\n\n  </span><span class="s1">if (process.env.__NEXT_DEV_INDICATOR) {</span><span class="s3">\n    </span><span class="s1">// this conditional is only for dead-code elimination which</span><span class="s3">\n    </span><span class="s1">// isn't a runtime conditional only build-time so ignore hooks rule</span><span class="s3">\n    </span><span class="s1">// eslint-disable-next-line react-hooks/rules-of-hooks</span><span class="s3">\n    </span><span class="s1">useEffect(() =&gt; {</span><span class="s3">\n      </span><span class="s1">pathnameRef.current = pathname</span><span class="s3">\n\n      </span><span class="s1">const appIsrManifest = appIsrManifestRef.current</span><span class="s3">\n\n      </span><span class="s1">if (appIsrManifest) {</span><span class="s3">\n        </span><span class="s1">if (pathname &amp;&amp; pathname in appIsrManifest) {</span><span class="s3">\n          </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">dispatcher.onStaticIndicator(true)</span><span class="s3">\n          </span><span class="s1">} catch (reason) {</span><span class="s3">\n            </span><span class="s1">let message = ''</span><span class="s3">\n\n            </span><span class="s1">if (reason instanceof DOMException) {</span><span class="s3">\n              </span><span class="s1">// Most likely a SecurityError, because of an unavailable localStorage</span><span class="s3">\n              </span><span class="s1">message = reason.stack ?? reason.message</span><span class="s3">\n            </span><span class="s1">} else if (reason instanceof Error) {</span><span class="s3">\n              </span><span class="s1">message = 'Error: ' + reason.message + '</span><span class="s3">\\</span><span class="s1">n' + (reason.stack ?? '')</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">message = 'Unexpected Exception: ' + reason</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">console.warn('[HMR] ' + message)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">dispatcher.onStaticIndicator(false)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, [pathname])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">useEffect(() =&gt; {</span><span class="s3">\n    </span><span class="s1">const websocket = webSocketRef.current</span><span class="s3">\n    </span><span class="s1">if (!websocket) return</span><span class="s3">\n\n    </span><span class="s1">const handler = (event: MessageEvent&lt;any&gt;) =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const obj = JSON.parse(event.data)</span><span class="s3">\n        </span><span class="s1">processMessage(</span><span class="s3">\n          </span><span class="s1">obj,</span><span class="s3">\n          </span><span class="s1">sendMessage,</span><span class="s3">\n          </span><span class="s1">processTurbopackMessage,</span><span class="s3">\n          </span><span class="s1">router,</span><span class="s3">\n          </span><span class="s1">appIsrManifestRef,</span><span class="s3">\n          </span><span class="s1">pathnameRef</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} catch (err: unknown) {</span><span class="s3">\n        </span><span class="s1">reportInvalidHmrMessage(event, err)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">websocket.addEventListener('message', handler)</span><span class="s3">\n    </span><span class="s1">return () =&gt; websocket.removeEventListener('message', handler)</span><span class="s3">\n  </span><span class="s1">}, [</span><span class="s3">\n    </span><span class="s1">sendMessage,</span><span class="s3">\n    </span><span class="s1">router,</span><span class="s3">\n    </span><span class="s1">webSocketRef,</span><span class="s3">\n    </span><span class="s1">processTurbopackMessage,</span><span class="s3">\n    </span><span class="s1">appIsrManifestRef,</span><span class="s3">\n  </span><span class="s1">])</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">&lt;AppDevOverlayErrorBoundary globalError={globalError}&gt;</span><span class="s3">\n      </span><span class="s1">&lt;ReplaySsrOnlyErrors onBlockingError={dispatcher.openErrorOverlay} /&gt;</span><span class="s3">\n      </span><span class="s1">{children}</span><span class="s3">\n    </span><span class="s1">&lt;/AppDevOverlayErrorBoundary&gt;</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;HotReload&quot;</span><span class="s0">,</span><span class="s1">&quot;waitForWebpackRuntimeHotUpdate&quot;</span><span class="s0">,</span><span class="s1">&quot;mostRecentCompilationHash&quot;</span><span class="s0">,</span><span class="s1">&quot;__nextDevClientId&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;round&quot;</span><span class="s0">,</span><span class="s1">&quot;random&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;reloading&quot;</span><span class="s0">,</span><span class="s1">&quot;webpackStartMsSinceEpoch&quot;</span><span class="s0">,</span><span class="s1">&quot;turbopackHmr&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;TURBOPACK&quot;</span><span class="s0">,</span><span class="s1">&quot;TurbopackHmr&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingHotUpdateWebpack&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvePendingHotUpdateWebpack&quot;</span><span class="s0">,</span><span class="s1">&quot;setPendingHotUpdateWebpack&quot;</span><span class="s0">,</span><span class="s1">&quot;handleAvailableHash&quot;</span><span class="s0">,</span><span class="s1">&quot;hash&quot;</span><span class="s0">,</span><span class="s1">&quot;isUpdateAvailable&quot;</span><span class="s0">,</span><span class="s1">&quot;__webpack_hash__&quot;</span><span class="s0">,</span><span class="s1">&quot;canApplyUpdates&quot;</span><span class="s0">,</span><span class="s1">&quot;module&quot;</span><span class="s0">,</span><span class="s1">&quot;hot&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;afterApplyUpdates&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;handler&quot;</span><span class="s0">,</span><span class="s1">&quot;removeStatusHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;addStatusHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;performFullReload&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;sendMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;stackTrace&quot;</span><span class="s0">,</span><span class="s1">&quot;stack&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;event&quot;</span><span class="s0">,</span><span class="s1">&quot;hadRuntimeError&quot;</span><span class="s0">,</span><span class="s1">&quot;RuntimeErrorHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;dependencyChain&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;reload&quot;</span><span class="s0">,</span><span class="s1">&quot;tryApplyUpdatesWebpack&quot;</span><span class="s0">,</span><span class="s1">&quot;dispatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;onBuildOk&quot;</span><span class="s0">,</span><span class="s1">&quot;reportHmrLatency&quot;</span><span class="s0">,</span><span class="s1">&quot;handleApplyUpdates&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedModules&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;warn&quot;</span><span class="s0">,</span><span class="s1">&quot;REACT_REFRESH_FULL_RELOAD&quot;</span><span class="s0">,</span><span class="s1">&quot;REACT_REFRESH_FULL_RELOAD_FROM_ERROR&quot;</span><span class="s0">,</span><span class="s1">&quot;onRefresh&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_TEST_MODE&quot;</span><span class="s0">,</span><span class="s1">&quot;self&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_HMR_CB&quot;</span><span class="s0">,</span><span class="s1">&quot;check&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;onBeforeRefresh&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;processMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;processTurbopackMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;router&quot;</span><span class="s0">,</span><span class="s1">&quot;appIsrManifestRef&quot;</span><span class="s0">,</span><span class="s1">&quot;pathnameRef&quot;</span><span class="s0">,</span><span class="s1">&quot;handleErrors&quot;</span><span class="s0">,</span><span class="s1">&quot;errors&quot;</span><span class="s0">,</span><span class="s1">&quot;formatted&quot;</span><span class="s0">,</span><span class="s1">&quot;formatWebpackMessages&quot;</span><span class="s0">,</span><span class="s1">&quot;warnings&quot;</span><span class="s0">,</span><span class="s1">&quot;onBuildError&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;stripAnsi&quot;</span><span class="s0">,</span><span class="s1">&quot;handleHotUpdate&quot;</span><span class="s0">,</span><span class="s1">&quot;hmrUpdate&quot;</span><span class="s0">,</span><span class="s1">&quot;onBuilt&quot;</span><span class="s0">,</span><span class="s1">&quot;startMsSinceEpoch&quot;</span><span class="s0">,</span><span class="s1">&quot;endMsSinceEpoch&quot;</span><span class="s0">,</span><span class="s1">&quot;hasUpdates&quot;</span><span class="s0">,</span><span class="s1">&quot;action&quot;</span><span class="s0">,</span><span class="s1">&quot;HMR_ACTIONS_SENT_TO_BROWSER&quot;</span><span class="s0">,</span><span class="s1">&quot;ISR_MANIFEST&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_DEV_INDICATOR&quot;</span><span class="s0">,</span><span class="s1">&quot;current&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;onStaticIndicator&quot;</span><span class="s0">,</span><span class="s1">&quot;BUILDING&quot;</span><span class="s0">,</span><span class="s1">&quot;buildingIndicatorShow&quot;</span><span class="s0">,</span><span class="s1">&quot;onBuilding&quot;</span><span class="s0">,</span><span class="s1">&quot;log&quot;</span><span class="s0">,</span><span class="s1">&quot;BUILT&quot;</span><span class="s0">,</span><span class="s1">&quot;SYNC&quot;</span><span class="s0">,</span><span class="s1">&quot;buildingIndicatorHide&quot;</span><span class="s0">,</span><span class="s1">&quot;onVersionInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;versionInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;debug&quot;</span><span class="s0">,</span><span class="s1">&quot;onDebugInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;onDevIndicator&quot;</span><span class="s0">,</span><span class="s1">&quot;devIndicator&quot;</span><span class="s0">,</span><span class="s1">&quot;onDevToolsConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;devToolsConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;hasErrors&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">,</span><span class="s1">&quot;errorCount&quot;</span><span class="s0">,</span><span class="s1">&quot;clientId&quot;</span><span class="s0">,</span><span class="s1">&quot;hasWarnings&quot;</span><span class="s0">,</span><span class="s1">&quot;warningCount&quot;</span><span class="s0">,</span><span class="s1">&quot;formattedMessages&quot;</span><span class="s0">,</span><span class="s1">&quot;TURBOPACK_CONNECTED&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;sessionId&quot;</span><span class="s0">,</span><span class="s1">&quot;TURBOPACK_MESSAGE&quot;</span><span class="s0">,</span><span class="s1">&quot;onTurbopackMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;SERVER_COMPONENT_CHANGES&quot;</span><span class="s0">,</span><span class="s1">&quot;onServerComponentChanges&quot;</span><span class="s0">,</span><span class="s1">&quot;document&quot;</span><span class="s0">,</span><span class="s1">&quot;cookie&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_HMR_REFRESH_HASH_COOKIE&quot;</span><span class="s0">,</span><span class="s1">&quot;documentElement&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;startTransition&quot;</span><span class="s0">,</span><span class="s1">&quot;hmrRefresh&quot;</span><span class="s0">,</span><span class="s1">&quot;RELOAD_PAGE&quot;</span><span class="s0">,</span><span class="s1">&quot;onReloadPage&quot;</span><span class="s0">,</span><span class="s1">&quot;ADDED_PAGE&quot;</span><span class="s0">,</span><span class="s1">&quot;REMOVED_PAGE&quot;</span><span class="s0">,</span><span class="s1">&quot;onPageAddRemove&quot;</span><span class="s0">,</span><span class="s1">&quot;SERVER_ERROR&quot;</span><span class="s0">,</span><span class="s1">&quot;errorJSON&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;DEV_PAGES_MANIFEST_UPDATE&quot;</span><span class="s0">,</span><span class="s1">&quot;DEVTOOLS_CONFIG&quot;</span><span class="s0">,</span><span class="s1">&quot;assetPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;globalError&quot;</span><span class="s0">,</span><span class="s1">&quot;useErrorHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;onUnhandledError&quot;</span><span class="s0">,</span><span class="s1">&quot;onUnhandledRejection&quot;</span><span class="s0">,</span><span class="s1">&quot;webSocketRef&quot;</span><span class="s0">,</span><span class="s1">&quot;useWebsocket&quot;</span><span class="s0">,</span><span class="s1">&quot;useWebsocketPing&quot;</span><span class="s0">,</span><span class="s1">&quot;useSendMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;useForwardConsoleLog&quot;</span><span class="s0">,</span><span class="s1">&quot;useTurbopack&quot;</span><span class="s0">,</span><span class="s1">&quot;useRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;useUntrackedPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;useRef&quot;</span><span class="s0">,</span><span class="s1">&quot;useEffect&quot;</span><span class="s0">,</span><span class="s1">&quot;appIsrManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;reason&quot;</span><span class="s0">,</span><span class="s1">&quot;DOMException&quot;</span><span class="s0">,</span><span class="s1">&quot;websocket&quot;</span><span class="s0">,</span><span class="s1">&quot;reportInvalidHmrMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;addEventListener&quot;</span><span class="s0">,</span><span class="s1">&quot;removeEventListener&quot;</span><span class="s0">,</span><span class="s1">&quot;AppDevOverlayErrorBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;ReplaySsrOnlyErrors&quot;</span><span class="s0">,</span><span class="s1">&quot;onBlockingError&quot;</span><span class="s0">,</span><span class="s1">&quot;openErrorOverlay&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">6451</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/app-router.tsx&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;'use client'</span><span class="s3">\n\n</span><span class="s1">import React, {</span><span class="s3">\n  </span><span class="s1">useEffect,</span><span class="s3">\n  </span><span class="s1">useMemo,</span><span class="s3">\n  </span><span class="s1">startTransition,</span><span class="s3">\n  </span><span class="s1">useInsertionEffect,</span><span class="s3">\n  </span><span class="s1">useDeferredValue,</span><span class="s3">\n</span><span class="s1">} from 'react'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">AppRouterContext,</span><span class="s3">\n  </span><span class="s1">LayoutRouterContext,</span><span class="s3">\n  </span><span class="s1">GlobalLayoutRouterContext,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type { CacheNode } from '../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { ACTION_RESTORE } from './router-reducer/router-reducer-types'</span><span class="s3">\n</span><span class="s1">import type { AppRouterState } from './router-reducer/router-reducer-types'</span><span class="s3">\n</span><span class="s1">import { createHrefFromUrl } from './router-reducer/create-href-from-url'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">SearchParamsContext,</span><span class="s3">\n  </span><span class="s1">PathnameContext,</span><span class="s3">\n  </span><span class="s1">PathParamsContext,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/hooks-client-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { dispatchAppRouterAction, useActionQueue } from './use-action-queue'</span><span class="s3">\n</span><span class="s1">import { isBot } from '../../shared/lib/router/utils/is-bot'</span><span class="s3">\n</span><span class="s1">import { addBasePath } from '../add-base-path'</span><span class="s3">\n</span><span class="s1">import { AppRouterAnnouncer } from './app-router-announcer'</span><span class="s3">\n</span><span class="s1">import { RedirectBoundary } from './redirect-boundary'</span><span class="s3">\n</span><span class="s1">import { findHeadInCache } from './router-reducer/reducers/find-head-in-cache'</span><span class="s3">\n</span><span class="s1">import { unresolvedThenable } from './unresolved-thenable'</span><span class="s3">\n</span><span class="s1">import { removeBasePath } from '../remove-base-path'</span><span class="s3">\n</span><span class="s1">import { hasBasePath } from '../has-base-path'</span><span class="s3">\n</span><span class="s1">import { getSelectedParams } from './router-reducer/compute-changed-path'</span><span class="s3">\n</span><span class="s1">import type { FlightRouterState } from '../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { useNavFailureHandler } from './nav-failure-handler'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">dispatchTraverseAction,</span><span class="s3">\n  </span><span class="s1">publicAppRouterInstance,</span><span class="s3">\n  </span><span class="s1">type AppRouterActionQueue,</span><span class="s3">\n  </span><span class="s1">type GlobalErrorState,</span><span class="s3">\n</span><span class="s1">} from './app-router-instance'</span><span class="s3">\n</span><span class="s1">import { getRedirectTypeFromError, getURLFromRedirectError } from './redirect'</span><span class="s3">\n</span><span class="s1">import { isRedirectError, RedirectType } from './redirect-error'</span><span class="s3">\n</span><span class="s1">import { pingVisibleLinks } from './links'</span><span class="s3">\n</span><span class="s1">import RootErrorBoundary from './errors/root-error-boundary'</span><span class="s3">\n</span><span class="s1">import DefaultGlobalError from './builtin/global-error'</span><span class="s3">\n</span><span class="s1">import { RootLayoutBoundary } from '../../lib/framework/boundary-components'</span><span class="s3">\n\n</span><span class="s1">const globalMutable: {</span><span class="s3">\n  </span><span class="s1">pendingMpaPath?: string</span><span class="s3">\n</span><span class="s1">} = {}</span><span class="s3">\n\n</span><span class="s1">export function isExternalURL(url: URL) {</span><span class="s3">\n  </span><span class="s1">return url.origin !== window.location.origin</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Given a link href, constructs the URL that should be prefetched. Returns null</span><span class="s3">\n </span><span class="s1">* in cases where prefetching should be disabled, like external URLs, or</span><span class="s3">\n </span><span class="s1">* during development.</span><span class="s3">\n </span><span class="s1">* @param href The href passed to &lt;Link&gt;, router.prefetch(), or similar</span><span class="s3">\n </span><span class="s1">* @returns A URL object to prefetch, or null if prefetching should be disabled</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function createPrefetchURL(href: string): URL | null {</span><span class="s3">\n  </span><span class="s1">// Don't prefetch for bots as they don't navigate.</span><span class="s3">\n  </span><span class="s1">if (isBot(window.navigator.userAgent)) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let url: URL</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">url = new URL(addBasePath(href), window.location.href)</span><span class="s3">\n  </span><span class="s1">} catch (_) {</span><span class="s3">\n    </span><span class="s1">// TODO: Does this need to throw or can we just console.error instead? Does</span><span class="s3">\n    </span><span class="s1">// anyone rely on this throwing? (Seems unlikely.)</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Cannot prefetch '${href}' because it cannot be converted to a URL.`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Don't prefetch during development (improves compilation performance)</span><span class="s3">\n  </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// External urls can't be prefetched in the same way.</span><span class="s3">\n  </span><span class="s1">if (isExternalURL(url)) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return url</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function HistoryUpdater({</span><span class="s3">\n  </span><span class="s1">appRouterState,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">appRouterState: AppRouterState</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">useInsertionEffect(() =&gt; {</span><span class="s3">\n    </span><span class="s1">if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {</span><span class="s3">\n      </span><span class="s1">// clear pending URL as navigation is no longer</span><span class="s3">\n      </span><span class="s1">// in flight</span><span class="s3">\n      </span><span class="s1">window.next.__pendingUrl = undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const { tree, pushRef, canonicalUrl } = appRouterState</span><span class="s3">\n    </span><span class="s1">const historyState = {</span><span class="s3">\n      </span><span class="s1">...(pushRef.preserveCustomHistoryState ? window.history.state : {}),</span><span class="s3">\n      </span><span class="s1">// Identifier is shortened intentionally.</span><span class="s3">\n      </span><span class="s1">// __NA is used to identify if the history entry can be handled by the app-router.</span><span class="s3">\n      </span><span class="s1">// __N is used to identify if the history entry can be handled by the old router.</span><span class="s3">\n      </span><span class="s1">__NA: true,</span><span class="s3">\n      </span><span class="s1">__PRIVATE_NEXTJS_INTERNALS_TREE: tree,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">pushRef.pendingPush &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Skip pushing an additional history entry if the canonicalUrl is the same as the current url.</span><span class="s3">\n      </span><span class="s1">// This mirrors the browser behavior for normal navigation.</span><span class="s3">\n      </span><span class="s1">createHrefFromUrl(new URL(window.location.href)) !== canonicalUrl</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.</span><span class="s3">\n      </span><span class="s1">pushRef.pendingPush = false</span><span class="s3">\n      </span><span class="s1">window.history.pushState(historyState, '', canonicalUrl)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">window.history.replaceState(historyState, '', canonicalUrl)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, [appRouterState])</span><span class="s3">\n\n  </span><span class="s1">useEffect(() =&gt; {</span><span class="s3">\n    </span><span class="s1">// The Next-Url and the base tree may affect the result of a prefetch</span><span class="s3">\n    </span><span class="s1">// task. Re-prefetch all visible links with the updated values. In most</span><span class="s3">\n    </span><span class="s1">// cases, this will not result in any new network requests, only if</span><span class="s3">\n    </span><span class="s1">// the prefetch result actually varies on one of these inputs.</span><span class="s3">\n    </span><span class="s1">if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {</span><span class="s3">\n      </span><span class="s1">pingVisibleLinks(appRouterState.nextUrl, appRouterState.tree)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, [appRouterState.nextUrl, appRouterState.tree])</span><span class="s3">\n\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createEmptyCacheNode(): CacheNode {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">lazyData: null,</span><span class="s3">\n    </span><span class="s1">rsc: null,</span><span class="s3">\n    </span><span class="s1">prefetchRsc: null,</span><span class="s3">\n    </span><span class="s1">head: null,</span><span class="s3">\n    </span><span class="s1">prefetchHead: null,</span><span class="s3">\n    </span><span class="s1">parallelRoutes: new Map(),</span><span class="s3">\n    </span><span class="s1">loading: null,</span><span class="s3">\n    </span><span class="s1">navigatedAt: -1,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function copyNextJsInternalHistoryState(data: any) {</span><span class="s3">\n  </span><span class="s1">if (data == null) data = {}</span><span class="s3">\n  </span><span class="s1">const currentState = window.history.state</span><span class="s3">\n  </span><span class="s1">const __NA = currentState?.__NA</span><span class="s3">\n  </span><span class="s1">if (__NA) {</span><span class="s3">\n    </span><span class="s1">data.__NA = __NA</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const __PRIVATE_NEXTJS_INTERNALS_TREE =</span><span class="s3">\n    </span><span class="s1">currentState?.__PRIVATE_NEXTJS_INTERNALS_TREE</span><span class="s3">\n  </span><span class="s1">if (__PRIVATE_NEXTJS_INTERNALS_TREE) {</span><span class="s3">\n    </span><span class="s1">data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return data</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function Head({</span><span class="s3">\n  </span><span class="s1">headCacheNode,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">headCacheNode: CacheNode | null</span><span class="s3">\n</span><span class="s1">}): React.ReactNode {</span><span class="s3">\n  </span><span class="s1">// If this segment has a `prefetchHead`, it's the statically prefetched data.</span><span class="s3">\n  </span><span class="s1">// We should use that on initial render instead of `head`. Then we'll switch</span><span class="s3">\n  </span><span class="s1">// to `head` when the dynamic response streams in.</span><span class="s3">\n  </span><span class="s1">const head = headCacheNode !== null ? headCacheNode.head : null</span><span class="s3">\n  </span><span class="s1">const prefetchHead =</span><span class="s3">\n    </span><span class="s1">headCacheNode !== null ? headCacheNode.prefetchHead : null</span><span class="s3">\n\n  </span><span class="s1">// If no prefetch data is available, then we go straight to rendering `head`.</span><span class="s3">\n  </span><span class="s1">const resolvedPrefetchRsc = prefetchHead !== null ? prefetchHead : head</span><span class="s3">\n\n  </span><span class="s1">// We use `useDeferredValue` to handle switching between the prefetched and</span><span class="s3">\n  </span><span class="s1">// final values. The second argument is returned on initial render, then it</span><span class="s3">\n  </span><span class="s1">// re-renders with the first argument.</span><span class="s3">\n  </span><span class="s1">return useDeferredValue(head, resolvedPrefetchRsc)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The global router that wraps the application components.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function Router({</span><span class="s3">\n  </span><span class="s1">actionQueue,</span><span class="s3">\n  </span><span class="s1">assetPrefix,</span><span class="s3">\n  </span><span class="s1">globalError,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">actionQueue: AppRouterActionQueue</span><span class="s3">\n  </span><span class="s1">assetPrefix: string</span><span class="s3">\n  </span><span class="s1">globalError: GlobalErrorState</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">const state = useActionQueue(actionQueue)</span><span class="s3">\n  </span><span class="s1">const { canonicalUrl } = state</span><span class="s3">\n  </span><span class="s1">// Add memoized pathname/query for useSearchParams and usePathname.</span><span class="s3">\n  </span><span class="s1">const { searchParams, pathname } = useMemo(() =&gt; {</span><span class="s3">\n    </span><span class="s1">const url = new URL(</span><span class="s3">\n      </span><span class="s1">canonicalUrl,</span><span class="s3">\n      </span><span class="s1">typeof window === 'undefined' ? 'http://n' : window.location.href</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">// This is turned into a readonly class in `useSearchParams`</span><span class="s3">\n      </span><span class="s1">searchParams: url.searchParams,</span><span class="s3">\n      </span><span class="s1">pathname: hasBasePath(url.pathname)</span><span class="s3">\n        </span><span class="s1">? removeBasePath(url.pathname)</span><span class="s3">\n        </span><span class="s1">: url.pathname,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, [canonicalUrl])</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n    </span><span class="s1">// eslint-disable-next-line react-hooks/rules-of-hooks</span><span class="s3">\n    </span><span class="s1">const { cache, prefetchCache, tree } = state</span><span class="s3">\n\n    </span><span class="s1">// This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes</span><span class="s3">\n    </span><span class="s1">// eslint-disable-next-line react-hooks/rules-of-hooks</span><span class="s3">\n    </span><span class="s1">useEffect(() =&gt; {</span><span class="s3">\n      </span><span class="s1">// Add `window.nd` for debugging purposes.</span><span class="s3">\n      </span><span class="s1">// This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.</span><span class="s3">\n      </span><span class="s1">// @ts-ignore this is for debugging</span><span class="s3">\n      </span><span class="s1">window.nd = {</span><span class="s3">\n        </span><span class="s1">router: publicAppRouterInstance,</span><span class="s3">\n        </span><span class="s1">cache,</span><span class="s3">\n        </span><span class="s1">prefetchCache,</span><span class="s3">\n        </span><span class="s1">tree,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, [cache, prefetchCache, tree])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">useEffect(() =&gt; {</span><span class="s3">\n    </span><span class="s1">// If the app is restored from bfcache, it's possible that</span><span class="s3">\n    </span><span class="s1">// pushRef.mpaNavigation is true, which would mean that any re-render of this component</span><span class="s3">\n    </span><span class="s1">// would trigger the mpa navigation logic again from the lines below.</span><span class="s3">\n    </span><span class="s1">// This will restore the router to the initial state in the event that the app is restored from bfcache.</span><span class="s3">\n    </span><span class="s1">function handlePageShow(event: PageTransitionEvent) {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!event.persisted ||</span><span class="s3">\n        </span><span class="s1">!window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Clear the pendingMpaPath value so that a subsequent MPA navigation to the same URL can be triggered.</span><span class="s3">\n      </span><span class="s1">// This is necessary because if the browser restored from bfcache, the pendingMpaPath would still be set to the value</span><span class="s3">\n      </span><span class="s1">// of the last MPA navigation.</span><span class="s3">\n      </span><span class="s1">globalMutable.pendingMpaPath = undefined</span><span class="s3">\n\n      </span><span class="s1">dispatchAppRouterAction({</span><span class="s3">\n        </span><span class="s1">type: ACTION_RESTORE,</span><span class="s3">\n        </span><span class="s1">url: new URL(window.location.href),</span><span class="s3">\n        </span><span class="s1">tree: window.history.state.__PRIVATE_NEXTJS_INTERNALS_TREE,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">window.addEventListener('pageshow', handlePageShow)</span><span class="s3">\n\n    </span><span class="s1">return () =&gt; {</span><span class="s3">\n      </span><span class="s1">window.removeEventListener('pageshow', handlePageShow)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, [])</span><span class="s3">\n\n  </span><span class="s1">useEffect(() =&gt; {</span><span class="s3">\n    </span><span class="s1">// Ensure that any redirect errors that bubble up outside of the RedirectBoundary</span><span class="s3">\n    </span><span class="s1">// are caught and handled by the router.</span><span class="s3">\n    </span><span class="s1">function handleUnhandledRedirect(</span><span class="s3">\n      </span><span class="s1">event: ErrorEvent | PromiseRejectionEvent</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const error = 'reason' in event ? event.reason : event.error</span><span class="s3">\n      </span><span class="s1">if (isRedirectError(error)) {</span><span class="s3">\n        </span><span class="s1">event.preventDefault()</span><span class="s3">\n        </span><span class="s1">const url = getURLFromRedirectError(error)</span><span class="s3">\n        </span><span class="s1">const redirectType = getRedirectTypeFromError(error)</span><span class="s3">\n        </span><span class="s1">// TODO: This should access the router methods directly, rather than</span><span class="s3">\n        </span><span class="s1">// go through the public interface.</span><span class="s3">\n        </span><span class="s1">if (redirectType === RedirectType.push) {</span><span class="s3">\n          </span><span class="s1">publicAppRouterInstance.push(url, {})</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">publicAppRouterInstance.replace(url, {})</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">window.addEventListener('error', handleUnhandledRedirect)</span><span class="s3">\n    </span><span class="s1">window.addEventListener('unhandledrejection', handleUnhandledRedirect)</span><span class="s3">\n\n    </span><span class="s1">return () =&gt; {</span><span class="s3">\n      </span><span class="s1">window.removeEventListener('error', handleUnhandledRedirect)</span><span class="s3">\n      </span><span class="s1">window.removeEventListener('unhandledrejection', handleUnhandledRedirect)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, [])</span><span class="s3">\n\n  </span><span class="s1">// When mpaNavigation flag is set do a hard navigation to the new url.</span><span class="s3">\n  </span><span class="s1">// Infinitely suspend because we don't actually want to rerender any child</span><span class="s3">\n  </span><span class="s1">// components with the new URL and any entangled state updates shouldn't</span><span class="s3">\n  </span><span class="s1">// commit either (eg: useTransition isPending should stay true until the page</span><span class="s3">\n  </span><span class="s1">// unloads).</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// This is a side effect in render. Don't try this at home, kids. It's</span><span class="s3">\n  </span><span class="s1">// probably safe because we know this is a singleton component and it's never</span><span class="s3">\n  </span><span class="s1">// in &lt;Offscreen&gt;. At least I hope so. (It will run twice in dev strict mode,</span><span class="s3">\n  </span><span class="s1">// but that's... fine?)</span><span class="s3">\n  </span><span class="s1">const { pushRef } = state</span><span class="s3">\n  </span><span class="s1">if (pushRef.mpaNavigation) {</span><span class="s3">\n    </span><span class="s1">// if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL</span><span class="s3">\n    </span><span class="s1">if (globalMutable.pendingMpaPath !== canonicalUrl) {</span><span class="s3">\n      </span><span class="s1">const location = window.location</span><span class="s3">\n      </span><span class="s1">if (pushRef.pendingPush) {</span><span class="s3">\n        </span><span class="s1">location.assign(canonicalUrl)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">location.replace(canonicalUrl)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">globalMutable.pendingMpaPath = canonicalUrl</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// TODO-APP: Should we listen to navigateerror here to catch failed</span><span class="s3">\n    </span><span class="s1">// navigations somehow? And should we call window.stop() if a SPA navigation</span><span class="s3">\n    </span><span class="s1">// should interrupt an MPA one?</span><span class="s3">\n    </span><span class="s1">// NOTE: This is intentionally using `throw` instead of `use` because we're</span><span class="s3">\n    </span><span class="s1">// inside an externally mutable condition (pushRef.mpaNavigation), which</span><span class="s3">\n    </span><span class="s1">// violates the rules of hooks.</span><span class="s3">\n    </span><span class="s1">throw unresolvedThenable</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">useEffect(() =&gt; {</span><span class="s3">\n    </span><span class="s1">const originalPushState = window.history.pushState.bind(window.history)</span><span class="s3">\n    </span><span class="s1">const originalReplaceState = window.history.replaceState.bind(</span><span class="s3">\n      </span><span class="s1">window.history</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">// Ensure the canonical URL in the Next.js Router is updated when the URL is changed so that `usePathname` and `useSearchParams` hold the pushed values.</span><span class="s3">\n    </span><span class="s1">const applyUrlFromHistoryPushReplace = (</span><span class="s3">\n      </span><span class="s1">url: string | URL | null | undefined</span><span class="s3">\n    </span><span class="s1">) =&gt; {</span><span class="s3">\n      </span><span class="s1">const href = window.location.href</span><span class="s3">\n      </span><span class="s1">const tree: FlightRouterState | undefined =</span><span class="s3">\n        </span><span class="s1">window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE</span><span class="s3">\n\n      </span><span class="s1">startTransition(() =&gt; {</span><span class="s3">\n        </span><span class="s1">dispatchAppRouterAction({</span><span class="s3">\n          </span><span class="s1">type: ACTION_RESTORE,</span><span class="s3">\n          </span><span class="s1">url: new URL(url ?? href, href),</span><span class="s3">\n          </span><span class="s1">tree,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Patch pushState to ensure external changes to the history are reflected in the Next.js Router.</span><span class="s3">\n     </span><span class="s1">* Ensures Next.js internal history state is copied to the new history entry.</span><span class="s3">\n     </span><span class="s1">* Ensures usePathname and useSearchParams hold the newly provided url.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">window.history.pushState = function pushState(</span><span class="s3">\n      </span><span class="s1">data: any,</span><span class="s3">\n      </span><span class="s1">_unused: string,</span><span class="s3">\n      </span><span class="s1">url?: string | URL | null</span><span class="s3">\n    </span><span class="s1">): void {</span><span class="s3">\n      </span><span class="s1">// Avoid a loop when Next.js internals trigger pushState/replaceState</span><span class="s3">\n      </span><span class="s1">if (data?.__NA || data?._N) {</span><span class="s3">\n        </span><span class="s1">return originalPushState(data, _unused, url)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">data = copyNextJsInternalHistoryState(data)</span><span class="s3">\n\n      </span><span class="s1">if (url) {</span><span class="s3">\n        </span><span class="s1">applyUrlFromHistoryPushReplace(url)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return originalPushState(data, _unused, url)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Patch replaceState to ensure external changes to the history are reflected in the Next.js Router.</span><span class="s3">\n     </span><span class="s1">* Ensures Next.js internal history state is copied to the new history entry.</span><span class="s3">\n     </span><span class="s1">* Ensures usePathname and useSearchParams hold the newly provided url.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">window.history.replaceState = function replaceState(</span><span class="s3">\n      </span><span class="s1">data: any,</span><span class="s3">\n      </span><span class="s1">_unused: string,</span><span class="s3">\n      </span><span class="s1">url?: string | URL | null</span><span class="s3">\n    </span><span class="s1">): void {</span><span class="s3">\n      </span><span class="s1">// Avoid a loop when Next.js internals trigger pushState/replaceState</span><span class="s3">\n      </span><span class="s1">if (data?.__NA || data?._N) {</span><span class="s3">\n        </span><span class="s1">return originalReplaceState(data, _unused, url)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">data = copyNextJsInternalHistoryState(data)</span><span class="s3">\n\n      </span><span class="s1">if (url) {</span><span class="s3">\n        </span><span class="s1">applyUrlFromHistoryPushReplace(url)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return originalReplaceState(data, _unused, url)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle popstate event, this is used to handle back/forward in the browser.</span><span class="s3">\n     </span><span class="s1">* By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.</span><span class="s3">\n     </span><span class="s1">* That case can happen when the old router injected the history entry.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const onPopState = (event: PopStateEvent) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (!event.state) {</span><span class="s3">\n        </span><span class="s1">// TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// This case happens when the history entry was pushed by the `pages` router.</span><span class="s3">\n      </span><span class="s1">if (!event.state.__NA) {</span><span class="s3">\n        </span><span class="s1">window.location.reload()</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously</span><span class="s3">\n      </span><span class="s1">// Without startTransition works if the cache is there for this path</span><span class="s3">\n      </span><span class="s1">startTransition(() =&gt; {</span><span class="s3">\n        </span><span class="s1">dispatchTraverseAction(</span><span class="s3">\n          </span><span class="s1">window.location.href,</span><span class="s3">\n          </span><span class="s1">event.state.__PRIVATE_NEXTJS_INTERNALS_TREE</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Register popstate event to call onPopstate.</span><span class="s3">\n    </span><span class="s1">window.addEventListener('popstate', onPopState)</span><span class="s3">\n    </span><span class="s1">return () =&gt; {</span><span class="s3">\n      </span><span class="s1">window.history.pushState = originalPushState</span><span class="s3">\n      </span><span class="s1">window.history.replaceState = originalReplaceState</span><span class="s3">\n      </span><span class="s1">window.removeEventListener('popstate', onPopState)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, [])</span><span class="s3">\n\n  </span><span class="s1">const { cache, tree, nextUrl, focusAndScrollRef } = state</span><span class="s3">\n\n  </span><span class="s1">const matchingHead = useMemo(() =&gt; {</span><span class="s3">\n    </span><span class="s1">return findHeadInCache(cache, tree[1])</span><span class="s3">\n  </span><span class="s1">}, [cache, tree])</span><span class="s3">\n\n  </span><span class="s1">// Add memoized pathParams for useParams.</span><span class="s3">\n  </span><span class="s1">const pathParams = useMemo(() =&gt; {</span><span class="s3">\n    </span><span class="s1">return getSelectedParams(tree)</span><span class="s3">\n  </span><span class="s1">}, [tree])</span><span class="s3">\n\n  </span><span class="s1">const layoutRouterContext = useMemo(() =&gt; {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">parentTree: tree,</span><span class="s3">\n      </span><span class="s1">parentCacheNode: cache,</span><span class="s3">\n      </span><span class="s1">parentSegmentPath: null,</span><span class="s3">\n      </span><span class="s1">// Root node always has `url`</span><span class="s3">\n      </span><span class="s1">// Provided in AppTreeContext to ensure it can be overwritten in layout-router</span><span class="s3">\n      </span><span class="s1">url: canonicalUrl,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, [tree, cache, canonicalUrl])</span><span class="s3">\n\n  </span><span class="s1">const globalLayoutRouterContext = useMemo(() =&gt; {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">tree,</span><span class="s3">\n      </span><span class="s1">focusAndScrollRef,</span><span class="s3">\n      </span><span class="s1">nextUrl,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, [tree, focusAndScrollRef, nextUrl])</span><span class="s3">\n\n  </span><span class="s1">let head</span><span class="s3">\n  </span><span class="s1">if (matchingHead !== null) {</span><span class="s3">\n    </span><span class="s1">// The head is wrapped in an extra component so we can use</span><span class="s3">\n    </span><span class="s1">// `useDeferredValue` to swap between the prefetched and final versions of</span><span class="s3">\n    </span><span class="s1">// the head. (This is what LayoutRouter does for segment data, too.)</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// The `key` is used to remount the component whenever the head moves to</span><span class="s3">\n    </span><span class="s1">// a different segment.</span><span class="s3">\n    </span><span class="s1">const [headCacheNode, headKey, headKeyWithoutSearchParams] = matchingHead</span><span class="s3">\n\n    </span><span class="s1">head = (</span><span class="s3">\n      </span><span class="s1">&lt;Head</span><span class="s3">\n        </span><span class="s1">key={</span><span class="s3">\n          </span><span class="s1">// Necessary for PPR: omit search params from the key to match prerendered keys</span><span class="s3">\n          </span><span class="s1">typeof window === 'undefined' ? headKeyWithoutSearchParams : headKey</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">headCacheNode={headCacheNode}</span><span class="s3">\n      </span><span class="s1">/&gt;</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">head = null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let content = (</span><span class="s3">\n    </span><span class="s1">&lt;RedirectBoundary&gt;</span><span class="s3">\n      </span><span class="s1">{head}</span><span class="s3">\n      </span><span class="s1">{/* RootLayoutBoundary enables detection of Suspense boundaries around the root layout.</span><span class="s3">\n          </span><span class="s1">When users wrap their layout in &lt;Suspense&gt;, this creates the component stack pattern</span><span class="s3">\n          \&quot;</span><span class="s1">Suspense -&gt; RootLayoutBoundary</span><span class="s3">\&quot; </span><span class="s1">which dynamic-rendering.ts uses to allow dynamic rendering. */}</span><span class="s3">\n      </span><span class="s1">&lt;RootLayoutBoundary&gt;{cache.rsc}&lt;/RootLayoutBoundary&gt;</span><span class="s3">\n      </span><span class="s1">&lt;AppRouterAnnouncer tree={tree} /&gt;</span><span class="s3">\n    </span><span class="s1">&lt;/RedirectBoundary&gt;</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n    </span><span class="s1">// In development, we apply few error boundaries and hot-reloader:</span><span class="s3">\n    </span><span class="s1">// - DevRootHTTPAccessFallbackBoundary: avoid using navigation API like notFound() in root layout</span><span class="s3">\n    </span><span class="s1">// - HotReloader:</span><span class="s3">\n    </span><span class="s1">//  - hot-reload the app when the code changes</span><span class="s3">\n    </span><span class="s1">//  - render dev overlay</span><span class="s3">\n    </span><span class="s1">//  - catch runtime errors and display global-error when necessary</span><span class="s3">\n    </span><span class="s1">if (typeof window !== 'undefined') {</span><span class="s3">\n      </span><span class="s1">const { DevRootHTTPAccessFallbackBoundary } =</span><span class="s3">\n        </span><span class="s1">require('./dev-root-http-access-fallback-boundary') as typeof import('./dev-root-http-access-fallback-boundary')</span><span class="s3">\n      </span><span class="s1">content = (</span><span class="s3">\n        </span><span class="s1">&lt;DevRootHTTPAccessFallbackBoundary&gt;</span><span class="s3">\n          </span><span class="s1">{content}</span><span class="s3">\n        </span><span class="s1">&lt;/DevRootHTTPAccessFallbackBoundary&gt;</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const HotReloader: typeof import('../dev/hot-reloader/app/hot-reloader-app').default =</span><span class="s3">\n      </span><span class="s1">(</span><span class="s3">\n        </span><span class="s1">require('../dev/hot-reloader/app/hot-reloader-app') as typeof import('../dev/hot-reloader/app/hot-reloader-app')</span><span class="s3">\n      </span><span class="s1">).default</span><span class="s3">\n\n    </span><span class="s1">content = (</span><span class="s3">\n      </span><span class="s1">&lt;HotReloader assetPrefix={assetPrefix} globalError={globalError}&gt;</span><span class="s3">\n        </span><span class="s1">{content}</span><span class="s3">\n      </span><span class="s1">&lt;/HotReloader&gt;</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">content = (</span><span class="s3">\n      </span><span class="s1">&lt;RootErrorBoundary</span><span class="s3">\n        </span><span class="s1">errorComponent={globalError[0]}</span><span class="s3">\n        </span><span class="s1">errorStyles={globalError[1]}</span><span class="s3">\n      </span><span class="s1">&gt;</span><span class="s3">\n        </span><span class="s1">{content}</span><span class="s3">\n      </span><span class="s1">&lt;/RootErrorBoundary&gt;</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">&lt;&gt;</span><span class="s3">\n      </span><span class="s1">&lt;HistoryUpdater appRouterState={state} /&gt;</span><span class="s3">\n      </span><span class="s1">&lt;RuntimeStyles /&gt;</span><span class="s3">\n      </span><span class="s1">&lt;PathParamsContext.Provider value={pathParams}&gt;</span><span class="s3">\n        </span><span class="s1">&lt;PathnameContext.Provider value={pathname}&gt;</span><span class="s3">\n          </span><span class="s1">&lt;SearchParamsContext.Provider value={searchParams}&gt;</span><span class="s3">\n            </span><span class="s1">&lt;GlobalLayoutRouterContext.Provider</span><span class="s3">\n              </span><span class="s1">value={globalLayoutRouterContext}</span><span class="s3">\n            </span><span class="s1">&gt;</span><span class="s3">\n              </span><span class="s1">{/* TODO: We should be able to remove this context. useRouter</span><span class="s3">\n                  </span><span class="s1">should import from app-router-instance instead. It's only</span><span class="s3">\n                  </span><span class="s1">necessary because useRouter is shared between Pages and</span><span class="s3">\n                  </span><span class="s1">App Router. We should fork that module, then remove this</span><span class="s3">\n                  </span><span class="s1">context provider. */}</span><span class="s3">\n              </span><span class="s1">&lt;AppRouterContext.Provider value={publicAppRouterInstance}&gt;</span><span class="s3">\n                </span><span class="s1">&lt;LayoutRouterContext.Provider value={layoutRouterContext}&gt;</span><span class="s3">\n                  </span><span class="s1">{content}</span><span class="s3">\n                </span><span class="s1">&lt;/LayoutRouterContext.Provider&gt;</span><span class="s3">\n              </span><span class="s1">&lt;/AppRouterContext.Provider&gt;</span><span class="s3">\n            </span><span class="s1">&lt;/GlobalLayoutRouterContext.Provider&gt;</span><span class="s3">\n          </span><span class="s1">&lt;/SearchParamsContext.Provider&gt;</span><span class="s3">\n        </span><span class="s1">&lt;/PathnameContext.Provider&gt;</span><span class="s3">\n      </span><span class="s1">&lt;/PathParamsContext.Provider&gt;</span><span class="s3">\n    </span><span class="s1">&lt;/&gt;</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default function AppRouter({</span><span class="s3">\n  </span><span class="s1">actionQueue,</span><span class="s3">\n  </span><span class="s1">globalErrorState,</span><span class="s3">\n  </span><span class="s1">assetPrefix,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">actionQueue: AppRouterActionQueue</span><span class="s3">\n  </span><span class="s1">globalErrorState: GlobalErrorState</span><span class="s3">\n  </span><span class="s1">assetPrefix: string</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">useNavFailureHandler()</span><span class="s3">\n\n  </span><span class="s1">const router = (</span><span class="s3">\n    </span><span class="s1">&lt;Router</span><span class="s3">\n      </span><span class="s1">actionQueue={actionQueue}</span><span class="s3">\n      </span><span class="s1">assetPrefix={assetPrefix}</span><span class="s3">\n      </span><span class="s1">globalError={globalErrorState}</span><span class="s3">\n    </span><span class="s1">/&gt;</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// At the very top level, use the default GlobalError component as the final fallback.</span><span class="s3">\n  </span><span class="s1">// When the app router itself fails, which means the framework itself fails, we show the default error.</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">&lt;RootErrorBoundary errorComponent={DefaultGlobalError}&gt;</span><span class="s3">\n      </span><span class="s1">{router}</span><span class="s3">\n    </span><span class="s1">&lt;/RootErrorBoundary&gt;</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const runtimeStyles = new Set&lt;string&gt;()</span><span class="s3">\n</span><span class="s1">let runtimeStyleChanged = new Set&lt;() =&gt; void&gt;()</span><span class="s3">\n\n</span><span class="s1">globalThis._N_E_STYLE_LOAD = function (href: string) {</span><span class="s3">\n  </span><span class="s1">let len = runtimeStyles.size</span><span class="s3">\n  </span><span class="s1">runtimeStyles.add(href)</span><span class="s3">\n  </span><span class="s1">if (runtimeStyles.size !== len) {</span><span class="s3">\n    </span><span class="s1">runtimeStyleChanged.forEach((cb) =&gt; cb())</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// TODO figure out how to get a promise here</span><span class="s3">\n  </span><span class="s1">// But maybe it's not necessary as react would block rendering until it's loaded</span><span class="s3">\n  </span><span class="s1">return Promise.resolve()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function RuntimeStyles() {</span><span class="s3">\n  </span><span class="s1">const [, forceUpdate] = React.useState(0)</span><span class="s3">\n  </span><span class="s1">const renderedStylesSize = runtimeStyles.size</span><span class="s3">\n  </span><span class="s1">useEffect(() =&gt; {</span><span class="s3">\n    </span><span class="s1">const changed = () =&gt; forceUpdate((c) =&gt; c + 1)</span><span class="s3">\n    </span><span class="s1">runtimeStyleChanged.add(changed)</span><span class="s3">\n    </span><span class="s1">if (renderedStylesSize !== runtimeStyles.size) {</span><span class="s3">\n      </span><span class="s1">changed()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return () =&gt; {</span><span class="s3">\n      </span><span class="s1">runtimeStyleChanged.delete(changed)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, [renderedStylesSize, forceUpdate])</span><span class="s3">\n\n  </span><span class="s1">const dplId = process.env.NEXT_DEPLOYMENT_ID</span><span class="s3">\n    </span><span class="s1">? `?dpl=${process.env.NEXT_DEPLOYMENT_ID}`</span><span class="s3">\n    </span><span class="s1">: ''</span><span class="s3">\n  </span><span class="s1">return [...runtimeStyles].map((href, i) =&gt; (</span><span class="s3">\n    </span><span class="s1">&lt;link</span><span class="s3">\n      </span><span class="s1">key={i}</span><span class="s3">\n      </span><span class="s1">rel=</span><span class="s3">\&quot;</span><span class="s1">stylesheet</span><span class="s3">\&quot;\n      </span><span class="s1">href={`${href}${dplId}`}</span><span class="s3">\n      </span><span class="s1">// @ts-ignore</span><span class="s3">\n      </span><span class="s1">precedence=</span><span class="s3">\&quot;</span><span class="s1">next</span><span class="s3">\&quot;\n      </span><span class="s1">// TODO figure out crossOrigin and nonce</span><span class="s3">\n      </span><span class="s1">// crossOrigin={TODO}</span><span class="s3">\n      </span><span class="s1">// nonce={TODO}</span><span class="s3">\n    </span><span class="s1">/&gt;</span><span class="s3">\n  </span><span class="s1">))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;createEmptyCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;createPrefetchURL&quot;</span><span class="s0">,</span><span class="s1">&quot;AppRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;isExternalURL&quot;</span><span class="s0">,</span><span class="s1">&quot;globalMutable&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;isBot&quot;</span><span class="s0">,</span><span class="s1">&quot;navigator&quot;</span><span class="s0">,</span><span class="s1">&quot;userAgent&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;addBasePath&quot;</span><span class="s0">,</span><span class="s1">&quot;_&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;HistoryUpdater&quot;</span><span class="s0">,</span><span class="s1">&quot;appRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;useInsertionEffect&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_APP_NAV_FAIL_HANDLING&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;__pendingUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;pushRef&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;historyState&quot;</span><span class="s0">,</span><span class="s1">&quot;preserveCustomHistoryState&quot;</span><span class="s0">,</span><span class="s1">&quot;history&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;__NA&quot;</span><span class="s0">,</span><span class="s1">&quot;__PRIVATE_NEXTJS_INTERNALS_TREE&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingPush&quot;</span><span class="s0">,</span><span class="s1">&quot;createHrefFromUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;pushState&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceState&quot;</span><span class="s0">,</span><span class="s1">&quot;useEffect&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CLIENT_SEGMENT_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;pingVisibleLinks&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyData&quot;</span><span class="s0">,</span><span class="s1">&quot;rsc&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchHead&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;navigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;copyNextJsInternalHistoryState&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;currentState&quot;</span><span class="s0">,</span><span class="s1">&quot;Head&quot;</span><span class="s0">,</span><span class="s1">&quot;headCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedPrefetchRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;useDeferredValue&quot;</span><span class="s0">,</span><span class="s1">&quot;Router&quot;</span><span class="s0">,</span><span class="s1">&quot;actionQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;assetPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;globalError&quot;</span><span class="s0">,</span><span class="s1">&quot;useActionQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;useMemo&quot;</span><span class="s0">,</span><span class="s1">&quot;hasBasePath&quot;</span><span class="s0">,</span><span class="s1">&quot;removeBasePath&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;nd&quot;</span><span class="s0">,</span><span class="s1">&quot;router&quot;</span><span class="s0">,</span><span class="s1">&quot;publicAppRouterInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;handlePageShow&quot;</span><span class="s0">,</span><span class="s1">&quot;event&quot;</span><span class="s0">,</span><span class="s1">&quot;persisted&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingMpaPath&quot;</span><span class="s0">,</span><span class="s1">&quot;dispatchAppRouterAction&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_RESTORE&quot;</span><span class="s0">,</span><span class="s1">&quot;addEventListener&quot;</span><span class="s0">,</span><span class="s1">&quot;removeEventListener&quot;</span><span class="s0">,</span><span class="s1">&quot;handleUnhandledRedirect&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;reason&quot;</span><span class="s0">,</span><span class="s1">&quot;isRedirectError&quot;</span><span class="s0">,</span><span class="s1">&quot;preventDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;getURLFromRedirectError&quot;</span><span class="s0">,</span><span class="s1">&quot;redirectType&quot;</span><span class="s0">,</span><span class="s1">&quot;getRedirectTypeFromError&quot;</span><span class="s0">,</span><span class="s1">&quot;RedirectType&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;mpaNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;unresolvedThenable&quot;</span><span class="s0">,</span><span class="s1">&quot;originalPushState&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;originalReplaceState&quot;</span><span class="s0">,</span><span class="s1">&quot;applyUrlFromHistoryPushReplace&quot;</span><span class="s0">,</span><span class="s1">&quot;startTransition&quot;</span><span class="s0">,</span><span class="s1">&quot;_unused&quot;</span><span class="s0">,</span><span class="s1">&quot;_N&quot;</span><span class="s0">,</span><span class="s1">&quot;onPopState&quot;</span><span class="s0">,</span><span class="s1">&quot;reload&quot;</span><span class="s0">,</span><span class="s1">&quot;dispatchTraverseAction&quot;</span><span class="s0">,</span><span class="s1">&quot;focusAndScrollRef&quot;</span><span class="s0">,</span><span class="s1">&quot;matchingHead&quot;</span><span class="s0">,</span><span class="s1">&quot;findHeadInCache&quot;</span><span class="s0">,</span><span class="s1">&quot;pathParams&quot;</span><span class="s0">,</span><span class="s1">&quot;getSelectedParams&quot;</span><span class="s0">,</span><span class="s1">&quot;layoutRouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;parentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;parentCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;parentSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;globalLayoutRouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;headKey&quot;</span><span class="s0">,</span><span class="s1">&quot;headKeyWithoutSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;content&quot;</span><span class="s0">,</span><span class="s1">&quot;RedirectBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;RootLayoutBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;AppRouterAnnouncer&quot;</span><span class="s0">,</span><span class="s1">&quot;DevRootHTTPAccessFallbackBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;HotReloader&quot;</span><span class="s0">,</span><span class="s1">&quot;default&quot;</span><span class="s0">,</span><span class="s1">&quot;RootErrorBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;errorComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;errorStyles&quot;</span><span class="s0">,</span><span class="s1">&quot;RuntimeStyles&quot;</span><span class="s0">,</span><span class="s1">&quot;PathParamsContext&quot;</span><span class="s0">,</span><span class="s1">&quot;Provider&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;PathnameContext&quot;</span><span class="s0">,</span><span class="s1">&quot;SearchParamsContext&quot;</span><span class="s0">,</span><span class="s1">&quot;GlobalLayoutRouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;AppRouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;LayoutRouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;globalErrorState&quot;</span><span class="s0">,</span><span class="s1">&quot;useNavFailureHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;DefaultGlobalError&quot;</span><span class="s0">,</span><span class="s1">&quot;runtimeStyles&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;runtimeStyleChanged&quot;</span><span class="s0">,</span><span class="s1">&quot;globalThis&quot;</span><span class="s0">,</span><span class="s1">&quot;_N_E_STYLE_LOAD&quot;</span><span class="s0">,</span><span class="s1">&quot;len&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;cb&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;forceUpdate&quot;</span><span class="s0">,</span><span class="s1">&quot;React&quot;</span><span class="s0">,</span><span class="s1">&quot;useState&quot;</span><span class="s0">,</span><span class="s1">&quot;renderedStylesSize&quot;</span><span class="s0">,</span><span class="s1">&quot;changed&quot;</span><span class="s0">,</span><span class="s1">&quot;c&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;dplId&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_DEPLOYMENT_ID&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;link&quot;</span><span class="s0">,</span><span class="s1">&quot;rel&quot;</span><span class="s0">,</span><span class="s1">&quot;precedence&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">6984</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/ppr-navigations.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">CacheNodeSeedData,</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">FlightSegmentPath,</span><span class="s3">\n  </span><span class="s1">Segment,</span><span class="s3">\n</span><span class="s1">} from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">CacheNode,</span><span class="s3">\n  </span><span class="s1">ChildSegmentMap,</span><span class="s3">\n  </span><span class="s1">HeadData,</span><span class="s3">\n  </span><span class="s1">LoadingModuleData,</span><span class="s3">\n  </span><span class="s1">ReadyCacheNode,</span><span class="s3">\n</span><span class="s1">} from '../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'</span><span class="s3">\n</span><span class="s1">import { matchSegment } from '../match-segments'</span><span class="s3">\n</span><span class="s1">import { createRouterCacheKey } from './create-router-cache-key'</span><span class="s3">\n</span><span class="s1">import type { FetchServerResponseResult } from './fetch-server-response'</span><span class="s3">\n</span><span class="s1">import { isNavigatingToNewRootLayout } from './is-navigating-to-new-root-layout'</span><span class="s3">\n</span><span class="s1">import { DYNAMIC_STALETIME_MS } from './prefetch-cache-utils'</span><span class="s3">\n\n</span><span class="s1">// This is yet another tree type that is used to track pending promises that</span><span class="s3">\n</span><span class="s1">// need to be fulfilled once the dynamic data is received. The terminal nodes of</span><span class="s3">\n</span><span class="s1">// this tree represent the new Cache Node trees that were created during this</span><span class="s3">\n</span><span class="s1">// request. We can't use the Cache Node tree or Route State tree directly</span><span class="s3">\n</span><span class="s1">// because those include reused nodes, too. This tree is discarded as soon as</span><span class="s3">\n</span><span class="s1">// the navigation response is received.</span><span class="s3">\n</span><span class="s1">type SPANavigationTask = {</span><span class="s3">\n  </span><span class="s1">// The router state that corresponds to the tree that this Task represents.</span><span class="s3">\n  </span><span class="s1">route: FlightRouterState</span><span class="s3">\n  </span><span class="s1">// The CacheNode that corresponds to the tree that this Task represents. If</span><span class="s3">\n  </span><span class="s1">// `children` is null (i.e. if this is a terminal task node), then `node`</span><span class="s3">\n  </span><span class="s1">// represents a brand new Cache Node tree, which way or may not need to be</span><span class="s3">\n  </span><span class="s1">// filled with dynamic data from the server.</span><span class="s3">\n  </span><span class="s1">node: CacheNode | null</span><span class="s3">\n  </span><span class="s1">// The tree sent to the server during the dynamic request. This is the</span><span class="s3">\n  </span><span class="s1">// same as `route`, except with the `refetch` marker set on dynamic segments.</span><span class="s3">\n  </span><span class="s1">// If all the segments are static, then this will be null, and no server</span><span class="s3">\n  </span><span class="s1">// request is required.</span><span class="s3">\n  </span><span class="s1">dynamicRequestTree: FlightRouterState | null</span><span class="s3">\n  </span><span class="s1">children: Map&lt;string, SPANavigationTask&gt; | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// A special type used to bail out and trigger a full-page navigation.</span><span class="s3">\n</span><span class="s1">type MPANavigationTask = {</span><span class="s3">\n  </span><span class="s1">// MPA tasks are distinguised from SPA tasks by having a null `route`.</span><span class="s3">\n  </span><span class="s1">route: null</span><span class="s3">\n  </span><span class="s1">node: null</span><span class="s3">\n  </span><span class="s1">dynamicRequestTree: null</span><span class="s3">\n  </span><span class="s1">children: null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const MPA_NAVIGATION_TASK: MPANavigationTask = {</span><span class="s3">\n  </span><span class="s1">route: null,</span><span class="s3">\n  </span><span class="s1">node: null,</span><span class="s3">\n  </span><span class="s1">dynamicRequestTree: null,</span><span class="s3">\n  </span><span class="s1">children: null,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type Task = SPANavigationTask | MPANavigationTask</span><span class="s3">\n\n</span><span class="s1">// Creates a new Cache Node tree (i.e. copy-on-write) that represents the</span><span class="s3">\n</span><span class="s1">// optimistic result of a navigation, using both the current Cache Node tree and</span><span class="s3">\n</span><span class="s1">// data that was prefetched prior to navigation.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// At the moment we call this function, we haven't yet received the navigation</span><span class="s3">\n</span><span class="s1">// response from the server. It could send back something completely different</span><span class="s3">\n</span><span class="s1">// from the tree that was prefetched  due to rewrites, default routes, parallel</span><span class="s3">\n</span><span class="s1">// routes, etc.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// But in most cases, it will return the same tree that we prefetched, just with</span><span class="s3">\n</span><span class="s1">// the dynamic holes filled in. So we optimistically assume this will happen,</span><span class="s3">\n</span><span class="s1">// and accept that the real result could be arbitrarily different.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// We'll reuse anything that was already in the previous tree, since that's what</span><span class="s3">\n</span><span class="s1">// the server does.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// New segments (ones that don't appear in the old tree) are assigned an</span><span class="s3">\n</span><span class="s1">// unresolved promise. The data for these promises will be fulfilled later, when</span><span class="s3">\n</span><span class="s1">// the navigation response is received.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// The tree can be rendered immediately after it is created (that's why this is</span><span class="s3">\n</span><span class="s1">// a synchronous function). Any new trees that do not have prefetch data will</span><span class="s3">\n</span><span class="s1">// suspend during rendering, until the dynamic data streams in.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Returns a Task object, which contains both the updated Cache Node and a path</span><span class="s3">\n</span><span class="s1">// to the pending subtrees that need to be resolved by the navigation response.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// A return value of `null` means there were no changes, and the previous tree</span><span class="s3">\n</span><span class="s1">// can be reused without initiating a server request.</span><span class="s3">\n</span><span class="s1">export function startPPRNavigation(</span><span class="s3">\n  </span><span class="s1">navigatedAt: number,</span><span class="s3">\n  </span><span class="s1">oldCacheNode: CacheNode,</span><span class="s3">\n  </span><span class="s1">oldRouterState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">newRouterState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">prefetchData: CacheNodeSeedData | null,</span><span class="s3">\n  </span><span class="s1">prefetchHead: HeadData | null,</span><span class="s3">\n  </span><span class="s1">isPrefetchHeadPartial: boolean,</span><span class="s3">\n  </span><span class="s1">isSamePageNavigation: boolean,</span><span class="s3">\n  </span><span class="s1">scrollableSegmentsResult: Array&lt;FlightSegmentPath&gt;</span><span class="s3">\n</span><span class="s1">): Task | null {</span><span class="s3">\n  </span><span class="s1">const segmentPath: Array&lt;FlightSegmentPath&gt; = []</span><span class="s3">\n  </span><span class="s1">return updateCacheNodeOnNavigation(</span><span class="s3">\n    </span><span class="s1">navigatedAt,</span><span class="s3">\n    </span><span class="s1">oldCacheNode,</span><span class="s3">\n    </span><span class="s1">oldRouterState,</span><span class="s3">\n    </span><span class="s1">newRouterState,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">prefetchData,</span><span class="s3">\n    </span><span class="s1">prefetchHead,</span><span class="s3">\n    </span><span class="s1">isPrefetchHeadPartial,</span><span class="s3">\n    </span><span class="s1">isSamePageNavigation,</span><span class="s3">\n    </span><span class="s1">segmentPath,</span><span class="s3">\n    </span><span class="s1">scrollableSegmentsResult</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function updateCacheNodeOnNavigation(</span><span class="s3">\n  </span><span class="s1">navigatedAt: number,</span><span class="s3">\n  </span><span class="s1">oldCacheNode: CacheNode,</span><span class="s3">\n  </span><span class="s1">oldRouterState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">newRouterState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">didFindRootLayout: boolean,</span><span class="s3">\n  </span><span class="s1">prefetchData: CacheNodeSeedData | null,</span><span class="s3">\n  </span><span class="s1">prefetchHead: HeadData | null,</span><span class="s3">\n  </span><span class="s1">isPrefetchHeadPartial: boolean,</span><span class="s3">\n  </span><span class="s1">isSamePageNavigation: boolean,</span><span class="s3">\n  </span><span class="s1">segmentPath: FlightSegmentPath,</span><span class="s3">\n  </span><span class="s1">scrollableSegmentsResult: Array&lt;FlightSegmentPath&gt;</span><span class="s3">\n</span><span class="s1">): Task | null {</span><span class="s3">\n  </span><span class="s1">// Diff the old and new trees to reuse the shared layouts.</span><span class="s3">\n  </span><span class="s1">const oldRouterStateChildren = oldRouterState[1]</span><span class="s3">\n  </span><span class="s1">const newRouterStateChildren = newRouterState[1]</span><span class="s3">\n  </span><span class="s1">const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null</span><span class="s3">\n\n  </span><span class="s1">if (!didFindRootLayout) {</span><span class="s3">\n    </span><span class="s1">// We're currently traversing the part of the tree that was also part of</span><span class="s3">\n    </span><span class="s1">// the previous route. If we discover a root layout, then we don't need to</span><span class="s3">\n    </span><span class="s1">// trigger an MPA navigation. See beginRenderingNewRouteTree for context.</span><span class="s3">\n    </span><span class="s1">const isRootLayout = newRouterState[4] === true</span><span class="s3">\n    </span><span class="s1">if (isRootLayout) {</span><span class="s3">\n      </span><span class="s1">// Found a matching root layout.</span><span class="s3">\n      </span><span class="s1">didFindRootLayout = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const oldParallelRoutes = oldCacheNode.parallelRoutes</span><span class="s3">\n\n  </span><span class="s1">// Clone the current set of segment children, even if they aren't active in</span><span class="s3">\n  </span><span class="s1">// the new tree.</span><span class="s3">\n  </span><span class="s1">// TODO: We currently retain all the inactive segments indefinitely, until</span><span class="s3">\n  </span><span class="s1">// there's an explicit refresh, or a parent layout is lazily refreshed. We</span><span class="s3">\n  </span><span class="s1">// rely on this for popstate navigations, which update the Router State Tree</span><span class="s3">\n  </span><span class="s1">// but do not eagerly perform a data fetch, because they expect the segment</span><span class="s3">\n  </span><span class="s1">// data to already be in the Cache Node tree. For highly static sites that</span><span class="s3">\n  </span><span class="s1">// are mostly read-only, this may happen only rarely, causing memory to</span><span class="s3">\n  </span><span class="s1">// leak. We should figure out a better model for the lifetime of inactive</span><span class="s3">\n  </span><span class="s1">// segments, so we can maintain instant back/forward navigations without</span><span class="s3">\n  </span><span class="s1">// leaking memory indefinitely.</span><span class="s3">\n  </span><span class="s1">const prefetchParallelRoutes = new Map(oldParallelRoutes)</span><span class="s3">\n\n  </span><span class="s1">// As we diff the trees, we may sometimes modify (copy-on-write, not mutate)</span><span class="s3">\n  </span><span class="s1">// the Route Tree that was returned by the server  for example, in the case</span><span class="s3">\n  </span><span class="s1">// of default parallel routes, we preserve the currently active segment. To</span><span class="s3">\n  </span><span class="s1">// avoid mutating the original tree, we clone the router state children along</span><span class="s3">\n  </span><span class="s1">// the return path.</span><span class="s3">\n  </span><span class="s1">let patchedRouterStateChildren: {</span><span class="s3">\n    </span><span class="s1">[parallelRouteKey: string]: FlightRouterState</span><span class="s3">\n  </span><span class="s1">} = {}</span><span class="s3">\n  </span><span class="s1">let taskChildren = null</span><span class="s3">\n\n  </span><span class="s1">// Most navigations require a request to fetch additional data from the</span><span class="s3">\n  </span><span class="s1">// server, either because the data was not already prefetched, or because the</span><span class="s3">\n  </span><span class="s1">// target route contains dynamic data that cannot be prefetched.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// However, if the target route is fully static, and it's already completely</span><span class="s3">\n  </span><span class="s1">// loaded into the segment cache, then we can skip the server request.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// This starts off as `false`, and is set to `true` if any of the child</span><span class="s3">\n  </span><span class="s1">// routes requires a dynamic request.</span><span class="s3">\n  </span><span class="s1">let needsDynamicRequest = false</span><span class="s3">\n  </span><span class="s1">// As we traverse the children, we'll construct a FlightRouterState that can</span><span class="s3">\n  </span><span class="s1">// be sent to the server to request the dynamic data. If it turns out that</span><span class="s3">\n  </span><span class="s1">// nothing in the subtree is dynamic (i.e. needsDynamicRequest is false at the</span><span class="s3">\n  </span><span class="s1">// end), then this will be discarded.</span><span class="s3">\n  </span><span class="s1">// TODO: We can probably optimize the format of this data structure to only</span><span class="s3">\n  </span><span class="s1">// include paths that are dynamic. Instead of reusing the</span><span class="s3">\n  </span><span class="s1">// FlightRouterState type.</span><span class="s3">\n  </span><span class="s1">let dynamicRequestTreeChildren: {</span><span class="s3">\n    </span><span class="s1">[parallelRouteKey: string]: FlightRouterState</span><span class="s3">\n  </span><span class="s1">} = {}</span><span class="s3">\n\n  </span><span class="s1">for (let parallelRouteKey in newRouterStateChildren) {</span><span class="s3">\n    </span><span class="s1">const newRouterStateChild: FlightRouterState =</span><span class="s3">\n      </span><span class="s1">newRouterStateChildren[parallelRouteKey]</span><span class="s3">\n    </span><span class="s1">const oldRouterStateChild: FlightRouterState | void =</span><span class="s3">\n      </span><span class="s1">oldRouterStateChildren[parallelRouteKey]</span><span class="s3">\n    </span><span class="s1">const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)</span><span class="s3">\n    </span><span class="s1">const prefetchDataChild: CacheNodeSeedData | void | null =</span><span class="s3">\n      </span><span class="s1">prefetchDataChildren !== null</span><span class="s3">\n        </span><span class="s1">? prefetchDataChildren[parallelRouteKey]</span><span class="s3">\n        </span><span class="s1">: null</span><span class="s3">\n\n    </span><span class="s1">const newSegmentChild = newRouterStateChild[0]</span><span class="s3">\n    </span><span class="s1">const newSegmentPathChild = segmentPath.concat([</span><span class="s3">\n      </span><span class="s1">parallelRouteKey,</span><span class="s3">\n      </span><span class="s1">newSegmentChild,</span><span class="s3">\n    </span><span class="s1">])</span><span class="s3">\n    </span><span class="s1">const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)</span><span class="s3">\n\n    </span><span class="s1">const oldSegmentChild =</span><span class="s3">\n      </span><span class="s1">oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined</span><span class="s3">\n\n    </span><span class="s1">const oldCacheNodeChild =</span><span class="s3">\n      </span><span class="s1">oldSegmentMapChild !== undefined</span><span class="s3">\n        </span><span class="s1">? oldSegmentMapChild.get(newSegmentKeyChild)</span><span class="s3">\n        </span><span class="s1">: undefined</span><span class="s3">\n\n    </span><span class="s1">let taskChild: Task | null</span><span class="s3">\n    </span><span class="s1">if (newSegmentChild === DEFAULT_SEGMENT_KEY) {</span><span class="s3">\n      </span><span class="s1">// This is another kind of leaf segment  a default route.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// Default routes have special behavior. When there's no matching segment</span><span class="s3">\n      </span><span class="s1">// for a parallel route, Next.js preserves the currently active segment</span><span class="s3">\n      </span><span class="s1">// during a client navigation  but not for initial render. The server</span><span class="s3">\n      </span><span class="s1">// leaves it to the client to account for this. So we need to handle</span><span class="s3">\n      </span><span class="s1">// it here.</span><span class="s3">\n      </span><span class="s1">if (oldRouterStateChild !== undefined) {</span><span class="s3">\n        </span><span class="s1">// Reuse the existing Router State for this segment. We spawn a </span><span class="s3">\&quot;</span><span class="s1">task</span><span class="s3">\&quot;\n        </span><span class="s1">// just to keep track of the updated router state; unlike most, it's</span><span class="s3">\n        </span><span class="s1">// already fulfilled and won't be affected by the dynamic response.</span><span class="s3">\n        </span><span class="s1">taskChild = spawnReusedTask(oldRouterStateChild)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// There's no currently active segment. Switch to the </span><span class="s3">\&quot;</span><span class="s1">create</span><span class="s3">\&quot; </span><span class="s1">path.</span><span class="s3">\n        </span><span class="s1">taskChild = beginRenderingNewRouteTree(</span><span class="s3">\n          </span><span class="s1">navigatedAt,</span><span class="s3">\n          </span><span class="s1">oldRouterStateChild,</span><span class="s3">\n          </span><span class="s1">newRouterStateChild,</span><span class="s3">\n          </span><span class="s1">oldCacheNodeChild,</span><span class="s3">\n          </span><span class="s1">didFindRootLayout,</span><span class="s3">\n          </span><span class="s1">prefetchDataChild !== undefined ? prefetchDataChild : null,</span><span class="s3">\n          </span><span class="s1">prefetchHead,</span><span class="s3">\n          </span><span class="s1">isPrefetchHeadPartial,</span><span class="s3">\n          </span><span class="s1">newSegmentPathChild,</span><span class="s3">\n          </span><span class="s1">scrollableSegmentsResult</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">isSamePageNavigation &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Check if this is a page segment.</span><span class="s3">\n      </span><span class="s1">// TODO: We're not consistent about how we do this check. Some places</span><span class="s3">\n      </span><span class="s1">// check if the segment starts with PAGE_SEGMENT_KEY, but most seem to</span><span class="s3">\n      </span><span class="s1">// check if there any any children, which is why I'm doing it here. We</span><span class="s3">\n      </span><span class="s1">// should probably encode an empty children set as `null` though. Either</span><span class="s3">\n      </span><span class="s1">// way, we should update all the checks to be consistent.</span><span class="s3">\n      </span><span class="s1">Object.keys(newRouterStateChild[1]).length === 0</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// We special case navigations to the exact same URL as the current</span><span class="s3">\n      </span><span class="s1">// location. It's a common UI pattern for apps to refresh when you click a</span><span class="s3">\n      </span><span class="s1">// link to the current page. So when this happens, we refresh the dynamic</span><span class="s3">\n      </span><span class="s1">// data in the page segments.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// Note that this does not apply if the any part of the hash or search</span><span class="s3">\n      </span><span class="s1">// query has changed. This might feel a bit weird but it makes more sense</span><span class="s3">\n      </span><span class="s1">// when you consider that the way to trigger this behavior is to click</span><span class="s3">\n      </span><span class="s1">// the same link multiple times.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// TODO: We should probably refresh the *entire* route when this case</span><span class="s3">\n      </span><span class="s1">// occurs, not just the page segments. Essentially treating it the same as</span><span class="s3">\n      </span><span class="s1">// a refresh() triggered by an action, which is the more explicit way of</span><span class="s3">\n      </span><span class="s1">// modeling the UI pattern described above.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// Also note that this only refreshes the dynamic data, not static/</span><span class="s3">\n      </span><span class="s1">// cached data. If the page segment is fully static and prefetched, the</span><span class="s3">\n      </span><span class="s1">// request is skipped. (This is also how refresh() works.)</span><span class="s3">\n      </span><span class="s1">taskChild = beginRenderingNewRouteTree(</span><span class="s3">\n        </span><span class="s1">navigatedAt,</span><span class="s3">\n        </span><span class="s1">oldRouterStateChild,</span><span class="s3">\n        </span><span class="s1">newRouterStateChild,</span><span class="s3">\n        </span><span class="s1">oldCacheNodeChild,</span><span class="s3">\n        </span><span class="s1">didFindRootLayout,</span><span class="s3">\n        </span><span class="s1">prefetchDataChild !== undefined ? prefetchDataChild : null,</span><span class="s3">\n        </span><span class="s1">prefetchHead,</span><span class="s3">\n        </span><span class="s1">isPrefetchHeadPartial,</span><span class="s3">\n        </span><span class="s1">newSegmentPathChild,</span><span class="s3">\n        </span><span class="s1">scrollableSegmentsResult</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">oldRouterStateChild !== undefined &amp;&amp;</span><span class="s3">\n      </span><span class="s1">oldSegmentChild !== undefined &amp;&amp;</span><span class="s3">\n      </span><span class="s1">matchSegment(newSegmentChild, oldSegmentChild)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">oldCacheNodeChild !== undefined &amp;&amp;</span><span class="s3">\n        </span><span class="s1">oldRouterStateChild !== undefined</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// This segment exists in both the old and new trees. Recursively update</span><span class="s3">\n        </span><span class="s1">// the children.</span><span class="s3">\n        </span><span class="s1">taskChild = updateCacheNodeOnNavigation(</span><span class="s3">\n          </span><span class="s1">navigatedAt,</span><span class="s3">\n          </span><span class="s1">oldCacheNodeChild,</span><span class="s3">\n          </span><span class="s1">oldRouterStateChild,</span><span class="s3">\n          </span><span class="s1">newRouterStateChild,</span><span class="s3">\n          </span><span class="s1">didFindRootLayout,</span><span class="s3">\n          </span><span class="s1">prefetchDataChild,</span><span class="s3">\n          </span><span class="s1">prefetchHead,</span><span class="s3">\n          </span><span class="s1">isPrefetchHeadPartial,</span><span class="s3">\n          </span><span class="s1">isSamePageNavigation,</span><span class="s3">\n          </span><span class="s1">newSegmentPathChild,</span><span class="s3">\n          </span><span class="s1">scrollableSegmentsResult</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// There's no existing Cache Node for this segment. Switch to the</span><span class="s3">\n        </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">create</span><span class="s3">\&quot; </span><span class="s1">path.</span><span class="s3">\n        </span><span class="s1">taskChild = beginRenderingNewRouteTree(</span><span class="s3">\n          </span><span class="s1">navigatedAt,</span><span class="s3">\n          </span><span class="s1">oldRouterStateChild,</span><span class="s3">\n          </span><span class="s1">newRouterStateChild,</span><span class="s3">\n          </span><span class="s1">oldCacheNodeChild,</span><span class="s3">\n          </span><span class="s1">didFindRootLayout,</span><span class="s3">\n          </span><span class="s1">prefetchDataChild !== undefined ? prefetchDataChild : null,</span><span class="s3">\n          </span><span class="s1">prefetchHead,</span><span class="s3">\n          </span><span class="s1">isPrefetchHeadPartial,</span><span class="s3">\n          </span><span class="s1">newSegmentPathChild,</span><span class="s3">\n          </span><span class="s1">scrollableSegmentsResult</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// This is a new tree. Switch to the </span><span class="s3">\&quot;</span><span class="s1">create</span><span class="s3">\&quot; </span><span class="s1">path.</span><span class="s3">\n      </span><span class="s1">taskChild = beginRenderingNewRouteTree(</span><span class="s3">\n        </span><span class="s1">navigatedAt,</span><span class="s3">\n        </span><span class="s1">oldRouterStateChild,</span><span class="s3">\n        </span><span class="s1">newRouterStateChild,</span><span class="s3">\n        </span><span class="s1">oldCacheNodeChild,</span><span class="s3">\n        </span><span class="s1">didFindRootLayout,</span><span class="s3">\n        </span><span class="s1">prefetchDataChild !== undefined ? prefetchDataChild : null,</span><span class="s3">\n        </span><span class="s1">prefetchHead,</span><span class="s3">\n        </span><span class="s1">isPrefetchHeadPartial,</span><span class="s3">\n        </span><span class="s1">newSegmentPathChild,</span><span class="s3">\n        </span><span class="s1">scrollableSegmentsResult</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (taskChild !== null) {</span><span class="s3">\n      </span><span class="s1">// Recursively propagate up the child tasks.</span><span class="s3">\n\n      </span><span class="s1">if (taskChild.route === null) {</span><span class="s3">\n        </span><span class="s1">// One of the child tasks discovered a change to the root layout.</span><span class="s3">\n        </span><span class="s1">// Immediately unwind from this recursive traversal.</span><span class="s3">\n        </span><span class="s1">return MPA_NAVIGATION_TASK</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (taskChildren === null) {</span><span class="s3">\n        </span><span class="s1">taskChildren = new Map()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">taskChildren.set(parallelRouteKey, taskChild)</span><span class="s3">\n      </span><span class="s1">const newCacheNodeChild = taskChild.node</span><span class="s3">\n      </span><span class="s1">if (newCacheNodeChild !== null) {</span><span class="s3">\n        </span><span class="s1">const newSegmentMapChild: ChildSegmentMap = new Map(oldSegmentMapChild)</span><span class="s3">\n        </span><span class="s1">newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)</span><span class="s3">\n        </span><span class="s1">prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// The child tree's route state may be different from the prefetched</span><span class="s3">\n      </span><span class="s1">// route sent by the server. We need to clone it as we traverse back up</span><span class="s3">\n      </span><span class="s1">// the tree.</span><span class="s3">\n      </span><span class="s1">const taskChildRoute = taskChild.route</span><span class="s3">\n      </span><span class="s1">patchedRouterStateChildren[parallelRouteKey] = taskChildRoute</span><span class="s3">\n\n      </span><span class="s1">const dynamicRequestTreeChild = taskChild.dynamicRequestTree</span><span class="s3">\n      </span><span class="s1">if (dynamicRequestTreeChild !== null) {</span><span class="s3">\n        </span><span class="s1">// Something in the child tree is dynamic.</span><span class="s3">\n        </span><span class="s1">needsDynamicRequest = true</span><span class="s3">\n        </span><span class="s1">dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// The child didn't change. We can use the prefetched router state.</span><span class="s3">\n      </span><span class="s1">patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild</span><span class="s3">\n      </span><span class="s1">dynamicRequestTreeChildren[parallelRouteKey] = newRouterStateChild</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (taskChildren === null) {</span><span class="s3">\n    </span><span class="s1">// No new tasks were spawned.</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const newCacheNode: ReadyCacheNode = {</span><span class="s3">\n    </span><span class="s1">lazyData: null,</span><span class="s3">\n    </span><span class="s1">rsc: oldCacheNode.rsc,</span><span class="s3">\n    </span><span class="s1">// We intentionally aren't updating the prefetchRsc field, since this node</span><span class="s3">\n    </span><span class="s1">// is already part of the current tree, because it would be weird for</span><span class="s3">\n    </span><span class="s1">// prefetch data to be newer than the final data. It probably won't ever be</span><span class="s3">\n    </span><span class="s1">// observable anyway, but it could happen if the segment is unmounted then</span><span class="s3">\n    </span><span class="s1">// mounted again, because LayoutRouter will momentarily switch to rendering</span><span class="s3">\n    </span><span class="s1">// prefetchRsc, via useDeferredValue.</span><span class="s3">\n    </span><span class="s1">prefetchRsc: oldCacheNode.prefetchRsc,</span><span class="s3">\n    </span><span class="s1">head: oldCacheNode.head,</span><span class="s3">\n    </span><span class="s1">prefetchHead: oldCacheNode.prefetchHead,</span><span class="s3">\n    </span><span class="s1">loading: oldCacheNode.loading,</span><span class="s3">\n\n    </span><span class="s1">// Everything is cloned except for the children, which we computed above.</span><span class="s3">\n    </span><span class="s1">parallelRoutes: prefetchParallelRoutes,</span><span class="s3">\n\n    </span><span class="s1">navigatedAt,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">// Return a cloned copy of the router state with updated children.</span><span class="s3">\n    </span><span class="s1">route: patchRouterStateWithNewChildren(</span><span class="s3">\n      </span><span class="s1">newRouterState,</span><span class="s3">\n      </span><span class="s1">patchedRouterStateChildren</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">node: newCacheNode,</span><span class="s3">\n    </span><span class="s1">dynamicRequestTree: needsDynamicRequest</span><span class="s3">\n      </span><span class="s1">? patchRouterStateWithNewChildren(</span><span class="s3">\n          </span><span class="s1">newRouterState,</span><span class="s3">\n          </span><span class="s1">dynamicRequestTreeChildren</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">: null,</span><span class="s3">\n    </span><span class="s1">children: taskChildren,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function beginRenderingNewRouteTree(</span><span class="s3">\n  </span><span class="s1">navigatedAt: number,</span><span class="s3">\n  </span><span class="s1">oldRouterState: FlightRouterState | void,</span><span class="s3">\n  </span><span class="s1">newRouterState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">existingCacheNode: CacheNode | void,</span><span class="s3">\n  </span><span class="s1">didFindRootLayout: boolean,</span><span class="s3">\n  </span><span class="s1">prefetchData: CacheNodeSeedData | null,</span><span class="s3">\n  </span><span class="s1">possiblyPartialPrefetchHead: HeadData | null,</span><span class="s3">\n  </span><span class="s1">isPrefetchHeadPartial: boolean,</span><span class="s3">\n  </span><span class="s1">segmentPath: FlightSegmentPath,</span><span class="s3">\n  </span><span class="s1">scrollableSegmentsResult: Array&lt;FlightSegmentPath&gt;</span><span class="s3">\n</span><span class="s1">): Task {</span><span class="s3">\n  </span><span class="s1">if (!didFindRootLayout) {</span><span class="s3">\n    </span><span class="s1">// The route tree changed before we reached a layout. (The highest-level</span><span class="s3">\n    </span><span class="s1">// layout in a route tree is referred to as the </span><span class="s3">\&quot;</span><span class="s1">root</span><span class="s3">\&quot; </span><span class="s1">layout.) This could</span><span class="s3">\n    </span><span class="s1">// mean that we're navigating between two different root layouts. When this</span><span class="s3">\n    </span><span class="s1">// happens, we perform a full-page (MPA-style) navigation.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// However, the algorithm for deciding where to start rendering a route</span><span class="s3">\n    </span><span class="s1">// (i.e. the one performed in order to reach this function) is stricter</span><span class="s3">\n    </span><span class="s1">// than the one used to detect a change in the root layout. So just because</span><span class="s3">\n    </span><span class="s1">// we're re-rendering a segment outside of the root layout does not mean we</span><span class="s3">\n    </span><span class="s1">// should trigger a full-page navigation.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// Specifically, we handle dynamic parameters differently: two segments are</span><span class="s3">\n    </span><span class="s1">// considered the same even if their parameter values are different.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// Refer to isNavigatingToNewRootLayout for details.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// Note that we only have to perform this extra traversal if we didn't</span><span class="s3">\n    </span><span class="s1">// already discover a root layout in the part of the tree that is unchanged.</span><span class="s3">\n    </span><span class="s1">// In the common case, this branch is skipped completely.</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">oldRouterState === undefined ||</span><span class="s3">\n      </span><span class="s1">isNavigatingToNewRootLayout(oldRouterState, newRouterState)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// The root layout changed. Perform a full-page navigation.</span><span class="s3">\n      </span><span class="s1">return MPA_NAVIGATION_TASK</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return createCacheNodeOnNavigation(</span><span class="s3">\n    </span><span class="s1">navigatedAt,</span><span class="s3">\n    </span><span class="s1">newRouterState,</span><span class="s3">\n    </span><span class="s1">existingCacheNode,</span><span class="s3">\n    </span><span class="s1">prefetchData,</span><span class="s3">\n    </span><span class="s1">possiblyPartialPrefetchHead,</span><span class="s3">\n    </span><span class="s1">isPrefetchHeadPartial,</span><span class="s3">\n    </span><span class="s1">segmentPath,</span><span class="s3">\n    </span><span class="s1">scrollableSegmentsResult</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createCacheNodeOnNavigation(</span><span class="s3">\n  </span><span class="s1">navigatedAt: number,</span><span class="s3">\n  </span><span class="s1">routerState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">existingCacheNode: CacheNode | void,</span><span class="s3">\n  </span><span class="s1">prefetchData: CacheNodeSeedData | null,</span><span class="s3">\n  </span><span class="s1">possiblyPartialPrefetchHead: HeadData | null,</span><span class="s3">\n  </span><span class="s1">isPrefetchHeadPartial: boolean,</span><span class="s3">\n  </span><span class="s1">segmentPath: FlightSegmentPath,</span><span class="s3">\n  </span><span class="s1">scrollableSegmentsResult: Array&lt;FlightSegmentPath&gt;</span><span class="s3">\n</span><span class="s1">): SPANavigationTask {</span><span class="s3">\n  </span><span class="s1">// Same traversal as updateCacheNodeNavigation, but we switch to this path</span><span class="s3">\n  </span><span class="s1">// once we reach the part of the tree that was not in the previous route. We</span><span class="s3">\n  </span><span class="s1">// don't need to diff against the old tree, we just need to create a new one.</span><span class="s3">\n\n  </span><span class="s1">// The head is assigned to every leaf segment delivered by the server. Based</span><span class="s3">\n  </span><span class="s1">// on corresponding logic in fill-lazy-items-till-leaf-with-head.ts</span><span class="s3">\n  </span><span class="s1">const routerStateChildren = routerState[1]</span><span class="s3">\n  </span><span class="s1">const isLeafSegment = Object.keys(routerStateChildren).length === 0</span><span class="s3">\n\n  </span><span class="s1">// Even we're rendering inside the </span><span class="s3">\&quot;</span><span class="s1">new</span><span class="s3">\&quot; </span><span class="s1">part of the target tree, we may have</span><span class="s3">\n  </span><span class="s1">// a locally cached segment that we can reuse. This may come from either 1)</span><span class="s3">\n  </span><span class="s1">// the CacheNode tree, which lives in React state and is populated by previous</span><span class="s3">\n  </span><span class="s1">// navigations; or 2) the prefetch cache, which is a separate cache that is</span><span class="s3">\n  </span><span class="s1">// populated by prefetches.</span><span class="s3">\n  </span><span class="s1">let rsc: React.ReactNode</span><span class="s3">\n  </span><span class="s1">let loading: LoadingModuleData | Promise&lt;LoadingModuleData&gt;</span><span class="s3">\n  </span><span class="s1">let head: HeadData | null</span><span class="s3">\n  </span><span class="s1">let cacheNodeNavigatedAt: number</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">existingCacheNode !== undefined &amp;&amp;</span><span class="s3">\n    </span><span class="s1">// DYNAMIC_STALETIME_MS defaults to 0, but it can be increased using</span><span class="s3">\n    </span><span class="s1">// the experimental.staleTimes.dynamic config. When set, we'll avoid</span><span class="s3">\n    </span><span class="s1">// refetching dynamic data if it was fetched within the given threshold.</span><span class="s3">\n    </span><span class="s1">existingCacheNode.navigatedAt + DYNAMIC_STALETIME_MS &gt; navigatedAt</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// We have an existing CacheNode for this segment, and it's not stale. We</span><span class="s3">\n    </span><span class="s1">// should reuse it rather than request a new one.</span><span class="s3">\n    </span><span class="s1">rsc = existingCacheNode.rsc</span><span class="s3">\n    </span><span class="s1">loading = existingCacheNode.loading</span><span class="s3">\n    </span><span class="s1">head = existingCacheNode.head</span><span class="s3">\n\n    </span><span class="s1">// Don't update the navigatedAt timestamp, since we're reusing stale data.</span><span class="s3">\n    </span><span class="s1">cacheNodeNavigatedAt = existingCacheNode.navigatedAt</span><span class="s3">\n  </span><span class="s1">} else if (prefetchData !== null) {</span><span class="s3">\n    </span><span class="s1">// There's no existing CacheNode for this segment, but we do have prefetch</span><span class="s3">\n    </span><span class="s1">// data. If the prefetch data is fully static (i.e. does not contain any</span><span class="s3">\n    </span><span class="s1">// dynamic holes), we don't need to request it from the server.</span><span class="s3">\n    </span><span class="s1">rsc = prefetchData[1]</span><span class="s3">\n    </span><span class="s1">loading = prefetchData[3]</span><span class="s3">\n    </span><span class="s1">head = isLeafSegment ? possiblyPartialPrefetchHead : null</span><span class="s3">\n    </span><span class="s1">// Even though we're accessing the data from the prefetch cache, this is</span><span class="s3">\n    </span><span class="s1">// conceptually a new segment, not a reused one. So we should update the</span><span class="s3">\n    </span><span class="s1">// navigatedAt timestamp.</span><span class="s3">\n    </span><span class="s1">cacheNodeNavigatedAt = navigatedAt</span><span class="s3">\n    </span><span class="s1">const isPrefetchRscPartial = prefetchData[4]</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">// Check if the segment data is partial</span><span class="s3">\n      </span><span class="s1">isPrefetchRscPartial ||</span><span class="s3">\n      </span><span class="s1">// Check if the head is partial (only relevant if this is a leaf segment)</span><span class="s3">\n      </span><span class="s1">(isPrefetchHeadPartial &amp;&amp; isLeafSegment)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// We only have partial data from this segment. Like missing segments, we</span><span class="s3">\n      </span><span class="s1">// must request the full data from the server.</span><span class="s3">\n      </span><span class="s1">return spawnPendingTask(</span><span class="s3">\n        </span><span class="s1">navigatedAt,</span><span class="s3">\n        </span><span class="s1">routerState,</span><span class="s3">\n        </span><span class="s1">prefetchData,</span><span class="s3">\n        </span><span class="s1">possiblyPartialPrefetchHead,</span><span class="s3">\n        </span><span class="s1">isPrefetchHeadPartial,</span><span class="s3">\n        </span><span class="s1">segmentPath,</span><span class="s3">\n        </span><span class="s1">scrollableSegmentsResult</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// The prefetch data is fully static, so we can omit it from the</span><span class="s3">\n      </span><span class="s1">// navigation request.</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// There's no prefetch for this segment. Everything from this point will be</span><span class="s3">\n    </span><span class="s1">// requested from the server, even if there are static children below it.</span><span class="s3">\n    </span><span class="s1">// Create a terminal task node that will later be fulfilled by</span><span class="s3">\n    </span><span class="s1">// server response.</span><span class="s3">\n    </span><span class="s1">return spawnPendingTask(</span><span class="s3">\n      </span><span class="s1">navigatedAt,</span><span class="s3">\n      </span><span class="s1">routerState,</span><span class="s3">\n      </span><span class="s1">null,</span><span class="s3">\n      </span><span class="s1">possiblyPartialPrefetchHead,</span><span class="s3">\n      </span><span class="s1">isPrefetchHeadPartial,</span><span class="s3">\n      </span><span class="s1">segmentPath,</span><span class="s3">\n      </span><span class="s1">scrollableSegmentsResult</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// We already have a full segment we can render, so we don't need to request a</span><span class="s3">\n  </span><span class="s1">// new one from the server. Keep traversing down the tree until we reach</span><span class="s3">\n  </span><span class="s1">// something that requires a dynamic request.</span><span class="s3">\n  </span><span class="s1">const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null</span><span class="s3">\n  </span><span class="s1">const taskChildren = new Map()</span><span class="s3">\n  </span><span class="s1">const existingCacheNodeChildren =</span><span class="s3">\n    </span><span class="s1">existingCacheNode !== undefined ? existingCacheNode.parallelRoutes : null</span><span class="s3">\n  </span><span class="s1">const cacheNodeChildren = new Map(existingCacheNodeChildren)</span><span class="s3">\n  </span><span class="s1">let dynamicRequestTreeChildren: {</span><span class="s3">\n    </span><span class="s1">[parallelRouteKey: string]: FlightRouterState</span><span class="s3">\n  </span><span class="s1">} = {}</span><span class="s3">\n  </span><span class="s1">let needsDynamicRequest = false</span><span class="s3">\n  </span><span class="s1">if (isLeafSegment) {</span><span class="s3">\n    </span><span class="s1">// The segment path of every leaf segment (i.e. page) is collected into</span><span class="s3">\n    </span><span class="s1">// a result array. This is used by the LayoutRouter to scroll to ensure that</span><span class="s3">\n    </span><span class="s1">// new pages are visible after a navigation.</span><span class="s3">\n    </span><span class="s1">// TODO: We should use a string to represent the segment path instead of</span><span class="s3">\n    </span><span class="s1">// an array. We already use a string representation for the path when</span><span class="s3">\n    </span><span class="s1">// accessing the Segment Cache, so we can use the same one.</span><span class="s3">\n    </span><span class="s1">scrollableSegmentsResult.push(segmentPath)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">for (let parallelRouteKey in routerStateChildren) {</span><span class="s3">\n      </span><span class="s1">const routerStateChild: FlightRouterState =</span><span class="s3">\n        </span><span class="s1">routerStateChildren[parallelRouteKey]</span><span class="s3">\n      </span><span class="s1">const prefetchDataChild: CacheNodeSeedData | void | null =</span><span class="s3">\n        </span><span class="s1">prefetchDataChildren !== null</span><span class="s3">\n          </span><span class="s1">? prefetchDataChildren[parallelRouteKey]</span><span class="s3">\n          </span><span class="s1">: null</span><span class="s3">\n      </span><span class="s1">const existingSegmentMapChild =</span><span class="s3">\n        </span><span class="s1">existingCacheNodeChildren !== null</span><span class="s3">\n          </span><span class="s1">? existingCacheNodeChildren.get(parallelRouteKey)</span><span class="s3">\n          </span><span class="s1">: undefined</span><span class="s3">\n      </span><span class="s1">const segmentChild = routerStateChild[0]</span><span class="s3">\n      </span><span class="s1">const segmentPathChild = segmentPath.concat([</span><span class="s3">\n        </span><span class="s1">parallelRouteKey,</span><span class="s3">\n        </span><span class="s1">segmentChild,</span><span class="s3">\n      </span><span class="s1">])</span><span class="s3">\n      </span><span class="s1">const segmentKeyChild = createRouterCacheKey(segmentChild)</span><span class="s3">\n\n      </span><span class="s1">const existingCacheNodeChild =</span><span class="s3">\n        </span><span class="s1">existingSegmentMapChild !== undefined</span><span class="s3">\n          </span><span class="s1">? existingSegmentMapChild.get(segmentKeyChild)</span><span class="s3">\n          </span><span class="s1">: undefined</span><span class="s3">\n\n      </span><span class="s1">const taskChild = createCacheNodeOnNavigation(</span><span class="s3">\n        </span><span class="s1">navigatedAt,</span><span class="s3">\n        </span><span class="s1">routerStateChild,</span><span class="s3">\n        </span><span class="s1">existingCacheNodeChild,</span><span class="s3">\n        </span><span class="s1">prefetchDataChild,</span><span class="s3">\n        </span><span class="s1">possiblyPartialPrefetchHead,</span><span class="s3">\n        </span><span class="s1">isPrefetchHeadPartial,</span><span class="s3">\n        </span><span class="s1">segmentPathChild,</span><span class="s3">\n        </span><span class="s1">scrollableSegmentsResult</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">taskChildren.set(parallelRouteKey, taskChild)</span><span class="s3">\n      </span><span class="s1">const dynamicRequestTreeChild = taskChild.dynamicRequestTree</span><span class="s3">\n      </span><span class="s1">if (dynamicRequestTreeChild !== null) {</span><span class="s3">\n        </span><span class="s1">// Something in the child tree is dynamic.</span><span class="s3">\n        </span><span class="s1">needsDynamicRequest = true</span><span class="s3">\n        </span><span class="s1">dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">dynamicRequestTreeChildren[parallelRouteKey] = routerStateChild</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const newCacheNodeChild = taskChild.node</span><span class="s3">\n      </span><span class="s1">if (newCacheNodeChild !== null) {</span><span class="s3">\n        </span><span class="s1">const newSegmentMapChild: ChildSegmentMap = new Map()</span><span class="s3">\n        </span><span class="s1">newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)</span><span class="s3">\n        </span><span class="s1">cacheNodeChildren.set(parallelRouteKey, newSegmentMapChild)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">// Since we're inside a new route tree, unlike the</span><span class="s3">\n    </span><span class="s1">// `updateCacheNodeOnNavigation` path, the router state on the children</span><span class="s3">\n    </span><span class="s1">// tasks is always the same as the router state we pass in. So we don't need</span><span class="s3">\n    </span><span class="s1">// to clone/modify it.</span><span class="s3">\n    </span><span class="s1">route: routerState,</span><span class="s3">\n    </span><span class="s1">node: {</span><span class="s3">\n      </span><span class="s1">lazyData: null,</span><span class="s3">\n      </span><span class="s1">// Since this segment is already full, we don't need to use the</span><span class="s3">\n      </span><span class="s1">// `prefetchRsc` field.</span><span class="s3">\n      </span><span class="s1">rsc,</span><span class="s3">\n      </span><span class="s1">prefetchRsc: null,</span><span class="s3">\n      </span><span class="s1">head,</span><span class="s3">\n      </span><span class="s1">prefetchHead: null,</span><span class="s3">\n      </span><span class="s1">loading,</span><span class="s3">\n      </span><span class="s1">parallelRoutes: cacheNodeChildren,</span><span class="s3">\n      </span><span class="s1">navigatedAt: cacheNodeNavigatedAt,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">dynamicRequestTree: needsDynamicRequest</span><span class="s3">\n      </span><span class="s1">? patchRouterStateWithNewChildren(routerState, dynamicRequestTreeChildren)</span><span class="s3">\n      </span><span class="s1">: null,</span><span class="s3">\n    </span><span class="s1">children: taskChildren,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function patchRouterStateWithNewChildren(</span><span class="s3">\n  </span><span class="s1">baseRouterState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">newChildren: { [parallelRouteKey: string]: FlightRouterState }</span><span class="s3">\n</span><span class="s1">): FlightRouterState {</span><span class="s3">\n  </span><span class="s1">const clone: FlightRouterState = [baseRouterState[0], newChildren]</span><span class="s3">\n  </span><span class="s1">// Based on equivalent logic in apply-router-state-patch-to-tree, but should</span><span class="s3">\n  </span><span class="s1">// confirm whether we need to copy all of these fields. Not sure the server</span><span class="s3">\n  </span><span class="s1">// ever sends, e.g. the refetch marker.</span><span class="s3">\n  </span><span class="s1">if (2 in baseRouterState) {</span><span class="s3">\n    </span><span class="s1">clone[2] = baseRouterState[2]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (3 in baseRouterState) {</span><span class="s3">\n    </span><span class="s1">clone[3] = baseRouterState[3]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (4 in baseRouterState) {</span><span class="s3">\n    </span><span class="s1">clone[4] = baseRouterState[4]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return clone</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function spawnPendingTask(</span><span class="s3">\n  </span><span class="s1">navigatedAt: number,</span><span class="s3">\n  </span><span class="s1">routerState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">prefetchData: CacheNodeSeedData | null,</span><span class="s3">\n  </span><span class="s1">prefetchHead: HeadData | null,</span><span class="s3">\n  </span><span class="s1">isPrefetchHeadPartial: boolean,</span><span class="s3">\n  </span><span class="s1">segmentPath: FlightSegmentPath,</span><span class="s3">\n  </span><span class="s1">scrollableSegmentsResult: Array&lt;FlightSegmentPath&gt;</span><span class="s3">\n</span><span class="s1">): SPANavigationTask {</span><span class="s3">\n  </span><span class="s1">// Create a task that will later be fulfilled by data from the server.</span><span class="s3">\n\n  </span><span class="s1">// Clone the prefetched route tree and the `refetch` marker to it. We'll send</span><span class="s3">\n  </span><span class="s1">// this to the server so it knows where to start rendering.</span><span class="s3">\n  </span><span class="s1">const dynamicRequestTree = patchRouterStateWithNewChildren(</span><span class="s3">\n    </span><span class="s1">routerState,</span><span class="s3">\n    </span><span class="s1">routerState[1]</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">dynamicRequestTree[3] = 'refetch'</span><span class="s3">\n\n  </span><span class="s1">const newTask: Task = {</span><span class="s3">\n    </span><span class="s1">route: routerState,</span><span class="s3">\n\n    </span><span class="s1">// Corresponds to the part of the route that will be rendered on the server.</span><span class="s3">\n    </span><span class="s1">node: createPendingCacheNode(</span><span class="s3">\n      </span><span class="s1">navigatedAt,</span><span class="s3">\n      </span><span class="s1">routerState,</span><span class="s3">\n      </span><span class="s1">prefetchData,</span><span class="s3">\n      </span><span class="s1">prefetchHead,</span><span class="s3">\n      </span><span class="s1">isPrefetchHeadPartial,</span><span class="s3">\n      </span><span class="s1">segmentPath,</span><span class="s3">\n      </span><span class="s1">scrollableSegmentsResult</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">// Because this is non-null, and it gets propagated up through the parent</span><span class="s3">\n    </span><span class="s1">// tasks, the root task will know that it needs to perform a server request.</span><span class="s3">\n    </span><span class="s1">dynamicRequestTree,</span><span class="s3">\n    </span><span class="s1">children: null,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return newTask</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function spawnReusedTask(reusedRouterState: FlightRouterState): Task {</span><span class="s3">\n  </span><span class="s1">// Create a task that reuses an existing segment, e.g. when reusing</span><span class="s3">\n  </span><span class="s1">// the current active segment in place of a default route.</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">route: reusedRouterState,</span><span class="s3">\n    </span><span class="s1">node: null,</span><span class="s3">\n    </span><span class="s1">dynamicRequestTree: null,</span><span class="s3">\n    </span><span class="s1">children: null,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Writes a dynamic server response into the tree created by</span><span class="s3">\n</span><span class="s1">// updateCacheNodeOnNavigation. All pending promises that were spawned by the</span><span class="s3">\n</span><span class="s1">// navigation will be resolved, either with dynamic data from the server, or</span><span class="s3">\n</span><span class="s1">// `null` to indicate that the data is missing.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// A `null` value will trigger a lazy fetch during render, which will then patch</span><span class="s3">\n</span><span class="s1">// up the tree using the same mechanism as the non-PPR implementation</span><span class="s3">\n</span><span class="s1">// (serverPatchReducer).</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Usually, the server will respond with exactly the subset of data that we're</span><span class="s3">\n</span><span class="s1">// waiting for  everything below the nearest shared layout. But technically,</span><span class="s3">\n</span><span class="s1">// the server can return anything it wants.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// This does _not_ create a new tree; it modifies the existing one in place.</span><span class="s3">\n</span><span class="s1">// Which means it must follow the Suspense rules of cache safety.</span><span class="s3">\n</span><span class="s1">export function listenForDynamicRequest(</span><span class="s3">\n  </span><span class="s1">task: SPANavigationTask,</span><span class="s3">\n  </span><span class="s1">responsePromise: Promise&lt;FetchServerResponseResult&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">responsePromise.then(</span><span class="s3">\n    </span><span class="s1">({ flightData }: FetchServerResponseResult) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (typeof flightData === 'string') {</span><span class="s3">\n        </span><span class="s1">// Happens when navigating to page in `pages` from `app`. We shouldn't</span><span class="s3">\n        </span><span class="s1">// get here because should have already handled this during</span><span class="s3">\n        </span><span class="s1">// the prefetch.</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">for (const normalizedFlightData of flightData) {</span><span class="s3">\n        </span><span class="s1">const {</span><span class="s3">\n          </span><span class="s1">segmentPath,</span><span class="s3">\n          </span><span class="s1">tree: serverRouterState,</span><span class="s3">\n          </span><span class="s1">seedData: dynamicData,</span><span class="s3">\n          </span><span class="s1">head: dynamicHead,</span><span class="s3">\n        </span><span class="s1">} = normalizedFlightData</span><span class="s3">\n\n        </span><span class="s1">if (!dynamicData) {</span><span class="s3">\n          </span><span class="s1">// This shouldn't happen. PPR should always send back a response.</span><span class="s3">\n          </span><span class="s1">// However, `FlightDataPath` is a shared type and the pre-PPR handling of</span><span class="s3">\n          </span><span class="s1">// this might return null.</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">writeDynamicDataIntoPendingTask(</span><span class="s3">\n          </span><span class="s1">task,</span><span class="s3">\n          </span><span class="s1">segmentPath,</span><span class="s3">\n          </span><span class="s1">serverRouterState,</span><span class="s3">\n          </span><span class="s1">dynamicData,</span><span class="s3">\n          </span><span class="s1">dynamicHead</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Now that we've exhausted all the data we received from the server, if</span><span class="s3">\n      </span><span class="s1">// there are any remaining pending tasks in the tree, abort them now.</span><span class="s3">\n      </span><span class="s1">// If there's any missing data, it will trigger a lazy fetch.</span><span class="s3">\n      </span><span class="s1">abortTask(task, null)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">(error: any) =&gt; {</span><span class="s3">\n      </span><span class="s1">// This will trigger an error during render</span><span class="s3">\n      </span><span class="s1">abortTask(task, error)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function writeDynamicDataIntoPendingTask(</span><span class="s3">\n  </span><span class="s1">rootTask: SPANavigationTask,</span><span class="s3">\n  </span><span class="s1">segmentPath: FlightSegmentPath,</span><span class="s3">\n  </span><span class="s1">serverRouterState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">dynamicData: CacheNodeSeedData,</span><span class="s3">\n  </span><span class="s1">dynamicHead: HeadData</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// The data sent by the server represents only a subtree of the app. We need</span><span class="s3">\n  </span><span class="s1">// to find the part of the task tree that matches the server response, and</span><span class="s3">\n  </span><span class="s1">// fulfill it using the dynamic data.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// segmentPath represents the parent path of subtree. It's a repeating pattern</span><span class="s3">\n  </span><span class="s1">// of parallel route key and segment:</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">//   [string, Segment, string, Segment, string, Segment, ...]</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Iterate through the path and finish any tasks that match this payload.</span><span class="s3">\n  </span><span class="s1">let task = rootTask</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; segmentPath.length; i += 2) {</span><span class="s3">\n    </span><span class="s1">const parallelRouteKey: string = segmentPath[i]</span><span class="s3">\n    </span><span class="s1">const segment: Segment = segmentPath[i + 1]</span><span class="s3">\n    </span><span class="s1">const taskChildren = task.children</span><span class="s3">\n    </span><span class="s1">if (taskChildren !== null) {</span><span class="s3">\n      </span><span class="s1">const taskChild = taskChildren.get(parallelRouteKey)</span><span class="s3">\n      </span><span class="s1">if (taskChild !== undefined) {</span><span class="s3">\n        </span><span class="s1">const taskSegment = taskChild.route[0]</span><span class="s3">\n        </span><span class="s1">if (matchSegment(segment, taskSegment)) {</span><span class="s3">\n          </span><span class="s1">// Found a match for this task. Keep traversing down the task tree.</span><span class="s3">\n          </span><span class="s1">task = taskChild</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// We didn't find a child task that matches the server data. Exit. We won't</span><span class="s3">\n    </span><span class="s1">// abort the task, though, because a different FlightDataPath may be able to</span><span class="s3">\n    </span><span class="s1">// fulfill it (see loop in listenForDynamicRequest). We only abort tasks</span><span class="s3">\n    </span><span class="s1">// once we've run out of data.</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">finishTaskUsingDynamicDataPayload(</span><span class="s3">\n    </span><span class="s1">task,</span><span class="s3">\n    </span><span class="s1">serverRouterState,</span><span class="s3">\n    </span><span class="s1">dynamicData,</span><span class="s3">\n    </span><span class="s1">dynamicHead</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function finishTaskUsingDynamicDataPayload(</span><span class="s3">\n  </span><span class="s1">task: SPANavigationTask,</span><span class="s3">\n  </span><span class="s1">serverRouterState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">dynamicData: CacheNodeSeedData,</span><span class="s3">\n  </span><span class="s1">dynamicHead: HeadData</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (task.dynamicRequestTree === null) {</span><span class="s3">\n    </span><span class="s1">// Everything in this subtree is already complete. Bail out.</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// dynamicData may represent a larger subtree than the task. Before we can</span><span class="s3">\n  </span><span class="s1">// finish the task, we need to line them up.</span><span class="s3">\n  </span><span class="s1">const taskChildren = task.children</span><span class="s3">\n  </span><span class="s1">const taskNode = task.node</span><span class="s3">\n  </span><span class="s1">if (taskChildren === null) {</span><span class="s3">\n    </span><span class="s1">// We've reached the leaf node of the pending task. The server data tree</span><span class="s3">\n    </span><span class="s1">// lines up the pending Cache Node tree. We can now switch to the</span><span class="s3">\n    </span><span class="s1">// normal algorithm.</span><span class="s3">\n    </span><span class="s1">if (taskNode !== null) {</span><span class="s3">\n      </span><span class="s1">finishPendingCacheNode(</span><span class="s3">\n        </span><span class="s1">taskNode,</span><span class="s3">\n        </span><span class="s1">task.route,</span><span class="s3">\n        </span><span class="s1">serverRouterState,</span><span class="s3">\n        </span><span class="s1">dynamicData,</span><span class="s3">\n        </span><span class="s1">dynamicHead</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">// Set this to null to indicate that this task is now complete.</span><span class="s3">\n      </span><span class="s1">task.dynamicRequestTree = null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// The server returned more data than we need to finish the task. Skip over</span><span class="s3">\n  </span><span class="s1">// the extra segments until we reach the leaf task node.</span><span class="s3">\n  </span><span class="s1">const serverChildren = serverRouterState[1]</span><span class="s3">\n  </span><span class="s1">const dynamicDataChildren = dynamicData[2]</span><span class="s3">\n\n  </span><span class="s1">for (const parallelRouteKey in serverRouterState) {</span><span class="s3">\n    </span><span class="s1">const serverRouterStateChild: FlightRouterState =</span><span class="s3">\n      </span><span class="s1">serverChildren[parallelRouteKey]</span><span class="s3">\n    </span><span class="s1">const dynamicDataChild: CacheNodeSeedData | null | void =</span><span class="s3">\n      </span><span class="s1">dynamicDataChildren[parallelRouteKey]</span><span class="s3">\n\n    </span><span class="s1">const taskChild = taskChildren.get(parallelRouteKey)</span><span class="s3">\n    </span><span class="s1">if (taskChild !== undefined) {</span><span class="s3">\n      </span><span class="s1">const taskSegment = taskChild.route[0]</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">matchSegment(serverRouterStateChild[0], taskSegment) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">dynamicDataChild !== null &amp;&amp;</span><span class="s3">\n        </span><span class="s1">dynamicDataChild !== undefined</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// Found a match for this task. Keep traversing down the task tree.</span><span class="s3">\n        </span><span class="s1">return finishTaskUsingDynamicDataPayload(</span><span class="s3">\n          </span><span class="s1">taskChild,</span><span class="s3">\n          </span><span class="s1">serverRouterStateChild,</span><span class="s3">\n          </span><span class="s1">dynamicDataChild,</span><span class="s3">\n          </span><span class="s1">dynamicHead</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// We didn't find a child task that matches the server data. We won't abort</span><span class="s3">\n    </span><span class="s1">// the task, though, because a different FlightDataPath may be able to</span><span class="s3">\n    </span><span class="s1">// fulfill it (see loop in listenForDynamicRequest). We only abort tasks</span><span class="s3">\n    </span><span class="s1">// once we've run out of data.</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createPendingCacheNode(</span><span class="s3">\n  </span><span class="s1">navigatedAt: number,</span><span class="s3">\n  </span><span class="s1">routerState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">prefetchData: CacheNodeSeedData | null,</span><span class="s3">\n  </span><span class="s1">prefetchHead: HeadData | null,</span><span class="s3">\n  </span><span class="s1">isPrefetchHeadPartial: boolean,</span><span class="s3">\n  </span><span class="s1">segmentPath: FlightSegmentPath,</span><span class="s3">\n  </span><span class="s1">scrollableSegmentsResult: Array&lt;FlightSegmentPath&gt;</span><span class="s3">\n</span><span class="s1">): ReadyCacheNode {</span><span class="s3">\n  </span><span class="s1">const routerStateChildren = routerState[1]</span><span class="s3">\n  </span><span class="s1">const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null</span><span class="s3">\n\n  </span><span class="s1">const parallelRoutes = new Map()</span><span class="s3">\n  </span><span class="s1">for (let parallelRouteKey in routerStateChildren) {</span><span class="s3">\n    </span><span class="s1">const routerStateChild: FlightRouterState =</span><span class="s3">\n      </span><span class="s1">routerStateChildren[parallelRouteKey]</span><span class="s3">\n    </span><span class="s1">const prefetchDataChild: CacheNodeSeedData | null | void =</span><span class="s3">\n      </span><span class="s1">prefetchDataChildren !== null</span><span class="s3">\n        </span><span class="s1">? prefetchDataChildren[parallelRouteKey]</span><span class="s3">\n        </span><span class="s1">: null</span><span class="s3">\n\n    </span><span class="s1">const segmentChild = routerStateChild[0]</span><span class="s3">\n    </span><span class="s1">const segmentPathChild = segmentPath.concat([</span><span class="s3">\n      </span><span class="s1">parallelRouteKey,</span><span class="s3">\n      </span><span class="s1">segmentChild,</span><span class="s3">\n    </span><span class="s1">])</span><span class="s3">\n    </span><span class="s1">const segmentKeyChild = createRouterCacheKey(segmentChild)</span><span class="s3">\n\n    </span><span class="s1">const newCacheNodeChild = createPendingCacheNode(</span><span class="s3">\n      </span><span class="s1">navigatedAt,</span><span class="s3">\n      </span><span class="s1">routerStateChild,</span><span class="s3">\n      </span><span class="s1">prefetchDataChild === undefined ? null : prefetchDataChild,</span><span class="s3">\n      </span><span class="s1">prefetchHead,</span><span class="s3">\n      </span><span class="s1">isPrefetchHeadPartial,</span><span class="s3">\n      </span><span class="s1">segmentPathChild,</span><span class="s3">\n      </span><span class="s1">scrollableSegmentsResult</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const newSegmentMapChild: ChildSegmentMap = new Map()</span><span class="s3">\n    </span><span class="s1">newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)</span><span class="s3">\n    </span><span class="s1">parallelRoutes.set(parallelRouteKey, newSegmentMapChild)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// The head is assigned to every leaf segment delivered by the server. Based</span><span class="s3">\n  </span><span class="s1">// on corresponding logic in fill-lazy-items-till-leaf-with-head.ts</span><span class="s3">\n  </span><span class="s1">const isLeafSegment = parallelRoutes.size === 0</span><span class="s3">\n\n  </span><span class="s1">if (isLeafSegment) {</span><span class="s3">\n    </span><span class="s1">// The segment path of every leaf segment (i.e. page) is collected into</span><span class="s3">\n    </span><span class="s1">// a result array. This is used by the LayoutRouter to scroll to ensure that</span><span class="s3">\n    </span><span class="s1">// new pages are visible after a navigation.</span><span class="s3">\n    </span><span class="s1">// TODO: We should use a string to represent the segment path instead of</span><span class="s3">\n    </span><span class="s1">// an array. We already use a string representation for the path when</span><span class="s3">\n    </span><span class="s1">// accessing the Segment Cache, so we can use the same one.</span><span class="s3">\n    </span><span class="s1">scrollableSegmentsResult.push(segmentPath)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const maybePrefetchRsc = prefetchData !== null ? prefetchData[1] : null</span><span class="s3">\n  </span><span class="s1">const maybePrefetchLoading = prefetchData !== null ? prefetchData[3] : null</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">lazyData: null,</span><span class="s3">\n    </span><span class="s1">parallelRoutes: parallelRoutes,</span><span class="s3">\n\n    </span><span class="s1">prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,</span><span class="s3">\n    </span><span class="s1">prefetchHead: isLeafSegment ? prefetchHead : [null, null],</span><span class="s3">\n\n    </span><span class="s1">// TODO: Technically, a loading boundary could contain dynamic data. We must</span><span class="s3">\n    </span><span class="s1">// have separate `loading` and `prefetchLoading` fields to handle this, like</span><span class="s3">\n    </span><span class="s1">// we do for the segment data and head.</span><span class="s3">\n    </span><span class="s1">loading: maybePrefetchLoading !== undefined ? maybePrefetchLoading : null,</span><span class="s3">\n\n    </span><span class="s1">// Create a deferred promise. This will be fulfilled once the dynamic</span><span class="s3">\n    </span><span class="s1">// response is received from the server.</span><span class="s3">\n    </span><span class="s1">rsc: createDeferredRsc() as React.ReactNode,</span><span class="s3">\n    </span><span class="s1">head: isLeafSegment ? (createDeferredRsc() as React.ReactNode) : null,</span><span class="s3">\n\n    </span><span class="s1">navigatedAt,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function finishPendingCacheNode(</span><span class="s3">\n  </span><span class="s1">cacheNode: CacheNode,</span><span class="s3">\n  </span><span class="s1">taskState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">serverState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">dynamicData: CacheNodeSeedData,</span><span class="s3">\n  </span><span class="s1">dynamicHead: HeadData</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">// Writes a dynamic response into an existing Cache Node tree. This does _not_</span><span class="s3">\n  </span><span class="s1">// create a new tree, it updates the existing tree in-place. So it must follow</span><span class="s3">\n  </span><span class="s1">// the Suspense rules of cache safety  it can resolve pending promises, but</span><span class="s3">\n  </span><span class="s1">// it cannot overwrite existing data. It can add segments to the tree (because</span><span class="s3">\n  </span><span class="s1">// a missing segment will cause the layout router to suspend).</span><span class="s3">\n  </span><span class="s1">// but it cannot delete them.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// We must resolve every promise in the tree, or else it will suspend</span><span class="s3">\n  </span><span class="s1">// indefinitely. If we did not receive data for a segment, we will resolve its</span><span class="s3">\n  </span><span class="s1">// data promise to `null` to trigger a lazy fetch during render.</span><span class="s3">\n  </span><span class="s1">const taskStateChildren = taskState[1]</span><span class="s3">\n  </span><span class="s1">const serverStateChildren = serverState[1]</span><span class="s3">\n  </span><span class="s1">const dataChildren = dynamicData[2]</span><span class="s3">\n\n  </span><span class="s1">// The router state that we traverse the tree with (taskState) is the same one</span><span class="s3">\n  </span><span class="s1">// that we used to construct the pending Cache Node tree. That way we're sure</span><span class="s3">\n  </span><span class="s1">// to resolve all the pending promises.</span><span class="s3">\n  </span><span class="s1">const parallelRoutes = cacheNode.parallelRoutes</span><span class="s3">\n  </span><span class="s1">for (let parallelRouteKey in taskStateChildren) {</span><span class="s3">\n    </span><span class="s1">const taskStateChild: FlightRouterState =</span><span class="s3">\n      </span><span class="s1">taskStateChildren[parallelRouteKey]</span><span class="s3">\n    </span><span class="s1">const serverStateChild: FlightRouterState | void =</span><span class="s3">\n      </span><span class="s1">serverStateChildren[parallelRouteKey]</span><span class="s3">\n    </span><span class="s1">const dataChild: CacheNodeSeedData | null | void =</span><span class="s3">\n      </span><span class="s1">dataChildren[parallelRouteKey]</span><span class="s3">\n\n    </span><span class="s1">const segmentMapChild = parallelRoutes.get(parallelRouteKey)</span><span class="s3">\n    </span><span class="s1">const taskSegmentChild = taskStateChild[0]</span><span class="s3">\n    </span><span class="s1">const taskSegmentKeyChild = createRouterCacheKey(taskSegmentChild)</span><span class="s3">\n\n    </span><span class="s1">const cacheNodeChild =</span><span class="s3">\n      </span><span class="s1">segmentMapChild !== undefined</span><span class="s3">\n        </span><span class="s1">? segmentMapChild.get(taskSegmentKeyChild)</span><span class="s3">\n        </span><span class="s1">: undefined</span><span class="s3">\n\n    </span><span class="s1">if (cacheNodeChild !== undefined) {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">serverStateChild !== undefined &amp;&amp;</span><span class="s3">\n        </span><span class="s1">matchSegment(taskSegmentChild, serverStateChild[0])</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">if (dataChild !== undefined &amp;&amp; dataChild !== null) {</span><span class="s3">\n          </span><span class="s1">// This is the happy path. Recursively update all the children.</span><span class="s3">\n          </span><span class="s1">finishPendingCacheNode(</span><span class="s3">\n            </span><span class="s1">cacheNodeChild,</span><span class="s3">\n            </span><span class="s1">taskStateChild,</span><span class="s3">\n            </span><span class="s1">serverStateChild,</span><span class="s3">\n            </span><span class="s1">dataChild,</span><span class="s3">\n            </span><span class="s1">dynamicHead</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// The server never returned data for this segment. Trigger a lazy</span><span class="s3">\n          </span><span class="s1">// fetch during render. This shouldn't happen because the Route Tree</span><span class="s3">\n          </span><span class="s1">// and the Seed Data tree sent by the server should always be the same</span><span class="s3">\n          </span><span class="s1">// shape when part of the same server response.</span><span class="s3">\n          </span><span class="s1">abortPendingCacheNode(taskStateChild, cacheNodeChild, null)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// The server never returned data for this segment. Trigger a lazy</span><span class="s3">\n        </span><span class="s1">// fetch during render.</span><span class="s3">\n        </span><span class="s1">abortPendingCacheNode(taskStateChild, cacheNodeChild, null)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// The server response matches what was expected to receive, but there's</span><span class="s3">\n      </span><span class="s1">// no matching Cache Node in the task tree. This is a bug in the</span><span class="s3">\n      </span><span class="s1">// implementation because we should have created a node for every</span><span class="s3">\n      </span><span class="s1">// segment in the tree that's associated with this task.</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Use the dynamic data from the server to fulfill the deferred RSC promise</span><span class="s3">\n  </span><span class="s1">// on the Cache Node.</span><span class="s3">\n  </span><span class="s1">const rsc = cacheNode.rsc</span><span class="s3">\n  </span><span class="s1">const dynamicSegmentData = dynamicData[1]</span><span class="s3">\n  </span><span class="s1">if (rsc === null) {</span><span class="s3">\n    </span><span class="s1">// This is a lazy cache node. We can overwrite it. This is only safe</span><span class="s3">\n    </span><span class="s1">// because we know that the LayoutRouter suspends if `rsc` is `null`.</span><span class="s3">\n    </span><span class="s1">cacheNode.rsc = dynamicSegmentData</span><span class="s3">\n  </span><span class="s1">} else if (isDeferredRsc(rsc)) {</span><span class="s3">\n    </span><span class="s1">// This is a deferred RSC promise. We can fulfill it with the data we just</span><span class="s3">\n    </span><span class="s1">// received from the server. If it was already resolved by a different</span><span class="s3">\n    </span><span class="s1">// navigation, then this does nothing because we can't overwrite data.</span><span class="s3">\n    </span><span class="s1">rsc.resolve(dynamicSegmentData)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// This is not a deferred RSC promise, nor is it empty, so it must have</span><span class="s3">\n    </span><span class="s1">// been populated by a different navigation. We must not overwrite it.</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Check if this is a leaf segment. If so, it will have a `head` property with</span><span class="s3">\n  </span><span class="s1">// a pending promise that needs to be resolved with the dynamic head from</span><span class="s3">\n  </span><span class="s1">// the server.</span><span class="s3">\n  </span><span class="s1">const head = cacheNode.head</span><span class="s3">\n  </span><span class="s1">if (isDeferredRsc(head)) {</span><span class="s3">\n    </span><span class="s1">head.resolve(dynamicHead)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function abortTask(task: SPANavigationTask, error: any): void {</span><span class="s3">\n  </span><span class="s1">const cacheNode = task.node</span><span class="s3">\n  </span><span class="s1">if (cacheNode === null) {</span><span class="s3">\n    </span><span class="s1">// This indicates the task is already complete.</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const taskChildren = task.children</span><span class="s3">\n  </span><span class="s1">if (taskChildren === null) {</span><span class="s3">\n    </span><span class="s1">// Reached the leaf task node. This is the root of a pending cache</span><span class="s3">\n    </span><span class="s1">// node tree.</span><span class="s3">\n    </span><span class="s1">abortPendingCacheNode(task.route, cacheNode, error)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// This is an intermediate task node. Keep traversing until we reach a</span><span class="s3">\n    </span><span class="s1">// task node with no children. That will be the root of the cache node tree</span><span class="s3">\n    </span><span class="s1">// that needs to be resolved.</span><span class="s3">\n    </span><span class="s1">for (const taskChild of taskChildren.values()) {</span><span class="s3">\n      </span><span class="s1">abortTask(taskChild, error)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Set this to null to indicate that this task is now complete.</span><span class="s3">\n  </span><span class="s1">task.dynamicRequestTree = null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function abortPendingCacheNode(</span><span class="s3">\n  </span><span class="s1">routerState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">cacheNode: CacheNode,</span><span class="s3">\n  </span><span class="s1">error: any</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">// For every pending segment in the tree, resolve its `rsc` promise to `null`</span><span class="s3">\n  </span><span class="s1">// to trigger a lazy fetch during render.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Or, if an error object is provided, it will error instead.</span><span class="s3">\n  </span><span class="s1">const routerStateChildren = routerState[1]</span><span class="s3">\n  </span><span class="s1">const parallelRoutes = cacheNode.parallelRoutes</span><span class="s3">\n  </span><span class="s1">for (let parallelRouteKey in routerStateChildren) {</span><span class="s3">\n    </span><span class="s1">const routerStateChild: FlightRouterState =</span><span class="s3">\n      </span><span class="s1">routerStateChildren[parallelRouteKey]</span><span class="s3">\n    </span><span class="s1">const segmentMapChild = parallelRoutes.get(parallelRouteKey)</span><span class="s3">\n    </span><span class="s1">if (segmentMapChild === undefined) {</span><span class="s3">\n      </span><span class="s1">// This shouldn't happen because we're traversing the same tree that was</span><span class="s3">\n      </span><span class="s1">// used to construct the cache nodes in the first place.</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const segmentChild = routerStateChild[0]</span><span class="s3">\n    </span><span class="s1">const segmentKeyChild = createRouterCacheKey(segmentChild)</span><span class="s3">\n    </span><span class="s1">const cacheNodeChild = segmentMapChild.get(segmentKeyChild)</span><span class="s3">\n    </span><span class="s1">if (cacheNodeChild !== undefined) {</span><span class="s3">\n      </span><span class="s1">abortPendingCacheNode(routerStateChild, cacheNodeChild, error)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// This shouldn't happen because we're traversing the same tree that was</span><span class="s3">\n      </span><span class="s1">// used to construct the cache nodes in the first place.</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const rsc = cacheNode.rsc</span><span class="s3">\n  </span><span class="s1">if (isDeferredRsc(rsc)) {</span><span class="s3">\n    </span><span class="s1">if (error === null) {</span><span class="s3">\n      </span><span class="s1">// This will trigger a lazy fetch during render.</span><span class="s3">\n      </span><span class="s1">rsc.resolve(null)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// This will trigger an error during rendering.</span><span class="s3">\n      </span><span class="s1">rsc.reject(error)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Check if this is a leaf segment. If so, it will have a `head` property with</span><span class="s3">\n  </span><span class="s1">// a pending promise that needs to be resolved. If an error was provided, we</span><span class="s3">\n  </span><span class="s1">// will not resolve it with an error, since this is rendered at the root of</span><span class="s3">\n  </span><span class="s1">// the app. We want the segment to error, not the entire app.</span><span class="s3">\n  </span><span class="s1">const head = cacheNode.head</span><span class="s3">\n  </span><span class="s1">if (isDeferredRsc(head)) {</span><span class="s3">\n    </span><span class="s1">head.resolve(null)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function updateCacheNodeOnPopstateRestoration(</span><span class="s3">\n  </span><span class="s1">oldCacheNode: CacheNode,</span><span class="s3">\n  </span><span class="s1">routerState: FlightRouterState</span><span class="s3">\n</span><span class="s1">): ReadyCacheNode {</span><span class="s3">\n  </span><span class="s1">// A popstate navigation reads data from the local cache. It does not issue</span><span class="s3">\n  </span><span class="s1">// new network requests (unless the cache entries have been evicted). So, we</span><span class="s3">\n  </span><span class="s1">// update the cache to drop the prefetch data for any segment whose dynamic</span><span class="s3">\n  </span><span class="s1">// data was already received. This prevents an unnecessary flash back to PPR</span><span class="s3">\n  </span><span class="s1">// state during a back/forward navigation.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// This function clones the entire cache node tree and sets the `prefetchRsc`</span><span class="s3">\n  </span><span class="s1">// field to `null` to prevent it from being rendered. We can't mutate the node</span><span class="s3">\n  </span><span class="s1">// in place because this is a concurrent data structure.</span><span class="s3">\n\n  </span><span class="s1">const routerStateChildren = routerState[1]</span><span class="s3">\n  </span><span class="s1">const oldParallelRoutes = oldCacheNode.parallelRoutes</span><span class="s3">\n  </span><span class="s1">const newParallelRoutes = new Map(oldParallelRoutes)</span><span class="s3">\n  </span><span class="s1">for (let parallelRouteKey in routerStateChildren) {</span><span class="s3">\n    </span><span class="s1">const routerStateChild: FlightRouterState =</span><span class="s3">\n      </span><span class="s1">routerStateChildren[parallelRouteKey]</span><span class="s3">\n    </span><span class="s1">const segmentChild = routerStateChild[0]</span><span class="s3">\n    </span><span class="s1">const segmentKeyChild = createRouterCacheKey(segmentChild)</span><span class="s3">\n    </span><span class="s1">const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)</span><span class="s3">\n    </span><span class="s1">if (oldSegmentMapChild !== undefined) {</span><span class="s3">\n      </span><span class="s1">const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild)</span><span class="s3">\n      </span><span class="s1">if (oldCacheNodeChild !== undefined) {</span><span class="s3">\n        </span><span class="s1">const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(</span><span class="s3">\n          </span><span class="s1">oldCacheNodeChild,</span><span class="s3">\n          </span><span class="s1">routerStateChild</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">const newSegmentMapChild = new Map(oldSegmentMapChild)</span><span class="s3">\n        </span><span class="s1">newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)</span><span class="s3">\n        </span><span class="s1">newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Only show prefetched data if the dynamic data is still pending.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Tehnically, what we're actually checking is whether the dynamic network</span><span class="s3">\n  </span><span class="s1">// response was received. But since it's a streaming response, this does not</span><span class="s3">\n  </span><span class="s1">// mean that all the dynamic data has fully streamed in. It just means that</span><span class="s3">\n  </span><span class="s1">// _some_ of the dynamic data was received. But as a heuristic, we assume that</span><span class="s3">\n  </span><span class="s1">// the rest dynamic data will stream in quickly, so it's still better to skip</span><span class="s3">\n  </span><span class="s1">// the prefetch state.</span><span class="s3">\n  </span><span class="s1">const rsc = oldCacheNode.rsc</span><span class="s3">\n  </span><span class="s1">const shouldUsePrefetch = isDeferredRsc(rsc) &amp;&amp; rsc.status === 'pending'</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">lazyData: null,</span><span class="s3">\n    </span><span class="s1">rsc,</span><span class="s3">\n    </span><span class="s1">head: oldCacheNode.head,</span><span class="s3">\n\n    </span><span class="s1">prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : [null, null],</span><span class="s3">\n    </span><span class="s1">prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,</span><span class="s3">\n    </span><span class="s1">loading: oldCacheNode.loading,</span><span class="s3">\n\n    </span><span class="s1">// These are the cloned children we computed above</span><span class="s3">\n    </span><span class="s1">parallelRoutes: newParallelRoutes,</span><span class="s3">\n\n    </span><span class="s1">navigatedAt: oldCacheNode.navigatedAt,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const DEFERRED = Symbol()</span><span class="s3">\n\n</span><span class="s1">type PendingDeferredRsc = Promise&lt;React.ReactNode&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">status: 'pending'</span><span class="s3">\n  </span><span class="s1">resolve: (value: React.ReactNode) =&gt; void</span><span class="s3">\n  </span><span class="s1">reject: (error: any) =&gt; void</span><span class="s3">\n  </span><span class="s1">tag: Symbol</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type FulfilledDeferredRsc = Promise&lt;React.ReactNode&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">status: 'fulfilled'</span><span class="s3">\n  </span><span class="s1">value: React.ReactNode</span><span class="s3">\n  </span><span class="s1">resolve: (value: React.ReactNode) =&gt; void</span><span class="s3">\n  </span><span class="s1">reject: (error: any) =&gt; void</span><span class="s3">\n  </span><span class="s1">tag: Symbol</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type RejectedDeferredRsc = Promise&lt;React.ReactNode&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">status: 'rejected'</span><span class="s3">\n  </span><span class="s1">reason: any</span><span class="s3">\n  </span><span class="s1">resolve: (value: React.ReactNode) =&gt; void</span><span class="s3">\n  </span><span class="s1">reject: (error: any) =&gt; void</span><span class="s3">\n  </span><span class="s1">tag: Symbol</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type DeferredRsc =</span><span class="s3">\n  </span><span class="s1">| PendingDeferredRsc</span><span class="s3">\n  </span><span class="s1">| FulfilledDeferredRsc</span><span class="s3">\n  </span><span class="s1">| RejectedDeferredRsc</span><span class="s3">\n\n</span><span class="s1">// This type exists to distinguish a DeferredRsc from a Flight promise. It's a</span><span class="s3">\n</span><span class="s1">// compromise to avoid adding an extra field on every Cache Node, which would be</span><span class="s3">\n</span><span class="s1">// awkward because the pre-PPR parts of codebase would need to account for it,</span><span class="s3">\n</span><span class="s1">// too. We can remove it once type Cache Node type is more settled.</span><span class="s3">\n</span><span class="s1">function isDeferredRsc(value: any): value is DeferredRsc {</span><span class="s3">\n  </span><span class="s1">return value &amp;&amp; value.tag === DEFERRED</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createDeferredRsc(): PendingDeferredRsc {</span><span class="s3">\n  </span><span class="s1">let resolve: any</span><span class="s3">\n  </span><span class="s1">let reject: any</span><span class="s3">\n  </span><span class="s1">const pendingRsc = new Promise&lt;React.ReactNode&gt;((res, rej) =&gt; {</span><span class="s3">\n    </span><span class="s1">resolve = res</span><span class="s3">\n    </span><span class="s1">reject = rej</span><span class="s3">\n  </span><span class="s1">}) as PendingDeferredRsc</span><span class="s3">\n  </span><span class="s1">pendingRsc.status = 'pending'</span><span class="s3">\n  </span><span class="s1">pendingRsc.resolve = (value: React.ReactNode) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (pendingRsc.status === 'pending') {</span><span class="s3">\n      </span><span class="s1">const fulfilledRsc: FulfilledDeferredRsc = pendingRsc as any</span><span class="s3">\n      </span><span class="s1">fulfilledRsc.status = 'fulfilled'</span><span class="s3">\n      </span><span class="s1">fulfilledRsc.value = value</span><span class="s3">\n      </span><span class="s1">resolve(value)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">pendingRsc.reject = (error: any) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (pendingRsc.status === 'pending') {</span><span class="s3">\n      </span><span class="s1">const rejectedRsc: RejectedDeferredRsc = pendingRsc as any</span><span class="s3">\n      </span><span class="s1">rejectedRsc.status = 'rejected'</span><span class="s3">\n      </span><span class="s1">rejectedRsc.reason = error</span><span class="s3">\n      </span><span class="s1">reject(error)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">pendingRsc.tag = DEFERRED</span><span class="s3">\n  </span><span class="s1">return pendingRsc</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;abortTask&quot;</span><span class="s0">,</span><span class="s1">&quot;listenForDynamicRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;startPPRNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;updateCacheNodeOnPopstateRestoration&quot;</span><span class="s0">,</span><span class="s1">&quot;MPA_NAVIGATION_TASK&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicRequestTree&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;navigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;oldCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;oldRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;newRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchData&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchHead&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrefetchHeadPartial&quot;</span><span class="s0">,</span><span class="s1">&quot;isSamePageNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;scrollableSegmentsResult&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;updateCacheNodeOnNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;didFindRootLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;oldRouterStateChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;newRouterStateChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchDataChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;oldParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;patchedRouterStateChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;taskChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;needsDynamicRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicRequestTreeChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;newRouterStateChild&quot;</span><span class="s0">,</span><span class="s1">&quot;oldRouterStateChild&quot;</span><span class="s0">,</span><span class="s1">&quot;oldSegmentMapChild&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchDataChild&quot;</span><span class="s0">,</span><span class="s1">&quot;newSegmentChild&quot;</span><span class="s0">,</span><span class="s1">&quot;newSegmentPathChild&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;newSegmentKeyChild&quot;</span><span class="s0">,</span><span class="s1">&quot;createRouterCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;oldSegmentChild&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;oldCacheNodeChild&quot;</span><span class="s0">,</span><span class="s1">&quot;taskChild&quot;</span><span class="s0">,</span><span class="s1">&quot;DEFAULT_SEGMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;spawnReusedTask&quot;</span><span class="s0">,</span><span class="s1">&quot;beginRenderingNewRouteTree&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;matchSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;newCacheNodeChild&quot;</span><span class="s0">,</span><span class="s1">&quot;newSegmentMapChild&quot;</span><span class="s0">,</span><span class="s1">&quot;taskChildRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicRequestTreeChild&quot;</span><span class="s0">,</span><span class="s1">&quot;newCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyData&quot;</span><span class="s0">,</span><span class="s1">&quot;rsc&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;patchRouterStateWithNewChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;possiblyPartialPrefetchHead&quot;</span><span class="s0">,</span><span class="s1">&quot;isNavigatingToNewRootLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;createCacheNodeOnNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;routerState&quot;</span><span class="s0">,</span><span class="s1">&quot;routerStateChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;isLeafSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheNodeNavigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;DYNAMIC_STALETIME_MS&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrefetchRscPartial&quot;</span><span class="s0">,</span><span class="s1">&quot;spawnPendingTask&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCacheNodeChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheNodeChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;routerStateChild&quot;</span><span class="s0">,</span><span class="s1">&quot;existingSegmentMapChild&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentChild&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPathChild&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentKeyChild&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCacheNodeChild&quot;</span><span class="s0">,</span><span class="s1">&quot;baseRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;newChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;clone&quot;</span><span class="s0">,</span><span class="s1">&quot;newTask&quot;</span><span class="s0">,</span><span class="s1">&quot;createPendingCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;reusedRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;task&quot;</span><span class="s0">,</span><span class="s1">&quot;responsePromise&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;serverRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;seedData&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicData&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicHead&quot;</span><span class="s0">,</span><span class="s1">&quot;writeDynamicDataIntoPendingTask&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;rootTask&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;taskSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;finishTaskUsingDynamicDataPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;taskNode&quot;</span><span class="s0">,</span><span class="s1">&quot;finishPendingCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;serverChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicDataChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;serverRouterStateChild&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicDataChild&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;maybePrefetchRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;maybePrefetchLoading&quot;</span><span class="s0">,</span><span class="s1">&quot;createDeferredRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;taskState&quot;</span><span class="s0">,</span><span class="s1">&quot;serverState&quot;</span><span class="s0">,</span><span class="s1">&quot;taskStateChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;serverStateChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;dataChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;taskStateChild&quot;</span><span class="s0">,</span><span class="s1">&quot;serverStateChild&quot;</span><span class="s0">,</span><span class="s1">&quot;dataChild&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentMapChild&quot;</span><span class="s0">,</span><span class="s1">&quot;taskSegmentChild&quot;</span><span class="s0">,</span><span class="s1">&quot;taskSegmentKeyChild&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheNodeChild&quot;</span><span class="s0">,</span><span class="s1">&quot;abortPendingCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicSegmentData&quot;</span><span class="s0">,</span><span class="s1">&quot;isDeferredRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;newParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldUsePrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;DEFERRED&quot;</span><span class="s0">,</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;rej&quot;</span><span class="s0">,</span><span class="s1">&quot;fulfilledRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;rejectedRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;reason&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">7806</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/clear-cache-node-data-for-segment-path.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { FlightSegmentPath } from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { getNextFlightSegmentPath } from '../../flight-data-helpers'</span><span class="s3">\n</span><span class="s1">import { createRouterCacheKey } from './create-router-cache-key'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This will clear the CacheNode data for a particular segment path. This will cause a lazy-fetch in layout router to fill in new data.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function clearCacheNodeDataForSegmentPath(</span><span class="s3">\n  </span><span class="s1">newCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">existingCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">flightSegmentPath: FlightSegmentPath</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const isLastEntry = flightSegmentPath.length &lt;= 2</span><span class="s3">\n\n  </span><span class="s1">const [parallelRouteKey, segment] = flightSegmentPath</span><span class="s3">\n  </span><span class="s1">const cacheKey = createRouterCacheKey(segment)</span><span class="s3">\n\n  </span><span class="s1">const existingChildSegmentMap =</span><span class="s3">\n    </span><span class="s1">existingCache.parallelRoutes.get(parallelRouteKey)</span><span class="s3">\n\n  </span><span class="s1">let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey)</span><span class="s3">\n\n  </span><span class="s1">if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {</span><span class="s3">\n    </span><span class="s1">childSegmentMap = new Map(existingChildSegmentMap)</span><span class="s3">\n    </span><span class="s1">newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const existingChildCacheNode = existingChildSegmentMap?.get(cacheKey)</span><span class="s3">\n  </span><span class="s1">let childCacheNode = childSegmentMap.get(cacheKey)</span><span class="s3">\n\n  </span><span class="s1">// In case of last segment start off the fetch at this level and don't copy further down.</span><span class="s3">\n  </span><span class="s1">if (isLastEntry) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!childCacheNode ||</span><span class="s3">\n      </span><span class="s1">!childCacheNode.lazyData ||</span><span class="s3">\n      </span><span class="s1">childCacheNode === existingChildCacheNode</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">childSegmentMap.set(cacheKey, {</span><span class="s3">\n        </span><span class="s1">lazyData: null,</span><span class="s3">\n        </span><span class="s1">rsc: null,</span><span class="s3">\n        </span><span class="s1">prefetchRsc: null,</span><span class="s3">\n        </span><span class="s1">head: null,</span><span class="s3">\n        </span><span class="s1">prefetchHead: null,</span><span class="s3">\n        </span><span class="s1">parallelRoutes: new Map(),</span><span class="s3">\n        </span><span class="s1">loading: null,</span><span class="s3">\n        </span><span class="s1">navigatedAt: -1,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!childCacheNode || !existingChildCacheNode) {</span><span class="s3">\n    </span><span class="s1">// Start fetch in the place where the existing cache doesn't have the data yet.</span><span class="s3">\n    </span><span class="s1">if (!childCacheNode) {</span><span class="s3">\n      </span><span class="s1">childSegmentMap.set(cacheKey, {</span><span class="s3">\n        </span><span class="s1">lazyData: null,</span><span class="s3">\n        </span><span class="s1">rsc: null,</span><span class="s3">\n        </span><span class="s1">prefetchRsc: null,</span><span class="s3">\n        </span><span class="s1">head: null,</span><span class="s3">\n        </span><span class="s1">prefetchHead: null,</span><span class="s3">\n        </span><span class="s1">parallelRoutes: new Map(),</span><span class="s3">\n        </span><span class="s1">loading: null,</span><span class="s3">\n        </span><span class="s1">navigatedAt: -1,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (childCacheNode === existingChildCacheNode) {</span><span class="s3">\n    </span><span class="s1">childCacheNode = {</span><span class="s3">\n      </span><span class="s1">lazyData: childCacheNode.lazyData,</span><span class="s3">\n      </span><span class="s1">rsc: childCacheNode.rsc,</span><span class="s3">\n      </span><span class="s1">prefetchRsc: childCacheNode.prefetchRsc,</span><span class="s3">\n      </span><span class="s1">head: childCacheNode.head,</span><span class="s3">\n      </span><span class="s1">prefetchHead: childCacheNode.prefetchHead,</span><span class="s3">\n      </span><span class="s1">parallelRoutes: new Map(childCacheNode.parallelRoutes),</span><span class="s3">\n      </span><span class="s1">loading: childCacheNode.loading,</span><span class="s3">\n    </span><span class="s1">} as CacheNode</span><span class="s3">\n    </span><span class="s1">childSegmentMap.set(cacheKey, childCacheNode)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return clearCacheNodeDataForSegmentPath(</span><span class="s3">\n    </span><span class="s1">childCacheNode,</span><span class="s3">\n    </span><span class="s1">existingChildCacheNode,</span><span class="s3">\n    </span><span class="s1">getNextFlightSegmentPath(flightSegmentPath)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;clearCacheNodeDataForSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;newCache&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCache&quot;</span><span class="s0">,</span><span class="s1">&quot;flightSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isLastEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;createRouterCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;existingChildSegmentMap&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;childSegmentMap&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;existingChildCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;childCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyData&quot;</span><span class="s0">,</span><span class="s1">&quot;rsc&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchHead&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;navigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;getNextFlightSegmentPath&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAQgBA,oCAAAA;;;eAAAA;;;mCANyB;sCACJ;AAK9B,SAASA,iCACdC,QAAmB,EACnBC,aAAwB,EACxBC,iBAAoC;IAEpC,MAAMC,cAAcD,kBAAkBE,MAAM,IAAI;IAEhD,MAAM,CAACC,kBAAkBC,QAAQ,GAAGJ;IACpC,MAAMK,WAAWC,CAAAA,GAAAA,sBAAAA,oBAAoB,EAACF;IAEtC,MAAMG,0BACJR,cAAcS,cAAc,CAACC,GAAG,CAACN;IAEnC,IAAIO,kBAAkBZ,SAASU,cAAc,CAACC,GAAG,CAACN;IAElD,IAAI,CAACO,mBAAmBA,oBAAoBH,yBAAyB;QACnEG,kBAAkB,IAAIC,IAAIJ;QAC1BT,SAASU,cAAc,CAACI,GAAG,CAACT,kBAAkBO;IAChD;IAEA,MAAMG,yBAAyBN,2BAAAA,OAAAA,KAAAA,IAAAA,wBAAyBE,GAAG,CAACJ;IAC5D,IAAIS,iBAAiBJ,gBAAgBD,GAAG,CAACJ;IAEzC,yFAAyF;IACzF,IAAIJ,aAAa;QACf,IACE,CAACa,kBACD,CAACA,eAAeC,QAAQ,IACxBD,mBAAmBD,wBACnB;YACAH,gBAAgBE,GAAG,CAACP,UAAU;gBAC5BU,UAAU;gBACVC,KAAK;gBACLC,aAAa;gBACbC,MAAM;gBACNC,cAAc;gBACdX,gBAAgB,IAAIG;gBACpBS,SAAS;gBACTC,aAAa,CAAC;YAChB;QACF;QACA;IACF;IAEA,IAAI,CAACP,kBAAkB,CAACD,wBAAwB;QAC9C,+EAA+E;QAC/E,IAAI,CAACC,gBAAgB;YACnBJ,gBAAgBE,GAAG,CAACP,UAAU;gBAC5BU,UAAU;gBACVC,KAAK;gBACLC,aAAa;gBACbC,MAAM;gBACNC,cAAc;gBACdX,gBAAgB,IAAIG;gBACpBS,SAAS;gBACTC,aAAa,CAAC;YAChB;QACF;QACA;IACF;IAEA,IAAIP,mBAAmBD,wBAAwB;QAC7CC,iBAAiB;YACfC,UAAUD,eAAeC,QAAQ;YACjCC,KAAKF,eAAeE,GAAG;YACvBC,aAAaH,eAAeG,WAAW;YACvCC,MAAMJ,eAAeI,IAAI;YACzBC,cAAcL,eAAeK,YAAY;YACzCX,gBAAgB,IAAIG,IAAIG,eAAeN,cAAc;YACrDY,SAASN,eAAeM,OAAO;QACjC;QACAV,gBAAgBE,GAAG,CAACP,UAAUS;IAChC;IAEA,OAAOjB,iCACLiB,gBACAD,wBACAS,CAAAA,GAAAA,mBAAAA,wBAAwB,EAACtB;AAE7B&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">7886</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/aliased-prefetch-navigations.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">CacheNodeSeedData,</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">FlightSegmentPath,</span><span class="s3">\n</span><span class="s1">} from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">addSearchParamsIfPageSegment,</span><span class="s3">\n  </span><span class="s1">DEFAULT_SEGMENT_KEY,</span><span class="s3">\n  </span><span class="s1">PAGE_SEGMENT_KEY,</span><span class="s3">\n</span><span class="s1">} from '../../../shared/lib/segment'</span><span class="s3">\n</span><span class="s1">import type { NormalizedFlightData } from '../../flight-data-helpers'</span><span class="s3">\n</span><span class="s1">import { createEmptyCacheNode } from '../app-router'</span><span class="s3">\n</span><span class="s1">import { applyRouterStatePatchToTree } from './apply-router-state-patch-to-tree'</span><span class="s3">\n</span><span class="s1">import { createHrefFromUrl } from './create-href-from-url'</span><span class="s3">\n</span><span class="s1">import { createRouterCacheKey } from './create-router-cache-key'</span><span class="s3">\n</span><span class="s1">import { fillCacheWithNewSubTreeDataButOnlyLoading } from './fill-cache-with-new-subtree-data'</span><span class="s3">\n</span><span class="s1">import { handleMutable } from './handle-mutable'</span><span class="s3">\n</span><span class="s1">import { generateSegmentsFromPatch } from './reducers/navigate-reducer'</span><span class="s3">\n</span><span class="s1">import type { Mutable, ReadonlyReducerState } from './router-reducer-types'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This is a stop-gap until per-segment caching is implemented. It leverages the `aliased` flag that is added</span><span class="s3">\n </span><span class="s1">* to prefetch entries when it's determined that the loading state from that entry should be used for this navigation.</span><span class="s3">\n </span><span class="s1">* This function takes the aliased entry and only applies the loading state to the updated cache node.</span><span class="s3">\n </span><span class="s1">* We should remove this once per-segment fetching is implemented as ideally the prefetch cache will contain a</span><span class="s3">\n </span><span class="s1">* more granular segment map and so the router will be able to simply re-use the loading segment for the new navigation.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function handleAliasedPrefetchEntry(</span><span class="s3">\n  </span><span class="s1">navigatedAt: number,</span><span class="s3">\n  </span><span class="s1">state: ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">flightData: string | NormalizedFlightData[],</span><span class="s3">\n  </span><span class="s1">url: URL,</span><span class="s3">\n  </span><span class="s1">mutable: Mutable</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let currentTree = state.tree</span><span class="s3">\n  </span><span class="s1">let currentCache = state.cache</span><span class="s3">\n  </span><span class="s1">const href = createHrefFromUrl(url)</span><span class="s3">\n  </span><span class="s1">let applied</span><span class="s3">\n  </span><span class="s1">let scrollableSegments: FlightSegmentPath[] = []</span><span class="s3">\n\n  </span><span class="s1">if (typeof flightData === 'string') {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const normalizedFlightData of flightData) {</span><span class="s3">\n    </span><span class="s1">// If the segment doesn't have a loading component, we don't need to do anything.</span><span class="s3">\n    </span><span class="s1">if (!hasLoadingComponentInSeedData(normalizedFlightData.seedData)) {</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let treePatch = normalizedFlightData.tree</span><span class="s3">\n    </span><span class="s1">// Segments are keyed by searchParams (e.g. __PAGE__?{</span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">bar</span><span class="s3">\&quot;</span><span class="s1">}). We might return a less specific, param-less entry,</span><span class="s3">\n    </span><span class="s1">// so we ensure that the final tree contains the correct searchParams (reflected in the URL) are provided in the updated FlightRouterState tree.</span><span class="s3">\n    </span><span class="s1">// We only do this on the first read, as otherwise we'd be overwriting the searchParams that may have already been set</span><span class="s3">\n    </span><span class="s1">treePatch = addSearchParamsToPageSegments(</span><span class="s3">\n      </span><span class="s1">treePatch,</span><span class="s3">\n      </span><span class="s1">Object.fromEntries(url.searchParams)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const { seedData, isRootRender, pathToSegment } = normalizedFlightData</span><span class="s3">\n    </span><span class="s1">// TODO-APP: remove ''</span><span class="s3">\n    </span><span class="s1">const flightSegmentPathWithLeadingEmpty = ['', ...pathToSegment]</span><span class="s3">\n\n    </span><span class="s1">// Segments are keyed by searchParams (e.g. __PAGE__?{</span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">bar</span><span class="s3">\&quot;</span><span class="s1">}). We might return a less specific, param-less entry,</span><span class="s3">\n    </span><span class="s1">// so we ensure that the final tree contains the correct searchParams (reflected in the URL) are provided in the updated FlightRouterState tree.</span><span class="s3">\n    </span><span class="s1">// We only do this on the first read, as otherwise we'd be overwriting the searchParams that may have already been set</span><span class="s3">\n    </span><span class="s1">treePatch = addSearchParamsToPageSegments(</span><span class="s3">\n      </span><span class="s1">treePatch,</span><span class="s3">\n      </span><span class="s1">Object.fromEntries(url.searchParams)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">let newTree = applyRouterStatePatchToTree(</span><span class="s3">\n      </span><span class="s1">flightSegmentPathWithLeadingEmpty,</span><span class="s3">\n      </span><span class="s1">currentTree,</span><span class="s3">\n      </span><span class="s1">treePatch,</span><span class="s3">\n      </span><span class="s1">href</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const newCache = createEmptyCacheNode()</span><span class="s3">\n\n    </span><span class="s1">// The prefetch cache entry was aliased -- this signals that we only fill in the cache with the</span><span class="s3">\n    </span><span class="s1">// loading state and not the actual parallel route seed data.</span><span class="s3">\n    </span><span class="s1">if (isRootRender &amp;&amp; seedData) {</span><span class="s3">\n      </span><span class="s1">// Fill in the cache with the new loading / rsc data</span><span class="s3">\n      </span><span class="s1">const rsc = seedData[1]</span><span class="s3">\n      </span><span class="s1">const loading = seedData[3]</span><span class="s3">\n      </span><span class="s1">newCache.loading = loading</span><span class="s3">\n      </span><span class="s1">newCache.rsc = rsc</span><span class="s3">\n\n      </span><span class="s1">// Construct a new tree and apply the aliased loading state for each parallel route</span><span class="s3">\n      </span><span class="s1">fillNewTreeWithOnlyLoadingSegments(</span><span class="s3">\n        </span><span class="s1">navigatedAt,</span><span class="s3">\n        </span><span class="s1">newCache,</span><span class="s3">\n        </span><span class="s1">currentCache,</span><span class="s3">\n        </span><span class="s1">treePatch,</span><span class="s3">\n        </span><span class="s1">seedData</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Copy rsc for the root node of the cache.</span><span class="s3">\n      </span><span class="s1">newCache.rsc = currentCache.rsc</span><span class="s3">\n      </span><span class="s1">newCache.prefetchRsc = currentCache.prefetchRsc</span><span class="s3">\n      </span><span class="s1">newCache.loading = currentCache.loading</span><span class="s3">\n      </span><span class="s1">newCache.parallelRoutes = new Map(currentCache.parallelRoutes)</span><span class="s3">\n\n      </span><span class="s1">// copy the loading state only into the leaf node (the part that changed)</span><span class="s3">\n      </span><span class="s1">fillCacheWithNewSubTreeDataButOnlyLoading(</span><span class="s3">\n        </span><span class="s1">navigatedAt,</span><span class="s3">\n        </span><span class="s1">newCache,</span><span class="s3">\n        </span><span class="s1">currentCache,</span><span class="s3">\n        </span><span class="s1">normalizedFlightData</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If we don't have an updated tree, there's no reason to update the cache, as the tree</span><span class="s3">\n    </span><span class="s1">// dictates what cache nodes to render.</span><span class="s3">\n    </span><span class="s1">if (newTree) {</span><span class="s3">\n      </span><span class="s1">currentTree = newTree</span><span class="s3">\n      </span><span class="s1">currentCache = newCache</span><span class="s3">\n      </span><span class="s1">applied = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const subSegment of generateSegmentsFromPatch(treePatch)) {</span><span class="s3">\n      </span><span class="s1">const scrollableSegmentPath = [</span><span class="s3">\n        </span><span class="s1">...normalizedFlightData.pathToSegment,</span><span class="s3">\n        </span><span class="s1">...subSegment,</span><span class="s3">\n      </span><span class="s1">]</span><span class="s3">\n      </span><span class="s1">// Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">scrollableSegmentPath[scrollableSegmentPath.length - 1] !==</span><span class="s3">\n        </span><span class="s1">DEFAULT_SEGMENT_KEY</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">scrollableSegments.push(scrollableSegmentPath)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!applied) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">mutable.patchedTree = currentTree</span><span class="s3">\n  </span><span class="s1">mutable.cache = currentCache</span><span class="s3">\n  </span><span class="s1">mutable.canonicalUrl = href</span><span class="s3">\n  </span><span class="s1">mutable.hashFragment = url.hash</span><span class="s3">\n  </span><span class="s1">mutable.scrollableSegments = scrollableSegments</span><span class="s3">\n\n  </span><span class="s1">return handleMutable(state, mutable)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function hasLoadingComponentInSeedData(seedData: CacheNodeSeedData | null) {</span><span class="s3">\n  </span><span class="s1">if (!seedData) return false</span><span class="s3">\n\n  </span><span class="s1">const parallelRoutes = seedData[2]</span><span class="s3">\n  </span><span class="s1">const loading = seedData[3]</span><span class="s3">\n\n  </span><span class="s1">if (loading) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const key in parallelRoutes) {</span><span class="s3">\n    </span><span class="s1">if (hasLoadingComponentInSeedData(parallelRoutes[key])) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function fillNewTreeWithOnlyLoadingSegments(</span><span class="s3">\n  </span><span class="s1">navigatedAt: number,</span><span class="s3">\n  </span><span class="s1">newCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">existingCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">routerState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">cacheNodeSeedData: CacheNodeSeedData | null</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const isLastSegment = Object.keys(routerState[1]).length === 0</span><span class="s3">\n  </span><span class="s1">if (isLastSegment) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const key in routerState[1]) {</span><span class="s3">\n    </span><span class="s1">const parallelRouteState = routerState[1][key]</span><span class="s3">\n    </span><span class="s1">const segmentForParallelRoute = parallelRouteState[0]</span><span class="s3">\n    </span><span class="s1">const cacheKey = createRouterCacheKey(segmentForParallelRoute)</span><span class="s3">\n\n    </span><span class="s1">const parallelSeedData =</span><span class="s3">\n      </span><span class="s1">cacheNodeSeedData !== null &amp;&amp; cacheNodeSeedData[2][key] !== undefined</span><span class="s3">\n        </span><span class="s1">? cacheNodeSeedData[2][key]</span><span class="s3">\n        </span><span class="s1">: null</span><span class="s3">\n\n    </span><span class="s1">let newCacheNode: CacheNode</span><span class="s3">\n    </span><span class="s1">if (parallelSeedData !== null) {</span><span class="s3">\n      </span><span class="s1">// New data was sent from the server.</span><span class="s3">\n      </span><span class="s1">const rsc = parallelSeedData[1]</span><span class="s3">\n      </span><span class="s1">const loading = parallelSeedData[3]</span><span class="s3">\n      </span><span class="s1">newCacheNode = {</span><span class="s3">\n        </span><span class="s1">lazyData: null,</span><span class="s3">\n        </span><span class="s1">// copy the layout but null the page segment as that's not meant to be used</span><span class="s3">\n        </span><span class="s1">rsc: segmentForParallelRoute.includes(PAGE_SEGMENT_KEY) ? null : rsc,</span><span class="s3">\n        </span><span class="s1">prefetchRsc: null,</span><span class="s3">\n        </span><span class="s1">head: null,</span><span class="s3">\n        </span><span class="s1">prefetchHead: null,</span><span class="s3">\n        </span><span class="s1">parallelRoutes: new Map(),</span><span class="s3">\n        </span><span class="s1">loading,</span><span class="s3">\n        </span><span class="s1">navigatedAt,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// No data available for this node. This will trigger a lazy fetch</span><span class="s3">\n      </span><span class="s1">// during render.</span><span class="s3">\n      </span><span class="s1">newCacheNode = {</span><span class="s3">\n        </span><span class="s1">lazyData: null,</span><span class="s3">\n        </span><span class="s1">rsc: null,</span><span class="s3">\n        </span><span class="s1">prefetchRsc: null,</span><span class="s3">\n        </span><span class="s1">head: null,</span><span class="s3">\n        </span><span class="s1">prefetchHead: null,</span><span class="s3">\n        </span><span class="s1">parallelRoutes: new Map(),</span><span class="s3">\n        </span><span class="s1">loading: null,</span><span class="s3">\n        </span><span class="s1">navigatedAt: -1,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const existingParallelRoutes = newCache.parallelRoutes.get(key)</span><span class="s3">\n    </span><span class="s1">if (existingParallelRoutes) {</span><span class="s3">\n      </span><span class="s1">existingParallelRoutes.set(cacheKey, newCacheNode)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">newCache.parallelRoutes.set(key, new Map([[cacheKey, newCacheNode]]))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">fillNewTreeWithOnlyLoadingSegments(</span><span class="s3">\n      </span><span class="s1">navigatedAt,</span><span class="s3">\n      </span><span class="s1">newCacheNode,</span><span class="s3">\n      </span><span class="s1">existingCache,</span><span class="s3">\n      </span><span class="s1">parallelRouteState,</span><span class="s3">\n      </span><span class="s1">parallelSeedData</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Add search params to the page segments in the flight router state</span><span class="s3">\n </span><span class="s1">* Page segments that are associated with search params have a page segment key</span><span class="s3">\n </span><span class="s1">* followed by a query string. This function will add those params to the page segment.</span><span class="s3">\n </span><span class="s1">* This is useful if we return an aliased prefetch entry (ie, won't have search params)</span><span class="s3">\n </span><span class="s1">* but the canonical router URL has search params.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function addSearchParamsToPageSegments(</span><span class="s3">\n  </span><span class="s1">flightRouterState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">searchParams: Record&lt;string, string | string[] | undefined&gt;</span><span class="s3">\n</span><span class="s1">): FlightRouterState {</span><span class="s3">\n  </span><span class="s1">const [segment, parallelRoutes, ...rest] = flightRouterState</span><span class="s3">\n\n  </span><span class="s1">// If it's a page segment, modify the segment by adding search params</span><span class="s3">\n  </span><span class="s1">if (segment.includes(PAGE_SEGMENT_KEY)) {</span><span class="s3">\n    </span><span class="s1">const newSegment = addSearchParamsIfPageSegment(segment, searchParams)</span><span class="s3">\n    </span><span class="s1">return [newSegment, parallelRoutes, ...rest]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Otherwise, recurse through the parallel routes and return a new tree</span><span class="s3">\n  </span><span class="s1">const updatedParallelRoutes: { [key: string]: FlightRouterState } = {}</span><span class="s3">\n\n  </span><span class="s1">for (const [key, parallelRoute] of Object.entries(parallelRoutes)) {</span><span class="s3">\n    </span><span class="s1">updatedParallelRoutes[key] = addSearchParamsToPageSegments(</span><span class="s3">\n      </span><span class="s1">parallelRoute,</span><span class="s3">\n      </span><span class="s1">searchParams</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return [segment, updatedParallelRoutes, ...rest]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;addSearchParamsToPageSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;handleAliasedPrefetchEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;navigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;mutable&quot;</span><span class="s0">,</span><span class="s1">&quot;currentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;currentCache&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;createHrefFromUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;applied&quot;</span><span class="s0">,</span><span class="s1">&quot;scrollableSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;hasLoadingComponentInSeedData&quot;</span><span class="s0">,</span><span class="s1">&quot;seedData&quot;</span><span class="s0">,</span><span class="s1">&quot;treePatch&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;fromEntries&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootRender&quot;</span><span class="s0">,</span><span class="s1">&quot;pathToSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;flightSegmentPathWithLeadingEmpty&quot;</span><span class="s0">,</span><span class="s1">&quot;newTree&quot;</span><span class="s0">,</span><span class="s1">&quot;applyRouterStatePatchToTree&quot;</span><span class="s0">,</span><span class="s1">&quot;newCache&quot;</span><span class="s0">,</span><span class="s1">&quot;createEmptyCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;rsc&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;fillNewTreeWithOnlyLoadingSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;fillCacheWithNewSubTreeDataButOnlyLoading&quot;</span><span class="s0">,</span><span class="s1">&quot;subSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;generateSegmentsFromPatch&quot;</span><span class="s0">,</span><span class="s1">&quot;scrollableSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;DEFAULT_SEGMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;patchedTree&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;hashFragment&quot;</span><span class="s0">,</span><span class="s1">&quot;hash&quot;</span><span class="s0">,</span><span class="s1">&quot;handleMutable&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCache&quot;</span><span class="s0">,</span><span class="s1">&quot;routerState&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheNodeSeedData&quot;</span><span class="s0">,</span><span class="s1">&quot;isLastSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteState&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentForParallelRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;createRouterCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelSeedData&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;newCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyData&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;PAGE_SEGMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchHead&quot;</span><span class="s0">,</span><span class="s1">&quot;existingParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;rest&quot;</span><span class="s0">,</span><span class="s1">&quot;newSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;addSearchParamsIfPageSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">8094</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/reducers/navigate-reducer.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">FlightSegmentPath,</span><span class="s3">\n</span><span class="s1">} from '../../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { fetchServerResponse } from '../fetch-server-response'</span><span class="s3">\n</span><span class="s1">import { createHrefFromUrl } from '../create-href-from-url'</span><span class="s3">\n</span><span class="s1">import { invalidateCacheBelowFlightSegmentPath } from '../invalidate-cache-below-flight-segmentpath'</span><span class="s3">\n</span><span class="s1">import { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'</span><span class="s3">\n</span><span class="s1">import { shouldHardNavigate } from '../should-hard-navigate'</span><span class="s3">\n</span><span class="s1">import { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">PrefetchCacheEntryStatus,</span><span class="s3">\n  </span><span class="s1">type Mutable,</span><span class="s3">\n  </span><span class="s1">type NavigateAction,</span><span class="s3">\n  </span><span class="s1">type ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">type ReducerState,</span><span class="s3">\n</span><span class="s1">} from '../router-reducer-types'</span><span class="s3">\n</span><span class="s1">import { handleMutable } from '../handle-mutable'</span><span class="s3">\n</span><span class="s1">import { applyFlightData } from '../apply-flight-data'</span><span class="s3">\n</span><span class="s1">import { prefetchQueue } from './prefetch-reducer'</span><span class="s3">\n</span><span class="s1">import { createEmptyCacheNode } from '../../app-router'</span><span class="s3">\n</span><span class="s1">import { DEFAULT_SEGMENT_KEY } from '../../../../shared/lib/segment'</span><span class="s3">\n</span><span class="s1">import { listenForDynamicRequest, startPPRNavigation } from '../ppr-navigations'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getOrCreatePrefetchCacheEntry,</span><span class="s3">\n  </span><span class="s1">prunePrefetchCache,</span><span class="s3">\n</span><span class="s1">} from '../prefetch-cache-utils'</span><span class="s3">\n</span><span class="s1">import { clearCacheNodeDataForSegmentPath } from '../clear-cache-node-data-for-segment-path'</span><span class="s3">\n</span><span class="s1">import { handleAliasedPrefetchEntry } from '../aliased-prefetch-navigations'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">navigate as navigateUsingSegmentCache,</span><span class="s3">\n  </span><span class="s1">NavigationResultTag,</span><span class="s3">\n  </span><span class="s1">type NavigationResult,</span><span class="s3">\n</span><span class="s1">} from '../../segment-cache'</span><span class="s3">\n\n</span><span class="s1">export function handleExternalUrl(</span><span class="s3">\n  </span><span class="s1">state: ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">mutable: Mutable,</span><span class="s3">\n  </span><span class="s1">url: string,</span><span class="s3">\n  </span><span class="s1">pendingPush: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">mutable.mpaNavigation = true</span><span class="s3">\n  </span><span class="s1">mutable.canonicalUrl = url</span><span class="s3">\n  </span><span class="s1">mutable.pendingPush = pendingPush</span><span class="s3">\n  </span><span class="s1">mutable.scrollableSegments = undefined</span><span class="s3">\n\n  </span><span class="s1">return handleMutable(state, mutable)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function generateSegmentsFromPatch(</span><span class="s3">\n  </span><span class="s1">flightRouterPatch: FlightRouterState</span><span class="s3">\n</span><span class="s1">): FlightSegmentPath[] {</span><span class="s3">\n  </span><span class="s1">const segments: FlightSegmentPath[] = []</span><span class="s3">\n  </span><span class="s1">const [segment, parallelRoutes] = flightRouterPatch</span><span class="s3">\n\n  </span><span class="s1">if (Object.keys(parallelRoutes).length === 0) {</span><span class="s3">\n    </span><span class="s1">return [[segment]]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const [parallelRouteKey, parallelRoute] of Object.entries(</span><span class="s3">\n    </span><span class="s1">parallelRoutes</span><span class="s3">\n  </span><span class="s1">)) {</span><span class="s3">\n    </span><span class="s1">for (const childSegment of generateSegmentsFromPatch(parallelRoute)) {</span><span class="s3">\n      </span><span class="s1">// If the segment is empty, it means we are at the root of the tree</span><span class="s3">\n      </span><span class="s1">if (segment === '') {</span><span class="s3">\n        </span><span class="s1">segments.push([parallelRouteKey, ...childSegment])</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">segments.push([segment, parallelRouteKey, ...childSegment])</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return segments</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function triggerLazyFetchForLeafSegments(</span><span class="s3">\n  </span><span class="s1">newCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">currentCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">flightSegmentPath: FlightSegmentPath,</span><span class="s3">\n  </span><span class="s1">treePatch: FlightRouterState</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let appliedPatch = false</span><span class="s3">\n\n  </span><span class="s1">newCache.rsc = currentCache.rsc</span><span class="s3">\n  </span><span class="s1">newCache.prefetchRsc = currentCache.prefetchRsc</span><span class="s3">\n  </span><span class="s1">newCache.loading = currentCache.loading</span><span class="s3">\n  </span><span class="s1">newCache.parallelRoutes = new Map(currentCache.parallelRoutes)</span><span class="s3">\n\n  </span><span class="s1">const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map(</span><span class="s3">\n    </span><span class="s1">(segment) =&gt; [...flightSegmentPath, ...segment]</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">for (const segmentPaths of segmentPathsToFill) {</span><span class="s3">\n    </span><span class="s1">clearCacheNodeDataForSegmentPath(newCache, currentCache, segmentPaths)</span><span class="s3">\n\n    </span><span class="s1">appliedPatch = true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return appliedPatch</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function handleNavigationResult(</span><span class="s3">\n  </span><span class="s1">url: URL,</span><span class="s3">\n  </span><span class="s1">state: ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">mutable: Mutable,</span><span class="s3">\n  </span><span class="s1">pendingPush: boolean,</span><span class="s3">\n  </span><span class="s1">result: NavigationResult</span><span class="s3">\n</span><span class="s1">): ReducerState {</span><span class="s3">\n  </span><span class="s1">switch (result.tag) {</span><span class="s3">\n    </span><span class="s1">case NavigationResultTag.MPA: {</span><span class="s3">\n      </span><span class="s1">// Perform an MPA navigation.</span><span class="s3">\n      </span><span class="s1">const newUrl = result.data</span><span class="s3">\n      </span><span class="s1">return handleExternalUrl(state, mutable, newUrl, pendingPush)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case NavigationResultTag.NoOp: {</span><span class="s3">\n      </span><span class="s1">// The server responded with no change to the current page. However, if</span><span class="s3">\n      </span><span class="s1">// the URL changed, we still need to update that.</span><span class="s3">\n      </span><span class="s1">const newCanonicalUrl = result.data.canonicalUrl</span><span class="s3">\n      </span><span class="s1">mutable.canonicalUrl = newCanonicalUrl</span><span class="s3">\n\n      </span><span class="s1">// Check if the only thing that changed was the hash fragment.</span><span class="s3">\n      </span><span class="s1">const oldUrl = new URL(state.canonicalUrl, url)</span><span class="s3">\n      </span><span class="s1">const onlyHashChange =</span><span class="s3">\n        </span><span class="s1">// We don't need to compare the origins, because client-driven</span><span class="s3">\n        </span><span class="s1">// navigations are always same-origin.</span><span class="s3">\n        </span><span class="s1">url.pathname === oldUrl.pathname &amp;&amp;</span><span class="s3">\n        </span><span class="s1">url.search === oldUrl.search &amp;&amp;</span><span class="s3">\n        </span><span class="s1">url.hash !== oldUrl.hash</span><span class="s3">\n      </span><span class="s1">if (onlyHashChange) {</span><span class="s3">\n        </span><span class="s1">// The only updated part of the URL is the hash.</span><span class="s3">\n        </span><span class="s1">mutable.onlyHashChange = true</span><span class="s3">\n        </span><span class="s1">mutable.shouldScroll = result.data.shouldScroll</span><span class="s3">\n        </span><span class="s1">mutable.hashFragment = url.hash</span><span class="s3">\n        </span><span class="s1">// Setting this to an empty array triggers a scroll for all new and</span><span class="s3">\n        </span><span class="s1">// updated segments. See `ScrollAndFocusHandler` for more details.</span><span class="s3">\n        </span><span class="s1">mutable.scrollableSegments = []</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return handleMutable(state, mutable)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case NavigationResultTag.Success: {</span><span class="s3">\n      </span><span class="s1">// Received a new result.</span><span class="s3">\n      </span><span class="s1">mutable.cache = result.data.cacheNode</span><span class="s3">\n      </span><span class="s1">mutable.patchedTree = result.data.flightRouterState</span><span class="s3">\n      </span><span class="s1">mutable.canonicalUrl = result.data.canonicalUrl</span><span class="s3">\n      </span><span class="s1">mutable.scrollableSegments = result.data.scrollableSegments</span><span class="s3">\n      </span><span class="s1">mutable.shouldScroll = result.data.shouldScroll</span><span class="s3">\n      </span><span class="s1">mutable.hashFragment = result.data.hash</span><span class="s3">\n      </span><span class="s1">return handleMutable(state, mutable)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case NavigationResultTag.Async: {</span><span class="s3">\n      </span><span class="s1">return result.data.then(</span><span class="s3">\n        </span><span class="s1">(asyncResult) =&gt;</span><span class="s3">\n          </span><span class="s1">handleNavigationResult(url, state, mutable, pendingPush, asyncResult),</span><span class="s3">\n        </span><span class="s1">// If the navigation failed, return the current state.</span><span class="s3">\n        </span><span class="s1">// TODO: This matches the current behavior but we need to do something</span><span class="s3">\n        </span><span class="s1">// better here if the network fails.</span><span class="s3">\n        </span><span class="s1">() =&gt; {</span><span class="s3">\n          </span><span class="s1">return state</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">default: {</span><span class="s3">\n      </span><span class="s1">result satisfies never</span><span class="s3">\n      </span><span class="s1">return state</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function navigateReducer(</span><span class="s3">\n  </span><span class="s1">state: ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">action: NavigateAction</span><span class="s3">\n</span><span class="s1">): ReducerState {</span><span class="s3">\n  </span><span class="s1">const { url, isExternalUrl, navigateType, shouldScroll, allowAliasing } =</span><span class="s3">\n    </span><span class="s1">action</span><span class="s3">\n  </span><span class="s1">const mutable: Mutable = {}</span><span class="s3">\n  </span><span class="s1">const { hash } = url</span><span class="s3">\n  </span><span class="s1">const href = createHrefFromUrl(url)</span><span class="s3">\n  </span><span class="s1">const pendingPush = navigateType === 'push'</span><span class="s3">\n  </span><span class="s1">// we want to prune the prefetch cache on every navigation to avoid it growing too large</span><span class="s3">\n  </span><span class="s1">prunePrefetchCache(state.prefetchCache)</span><span class="s3">\n\n  </span><span class="s1">mutable.preserveCustomHistoryState = false</span><span class="s3">\n  </span><span class="s1">mutable.pendingPush = pendingPush</span><span class="s3">\n\n  </span><span class="s1">if (isExternalUrl) {</span><span class="s3">\n    </span><span class="s1">return handleExternalUrl(state, mutable, url.toString(), pendingPush)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Handles case where `&lt;meta http-equiv=</span><span class="s3">\&quot;</span><span class="s1">refresh</span><span class="s3">\&quot;</span><span class="s1">&gt;` tag is present,</span><span class="s3">\n  </span><span class="s1">// which will trigger an MPA navigation.</span><span class="s3">\n  </span><span class="s1">if (document.getElementById('__next-page-redirect')) {</span><span class="s3">\n    </span><span class="s1">return handleExternalUrl(state, mutable, href, pendingPush)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {</span><span class="s3">\n    </span><span class="s1">// (Very Early Experimental Feature) Segment Cache</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// Bypass the normal prefetch cache and use the new per-segment cache</span><span class="s3">\n    </span><span class="s1">// implementation instead. This is only supported if PPR is enabled, too.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// Temporary glue code between the router reducer and the new navigation</span><span class="s3">\n    </span><span class="s1">// implementation. Eventually we'll rewrite the router reducer to a</span><span class="s3">\n    </span><span class="s1">// state machine.</span><span class="s3">\n    </span><span class="s1">const result = navigateUsingSegmentCache(</span><span class="s3">\n      </span><span class="s1">url,</span><span class="s3">\n      </span><span class="s1">state.cache,</span><span class="s3">\n      </span><span class="s1">state.tree,</span><span class="s3">\n      </span><span class="s1">state.nextUrl,</span><span class="s3">\n      </span><span class="s1">shouldScroll</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">return handleNavigationResult(url, state, mutable, pendingPush, result)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const prefetchValues = getOrCreatePrefetchCacheEntry({</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">nextUrl: state.nextUrl,</span><span class="s3">\n    </span><span class="s1">tree: state.tree,</span><span class="s3">\n    </span><span class="s1">prefetchCache: state.prefetchCache,</span><span class="s3">\n    </span><span class="s1">allowAliasing,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">const { treeAtTimeOfPrefetch, data } = prefetchValues</span><span class="s3">\n\n  </span><span class="s1">prefetchQueue.bump(data)</span><span class="s3">\n\n  </span><span class="s1">return data.then(</span><span class="s3">\n    </span><span class="s1">({ flightData, canonicalUrl: canonicalUrlOverride, postponed }) =&gt; {</span><span class="s3">\n      </span><span class="s1">const navigatedAt = Date.now()</span><span class="s3">\n\n      </span><span class="s1">let isFirstRead = false</span><span class="s3">\n      </span><span class="s1">// we only want to mark this once</span><span class="s3">\n      </span><span class="s1">if (!prefetchValues.lastUsedTime) {</span><span class="s3">\n        </span><span class="s1">// important: we should only mark the cache node as dirty after we unsuspend from the call above</span><span class="s3">\n        </span><span class="s1">prefetchValues.lastUsedTime = navigatedAt</span><span class="s3">\n        </span><span class="s1">isFirstRead = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (prefetchValues.aliased) {</span><span class="s3">\n        </span><span class="s1">// When alias is enabled, search param may not be included in the canonicalUrl.</span><span class="s3">\n        </span><span class="s1">// But we want to set url to canonicalUrl so that we use redirected path for fetching dynamic data.</span><span class="s3">\n        </span><span class="s1">const urlWithCanonicalPathname = new URL(url.href)</span><span class="s3">\n        </span><span class="s1">if (canonicalUrlOverride) {</span><span class="s3">\n          </span><span class="s1">urlWithCanonicalPathname.pathname = canonicalUrlOverride.pathname</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const result = handleAliasedPrefetchEntry(</span><span class="s3">\n          </span><span class="s1">navigatedAt,</span><span class="s3">\n          </span><span class="s1">state,</span><span class="s3">\n          </span><span class="s1">flightData,</span><span class="s3">\n          </span><span class="s1">urlWithCanonicalPathname,</span><span class="s3">\n          </span><span class="s1">mutable</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// We didn't return new router state because we didn't apply the aliased entry for some reason.</span><span class="s3">\n        </span><span class="s1">// We'll re-invoke the navigation handler but ensure that we don't attempt to use the aliased entry. This</span><span class="s3">\n        </span><span class="s1">// will create an on-demand prefetch entry.</span><span class="s3">\n        </span><span class="s1">if (result === false) {</span><span class="s3">\n          </span><span class="s1">return navigateReducer(state, { ...action, allowAliasing: false })</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return result</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Handle case when navigating to page in `pages` from `app`</span><span class="s3">\n      </span><span class="s1">if (typeof flightData === 'string') {</span><span class="s3">\n        </span><span class="s1">return handleExternalUrl(state, mutable, flightData, pendingPush)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const updatedCanonicalUrl = canonicalUrlOverride</span><span class="s3">\n        </span><span class="s1">? createHrefFromUrl(canonicalUrlOverride)</span><span class="s3">\n        </span><span class="s1">: href</span><span class="s3">\n\n      </span><span class="s1">const onlyHashChange =</span><span class="s3">\n        </span><span class="s1">!!hash &amp;&amp;</span><span class="s3">\n        </span><span class="s1">state.canonicalUrl.split('#', 1)[0] ===</span><span class="s3">\n          </span><span class="s1">updatedCanonicalUrl.split('#', 1)[0]</span><span class="s3">\n\n      </span><span class="s1">// If only the hash has changed, the server hasn't sent us any new data. We can just update</span><span class="s3">\n      </span><span class="s1">// the mutable properties responsible for URL and scroll handling and return early.</span><span class="s3">\n      </span><span class="s1">if (onlyHashChange) {</span><span class="s3">\n        </span><span class="s1">mutable.onlyHashChange = true</span><span class="s3">\n        </span><span class="s1">mutable.canonicalUrl = updatedCanonicalUrl</span><span class="s3">\n        </span><span class="s1">mutable.shouldScroll = shouldScroll</span><span class="s3">\n        </span><span class="s1">mutable.hashFragment = hash</span><span class="s3">\n        </span><span class="s1">mutable.scrollableSegments = []</span><span class="s3">\n        </span><span class="s1">return handleMutable(state, mutable)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let currentTree = state.tree</span><span class="s3">\n      </span><span class="s1">let currentCache = state.cache</span><span class="s3">\n      </span><span class="s1">let scrollableSegments: FlightSegmentPath[] = []</span><span class="s3">\n      </span><span class="s1">for (const normalizedFlightData of flightData) {</span><span class="s3">\n        </span><span class="s1">const {</span><span class="s3">\n          </span><span class="s1">pathToSegment: flightSegmentPath,</span><span class="s3">\n          </span><span class="s1">seedData,</span><span class="s3">\n          </span><span class="s1">head,</span><span class="s3">\n          </span><span class="s1">isHeadPartial,</span><span class="s3">\n          </span><span class="s1">isRootRender,</span><span class="s3">\n        </span><span class="s1">} = normalizedFlightData</span><span class="s3">\n        </span><span class="s1">let treePatch = normalizedFlightData.tree</span><span class="s3">\n\n        </span><span class="s1">// TODO-APP: remove ''</span><span class="s3">\n        </span><span class="s1">const flightSegmentPathWithLeadingEmpty = ['', ...flightSegmentPath]</span><span class="s3">\n\n        </span><span class="s1">// Create new tree based on the flightSegmentPath and router state patch</span><span class="s3">\n        </span><span class="s1">let newTree = applyRouterStatePatchToTree(</span><span class="s3">\n          </span><span class="s1">// TODO-APP: remove ''</span><span class="s3">\n          </span><span class="s1">flightSegmentPathWithLeadingEmpty,</span><span class="s3">\n          </span><span class="s1">currentTree,</span><span class="s3">\n          </span><span class="s1">treePatch,</span><span class="s3">\n          </span><span class="s1">href</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// If the tree patch can't be applied to the current tree then we use the tree at time of prefetch</span><span class="s3">\n        </span><span class="s1">// TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.</span><span class="s3">\n        </span><span class="s1">if (newTree === null) {</span><span class="s3">\n          </span><span class="s1">newTree = applyRouterStatePatchToTree(</span><span class="s3">\n            </span><span class="s1">// TODO-APP: remove ''</span><span class="s3">\n            </span><span class="s1">flightSegmentPathWithLeadingEmpty,</span><span class="s3">\n            </span><span class="s1">treeAtTimeOfPrefetch,</span><span class="s3">\n            </span><span class="s1">treePatch,</span><span class="s3">\n            </span><span class="s1">href</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (newTree !== null) {</span><span class="s3">\n          </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">// This is just a paranoid check. When a route is PPRed, the server</span><span class="s3">\n            </span><span class="s1">// will send back a static response that's rendered from</span><span class="s3">\n            </span><span class="s1">// the root. If for some reason it doesn't, we fall back to the</span><span class="s3">\n            </span><span class="s1">// non-PPR implementation.</span><span class="s3">\n            </span><span class="s1">// TODO: We should get rid of the else branch and do all navigations</span><span class="s3">\n            </span><span class="s1">// via startPPRNavigation. The current structure is just</span><span class="s3">\n            </span><span class="s1">// an incremental step.</span><span class="s3">\n            </span><span class="s1">seedData &amp;&amp;</span><span class="s3">\n            </span><span class="s1">isRootRender &amp;&amp;</span><span class="s3">\n            </span><span class="s1">postponed</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">const task = startPPRNavigation(</span><span class="s3">\n              </span><span class="s1">navigatedAt,</span><span class="s3">\n              </span><span class="s1">currentCache,</span><span class="s3">\n              </span><span class="s1">currentTree,</span><span class="s3">\n              </span><span class="s1">treePatch,</span><span class="s3">\n              </span><span class="s1">seedData,</span><span class="s3">\n              </span><span class="s1">head,</span><span class="s3">\n              </span><span class="s1">isHeadPartial,</span><span class="s3">\n              </span><span class="s1">false,</span><span class="s3">\n              </span><span class="s1">scrollableSegments</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n\n            </span><span class="s1">if (task !== null) {</span><span class="s3">\n              </span><span class="s1">if (task.route === null) {</span><span class="s3">\n                </span><span class="s1">// Detected a change to the root layout. Perform an full-</span><span class="s3">\n                </span><span class="s1">// page navigation.</span><span class="s3">\n                </span><span class="s1">return handleExternalUrl(state, mutable, href, pendingPush)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">// Use the tree computed by startPPRNavigation instead</span><span class="s3">\n              </span><span class="s1">// of the one computed by applyRouterStatePatchToTree.</span><span class="s3">\n              </span><span class="s1">// TODO: We should remove applyRouterStatePatchToTree</span><span class="s3">\n              </span><span class="s1">// from the PPR path entirely.</span><span class="s3">\n              </span><span class="s1">const patchedRouterState: FlightRouterState = task.route</span><span class="s3">\n              </span><span class="s1">newTree = patchedRouterState</span><span class="s3">\n\n              </span><span class="s1">const newCache = task.node</span><span class="s3">\n              </span><span class="s1">if (newCache !== null) {</span><span class="s3">\n                </span><span class="s1">// We've created a new Cache Node tree that contains a prefetched</span><span class="s3">\n                </span><span class="s1">// version of the next page. This can be rendered instantly.</span><span class="s3">\n                </span><span class="s1">mutable.cache = newCache</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">const dynamicRequestTree = task.dynamicRequestTree</span><span class="s3">\n              </span><span class="s1">if (dynamicRequestTree !== null) {</span><span class="s3">\n                </span><span class="s1">// The prefetched tree has dynamic holes in it. We initiate a</span><span class="s3">\n                </span><span class="s1">// dynamic request to fill them in.</span><span class="s3">\n                </span><span class="s1">//</span><span class="s3">\n                </span><span class="s1">// Do not block on the result. We'll immediately render the Cache</span><span class="s3">\n                </span><span class="s1">// Node tree and suspend on the dynamic parts. When the request</span><span class="s3">\n                </span><span class="s1">// comes in, we'll fill in missing data and ping React to</span><span class="s3">\n                </span><span class="s1">// re-render. Unlike the lazy fetching model in the non-PPR</span><span class="s3">\n                </span><span class="s1">// implementation, this is modeled as a single React update +</span><span class="s3">\n                </span><span class="s1">// streaming, rather than multiple top-level updates. (However,</span><span class="s3">\n                </span><span class="s1">// even in the new model, we'll still need to sometimes update the</span><span class="s3">\n                </span><span class="s1">// root multiple times per navigation, like if the server sends us</span><span class="s3">\n                </span><span class="s1">// a different response than we expected. For now, we revert back</span><span class="s3">\n                </span><span class="s1">// to the lazy fetching mechanism in that case.)</span><span class="s3">\n                </span><span class="s1">const dynamicRequest = fetchServerResponse(</span><span class="s3">\n                  </span><span class="s1">new URL(updatedCanonicalUrl, url.origin),</span><span class="s3">\n                  </span><span class="s1">{</span><span class="s3">\n                    </span><span class="s1">flightRouterState: dynamicRequestTree,</span><span class="s3">\n                    </span><span class="s1">nextUrl: state.nextUrl,</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n\n                </span><span class="s1">listenForDynamicRequest(task, dynamicRequest)</span><span class="s3">\n                </span><span class="s1">// We store the dynamic request on the `lazyData` property of the CacheNode</span><span class="s3">\n                </span><span class="s1">// because we're not going to await the dynamic request here. Since we're not blocking</span><span class="s3">\n                </span><span class="s1">// on the dynamic request, `layout-router` will</span><span class="s3">\n                </span><span class="s1">// task.node.lazyData = dynamicRequest</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">// The prefetched tree does not contain dynamic holes  it's</span><span class="s3">\n                </span><span class="s1">// fully static. We can skip the dynamic request.</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">// Nothing changed, so reuse the old cache.</span><span class="s3">\n              </span><span class="s1">// TODO: What if the head changed but not any of the segment data?</span><span class="s3">\n              </span><span class="s1">// Is that possible? If so, we should clone the whole tree and</span><span class="s3">\n              </span><span class="s1">// update the head.</span><span class="s3">\n              </span><span class="s1">newTree = treePatch</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">// The static response does not include any dynamic holes, so</span><span class="s3">\n            </span><span class="s1">// there's no need to do a second request.</span><span class="s3">\n            </span><span class="s1">// TODO: As an incremental step this just reverts back to the</span><span class="s3">\n            </span><span class="s1">// non-PPR implementation. We can simplify this branch further,</span><span class="s3">\n            </span><span class="s1">// given that PPR prefetches are always static and return the whole</span><span class="s3">\n            </span><span class="s1">// tree. Or in the meantime we could factor it out into a</span><span class="s3">\n            </span><span class="s1">// separate function.</span><span class="s3">\n\n            </span><span class="s1">if (isNavigatingToNewRootLayout(currentTree, newTree)) {</span><span class="s3">\n              </span><span class="s1">return handleExternalUrl(state, mutable, href, pendingPush)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const cache: CacheNode = createEmptyCacheNode()</span><span class="s3">\n            </span><span class="s1">let applied = false</span><span class="s3">\n\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">prefetchValues.status === PrefetchCacheEntryStatus.stale &amp;&amp;</span><span class="s3">\n              </span><span class="s1">!isFirstRead</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">// When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations</span><span class="s3">\n              </span><span class="s1">// this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,</span><span class="s3">\n              </span><span class="s1">// while copying over the `loading` for the segment that contains the page data.</span><span class="s3">\n              </span><span class="s1">// We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.</span><span class="s3">\n\n              </span><span class="s1">// We skip this branch if only the hash fragment has changed, as we don't want to trigger a lazy fetch in that case</span><span class="s3">\n              </span><span class="s1">applied = triggerLazyFetchForLeafSegments(</span><span class="s3">\n                </span><span class="s1">cache,</span><span class="s3">\n                </span><span class="s1">currentCache,</span><span class="s3">\n                </span><span class="s1">flightSegmentPath,</span><span class="s3">\n                </span><span class="s1">treePatch</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">// since we re-used the stale cache's loading state &amp; refreshed the data,</span><span class="s3">\n              </span><span class="s1">// update the `lastUsedTime` so that it can continue to be re-used for the next 30s</span><span class="s3">\n              </span><span class="s1">prefetchValues.lastUsedTime = navigatedAt</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">applied = applyFlightData(</span><span class="s3">\n                </span><span class="s1">navigatedAt,</span><span class="s3">\n                </span><span class="s1">currentCache,</span><span class="s3">\n                </span><span class="s1">cache,</span><span class="s3">\n                </span><span class="s1">normalizedFlightData,</span><span class="s3">\n                </span><span class="s1">prefetchValues</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const hardNavigate = shouldHardNavigate(</span><span class="s3">\n              </span><span class="s1">// TODO-APP: remove ''</span><span class="s3">\n              </span><span class="s1">flightSegmentPathWithLeadingEmpty,</span><span class="s3">\n              </span><span class="s1">currentTree</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n\n            </span><span class="s1">if (hardNavigate) {</span><span class="s3">\n              </span><span class="s1">// Copy rsc for the root node of the cache.</span><span class="s3">\n              </span><span class="s1">cache.rsc = currentCache.rsc</span><span class="s3">\n              </span><span class="s1">cache.prefetchRsc = currentCache.prefetchRsc</span><span class="s3">\n\n              </span><span class="s1">invalidateCacheBelowFlightSegmentPath(</span><span class="s3">\n                </span><span class="s1">cache,</span><span class="s3">\n                </span><span class="s1">currentCache,</span><span class="s3">\n                </span><span class="s1">flightSegmentPath</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">// Ensure the existing cache value is used when the cache was not invalidated.</span><span class="s3">\n              </span><span class="s1">mutable.cache = cache</span><span class="s3">\n            </span><span class="s1">} else if (applied) {</span><span class="s3">\n              </span><span class="s1">mutable.cache = cache</span><span class="s3">\n              </span><span class="s1">// If we applied the cache, we update the </span><span class="s3">\&quot;</span><span class="s1">current cache</span><span class="s3">\&quot; </span><span class="s1">value so any other</span><span class="s3">\n              </span><span class="s1">// segments in the FlightDataPath will be able to reference the updated cache.</span><span class="s3">\n              </span><span class="s1">currentCache = cache</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">for (const subSegment of generateSegmentsFromPatch(treePatch)) {</span><span class="s3">\n              </span><span class="s1">const scrollableSegmentPath = [</span><span class="s3">\n                </span><span class="s1">...flightSegmentPath,</span><span class="s3">\n                </span><span class="s1">...subSegment,</span><span class="s3">\n              </span><span class="s1">]</span><span class="s3">\n              </span><span class="s1">// Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.</span><span class="s3">\n              </span><span class="s1">if (</span><span class="s3">\n                </span><span class="s1">scrollableSegmentPath[scrollableSegmentPath.length - 1] !==</span><span class="s3">\n                </span><span class="s1">DEFAULT_SEGMENT_KEY</span><span class="s3">\n              </span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">scrollableSegments.push(scrollableSegmentPath)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">currentTree = newTree</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">mutable.patchedTree = currentTree</span><span class="s3">\n      </span><span class="s1">mutable.canonicalUrl = updatedCanonicalUrl</span><span class="s3">\n      </span><span class="s1">mutable.scrollableSegments = scrollableSegments</span><span class="s3">\n      </span><span class="s1">mutable.hashFragment = hash</span><span class="s3">\n      </span><span class="s1">mutable.shouldScroll = shouldScroll</span><span class="s3">\n\n      </span><span class="s1">return handleMutable(state, mutable)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">() =&gt; state</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;generateSegmentsFromPatch&quot;</span><span class="s0">,</span><span class="s1">&quot;handleExternalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;navigateReducer&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;mutable&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingPush&quot;</span><span class="s0">,</span><span class="s1">&quot;mpaNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;scrollableSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;handleMutable&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterPatch&quot;</span><span class="s0">,</span><span class="s1">&quot;segments&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;childSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;triggerLazyFetchForLeafSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;newCache&quot;</span><span class="s0">,</span><span class="s1">&quot;currentCache&quot;</span><span class="s0">,</span><span class="s1">&quot;flightSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;treePatch&quot;</span><span class="s0">,</span><span class="s1">&quot;appliedPatch&quot;</span><span class="s0">,</span><span class="s1">&quot;rsc&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPathsToFill&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;clearCacheNodeDataForSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;handleNavigationResult&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;NavigationResultTag&quot;</span><span class="s0">,</span><span class="s1">&quot;MPA&quot;</span><span class="s0">,</span><span class="s1">&quot;newUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;NoOp&quot;</span><span class="s0">,</span><span class="s1">&quot;newCanonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;oldUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;onlyHashChange&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;hash&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldScroll&quot;</span><span class="s0">,</span><span class="s1">&quot;hashFragment&quot;</span><span class="s0">,</span><span class="s1">&quot;Success&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;patchedTree&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;Async&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;asyncResult&quot;</span><span class="s0">,</span><span class="s1">&quot;action&quot;</span><span class="s0">,</span><span class="s1">&quot;isExternalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;navigateType&quot;</span><span class="s0">,</span><span class="s1">&quot;allowAliasing&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;createHrefFromUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;prunePrefetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;preserveCustomHistoryState&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;document&quot;</span><span class="s0">,</span><span class="s1">&quot;getElementById&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CLIENT_SEGMENT_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;navigateUsingSegmentCache&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchValues&quot;</span><span class="s0">,</span><span class="s1">&quot;getOrCreatePrefetchCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;treeAtTimeOfPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;bump&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrlOverride&quot;</span><span class="s0">,</span><span class="s1">&quot;postponed&quot;</span><span class="s0">,</span><span class="s1">&quot;navigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;isFirstRead&quot;</span><span class="s0">,</span><span class="s1">&quot;lastUsedTime&quot;</span><span class="s0">,</span><span class="s1">&quot;aliased&quot;</span><span class="s0">,</span><span class="s1">&quot;urlWithCanonicalPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;handleAliasedPrefetchEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedCanonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;currentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;pathToSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;seedData&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;isHeadPartial&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootRender&quot;</span><span class="s0">,</span><span class="s1">&quot;flightSegmentPathWithLeadingEmpty&quot;</span><span class="s0">,</span><span class="s1">&quot;newTree&quot;</span><span class="s0">,</span><span class="s1">&quot;applyRouterStatePatchToTree&quot;</span><span class="s0">,</span><span class="s1">&quot;task&quot;</span><span class="s0">,</span><span class="s1">&quot;startPPRNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;patchedRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicRequestTree&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchServerResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;listenForDynamicRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;isNavigatingToNewRootLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;createEmptyCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;applied&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchCacheEntryStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;stale&quot;</span><span class="s0">,</span><span class="s1">&quot;applyFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;hardNavigate&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldHardNavigate&quot;</span><span class="s0">,</span><span class="s1">&quot;invalidateCacheBelowFlightSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;subSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;scrollableSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;DEFAULT_SEGMENT_KEY&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">8472</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/reducers/server-patch-reducer.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { createHrefFromUrl } from '../create-href-from-url'</span><span class="s3">\n</span><span class="s1">import { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'</span><span class="s3">\n</span><span class="s1">import { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">ServerPatchAction,</span><span class="s3">\n  </span><span class="s1">ReducerState,</span><span class="s3">\n  </span><span class="s1">ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">Mutable,</span><span class="s3">\n</span><span class="s1">} from '../router-reducer-types'</span><span class="s3">\n</span><span class="s1">import { handleExternalUrl } from './navigate-reducer'</span><span class="s3">\n</span><span class="s1">import { applyFlightData } from '../apply-flight-data'</span><span class="s3">\n</span><span class="s1">import { handleMutable } from '../handle-mutable'</span><span class="s3">\n</span><span class="s1">import type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { createEmptyCacheNode } from '../../app-router'</span><span class="s3">\n\n</span><span class="s1">export function serverPatchReducer(</span><span class="s3">\n  </span><span class="s1">state: ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">action: ServerPatchAction</span><span class="s3">\n</span><span class="s1">): ReducerState {</span><span class="s3">\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">serverResponse: { flightData, canonicalUrl: canonicalUrlOverride },</span><span class="s3">\n    </span><span class="s1">navigatedAt,</span><span class="s3">\n  </span><span class="s1">} = action</span><span class="s3">\n\n  </span><span class="s1">const mutable: Mutable = {}</span><span class="s3">\n\n  </span><span class="s1">mutable.preserveCustomHistoryState = false</span><span class="s3">\n\n  </span><span class="s1">// Handle case when navigating to page in `pages` from `app`</span><span class="s3">\n  </span><span class="s1">if (typeof flightData === 'string') {</span><span class="s3">\n    </span><span class="s1">return handleExternalUrl(</span><span class="s3">\n      </span><span class="s1">state,</span><span class="s3">\n      </span><span class="s1">mutable,</span><span class="s3">\n      </span><span class="s1">flightData,</span><span class="s3">\n      </span><span class="s1">state.pushRef.pendingPush</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let currentTree = state.tree</span><span class="s3">\n  </span><span class="s1">let currentCache = state.cache</span><span class="s3">\n\n  </span><span class="s1">for (const normalizedFlightData of flightData) {</span><span class="s3">\n    </span><span class="s1">const { segmentPath: flightSegmentPath, tree: treePatch } =</span><span class="s3">\n      </span><span class="s1">normalizedFlightData</span><span class="s3">\n\n    </span><span class="s1">const newTree = applyRouterStatePatchToTree(</span><span class="s3">\n      </span><span class="s1">// TODO-APP: remove ''</span><span class="s3">\n      </span><span class="s1">['', ...flightSegmentPath],</span><span class="s3">\n      </span><span class="s1">currentTree,</span><span class="s3">\n      </span><span class="s1">treePatch,</span><span class="s3">\n      </span><span class="s1">state.canonicalUrl</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">// `applyRouterStatePatchToTree` returns `null` when it determined that the server response is not applicable to the current tree.</span><span class="s3">\n    </span><span class="s1">// In other words, the server responded with a tree that doesn't match what the client is currently rendering.</span><span class="s3">\n    </span><span class="s1">// This can happen if the server patch action took longer to resolve than a subsequent navigation which would have changed the tree.</span><span class="s3">\n    </span><span class="s1">// Previously this case triggered an MPA navigation but it should be safe to simply discard the server response rather than forcing</span><span class="s3">\n    </span><span class="s1">// the entire page to reload.</span><span class="s3">\n    </span><span class="s1">if (newTree === null) {</span><span class="s3">\n      </span><span class="s1">return state</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isNavigatingToNewRootLayout(currentTree, newTree)) {</span><span class="s3">\n      </span><span class="s1">return handleExternalUrl(</span><span class="s3">\n        </span><span class="s1">state,</span><span class="s3">\n        </span><span class="s1">mutable,</span><span class="s3">\n        </span><span class="s1">state.canonicalUrl,</span><span class="s3">\n        </span><span class="s1">state.pushRef.pendingPush</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const canonicalUrlOverrideHref = canonicalUrlOverride</span><span class="s3">\n      </span><span class="s1">? createHrefFromUrl(canonicalUrlOverride)</span><span class="s3">\n      </span><span class="s1">: undefined</span><span class="s3">\n\n    </span><span class="s1">if (canonicalUrlOverrideHref) {</span><span class="s3">\n      </span><span class="s1">mutable.canonicalUrl = canonicalUrlOverrideHref</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const cache: CacheNode = createEmptyCacheNode()</span><span class="s3">\n    </span><span class="s1">applyFlightData(navigatedAt, currentCache, cache, normalizedFlightData)</span><span class="s3">\n\n    </span><span class="s1">mutable.patchedTree = newTree</span><span class="s3">\n    </span><span class="s1">mutable.cache = cache</span><span class="s3">\n\n    </span><span class="s1">currentCache = cache</span><span class="s3">\n    </span><span class="s1">currentTree = newTree</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return handleMutable(state, mutable)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;serverPatchReducer&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;action&quot;</span><span class="s0">,</span><span class="s1">&quot;serverResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrlOverride&quot;</span><span class="s0">,</span><span class="s1">&quot;navigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;mutable&quot;</span><span class="s0">,</span><span class="s1">&quot;preserveCustomHistoryState&quot;</span><span class="s0">,</span><span class="s1">&quot;handleExternalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;pushRef&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingPush&quot;</span><span class="s0">,</span><span class="s1">&quot;currentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;currentCache&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;flightSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;treePatch&quot;</span><span class="s0">,</span><span class="s1">&quot;newTree&quot;</span><span class="s0">,</span><span class="s1">&quot;applyRouterStatePatchToTree&quot;</span><span class="s0">,</span><span class="s1">&quot;isNavigatingToNewRootLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrlOverrideHref&quot;</span><span class="s0">,</span><span class="s1">&quot;createHrefFromUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;createEmptyCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;applyFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;patchedTree&quot;</span><span class="s0">,</span><span class="s1">&quot;handleMutable&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAegBA,sBAAAA;;;eAAAA;;;mCAfkB;6CACU;6CACA;iCAOV;iCACF;+BACF;2BAEO;AAE9B,SAASA,mBACdC,KAA2B,EAC3BC,MAAyB;IAEzB,MAAM,EACJC,gBAAgB,EAAEC,UAAU,EAAEC,cAAcC,oBAAoB,EAAE,EAClEC,WAAW,EACZ,GAAGL;IAEJ,MAAMM,UAAmB,CAAC;IAE1BA,QAAQC,0BAA0B,GAAG;IAErC,4DAA4D;IAC5D,IAAI,OAAOL,eAAe,UAAU;QAClC,OAAOM,CAAAA,GAAAA,iBAAAA,iBAAiB,EACtBT,OACAO,SACAJ,YACAH,MAAMU,OAAO,CAACC,WAAW;IAE7B;IAEA,IAAIC,cAAcZ,MAAMa,IAAI;IAC5B,IAAIC,eAAed,MAAMe,KAAK;IAE9B,KAAK,MAAMC,wBAAwBb,WAAY;QAC7C,MAAM,EAAEc,aAAaC,iBAAiB,EAAEL,MAAMM,SAAS,EAAE,GACvDH;QAEF,MAAMI,UAAUC,CAAAA,GAAAA,6BAAAA,2BAA2B,EACzC,AACA,sBADsB;YACrB;eAAOH;SAAkB,EAC1BN,aACAO,WACAnB,MAAMI,YAAY;QAGpB,kIAAkI;QAClI,8GAA8G;QAC9G,oIAAoI;QACpI,mIAAmI;QACnI,6BAA6B;QAC7B,IAAIgB,YAAY,MAAM;YACpB,OAAOpB;QACT;QAEA,IAAIsB,CAAAA,GAAAA,6BAAAA,2BAA2B,EAACV,aAAaQ,UAAU;YACrD,OAAOX,CAAAA,GAAAA,iBAAAA,iBAAiB,EACtBT,OACAO,SACAP,MAAMI,YAAY,EAClBJ,MAAMU,OAAO,CAACC,WAAW;QAE7B;QAEA,MAAMY,2BAA2BlB,uBAC7BmB,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACnB,wBAClBoB;QAEJ,IAAIF,0BAA0B;YAC5BhB,QAAQH,YAAY,GAAGmB;QACzB;QAEA,MAAMR,QAAmBW,CAAAA,GAAAA,WAAAA,oBAAoB;QAC7CC,CAAAA,GAAAA,iBAAAA,eAAe,EAACrB,aAAaQ,cAAcC,OAAOC;QAElDT,QAAQqB,WAAW,GAAGR;QACtBb,QAAQQ,KAAK,GAAGA;QAEhBD,eAAeC;QACfH,cAAcQ;IAChB;IAEA,OAAOS,CAAAA,GAAAA,eAAAA,aAAa,EAAC7B,OAAOO;AAC9B&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">8539</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/reducers/restore-reducer.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { createHrefFromUrl } from '../create-href-from-url'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">ReducerState,</span><span class="s3">\n  </span><span class="s1">RestoreAction,</span><span class="s3">\n</span><span class="s1">} from '../router-reducer-types'</span><span class="s3">\n</span><span class="s1">import { extractPathFromFlightRouterState } from '../compute-changed-path'</span><span class="s3">\n</span><span class="s1">import { updateCacheNodeOnPopstateRestoration } from '../ppr-navigations'</span><span class="s3">\n\n</span><span class="s1">export function restoreReducer(</span><span class="s3">\n  </span><span class="s1">state: ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">action: RestoreAction</span><span class="s3">\n</span><span class="s1">): ReducerState {</span><span class="s3">\n  </span><span class="s1">const { url, tree } = action</span><span class="s3">\n  </span><span class="s1">const href = createHrefFromUrl(url)</span><span class="s3">\n  </span><span class="s1">// This action is used to restore the router state from the history state.</span><span class="s3">\n  </span><span class="s1">// However, it's possible that the history state no longer contains the `FlightRouterState`.</span><span class="s3">\n  </span><span class="s1">// We will copy over the internal state on pushState/replaceState events, but if a history entry</span><span class="s3">\n  </span><span class="s1">// occurred before hydration, or if the user navigated to a hash using a regular anchor link,</span><span class="s3">\n  </span><span class="s1">// the history state will not contain the `FlightRouterState`.</span><span class="s3">\n  </span><span class="s1">// In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.</span><span class="s3">\n  </span><span class="s1">const treeToRestore = tree || state.tree</span><span class="s3">\n\n  </span><span class="s1">const oldCache = state.cache</span><span class="s3">\n  </span><span class="s1">const newCache = process.env.__NEXT_PPR</span><span class="s3">\n    </span><span class="s1">? // When PPR is enabled, we update the cache to drop the prefetch</span><span class="s3">\n      </span><span class="s1">// data for any segment whose dynamic data was already received. This</span><span class="s3">\n      </span><span class="s1">// prevents an unnecessary flash back to PPR state during a</span><span class="s3">\n      </span><span class="s1">// back/forward navigation.</span><span class="s3">\n      </span><span class="s1">updateCacheNodeOnPopstateRestoration(oldCache, treeToRestore)</span><span class="s3">\n    </span><span class="s1">: oldCache</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">// Set canonical url</span><span class="s3">\n    </span><span class="s1">canonicalUrl: href,</span><span class="s3">\n    </span><span class="s1">pushRef: {</span><span class="s3">\n      </span><span class="s1">pendingPush: false,</span><span class="s3">\n      </span><span class="s1">mpaNavigation: false,</span><span class="s3">\n      </span><span class="s1">// Ensures that the custom history state that was set is preserved when applying this update.</span><span class="s3">\n      </span><span class="s1">preserveCustomHistoryState: true,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">focusAndScrollRef: state.focusAndScrollRef,</span><span class="s3">\n    </span><span class="s1">cache: newCache,</span><span class="s3">\n    </span><span class="s1">prefetchCache: state.prefetchCache,</span><span class="s3">\n    </span><span class="s1">// Restore provided tree</span><span class="s3">\n    </span><span class="s1">tree: treeToRestore,</span><span class="s3">\n    </span><span class="s1">nextUrl: extractPathFromFlightRouterState(treeToRestore) ?? url.pathname,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;restoreReducer&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;action&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;createHrefFromUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;treeToRestore&quot;</span><span class="s0">,</span><span class="s1">&quot;oldCache&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;newCache&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_PPR&quot;</span><span class="s0">,</span><span class="s1">&quot;updateCacheNodeOnPopstateRestoration&quot;</span><span class="s0">,</span><span class="s1">&quot;extractPathFromFlightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;pushRef&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingPush&quot;</span><span class="s0">,</span><span class="s1">&quot;mpaNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;preserveCustomHistoryState&quot;</span><span class="s0">,</span><span class="s1">&quot;focusAndScrollRef&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAwBmBW,QAAQC,GAAG,CAACC,UAAU,GAEnC,qEAAqE;;;;;+BAjB3Db,kBAAAA;;;eAAAA;;;mCATkB;oCAMe;gCACI;AAE9C,SAASA,eACdC,KAA2B,EAC3BC,MAAqB;IAErB,MAAM,EAAEC,GAAG,EAAEC,IAAI,EAAE,GAAGF;IACtB,MAAMG,OAAOC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACH;IAC/B,0EAA0E;IAC1E,4FAA4F;IAC5F,gGAAgG;IAChG,6FAA6F;IAC7F,8DAA8D;IAC9D,yGAAyG;IACzG,MAAMI,gBAAgBH,QAAQH,MAAMG,IAAI;IAExC,MAAMI,WAAWP,MAAMQ,KAAK;IAC5B,MAAMC,iDAGF,2DAA2D;IAC3D,2BAA2B;IAC3BI,IAAAA,sBACAN,8BADoC,EAACA,UAAUD;QAiBxCQ;IAdX,OAAO;QACL,oBAAoB;QACpBC,cAAcX;QACdY,SAAS;YACPC,aAAa;YACbC,eAAe;YACf,6FAA6F;YAC7FC,4BAA4B;QAC9B;QACAC,mBAAmBpB,MAAMoB,iBAAiB;QAC1CZ,OAAOC;QACPY,eAAerB,MAAMqB,aAAa;QAClC,wBAAwB;QACxBlB,MAAMG;QACNgB,SAASR,CAAAA,oCAAAA,CAAAA,GAAAA,oBAAAA,gCAAgC,EAACR,cAAAA,KAAAA,OAAjCQ,oCAAmDZ,IAAIqB,QAAQ;IAC1E;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">8596</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/handle-segment-mismatch.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { FlightRouterState } from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { handleExternalUrl } from './reducers/navigate-reducer'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">ReducerActions,</span><span class="s3">\n</span><span class="s1">} from './router-reducer-types'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Handles the case where the client router attempted to patch the tree but, due to a mismatch, the patch failed.</span><span class="s3">\n </span><span class="s1">* This will perform an MPA navigation to return the router to a valid state.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function handleSegmentMismatch(</span><span class="s3">\n  </span><span class="s1">state: ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">action: ReducerActions,</span><span class="s3">\n  </span><span class="s1">treePatch: FlightRouterState</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s3">\n    </span><span class="s1">console.warn(</span><span class="s3">\n      </span><span class="s1">'Performing hard navigation because your application experienced an unrecoverable error. If this keeps occurring, please file a Next.js issue.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n' +</span><span class="s3">\n        </span><span class="s1">'Reason: Segment mismatch</span><span class="s3">\\</span><span class="s1">n' +</span><span class="s3">\n        </span><span class="s1">`Last Action: ${action.type}</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n        </span><span class="s1">`Current Tree: ${JSON.stringify(state.tree)}</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n        </span><span class="s1">`Tree Patch Payload: ${JSON.stringify(treePatch)}`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return handleExternalUrl(state, {}, state.canonicalUrl, true)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;handleSegmentMismatch&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;action&quot;</span><span class="s0">,</span><span class="s1">&quot;treePatch&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;warn&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;handleExternalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrl&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAgBMI,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;+BALfN,yBAAAA;;;eAAAA;;;iCAVkB;AAU3B,SAASA,sBACdC,KAA2B,EAC3BC,MAAsB,EACtBC,SAA4B;IAE5B,wCAA4C;QAC1CI,QAAQC,IAAI,CACV,sJACE,+BACA,CAAC,kBAAeN,OAAOO,IAAI,GAAC,MAAI,IAChC,CAAC,mBAAgBC,KAAKC,SAAS,CAACV,MAAMW,IAAI,IAAE,MAAI,IAChD,CAAC,yBAAsBF,KAAKC,SAAS,CAACR,UAAW;IAEvD;IAEA,OAAOU,CAAAA,GAAAA,iBAAAA,iBAAiB,EAACZ,OAAO,CAAC,GAAGA,MAAMa,YAAY,EAAE;AAC1D&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">8625</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/reducers/has-interception-route-in-current-tree.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { FlightRouterState } from '../../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { isInterceptionRouteAppPath } from '../../../../shared/lib/router/utils/interception-routes'</span><span class="s3">\n\n</span><span class="s1">export function hasInterceptionRouteInCurrentTree([</span><span class="s3">\n  </span><span class="s1">segment,</span><span class="s3">\n  </span><span class="s1">parallelRoutes,</span><span class="s3">\n</span><span class="s1">]: FlightRouterState): boolean {</span><span class="s3">\n  </span><span class="s1">// If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.</span><span class="s3">\n  </span><span class="s1">if (Array.isArray(segment) &amp;&amp; (segment[2] === 'di' || segment[2] === 'ci')) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If segment is not an array, apply the existing string-based check</span><span class="s3">\n  </span><span class="s1">if (typeof segment === 'string' &amp;&amp; isInterceptionRouteAppPath(segment)) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Iterate through parallelRoutes if they exist</span><span class="s3">\n  </span><span class="s1">if (parallelRoutes) {</span><span class="s3">\n    </span><span class="s1">for (const key in parallelRoutes) {</span><span class="s3">\n      </span><span class="s1">if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;hasInterceptionRouteInCurrentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;isInterceptionRouteAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAGgBA,qCAAAA;;;eAAAA;;;oCAF2B;AAEpC,SAASA,kCAAkC,KAG9B;IAH8B,IAAA,CAChDC,SACAC,eACkB,GAH8B;IAIhD,wGAAwG;IACxG,IAAIC,MAAMC,OAAO,CAACH,YAAaA,CAAAA,OAAO,CAAC,EAAE,KAAK,QAAQA,OAAO,CAAC,EAAE,KAAK,IAAG,GAAI;QAC1E,OAAO;IACT;IAEA,oEAAoE;IACpE,IAAI,OAAOA,YAAY,YAAYI,CAAAA,GAAAA,oBAAAA,0BAA0B,EAACJ,UAAU;QACtE,OAAO;IACT;IAEA,+CAA+C;IAC/C,IAAIC,gBAAgB;QAClB,IAAK,MAAMI,OAAOJ,eAAgB;YAChC,IAAIF,kCAAkCE,cAAc,CAACI,IAAI,GAAG;gBAC1D,OAAO;YACT;QACF;IACF;IAEA,OAAO;AACT&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">8666</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/reducers/refresh-reducer.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { fetchServerResponse } from '../fetch-server-response'</span><span class="s3">\n</span><span class="s1">import { createHrefFromUrl } from '../create-href-from-url'</span><span class="s3">\n</span><span class="s1">import { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'</span><span class="s3">\n</span><span class="s1">import { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">Mutable,</span><span class="s3">\n  </span><span class="s1">ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">ReducerState,</span><span class="s3">\n  </span><span class="s1">RefreshAction,</span><span class="s3">\n</span><span class="s1">} from '../router-reducer-types'</span><span class="s3">\n</span><span class="s1">import { handleExternalUrl } from './navigate-reducer'</span><span class="s3">\n</span><span class="s1">import { handleMutable } from '../handle-mutable'</span><span class="s3">\n</span><span class="s1">import type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head'</span><span class="s3">\n</span><span class="s1">import { createEmptyCacheNode } from '../../app-router'</span><span class="s3">\n</span><span class="s1">import { handleSegmentMismatch } from '../handle-segment-mismatch'</span><span class="s3">\n</span><span class="s1">import { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'</span><span class="s3">\n</span><span class="s1">import { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments'</span><span class="s3">\n</span><span class="s1">import { revalidateEntireCache } from '../../segment-cache'</span><span class="s3">\n\n</span><span class="s1">export function refreshReducer(</span><span class="s3">\n  </span><span class="s1">state: ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">action: RefreshAction</span><span class="s3">\n</span><span class="s1">): ReducerState {</span><span class="s3">\n  </span><span class="s1">const { origin } = action</span><span class="s3">\n  </span><span class="s1">const mutable: Mutable = {}</span><span class="s3">\n  </span><span class="s1">const href = state.canonicalUrl</span><span class="s3">\n\n  </span><span class="s1">let currentTree = state.tree</span><span class="s3">\n\n  </span><span class="s1">mutable.preserveCustomHistoryState = false</span><span class="s3">\n\n  </span><span class="s1">const cache: CacheNode = createEmptyCacheNode()</span><span class="s3">\n\n  </span><span class="s1">// If the current tree was intercepted, the nextUrl should be included in the request.</span><span class="s3">\n  </span><span class="s1">// This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.</span><span class="s3">\n  </span><span class="s1">const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree)</span><span class="s3">\n\n  </span><span class="s1">// TODO-APP: verify that `href` is not an external url.</span><span class="s3">\n  </span><span class="s1">// Fetch data from the root of the tree.</span><span class="s3">\n  </span><span class="s1">cache.lazyData = fetchServerResponse(new URL(href, origin), {</span><span class="s3">\n    </span><span class="s1">flightRouterState: [</span><span class="s3">\n      </span><span class="s1">currentTree[0],</span><span class="s3">\n      </span><span class="s1">currentTree[1],</span><span class="s3">\n      </span><span class="s1">currentTree[2],</span><span class="s3">\n      </span><span class="s1">'refetch',</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">nextUrl: includeNextUrl ? state.nextUrl : null,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const navigatedAt = Date.now()</span><span class="s3">\n  </span><span class="s1">return cache.lazyData.then(</span><span class="s3">\n    </span><span class="s1">async ({ flightData, canonicalUrl: canonicalUrlOverride }) =&gt; {</span><span class="s3">\n      </span><span class="s1">// Handle case when navigating to page in `pages` from `app`</span><span class="s3">\n      </span><span class="s1">if (typeof flightData === 'string') {</span><span class="s3">\n        </span><span class="s1">return handleExternalUrl(</span><span class="s3">\n          </span><span class="s1">state,</span><span class="s3">\n          </span><span class="s1">mutable,</span><span class="s3">\n          </span><span class="s1">flightData,</span><span class="s3">\n          </span><span class="s1">state.pushRef.pendingPush</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Remove cache.lazyData as it has been resolved at this point.</span><span class="s3">\n      </span><span class="s1">cache.lazyData = null</span><span class="s3">\n\n      </span><span class="s1">for (const normalizedFlightData of flightData) {</span><span class="s3">\n        </span><span class="s1">const {</span><span class="s3">\n          </span><span class="s1">tree: treePatch,</span><span class="s3">\n          </span><span class="s1">seedData: cacheNodeSeedData,</span><span class="s3">\n          </span><span class="s1">head,</span><span class="s3">\n          </span><span class="s1">isRootRender,</span><span class="s3">\n        </span><span class="s1">} = normalizedFlightData</span><span class="s3">\n\n        </span><span class="s1">if (!isRootRender) {</span><span class="s3">\n          </span><span class="s1">// TODO-APP: handle this case better</span><span class="s3">\n          </span><span class="s1">console.log('REFRESH FAILED')</span><span class="s3">\n          </span><span class="s1">return state</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const newTree = applyRouterStatePatchToTree(</span><span class="s3">\n          </span><span class="s1">// TODO-APP: remove ''</span><span class="s3">\n          </span><span class="s1">[''],</span><span class="s3">\n          </span><span class="s1">currentTree,</span><span class="s3">\n          </span><span class="s1">treePatch,</span><span class="s3">\n          </span><span class="s1">state.canonicalUrl</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">if (newTree === null) {</span><span class="s3">\n          </span><span class="s1">return handleSegmentMismatch(state, action, treePatch)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (isNavigatingToNewRootLayout(currentTree, newTree)) {</span><span class="s3">\n          </span><span class="s1">return handleExternalUrl(</span><span class="s3">\n            </span><span class="s1">state,</span><span class="s3">\n            </span><span class="s1">mutable,</span><span class="s3">\n            </span><span class="s1">href,</span><span class="s3">\n            </span><span class="s1">state.pushRef.pendingPush</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const canonicalUrlOverrideHref = canonicalUrlOverride</span><span class="s3">\n          </span><span class="s1">? createHrefFromUrl(canonicalUrlOverride)</span><span class="s3">\n          </span><span class="s1">: undefined</span><span class="s3">\n\n        </span><span class="s1">if (canonicalUrlOverride) {</span><span class="s3">\n          </span><span class="s1">mutable.canonicalUrl = canonicalUrlOverrideHref</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Handles case where prefetch only returns the router tree patch without rendered components.</span><span class="s3">\n        </span><span class="s1">if (cacheNodeSeedData !== null) {</span><span class="s3">\n          </span><span class="s1">const rsc = cacheNodeSeedData[1]</span><span class="s3">\n          </span><span class="s1">const loading = cacheNodeSeedData[3]</span><span class="s3">\n          </span><span class="s1">cache.rsc = rsc</span><span class="s3">\n          </span><span class="s1">cache.prefetchRsc = null</span><span class="s3">\n          </span><span class="s1">cache.loading = loading</span><span class="s3">\n          </span><span class="s1">fillLazyItemsTillLeafWithHead(</span><span class="s3">\n            </span><span class="s1">navigatedAt,</span><span class="s3">\n            </span><span class="s1">cache,</span><span class="s3">\n            </span><span class="s1">// Existing cache is not passed in as `router.refresh()` has to invalidate the entire cache.</span><span class="s3">\n            </span><span class="s1">undefined,</span><span class="s3">\n            </span><span class="s1">treePatch,</span><span class="s3">\n            </span><span class="s1">cacheNodeSeedData,</span><span class="s3">\n            </span><span class="s1">head,</span><span class="s3">\n            </span><span class="s1">undefined</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {</span><span class="s3">\n            </span><span class="s1">revalidateEntireCache(state.nextUrl, newTree)</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">mutable.prefetchCache = new Map()</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">await refreshInactiveParallelSegments({</span><span class="s3">\n          </span><span class="s1">navigatedAt,</span><span class="s3">\n          </span><span class="s1">state,</span><span class="s3">\n          </span><span class="s1">updatedTree: newTree,</span><span class="s3">\n          </span><span class="s1">updatedCache: cache,</span><span class="s3">\n          </span><span class="s1">includeNextUrl,</span><span class="s3">\n          </span><span class="s1">canonicalUrl: mutable.canonicalUrl || state.canonicalUrl,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">mutable.cache = cache</span><span class="s3">\n        </span><span class="s1">mutable.patchedTree = newTree</span><span class="s3">\n\n        </span><span class="s1">currentTree = newTree</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return handleMutable(state, mutable)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">() =&gt; state</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;refreshReducer&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;action&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;mutable&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;currentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;preserveCustomHistoryState&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;createEmptyCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;includeNextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;hasInterceptionRouteInCurrentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyData&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchServerResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;navigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrlOverride&quot;</span><span class="s0">,</span><span class="s1">&quot;handleExternalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;pushRef&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingPush&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;treePatch&quot;</span><span class="s0">,</span><span class="s1">&quot;seedData&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheNodeSeedData&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootRender&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;log&quot;</span><span class="s0">,</span><span class="s1">&quot;newTree&quot;</span><span class="s0">,</span><span class="s1">&quot;applyRouterStatePatchToTree&quot;</span><span class="s0">,</span><span class="s1">&quot;handleSegmentMismatch&quot;</span><span class="s0">,</span><span class="s1">&quot;isNavigatingToNewRootLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrlOverrideHref&quot;</span><span class="s0">,</span><span class="s1">&quot;createHrefFromUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;rsc&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;fillLazyItemsTillLeafWithHead&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CLIENT_SEGMENT_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateEntireCache&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;refreshInactiveParallelSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedTree&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedCache&quot;</span><span class="s0">,</span><span class="s1">&quot;patchedTree&quot;</span><span class="s0">,</span><span class="s1">&quot;handleMutable&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">8779</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/reducers/hmr-refresh-reducer.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { fetchServerResponse } from '../fetch-server-response'</span><span class="s3">\n</span><span class="s1">import { createHrefFromUrl } from '../create-href-from-url'</span><span class="s3">\n</span><span class="s1">import { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'</span><span class="s3">\n</span><span class="s1">import { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">ReducerState,</span><span class="s3">\n  </span><span class="s1">HmrRefreshAction,</span><span class="s3">\n  </span><span class="s1">Mutable,</span><span class="s3">\n</span><span class="s1">} from '../router-reducer-types'</span><span class="s3">\n</span><span class="s1">import { handleExternalUrl } from './navigate-reducer'</span><span class="s3">\n</span><span class="s1">import { handleMutable } from '../handle-mutable'</span><span class="s3">\n</span><span class="s1">import { applyFlightData } from '../apply-flight-data'</span><span class="s3">\n</span><span class="s1">import type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { createEmptyCacheNode } from '../../app-router'</span><span class="s3">\n</span><span class="s1">import { handleSegmentMismatch } from '../handle-segment-mismatch'</span><span class="s3">\n</span><span class="s1">import { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'</span><span class="s3">\n\n</span><span class="s1">// A version of refresh reducer that keeps the cache around instead of wiping all of it.</span><span class="s3">\n</span><span class="s1">function hmrRefreshReducerImpl(</span><span class="s3">\n  </span><span class="s1">state: ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">action: HmrRefreshAction</span><span class="s3">\n</span><span class="s1">): ReducerState {</span><span class="s3">\n  </span><span class="s1">const { origin } = action</span><span class="s3">\n  </span><span class="s1">const mutable: Mutable = {}</span><span class="s3">\n  </span><span class="s1">const href = state.canonicalUrl</span><span class="s3">\n\n  </span><span class="s1">mutable.preserveCustomHistoryState = false</span><span class="s3">\n\n  </span><span class="s1">const cache: CacheNode = createEmptyCacheNode()</span><span class="s3">\n  </span><span class="s1">// If the current tree was intercepted, the nextUrl should be included in the request.</span><span class="s3">\n  </span><span class="s1">// This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.</span><span class="s3">\n  </span><span class="s1">const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree)</span><span class="s3">\n\n  </span><span class="s1">// TODO-APP: verify that `href` is not an external url.</span><span class="s3">\n  </span><span class="s1">// Fetch data from the root of the tree.</span><span class="s3">\n  </span><span class="s1">const navigatedAt = Date.now()</span><span class="s3">\n  </span><span class="s1">cache.lazyData = fetchServerResponse(new URL(href, origin), {</span><span class="s3">\n    </span><span class="s1">flightRouterState: [state.tree[0], state.tree[1], state.tree[2], 'refetch'],</span><span class="s3">\n    </span><span class="s1">nextUrl: includeNextUrl ? state.nextUrl : null,</span><span class="s3">\n    </span><span class="s1">isHmrRefresh: true,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">return cache.lazyData.then(</span><span class="s3">\n    </span><span class="s1">({ flightData, canonicalUrl: canonicalUrlOverride }) =&gt; {</span><span class="s3">\n      </span><span class="s1">// Handle case when navigating to page in `pages` from `app`</span><span class="s3">\n      </span><span class="s1">if (typeof flightData === 'string') {</span><span class="s3">\n        </span><span class="s1">return handleExternalUrl(</span><span class="s3">\n          </span><span class="s1">state,</span><span class="s3">\n          </span><span class="s1">mutable,</span><span class="s3">\n          </span><span class="s1">flightData,</span><span class="s3">\n          </span><span class="s1">state.pushRef.pendingPush</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Remove cache.lazyData as it has been resolved at this point.</span><span class="s3">\n      </span><span class="s1">cache.lazyData = null</span><span class="s3">\n\n      </span><span class="s1">let currentTree = state.tree</span><span class="s3">\n      </span><span class="s1">let currentCache = state.cache</span><span class="s3">\n\n      </span><span class="s1">for (const normalizedFlightData of flightData) {</span><span class="s3">\n        </span><span class="s1">const { tree: treePatch, isRootRender } = normalizedFlightData</span><span class="s3">\n        </span><span class="s1">if (!isRootRender) {</span><span class="s3">\n          </span><span class="s1">// TODO-APP: handle this case better</span><span class="s3">\n          </span><span class="s1">console.log('REFRESH FAILED')</span><span class="s3">\n          </span><span class="s1">return state</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const newTree = applyRouterStatePatchToTree(</span><span class="s3">\n          </span><span class="s1">// TODO-APP: remove ''</span><span class="s3">\n          </span><span class="s1">[''],</span><span class="s3">\n          </span><span class="s1">currentTree,</span><span class="s3">\n          </span><span class="s1">treePatch,</span><span class="s3">\n          </span><span class="s1">state.canonicalUrl</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">if (newTree === null) {</span><span class="s3">\n          </span><span class="s1">return handleSegmentMismatch(state, action, treePatch)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (isNavigatingToNewRootLayout(currentTree, newTree)) {</span><span class="s3">\n          </span><span class="s1">return handleExternalUrl(</span><span class="s3">\n            </span><span class="s1">state,</span><span class="s3">\n            </span><span class="s1">mutable,</span><span class="s3">\n            </span><span class="s1">href,</span><span class="s3">\n            </span><span class="s1">state.pushRef.pendingPush</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const canonicalUrlOverrideHref = canonicalUrlOverride</span><span class="s3">\n          </span><span class="s1">? createHrefFromUrl(canonicalUrlOverride)</span><span class="s3">\n          </span><span class="s1">: undefined</span><span class="s3">\n\n        </span><span class="s1">if (canonicalUrlOverride) {</span><span class="s3">\n          </span><span class="s1">mutable.canonicalUrl = canonicalUrlOverrideHref</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const applied = applyFlightData(</span><span class="s3">\n          </span><span class="s1">navigatedAt,</span><span class="s3">\n          </span><span class="s1">currentCache,</span><span class="s3">\n          </span><span class="s1">cache,</span><span class="s3">\n          </span><span class="s1">normalizedFlightData</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">if (applied) {</span><span class="s3">\n          </span><span class="s1">mutable.cache = cache</span><span class="s3">\n          </span><span class="s1">currentCache = cache</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">mutable.patchedTree = newTree</span><span class="s3">\n        </span><span class="s1">mutable.canonicalUrl = href</span><span class="s3">\n\n        </span><span class="s1">currentTree = newTree</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return handleMutable(state, mutable)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">() =&gt; state</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function hmrRefreshReducerNoop(</span><span class="s3">\n  </span><span class="s1">state: ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">_action: HmrRefreshAction</span><span class="s3">\n</span><span class="s1">): ReducerState {</span><span class="s3">\n  </span><span class="s1">return state</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const hmrRefreshReducer =</span><span class="s3">\n  </span><span class="s1">process.env.NODE_ENV === 'production'</span><span class="s3">\n    </span><span class="s1">? hmrRefreshReducerNoop</span><span class="s3">\n    </span><span class="s1">: hmrRefreshReducerImpl</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;hmrRefreshReducer&quot;</span><span class="s0">,</span><span class="s1">&quot;hmrRefreshReducerImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;action&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;mutable&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;preserveCustomHistoryState&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;createEmptyCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;includeNextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;hasInterceptionRouteInCurrentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;navigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyData&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchServerResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;isHmrRefresh&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrlOverride&quot;</span><span class="s0">,</span><span class="s1">&quot;handleExternalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;pushRef&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingPush&quot;</span><span class="s0">,</span><span class="s1">&quot;currentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;currentCache&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;treePatch&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootRender&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;log&quot;</span><span class="s0">,</span><span class="s1">&quot;newTree&quot;</span><span class="s0">,</span><span class="s1">&quot;applyRouterStatePatchToTree&quot;</span><span class="s0">,</span><span class="s1">&quot;handleSegmentMismatch&quot;</span><span class="s0">,</span><span class="s1">&quot;isNavigatingToNewRootLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrlOverrideHref&quot;</span><span class="s0">,</span><span class="s1">&quot;createHrefFromUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;applied&quot;</span><span class="s0">,</span><span class="s1">&quot;applyFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;patchedTree&quot;</span><span class="s0">,</span><span class="s1">&quot;handleMutable&quot;</span><span class="s0">,</span><span class="s1">&quot;hmrRefreshReducerNoop&quot;</span><span class="s0">,</span><span class="s1">&quot;_action&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">8880</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/assign-location.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { addBasePath } from './add-base-path'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Function to correctly assign location to URL</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The method will add basePath, and will also correctly add location (including if it is a relative path)</span><span class="s3">\n </span><span class="s1">* @param location Location that should be added to the url</span><span class="s3">\n </span><span class="s1">* @param url Base URL to which the location should be assigned</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function assignLocation(location: string, url: URL): URL {</span><span class="s3">\n  </span><span class="s1">if (location.startsWith('.')) {</span><span class="s3">\n    </span><span class="s1">const urlBase = url.origin + url.pathname</span><span class="s3">\n    </span><span class="s1">return new URL(</span><span class="s3">\n      </span><span class="s1">// In order for a relative path to be added to the current url correctly, the current url must end with a slash</span><span class="s3">\n      </span><span class="s1">// new URL('./relative', 'https://example.com/subdir').href -&gt; 'https://example.com/relative'</span><span class="s3">\n      </span><span class="s1">// new URL('./relative', 'https://example.com/subdir/').href -&gt; 'https://example.com/subdir/relative'</span><span class="s3">\n      </span><span class="s1">(urlBase.endsWith('/') ? urlBase : urlBase + '/') + location</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return new URL(addBasePath(location), url.href)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;assignLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;urlBase&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;addBasePath&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BASgBA,kBAAAA;;;eAAAA;;;6BATY;AASrB,SAASA,eAAeC,QAAgB,EAAEC,GAAQ;IACvD,IAAID,SAASE,UAAU,CAAC,MAAM;QAC5B,MAAMC,UAAUF,IAAIG,MAAM,GAAGH,IAAII,QAAQ;QACzC,OAAO,IAAIC,IACT,AAGA,AAFA,6FAA6F,kBADkB;QAE/G,qGAAqG;QACpGH,CAAAA,QAAQI,QAAQ,CAAC,OAAOJ,UAAUA,UAAU,GAAE,IAAKH;IAExD;IAEA,OAAO,IAAIM,IAAIE,CAAAA,GAAAA,aAAAA,WAAW,EAACR,WAAWC,IAAIQ,IAAI;AAChD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">8910</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/reducers/server-action-reducer.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">ActionFlightResponse,</span><span class="s3">\n  </span><span class="s1">ActionResult,</span><span class="s3">\n</span><span class="s1">} from '../../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { callServer } from '../../../app-call-server'</span><span class="s3">\n</span><span class="s1">import { findSourceMapURL } from '../../../app-find-source-map-url'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">ACTION_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ACTION_NOT_FOUND_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_IS_PRERENDER_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_STATE_TREE_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_URL,</span><span class="s3">\n  </span><span class="s1">RSC_CONTENT_TYPE_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../../app-router-headers'</span><span class="s3">\n</span><span class="s1">import { UnrecognizedActionError } from '../../unrecognized-action-error'</span><span class="s3">\n\n</span><span class="s1">// TODO: Explicitly import from client.browser</span><span class="s3">\n</span><span class="s1">// eslint-disable-next-line import/no-extraneous-dependencies</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">createFromFetch as createFromFetchBrowser,</span><span class="s3">\n  </span><span class="s1">createTemporaryReferenceSet,</span><span class="s3">\n  </span><span class="s1">encodeReply,</span><span class="s3">\n</span><span class="s1">} from 'react-server-dom-webpack/client'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">PrefetchKind,</span><span class="s3">\n  </span><span class="s1">type ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">type ReducerState,</span><span class="s3">\n  </span><span class="s1">type ServerActionAction,</span><span class="s3">\n  </span><span class="s1">type ServerActionMutable,</span><span class="s3">\n</span><span class="s1">} from '../router-reducer-types'</span><span class="s3">\n</span><span class="s1">import { assignLocation } from '../../../assign-location'</span><span class="s3">\n</span><span class="s1">import { createHrefFromUrl } from '../create-href-from-url'</span><span class="s3">\n</span><span class="s1">import { handleExternalUrl } from './navigate-reducer'</span><span class="s3">\n</span><span class="s1">import { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'</span><span class="s3">\n</span><span class="s1">import { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'</span><span class="s3">\n</span><span class="s1">import type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { handleMutable } from '../handle-mutable'</span><span class="s3">\n</span><span class="s1">import { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head'</span><span class="s3">\n</span><span class="s1">import { createEmptyCacheNode } from '../../app-router'</span><span class="s3">\n</span><span class="s1">import { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'</span><span class="s3">\n</span><span class="s1">import { handleSegmentMismatch } from '../handle-segment-mismatch'</span><span class="s3">\n</span><span class="s1">import { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">normalizeFlightData,</span><span class="s3">\n  </span><span class="s1">prepareFlightRouterStateForRequest,</span><span class="s3">\n  </span><span class="s1">type NormalizedFlightData,</span><span class="s3">\n</span><span class="s1">} from '../../../flight-data-helpers'</span><span class="s3">\n</span><span class="s1">import { getRedirectError } from '../../redirect'</span><span class="s3">\n</span><span class="s1">import { RedirectType } from '../../redirect-error'</span><span class="s3">\n</span><span class="s1">import { createSeededPrefetchCacheEntry } from '../prefetch-cache-utils'</span><span class="s3">\n</span><span class="s1">import { removeBasePath } from '../../../remove-base-path'</span><span class="s3">\n</span><span class="s1">import { hasBasePath } from '../../../has-base-path'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">extractInfoFromServerReferenceId,</span><span class="s3">\n  </span><span class="s1">omitUnusedArgs,</span><span class="s3">\n</span><span class="s1">} from '../../../../shared/lib/server-reference-info'</span><span class="s3">\n</span><span class="s1">import { revalidateEntireCache } from '../../segment-cache'</span><span class="s3">\n\n</span><span class="s1">const createFromFetch =</span><span class="s3">\n  </span><span class="s1">createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']</span><span class="s3">\n\n</span><span class="s1">type FetchServerActionResult = {</span><span class="s3">\n  </span><span class="s1">redirectLocation: URL | undefined</span><span class="s3">\n  </span><span class="s1">redirectType: RedirectType | undefined</span><span class="s3">\n  </span><span class="s1">actionResult: ActionResult | undefined</span><span class="s3">\n  </span><span class="s1">actionFlightData: NormalizedFlightData[] | string | undefined</span><span class="s3">\n  </span><span class="s1">isPrerender: boolean</span><span class="s3">\n  </span><span class="s1">revalidatedParts: {</span><span class="s3">\n    </span><span class="s1">tag: boolean</span><span class="s3">\n    </span><span class="s1">cookie: boolean</span><span class="s3">\n    </span><span class="s1">paths: string[]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function fetchServerAction(</span><span class="s3">\n  </span><span class="s1">state: ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">nextUrl: ReadonlyReducerState['nextUrl'],</span><span class="s3">\n  </span><span class="s1">{ actionId, actionArgs }: ServerActionAction</span><span class="s3">\n</span><span class="s1">): Promise&lt;FetchServerActionResult&gt; {</span><span class="s3">\n  </span><span class="s1">const temporaryReferences = createTemporaryReferenceSet()</span><span class="s3">\n  </span><span class="s1">const info = extractInfoFromServerReferenceId(actionId)</span><span class="s3">\n\n  </span><span class="s1">// TODO: Currently, we're only omitting unused args for the experimental </span><span class="s3">\&quot;</span><span class="s1">use</span><span class="s3">\n  </span><span class="s1">// cache</span><span class="s3">\&quot; </span><span class="s1">functions. Once the server reference info byte feature is stable, we</span><span class="s3">\n  </span><span class="s1">// should apply this to server actions as well.</span><span class="s3">\n  </span><span class="s1">const usedArgs =</span><span class="s3">\n    </span><span class="s1">info.type === 'use-cache' ? omitUnusedArgs(actionArgs, info) : actionArgs</span><span class="s3">\n\n  </span><span class="s1">const body = await encodeReply(usedArgs, { temporaryReferences })</span><span class="s3">\n\n  </span><span class="s1">const res = await fetch(state.canonicalUrl, {</span><span class="s3">\n    </span><span class="s1">method: 'POST',</span><span class="s3">\n    </span><span class="s1">headers: {</span><span class="s3">\n      </span><span class="s1">Accept: RSC_CONTENT_TYPE_HEADER,</span><span class="s3">\n      </span><span class="s1">[ACTION_HEADER]: actionId,</span><span class="s3">\n      </span><span class="s1">[NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(</span><span class="s3">\n        </span><span class="s1">state.tree</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">...(process.env.NEXT_DEPLOYMENT_ID</span><span class="s3">\n        </span><span class="s1">? {</span><span class="s3">\n            </span><span class="s1">'x-deployment-id': process.env.NEXT_DEPLOYMENT_ID,</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">: {}),</span><span class="s3">\n      </span><span class="s1">...(nextUrl</span><span class="s3">\n        </span><span class="s1">? {</span><span class="s3">\n            </span><span class="s1">[NEXT_URL]: nextUrl,</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">: {}),</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">// Handle server actions that the server didn't recognize.</span><span class="s3">\n  </span><span class="s1">const unrecognizedActionHeader = res.headers.get(NEXT_ACTION_NOT_FOUND_HEADER)</span><span class="s3">\n  </span><span class="s1">if (unrecognizedActionHeader === '1') {</span><span class="s3">\n    </span><span class="s1">throw new UnrecognizedActionError(</span><span class="s3">\n      </span><span class="s1">`Server Action </span><span class="s3">\&quot;</span><span class="s1">${actionId}</span><span class="s3">\&quot; </span><span class="s1">was not found on the server. </span><span class="s3">\\</span><span class="s1">nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const redirectHeader = res.headers.get('x-action-redirect')</span><span class="s3">\n  </span><span class="s1">const [location, _redirectType] = redirectHeader?.split(';') || []</span><span class="s3">\n  </span><span class="s1">let redirectType: RedirectType | undefined</span><span class="s3">\n  </span><span class="s1">switch (_redirectType) {</span><span class="s3">\n    </span><span class="s1">case 'push':</span><span class="s3">\n      </span><span class="s1">redirectType = RedirectType.push</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case 'replace':</span><span class="s3">\n      </span><span class="s1">redirectType = RedirectType.replace</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">redirectType = undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const isPrerender = !!res.headers.get(NEXT_IS_PRERENDER_HEADER)</span><span class="s3">\n  </span><span class="s1">let revalidatedParts: FetchServerActionResult['revalidatedParts']</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const revalidatedHeader = JSON.parse(</span><span class="s3">\n      </span><span class="s1">res.headers.get('x-action-revalidated') || '[[],0,0]'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">revalidatedParts = {</span><span class="s3">\n      </span><span class="s1">paths: revalidatedHeader[0] || [],</span><span class="s3">\n      </span><span class="s1">tag: !!revalidatedHeader[1],</span><span class="s3">\n      </span><span class="s1">cookie: revalidatedHeader[2],</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} catch (e) {</span><span class="s3">\n    </span><span class="s1">revalidatedParts = NO_REVALIDATED_PARTS</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const redirectLocation = location</span><span class="s3">\n    </span><span class="s1">? assignLocation(</span><span class="s3">\n        </span><span class="s1">location,</span><span class="s3">\n        </span><span class="s1">new URL(state.canonicalUrl, window.location.href)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n\n  </span><span class="s1">const contentType = res.headers.get('content-type')</span><span class="s3">\n  </span><span class="s1">const isRscResponse = !!(</span><span class="s3">\n    </span><span class="s1">contentType &amp;&amp; contentType.startsWith(RSC_CONTENT_TYPE_HEADER)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// Handle invalid server action responses.</span><span class="s3">\n  </span><span class="s1">// A valid response must have `content-type: text/x-component`, unless it's an external redirect.</span><span class="s3">\n  </span><span class="s1">// (external redirects have an 'x-action-redirect' header, but the body is an empty 'text/plain')</span><span class="s3">\n  </span><span class="s1">if (!isRscResponse &amp;&amp; !redirectLocation) {</span><span class="s3">\n    </span><span class="s1">// The server can respond with a text/plain error message, but we'll fallback to something generic</span><span class="s3">\n    </span><span class="s1">// if there isn't one.</span><span class="s3">\n    </span><span class="s1">const message =</span><span class="s3">\n      </span><span class="s1">res.status &gt;= 400 &amp;&amp; contentType === 'text/plain'</span><span class="s3">\n        </span><span class="s1">? await res.text()</span><span class="s3">\n        </span><span class="s1">: 'An unexpected response was received from the server.'</span><span class="s3">\n\n    </span><span class="s1">throw new Error(message)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let actionResult: FetchServerActionResult['actionResult']</span><span class="s3">\n  </span><span class="s1">let actionFlightData: FetchServerActionResult['actionFlightData']</span><span class="s3">\n  </span><span class="s1">if (isRscResponse) {</span><span class="s3">\n    </span><span class="s1">const response: ActionFlightResponse = await createFromFetch(</span><span class="s3">\n      </span><span class="s1">Promise.resolve(res),</span><span class="s3">\n      </span><span class="s1">{ callServer, findSourceMapURL, temporaryReferences }</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">// An internal redirect can send an RSC response, but does not have a useful `actionResult`.</span><span class="s3">\n    </span><span class="s1">actionResult = redirectLocation ? undefined : response.a</span><span class="s3">\n    </span><span class="s1">actionFlightData = normalizeFlightData(response.f)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// An external redirect doesn't contain RSC data.</span><span class="s3">\n    </span><span class="s1">actionResult = undefined</span><span class="s3">\n    </span><span class="s1">actionFlightData = undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">actionResult,</span><span class="s3">\n    </span><span class="s1">actionFlightData,</span><span class="s3">\n    </span><span class="s1">redirectLocation,</span><span class="s3">\n    </span><span class="s1">redirectType,</span><span class="s3">\n    </span><span class="s1">revalidatedParts,</span><span class="s3">\n    </span><span class="s1">isPrerender,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const NO_REVALIDATED_PARTS = {</span><span class="s3">\n  </span><span class="s1">paths: [],</span><span class="s3">\n  </span><span class="s1">tag: false,</span><span class="s3">\n  </span><span class="s1">cookie: false,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* This reducer is responsible for calling the server action and processing any side-effects from the server action.</span><span class="s3">\n </span><span class="s1">* It does not mutate the state by itself but rather delegates to other reducers to do the actual mutation.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function serverActionReducer(</span><span class="s3">\n  </span><span class="s1">state: ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">action: ServerActionAction</span><span class="s3">\n</span><span class="s1">): ReducerState {</span><span class="s3">\n  </span><span class="s1">const { resolve, reject } = action</span><span class="s3">\n  </span><span class="s1">const mutable: ServerActionMutable = {}</span><span class="s3">\n\n  </span><span class="s1">let currentTree = state.tree</span><span class="s3">\n\n  </span><span class="s1">mutable.preserveCustomHistoryState = false</span><span class="s3">\n\n  </span><span class="s1">// only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.</span><span class="s3">\n  </span><span class="s1">// If the route has been intercepted, the action should be as well.</span><span class="s3">\n  </span><span class="s1">// Otherwise the server action might be intercepted with the wrong action id</span><span class="s3">\n  </span><span class="s1">// (ie, one that corresponds with the intercepted route)</span><span class="s3">\n  </span><span class="s1">const nextUrl =</span><span class="s3">\n    </span><span class="s1">state.nextUrl &amp;&amp; hasInterceptionRouteInCurrentTree(state.tree)</span><span class="s3">\n      </span><span class="s1">? state.nextUrl</span><span class="s3">\n      </span><span class="s1">: null</span><span class="s3">\n\n  </span><span class="s1">const navigatedAt = Date.now()</span><span class="s3">\n\n  </span><span class="s1">return fetchServerAction(state, nextUrl, action).then(</span><span class="s3">\n    </span><span class="s1">async ({</span><span class="s3">\n      </span><span class="s1">actionResult,</span><span class="s3">\n      </span><span class="s1">actionFlightData: flightData,</span><span class="s3">\n      </span><span class="s1">redirectLocation,</span><span class="s3">\n      </span><span class="s1">redirectType,</span><span class="s3">\n      </span><span class="s1">isPrerender,</span><span class="s3">\n      </span><span class="s1">revalidatedParts,</span><span class="s3">\n    </span><span class="s1">}) =&gt; {</span><span class="s3">\n      </span><span class="s1">let redirectHref: string | undefined</span><span class="s3">\n\n      </span><span class="s1">// honor the redirect type instead of defaulting to push in case of server actions.</span><span class="s3">\n      </span><span class="s1">if (redirectLocation) {</span><span class="s3">\n        </span><span class="s1">if (redirectType === RedirectType.replace) {</span><span class="s3">\n          </span><span class="s1">state.pushRef.pendingPush = false</span><span class="s3">\n          </span><span class="s1">mutable.pendingPush = false</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">state.pushRef.pendingPush = true</span><span class="s3">\n          </span><span class="s1">mutable.pendingPush = true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">redirectHref = createHrefFromUrl(redirectLocation, false)</span><span class="s3">\n        </span><span class="s1">mutable.canonicalUrl = redirectHref</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (!flightData) {</span><span class="s3">\n        </span><span class="s1">resolve(actionResult)</span><span class="s3">\n\n        </span><span class="s1">// If there is a redirect but no flight data we need to do a mpaNavigation.</span><span class="s3">\n        </span><span class="s1">if (redirectLocation) {</span><span class="s3">\n          </span><span class="s1">return handleExternalUrl(</span><span class="s3">\n            </span><span class="s1">state,</span><span class="s3">\n            </span><span class="s1">mutable,</span><span class="s3">\n            </span><span class="s1">redirectLocation.href,</span><span class="s3">\n            </span><span class="s1">state.pushRef.pendingPush</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return state</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (typeof flightData === 'string') {</span><span class="s3">\n        </span><span class="s1">// Handle case when navigating to page in `pages` from `app`</span><span class="s3">\n        </span><span class="s1">resolve(actionResult)</span><span class="s3">\n\n        </span><span class="s1">return handleExternalUrl(</span><span class="s3">\n          </span><span class="s1">state,</span><span class="s3">\n          </span><span class="s1">mutable,</span><span class="s3">\n          </span><span class="s1">flightData,</span><span class="s3">\n          </span><span class="s1">state.pushRef.pendingPush</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const actionRevalidated =</span><span class="s3">\n        </span><span class="s1">revalidatedParts.paths.length &gt; 0 ||</span><span class="s3">\n        </span><span class="s1">revalidatedParts.tag ||</span><span class="s3">\n        </span><span class="s1">revalidatedParts.cookie</span><span class="s3">\n\n      </span><span class="s1">for (const normalizedFlightData of flightData) {</span><span class="s3">\n        </span><span class="s1">const {</span><span class="s3">\n          </span><span class="s1">tree: treePatch,</span><span class="s3">\n          </span><span class="s1">seedData: cacheNodeSeedData,</span><span class="s3">\n          </span><span class="s1">head,</span><span class="s3">\n          </span><span class="s1">isRootRender,</span><span class="s3">\n        </span><span class="s1">} = normalizedFlightData</span><span class="s3">\n\n        </span><span class="s1">if (!isRootRender) {</span><span class="s3">\n          </span><span class="s1">// TODO-APP: handle this case better</span><span class="s3">\n          </span><span class="s1">console.log('SERVER ACTION APPLY FAILED')</span><span class="s3">\n          </span><span class="s1">resolve(actionResult)</span><span class="s3">\n\n          </span><span class="s1">return state</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Given the path can only have two items the items are only the router state and rsc for the root.</span><span class="s3">\n        </span><span class="s1">const newTree = applyRouterStatePatchToTree(</span><span class="s3">\n          </span><span class="s1">// TODO-APP: remove ''</span><span class="s3">\n          </span><span class="s1">[''],</span><span class="s3">\n          </span><span class="s1">currentTree,</span><span class="s3">\n          </span><span class="s1">treePatch,</span><span class="s3">\n          </span><span class="s1">redirectHref ? redirectHref : state.canonicalUrl</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">if (newTree === null) {</span><span class="s3">\n          </span><span class="s1">resolve(actionResult)</span><span class="s3">\n\n          </span><span class="s1">return handleSegmentMismatch(state, action, treePatch)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (isNavigatingToNewRootLayout(currentTree, newTree)) {</span><span class="s3">\n          </span><span class="s1">resolve(actionResult)</span><span class="s3">\n\n          </span><span class="s1">return handleExternalUrl(</span><span class="s3">\n            </span><span class="s1">state,</span><span class="s3">\n            </span><span class="s1">mutable,</span><span class="s3">\n            </span><span class="s1">redirectHref || state.canonicalUrl,</span><span class="s3">\n            </span><span class="s1">state.pushRef.pendingPush</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// The server sent back RSC data for the server action, so we need to apply it to the cache.</span><span class="s3">\n        </span><span class="s1">if (cacheNodeSeedData !== null) {</span><span class="s3">\n          </span><span class="s1">const rsc = cacheNodeSeedData[1]</span><span class="s3">\n          </span><span class="s1">const cache: CacheNode = createEmptyCacheNode()</span><span class="s3">\n          </span><span class="s1">cache.rsc = rsc</span><span class="s3">\n          </span><span class="s1">cache.prefetchRsc = null</span><span class="s3">\n          </span><span class="s1">cache.loading = cacheNodeSeedData[3]</span><span class="s3">\n          </span><span class="s1">fillLazyItemsTillLeafWithHead(</span><span class="s3">\n            </span><span class="s1">navigatedAt,</span><span class="s3">\n            </span><span class="s1">cache,</span><span class="s3">\n            </span><span class="s1">// Existing cache is not passed in as server actions have to invalidate the entire cache.</span><span class="s3">\n            </span><span class="s1">undefined,</span><span class="s3">\n            </span><span class="s1">treePatch,</span><span class="s3">\n            </span><span class="s1">cacheNodeSeedData,</span><span class="s3">\n            </span><span class="s1">head,</span><span class="s3">\n            </span><span class="s1">undefined</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">mutable.cache = cache</span><span class="s3">\n          </span><span class="s1">if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {</span><span class="s3">\n            </span><span class="s1">revalidateEntireCache(state.nextUrl, newTree)</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">mutable.prefetchCache = new Map()</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (actionRevalidated) {</span><span class="s3">\n            </span><span class="s1">await refreshInactiveParallelSegments({</span><span class="s3">\n              </span><span class="s1">navigatedAt,</span><span class="s3">\n              </span><span class="s1">state,</span><span class="s3">\n              </span><span class="s1">updatedTree: newTree,</span><span class="s3">\n              </span><span class="s1">updatedCache: cache,</span><span class="s3">\n              </span><span class="s1">includeNextUrl: Boolean(nextUrl),</span><span class="s3">\n              </span><span class="s1">canonicalUrl: mutable.canonicalUrl || state.canonicalUrl,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">mutable.patchedTree = newTree</span><span class="s3">\n        </span><span class="s1">currentTree = newTree</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (redirectLocation &amp;&amp; redirectHref) {</span><span class="s3">\n        </span><span class="s1">if (!process.env.__NEXT_CLIENT_SEGMENT_CACHE &amp;&amp; !actionRevalidated) {</span><span class="s3">\n          </span><span class="s1">// Because the RedirectBoundary will trigger a navigation, we need to seed the prefetch cache</span><span class="s3">\n          </span><span class="s1">// with the FlightData that we got from the server action for the target page, so that it's</span><span class="s3">\n          </span><span class="s1">// available when the page is navigated to and doesn't need to be re-fetched.</span><span class="s3">\n          </span><span class="s1">// We only do this if the server action didn't revalidate any data, as in that case the</span><span class="s3">\n          </span><span class="s1">// client cache will be cleared and the data will be re-fetched anyway.</span><span class="s3">\n          </span><span class="s1">// NOTE: We don't do this in the Segment Cache implementation.</span><span class="s3">\n          </span><span class="s1">// Dynamic data should never be placed into the cache, unless it's</span><span class="s3">\n          </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">converted</span><span class="s3">\&quot; </span><span class="s1">to static data using &lt;Link prefetch={true}&gt;. What we</span><span class="s3">\n          </span><span class="s1">// do instead is re-prefetch links and forms whenever the cache is</span><span class="s3">\n          </span><span class="s1">// invalidated.</span><span class="s3">\n          </span><span class="s1">createSeededPrefetchCacheEntry({</span><span class="s3">\n            </span><span class="s1">url: redirectLocation,</span><span class="s3">\n            </span><span class="s1">data: {</span><span class="s3">\n              </span><span class="s1">flightData,</span><span class="s3">\n              </span><span class="s1">canonicalUrl: undefined,</span><span class="s3">\n              </span><span class="s1">couldBeIntercepted: false,</span><span class="s3">\n              </span><span class="s1">prerendered: false,</span><span class="s3">\n              </span><span class="s1">postponed: false,</span><span class="s3">\n              </span><span class="s1">// TODO: We should be able to set this if the server action</span><span class="s3">\n              </span><span class="s1">// returned a fully static response.</span><span class="s3">\n              </span><span class="s1">staleTime: -1,</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">tree: state.tree,</span><span class="s3">\n            </span><span class="s1">prefetchCache: state.prefetchCache,</span><span class="s3">\n            </span><span class="s1">nextUrl: state.nextUrl,</span><span class="s3">\n            </span><span class="s1">kind: isPrerender ? PrefetchKind.FULL : PrefetchKind.AUTO,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">mutable.prefetchCache = state.prefetchCache</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// If the action triggered a redirect, the action promise will be rejected with</span><span class="s3">\n        </span><span class="s1">// a redirect so that it's handled by RedirectBoundary as we won't have a valid</span><span class="s3">\n        </span><span class="s1">// action result to resolve the promise with. This will effectively reset the state of</span><span class="s3">\n        </span><span class="s1">// the component that called the action as the error boundary will remount the tree.</span><span class="s3">\n        </span><span class="s1">// The status code doesn't matter here as the action handler will have already sent</span><span class="s3">\n        </span><span class="s1">// a response with the correct status code.</span><span class="s3">\n        </span><span class="s1">reject(</span><span class="s3">\n          </span><span class="s1">getRedirectError(</span><span class="s3">\n            </span><span class="s1">hasBasePath(redirectHref)</span><span class="s3">\n              </span><span class="s1">? removeBasePath(redirectHref)</span><span class="s3">\n              </span><span class="s1">: redirectHref,</span><span class="s3">\n            </span><span class="s1">redirectType || RedirectType.push</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">resolve(actionResult)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return handleMutable(state, mutable)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">(e: any) =&gt; {</span><span class="s3">\n      </span><span class="s1">// When the server action is rejected we don't update the state and instead call the reject handler of the promise.</span><span class="s3">\n      </span><span class="s1">reject(e)</span><span class="s3">\n\n      </span><span class="s1">return state</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;serverActionReducer&quot;</span><span class="s0">,</span><span class="s1">&quot;createFromFetch&quot;</span><span class="s0">,</span><span class="s1">&quot;createFromFetchBrowser&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchServerAction&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;actionId&quot;</span><span class="s0">,</span><span class="s1">&quot;actionArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;temporaryReferences&quot;</span><span class="s0">,</span><span class="s1">&quot;createTemporaryReferenceSet&quot;</span><span class="s0">,</span><span class="s1">&quot;info&quot;</span><span class="s0">,</span><span class="s1">&quot;extractInfoFromServerReferenceId&quot;</span><span class="s0">,</span><span class="s1">&quot;usedArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;omitUnusedArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeReply&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;fetch&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;Accept&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_CONTENT_TYPE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_STATE_TREE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;prepareFlightRouterStateForRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_DEPLOYMENT_ID&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_URL&quot;</span><span class="s0">,</span><span class="s1">&quot;unrecognizedActionHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ACTION_NOT_FOUND_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;UnrecognizedActionError&quot;</span><span class="s0">,</span><span class="s1">&quot;redirectHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;_redirectType&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;redirectType&quot;</span><span class="s0">,</span><span class="s1">&quot;RedirectType&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrerender&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_IS_PRERENDER_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidatedParts&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidatedHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;paths&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;cookie&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;NO_REVALIDATED_PARTS&quot;</span><span class="s0">,</span><span class="s1">&quot;redirectLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;assignLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;contentType&quot;</span><span class="s0">,</span><span class="s1">&quot;isRscResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;text&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;actionResult&quot;</span><span class="s0">,</span><span class="s1">&quot;actionFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;response&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;callServer&quot;</span><span class="s0">,</span><span class="s1">&quot;findSourceMapURL&quot;</span><span class="s0">,</span><span class="s1">&quot;a&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;f&quot;</span><span class="s0">,</span><span class="s1">&quot;action&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;mutable&quot;</span><span class="s0">,</span><span class="s1">&quot;currentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;preserveCustomHistoryState&quot;</span><span class="s0">,</span><span class="s1">&quot;hasInterceptionRouteInCurrentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;navigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;redirectHref&quot;</span><span class="s0">,</span><span class="s1">&quot;pushRef&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingPush&quot;</span><span class="s0">,</span><span class="s1">&quot;createHrefFromUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;handleExternalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;actionRevalidated&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;treePatch&quot;</span><span class="s0">,</span><span class="s1">&quot;seedData&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheNodeSeedData&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootRender&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;log&quot;</span><span class="s0">,</span><span class="s1">&quot;newTree&quot;</span><span class="s0">,</span><span class="s1">&quot;applyRouterStatePatchToTree&quot;</span><span class="s0">,</span><span class="s1">&quot;handleSegmentMismatch&quot;</span><span class="s0">,</span><span class="s1">&quot;isNavigatingToNewRootLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;rsc&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;createEmptyCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;fillLazyItemsTillLeafWithHead&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CLIENT_SEGMENT_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateEntireCache&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;refreshInactiveParallelSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedTree&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedCache&quot;</span><span class="s0">,</span><span class="s1">&quot;includeNextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">,</span><span class="s1">&quot;patchedTree&quot;</span><span class="s0">,</span><span class="s1">&quot;createSeededPrefetchCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;couldBeIntercepted&quot;</span><span class="s0">,</span><span class="s1">&quot;prerendered&quot;</span><span class="s0">,</span><span class="s1">&quot;postponed&quot;</span><span class="s0">,</span><span class="s1">&quot;staleTime&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchKind&quot;</span><span class="s0">,</span><span class="s1">&quot;FULL&quot;</span><span class="s0">,</span><span class="s1">&quot;AUTO&quot;</span><span class="s0">,</span><span class="s1">&quot;getRedirectError&quot;</span><span class="s0">,</span><span class="s1">&quot;hasBasePath&quot;</span><span class="s0">,</span><span class="s1">&quot;removeBasePath&quot;</span><span class="s0">,</span><span class="s1">&quot;handleMutable&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">9198</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/router-reducer.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">ACTION_NAVIGATE,</span><span class="s3">\n  </span><span class="s1">ACTION_SERVER_PATCH,</span><span class="s3">\n  </span><span class="s1">ACTION_RESTORE,</span><span class="s3">\n  </span><span class="s1">ACTION_REFRESH,</span><span class="s3">\n  </span><span class="s1">ACTION_PREFETCH,</span><span class="s3">\n  </span><span class="s1">ACTION_HMR_REFRESH,</span><span class="s3">\n  </span><span class="s1">ACTION_SERVER_ACTION,</span><span class="s3">\n</span><span class="s1">} from './router-reducer-types'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">ReducerActions,</span><span class="s3">\n  </span><span class="s1">ReducerState,</span><span class="s3">\n  </span><span class="s1">ReadonlyReducerState,</span><span class="s3">\n</span><span class="s1">} from './router-reducer-types'</span><span class="s3">\n</span><span class="s1">import { navigateReducer } from './reducers/navigate-reducer'</span><span class="s3">\n</span><span class="s1">import { serverPatchReducer } from './reducers/server-patch-reducer'</span><span class="s3">\n</span><span class="s1">import { restoreReducer } from './reducers/restore-reducer'</span><span class="s3">\n</span><span class="s1">import { refreshReducer } from './reducers/refresh-reducer'</span><span class="s3">\n</span><span class="s1">import { prefetchReducer } from './reducers/prefetch-reducer'</span><span class="s3">\n</span><span class="s1">import { hmrRefreshReducer } from './reducers/hmr-refresh-reducer'</span><span class="s3">\n</span><span class="s1">import { serverActionReducer } from './reducers/server-action-reducer'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Reducer that handles the app-router state updates.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function clientReducer(</span><span class="s3">\n  </span><span class="s1">state: ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">action: ReducerActions</span><span class="s3">\n</span><span class="s1">): ReducerState {</span><span class="s3">\n  </span><span class="s1">switch (action.type) {</span><span class="s3">\n    </span><span class="s1">case ACTION_NAVIGATE: {</span><span class="s3">\n      </span><span class="s1">return navigateReducer(state, action)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case ACTION_SERVER_PATCH: {</span><span class="s3">\n      </span><span class="s1">return serverPatchReducer(state, action)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case ACTION_RESTORE: {</span><span class="s3">\n      </span><span class="s1">return restoreReducer(state, action)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case ACTION_REFRESH: {</span><span class="s3">\n      </span><span class="s1">return refreshReducer(state, action)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case ACTION_HMR_REFRESH: {</span><span class="s3">\n      </span><span class="s1">return hmrRefreshReducer(state, action)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case ACTION_PREFETCH: {</span><span class="s3">\n      </span><span class="s1">return prefetchReducer(state, action)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case ACTION_SERVER_ACTION: {</span><span class="s3">\n      </span><span class="s1">return serverActionReducer(state, action)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// This case should never be hit as dispatch is strongly typed.</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">throw new Error('Unknown action')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function serverReducer(</span><span class="s3">\n  </span><span class="s1">state: ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">_action: ReducerActions</span><span class="s3">\n</span><span class="s1">): ReducerState {</span><span class="s3">\n  </span><span class="s1">return state</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// we don't run the client reducer on the server, so we use a noop function for better tree shaking</span><span class="s3">\n</span><span class="s1">export const reducer =</span><span class="s3">\n  </span><span class="s1">typeof window === 'undefined' ? serverReducer : clientReducer</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;reducer&quot;</span><span class="s0">,</span><span class="s1">&quot;clientReducer&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;action&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_NAVIGATE&quot;</span><span class="s0">,</span><span class="s1">&quot;navigateReducer&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_SERVER_PATCH&quot;</span><span class="s0">,</span><span class="s1">&quot;serverPatchReducer&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_RESTORE&quot;</span><span class="s0">,</span><span class="s1">&quot;restoreReducer&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_REFRESH&quot;</span><span class="s0">,</span><span class="s1">&quot;refreshReducer&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_HMR_REFRESH&quot;</span><span class="s0">,</span><span class="s1">&quot;hmrRefreshReducer&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_PREFETCH&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchReducer&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_SERVER_ACTION&quot;</span><span class="s0">,</span><span class="s1">&quot;serverActionReducer&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;serverReducer&quot;</span><span class="s0">,</span><span class="s1">&quot;_action&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;+BAiEaA,WAAAA;;;eAAAA;;;oCAzDN;iCAMyB;oCACG;gCACJ;gCACA;iCACC;mCACE;qCACE;AAEpC;;CAEC,GACD,SAASC,cACPC,KAA2B,EAC3BC,MAAsB;IAEtB,OAAQA,OAAOC,IAAI;QACjB,KAAKC,oBAAAA,eAAe;YAAE;gBACpB,OAAOC,CAAAA,GAAAA,iBAAAA,eAAe,EAACJ,OAAOC;YAChC;QACA,KAAKI,oBAAAA,mBAAmB;YAAE;gBACxB,OAAOC,CAAAA,GAAAA,oBAAAA,kBAAkB,EAACN,OAAOC;YACnC;QACA,KAAKM,oBAAAA,cAAc;YAAE;gBACnB,OAAOC,CAAAA,GAAAA,gBAAAA,cAAc,EAACR,OAAOC;YAC/B;QACA,KAAKQ,oBAAAA,cAAc;YAAE;gBACnB,OAAOC,CAAAA,GAAAA,gBAAAA,cAAc,EAACV,OAAOC;YAC/B;QACA,KAAKU,oBAAAA,kBAAkB;YAAE;gBACvB,OAAOC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACZ,OAAOC;YAClC;QACA,KAAKY,oBAAAA,eAAe;YAAE;gBACpB,OAAOC,CAAAA,GAAAA,iBAAAA,eAAe,EAACd,OAAOC;YAChC;QACA,KAAKc,oBAAAA,oBAAoB;YAAE;gBACzB,OAAOC,CAAAA,GAAAA,qBAAAA,mBAAmB,EAAChB,OAAOC;YACpC;QACA,+DAA+D;QAC/D;YACE,MAAM,OAAA,cAA2B,CAA3B,IAAIgB,MAAM,mBAAV,qBAAA;uBAAA;4BAAA;8BAAA;YAA0B;IACpC;AACF;AAEA,SAASC,cACPlB,KAA2B,EAC3BmB,OAAuB;IAEvB,OAAOnB;AACT;AAGO,MAAMF,UACX,OAAOsB,WAAW,cAAcF,gBAAgBnB&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">9271</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/app-router-instance.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">type AppRouterState,</span><span class="s3">\n  </span><span class="s1">type ReducerActions,</span><span class="s3">\n  </span><span class="s1">type ReducerState,</span><span class="s3">\n  </span><span class="s1">ACTION_REFRESH,</span><span class="s3">\n  </span><span class="s1">ACTION_SERVER_ACTION,</span><span class="s3">\n  </span><span class="s1">ACTION_NAVIGATE,</span><span class="s3">\n  </span><span class="s1">ACTION_RESTORE,</span><span class="s3">\n  </span><span class="s1">type NavigateAction,</span><span class="s3">\n  </span><span class="s1">ACTION_HMR_REFRESH,</span><span class="s3">\n  </span><span class="s1">PrefetchKind,</span><span class="s3">\n  </span><span class="s1">ACTION_PREFETCH,</span><span class="s3">\n</span><span class="s1">} from './router-reducer/router-reducer-types'</span><span class="s3">\n</span><span class="s1">import { reducer } from './router-reducer/router-reducer'</span><span class="s3">\n</span><span class="s1">import { startTransition } from 'react'</span><span class="s3">\n</span><span class="s1">import { isThenable } from '../../shared/lib/is-thenable'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">FetchStrategy,</span><span class="s3">\n  </span><span class="s1">prefetch as prefetchWithSegmentCache,</span><span class="s3">\n  </span><span class="s1">type PrefetchTaskFetchStrategy,</span><span class="s3">\n</span><span class="s1">} from './segment-cache'</span><span class="s3">\n</span><span class="s1">import { dispatchAppRouterAction } from './use-action-queue'</span><span class="s3">\n</span><span class="s1">import { addBasePath } from '../add-base-path'</span><span class="s3">\n</span><span class="s1">import { createPrefetchURL, isExternalURL } from './app-router'</span><span class="s3">\n</span><span class="s1">import { prefetchReducer } from './router-reducer/reducers/prefetch-reducer'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">AppRouterInstance,</span><span class="s3">\n  </span><span class="s1">NavigateOptions,</span><span class="s3">\n  </span><span class="s1">PrefetchOptions,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { setLinkForCurrentNavigation, type LinkInstance } from './links'</span><span class="s3">\n</span><span class="s1">import type { FlightRouterState } from '../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import type { ClientInstrumentationHooks } from '../app-index'</span><span class="s3">\n</span><span class="s1">import type { GlobalErrorComponent } from './builtin/global-error'</span><span class="s3">\n\n</span><span class="s1">export type DispatchStatePromise = React.Dispatch&lt;ReducerState&gt;</span><span class="s3">\n\n</span><span class="s1">export type AppRouterActionQueue = {</span><span class="s3">\n  </span><span class="s1">state: AppRouterState</span><span class="s3">\n  </span><span class="s1">dispatch: (payload: ReducerActions, setState: DispatchStatePromise) =&gt; void</span><span class="s3">\n  </span><span class="s1">action: (state: AppRouterState, action: ReducerActions) =&gt; ReducerState</span><span class="s3">\n\n  </span><span class="s1">onRouterTransitionStart:</span><span class="s3">\n    </span><span class="s1">| ((url: string, type: 'push' | 'replace' | 'traverse') =&gt; void)</span><span class="s3">\n    </span><span class="s1">| null</span><span class="s3">\n\n  </span><span class="s1">pending: ActionQueueNode | null</span><span class="s3">\n  </span><span class="s1">needsRefresh?: boolean</span><span class="s3">\n  </span><span class="s1">last: ActionQueueNode | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type GlobalErrorState = [</span><span class="s3">\n  </span><span class="s1">GlobalError: GlobalErrorComponent,</span><span class="s3">\n  </span><span class="s1">styles: React.ReactNode,</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export type ActionQueueNode = {</span><span class="s3">\n  </span><span class="s1">payload: ReducerActions</span><span class="s3">\n  </span><span class="s1">next: ActionQueueNode | null</span><span class="s3">\n  </span><span class="s1">resolve: (value: ReducerState) =&gt; void</span><span class="s3">\n  </span><span class="s1">reject: (err: Error) =&gt; void</span><span class="s3">\n  </span><span class="s1">discarded?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function runRemainingActions(</span><span class="s3">\n  </span><span class="s1">actionQueue: AppRouterActionQueue,</span><span class="s3">\n  </span><span class="s1">setState: DispatchStatePromise</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (actionQueue.pending !== null) {</span><span class="s3">\n    </span><span class="s1">actionQueue.pending = actionQueue.pending.next</span><span class="s3">\n    </span><span class="s1">if (actionQueue.pending !== null) {</span><span class="s3">\n      </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-use-before-define</span><span class="s3">\n      </span><span class="s1">runAction({</span><span class="s3">\n        </span><span class="s1">actionQueue,</span><span class="s3">\n        </span><span class="s1">action: actionQueue.pending,</span><span class="s3">\n        </span><span class="s1">setState,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// No more actions are pending, check if a refresh is needed</span><span class="s3">\n      </span><span class="s1">if (actionQueue.needsRefresh) {</span><span class="s3">\n        </span><span class="s1">actionQueue.needsRefresh = false</span><span class="s3">\n        </span><span class="s1">actionQueue.dispatch(</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">type: ACTION_REFRESH,</span><span class="s3">\n            </span><span class="s1">origin: window.location.origin,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">setState</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function runAction({</span><span class="s3">\n  </span><span class="s1">actionQueue,</span><span class="s3">\n  </span><span class="s1">action,</span><span class="s3">\n  </span><span class="s1">setState,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">actionQueue: AppRouterActionQueue</span><span class="s3">\n  </span><span class="s1">action: ActionQueueNode</span><span class="s3">\n  </span><span class="s1">setState: DispatchStatePromise</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">const prevState = actionQueue.state</span><span class="s3">\n\n  </span><span class="s1">actionQueue.pending = action</span><span class="s3">\n\n  </span><span class="s1">const payload = action.payload</span><span class="s3">\n  </span><span class="s1">const actionResult = actionQueue.action(prevState, payload)</span><span class="s3">\n\n  </span><span class="s1">function handleResult(nextState: AppRouterState) {</span><span class="s3">\n    </span><span class="s1">// if we discarded this action, the state should also be discarded</span><span class="s3">\n    </span><span class="s1">if (action.discarded) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">actionQueue.state = nextState</span><span class="s3">\n\n    </span><span class="s1">runRemainingActions(actionQueue, setState)</span><span class="s3">\n    </span><span class="s1">action.resolve(nextState)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// if the action is a promise, set up a callback to resolve it</span><span class="s3">\n  </span><span class="s1">if (isThenable(actionResult)) {</span><span class="s3">\n    </span><span class="s1">actionResult.then(handleResult, (err) =&gt; {</span><span class="s3">\n      </span><span class="s1">runRemainingActions(actionQueue, setState)</span><span class="s3">\n      </span><span class="s1">action.reject(err)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">handleResult(actionResult)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function dispatchAction(</span><span class="s3">\n  </span><span class="s1">actionQueue: AppRouterActionQueue,</span><span class="s3">\n  </span><span class="s1">payload: ReducerActions,</span><span class="s3">\n  </span><span class="s1">setState: DispatchStatePromise</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let resolvers: {</span><span class="s3">\n    </span><span class="s1">resolve: (value: ReducerState) =&gt; void</span><span class="s3">\n    </span><span class="s1">reject: (reason: any) =&gt; void</span><span class="s3">\n  </span><span class="s1">} = { resolve: setState, reject: () =&gt; {} }</span><span class="s3">\n\n  </span><span class="s1">// most of the action types are async with the exception of restore</span><span class="s3">\n  </span><span class="s1">// it's important that restore is handled quickly since it's fired on the popstate event</span><span class="s3">\n  </span><span class="s1">// and we don't want to add any delay on a back/forward nav</span><span class="s3">\n  </span><span class="s1">// this only creates a promise for the async actions</span><span class="s3">\n  </span><span class="s1">if (payload.type !== ACTION_RESTORE) {</span><span class="s3">\n    </span><span class="s1">// Create the promise and assign the resolvers to the object.</span><span class="s3">\n    </span><span class="s1">const deferredPromise = new Promise&lt;AppRouterState&gt;((resolve, reject) =&gt; {</span><span class="s3">\n      </span><span class="s1">resolvers = { resolve, reject }</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">startTransition(() =&gt; {</span><span class="s3">\n      </span><span class="s1">// we immediately notify React of the pending promise -- the resolver is attached to the action node</span><span class="s3">\n      </span><span class="s1">// and will be called when the associated action promise resolves</span><span class="s3">\n      </span><span class="s1">setState(deferredPromise)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const newAction: ActionQueueNode = {</span><span class="s3">\n    </span><span class="s1">payload,</span><span class="s3">\n    </span><span class="s1">next: null,</span><span class="s3">\n    </span><span class="s1">resolve: resolvers.resolve,</span><span class="s3">\n    </span><span class="s1">reject: resolvers.reject,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Check if the queue is empty</span><span class="s3">\n  </span><span class="s1">if (actionQueue.pending === null) {</span><span class="s3">\n    </span><span class="s1">// The queue is empty, so add the action and start it immediately</span><span class="s3">\n    </span><span class="s1">// Mark this action as the last in the queue</span><span class="s3">\n    </span><span class="s1">actionQueue.last = newAction</span><span class="s3">\n\n    </span><span class="s1">runAction({</span><span class="s3">\n      </span><span class="s1">actionQueue,</span><span class="s3">\n      </span><span class="s1">action: newAction,</span><span class="s3">\n      </span><span class="s1">setState,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">} else if (</span><span class="s3">\n    </span><span class="s1">payload.type === ACTION_NAVIGATE ||</span><span class="s3">\n    </span><span class="s1">payload.type === ACTION_RESTORE</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// Navigations (including back/forward) take priority over any pending actions.</span><span class="s3">\n    </span><span class="s1">// Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.</span><span class="s3">\n    </span><span class="s1">actionQueue.pending.discarded = true</span><span class="s3">\n\n    </span><span class="s1">// The rest of the current queue should still execute after this navigation.</span><span class="s3">\n    </span><span class="s1">// (Note that it can't contain any earlier navigations, because we always put those into `actionQueue.pending` by calling `runAction`)</span><span class="s3">\n    </span><span class="s1">newAction.next = actionQueue.pending.next</span><span class="s3">\n\n    </span><span class="s1">// if the pending action was a server action, mark the queue as needing a refresh once events are processed</span><span class="s3">\n    </span><span class="s1">if (actionQueue.pending.payload.type === ACTION_SERVER_ACTION) {</span><span class="s3">\n      </span><span class="s1">actionQueue.needsRefresh = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">runAction({</span><span class="s3">\n      </span><span class="s1">actionQueue,</span><span class="s3">\n      </span><span class="s1">action: newAction,</span><span class="s3">\n      </span><span class="s1">setState,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// The queue is not empty, so add the action to the end of the queue</span><span class="s3">\n    </span><span class="s1">// It will be started by runRemainingActions after the previous action finishes</span><span class="s3">\n    </span><span class="s1">if (actionQueue.last !== null) {</span><span class="s3">\n      </span><span class="s1">actionQueue.last.next = newAction</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">actionQueue.last = newAction</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">let globalActionQueue: AppRouterActionQueue | null = null</span><span class="s3">\n\n</span><span class="s1">export function createMutableActionQueue(</span><span class="s3">\n  </span><span class="s1">initialState: AppRouterState,</span><span class="s3">\n  </span><span class="s1">instrumentationHooks: ClientInstrumentationHooks | null</span><span class="s3">\n</span><span class="s1">): AppRouterActionQueue {</span><span class="s3">\n  </span><span class="s1">const actionQueue: AppRouterActionQueue = {</span><span class="s3">\n    </span><span class="s1">state: initialState,</span><span class="s3">\n    </span><span class="s1">dispatch: (payload: ReducerActions, setState: DispatchStatePromise) =&gt;</span><span class="s3">\n      </span><span class="s1">dispatchAction(actionQueue, payload, setState),</span><span class="s3">\n    </span><span class="s1">action: async (state: AppRouterState, action: ReducerActions) =&gt; {</span><span class="s3">\n      </span><span class="s1">const result = reducer(state, action)</span><span class="s3">\n      </span><span class="s1">return result</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">pending: null,</span><span class="s3">\n    </span><span class="s1">last: null,</span><span class="s3">\n    </span><span class="s1">onRouterTransitionStart:</span><span class="s3">\n      </span><span class="s1">instrumentationHooks !== null &amp;&amp;</span><span class="s3">\n      </span><span class="s1">typeof instrumentationHooks.onRouterTransitionStart === 'function'</span><span class="s3">\n        </span><span class="s1">? // This profiling hook will be called at the start of every navigation.</span><span class="s3">\n          </span><span class="s1">instrumentationHooks.onRouterTransitionStart</span><span class="s3">\n        </span><span class="s1">: null,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (typeof window !== 'undefined') {</span><span class="s3">\n    </span><span class="s1">// The action queue is lazily created on hydration, but after that point</span><span class="s3">\n    </span><span class="s1">// it doesn't change. So we can store it in a global rather than pass</span><span class="s3">\n    </span><span class="s1">// it around everywhere via props/context.</span><span class="s3">\n    </span><span class="s1">if (globalActionQueue !== null) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'Internal Next.js Error: createMutableActionQueue was called more ' +</span><span class="s3">\n          </span><span class="s1">'than once'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">globalActionQueue = actionQueue</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return actionQueue</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getCurrentAppRouterState(): AppRouterState | null {</span><span class="s3">\n  </span><span class="s1">return globalActionQueue !== null ? globalActionQueue.state : null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getAppRouterActionQueue(): AppRouterActionQueue {</span><span class="s3">\n  </span><span class="s1">if (globalActionQueue === null) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">'Internal Next.js error: Router action dispatched before initialization.'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return globalActionQueue</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getProfilingHookForOnNavigationStart() {</span><span class="s3">\n  </span><span class="s1">if (globalActionQueue !== null) {</span><span class="s3">\n    </span><span class="s1">return globalActionQueue.onRouterTransitionStart</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function dispatchNavigateAction(</span><span class="s3">\n  </span><span class="s1">href: string,</span><span class="s3">\n  </span><span class="s1">navigateType: NavigateAction['navigateType'],</span><span class="s3">\n  </span><span class="s1">shouldScroll: boolean,</span><span class="s3">\n  </span><span class="s1">linkInstanceRef: LinkInstance | null</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">// TODO: This stuff could just go into the reducer. Leaving as-is for now</span><span class="s3">\n  </span><span class="s1">// since we're about to rewrite all the router reducer stuff anyway.</span><span class="s3">\n  </span><span class="s1">const url = new URL(addBasePath(href), location.href)</span><span class="s3">\n  </span><span class="s1">if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {</span><span class="s3">\n    </span><span class="s1">window.next.__pendingUrl = url</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">setLinkForCurrentNavigation(linkInstanceRef)</span><span class="s3">\n\n  </span><span class="s1">const onRouterTransitionStart = getProfilingHookForOnNavigationStart()</span><span class="s3">\n  </span><span class="s1">if (onRouterTransitionStart !== null) {</span><span class="s3">\n    </span><span class="s1">onRouterTransitionStart(href, navigateType)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">dispatchAppRouterAction({</span><span class="s3">\n    </span><span class="s1">type: ACTION_NAVIGATE,</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">isExternalUrl: isExternalURL(url),</span><span class="s3">\n    </span><span class="s1">locationSearch: location.search,</span><span class="s3">\n    </span><span class="s1">shouldScroll,</span><span class="s3">\n    </span><span class="s1">navigateType,</span><span class="s3">\n    </span><span class="s1">allowAliasing: true,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function dispatchTraverseAction(</span><span class="s3">\n  </span><span class="s1">href: string,</span><span class="s3">\n  </span><span class="s1">tree: FlightRouterState | undefined</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const onRouterTransitionStart = getProfilingHookForOnNavigationStart()</span><span class="s3">\n  </span><span class="s1">if (onRouterTransitionStart !== null) {</span><span class="s3">\n    </span><span class="s1">onRouterTransitionStart(href, 'traverse')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">dispatchAppRouterAction({</span><span class="s3">\n    </span><span class="s1">type: ACTION_RESTORE,</span><span class="s3">\n    </span><span class="s1">url: new URL(href),</span><span class="s3">\n    </span><span class="s1">tree,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The app router that is exposed through `useRouter`. These are public API</span><span class="s3">\n </span><span class="s1">* methods. Internal Next.js code should call the lower level methods directly</span><span class="s3">\n </span><span class="s1">* (although there's lots of existing code that doesn't do that).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const publicAppRouterInstance: AppRouterInstance = {</span><span class="s3">\n  </span><span class="s1">back: () =&gt; window.history.back(),</span><span class="s3">\n  </span><span class="s1">forward: () =&gt; window.history.forward(),</span><span class="s3">\n  </span><span class="s1">prefetch: process.env.__NEXT_CLIENT_SEGMENT_CACHE</span><span class="s3">\n    </span><span class="s1">? // Unlike the old implementation, the Segment Cache doesn't store its</span><span class="s3">\n      </span><span class="s1">// data in the router reducer state; it writes into a global mutable</span><span class="s3">\n      </span><span class="s1">// cache. So we don't need to dispatch an action.</span><span class="s3">\n      </span><span class="s1">(href: string, options?: PrefetchOptions) =&gt; {</span><span class="s3">\n        </span><span class="s1">const actionQueue = getAppRouterActionQueue()</span><span class="s3">\n        </span><span class="s1">const prefetchKind = options?.kind ?? PrefetchKind.AUTO</span><span class="s3">\n\n        </span><span class="s1">// We don't currently offer a way to issue a runtime prefetch via `router.prefetch()`.</span><span class="s3">\n        </span><span class="s1">// This will be possible when we update its API to not take a PrefetchKind.</span><span class="s3">\n        </span><span class="s1">let fetchStrategy: PrefetchTaskFetchStrategy</span><span class="s3">\n        </span><span class="s1">switch (prefetchKind) {</span><span class="s3">\n          </span><span class="s1">case PrefetchKind.AUTO: {</span><span class="s3">\n            </span><span class="s1">// We default to PPR. We'll discover whether or not the route supports it with the initial prefetch.</span><span class="s3">\n            </span><span class="s1">fetchStrategy = FetchStrategy.PPR</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">case PrefetchKind.FULL: {</span><span class="s3">\n            </span><span class="s1">fetchStrategy = FetchStrategy.Full</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">case PrefetchKind.TEMPORARY: {</span><span class="s3">\n            </span><span class="s1">// This concept doesn't exist in the segment cache implementation.</span><span class="s3">\n            </span><span class="s1">return</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">default: {</span><span class="s3">\n            </span><span class="s1">prefetchKind satisfies never</span><span class="s3">\n            </span><span class="s1">// Despite typescript thinking that this can't happen,</span><span class="s3">\n            </span><span class="s1">// we might get an unexpected value from user code.</span><span class="s3">\n            </span><span class="s1">// We don't know what they want, but we know they want a prefetch,</span><span class="s3">\n            </span><span class="s1">// so use the default.</span><span class="s3">\n            </span><span class="s1">fetchStrategy = FetchStrategy.PPR</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">prefetchWithSegmentCache(</span><span class="s3">\n          </span><span class="s1">href,</span><span class="s3">\n          </span><span class="s1">actionQueue.state.nextUrl,</span><span class="s3">\n          </span><span class="s1">actionQueue.state.tree,</span><span class="s3">\n          </span><span class="s1">fetchStrategy,</span><span class="s3">\n          </span><span class="s1">options?.onInvalidate ?? null</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">: (href: string, options?: PrefetchOptions) =&gt; {</span><span class="s3">\n        </span><span class="s1">// Use the old prefetch implementation.</span><span class="s3">\n        </span><span class="s1">const actionQueue = getAppRouterActionQueue()</span><span class="s3">\n        </span><span class="s1">const url = createPrefetchURL(href)</span><span class="s3">\n        </span><span class="s1">if (url !== null) {</span><span class="s3">\n          </span><span class="s1">// The prefetch reducer doesn't actually update any state or</span><span class="s3">\n          </span><span class="s1">// trigger a rerender. It just writes to a mutable cache. So we</span><span class="s3">\n          </span><span class="s1">// shouldn't bother calling setState/dispatch; we can just re-run</span><span class="s3">\n          </span><span class="s1">// the reducer directly using the current state.</span><span class="s3">\n          </span><span class="s1">// TODO: Refactor this away from a </span><span class="s3">\&quot;</span><span class="s1">reducer</span><span class="s3">\&quot; </span><span class="s1">so it's</span><span class="s3">\n          </span><span class="s1">// less confusing.</span><span class="s3">\n          </span><span class="s1">prefetchReducer(actionQueue.state, {</span><span class="s3">\n            </span><span class="s1">type: ACTION_PREFETCH,</span><span class="s3">\n            </span><span class="s1">url,</span><span class="s3">\n            </span><span class="s1">kind: options?.kind ?? PrefetchKind.FULL,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">replace: (href: string, options?: NavigateOptions) =&gt; {</span><span class="s3">\n    </span><span class="s1">startTransition(() =&gt; {</span><span class="s3">\n      </span><span class="s1">dispatchNavigateAction(href, 'replace', options?.scroll ?? true, null)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">push: (href: string, options?: NavigateOptions) =&gt; {</span><span class="s3">\n    </span><span class="s1">startTransition(() =&gt; {</span><span class="s3">\n      </span><span class="s1">dispatchNavigateAction(href, 'push', options?.scroll ?? true, null)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">refresh: () =&gt; {</span><span class="s3">\n    </span><span class="s1">startTransition(() =&gt; {</span><span class="s3">\n      </span><span class="s1">dispatchAppRouterAction({</span><span class="s3">\n        </span><span class="s1">type: ACTION_REFRESH,</span><span class="s3">\n        </span><span class="s1">origin: window.location.origin,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">hmrRefresh: () =&gt; {</span><span class="s3">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'development') {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'hmrRefresh can only be used in development mode. Please use refresh instead.'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">startTransition(() =&gt; {</span><span class="s3">\n        </span><span class="s1">dispatchAppRouterAction({</span><span class="s3">\n          </span><span class="s1">type: ACTION_HMR_REFRESH,</span><span class="s3">\n          </span><span class="s1">origin: window.location.origin,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Exists for debugging purposes. Don't use in application code.</span><span class="s3">\n</span><span class="s1">if (typeof window !== 'undefined' &amp;&amp; window.next) {</span><span class="s3">\n  </span><span class="s1">window.next.router = publicAppRouterInstance</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;createMutableActionQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;dispatchNavigateAction&quot;</span><span class="s0">,</span><span class="s1">&quot;dispatchTraverseAction&quot;</span><span class="s0">,</span><span class="s1">&quot;getCurrentAppRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;publicAppRouterInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;runRemainingActions&quot;</span><span class="s0">,</span><span class="s1">&quot;actionQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;setState&quot;</span><span class="s0">,</span><span class="s1">&quot;pending&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;runAction&quot;</span><span class="s0">,</span><span class="s1">&quot;action&quot;</span><span class="s0">,</span><span class="s1">&quot;needsRefresh&quot;</span><span class="s0">,</span><span class="s1">&quot;dispatch&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_REFRESH&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;prevState&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;payload&quot;</span><span class="s0">,</span><span class="s1">&quot;actionResult&quot;</span><span class="s0">,</span><span class="s1">&quot;handleResult&quot;</span><span class="s0">,</span><span class="s1">&quot;nextState&quot;</span><span class="s0">,</span><span class="s1">&quot;discarded&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;isThenable&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;dispatchAction&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvers&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_RESTORE&quot;</span><span class="s0">,</span><span class="s1">&quot;deferredPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;startTransition&quot;</span><span class="s0">,</span><span class="s1">&quot;newAction&quot;</span><span class="s0">,</span><span class="s1">&quot;last&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_NAVIGATE&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_SERVER_ACTION&quot;</span><span class="s0">,</span><span class="s1">&quot;globalActionQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;initialState&quot;</span><span class="s0">,</span><span class="s1">&quot;instrumentationHooks&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;reducer&quot;</span><span class="s0">,</span><span class="s1">&quot;onRouterTransitionStart&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;getAppRouterActionQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;getProfilingHookForOnNavigationStart&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;navigateType&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldScroll&quot;</span><span class="s0">,</span><span class="s1">&quot;linkInstanceRef&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;addBasePath&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_APP_NAV_FAIL_HANDLING&quot;</span><span class="s0">,</span><span class="s1">&quot;__pendingUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;setLinkForCurrentNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;dispatchAppRouterAction&quot;</span><span class="s0">,</span><span class="s1">&quot;isExternalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;isExternalURL&quot;</span><span class="s0">,</span><span class="s1">&quot;locationSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;allowAliasing&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;back&quot;</span><span class="s0">,</span><span class="s1">&quot;history&quot;</span><span class="s0">,</span><span class="s1">&quot;forward&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CLIENT_SEGMENT_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchKind&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchKind&quot;</span><span class="s0">,</span><span class="s1">&quot;AUTO&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchStrategy&quot;</span><span class="s0">,</span><span class="s1">&quot;FetchStrategy&quot;</span><span class="s0">,</span><span class="s1">&quot;PPR&quot;</span><span class="s0">,</span><span class="s1">&quot;FULL&quot;</span><span class="s0">,</span><span class="s1">&quot;Full&quot;</span><span class="s0">,</span><span class="s1">&quot;TEMPORARY&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchWithSegmentCache&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;onInvalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;createPrefetchURL&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchReducer&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_PREFETCH&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;scroll&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;refresh&quot;</span><span class="s0">,</span><span class="s1">&quot;hmrRefresh&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_HMR_REFRESH&quot;</span><span class="s0">,</span><span class="s1">&quot;router&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAmUYyD,QAAQC,GAAG,CAACe,2BAA2B,GAE7C,oEAAoE;;;;;;;;;;;;;;;;;;;IAlH1DzE,wBAAwB,EAAA;eAAxBA;;IA0DAC,sBAAsB,EAAA;eAAtBA;;IA+BAC,sBAAsB,EAAA;eAAtBA;;IAnDAC,wBAAwB,EAAA;eAAxBA;;IAuEHC,uBAAuB,EAAA;eAAvBA;;;oCApTN;+BACiB;uBACQ;4BACL;8BAKpB;gCACiC;6BACZ;2BACqB;iCACjB;uBAM+B;AAkC/D,SAASC,oBACPC,WAAiC,EACjCC,QAA8B;IAE9B,IAAID,YAAYE,OAAO,KAAK,MAAM;QAChCF,YAAYE,OAAO,GAAGF,YAAYE,OAAO,CAACC,IAAI;QAC9C,IAAIH,YAAYE,OAAO,KAAK,MAAM;YAChC,mEAAmE;YACnEE,UAAU;gBACRJ;gBACAK,QAAQL,YAAYE,OAAO;gBAC3BD;YACF;QACF,OAAO;YACL,4DAA4D;YAC5D,IAAID,YAAYM,YAAY,EAAE;gBAC5BN,YAAYM,YAAY,GAAG;gBAC3BN,YAAYO,QAAQ,CAClB;oBACEC,MAAMC,oBAAAA,cAAc;oBACpBC,QAAQC,OAAOC,QAAQ,CAACF,MAAM;gBAChC,GACAT;YAEJ;QACF;IACF;AACF;AAEA,eAAeG,UAAU,KAQxB;IARwB,IAAA,EACvBJ,WAAW,EACXK,MAAM,EACNJ,QAAQ,EAKT,GARwB;IASvB,MAAMY,YAAYb,YAAYc,KAAK;IAEnCd,YAAYE,OAAO,GAAGG;IAEtB,MAAMU,UAAUV,OAAOU,OAAO;IAC9B,MAAMC,eAAehB,YAAYK,MAAM,CAACQ,WAAWE;IAEnD,SAASE,aAAaC,SAAyB;QAC7C,kEAAkE;QAClE,IAAIb,OAAOc,SAAS,EAAE;YACpB;QACF;QAEAnB,YAAYc,KAAK,GAAGI;QAEpBnB,oBAAoBC,aAAaC;QACjCI,OAAOe,OAAO,CAACF;IACjB;IAEA,8DAA8D;IAC9D,IAAIG,CAAAA,GAAAA,YAAAA,UAAU,EAACL,eAAe;QAC5BA,aAAaM,IAAI,CAACL,cAAc,CAACM;YAC/BxB,oBAAoBC,aAAaC;YACjCI,OAAOmB,MAAM,CAACD;QAChB;IACF,OAAO;QACLN,aAAaD;IACf;AACF;AAEA,SAASS,eACPzB,WAAiC,EACjCe,OAAuB,EACvBd,QAA8B;IAE9B,IAAIyB,YAGA;QAAEN,SAASnB;QAAUuB,QAAQ,KAAO;IAAE;IAE1C,mEAAmE;IACnE,wFAAwF;IACxF,2DAA2D;IAC3D,oDAAoD;IACpD,IAAIT,QAAQP,IAAI,KAAKmB,oBAAAA,cAAc,EAAE;QACnC,6DAA6D;QAC7D,MAAMC,kBAAkB,IAAIC,QAAwB,CAACT,SAASI;YAC5DE,YAAY;gBAAEN;gBAASI;YAAO;QAChC;QAEAM,CAAAA,GAAAA,OAAAA,eAAe,EAAC;YACd,oGAAoG;YACpG,iEAAiE;YACjE7B,SAAS2B;QACX;IACF;IAEA,MAAMG,YAA6B;QACjChB;QACAZ,MAAM;QACNiB,SAASM,UAAUN,OAAO;QAC1BI,QAAQE,UAAUF,MAAM;IAC1B;IAEA,8BAA8B;IAC9B,IAAIxB,YAAYE,OAAO,KAAK,MAAM;QAChC,iEAAiE;QACjE,4CAA4C;QAC5CF,YAAYgC,IAAI,GAAGD;QAEnB3B,UAAU;YACRJ;YACAK,QAAQ0B;YACR9B;QACF;IACF,OAAO,IACLc,QAAQP,IAAI,KAAKyB,oBAAAA,eAAe,IAChClB,QAAQP,IAAI,KAAKmB,oBAAAA,cAAc,EAC/B;QACA,+EAA+E;QAC/E,oHAAoH;QACpH3B,YAAYE,OAAO,CAACiB,SAAS,GAAG;QAEhC,4EAA4E;QAC5E,sIAAsI;QACtIY,UAAU5B,IAAI,GAAGH,YAAYE,OAAO,CAACC,IAAI;QAEzC,2GAA2G;QAC3G,IAAIH,YAAYE,OAAO,CAACa,OAAO,CAACP,IAAI,KAAK0B,oBAAAA,oBAAoB,EAAE;YAC7DlC,YAAYM,YAAY,GAAG;QAC7B;QAEAF,UAAU;YACRJ;YACAK,QAAQ0B;YACR9B;QACF;IACF,OAAO;QACL,oEAAoE;QACpE,+EAA+E;QAC/E,IAAID,YAAYgC,IAAI,KAAK,MAAM;YAC7BhC,YAAYgC,IAAI,CAAC7B,IAAI,GAAG4B;QAC1B;QACA/B,YAAYgC,IAAI,GAAGD;IACrB;AACF;AAEA,IAAII,oBAAiD;AAE9C,SAASzC,yBACd0C,YAA4B,EAC5BC,oBAAuD;IAEvD,MAAMrC,cAAoC;QACxCc,OAAOsB;QACP7B,UAAU,CAACQ,SAAyBd,WAClCwB,eAAezB,aAAae,SAASd;QACvCI,QAAQ,OAAOS,OAAuBT;YACpC,MAAMiC,SAASC,CAAAA,GAAAA,eAAAA,OAAO,EAACzB,OAAOT;YAC9B,OAAOiC;QACT;QACApC,SAAS;QACT8B,MAAM;QACNQ,yBACEH,yBAAyB,QACzB,OAAOA,qBAAqBG,uBAAuB,KAAK,aAEpDH,qBAAqBG,uBAAuB,GAC5C;IACR;IAEA,IAAI,OAAO7B,WAAW,aAAa;QACjC,wEAAwE;QACxE,qEAAqE;QACrE,0CAA0C;QAC1C,IAAIwB,sBAAsB,MAAM;YAC9B,MAAM,OAAA,cAGL,CAHK,IAAIM,MACR,sEACE,cAFE,qBAAA;uBAAA;4BAAA;8BAAA;YAGN;QACF;QACAN,oBAAoBnC;IACtB;IAEA,OAAOA;AACT;AAEO,SAASH;IACd,OAAOsC,sBAAsB,OAAOA,kBAAkBrB,KAAK,GAAG;AAChE;AAEA,SAAS4B;IACP,IAAIP,sBAAsB,MAAM;QAC9B,MAAM,OAAA,cAEL,CAFK,IAAIM,MACR,4EADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IACA,OAAON;AACT;AAEA,SAASQ;IACP,IAAIR,sBAAsB,MAAM;QAC9B,OAAOA,kBAAkBK,uBAAuB;IAClD;IACA,OAAO;AACT;AAEO,SAAS7C,uBACdiD,IAAY,EACZC,YAA4C,EAC5CC,YAAqB,EACrBC,eAAoC;IAEpC,yEAAyE;IACzE,oEAAoE;IACpE,MAAMC,MAAM,IAAIC,IAAIC,CAAAA,GAAAA,aAAAA,WAAW,EAACN,OAAOhC,SAASgC,IAAI;IACpD,IAAIO,QAAQC,GAAG,CAACC,4BAA4B,EAAE;;IAI9CE,CAAAA,GAAAA,OAAAA,2BAA2B,EAACR;IAE5B,MAAMP,0BAA0BG;IAChC,IAAIH,4BAA4B,MAAM;QACpCA,wBAAwBI,MAAMC;IAChC;IAEAW,CAAAA,GAAAA,gBAAAA,uBAAuB,EAAC;QACtBhD,MAAMyB,oBAAAA,eAAe;QACrBe;QACAS,eAAeC,CAAAA,GAAAA,WAAAA,aAAa,EAACV;QAC7BW,gBAAgB/C,SAASgD,MAAM;QAC/Bd;QACAD;QACAgB,eAAe;IACjB;AACF;AAEO,SAASjE,uBACdgD,IAAY,EACZkB,IAAmC;IAEnC,MAAMtB,0BAA0BG;IAChC,IAAIH,4BAA4B,MAAM;QACpCA,wBAAwBI,MAAM;IAChC;IACAY,CAAAA,GAAAA,gBAAAA,uBAAuB,EAAC;QACtBhD,MAAMmB,oBAAAA,cAAc;QACpBqB,KAAK,IAAIC,IAAIL;QACbkB;IACF;AACF;AAOO,MAAMhE,0BAA6C;IACxDiE,MAAM,IAAMpD,OAAOqD,OAAO,CAACD,IAAI;IAC/BE,SAAS,IAAMtD,OAAOqD,OAAO,CAACC,OAAO;IACrCC,gDAGI,iDAAiD;IACjD,CAACtB,MAAcwB,mBAuCf,CAACxB,MAAcwB;QACb,uCAAuC;QACvC,MAAMpE,cAAc0C;QACpB,MAAMM,MAAMkC,CAAAA,GAAAA,WAAAA,iBAAiB,EAACtC;QAC9B,IAAII,QAAQ,MAAM;gBAURoB;YATR,4DAA4D;YAC5D,+DAA+D;YAC/D,iEAAiE;YACjE,gDAAgD;YAChD,oDAAoD;YACpD,kBAAkB;YAClBe,CAAAA,GAAAA,iBAAAA,eAAe,EAACnF,YAAYc,KAAK,EAAE;gBACjCN,MAAM4E,oBAAAA,eAAe;gBACrBpC;gBACAsB,MAAMF,CAAAA,gBAAAA,WAAAA,OAAAA,KAAAA,IAAAA,QAASE,IAAI,KAAA,OAAbF,gBAAiBG,oBAAAA,YAAY,CAACK,IAAI;YAC1C;QACF;IACF;IACJS,SAAS,CAACzC,MAAcwB;QACtBtC,CAAAA,GAAAA,OAAAA,eAAe,EAAC;gBAC0BsC;YAAxCzE,uBAAuBiD,MAAM,WAAWwB,CAAAA,kBAAAA,WAAAA,OAAAA,KAAAA,IAAAA,QAASkB,MAAM,KAAA,OAAflB,kBAAmB,MAAM;QACnE;IACF;IACAmB,MAAM,CAAC3C,MAAcwB;QACnBtC,CAAAA,GAAAA,OAAAA,eAAe,EAAC;gBACuBsC;YAArCzE,uBAAuBiD,MAAM,QAAQwB,CAAAA,kBAAAA,WAAAA,OAAAA,KAAAA,IAAAA,QAASkB,MAAM,KAAA,OAAflB,kBAAmB,MAAM;QAChE;IACF;IACAoB,SAAS;QACP1D,CAAAA,GAAAA,OAAAA,eAAe,EAAC;YACd0B,CAAAA,GAAAA,gBAAAA,uBAAuB,EAAC;gBACtBhD,MAAMC,oBAAAA,cAAc;gBACpBC,QAAQC,OAAOC,QAAQ,CAACF,MAAM;YAChC;QACF;IACF;IACA+E,YAAY;QACV,IAAItC,QAAQC,GAAG,CAACsC,QAAQ,KAAK,eAAe;;aAIrC;YACL5D,CAAAA,GAAAA,OAAAA,eAAe,EAAC;gBACd0B,CAAAA,GAAAA,gBAAAA,uBAAuB,EAAC;oBACtBhD,MAAMmF,oBAAAA,kBAAkB;oBACxBjF,QAAQC,OAAOC,QAAQ,CAACF,MAAM;gBAChC;YACF;QACF;IACF;AACF;AAEA,gEAAgE;AAChE,IAAI,OAAOC,WAAW,eAAeA,OAAOR,IAAI,EAAE;IAChDQ,OAAOR,IAAI,CAACyF,MAAM,GAAG9F;AACvB&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">9577</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/components/router-reducer/create-initial-router-state.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type { FlightDataPath } from '../../../server/app-render/types'</span><span class="s3">\n\n</span><span class="s1">import { createHrefFromUrl } from './create-href-from-url'</span><span class="s3">\n</span><span class="s1">import { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'</span><span class="s3">\n</span><span class="s1">import { extractPathFromFlightRouterState } from './compute-changed-path'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">createSeededPrefetchCacheEntry,</span><span class="s3">\n  </span><span class="s1">STATIC_STALETIME_MS,</span><span class="s3">\n</span><span class="s1">} from './prefetch-cache-utils'</span><span class="s3">\n</span><span class="s1">import { PrefetchKind, type PrefetchCacheEntry } from './router-reducer-types'</span><span class="s3">\n</span><span class="s1">import { addRefreshMarkerToActiveParallelSegments } from './refetch-inactive-parallel-segments'</span><span class="s3">\n</span><span class="s1">import { getFlightDataPartsFromPath } from '../../flight-data-helpers'</span><span class="s3">\n\n</span><span class="s1">export interface InitialRouterStateParameters {</span><span class="s3">\n  </span><span class="s1">navigatedAt: number</span><span class="s3">\n  </span><span class="s1">initialCanonicalUrlParts: string[]</span><span class="s3">\n  </span><span class="s1">initialParallelRoutes: CacheNode['parallelRoutes']</span><span class="s3">\n  </span><span class="s1">initialFlightData: FlightDataPath[]</span><span class="s3">\n  </span><span class="s1">location: Location | null</span><span class="s3">\n  </span><span class="s1">couldBeIntercepted: boolean</span><span class="s3">\n  </span><span class="s1">postponed: boolean</span><span class="s3">\n  </span><span class="s1">prerendered: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createInitialRouterState({</span><span class="s3">\n  </span><span class="s1">navigatedAt,</span><span class="s3">\n  </span><span class="s1">initialFlightData,</span><span class="s3">\n  </span><span class="s1">initialCanonicalUrlParts,</span><span class="s3">\n  </span><span class="s1">initialParallelRoutes,</span><span class="s3">\n  </span><span class="s1">location,</span><span class="s3">\n  </span><span class="s1">couldBeIntercepted,</span><span class="s3">\n  </span><span class="s1">postponed,</span><span class="s3">\n  </span><span class="s1">prerendered,</span><span class="s3">\n</span><span class="s1">}: InitialRouterStateParameters) {</span><span class="s3">\n  </span><span class="s1">// When initialized on the server, the canonical URL is provided as an array of parts.</span><span class="s3">\n  </span><span class="s1">// This is to ensure that when the RSC payload streamed to the client, crawlers don't interpret it</span><span class="s3">\n  </span><span class="s1">// as a URL that should be crawled.</span><span class="s3">\n  </span><span class="s1">const initialCanonicalUrl = initialCanonicalUrlParts.join('/')</span><span class="s3">\n\n  </span><span class="s1">const normalizedFlightData = getFlightDataPartsFromPath(initialFlightData[0])</span><span class="s3">\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">tree: initialTree,</span><span class="s3">\n    </span><span class="s1">seedData: initialSeedData,</span><span class="s3">\n    </span><span class="s1">head: initialHead,</span><span class="s3">\n  </span><span class="s1">} = normalizedFlightData</span><span class="s3">\n  </span><span class="s1">// For the SSR render, seed data should always be available (we only send back a `null` response</span><span class="s3">\n  </span><span class="s1">// in the case of a `loading` segment, pre-PPR.)</span><span class="s3">\n  </span><span class="s1">const rsc = initialSeedData?.[1]</span><span class="s3">\n  </span><span class="s1">const loading = initialSeedData?.[3] ?? null</span><span class="s3">\n\n  </span><span class="s1">const cache: CacheNode = {</span><span class="s3">\n    </span><span class="s1">lazyData: null,</span><span class="s3">\n    </span><span class="s1">rsc,</span><span class="s3">\n    </span><span class="s1">prefetchRsc: null,</span><span class="s3">\n    </span><span class="s1">head: null,</span><span class="s3">\n    </span><span class="s1">prefetchHead: null,</span><span class="s3">\n    </span><span class="s1">// The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.</span><span class="s3">\n    </span><span class="s1">parallelRoutes: initialParallelRoutes,</span><span class="s3">\n    </span><span class="s1">loading,</span><span class="s3">\n    </span><span class="s1">navigatedAt,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const canonicalUrl =</span><span class="s3">\n    </span><span class="s1">// location.href is read as the initial value for canonicalUrl in the browser</span><span class="s3">\n    </span><span class="s1">// This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.</span><span class="s3">\n    </span><span class="s1">location</span><span class="s3">\n      </span><span class="s1">? // window.location does not have the same type as URL but has all the fields createHrefFromUrl needs.</span><span class="s3">\n        </span><span class="s1">createHrefFromUrl(location)</span><span class="s3">\n      </span><span class="s1">: initialCanonicalUrl</span><span class="s3">\n\n  </span><span class="s1">addRefreshMarkerToActiveParallelSegments(initialTree, canonicalUrl)</span><span class="s3">\n\n  </span><span class="s1">const prefetchCache = new Map&lt;string, PrefetchCacheEntry&gt;()</span><span class="s3">\n\n  </span><span class="s1">// When the cache hasn't been seeded yet we fill the cache with the head.</span><span class="s3">\n  </span><span class="s1">if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {</span><span class="s3">\n    </span><span class="s1">fillLazyItemsTillLeafWithHead(</span><span class="s3">\n      </span><span class="s1">navigatedAt,</span><span class="s3">\n      </span><span class="s1">cache,</span><span class="s3">\n      </span><span class="s1">undefined,</span><span class="s3">\n      </span><span class="s1">initialTree,</span><span class="s3">\n      </span><span class="s1">initialSeedData,</span><span class="s3">\n      </span><span class="s1">initialHead,</span><span class="s3">\n      </span><span class="s1">undefined</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const initialState = {</span><span class="s3">\n    </span><span class="s1">tree: initialTree,</span><span class="s3">\n    </span><span class="s1">cache,</span><span class="s3">\n    </span><span class="s1">prefetchCache,</span><span class="s3">\n    </span><span class="s1">pushRef: {</span><span class="s3">\n      </span><span class="s1">pendingPush: false,</span><span class="s3">\n      </span><span class="s1">mpaNavigation: false,</span><span class="s3">\n      </span><span class="s1">// First render needs to preserve the previous window.history.state</span><span class="s3">\n      </span><span class="s1">// to avoid it being overwritten on navigation back/forward with MPA Navigation.</span><span class="s3">\n      </span><span class="s1">preserveCustomHistoryState: true,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">focusAndScrollRef: {</span><span class="s3">\n      </span><span class="s1">apply: false,</span><span class="s3">\n      </span><span class="s1">onlyHashChange: false,</span><span class="s3">\n      </span><span class="s1">hashFragment: null,</span><span class="s3">\n      </span><span class="s1">segmentPaths: [],</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">canonicalUrl,</span><span class="s3">\n    </span><span class="s1">nextUrl:</span><span class="s3">\n      </span><span class="s1">// the || operator is intentional, the pathname can be an empty string</span><span class="s3">\n      </span><span class="s1">(extractPathFromFlightRouterState(initialTree) || location?.pathname) ??</span><span class="s3">\n      </span><span class="s1">null,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NODE_ENV !== 'development' &amp;&amp; location) {</span><span class="s3">\n    </span><span class="s1">// Seed the prefetch cache with this page's data.</span><span class="s3">\n    </span><span class="s1">// This is to prevent needlessly re-prefetching a page that is already reusable,</span><span class="s3">\n    </span><span class="s1">// and will avoid triggering a loading state/data fetch stall when navigating back to the page.</span><span class="s3">\n    </span><span class="s1">// We don't currently do this in development because links aren't prefetched in development</span><span class="s3">\n    </span><span class="s1">// so having a mismatch between prefetch/no prefetch provides inconsistent behavior based on which page</span><span class="s3">\n    </span><span class="s1">// was loaded first.</span><span class="s3">\n    </span><span class="s1">const url = new URL(</span><span class="s3">\n      </span><span class="s1">`${location.pathname}${location.search}`,</span><span class="s3">\n      </span><span class="s1">location.origin</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">createSeededPrefetchCacheEntry({</span><span class="s3">\n      </span><span class="s1">url,</span><span class="s3">\n      </span><span class="s1">data: {</span><span class="s3">\n        </span><span class="s1">flightData: [normalizedFlightData],</span><span class="s3">\n        </span><span class="s1">canonicalUrl: undefined,</span><span class="s3">\n        </span><span class="s1">couldBeIntercepted: !!couldBeIntercepted,</span><span class="s3">\n        </span><span class="s1">prerendered,</span><span class="s3">\n        </span><span class="s1">postponed,</span><span class="s3">\n        </span><span class="s1">// TODO: The initial RSC payload includes both static and dynamic data</span><span class="s3">\n        </span><span class="s1">// in the same response, even if PPR is enabled. So if there's any</span><span class="s3">\n        </span><span class="s1">// dynamic data at all, we can't set a stale time. In the future we may</span><span class="s3">\n        </span><span class="s1">// add a way to split a single Flight stream into static and dynamic</span><span class="s3">\n        </span><span class="s1">// parts. But in the meantime we should at least make this work for</span><span class="s3">\n        </span><span class="s1">// fully static pages.</span><span class="s3">\n        </span><span class="s1">staleTime:</span><span class="s3">\n          </span><span class="s1">// In the old router, there was only a single configurable staleTime (experimental.staleTimes)</span><span class="s3">\n          </span><span class="s1">// As an abundance of caution, this will only set the initial staleTime to the configured value</span><span class="s3">\n          </span><span class="s1">// if we're not leveraging the segment cache, which has its own prefetching semantics.</span><span class="s3">\n          </span><span class="s1">prerendered &amp;&amp; !process.env.__NEXT_CLIENT_SEGMENT_CACHE</span><span class="s3">\n            </span><span class="s1">? STATIC_STALETIME_MS</span><span class="s3">\n            </span><span class="s1">: -1,</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">tree: initialState.tree,</span><span class="s3">\n      </span><span class="s1">prefetchCache: initialState.prefetchCache,</span><span class="s3">\n      </span><span class="s1">nextUrl: initialState.nextUrl,</span><span class="s3">\n      </span><span class="s1">kind: prerendered ? PrefetchKind.FULL : PrefetchKind.AUTO,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return initialState</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;createInitialRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;navigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;initialFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;initialCanonicalUrlParts&quot;</span><span class="s0">,</span><span class="s1">&quot;initialParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;couldBeIntercepted&quot;</span><span class="s0">,</span><span class="s1">&quot;postponed&quot;</span><span class="s0">,</span><span class="s1">&quot;prerendered&quot;</span><span class="s0">,</span><span class="s1">&quot;initialCanonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;getFlightDataPartsFromPath&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;initialTree&quot;</span><span class="s0">,</span><span class="s1">&quot;seedData&quot;</span><span class="s0">,</span><span class="s1">&quot;initialSeedData&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;initialHead&quot;</span><span class="s0">,</span><span class="s1">&quot;rsc&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyData&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchHead&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;createHrefFromUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;addRefreshMarkerToActiveParallelSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;fillLazyItemsTillLeafWithHead&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;extractPathFromFlightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;initialState&quot;</span><span class="s0">,</span><span class="s1">&quot;pushRef&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingPush&quot;</span><span class="s0">,</span><span class="s1">&quot;mpaNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;preserveCustomHistoryState&quot;</span><span class="s0">,</span><span class="s1">&quot;focusAndScrollRef&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;onlyHashChange&quot;</span><span class="s0">,</span><span class="s1">&quot;hashFragment&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;createSeededPrefetchCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;staleTime&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CLIENT_SEGMENT_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;STATIC_STALETIME_MS&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchKind&quot;</span><span class="s0">,</span><span class="s1">&quot;FULL&quot;</span><span class="s0">,</span><span class="s1">&quot;AUTO&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAgHM+C,QAAQC,GAAG,CAACC,QAAQ,KAAK,iBAAiB5C,UAAU;;;;;+BAvF1CL,4BAAAA;;;eAAAA;;;mCAtBkB;+CACY;oCACG;oCAI1C;oCAC+C;iDACG;mCACd;AAapC,SAASA,yBAAyB,KASV;IATU,IAAA,EACvCC,WAAW,EACXC,iBAAiB,EACjBC,wBAAwB,EACxBC,qBAAqB,EACrBC,QAAQ,EACRC,kBAAkB,EAClBC,SAAS,EACTC,WAAW,EACkB,GATU;IAUvC,sFAAsF;IACtF,kGAAkG;IAClG,mCAAmC;IACnC,MAAMC,sBAAsBN,yBAAyBO,IAAI,CAAC;IAE1D,MAAMC,uBAAuBC,CAAAA,GAAAA,mBAAAA,0BAA0B,EAACV,iBAAiB,CAAC,EAAE;IAC5E,MAAM,EACJW,MAAMC,WAAW,EACjBC,UAAUC,eAAe,EACzBC,MAAMC,WAAW,EAClB,GAAGP;IACJ,gGAAgG;IAChG,gDAAgD;IAChD,MAAMQ,MAAMH,mBAAAA,OAAAA,KAAAA,IAAAA,eAAiB,CAAC,EAAE;QAChBA;IAAhB,MAAMI,UAAUJ,CAAAA,oBAAAA,mBAAAA,OAAAA,KAAAA,IAAAA,eAAiB,CAAC,EAAE,KAAA,OAApBA,oBAAwB;IAExC,MAAMK,QAAmB;QACvBC,UAAU;QACVH;QACAI,aAAa;QACbN,MAAM;QACNO,cAAc;QACd,oJAAoJ;QACpJC,gBAAgBrB;QAChBgB;QACAnB;IACF;IAEA,MAAMyB,eACJ,AACA,6EAD6E,qEACqE;IAClJrB,WAEIsB,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACtB,YAClBI;IAENmB,CAAAA,GAAAA,iCAAAA,wCAAwC,EAACd,aAAaY;IAEtD,MAAMG,gBAAgB,IAAIC;IAE1B,yEAAyE;IACzE,IAAI1B,0BAA0B,QAAQA,sBAAsB2B,IAAI,KAAK,GAAG;QACtEC,CAAAA,GAAAA,+BAAAA,6BAA6B,EAC3B/B,aACAoB,OACAY,WACAnB,aACAE,iBACAE,aACAe;IAEJ;QAqBI,AACCC,sEADqE;IAnB1E,MAAMC,eAAe;QACnBtB,MAAMC;QACNO;QACAQ;QACAO,SAAS;YACPC,aAAa;YACbC,eAAe;YACf,mEAAmE;YACnE,gFAAgF;YAChFC,4BAA4B;QAC9B;QACAC,mBAAmB;YACjBC,OAAO;YACPC,gBAAgB;YAChBC,cAAc;YACdC,cAAc,EAAE;QAClB;QACAlB;QACAmB,SAEE,CAACX,OAAAA,CAAAA,GAAAA,oBAAAA,gCAAgC,EAACpB,gBAAAA,CAAgBT,YAAAA,OAAAA,KAAAA,IAAAA,SAAUyC,QAAQ,CAAA,KAAA,OAAnEZ,OACD;IACJ;IAEA;;IAyCA,OAAOC;AACT&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">9663</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/app-link-gc.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;export function linkGc() {</span><span class="s3">\n  </span><span class="s1">// TODO-APP: Remove this logic when Float has GC built-in in development.</span><span class="s3">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n    </span><span class="s1">const callback = (mutationList: MutationRecord[]) =&gt; {</span><span class="s3">\n      </span><span class="s1">for (const mutation of mutationList) {</span><span class="s3">\n        </span><span class="s1">if (mutation.type === 'childList') {</span><span class="s3">\n          </span><span class="s1">for (const node of mutation.addedNodes) {</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">'tagName' in node &amp;&amp;</span><span class="s3">\n              </span><span class="s1">(node as HTMLLinkElement).tagName === 'LINK'</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">const link = node as HTMLLinkElement</span><span class="s3">\n              </span><span class="s1">if (link.dataset.precedence?.startsWith('next')) {</span><span class="s3">\n                </span><span class="s1">const href = link.getAttribute('href')</span><span class="s3">\n                </span><span class="s1">if (href) {</span><span class="s3">\n                  </span><span class="s1">const [resource, version] = href.split('?v=', 2)</span><span class="s3">\n                  </span><span class="s1">if (version) {</span><span class="s3">\n                    </span><span class="s1">const currentOrigin = window.location.origin</span><span class="s3">\n                    </span><span class="s1">const allLinks = [</span><span class="s3">\n                      </span><span class="s1">...document.querySelectorAll(</span><span class="s3">\n                        </span><span class="s1">'link[href^=</span><span class="s3">\&quot;</span><span class="s1">' + resource + '</span><span class="s3">\&quot;</span><span class="s1">]'</span><span class="s3">\n                      </span><span class="s1">),</span><span class="s3">\n                      </span><span class="s1">// It's possible that the resource is a full URL or only pathname,</span><span class="s3">\n                      </span><span class="s1">// so we need to remove the alternative href as well.</span><span class="s3">\n                      </span><span class="s1">...document.querySelectorAll(</span><span class="s3">\n                        </span><span class="s1">'link[href^=</span><span class="s3">\&quot;</span><span class="s1">' +</span><span class="s3">\n                          </span><span class="s1">(resource.startsWith(currentOrigin)</span><span class="s3">\n                            </span><span class="s1">? resource.slice(currentOrigin.length)</span><span class="s3">\n                            </span><span class="s1">: currentOrigin + resource) +</span><span class="s3">\n                          </span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">]'</span><span class="s3">\n                      </span><span class="s1">),</span><span class="s3">\n                    </span><span class="s1">] as HTMLLinkElement[]</span><span class="s3">\n\n                    </span><span class="s1">for (const otherLink of allLinks) {</span><span class="s3">\n                      </span><span class="s1">if (otherLink.dataset.precedence?.startsWith('next')) {</span><span class="s3">\n                        </span><span class="s1">const otherHref = otherLink.getAttribute('href')</span><span class="s3">\n                        </span><span class="s1">if (otherHref) {</span><span class="s3">\n                          </span><span class="s1">const [, otherVersion] = otherHref.split('?v=', 2)</span><span class="s3">\n                          </span><span class="s1">if (!otherVersion || +otherVersion &lt; +version) {</span><span class="s3">\n                            </span><span class="s1">// Delay the removal of the stylesheet to avoid FOUC</span><span class="s3">\n                            </span><span class="s1">// caused by `@font-face` rules, as they seem to be</span><span class="s3">\n                            </span><span class="s1">// a couple of ticks delayed between the old and new</span><span class="s3">\n                            </span><span class="s1">// styles being swapped even if the font is cached.</span><span class="s3">\n                            </span><span class="s1">setTimeout(() =&gt; {</span><span class="s3">\n                              </span><span class="s1">otherLink.remove()</span><span class="s3">\n                            </span><span class="s1">}, 5)</span><span class="s3">\n                            </span><span class="s1">const preloadLink = document.querySelector(</span><span class="s3">\n                              </span><span class="s1">`link[rel=</span><span class="s3">\&quot;</span><span class="s1">preload</span><span class="s3">\&quot;</span><span class="s1">][as=</span><span class="s3">\&quot;</span><span class="s1">style</span><span class="s3">\&quot;</span><span class="s1">][href=</span><span class="s3">\&quot;</span><span class="s1">${otherHref}</span><span class="s3">\&quot;</span><span class="s1">]`</span><span class="s3">\n                            </span><span class="s1">)</span><span class="s3">\n                            </span><span class="s1">if (preloadLink) {</span><span class="s3">\n                              </span><span class="s1">preloadLink.remove()</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                          </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                      </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Create an observer instance linked to the callback function</span><span class="s3">\n    </span><span class="s1">const observer = new MutationObserver(callback)</span><span class="s3">\n    </span><span class="s1">observer.observe(document.head, {</span><span class="s3">\n      </span><span class="s1">childList: true,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;linkGc&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;callback&quot;</span><span class="s0">,</span><span class="s1">&quot;mutationList&quot;</span><span class="s0">,</span><span class="s1">&quot;mutation&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;addedNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;tagName&quot;</span><span class="s0">,</span><span class="s1">&quot;link&quot;</span><span class="s0">,</span><span class="s1">&quot;dataset&quot;</span><span class="s0">,</span><span class="s1">&quot;precedence&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;getAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;resource&quot;</span><span class="s0">,</span><span class="s1">&quot;version&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;currentOrigin&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;allLinks&quot;</span><span class="s0">,</span><span class="s1">&quot;document&quot;</span><span class="s0">,</span><span class="s1">&quot;querySelectorAll&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;otherLink&quot;</span><span class="s0">,</span><span class="s1">&quot;otherHref&quot;</span><span class="s0">,</span><span class="s1">&quot;otherVersion&quot;</span><span class="s0">,</span><span class="s1">&quot;setTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">,</span><span class="s1">&quot;preloadLink&quot;</span><span class="s0">,</span><span class="s1">&quot;querySelector&quot;</span><span class="s0">,</span><span class="s1">&quot;observer&quot;</span><span class="s0">,</span><span class="s1">&quot;MutationObserver&quot;</span><span class="s0">,</span><span class="s1">&quot;observe&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;childList&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAEMC,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;+BAFfH,UAAAA;;;eAAAA;;;AAAT,SAASA;IACd,yEAAyE;IACzE,wCAA2C;QACzC,MAAMI,WAAW,CAACC;YAChB,KAAK,MAAMC,YAAYD,aAAc;gBACnC,IAAIC,SAASC,IAAI,KAAK,aAAa;oBACjC,KAAK,MAAMC,QAAQF,SAASG,UAAU,CAAE;wBACtC,IACE,aAAaD,QACZA,KAAyBE,OAAO,KAAK,QACtC;gCAEIC;4BADJ,MAAMA,OAAOH;4BACb,IAAA,CAAIG,2BAAAA,KAAKC,OAAO,CAACC,UAAU,KAAA,OAAA,KAAA,IAAvBF,yBAAyBG,UAAU,CAAC,SAAS;gCAC/C,MAAMC,OAAOJ,KAAKK,YAAY,CAAC;gCAC/B,IAAID,MAAM;oCACR,MAAM,CAACE,UAAUC,QAAQ,GAAGH,KAAKI,KAAK,CAAC,OAAO;oCAC9C,IAAID,SAAS;wCACX,MAAME,gBAAgBC,OAAOC,QAAQ,CAACC,MAAM;wCAC5C,MAAMC,WAAW;+CACZC,SAASC,gBAAgB,CAC1B,iBAAiBT,WAAW;4CAE9B,kEAAkE;4CAClE,qDAAqD;+CAClDQ,SAASC,gBAAgB,CAC1B,iBACGT,CAAAA,SAASH,UAAU,CAACM,iBACjBH,SAASU,KAAK,CAACP,cAAcQ,MAAM,IACnCR,gBAAgBH,QAAO,IAC3B;yCAEL;wCAED,KAAK,MAAMY,aAAaL,SAAU;gDAC5BK;4CAAJ,IAAA,CAAIA,gCAAAA,UAAUjB,OAAO,CAACC,UAAU,KAAA,OAAA,KAAA,IAA5BgB,8BAA8Bf,UAAU,CAAC,SAAS;gDACpD,MAAMgB,YAAYD,UAAUb,YAAY,CAAC;gDACzC,IAAIc,WAAW;oDACb,MAAM,GAAGC,aAAa,GAAGD,UAAUX,KAAK,CAAC,OAAO;oDAChD,IAAI,CAACY,gBAAgB,CAACA,eAAe,CAACb,SAAS;wDAC7C,oDAAoD;wDACpD,mDAAmD;wDACnD,oDAAoD;wDACpD,mDAAmD;wDACnDc,WAAW;4DACTH,UAAUI,MAAM;wDAClB,GAAG;wDACH,MAAMC,cAAcT,SAASU,aAAa,CACvC,2CAAwCL,YAAU;wDAErD,IAAII,aAAa;4DACfA,YAAYD,MAAM;wDACpB;oDACF;gDACF;4CACF;wCACF;oCACF;gCACF;4BACF;wBACF;oBACF;gBACF;YACF;QACF;QAEA,8DAA8D;QAC9D,MAAMG,WAAW,IAAIC,iBAAiBjC;QACtCgC,SAASE,OAAO,CAACb,SAASc,IAAI,EAAE;YAC9BC,WAAW;QACb;IACF;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">9744</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/app-index.tsx&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import './app-globals'</span><span class="s3">\n</span><span class="s1">import ReactDOMClient from 'react-dom/client'</span><span class="s3">\n</span><span class="s1">import React, { use } from 'react'</span><span class="s3">\n</span><span class="s1">// TODO: Explicitly import from client.browser</span><span class="s3">\n</span><span class="s1">// eslint-disable-next-line import/no-extraneous-dependencies</span><span class="s3">\n</span><span class="s1">import { createFromReadableStream as createFromReadableStreamBrowser } from 'react-server-dom-webpack/client'</span><span class="s3">\n</span><span class="s1">import { HeadManagerContext } from '../shared/lib/head-manager-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { onRecoverableError } from './react-client-callbacks/on-recoverable-error'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">onCaughtError,</span><span class="s3">\n  </span><span class="s1">onUncaughtError,</span><span class="s3">\n</span><span class="s1">} from './react-client-callbacks/error-boundary-callbacks'</span><span class="s3">\n</span><span class="s1">import { callServer } from './app-call-server'</span><span class="s3">\n</span><span class="s1">import { findSourceMapURL } from './app-find-source-map-url'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">type AppRouterActionQueue,</span><span class="s3">\n  </span><span class="s1">createMutableActionQueue,</span><span class="s3">\n</span><span class="s1">} from './components/app-router-instance'</span><span class="s3">\n</span><span class="s1">import AppRouter from './components/app-router'</span><span class="s3">\n</span><span class="s1">import type { InitialRSCPayload } from '../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { createInitialRouterState } from './components/router-reducer/create-initial-router-state'</span><span class="s3">\n</span><span class="s1">import { MissingSlotContext } from '../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { setAppBuildId } from './app-build-id'</span><span class="s3">\n\n</span><span class="s1">/// &lt;reference types=</span><span class="s3">\&quot;</span><span class="s1">react-dom/experimental</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n\n</span><span class="s1">const createFromReadableStream =</span><span class="s3">\n  </span><span class="s1">createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']</span><span class="s3">\n\n</span><span class="s1">const appElement: HTMLElement | Document = document</span><span class="s3">\n\n</span><span class="s1">const encoder = new TextEncoder()</span><span class="s3">\n\n</span><span class="s1">let initialServerDataBuffer: (string | Uint8Array)[] | undefined = undefined</span><span class="s3">\n</span><span class="s1">let initialServerDataWriter: ReadableStreamDefaultController | undefined =</span><span class="s3">\n  </span><span class="s1">undefined</span><span class="s3">\n</span><span class="s1">let initialServerDataLoaded = false</span><span class="s3">\n</span><span class="s1">let initialServerDataFlushed = false</span><span class="s3">\n\n</span><span class="s1">let initialFormStateData: null | any = null</span><span class="s3">\n\n</span><span class="s1">type FlightSegment =</span><span class="s3">\n  </span><span class="s1">| [isBootStrap: 0]</span><span class="s3">\n  </span><span class="s1">| [isNotBootstrap: 1, responsePartial: string]</span><span class="s3">\n  </span><span class="s1">| [isFormState: 2, formState: any]</span><span class="s3">\n  </span><span class="s1">| [isBinary: 3, responseBase64Partial: string]</span><span class="s3">\n\n</span><span class="s1">type NextFlight = Omit&lt;Array&lt;FlightSegment&gt;, 'push'&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">push: (seg: FlightSegment) =&gt; void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">declare global {</span><span class="s3">\n  </span><span class="s1">// If you're working in a browser environment</span><span class="s3">\n  </span><span class="s1">interface Window {</span><span class="s3">\n    </span><span class="s1">__next_f: NextFlight</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function nextServerDataCallback(seg: FlightSegment): void {</span><span class="s3">\n  </span><span class="s1">if (seg[0] === 0) {</span><span class="s3">\n    </span><span class="s1">initialServerDataBuffer = []</span><span class="s3">\n  </span><span class="s1">} else if (seg[0] === 1) {</span><span class="s3">\n    </span><span class="s1">if (!initialServerDataBuffer)</span><span class="s3">\n      </span><span class="s1">throw new Error('Unexpected server data: missing bootstrap script.')</span><span class="s3">\n\n    </span><span class="s1">if (initialServerDataWriter) {</span><span class="s3">\n      </span><span class="s1">initialServerDataWriter.enqueue(encoder.encode(seg[1]))</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">initialServerDataBuffer.push(seg[1])</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (seg[0] === 2) {</span><span class="s3">\n    </span><span class="s1">initialFormStateData = seg[1]</span><span class="s3">\n  </span><span class="s1">} else if (seg[0] === 3) {</span><span class="s3">\n    </span><span class="s1">if (!initialServerDataBuffer)</span><span class="s3">\n      </span><span class="s1">throw new Error('Unexpected server data: missing bootstrap script.')</span><span class="s3">\n\n    </span><span class="s1">// Decode the base64 string back to binary data.</span><span class="s3">\n    </span><span class="s1">const binaryString = atob(seg[1])</span><span class="s3">\n    </span><span class="s1">const decodedChunk = new Uint8Array(binaryString.length)</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; binaryString.length; i++) {</span><span class="s3">\n      </span><span class="s1">decodedChunk[i] = binaryString.charCodeAt(i)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (initialServerDataWriter) {</span><span class="s3">\n      </span><span class="s1">initialServerDataWriter.enqueue(decodedChunk)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">initialServerDataBuffer.push(decodedChunk)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isStreamErrorOrUnfinished(ctr: ReadableStreamDefaultController) {</span><span class="s3">\n  </span><span class="s1">// If `desiredSize` is null, it means the stream is closed or errored. If it is lower than 0, the stream is still unfinished.</span><span class="s3">\n  </span><span class="s1">return ctr.desiredSize === null || ctr.desiredSize &lt; 0</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// There might be race conditions between `nextServerDataRegisterWriter` and</span><span class="s3">\n</span><span class="s1">// `DOMContentLoaded`. The former will be called when React starts to hydrate</span><span class="s3">\n</span><span class="s1">// the root, the latter will be called when the DOM is fully loaded.</span><span class="s3">\n</span><span class="s1">// For streaming, the former is called first due to partial hydration.</span><span class="s3">\n</span><span class="s1">// For non-streaming, the latter can be called first.</span><span class="s3">\n</span><span class="s1">// Hence, we use two variables `initialServerDataLoaded` and</span><span class="s3">\n</span><span class="s1">// `initialServerDataFlushed` to make sure the writer will be closed and</span><span class="s3">\n</span><span class="s1">// `initialServerDataBuffer` will be cleared in the right time.</span><span class="s3">\n</span><span class="s1">function nextServerDataRegisterWriter(ctr: ReadableStreamDefaultController) {</span><span class="s3">\n  </span><span class="s1">if (initialServerDataBuffer) {</span><span class="s3">\n    </span><span class="s1">initialServerDataBuffer.forEach((val) =&gt; {</span><span class="s3">\n      </span><span class="s1">ctr.enqueue(typeof val === 'string' ? encoder.encode(val) : val)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">if (initialServerDataLoaded &amp;&amp; !initialServerDataFlushed) {</span><span class="s3">\n      </span><span class="s1">if (isStreamErrorOrUnfinished(ctr)) {</span><span class="s3">\n        </span><span class="s1">ctr.error(</span><span class="s3">\n          </span><span class="s1">new Error(</span><span class="s3">\n            </span><span class="s1">'The connection to the page was unexpectedly closed, possibly due to the stop button being clicked, loss of Wi-Fi, or an unstable internet connection.'</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">ctr.close()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">initialServerDataFlushed = true</span><span class="s3">\n      </span><span class="s1">initialServerDataBuffer = undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">initialServerDataWriter = ctr</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// When `DOMContentLoaded`, we can close all pending writers to finish hydration.</span><span class="s3">\n</span><span class="s1">const DOMContentLoaded = function () {</span><span class="s3">\n  </span><span class="s1">if (initialServerDataWriter &amp;&amp; !initialServerDataFlushed) {</span><span class="s3">\n    </span><span class="s1">initialServerDataWriter.close()</span><span class="s3">\n    </span><span class="s1">initialServerDataFlushed = true</span><span class="s3">\n    </span><span class="s1">initialServerDataBuffer = undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">initialServerDataLoaded = true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// It's possible that the DOM is already loaded.</span><span class="s3">\n</span><span class="s1">if (document.readyState === 'loading') {</span><span class="s3">\n  </span><span class="s1">document.addEventListener('DOMContentLoaded', DOMContentLoaded, false)</span><span class="s3">\n</span><span class="s1">} else {</span><span class="s3">\n  </span><span class="s1">// Delayed in marco task to ensure it's executed later than hydration</span><span class="s3">\n  </span><span class="s1">setTimeout(DOMContentLoaded)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const nextServerDataLoadingGlobal = (self.__next_f = self.__next_f || [])</span><span class="s3">\n</span><span class="s1">nextServerDataLoadingGlobal.forEach(nextServerDataCallback)</span><span class="s3">\n</span><span class="s1">nextServerDataLoadingGlobal.push = nextServerDataCallback</span><span class="s3">\n\n</span><span class="s1">const readable = new ReadableStream({</span><span class="s3">\n  </span><span class="s1">start(controller) {</span><span class="s3">\n    </span><span class="s1">nextServerDataRegisterWriter(controller)</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">})</span><span class="s3">\n\n</span><span class="s1">const initialServerResponse = createFromReadableStream&lt;InitialRSCPayload&gt;(</span><span class="s3">\n  </span><span class="s1">readable,</span><span class="s3">\n  </span><span class="s1">{ callServer, findSourceMapURL }</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">function ServerRoot({</span><span class="s3">\n  </span><span class="s1">pendingActionQueue,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">pendingActionQueue: Promise&lt;AppRouterActionQueue&gt;</span><span class="s3">\n</span><span class="s1">}): React.ReactNode {</span><span class="s3">\n  </span><span class="s1">const initialRSCPayload = use(initialServerResponse)</span><span class="s3">\n  </span><span class="s1">const actionQueue = use&lt;AppRouterActionQueue&gt;(pendingActionQueue)</span><span class="s3">\n\n  </span><span class="s1">const router = (</span><span class="s3">\n    </span><span class="s1">&lt;AppRouter</span><span class="s3">\n      </span><span class="s1">actionQueue={actionQueue}</span><span class="s3">\n      </span><span class="s1">globalErrorState={initialRSCPayload.G}</span><span class="s3">\n      </span><span class="s1">assetPrefix={initialRSCPayload.p}</span><span class="s3">\n    </span><span class="s1">/&gt;</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NODE_ENV === 'development' &amp;&amp; initialRSCPayload.m) {</span><span class="s3">\n    </span><span class="s1">// We provide missing slot information in a context provider only during development</span><span class="s3">\n    </span><span class="s1">// as we log some additional information about the missing slots in the console.</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">&lt;MissingSlotContext value={initialRSCPayload.m}&gt;</span><span class="s3">\n        </span><span class="s1">{router}</span><span class="s3">\n      </span><span class="s1">&lt;/MissingSlotContext&gt;</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return router</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const StrictModeIfEnabled = process.env.__NEXT_STRICT_MODE_APP</span><span class="s3">\n  </span><span class="s1">? React.StrictMode</span><span class="s3">\n  </span><span class="s1">: React.Fragment</span><span class="s3">\n\n</span><span class="s1">function Root({ children }: React.PropsWithChildren&lt;{}&gt;) {</span><span class="s3">\n  </span><span class="s1">if (process.env.__NEXT_TEST_MODE) {</span><span class="s3">\n    </span><span class="s1">// eslint-disable-next-line react-hooks/rules-of-hooks</span><span class="s3">\n    </span><span class="s1">React.useEffect(() =&gt; {</span><span class="s3">\n      </span><span class="s1">window.__NEXT_HYDRATED = true</span><span class="s3">\n      </span><span class="s1">window.__NEXT_HYDRATED_AT = performance.now()</span><span class="s3">\n      </span><span class="s1">window.__NEXT_HYDRATED_CB?.()</span><span class="s3">\n    </span><span class="s1">}, [])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return children</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function onDefaultTransitionIndicator() {</span><span class="s3">\n  </span><span class="s1">// TODO: Compose default with user-configureable (e.g. nprogress)</span><span class="s3">\n  </span><span class="s1">// TODO: Use React's default once we figure out hanging indicators: https://codesandbox.io/p/sandbox/charming-moon-hktkp6?file=%2Fsrc%2Findex.js%3A106%2C30</span><span class="s3">\n  </span><span class="s1">return () =&gt; {}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const reactRootOptions: ReactDOMClient.RootOptions = {</span><span class="s3">\n  </span><span class="s1">onDefaultTransitionIndicator: onDefaultTransitionIndicator,</span><span class="s3">\n  </span><span class="s1">onRecoverableError,</span><span class="s3">\n  </span><span class="s1">onCaughtError,</span><span class="s3">\n  </span><span class="s1">onUncaughtError,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type ClientInstrumentationHooks = {</span><span class="s3">\n  </span><span class="s1">onRouterTransitionStart?: (</span><span class="s3">\n    </span><span class="s1">url: string,</span><span class="s3">\n    </span><span class="s1">navigationType: 'push' | 'replace' | 'traverse'</span><span class="s3">\n  </span><span class="s1">) =&gt; void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function hydrate(</span><span class="s3">\n  </span><span class="s1">instrumentationHooks: ClientInstrumentationHooks | null</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// React overrides `.then` and doesn't return a new promise chain,</span><span class="s3">\n  </span><span class="s1">// so we wrap the action queue in a promise to ensure that its value</span><span class="s3">\n  </span><span class="s1">// is defined when the promise resolves.</span><span class="s3">\n  </span><span class="s1">// https://github.com/facebook/react/blob/163365a07872337e04826c4f501565d43dbd2fd4/packages/react-client/src/ReactFlightClient.js#L189-L190</span><span class="s3">\n  </span><span class="s1">const pendingActionQueue: Promise&lt;AppRouterActionQueue&gt; = new Promise(</span><span class="s3">\n    </span><span class="s1">(resolve, reject) =&gt; {</span><span class="s3">\n      </span><span class="s1">initialServerResponse.then(</span><span class="s3">\n        </span><span class="s1">(initialRSCPayload) =&gt; {</span><span class="s3">\n          </span><span class="s1">// setAppBuildId should be called only once, during JS initialization</span><span class="s3">\n          </span><span class="s1">// and before any components have hydrated.</span><span class="s3">\n          </span><span class="s1">setAppBuildId(initialRSCPayload.b)</span><span class="s3">\n\n          </span><span class="s1">const initialTimestamp = Date.now()</span><span class="s3">\n\n          </span><span class="s1">resolve(</span><span class="s3">\n            </span><span class="s1">createMutableActionQueue(</span><span class="s3">\n              </span><span class="s1">createInitialRouterState({</span><span class="s3">\n                </span><span class="s1">navigatedAt: initialTimestamp,</span><span class="s3">\n                </span><span class="s1">initialFlightData: initialRSCPayload.f,</span><span class="s3">\n                </span><span class="s1">initialCanonicalUrlParts: initialRSCPayload.c,</span><span class="s3">\n                </span><span class="s1">initialParallelRoutes: new Map(),</span><span class="s3">\n                </span><span class="s1">location: window.location,</span><span class="s3">\n                </span><span class="s1">couldBeIntercepted: initialRSCPayload.i,</span><span class="s3">\n                </span><span class="s1">postponed: initialRSCPayload.s,</span><span class="s3">\n                </span><span class="s1">prerendered: initialRSCPayload.S,</span><span class="s3">\n              </span><span class="s1">}),</span><span class="s3">\n              </span><span class="s1">instrumentationHooks</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">(err: Error) =&gt; reject(err)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const reactEl = (</span><span class="s3">\n    </span><span class="s1">&lt;StrictModeIfEnabled&gt;</span><span class="s3">\n      </span><span class="s1">&lt;HeadManagerContext.Provider value={{ appDir: true }}&gt;</span><span class="s3">\n        </span><span class="s1">&lt;Root&gt;</span><span class="s3">\n          </span><span class="s1">&lt;ServerRoot pendingActionQueue={pendingActionQueue} /&gt;</span><span class="s3">\n        </span><span class="s1">&lt;/Root&gt;</span><span class="s3">\n      </span><span class="s1">&lt;/HeadManagerContext.Provider&gt;</span><span class="s3">\n    </span><span class="s1">&lt;/StrictModeIfEnabled&gt;</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (document.documentElement.id === '__next_error__') {</span><span class="s3">\n    </span><span class="s1">let element = reactEl</span><span class="s3">\n    </span><span class="s1">// Server rendering failed, fall back to client-side rendering</span><span class="s3">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n      </span><span class="s1">const { RootLevelDevOverlayElement } =</span><span class="s3">\n        </span><span class="s1">require('../next-devtools/userspace/app/client-entry') as typeof import('../next-devtools/userspace/app/client-entry')</span><span class="s3">\n\n      </span><span class="s1">// Note this won't cause hydration mismatch because we are doing CSR w/o hydration</span><span class="s3">\n      </span><span class="s1">element = (</span><span class="s3">\n        </span><span class="s1">&lt;RootLevelDevOverlayElement&gt;{element}&lt;/RootLevelDevOverlayElement&gt;</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">ReactDOMClient.createRoot(appElement, reactRootOptions).render(element)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">React.startTransition(() =&gt; {</span><span class="s3">\n      </span><span class="s1">ReactDOMClient.hydrateRoot(appElement, reactEl, {</span><span class="s3">\n        </span><span class="s1">...reactRootOptions,</span><span class="s3">\n        </span><span class="s1">formState: initialFormStateData,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// TODO-APP: Remove this logic when Float has GC built-in in development.</span><span class="s3">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n    </span><span class="s1">const { linkGc } =</span><span class="s3">\n      </span><span class="s1">require('./app-link-gc') as typeof import('./app-link-gc')</span><span class="s3">\n    </span><span class="s1">linkGc()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;hydrate&quot;</span><span class="s0">,</span><span class="s1">&quot;createFromReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;createFromReadableStreamBrowser&quot;</span><span class="s0">,</span><span class="s1">&quot;appElement&quot;</span><span class="s0">,</span><span class="s1">&quot;document&quot;</span><span class="s0">,</span><span class="s1">&quot;encoder&quot;</span><span class="s0">,</span><span class="s1">&quot;TextEncoder&quot;</span><span class="s0">,</span><span class="s1">&quot;initialServerDataBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;initialServerDataWriter&quot;</span><span class="s0">,</span><span class="s1">&quot;initialServerDataLoaded&quot;</span><span class="s0">,</span><span class="s1">&quot;initialServerDataFlushed&quot;</span><span class="s0">,</span><span class="s1">&quot;initialFormStateData&quot;</span><span class="s0">,</span><span class="s1">&quot;nextServerDataCallback&quot;</span><span class="s0">,</span><span class="s1">&quot;seg&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;enqueue&quot;</span><span class="s0">,</span><span class="s1">&quot;encode&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;binaryString&quot;</span><span class="s0">,</span><span class="s1">&quot;atob&quot;</span><span class="s0">,</span><span class="s1">&quot;decodedChunk&quot;</span><span class="s0">,</span><span class="s1">&quot;Uint8Array&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;charCodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;isStreamErrorOrUnfinished&quot;</span><span class="s0">,</span><span class="s1">&quot;ctr&quot;</span><span class="s0">,</span><span class="s1">&quot;desiredSize&quot;</span><span class="s0">,</span><span class="s1">&quot;nextServerDataRegisterWriter&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;val&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;close&quot;</span><span class="s0">,</span><span class="s1">&quot;DOMContentLoaded&quot;</span><span class="s0">,</span><span class="s1">&quot;readyState&quot;</span><span class="s0">,</span><span class="s1">&quot;addEventListener&quot;</span><span class="s0">,</span><span class="s1">&quot;setTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;nextServerDataLoadingGlobal&quot;</span><span class="s0">,</span><span class="s1">&quot;self&quot;</span><span class="s0">,</span><span class="s1">&quot;__next_f&quot;</span><span class="s0">,</span><span class="s1">&quot;readable&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;controller&quot;</span><span class="s0">,</span><span class="s1">&quot;initialServerResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;callServer&quot;</span><span class="s0">,</span><span class="s1">&quot;findSourceMapURL&quot;</span><span class="s0">,</span><span class="s1">&quot;ServerRoot&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingActionQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;initialRSCPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;use&quot;</span><span class="s0">,</span><span class="s1">&quot;actionQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;router&quot;</span><span class="s0">,</span><span class="s1">&quot;AppRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;globalErrorState&quot;</span><span class="s0">,</span><span class="s1">&quot;G&quot;</span><span class="s0">,</span><span class="s1">&quot;assetPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;p&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;m&quot;</span><span class="s0">,</span><span class="s1">&quot;MissingSlotContext&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;StrictModeIfEnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_STRICT_MODE_APP&quot;</span><span class="s0">,</span><span class="s1">&quot;React&quot;</span><span class="s0">,</span><span class="s1">&quot;StrictMode&quot;</span><span class="s0">,</span><span class="s1">&quot;Fragment&quot;</span><span class="s0">,</span><span class="s1">&quot;Root&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_TEST_MODE&quot;</span><span class="s0">,</span><span class="s1">&quot;useEffect&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_HYDRATED&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_HYDRATED_AT&quot;</span><span class="s0">,</span><span class="s1">&quot;performance&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_HYDRATED_CB&quot;</span><span class="s0">,</span><span class="s1">&quot;onDefaultTransitionIndicator&quot;</span><span class="s0">,</span><span class="s1">&quot;reactRootOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;onRecoverableError&quot;</span><span class="s0">,</span><span class="s1">&quot;onCaughtError&quot;</span><span class="s0">,</span><span class="s1">&quot;onUncaughtError&quot;</span><span class="s0">,</span><span class="s1">&quot;instrumentationHooks&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;setAppBuildId&quot;</span><span class="s0">,</span><span class="s1">&quot;b&quot;</span><span class="s0">,</span><span class="s1">&quot;initialTimestamp&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;createMutableActionQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;createInitialRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;navigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;initialFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;f&quot;</span><span class="s0">,</span><span class="s1">&quot;initialCanonicalUrlParts&quot;</span><span class="s0">,</span><span class="s1">&quot;c&quot;</span><span class="s0">,</span><span class="s1">&quot;initialParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;couldBeIntercepted&quot;</span><span class="s0">,</span><span class="s1">&quot;postponed&quot;</span><span class="s0">,</span><span class="s1">&quot;s&quot;</span><span class="s0">,</span><span class="s1">&quot;prerendered&quot;</span><span class="s0">,</span><span class="s1">&quot;S&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;reactEl&quot;</span><span class="s0">,</span><span class="s1">&quot;HeadManagerContext&quot;</span><span class="s0">,</span><span class="s1">&quot;Provider&quot;</span><span class="s0">,</span><span class="s1">&quot;appDir&quot;</span><span class="s0">,</span><span class="s1">&quot;documentElement&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;element&quot;</span><span class="s0">,</span><span class="s1">&quot;RootLevelDevOverlayElement&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;ReactDOMClient&quot;</span><span class="s0">,</span><span class="s1">&quot;createRoot&quot;</span><span class="s0">,</span><span class="s1">&quot;render&quot;</span><span class="s0">,</span><span class="s1">&quot;startTransition&quot;</span><span class="s0">,</span><span class="s1">&quot;hydrateRoot&quot;</span><span class="s0">,</span><span class="s1">&quot;formState&quot;</span><span class="s0">,</span><span class="s1">&quot;linkGc&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">9985</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/next/src/client/app-next-turbopack.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { appBootstrap } from './app-bootstrap'</span><span class="s3">\n</span><span class="s1">import { isRecoverableError } from './react-client-callbacks/on-recoverable-error'</span><span class="s3">\n\n</span><span class="s1">window.next.turbopack = true</span><span class="s3">\n</span><span class="s1">;(self as any).__webpack_hash__ = ''</span><span class="s3">\n\n</span><span class="s1">// eslint-disable-next-line @next/internal/typechecked-require</span><span class="s3">\n</span><span class="s1">const instrumentationHooks = require('../lib/require-instrumentation-client')</span><span class="s3">\n\n</span><span class="s1">appBootstrap(() =&gt; {</span><span class="s3">\n  </span><span class="s1">const { hydrate } = require('./app-index') as typeof import('./app-index')</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">hydrate(instrumentationHooks)</span><span class="s3">\n  </span><span class="s1">} finally {</span><span class="s3">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n      </span><span class="s1">const { getOwnerStack } =</span><span class="s3">\n        </span><span class="s1">require('../next-devtools/userspace/app/errors/stitched-error') as typeof import('../next-devtools/userspace/app/errors/stitched-error')</span><span class="s3">\n      </span><span class="s1">const { renderAppDevOverlay } =</span><span class="s3">\n        </span><span class="s1">require('next/dist/compiled/next-devtools') as typeof import('next/dist/compiled/next-devtools')</span><span class="s3">\n      </span><span class="s1">renderAppDevOverlay(getOwnerStack, isRecoverableError)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">})</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;turbopack&quot;</span><span class="s0">,</span><span class="s1">&quot;self&quot;</span><span class="s0">,</span><span class="s1">&quot;__webpack_hash__&quot;</span><span class="s0">,</span><span class="s1">&quot;instrumentationHooks&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;appBootstrap&quot;</span><span class="s0">,</span><span class="s1">&quot;hydrate&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;getOwnerStack&quot;</span><span class="s0">,</span><span class="s1">&quot;renderAppDevOverlay&quot;</span><span class="s0">,</span><span class="s1">&quot;isRecoverableError&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAcQS,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;8BAdJ;oCACM;AAEnCX,OAAOC,IAAI,CAACC,SAAS,GAAG;AACtBC,KAAaC,gBAAgB,GAAG;AAElC,8DAA8D;AAC9D,MAAMC,uBAAuBC,QAAQ;AAErCC,CAAAA,GAAAA,cAAAA,YAAY,EAAC;IACX,MAAM,EAAEC,OAAO,EAAE,GAAGF,QAAQ;IAC5B,IAAI;QACFE,QAAQH;IACV,SAAU;QACR,wCAA2C;YACzC,MAAM,EAAEO,aAAa,EAAE,GACrBN,QAAQ;YACV,MAAM,EAAEO,mBAAmB,EAAE,GAC3BP,QAAQ;YACVO,oBAAoBD,eAAeE,oBAAAA,kBAAkB;QACvD;IACF;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}}]</span>
<span class="s0">}</span></pre>
</body>
</html>