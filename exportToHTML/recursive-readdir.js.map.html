<html>
<head>
<title>recursive-readdir.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
recursive-readdir.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/lib/recursive-readdir.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import fs from 'fs/promises'</span><span class="s3">\n</span><span class="s1">import path from 'path'</span><span class="s3">\n\n</span><span class="s1">type Filter = (pathname: string) =&gt; boolean</span><span class="s3">\n\n</span><span class="s1">type Result = {</span><span class="s3">\n  </span><span class="s1">directories: string[]</span><span class="s3">\n  </span><span class="s1">pathnames: string[]</span><span class="s3">\n  </span><span class="s1">links: string[]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RecursiveReadDirOptions = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Filter to ignore files with absolute pathnames, false to ignore.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pathnameFilter?: Filter</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Filter to ignore files and directories with absolute pathnames, false to</span><span class="s3">\n   </span><span class="s1">* ignore.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">ignoreFilter?: Filter</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Filter to ignore files and directories with the pathname part, false to</span><span class="s3">\n   </span><span class="s1">* ignore.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">ignorePartFilter?: Filter</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to sort the results, true by default.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">sortPathnames?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to return relative pathnames, true by default.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">relativePathnames?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Recursively reads a directory and returns the list of pathnames.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param rootDirectory the directory to read</span><span class="s3">\n </span><span class="s1">* @param options options to control the behavior of the recursive read</span><span class="s3">\n </span><span class="s1">* @returns the list of pathnames</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export async function recursiveReadDir(</span><span class="s3">\n  </span><span class="s1">rootDirectory: string,</span><span class="s3">\n  </span><span class="s1">options: RecursiveReadDirOptions = {}</span><span class="s3">\n</span><span class="s1">): Promise&lt;string[]&gt; {</span><span class="s3">\n  </span><span class="s1">// Grab our options.</span><span class="s3">\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">pathnameFilter,</span><span class="s3">\n    </span><span class="s1">ignoreFilter,</span><span class="s3">\n    </span><span class="s1">ignorePartFilter,</span><span class="s3">\n    </span><span class="s1">sortPathnames = true,</span><span class="s3">\n    </span><span class="s1">relativePathnames = true,</span><span class="s3">\n  </span><span class="s1">} = options</span><span class="s3">\n\n  </span><span class="s1">// The list of pathnames to return.</span><span class="s3">\n  </span><span class="s1">const pathnames: string[] = []</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Coerces the pathname to be relative if requested.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const coerce = relativePathnames</span><span class="s3">\n    </span><span class="s1">? (pathname: string) =&gt; pathname.replace(rootDirectory, '')</span><span class="s3">\n    </span><span class="s1">: (pathname: string) =&gt; pathname</span><span class="s3">\n\n  </span><span class="s1">// The queue of directories to scan.</span><span class="s3">\n  </span><span class="s1">let directories: string[] = [rootDirectory]</span><span class="s3">\n\n  </span><span class="s1">while (directories.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">// Load all the files in each directory at the same time.</span><span class="s3">\n    </span><span class="s1">const results = await Promise.all(</span><span class="s3">\n      </span><span class="s1">directories.map(async (directory) =&gt; {</span><span class="s3">\n        </span><span class="s1">const result: Result = { directories: [], pathnames: [], links: [] }</span><span class="s3">\n\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">const dir = await fs.readdir(directory, { withFileTypes: true })</span><span class="s3">\n          </span><span class="s1">for (const file of dir) {</span><span class="s3">\n            </span><span class="s1">// If enabled, ignore the file if it matches the ignore filter.</span><span class="s3">\n            </span><span class="s1">if (ignorePartFilter &amp;&amp; ignorePartFilter(file.name)) {</span><span class="s3">\n              </span><span class="s1">continue</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// Handle each file.</span><span class="s3">\n            </span><span class="s1">const absolutePathname = path.join(directory, file.name)</span><span class="s3">\n\n            </span><span class="s1">// If enabled, ignore the file if it matches the ignore filter.</span><span class="s3">\n            </span><span class="s1">if (ignoreFilter &amp;&amp; ignoreFilter(absolutePathname)) {</span><span class="s3">\n              </span><span class="s1">continue</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// If the file is a directory, then add it to the list of directories,</span><span class="s3">\n            </span><span class="s1">// they'll be scanned on a later pass.</span><span class="s3">\n            </span><span class="s1">if (file.isDirectory()) {</span><span class="s3">\n              </span><span class="s1">result.directories.push(absolutePathname)</span><span class="s3">\n            </span><span class="s1">} else if (file.isSymbolicLink()) {</span><span class="s3">\n              </span><span class="s1">result.links.push(absolutePathname)</span><span class="s3">\n            </span><span class="s1">} else if (!pathnameFilter || pathnameFilter(absolutePathname)) {</span><span class="s3">\n              </span><span class="s1">result.pathnames.push(coerce(absolutePathname))</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} catch (err: any) {</span><span class="s3">\n          </span><span class="s1">// This can only happen when the underlying directory was removed. If</span><span class="s3">\n          </span><span class="s1">// anything other than this error occurs, re-throw it.</span><span class="s3">\n          </span><span class="s1">// if (err.code !== 'ENOENT') throw err</span><span class="s3">\n          </span><span class="s1">if (err.code !== 'ENOENT' || directory === rootDirectory) throw err</span><span class="s3">\n\n          </span><span class="s1">// The error occurred, so abandon reading this directory.</span><span class="s3">\n          </span><span class="s1">return null</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return result</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">// Empty the directories, we'll fill it later if some of the files are</span><span class="s3">\n    </span><span class="s1">// directories.</span><span class="s3">\n    </span><span class="s1">directories = []</span><span class="s3">\n\n    </span><span class="s1">// Keep track of any symbolic links we find, we'll resolve them later.</span><span class="s3">\n    </span><span class="s1">const links = []</span><span class="s3">\n\n    </span><span class="s1">// For each result of directory scans...</span><span class="s3">\n    </span><span class="s1">for (const result of results) {</span><span class="s3">\n      </span><span class="s1">// If the directory was removed, then skip it.</span><span class="s3">\n      </span><span class="s1">if (!result) continue</span><span class="s3">\n\n      </span><span class="s1">// Add any directories to the list of directories to scan.</span><span class="s3">\n      </span><span class="s1">directories.push(...result.directories)</span><span class="s3">\n\n      </span><span class="s1">// Add any symbolic links to the list of symbolic links to resolve.</span><span class="s3">\n      </span><span class="s1">links.push(...result.links)</span><span class="s3">\n\n      </span><span class="s1">// Add any file pathnames to the list of pathnames.</span><span class="s3">\n      </span><span class="s1">pathnames.push(...result.pathnames)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Resolve all the symbolic links we found if any.</span><span class="s3">\n    </span><span class="s1">if (links.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">const resolved = await Promise.all(</span><span class="s3">\n        </span><span class="s1">links.map(async (absolutePathname) =&gt; {</span><span class="s3">\n          </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">return await fs.stat(absolutePathname)</span><span class="s3">\n          </span><span class="s1">} catch (err: any) {</span><span class="s3">\n            </span><span class="s1">// This can only happen when the underlying link was removed. If</span><span class="s3">\n            </span><span class="s1">// anything other than this error occurs, re-throw it.</span><span class="s3">\n            </span><span class="s1">if (err.code !== 'ENOENT') throw err</span><span class="s3">\n\n            </span><span class="s1">// The error occurred, so abandon reading this directory.</span><span class="s3">\n            </span><span class="s1">return null</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">for (let i = 0; i &lt; links.length; i++) {</span><span class="s3">\n        </span><span class="s1">const stats = resolved[i]</span><span class="s3">\n\n        </span><span class="s1">// If the link was removed, then skip it.</span><span class="s3">\n        </span><span class="s1">if (!stats) continue</span><span class="s3">\n\n        </span><span class="s1">// We would have already ignored the file if it matched the ignore</span><span class="s3">\n        </span><span class="s1">// filter, so we don't need to check it again.</span><span class="s3">\n        </span><span class="s1">const absolutePathname = links[i]</span><span class="s3">\n\n        </span><span class="s1">if (stats.isDirectory()) {</span><span class="s3">\n          </span><span class="s1">directories.push(absolutePathname)</span><span class="s3">\n        </span><span class="s1">} else if (!pathnameFilter || pathnameFilter(absolutePathname)) {</span><span class="s3">\n          </span><span class="s1">pathnames.push(coerce(absolutePathname))</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Sort the pathnames in place if requested.</span><span class="s3">\n  </span><span class="s1">if (sortPathnames) {</span><span class="s3">\n    </span><span class="s1">pathnames.sort()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return pathnames</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;recursiveReadDir&quot;</span><span class="s0">,</span><span class="s1">&quot;rootDirectory&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;pathnameFilter&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreFilter&quot;</span><span class="s0">,</span><span class="s1">&quot;ignorePartFilter&quot;</span><span class="s0">,</span><span class="s1">&quot;sortPathnames&quot;</span><span class="s0">,</span><span class="s1">&quot;relativePathnames&quot;</span><span class="s0">,</span><span class="s1">&quot;pathnames&quot;</span><span class="s0">,</span><span class="s1">&quot;coerce&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;directories&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;results&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;all&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;directory&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;links&quot;</span><span class="s0">,</span><span class="s1">&quot;dir&quot;</span><span class="s0">,</span><span class="s1">&quot;fs&quot;</span><span class="s0">,</span><span class="s1">&quot;readdir&quot;</span><span class="s0">,</span><span class="s1">&quot;withFileTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;absolutePathname&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;isDirectory&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;isSymbolicLink&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;resolved&quot;</span><span class="s0">,</span><span class="s1">&quot;stat&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;stats&quot;</span><span class="s0">,</span><span class="s1">&quot;sort&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>