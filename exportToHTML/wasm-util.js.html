<html>
<head>
<title>wasm-util.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #0033b3;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #8c8c8c; font-style: italic;}
.s6 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
wasm-util.js</font>
</center></td></tr></table>
<pre><span class="s0">(</span><span class="s1">function </span><span class="s0">(global, factory) {</span>
    <span class="s1">typeof </span><span class="s0">exports === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">module !== </span><span class="s2">'undefined' </span><span class="s0">? factory(exports) :</span>
    <span class="s1">typeof </span><span class="s0">define === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; define.amd ? define([</span><span class="s2">'exports'</span><span class="s0">], factory) :</span>
    <span class="s0">(global = </span><span class="s1">typeof </span><span class="s0">globalThis !== </span><span class="s2">'undefined' </span><span class="s0">? globalThis : global || self, factory(global.wasmUtil = {}));</span>
<span class="s0">})(</span><span class="s1">this</span><span class="s0">, (</span><span class="s1">function </span><span class="s0">(exports) { </span><span class="s2">'use strict'</span><span class="s0">;</span>

    <span class="s1">const </span><span class="s0">_WebAssembly = </span><span class="s1">typeof </span><span class="s0">WebAssembly !== </span><span class="s2">'undefined'</span>
        <span class="s0">? WebAssembly</span>
        <span class="s0">: </span><span class="s1">typeof </span><span class="s0">WXWebAssembly !== </span><span class="s2">'undefined'</span>
            <span class="s0">? WXWebAssembly</span>
            <span class="s0">: undefined;</span>
    <span class="s1">if </span><span class="s0">(!_WebAssembly) {</span>
        <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'WebAssembly is not supported in this environment'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s3">/* eslint-disable spaced-comment */</span>

    <span class="s1">function </span><span class="s0">validateObject(value, name) {</span>
        <span class="s1">if </span><span class="s0">(value === </span><span class="s1">null </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">value !== </span><span class="s2">'object'</span><span class="s0">) {</span>
            <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">`</span><span class="s0">${name} </span><span class="s2">must be an object. Received </span><span class="s0">${value === </span><span class="s1">null </span><span class="s0">? </span><span class="s2">'null' </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">value}</span><span class="s2">`</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">validateArray(value, name) {</span>
        <span class="s1">if </span><span class="s0">(!Array.isArray(value)) {</span>
            <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">`</span><span class="s0">${name} </span><span class="s2">must be an array. Received </span><span class="s0">${value === </span><span class="s1">null </span><span class="s0">? </span><span class="s2">'null' </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">value}</span><span class="s2">`</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">validateBoolean(value, name) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">value !== </span><span class="s2">'boolean'</span><span class="s0">) {</span>
            <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">`</span><span class="s0">${name} </span><span class="s2">must be a boolean. Received </span><span class="s0">${value === </span><span class="s1">null </span><span class="s0">? </span><span class="s2">'null' </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">value}</span><span class="s2">`</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">validateString(value, name) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">value !== </span><span class="s2">'string'</span><span class="s0">) {</span>
            <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">`</span><span class="s0">${name} </span><span class="s2">must be a string. Received </span><span class="s0">${value === </span><span class="s1">null </span><span class="s0">? </span><span class="s2">'null' </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">value}</span><span class="s2">`</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">validateFunction(value, name) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">value !== </span><span class="s2">'function'</span><span class="s0">) {</span>
            <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">`</span><span class="s0">${name} </span><span class="s2">must be a function. Received </span><span class="s0">${value === </span><span class="s1">null </span><span class="s0">? </span><span class="s2">'null' </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">value}</span><span class="s2">`</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">validateUndefined(value, name) {</span>
        <span class="s1">if </span><span class="s0">(value !== undefined) {</span>
            <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">`</span><span class="s0">${name} </span><span class="s2">must be undefined. Received </span><span class="s0">${value === </span><span class="s1">null </span><span class="s0">? </span><span class="s2">'null' </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">value}</span><span class="s2">`</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">isPromiseLike(obj) {</span>
        <span class="s1">return </span><span class="s0">!!(obj &amp;&amp; (</span><span class="s1">typeof </span><span class="s0">obj === </span><span class="s2">'object' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">obj === </span><span class="s2">'function'</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">obj.then === </span><span class="s2">'function'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">wrapInstanceExports(exports, mapFn) {</span>
        <span class="s1">const </span><span class="s0">newExports = Object.create(</span><span class="s1">null</span><span class="s0">);</span>
        <span class="s0">Object.keys(exports).forEach(name =&gt; {</span>
            <span class="s1">const </span><span class="s0">exportValue = exports[name];</span>
            <span class="s0">Object.defineProperty(newExports, name, {</span>
                <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
                <span class="s0">value: mapFn(exportValue, name)</span>
            <span class="s0">});</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">newExports;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">sleepBreakIf(delay, breakIf) {</span>
        <span class="s1">const </span><span class="s0">start = Date.now();</span>
        <span class="s1">const </span><span class="s0">end = start + delay;</span>
        <span class="s1">let </span><span class="s0">ret = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">while </span><span class="s0">(Date.now() &lt; end) {</span>
            <span class="s1">if </span><span class="s0">(breakIf()) {</span>
                <span class="s0">ret = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">ret;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">unsharedSlice(view, start, end) {</span>
        <span class="s1">return </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">SharedArrayBuffer === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; view.buffer </span><span class="s1">instanceof </span><span class="s0">SharedArrayBuffer) || (Object.prototype.toString.call(view.buffer.constructor) === </span><span class="s2">'[object SharedArrayBuffer]'</span><span class="s0">))</span>
            <span class="s0">? view.slice(start, end)</span>
            <span class="s0">: view.subarray(start, end);</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">ignoreNames = [</span>
        <span class="s2">'asyncify_get_state'</span><span class="s0">,</span>
        <span class="s2">'asyncify_start_rewind'</span><span class="s0">,</span>
        <span class="s2">'asyncify_start_unwind'</span><span class="s0">,</span>
        <span class="s2">'asyncify_stop_rewind'</span><span class="s0">,</span>
        <span class="s2">'asyncify_stop_unwind'</span>
    <span class="s0">];</span>
    <span class="s1">function </span><span class="s0">tryAllocate(instance, wasm64, size, mallocName) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">instance.exports[mallocName] !== </span><span class="s2">'function' </span><span class="s0">|| size &lt;= </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">wasm64,</span>
                <span class="s0">dataPtr: </span><span class="s4">16</span><span class="s0">,</span>
                <span class="s0">start: wasm64 ? </span><span class="s4">32 </span><span class="s0">: </span><span class="s4">24</span><span class="s0">,</span>
                <span class="s0">end: </span><span class="s4">1024</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">malloc = instance.exports[mallocName];</span>
        <span class="s1">const </span><span class="s0">dataPtr = wasm64 ? Number(malloc(BigInt(</span><span class="s4">16</span><span class="s0">) + BigInt(size))) : malloc(</span><span class="s4">8 </span><span class="s0">+ size);</span>
        <span class="s1">if </span><span class="s0">(dataPtr === </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Allocate asyncify data failed'</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">wasm64</span>
            <span class="s0">? { wasm64, dataPtr, start: dataPtr + </span><span class="s4">16</span><span class="s0">, end: dataPtr + </span><span class="s4">16 </span><span class="s0">+ size }</span>
            <span class="s0">: { wasm64, dataPtr, start: dataPtr + </span><span class="s4">8</span><span class="s0">, end: dataPtr + </span><span class="s4">8 </span><span class="s0">+ size };</span>
    <span class="s0">}</span>
    <span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
    <span class="s1">class </span><span class="s0">Asyncify {</span>
        <span class="s0">constructor() {</span>
            <span class="s1">this</span><span class="s0">.value = undefined;</span>
            <span class="s1">this</span><span class="s0">.exports = undefined;</span>
            <span class="s1">this</span><span class="s0">.dataPtr = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">init(memory, instance, options) {</span>
            <span class="s1">var </span><span class="s0">_a, _b;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.exports) {</span>
                <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Asyncify has been initialized'</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(!(memory </span><span class="s1">instanceof </span><span class="s0">_WebAssembly.Memory)) {</span>
                <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'Require WebAssembly.Memory object'</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">exports = instance.exports;</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; ignoreNames.length; ++i) {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">exports[ignoreNames[i]] !== </span><span class="s2">'function'</span><span class="s0">) {</span>
                    <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'Invalid asyncify wasm'</span><span class="s0">);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">let </span><span class="s0">address;</span>
            <span class="s1">const </span><span class="s0">wasm64 = Boolean(options.wasm64);</span>
            <span class="s1">if </span><span class="s0">(!options.tryAllocate) {</span>
                <span class="s0">address = {</span>
                    <span class="s0">wasm64,</span>
                    <span class="s0">dataPtr: </span><span class="s4">16</span><span class="s0">,</span>
                    <span class="s0">start: wasm64 ? </span><span class="s4">32 </span><span class="s0">: </span><span class="s4">24</span><span class="s0">,</span>
                    <span class="s0">end: </span><span class="s4">1024</span>
                <span class="s0">};</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">if </span><span class="s0">(options.tryAllocate === </span><span class="s1">true</span><span class="s0">) {</span>
                    <span class="s0">address = tryAllocate(instance, wasm64, </span><span class="s4">4096</span><span class="s0">, </span><span class="s2">'malloc'</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">address = tryAllocate(instance, wasm64, (_a = options.tryAllocate.size) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _a !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _a : </span><span class="s4">4096</span><span class="s0">, (_b = options.tryAllocate.name) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _b !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _b : </span><span class="s2">'malloc'</span><span class="s0">);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.dataPtr = address.dataPtr;</span>
            <span class="s1">if </span><span class="s0">(wasm64) {</span>
                <span class="s1">new </span><span class="s0">BigInt64Array(memory.buffer, </span><span class="s1">this</span><span class="s0">.dataPtr).set([BigInt(address.start), BigInt(address.end)]);</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">new </span><span class="s0">Int32Array(memory.buffer, </span><span class="s1">this</span><span class="s0">.dataPtr).set([address.start, address.end]);</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.exports = </span><span class="s1">this</span><span class="s0">.wrapExports(exports, options.wrapExports);</span>
            <span class="s1">const </span><span class="s0">asyncifiedInstance = Object.create(_WebAssembly.Instance.prototype);</span>
            <span class="s0">Object.defineProperty(asyncifiedInstance, </span><span class="s2">'exports'</span><span class="s0">, { value: </span><span class="s1">this</span><span class="s0">.exports });</span>
            <span class="s3">// Object.setPrototypeOf(instance, Instance.prototype)</span>
            <span class="s1">return </span><span class="s0">asyncifiedInstance;</span>
        <span class="s0">}</span>
        <span class="s0">assertState() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.exports.asyncify_get_state() !== </span><span class="s4">0 </span><span class="s3">/* AsyncifyState.NONE */</span><span class="s0">) {</span>
                <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Asyncify state error'</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">wrapImportFunction(f) {</span>
            <span class="s3">// eslint-disable-next-line @typescript-eslint/no-this-alias</span>
            <span class="s1">const </span><span class="s0">_this = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">(</span><span class="s1">function </span><span class="s0">() {</span>
                <span class="s3">// eslint-disable-next-line no-unreachable-loop</span>
                <span class="s1">while </span><span class="s0">(_this.exports.asyncify_get_state() === </span><span class="s4">2 </span><span class="s3">/* AsyncifyState.REWINDING */</span><span class="s0">) {</span>
                    <span class="s0">_this.exports.asyncify_stop_rewind();</span>
                    <span class="s1">return </span><span class="s0">_this.value;</span>
                <span class="s0">}</span>
                <span class="s0">_this.assertState();</span>
                <span class="s1">const </span><span class="s0">v = f.apply(</span><span class="s1">this</span><span class="s0">, arguments);</span>
                <span class="s1">if </span><span class="s0">(!isPromiseLike(v))</span>
                    <span class="s1">return </span><span class="s0">v;</span>
                <span class="s0">_this.exports.asyncify_start_unwind(_this.dataPtr);</span>
                <span class="s0">_this.value = v;</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s0">wrapImports(imports) {</span>
            <span class="s1">const </span><span class="s0">importObject = {};</span>
            <span class="s0">Object.keys(imports).forEach(k =&gt; {</span>
                <span class="s1">const </span><span class="s0">mod = imports[k];</span>
                <span class="s1">const </span><span class="s0">newModule = {};</span>
                <span class="s0">Object.keys(mod).forEach(name =&gt; {</span>
                    <span class="s1">const </span><span class="s0">importValue = mod[name];</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">importValue === </span><span class="s2">'function'</span><span class="s0">) {</span>
                        <span class="s0">newModule[name] = </span><span class="s1">this</span><span class="s0">.wrapImportFunction(importValue);</span>
                    <span class="s0">}</span>
                    <span class="s1">else </span><span class="s0">{</span>
                        <span class="s0">newModule[name] = importValue;</span>
                    <span class="s0">}</span>
                <span class="s0">});</span>
                <span class="s0">importObject[k] = newModule;</span>
            <span class="s0">});</span>
            <span class="s1">return </span><span class="s0">importObject;</span>
        <span class="s0">}</span>
        <span class="s0">wrapExportFunction(f) {</span>
            <span class="s3">// eslint-disable-next-line @typescript-eslint/no-this-alias</span>
            <span class="s1">const </span><span class="s0">_this = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">(async </span><span class="s1">function </span><span class="s0">() {</span>
                <span class="s0">_this.assertState();</span>
                <span class="s1">let </span><span class="s0">ret = f.apply(</span><span class="s1">this</span><span class="s0">, arguments);</span>
                <span class="s1">while </span><span class="s0">(_this.exports.asyncify_get_state() === </span><span class="s4">1 </span><span class="s3">/* AsyncifyState.UNWINDING */</span><span class="s0">) {</span>
                    <span class="s0">_this.exports.asyncify_stop_unwind();</span>
                    <span class="s0">_this.value = </span><span class="s1">await </span><span class="s0">_this.value;</span>
                    <span class="s0">_this.assertState();</span>
                    <span class="s0">_this.exports.asyncify_start_rewind(_this.dataPtr);</span>
                    <span class="s0">ret = f.call(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s0">_this.assertState();</span>
                <span class="s1">return </span><span class="s0">ret;</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s0">wrapExports(exports, needWrap) {</span>
            <span class="s1">return </span><span class="s0">wrapInstanceExports(exports, (exportValue, name) =&gt; {</span>
                <span class="s1">let </span><span class="s0">ignore = ignoreNames.indexOf(name) !== -</span><span class="s4">1 </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exportValue !== </span><span class="s2">'function'</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(Array.isArray(needWrap)) {</span>
                    <span class="s0">ignore = ignore || (needWrap.indexOf(name) === -</span><span class="s4">1</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">ignore ? exportValue : </span><span class="s1">this</span><span class="s0">.wrapExportFunction(exportValue);</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">validateImports(imports) {</span>
        <span class="s1">if </span><span class="s0">(imports &amp;&amp; </span><span class="s1">typeof </span><span class="s0">imports !== </span><span class="s2">'object'</span><span class="s0">) {</span>
            <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'imports must be an object or undefined'</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">fetchWasm(urlOrBuffer, imports) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">wx !== </span><span class="s2">'undefined' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">__wxConfig !== </span><span class="s2">'undefined'</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">_WebAssembly.instantiate(urlOrBuffer, imports);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">fetch(urlOrBuffer)</span>
            <span class="s0">.then(response =&gt; response.arrayBuffer())</span>
            <span class="s0">.then(buffer =&gt; _WebAssembly.instantiate(buffer, imports));</span>
    <span class="s0">}</span>
    <span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">load(wasmInput, imports) {</span>
        <span class="s0">validateImports(imports);</span>
        <span class="s0">imports = imports !== </span><span class="s1">null </span><span class="s0">&amp;&amp; imports !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? imports : {};</span>
        <span class="s1">let </span><span class="s0">source;</span>
        <span class="s1">if </span><span class="s0">(wasmInput </span><span class="s1">instanceof </span><span class="s0">ArrayBuffer || ArrayBuffer.isView(wasmInput)) {</span>
            <span class="s1">return </span><span class="s0">_WebAssembly.instantiate(wasmInput, imports);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(wasmInput </span><span class="s1">instanceof </span><span class="s0">_WebAssembly.Module) {</span>
            <span class="s1">return </span><span class="s0">_WebAssembly.instantiate(wasmInput, imports).then((instance) =&gt; {</span>
                <span class="s1">return </span><span class="s0">{ instance, module: wasmInput };</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">wasmInput !== </span><span class="s2">'string' </span><span class="s0">&amp;&amp; !(wasmInput </span><span class="s1">instanceof </span><span class="s0">URL)) {</span>
            <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'Invalid source'</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">_WebAssembly.instantiateStreaming === </span><span class="s2">'function'</span><span class="s0">) {</span>
            <span class="s1">let </span><span class="s0">responsePromise;</span>
            <span class="s1">try </span><span class="s0">{</span>
                <span class="s0">responsePromise = fetch(wasmInput);</span>
                <span class="s0">source = _WebAssembly.instantiateStreaming(responsePromise, imports).catch(() =&gt; {</span>
                    <span class="s1">return </span><span class="s0">fetchWasm(wasmInput, imports);</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s1">catch </span><span class="s0">(_) {</span>
                <span class="s0">source = fetchWasm(wasmInput, imports);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s0">source = fetchWasm(wasmInput, imports);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">source;</span>
    <span class="s0">}</span>
    <span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">asyncifyLoad(asyncify, urlOrBuffer, imports) {</span>
        <span class="s0">validateImports(imports);</span>
        <span class="s0">imports = imports !== </span><span class="s1">null </span><span class="s0">&amp;&amp; imports !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? imports : {};</span>
        <span class="s1">const </span><span class="s0">asyncifyHelper = </span><span class="s1">new </span><span class="s0">Asyncify();</span>
        <span class="s0">imports = asyncifyHelper.wrapImports(imports);</span>
        <span class="s1">return </span><span class="s0">load(urlOrBuffer, imports).then(source =&gt; {</span>
            <span class="s1">var </span><span class="s0">_a;</span>
            <span class="s1">const </span><span class="s0">memory = source.instance.exports.memory || ((_a = imports.env) === </span><span class="s1">null </span><span class="s0">|| _a === </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: _a.memory);</span>
            <span class="s1">return </span><span class="s0">{ module: source.module, instance: asyncifyHelper.init(memory, source.instance, asyncify) };</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">loadSync(wasmInput, imports) {</span>
        <span class="s0">validateImports(imports);</span>
        <span class="s0">imports = imports !== </span><span class="s1">null </span><span class="s0">&amp;&amp; imports !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? imports : {};</span>
        <span class="s1">let </span><span class="s0">module;</span>
        <span class="s1">if </span><span class="s0">((wasmInput </span><span class="s1">instanceof </span><span class="s0">ArrayBuffer) || ArrayBuffer.isView(wasmInput)) {</span>
            <span class="s0">module = </span><span class="s1">new </span><span class="s0">_WebAssembly.Module(wasmInput);</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(wasmInput </span><span class="s1">instanceof </span><span class="s0">WebAssembly.Module) {</span>
            <span class="s0">module = wasmInput;</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'Invalid source'</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">instance = </span><span class="s1">new </span><span class="s0">_WebAssembly.Instance(module, imports);</span>
        <span class="s1">const </span><span class="s0">source = { instance, module };</span>
        <span class="s1">return </span><span class="s0">source;</span>
    <span class="s0">}</span>
    <span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">asyncifyLoadSync(asyncify, buffer, imports) {</span>
        <span class="s1">var </span><span class="s0">_a;</span>
        <span class="s0">validateImports(imports);</span>
        <span class="s0">imports = imports !== </span><span class="s1">null </span><span class="s0">&amp;&amp; imports !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? imports : {};</span>
        <span class="s1">const </span><span class="s0">asyncifyHelper = </span><span class="s1">new </span><span class="s0">Asyncify();</span>
        <span class="s0">imports = asyncifyHelper.wrapImports(imports);</span>
        <span class="s1">const </span><span class="s0">source = loadSync(buffer, imports);</span>
        <span class="s1">const </span><span class="s0">memory = source.instance.exports.memory || ((_a = imports.env) === </span><span class="s1">null </span><span class="s0">|| _a === </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: _a.memory);</span>
        <span class="s1">return </span><span class="s0">{ module: source.module, instance: asyncifyHelper.init(memory, source.instance, asyncify) };</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">CHAR_DOT = </span><span class="s4">46</span><span class="s0">; </span><span class="s3">/* . */</span>
    <span class="s1">const </span><span class="s0">CHAR_FORWARD_SLASH = </span><span class="s4">47</span><span class="s0">; </span><span class="s3">/* / */</span>
    <span class="s1">function </span><span class="s0">isPosixPathSeparator(code) {</span>
        <span class="s1">return </span><span class="s0">code === CHAR_FORWARD_SLASH;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">normalizeString(path, allowAboveRoot, separator, isPathSeparator) {</span>
        <span class="s1">let </span><span class="s0">res = </span><span class="s2">''</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">lastSegmentLength = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">lastSlash = -</span><span class="s4">1</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">dots = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">code = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt;= path.length; ++i) {</span>
            <span class="s1">if </span><span class="s0">(i &lt; path.length) {</span>
                <span class="s0">code = path.charCodeAt(i);</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(isPathSeparator(code)) {</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s0">code = CHAR_FORWARD_SLASH;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(isPathSeparator(code)) {</span>
                <span class="s1">if </span><span class="s0">(lastSlash === i - </span><span class="s4">1 </span><span class="s0">|| dots === </span><span class="s4">1</span><span class="s0">) ;</span>
                <span class="s1">else if </span><span class="s0">(dots === </span><span class="s4">2</span><span class="s0">) {</span>
                    <span class="s1">if </span><span class="s0">(res.length &lt; </span><span class="s4">2 </span><span class="s0">|| lastSegmentLength !== </span><span class="s4">2 </span><span class="s0">||</span>
                        <span class="s0">res.charCodeAt(res.length - </span><span class="s4">1</span><span class="s0">) !== CHAR_DOT ||</span>
                        <span class="s0">res.charCodeAt(res.length - </span><span class="s4">2</span><span class="s0">) !== CHAR_DOT) {</span>
                        <span class="s1">if </span><span class="s0">(res.length &gt; </span><span class="s4">2</span><span class="s0">) {</span>
                            <span class="s1">const </span><span class="s0">lastSlashIndex = res.indexOf(separator);</span>
                            <span class="s1">if </span><span class="s0">(lastSlashIndex === -</span><span class="s4">1</span><span class="s0">) {</span>
                                <span class="s0">res = </span><span class="s2">''</span><span class="s0">;</span>
                                <span class="s0">lastSegmentLength = </span><span class="s4">0</span><span class="s0">;</span>
                            <span class="s0">}</span>
                            <span class="s1">else </span><span class="s0">{</span>
                                <span class="s0">res = res.slice(</span><span class="s4">0</span><span class="s0">, lastSlashIndex);</span>
                                <span class="s0">lastSegmentLength =</span>
                                    <span class="s0">res.length - </span><span class="s4">1 </span><span class="s0">- res.indexOf(separator);</span>
                            <span class="s0">}</span>
                            <span class="s0">lastSlash = i;</span>
                            <span class="s0">dots = </span><span class="s4">0</span><span class="s0">;</span>
                            <span class="s1">continue</span><span class="s0">;</span>
                        <span class="s0">}</span>
                        <span class="s1">else if </span><span class="s0">(res.length !== </span><span class="s4">0</span><span class="s0">) {</span>
                            <span class="s0">res = </span><span class="s2">''</span><span class="s0">;</span>
                            <span class="s0">lastSegmentLength = </span><span class="s4">0</span><span class="s0">;</span>
                            <span class="s0">lastSlash = i;</span>
                            <span class="s0">dots = </span><span class="s4">0</span><span class="s0">;</span>
                            <span class="s1">continue</span><span class="s0">;</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                    <span class="s1">if </span><span class="s0">(allowAboveRoot) {</span>
                        <span class="s0">res += res.length &gt; </span><span class="s4">0 </span><span class="s0">? </span><span class="s2">`</span><span class="s0">${separator}</span><span class="s2">..` </span><span class="s0">: </span><span class="s2">'..'</span><span class="s0">;</span>
                        <span class="s0">lastSegmentLength = </span><span class="s4">2</span><span class="s0">;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s1">if </span><span class="s0">(res.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                        <span class="s0">res += </span><span class="s2">`</span><span class="s0">${separator}${path.slice(lastSlash + </span><span class="s4">1</span><span class="s0">, i)}</span><span class="s2">`</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">else </span><span class="s0">{</span>
                        <span class="s0">res = path.slice(lastSlash + </span><span class="s4">1</span><span class="s0">, i);</span>
                    <span class="s0">}</span>
                    <span class="s0">lastSegmentLength = i - lastSlash - </span><span class="s4">1</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">lastSlash = i;</span>
                <span class="s0">dots = </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(code === CHAR_DOT &amp;&amp; dots !== -</span><span class="s4">1</span><span class="s0">) {</span>
                <span class="s0">++dots;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s0">dots = -</span><span class="s4">1</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">res;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">resolve(...args) {</span>
        <span class="s1">let </span><span class="s0">resolvedPath = </span><span class="s2">''</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">resolvedAbsolute = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = args.length - </span><span class="s4">1</span><span class="s0">; i &gt;= -</span><span class="s4">1 </span><span class="s0">&amp;&amp; !resolvedAbsolute; i--) {</span>
            <span class="s1">const </span><span class="s0">path = i &gt;= </span><span class="s4">0 </span><span class="s0">? args[i] : </span><span class="s2">'/'</span><span class="s0">;</span>
            <span class="s0">validateString(path, </span><span class="s2">'path'</span><span class="s0">);</span>
            <span class="s3">// Skip empty entries</span>
            <span class="s1">if </span><span class="s0">(path.length === </span><span class="s4">0</span><span class="s0">) {</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">resolvedPath = </span><span class="s2">`</span><span class="s0">${path}</span><span class="s2">/</span><span class="s0">${resolvedPath}</span><span class="s2">`</span><span class="s0">;</span>
            <span class="s0">resolvedAbsolute = path.charCodeAt(</span><span class="s4">0</span><span class="s0">) === CHAR_FORWARD_SLASH;</span>
        <span class="s0">}</span>
        <span class="s3">// At this point the path should be resolved to a full absolute path, but</span>
        <span class="s3">// handle relative paths to be safe (might happen when process.cwd() fails)</span>
        <span class="s3">// Normalize the path</span>
        <span class="s0">resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, </span><span class="s2">'/'</span><span class="s0">, isPosixPathSeparator);</span>
        <span class="s1">if </span><span class="s0">(resolvedAbsolute) {</span>
            <span class="s1">return </span><span class="s2">`/</span><span class="s0">${resolvedPath}</span><span class="s2">`</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">resolvedPath.length &gt; </span><span class="s4">0 </span><span class="s0">? resolvedPath : </span><span class="s2">'.'</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">FD_DATASYNC = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">0</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">FD_READ = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">FD_SEEK = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">2</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">FD_FDSTAT_SET_FLAGS = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">3</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">FD_SYNC = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">4</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">FD_TELL = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">5</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">FD_WRITE = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">6</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">FD_ADVISE = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">7</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">FD_ALLOCATE = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">8</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">PATH_CREATE_DIRECTORY = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">9</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">PATH_CREATE_FILE = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">10</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">PATH_LINK_SOURCE = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">11</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">PATH_LINK_TARGET = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">12</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">PATH_OPEN = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">13</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">FD_READDIR = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">14</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">PATH_READLINK = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">15</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">PATH_RENAME_SOURCE = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">16</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">PATH_RENAME_TARGET = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">17</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">PATH_FILESTAT_GET = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">18</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">PATH_FILESTAT_SET_SIZE = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">19</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">PATH_FILESTAT_SET_TIMES = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">20</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">FD_FILESTAT_GET = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">21</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">FD_FILESTAT_SET_SIZE = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">22</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">FD_FILESTAT_SET_TIMES = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">23</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">PATH_SYMLINK = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">24</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">PATH_REMOVE_DIRECTORY = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">25</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">PATH_UNLINK_FILE = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">26</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">POLL_FD_READWRITE = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">27</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">SOCK_SHUTDOWN = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">28</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">SOCK_ACCEPT = ( </span><span class="s3">/*#__PURE__*/</span><span class="s0">BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">29</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">WasiRights = {</span>
        <span class="s0">FD_DATASYNC,</span>
        <span class="s0">FD_READ,</span>
        <span class="s0">FD_SEEK,</span>
        <span class="s0">FD_FDSTAT_SET_FLAGS,</span>
        <span class="s0">FD_SYNC,</span>
        <span class="s0">FD_TELL,</span>
        <span class="s0">FD_WRITE,</span>
        <span class="s0">FD_ADVISE,</span>
        <span class="s0">FD_ALLOCATE,</span>
        <span class="s0">PATH_CREATE_DIRECTORY,</span>
        <span class="s0">PATH_CREATE_FILE,</span>
        <span class="s0">PATH_LINK_SOURCE,</span>
        <span class="s0">PATH_LINK_TARGET,</span>
        <span class="s0">PATH_OPEN,</span>
        <span class="s0">FD_READDIR,</span>
        <span class="s0">PATH_READLINK,</span>
        <span class="s0">PATH_RENAME_SOURCE,</span>
        <span class="s0">PATH_RENAME_TARGET,</span>
        <span class="s0">PATH_FILESTAT_GET,</span>
        <span class="s0">PATH_FILESTAT_SET_SIZE,</span>
        <span class="s0">PATH_FILESTAT_SET_TIMES,</span>
        <span class="s0">FD_FILESTAT_GET,</span>
        <span class="s0">FD_FILESTAT_SET_SIZE,</span>
        <span class="s0">FD_FILESTAT_SET_TIMES,</span>
        <span class="s0">PATH_SYMLINK,</span>
        <span class="s0">PATH_REMOVE_DIRECTORY,</span>
        <span class="s0">PATH_UNLINK_FILE,</span>
        <span class="s0">POLL_FD_READWRITE,</span>
        <span class="s0">SOCK_SHUTDOWN,</span>
        <span class="s0">SOCK_ACCEPT</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">strerror(errno) {</span>
        <span class="s1">switch </span><span class="s0">(errno) {</span>
            <span class="s1">case </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Success'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">1 </span><span class="s3">/* WasiErrno.E2BIG */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Argument list too long'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">2 </span><span class="s3">/* WasiErrno.EACCES */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Permission denied'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">3 </span><span class="s3">/* WasiErrno.EADDRINUSE */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Address in use'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">4 </span><span class="s3">/* WasiErrno.EADDRNOTAVAIL */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Address not available'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">5 </span><span class="s3">/* WasiErrno.EAFNOSUPPORT */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Address family not supported by protocol'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">6 </span><span class="s3">/* WasiErrno.EAGAIN */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Resource temporarily unavailable'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">7 </span><span class="s3">/* WasiErrno.EALREADY */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Operation already in progress'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">8 </span><span class="s3">/* WasiErrno.EBADF */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Bad file descriptor'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">9 </span><span class="s3">/* WasiErrno.EBADMSG */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Bad message'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">10 </span><span class="s3">/* WasiErrno.EBUSY */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Resource busy'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">11 </span><span class="s3">/* WasiErrno.ECANCELED */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Operation canceled'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">12 </span><span class="s3">/* WasiErrno.ECHILD */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'No child process'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">13 </span><span class="s3">/* WasiErrno.ECONNABORTED */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Connection aborted'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">14 </span><span class="s3">/* WasiErrno.ECONNREFUSED */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Connection refused'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">15 </span><span class="s3">/* WasiErrno.ECONNRESET */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Connection reset by peer'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">16 </span><span class="s3">/* WasiErrno.EDEADLK */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Resource deadlock would occur'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">17 </span><span class="s3">/* WasiErrno.EDESTADDRREQ */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Destination address required'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">18 </span><span class="s3">/* WasiErrno.EDOM */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Domain error'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">19 </span><span class="s3">/* WasiErrno.EDQUOT */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Quota exceeded'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">20 </span><span class="s3">/* WasiErrno.EEXIST */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'File exists'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">21 </span><span class="s3">/* WasiErrno.EFAULT */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Bad address'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">22 </span><span class="s3">/* WasiErrno.EFBIG */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'File too large'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">23 </span><span class="s3">/* WasiErrno.EHOSTUNREACH */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Host is unreachable'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">24 </span><span class="s3">/* WasiErrno.EIDRM */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Identifier removed'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">25 </span><span class="s3">/* WasiErrno.EILSEQ */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Illegal byte sequence'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">26 </span><span class="s3">/* WasiErrno.EINPROGRESS */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Operation in progress'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">27 </span><span class="s3">/* WasiErrno.EINTR */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Interrupted system call'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Invalid argument'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">29 </span><span class="s3">/* WasiErrno.EIO */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'I/O error'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">30 </span><span class="s3">/* WasiErrno.EISCONN */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Socket is connected'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">31 </span><span class="s3">/* WasiErrno.EISDIR */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Is a directory'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">32 </span><span class="s3">/* WasiErrno.ELOOP */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Symbolic link loop'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">33 </span><span class="s3">/* WasiErrno.EMFILE */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'No file descriptors available'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">34 </span><span class="s3">/* WasiErrno.EMLINK */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Too many links'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">35 </span><span class="s3">/* WasiErrno.EMSGSIZE */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Message too large'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">36 </span><span class="s3">/* WasiErrno.EMULTIHOP */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Multihop attempted'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">37 </span><span class="s3">/* WasiErrno.ENAMETOOLONG */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Filename too long'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">38 </span><span class="s3">/* WasiErrno.ENETDOWN */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Network is down'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">39 </span><span class="s3">/* WasiErrno.ENETRESET */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Connection reset by network'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">40 </span><span class="s3">/* WasiErrno.ENETUNREACH */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Network unreachable'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">41 </span><span class="s3">/* WasiErrno.ENFILE */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Too many files open in system'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">42 </span><span class="s3">/* WasiErrno.ENOBUFS */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'No buffer space available'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">43 </span><span class="s3">/* WasiErrno.ENODEV */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'No such device'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">44 </span><span class="s3">/* WasiErrno.ENOENT */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'No such file or directory'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">45 </span><span class="s3">/* WasiErrno.ENOEXEC */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Exec format error'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">46 </span><span class="s3">/* WasiErrno.ENOLCK */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'No locks available'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">47 </span><span class="s3">/* WasiErrno.ENOLINK */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Link has been severed'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">48 </span><span class="s3">/* WasiErrno.ENOMEM */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Out of memory'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">49 </span><span class="s3">/* WasiErrno.ENOMSG */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'No message of the desired type'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">50 </span><span class="s3">/* WasiErrno.ENOPROTOOPT */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Protocol not available'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">51 </span><span class="s3">/* WasiErrno.ENOSPC */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'No space left on device'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">52 </span><span class="s3">/* WasiErrno.ENOSYS */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Function not implemented'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">53 </span><span class="s3">/* WasiErrno.ENOTCONN */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Socket not connected'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">54 </span><span class="s3">/* WasiErrno.ENOTDIR */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Not a directory'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">55 </span><span class="s3">/* WasiErrno.ENOTEMPTY */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Directory not empty'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">56 </span><span class="s3">/* WasiErrno.ENOTRECOVERABLE */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'State not recoverable'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">57 </span><span class="s3">/* WasiErrno.ENOTSOCK */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Not a socket'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">58 </span><span class="s3">/* WasiErrno.ENOTSUP */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Not supported'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">59 </span><span class="s3">/* WasiErrno.ENOTTY */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Not a tty'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">60 </span><span class="s3">/* WasiErrno.ENXIO */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'No such device or address'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">61 </span><span class="s3">/* WasiErrno.EOVERFLOW */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Value too large for data type'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">62 </span><span class="s3">/* WasiErrno.EOWNERDEAD */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Previous owner died'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">63 </span><span class="s3">/* WasiErrno.EPERM */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Operation not permitted'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">64 </span><span class="s3">/* WasiErrno.EPIPE */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Broken pipe'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">65 </span><span class="s3">/* WasiErrno.EPROTO */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Protocol error'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">66 </span><span class="s3">/* WasiErrno.EPROTONOSUPPORT */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Protocol not supported'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">67 </span><span class="s3">/* WasiErrno.EPROTOTYPE */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Protocol wrong type for socket'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">68 </span><span class="s3">/* WasiErrno.ERANGE */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Result not representable'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">69 </span><span class="s3">/* WasiErrno.EROFS */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Read-only file system'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">70 </span><span class="s3">/* WasiErrno.ESPIPE */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Invalid seek'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">71 </span><span class="s3">/* WasiErrno.ESRCH */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'No such process'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">72 </span><span class="s3">/* WasiErrno.ESTALE */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Stale file handle'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">73 </span><span class="s3">/* WasiErrno.ETIMEDOUT */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Operation timed out'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">74 </span><span class="s3">/* WasiErrno.ETXTBSY */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Text file busy'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">75 </span><span class="s3">/* WasiErrno.EXDEV */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Cross-device link'</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">76 </span><span class="s3">/* WasiErrno.ENOTCAPABLE */</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Capabilities insufficient'</span><span class="s0">;</span>
            <span class="s1">default</span><span class="s0">: </span><span class="s1">return </span><span class="s2">'Unknown error'</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">class </span><span class="s0">WasiError </span><span class="s1">extends </span><span class="s0">Error {</span>
        <span class="s0">constructor(message, errno) {</span>
            <span class="s1">super</span><span class="s0">(message);</span>
            <span class="s1">this</span><span class="s0">.errno = errno;</span>
        <span class="s0">}</span>
        <span class="s0">getErrorMessage() {</span>
            <span class="s1">return </span><span class="s0">strerror(</span><span class="s1">this</span><span class="s0">.errno);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">Object.defineProperty(WasiError.prototype, </span><span class="s2">'name'</span><span class="s0">, {</span>
        <span class="s0">configurable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">writable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">value: </span><span class="s2">'WasiError'</span>
    <span class="s0">});</span>

    <span class="s1">const </span><span class="s0">RIGHTS_ALL = WasiRights.FD_DATASYNC |</span>
        <span class="s0">WasiRights.FD_READ |</span>
        <span class="s0">WasiRights.FD_SEEK |</span>
        <span class="s0">WasiRights.FD_FDSTAT_SET_FLAGS |</span>
        <span class="s0">WasiRights.FD_SYNC |</span>
        <span class="s0">WasiRights.FD_TELL |</span>
        <span class="s0">WasiRights.FD_WRITE |</span>
        <span class="s0">WasiRights.FD_ADVISE |</span>
        <span class="s0">WasiRights.FD_ALLOCATE |</span>
        <span class="s0">WasiRights.PATH_CREATE_DIRECTORY |</span>
        <span class="s0">WasiRights.PATH_CREATE_FILE |</span>
        <span class="s0">WasiRights.PATH_LINK_SOURCE |</span>
        <span class="s0">WasiRights.PATH_LINK_TARGET |</span>
        <span class="s0">WasiRights.PATH_OPEN |</span>
        <span class="s0">WasiRights.FD_READDIR |</span>
        <span class="s0">WasiRights.PATH_READLINK |</span>
        <span class="s0">WasiRights.PATH_RENAME_SOURCE |</span>
        <span class="s0">WasiRights.PATH_RENAME_TARGET |</span>
        <span class="s0">WasiRights.PATH_FILESTAT_GET |</span>
        <span class="s0">WasiRights.PATH_FILESTAT_SET_SIZE |</span>
        <span class="s0">WasiRights.PATH_FILESTAT_SET_TIMES |</span>
        <span class="s0">WasiRights.FD_FILESTAT_GET |</span>
        <span class="s0">WasiRights.FD_FILESTAT_SET_TIMES |</span>
        <span class="s0">WasiRights.FD_FILESTAT_SET_SIZE |</span>
        <span class="s0">WasiRights.PATH_SYMLINK |</span>
        <span class="s0">WasiRights.PATH_UNLINK_FILE |</span>
        <span class="s0">WasiRights.PATH_REMOVE_DIRECTORY |</span>
        <span class="s0">WasiRights.POLL_FD_READWRITE |</span>
        <span class="s0">WasiRights.SOCK_SHUTDOWN |</span>
        <span class="s0">WasiRights.SOCK_ACCEPT;</span>
    <span class="s1">const </span><span class="s0">BLOCK_DEVICE_BASE = RIGHTS_ALL;</span>
    <span class="s1">const </span><span class="s0">BLOCK_DEVICE_INHERITING = RIGHTS_ALL;</span>
    <span class="s1">const </span><span class="s0">CHARACTER_DEVICE_BASE = RIGHTS_ALL;</span>
    <span class="s1">const </span><span class="s0">CHARACTER_DEVICE_INHERITING = RIGHTS_ALL;</span>
    <span class="s1">const </span><span class="s0">REGULAR_FILE_BASE = WasiRights.FD_DATASYNC |</span>
        <span class="s0">WasiRights.FD_READ |</span>
        <span class="s0">WasiRights.FD_SEEK |</span>
        <span class="s0">WasiRights.FD_FDSTAT_SET_FLAGS |</span>
        <span class="s0">WasiRights.FD_SYNC |</span>
        <span class="s0">WasiRights.FD_TELL |</span>
        <span class="s0">WasiRights.FD_WRITE |</span>
        <span class="s0">WasiRights.FD_ADVISE |</span>
        <span class="s0">WasiRights.FD_ALLOCATE |</span>
        <span class="s0">WasiRights.FD_FILESTAT_GET |</span>
        <span class="s0">WasiRights.FD_FILESTAT_SET_SIZE |</span>
        <span class="s0">WasiRights.FD_FILESTAT_SET_TIMES |</span>
        <span class="s0">WasiRights.POLL_FD_READWRITE;</span>
    <span class="s1">const </span><span class="s0">REGULAR_FILE_INHERITING = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">0</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">DIRECTORY_BASE = WasiRights.FD_FDSTAT_SET_FLAGS |</span>
        <span class="s0">WasiRights.FD_SYNC |</span>
        <span class="s0">WasiRights.FD_ADVISE |</span>
        <span class="s0">WasiRights.PATH_CREATE_DIRECTORY |</span>
        <span class="s0">WasiRights.PATH_CREATE_FILE |</span>
        <span class="s0">WasiRights.PATH_LINK_SOURCE |</span>
        <span class="s0">WasiRights.PATH_LINK_TARGET |</span>
        <span class="s0">WasiRights.PATH_OPEN |</span>
        <span class="s0">WasiRights.FD_READDIR |</span>
        <span class="s0">WasiRights.PATH_READLINK |</span>
        <span class="s0">WasiRights.PATH_RENAME_SOURCE |</span>
        <span class="s0">WasiRights.PATH_RENAME_TARGET |</span>
        <span class="s0">WasiRights.PATH_FILESTAT_GET |</span>
        <span class="s0">WasiRights.PATH_FILESTAT_SET_SIZE |</span>
        <span class="s0">WasiRights.PATH_FILESTAT_SET_TIMES |</span>
        <span class="s0">WasiRights.FD_FILESTAT_GET |</span>
        <span class="s0">WasiRights.FD_FILESTAT_SET_TIMES |</span>
        <span class="s0">WasiRights.PATH_SYMLINK |</span>
        <span class="s0">WasiRights.PATH_UNLINK_FILE |</span>
        <span class="s0">WasiRights.PATH_REMOVE_DIRECTORY |</span>
        <span class="s0">WasiRights.POLL_FD_READWRITE;</span>
    <span class="s1">const </span><span class="s0">DIRECTORY_INHERITING = DIRECTORY_BASE | REGULAR_FILE_BASE;</span>
    <span class="s1">const </span><span class="s0">SOCKET_BASE = (WasiRights.FD_READ |</span>
        <span class="s0">WasiRights.FD_FDSTAT_SET_FLAGS |</span>
        <span class="s0">WasiRights.FD_WRITE |</span>
        <span class="s0">WasiRights.FD_FILESTAT_GET |</span>
        <span class="s0">WasiRights.POLL_FD_READWRITE |</span>
        <span class="s0">WasiRights.SOCK_SHUTDOWN);</span>
    <span class="s1">const </span><span class="s0">SOCKET_INHERITING = RIGHTS_ALL;</span>
    <span class="s1">const </span><span class="s0">TTY_BASE = WasiRights.FD_READ |</span>
        <span class="s0">WasiRights.FD_FDSTAT_SET_FLAGS |</span>
        <span class="s0">WasiRights.FD_WRITE |</span>
        <span class="s0">WasiRights.FD_FILESTAT_GET |</span>
        <span class="s0">WasiRights.POLL_FD_READWRITE;</span>
    <span class="s1">const </span><span class="s0">TTY_INHERITING = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">BigInt(</span><span class="s4">0</span><span class="s0">);</span>
    <span class="s1">function </span><span class="s0">getRights(stdio, fd, flags, type) {</span>
        <span class="s1">const </span><span class="s0">ret = {</span>
            <span class="s0">base: BigInt(</span><span class="s4">0</span><span class="s0">),</span>
            <span class="s0">inheriting: BigInt(</span><span class="s4">0</span><span class="s0">)</span>
        <span class="s0">};</span>
        <span class="s1">if </span><span class="s0">(type === </span><span class="s4">0 </span><span class="s3">/* WasiFileType.UNKNOWN */</span><span class="s0">) {</span>
            <span class="s1">throw new </span><span class="s0">WasiError(</span><span class="s2">'Unknown file type'</span><span class="s0">, </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">switch </span><span class="s0">(type) {</span>
            <span class="s1">case </span><span class="s4">4 </span><span class="s3">/* WasiFileType.REGULAR_FILE */</span><span class="s0">:</span>
                <span class="s0">ret.base = REGULAR_FILE_BASE;</span>
                <span class="s0">ret.inheriting = REGULAR_FILE_INHERITING;</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">3 </span><span class="s3">/* WasiFileType.DIRECTORY */</span><span class="s0">:</span>
                <span class="s0">ret.base = DIRECTORY_BASE;</span>
                <span class="s0">ret.inheriting = DIRECTORY_INHERITING;</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">6 </span><span class="s3">/* WasiFileType.SOCKET_STREAM */</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s4">5 </span><span class="s3">/* WasiFileType.SOCKET_DGRAM */</span><span class="s0">:</span>
                <span class="s0">ret.base = SOCKET_BASE;</span>
                <span class="s0">ret.inheriting = SOCKET_INHERITING;</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">2 </span><span class="s3">/* WasiFileType.CHARACTER_DEVICE */</span><span class="s0">:</span>
                <span class="s1">if </span><span class="s0">(stdio.indexOf(fd) !== -</span><span class="s4">1</span><span class="s0">) {</span>
                    <span class="s0">ret.base = TTY_BASE;</span>
                    <span class="s0">ret.inheriting = TTY_INHERITING;</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">ret.base = CHARACTER_DEVICE_BASE;</span>
                    <span class="s0">ret.inheriting = CHARACTER_DEVICE_INHERITING;</span>
                <span class="s0">}</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s4">1 </span><span class="s3">/* WasiFileType.BLOCK_DEVICE */</span><span class="s0">:</span>
                <span class="s0">ret.base = BLOCK_DEVICE_BASE;</span>
                <span class="s0">ret.inheriting = BLOCK_DEVICE_INHERITING;</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s1">default</span><span class="s0">:</span>
                <span class="s0">ret.base = BigInt(</span><span class="s4">0</span><span class="s0">);</span>
                <span class="s0">ret.inheriting = BigInt(</span><span class="s4">0</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s3">/* Disable read/write bits depending on access mode. */</span>
        <span class="s1">const </span><span class="s0">read_or_write_only = flags &amp; (</span><span class="s4">0 </span><span class="s0">| </span><span class="s4">1 </span><span class="s0">| </span><span class="s4">2</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(read_or_write_only === </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s0">ret.base &amp;= ~WasiRights.FD_WRITE;</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(read_or_write_only === </span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s0">ret.base &amp;= ~WasiRights.FD_READ;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">ret;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">concatBuffer(buffers, size) {</span>
        <span class="s1">let </span><span class="s0">total = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">size === </span><span class="s2">'number' </span><span class="s0">&amp;&amp; size &gt;= </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s0">total = size;</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; buffers.length; i++) {</span>
                <span class="s1">const </span><span class="s0">buffer = buffers[i];</span>
                <span class="s0">total += buffer.length;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">let </span><span class="s0">pos = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">ret = </span><span class="s1">new </span><span class="s0">Uint8Array(total);</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; buffers.length; i++) {</span>
            <span class="s1">const </span><span class="s0">buffer = buffers[i];</span>
            <span class="s0">ret.set(buffer, pos);</span>
            <span class="s0">pos += buffer.length;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">ret;</span>
    <span class="s0">}</span>
    <span class="s1">class </span><span class="s0">FileDescriptor {</span>
        <span class="s0">constructor(id, fd, path, realPath, type, rightsBase, rightsInheriting, preopen) {</span>
            <span class="s1">this</span><span class="s0">.id = id;</span>
            <span class="s1">this</span><span class="s0">.fd = fd;</span>
            <span class="s1">this</span><span class="s0">.path = path;</span>
            <span class="s1">this</span><span class="s0">.realPath = realPath;</span>
            <span class="s1">this</span><span class="s0">.type = type;</span>
            <span class="s1">this</span><span class="s0">.rightsBase = rightsBase;</span>
            <span class="s1">this</span><span class="s0">.rightsInheriting = rightsInheriting;</span>
            <span class="s1">this</span><span class="s0">.preopen = preopen;</span>
            <span class="s1">this</span><span class="s0">.pos = BigInt(</span><span class="s4">0</span><span class="s0">);</span>
            <span class="s1">this</span><span class="s0">.size = BigInt(</span><span class="s4">0</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">seek(offset, whence) {</span>
            <span class="s1">if </span><span class="s0">(whence === </span><span class="s4">0 </span><span class="s3">/* WasiWhence.SET */</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.pos = BigInt(offset);</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(whence === </span><span class="s4">1 </span><span class="s3">/* WasiWhence.CUR */</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.pos += BigInt(offset);</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(whence === </span><span class="s4">2 </span><span class="s3">/* WasiWhence.END */</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.pos = BigInt(</span><span class="s1">this</span><span class="s0">.size) - BigInt(offset);</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">throw new </span><span class="s0">WasiError(</span><span class="s2">'Unknown whence'</span><span class="s0">, </span><span class="s4">29 </span><span class="s3">/* WasiErrno.EIO */</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">return this</span><span class="s0">.pos;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">class </span><span class="s0">StandardOutput </span><span class="s1">extends </span><span class="s0">FileDescriptor {</span>
        <span class="s0">constructor(log, id, fd, path, realPath, type, rightsBase, rightsInheriting, preopen) {</span>
            <span class="s1">super</span><span class="s0">(id, fd, path, realPath, type, rightsBase, rightsInheriting, preopen);</span>
            <span class="s1">this</span><span class="s0">._log = log;</span>
            <span class="s1">this</span><span class="s0">._buf = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">write(buffer) {</span>
            <span class="s1">const </span><span class="s0">originalBuffer = buffer;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._buf) {</span>
                <span class="s0">buffer = concatBuffer([</span><span class="s1">this</span><span class="s0">._buf, buffer]);</span>
                <span class="s1">this</span><span class="s0">._buf = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(buffer.indexOf(</span><span class="s4">10</span><span class="s0">) === -</span><span class="s4">1</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">._buf = buffer;</span>
                <span class="s1">return </span><span class="s0">originalBuffer.byteLength;</span>
            <span class="s0">}</span>
            <span class="s1">let </span><span class="s0">written = </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s1">let </span><span class="s0">lastBegin = </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s1">let </span><span class="s0">index;</span>
            <span class="s1">while </span><span class="s0">((index = buffer.indexOf(</span><span class="s4">10</span><span class="s0">, written)) !== -</span><span class="s4">1</span><span class="s0">) {</span>
                <span class="s1">const </span><span class="s0">str = </span><span class="s1">new </span><span class="s0">TextDecoder().decode(buffer.subarray(lastBegin, index));</span>
                <span class="s1">this</span><span class="s0">._log(str);</span>
                <span class="s0">written += index - lastBegin + </span><span class="s4">1</span><span class="s0">;</span>
                <span class="s0">lastBegin = index + </span><span class="s4">1</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(written &lt; buffer.length) {</span>
                <span class="s1">this</span><span class="s0">._buf = buffer.slice(written);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">originalBuffer.byteLength;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">toFileType(stat) {</span>
        <span class="s1">if </span><span class="s0">(stat.isBlockDevice())</span>
            <span class="s1">return </span><span class="s4">1 </span><span class="s3">/* WasiFileType.BLOCK_DEVICE */</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(stat.isCharacterDevice())</span>
            <span class="s1">return </span><span class="s4">2 </span><span class="s3">/* WasiFileType.CHARACTER_DEVICE */</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(stat.isDirectory())</span>
            <span class="s1">return </span><span class="s4">3 </span><span class="s3">/* WasiFileType.DIRECTORY */</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(stat.isSocket())</span>
            <span class="s1">return </span><span class="s4">6 </span><span class="s3">/* WasiFileType.SOCKET_STREAM */</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(stat.isFile())</span>
            <span class="s1">return </span><span class="s4">4 </span><span class="s3">/* WasiFileType.REGULAR_FILE */</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(stat.isSymbolicLink())</span>
            <span class="s1">return </span><span class="s4">7 </span><span class="s3">/* WasiFileType.SYMBOLIC_LINK */</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiFileType.UNKNOWN */</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">toFileStat(view, buf, stat) {</span>
        <span class="s0">view.setBigUint64(buf, stat.dev, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">view.setBigUint64(buf + </span><span class="s4">8</span><span class="s0">, stat.ino, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">view.setBigUint64(buf + </span><span class="s4">16</span><span class="s0">, BigInt(toFileType(stat)), </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">view.setBigUint64(buf + </span><span class="s4">24</span><span class="s0">, stat.nlink, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">view.setBigUint64(buf + </span><span class="s4">32</span><span class="s0">, stat.size, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">view.setBigUint64(buf + </span><span class="s4">40</span><span class="s0">, stat.atimeMs * BigInt(</span><span class="s4">1000000</span><span class="s0">), </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">view.setBigUint64(buf + </span><span class="s4">48</span><span class="s0">, stat.mtimeMs * BigInt(</span><span class="s4">1000000</span><span class="s0">), </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">view.setBigUint64(buf + </span><span class="s4">56</span><span class="s0">, stat.ctimeMs * BigInt(</span><span class="s4">1000000</span><span class="s0">), </span><span class="s1">true</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">class </span><span class="s0">FileDescriptorTable {</span>
        <span class="s0">constructor(options) {</span>
            <span class="s1">this</span><span class="s0">.used = </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.size = options.size;</span>
            <span class="s1">this</span><span class="s0">.fds = Array(options.size);</span>
            <span class="s1">this</span><span class="s0">.stdio = [options.in, options.out, options.err];</span>
            <span class="s1">this</span><span class="s0">.print = options.print;</span>
            <span class="s1">this</span><span class="s0">.printErr = options.printErr;</span>
            <span class="s1">this</span><span class="s0">.insertStdio(options.in, </span><span class="s4">0</span><span class="s0">, </span><span class="s2">'&lt;stdin&gt;'</span><span class="s0">);</span>
            <span class="s1">this</span><span class="s0">.insertStdio(options.out, </span><span class="s4">1</span><span class="s0">, </span><span class="s2">'&lt;stdout&gt;'</span><span class="s0">);</span>
            <span class="s1">this</span><span class="s0">.insertStdio(options.err, </span><span class="s4">2</span><span class="s0">, </span><span class="s2">'&lt;stderr&gt;'</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">insertStdio(fd, expected, name) {</span>
            <span class="s1">const </span><span class="s0">type = </span><span class="s4">2 </span><span class="s3">/* WasiFileType.CHARACTER_DEVICE */</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">{ base, inheriting } = getRights(</span><span class="s1">this</span><span class="s0">.stdio, fd, </span><span class="s4">2 </span><span class="s3">/* FileControlFlag.O_RDWR */</span><span class="s0">, type);</span>
            <span class="s1">const </span><span class="s0">wrap = </span><span class="s1">this</span><span class="s0">.insert(fd, name, name, type, base, inheriting, </span><span class="s4">0</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(wrap.id !== expected) {</span>
                <span class="s1">throw new </span><span class="s0">WasiError(</span><span class="s2">`id: </span><span class="s0">${wrap.id} </span><span class="s2">!== expected: </span><span class="s0">${expected}</span><span class="s2">`</span><span class="s0">, </span><span class="s4">8 </span><span class="s3">/* WasiErrno.EBADF */</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">wrap;</span>
        <span class="s0">}</span>
        <span class="s0">insert(fd, mappedPath, realPath, type, rightsBase, rightsInheriting, preopen) {</span>
            <span class="s1">var </span><span class="s0">_a, _b;</span>
            <span class="s1">let </span><span class="s0">index = -</span><span class="s4">1</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.used &gt;= </span><span class="s1">this</span><span class="s0">.size) {</span>
                <span class="s1">const </span><span class="s0">newSize = </span><span class="s1">this</span><span class="s0">.size * </span><span class="s4">2</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.fds.length = newSize;</span>
                <span class="s0">index = </span><span class="s1">this</span><span class="s0">.size;</span>
                <span class="s1">this</span><span class="s0">.size = newSize;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; </span><span class="s1">this</span><span class="s0">.size; ++i) {</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.fds[i] == </span><span class="s1">null</span><span class="s0">) {</span>
                        <span class="s0">index = i;</span>
                        <span class="s1">break</span><span class="s0">;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">let </span><span class="s0">entry;</span>
            <span class="s1">if </span><span class="s0">(mappedPath === </span><span class="s2">'&lt;stdout&gt;'</span><span class="s0">) {</span>
                <span class="s0">entry = </span><span class="s1">new </span><span class="s0">StandardOutput((_a = </span><span class="s1">this</span><span class="s0">.print) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _a !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _a : console.log, index, fd, mappedPath, realPath, type, rightsBase, rightsInheriting, preopen);</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(mappedPath === </span><span class="s2">'&lt;stderr&gt;'</span><span class="s0">) {</span>
                <span class="s0">entry = </span><span class="s1">new </span><span class="s0">StandardOutput((_b = </span><span class="s1">this</span><span class="s0">.printErr) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _b !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _b : console.error, index, fd, mappedPath, realPath, type, rightsBase, rightsInheriting, preopen);</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s0">entry = </span><span class="s1">new </span><span class="s0">FileDescriptor(index, fd, mappedPath, realPath, type, rightsBase, rightsInheriting, preopen);</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.fds[index] = entry;</span>
            <span class="s1">this</span><span class="s0">.used++;</span>
            <span class="s1">return </span><span class="s0">entry;</span>
        <span class="s0">}</span>
        <span class="s0">get(id, base, inheriting) {</span>
            <span class="s1">if </span><span class="s0">(id &gt;= </span><span class="s1">this</span><span class="s0">.size) {</span>
                <span class="s1">throw new </span><span class="s0">WasiError(</span><span class="s2">'Invalid fd'</span><span class="s0">, </span><span class="s4">8 </span><span class="s3">/* WasiErrno.EBADF */</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">entry = </span><span class="s1">this</span><span class="s0">.fds[id];</span>
            <span class="s1">if </span><span class="s0">(!entry || entry.id !== id) {</span>
                <span class="s1">throw new </span><span class="s0">WasiError(</span><span class="s2">'Bad file descriptor'</span><span class="s0">, </span><span class="s4">8 </span><span class="s3">/* WasiErrno.EBADF */</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s3">/* Validate that the fd has the necessary rights. */</span>
            <span class="s1">if </span><span class="s0">((~entry.rightsBase &amp; base) !== BigInt(</span><span class="s4">0</span><span class="s0">) || (~entry.rightsInheriting &amp; inheriting) !== BigInt(</span><span class="s4">0</span><span class="s0">)) {</span>
                <span class="s1">throw new </span><span class="s0">WasiError(</span><span class="s2">'Capabilities insufficient'</span><span class="s0">, </span><span class="s4">76 </span><span class="s3">/* WasiErrno.ENOTCAPABLE */</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">entry;</span>
        <span class="s0">}</span>
        <span class="s0">remove(id) {</span>
            <span class="s1">if </span><span class="s0">(id &gt;= </span><span class="s1">this</span><span class="s0">.size) {</span>
                <span class="s1">throw new </span><span class="s0">WasiError(</span><span class="s2">'Invalid fd'</span><span class="s0">, </span><span class="s4">8 </span><span class="s3">/* WasiErrno.EBADF */</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">entry = </span><span class="s1">this</span><span class="s0">.fds[id];</span>
            <span class="s1">if </span><span class="s0">(!entry || entry.id !== id) {</span>
                <span class="s1">throw new </span><span class="s0">WasiError(</span><span class="s2">'Bad file descriptor'</span><span class="s0">, </span><span class="s4">8 </span><span class="s3">/* WasiErrno.EBADF */</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.fds[id] = undefined;</span>
            <span class="s1">this</span><span class="s0">.used--;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">class </span><span class="s0">SyncTable </span><span class="s1">extends </span><span class="s0">FileDescriptorTable {</span>
        <span class="s0">constructor(options) {</span>
            <span class="s1">super</span><span class="s0">(options);</span>
            <span class="s1">this</span><span class="s0">.fs = options.fs;</span>
        <span class="s0">}</span>
        <span class="s0">getFileTypeByFd(fd) {</span>
            <span class="s1">const </span><span class="s0">stats = </span><span class="s1">this</span><span class="s0">.fs.fstatSync(fd, { bigint: </span><span class="s1">true </span><span class="s0">});</span>
            <span class="s1">return </span><span class="s0">toFileType(stats);</span>
        <span class="s0">}</span>
        <span class="s0">insertPreopen(fd, mappedPath, realPath) {</span>
            <span class="s1">const </span><span class="s0">type = </span><span class="s1">this</span><span class="s0">.getFileTypeByFd(fd);</span>
            <span class="s1">if </span><span class="s0">(type !== </span><span class="s4">3 </span><span class="s3">/* WasiFileType.DIRECTORY */</span><span class="s0">) {</span>
                <span class="s1">throw new </span><span class="s0">WasiError(</span><span class="s2">`Preopen not dir: [&quot;</span><span class="s0">${mappedPath}</span><span class="s2">&quot;, &quot;</span><span class="s0">${realPath}</span><span class="s2">&quot;]`</span><span class="s0">, </span><span class="s4">54 </span><span class="s3">/* WasiErrno.ENOTDIR */</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">result = getRights(</span><span class="s1">this</span><span class="s0">.stdio, fd, </span><span class="s4">0</span><span class="s0">, type);</span>
            <span class="s1">return this</span><span class="s0">.insert(fd, mappedPath, realPath, type, result.base, result.inheriting, </span><span class="s4">1</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">renumber(dst, src) {</span>
            <span class="s1">if </span><span class="s0">(dst === src)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(dst &gt;= </span><span class="s1">this</span><span class="s0">.size || src &gt;= </span><span class="s1">this</span><span class="s0">.size) {</span>
                <span class="s1">throw new </span><span class="s0">WasiError(</span><span class="s2">'Invalid fd'</span><span class="s0">, </span><span class="s4">8 </span><span class="s3">/* WasiErrno.EBADF */</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">dstEntry = </span><span class="s1">this</span><span class="s0">.fds[dst];</span>
            <span class="s1">const </span><span class="s0">srcEntry = </span><span class="s1">this</span><span class="s0">.fds[src];</span>
            <span class="s1">if </span><span class="s0">(!dstEntry || !srcEntry || dstEntry.id !== dst || srcEntry.id !== src) {</span>
                <span class="s1">throw new </span><span class="s0">WasiError(</span><span class="s2">'Invalid fd'</span><span class="s0">, </span><span class="s4">8 </span><span class="s3">/* WasiErrno.EBADF */</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.fs.closeSync(dstEntry.fd);</span>
            <span class="s1">this</span><span class="s0">.fds[dst] = </span><span class="s1">this</span><span class="s0">.fds[src];</span>
            <span class="s1">this</span><span class="s0">.fds[dst].id = dst;</span>
            <span class="s1">this</span><span class="s0">.fds[src] = undefined;</span>
            <span class="s1">this</span><span class="s0">.used--;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">class </span><span class="s0">AsyncTable </span><span class="s1">extends </span><span class="s0">FileDescriptorTable {</span>
        <span class="s3">// eslint-disable-next-line @typescript-eslint/no-useless-constructor</span>
        <span class="s0">constructor(options) {</span>
            <span class="s1">super</span><span class="s0">(options);</span>
        <span class="s0">}</span>
        <span class="s0">async getFileTypeByFd(fd) {</span>
            <span class="s1">const </span><span class="s0">stats = </span><span class="s1">await </span><span class="s0">fd.stat({ bigint: </span><span class="s1">true </span><span class="s0">});</span>
            <span class="s1">return </span><span class="s0">toFileType(stats);</span>
        <span class="s0">}</span>
        <span class="s0">async insertPreopen(fd, mappedPath, realPath) {</span>
            <span class="s1">const </span><span class="s0">type = </span><span class="s1">await this</span><span class="s0">.getFileTypeByFd(fd);</span>
            <span class="s1">if </span><span class="s0">(type !== </span><span class="s4">3 </span><span class="s3">/* WasiFileType.DIRECTORY */</span><span class="s0">) {</span>
                <span class="s1">throw new </span><span class="s0">WasiError(</span><span class="s2">`Preopen not dir: [&quot;</span><span class="s0">${mappedPath}</span><span class="s2">&quot;, &quot;</span><span class="s0">${realPath}</span><span class="s2">&quot;]`</span><span class="s0">, </span><span class="s4">54 </span><span class="s3">/* WasiErrno.ENOTDIR */</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">result = getRights(</span><span class="s1">this</span><span class="s0">.stdio, fd.fd, </span><span class="s4">0</span><span class="s0">, type);</span>
            <span class="s1">return this</span><span class="s0">.insert(fd, mappedPath, realPath, type, result.base, result.inheriting, </span><span class="s4">1</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">async renumber(dst, src) {</span>
            <span class="s1">if </span><span class="s0">(dst === src)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(dst &gt;= </span><span class="s1">this</span><span class="s0">.size || src &gt;= </span><span class="s1">this</span><span class="s0">.size) {</span>
                <span class="s1">throw new </span><span class="s0">WasiError(</span><span class="s2">'Invalid fd'</span><span class="s0">, </span><span class="s4">8 </span><span class="s3">/* WasiErrno.EBADF */</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">dstEntry = </span><span class="s1">this</span><span class="s0">.fds[dst];</span>
            <span class="s1">const </span><span class="s0">srcEntry = </span><span class="s1">this</span><span class="s0">.fds[src];</span>
            <span class="s1">if </span><span class="s0">(!dstEntry || !srcEntry || dstEntry.id !== dst || srcEntry.id !== src) {</span>
                <span class="s1">throw new </span><span class="s0">WasiError(</span><span class="s2">'Invalid fd'</span><span class="s0">, </span><span class="s4">8 </span><span class="s3">/* WasiErrno.EBADF */</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">await </span><span class="s0">dstEntry.fd.close();</span>
            <span class="s1">this</span><span class="s0">.fds[dst] = </span><span class="s1">this</span><span class="s0">.fds[src];</span>
            <span class="s1">this</span><span class="s0">.fds[dst].id = dst;</span>
            <span class="s1">this</span><span class="s0">.fds[src] = undefined;</span>
            <span class="s1">this</span><span class="s0">.used--;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">WebAssemblyMemory = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s1">function </span><span class="s0">() { </span><span class="s1">return </span><span class="s0">_WebAssembly.Memory; })();</span>
    <span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
    <span class="s1">class </span><span class="s0">Memory </span><span class="s1">extends </span><span class="s0">WebAssemblyMemory {</span>
        <span class="s3">// eslint-disable-next-line @typescript-eslint/no-useless-constructor</span>
        <span class="s0">constructor(descriptor) {</span>
            <span class="s1">super</span><span class="s0">(descriptor);</span>
        <span class="s0">}</span>
        <span class="s0">get HEAP8() { </span><span class="s1">return new </span><span class="s0">Int8Array(</span><span class="s1">super</span><span class="s0">.buffer); }</span>
        <span class="s0">get HEAPU8() { </span><span class="s1">return new </span><span class="s0">Uint8Array(</span><span class="s1">super</span><span class="s0">.buffer); }</span>
        <span class="s0">get HEAP16() { </span><span class="s1">return new </span><span class="s0">Int16Array(</span><span class="s1">super</span><span class="s0">.buffer); }</span>
        <span class="s0">get HEAPU16() { </span><span class="s1">return new </span><span class="s0">Uint16Array(</span><span class="s1">super</span><span class="s0">.buffer); }</span>
        <span class="s0">get HEAP32() { </span><span class="s1">return new </span><span class="s0">Int32Array(</span><span class="s1">super</span><span class="s0">.buffer); }</span>
        <span class="s0">get HEAPU32() { </span><span class="s1">return new </span><span class="s0">Uint32Array(</span><span class="s1">super</span><span class="s0">.buffer); }</span>
        <span class="s0">get HEAP64() { </span><span class="s1">return new </span><span class="s0">BigInt64Array(</span><span class="s1">super</span><span class="s0">.buffer); }</span>
        <span class="s0">get HEAPU64() { </span><span class="s1">return new </span><span class="s0">BigUint64Array(</span><span class="s1">super</span><span class="s0">.buffer); }</span>
        <span class="s0">get HEAPF32() { </span><span class="s1">return new </span><span class="s0">Float32Array(</span><span class="s1">super</span><span class="s0">.buffer); }</span>
        <span class="s0">get HEAPF64() { </span><span class="s1">return new </span><span class="s0">Float64Array(</span><span class="s1">super</span><span class="s0">.buffer); }</span>
        <span class="s0">get view() { </span><span class="s1">return new </span><span class="s0">DataView(</span><span class="s1">super</span><span class="s0">.buffer); }</span>
    <span class="s0">}</span>
    <span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">extendMemory(memory) {</span>
        <span class="s1">if </span><span class="s0">(Object.getPrototypeOf(memory) === _WebAssembly.Memory.prototype) {</span>
            <span class="s0">Object.setPrototypeOf(memory, Memory.prototype);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">memory;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">checkWebAssemblyFunction() {</span>
        <span class="s1">const </span><span class="s0">WebAssemblyFunction = _WebAssembly.Function;</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">WebAssemblyFunction !== </span><span class="s2">'function'</span><span class="s0">) {</span>
            <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'WebAssembly.Function is not supported in this environment.' </span><span class="s0">+</span>
                <span class="s2">' If you are using V8 based browser like Chrome, try to specify' </span><span class="s0">+</span>
                <span class="s2">' --js-flags=&quot;--wasm-staging --experimental-wasm-stack-switching&quot;'</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">WebAssemblyFunction;</span>
    <span class="s0">}</span>
    <span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">wrapAsyncImport(f, parameterType, returnType) {</span>
        <span class="s1">const </span><span class="s0">WebAssemblyFunction = checkWebAssemblyFunction();</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">f !== </span><span class="s2">'function'</span><span class="s0">) {</span>
            <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'Function required'</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">parameters = parameterType.slice(</span><span class="s4">0</span><span class="s0">);</span>
        <span class="s0">parameters.unshift(</span><span class="s2">'externref'</span><span class="s0">);</span>
        <span class="s1">return new </span><span class="s0">WebAssemblyFunction({ parameters, results: returnType }, f, { suspending: </span><span class="s2">'first' </span><span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">wrapAsyncExport(f) {</span>
        <span class="s1">const </span><span class="s0">WebAssemblyFunction = checkWebAssemblyFunction();</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">f !== </span><span class="s2">'function'</span><span class="s0">) {</span>
            <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'Function required'</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">return new </span><span class="s0">WebAssemblyFunction({ parameters: [...WebAssemblyFunction.type(f).parameters.slice(</span><span class="s4">1</span><span class="s0">)], results: [</span><span class="s2">'externref'</span><span class="s0">] }, f, { promising: </span><span class="s2">'first' </span><span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">wrapExports(exports, needWrap) {</span>
        <span class="s1">return </span><span class="s0">wrapInstanceExports(exports, (exportValue, name) =&gt; {</span>
            <span class="s1">let </span><span class="s0">ignore = </span><span class="s1">typeof </span><span class="s0">exportValue !== </span><span class="s2">'function'</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(Array.isArray(needWrap)) {</span>
                <span class="s0">ignore = ignore || (needWrap.indexOf(name) === -</span><span class="s4">1</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">ignore ? exportValue : wrapAsyncExport(exportValue);</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">copyMemory(targets, src) {</span>
        <span class="s1">if </span><span class="s0">(targets.length === </span><span class="s4">0 </span><span class="s0">|| src.length === </span><span class="s4">0</span><span class="s0">)</span>
            <span class="s1">return </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">copied = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">left = src.length - copied;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; targets.length; ++i) {</span>
            <span class="s1">const </span><span class="s0">target = targets[i];</span>
            <span class="s1">if </span><span class="s0">(left &lt; target.length) {</span>
                <span class="s0">target.set(src.subarray(copied, copied + left), </span><span class="s4">0</span><span class="s0">);</span>
                <span class="s0">copied += left;</span>
                <span class="s0">left = </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s1">return </span><span class="s0">copied;</span>
            <span class="s0">}</span>
            <span class="s0">target.set(src.subarray(copied, copied + target.length), </span><span class="s4">0</span><span class="s0">);</span>
            <span class="s0">copied += target.length;</span>
            <span class="s0">left -= target.length;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">copied;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">_memory = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
    <span class="s1">const </span><span class="s0">_wasi = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
    <span class="s1">const </span><span class="s0">_fs = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
    <span class="s1">function </span><span class="s0">getMemory(wasi) {</span>
        <span class="s1">return </span><span class="s0">_memory.get(wasi);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">getFs(wasi) {</span>
        <span class="s1">const </span><span class="s0">fs = _fs.get(wasi);</span>
        <span class="s1">if </span><span class="s0">(!fs)</span>
            <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'filesystem is unavailable'</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">fs;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">handleError(err) {</span>
        <span class="s1">if </span><span class="s0">(err </span><span class="s1">instanceof </span><span class="s0">WasiError) {</span>
            <span class="s0">{</span>
                <span class="s0">console.warn(err);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">err.errno;</span>
        <span class="s0">}</span>
        <span class="s1">switch </span><span class="s0">(err.code) {</span>
            <span class="s1">case </span><span class="s2">'ENOENT'</span><span class="s0">: </span><span class="s1">return </span><span class="s4">44 </span><span class="s3">/* WasiErrno.ENOENT */</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s2">'EBADF'</span><span class="s0">: </span><span class="s1">return </span><span class="s4">8 </span><span class="s3">/* WasiErrno.EBADF */</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s2">'EINVAL'</span><span class="s0">: </span><span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s2">'EPERM'</span><span class="s0">: </span><span class="s1">return </span><span class="s4">63 </span><span class="s3">/* WasiErrno.EPERM */</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s2">'EPROTO'</span><span class="s0">: </span><span class="s1">return </span><span class="s4">65 </span><span class="s3">/* WasiErrno.EPROTO */</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s2">'EEXIST'</span><span class="s0">: </span><span class="s1">return </span><span class="s4">20 </span><span class="s3">/* WasiErrno.EEXIST */</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s2">'ENOTDIR'</span><span class="s0">: </span><span class="s1">return </span><span class="s4">54 </span><span class="s3">/* WasiErrno.ENOTDIR */</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s2">'EMFILE'</span><span class="s0">: </span><span class="s1">return </span><span class="s4">33 </span><span class="s3">/* WasiErrno.EMFILE */</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s2">'EACCES'</span><span class="s0">: </span><span class="s1">return </span><span class="s4">2 </span><span class="s3">/* WasiErrno.EACCES */</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s2">'EISDIR'</span><span class="s0">: </span><span class="s1">return </span><span class="s4">31 </span><span class="s3">/* WasiErrno.EISDIR */</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s2">'ENOTEMPTY'</span><span class="s0">: </span><span class="s1">return </span><span class="s4">55 </span><span class="s3">/* WasiErrno.ENOTEMPTY */</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s2">'ENOSYS'</span><span class="s0">: </span><span class="s1">return </span><span class="s4">52 </span><span class="s3">/* WasiErrno.ENOSYS */</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">throw </span><span class="s0">err;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">defineName(name, f) {</span>
        <span class="s0">Object.defineProperty(f, </span><span class="s2">'name'</span><span class="s0">, { value: name });</span>
        <span class="s1">return </span><span class="s0">f;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">tryCall(f, wasi, args) {</span>
        <span class="s1">let </span><span class="s0">r;</span>
        <span class="s1">try </span><span class="s0">{</span>
            <span class="s0">r = f.apply(wasi, args);</span>
        <span class="s0">}</span>
        <span class="s1">catch </span><span class="s0">(err) {</span>
            <span class="s1">return </span><span class="s0">handleError(err);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(isPromiseLike(r)) {</span>
            <span class="s1">return </span><span class="s0">r.then(_ =&gt; _, handleError);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">r;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">syscallWrap(self, name, f) {</span>
        <span class="s1">let </span><span class="s0">debug = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">NODE_DEBUG_NATIVE = (() =&gt; {</span>
            <span class="s1">try </span><span class="s0">{</span>
                <span class="s1">return </span><span class="s2">&quot;wasi&quot;</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">catch </span><span class="s0">(_) {</span>
                <span class="s1">return </span><span class="s0">undefined;</span>
            <span class="s0">}</span>
        <span class="s0">})();</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">NODE_DEBUG_NATIVE === </span><span class="s2">'string' </span><span class="s0">&amp;&amp; NODE_DEBUG_NATIVE.split(</span><span class="s2">','</span><span class="s0">).includes(</span><span class="s2">'wasi'</span><span class="s0">)) {</span>
            <span class="s0">debug = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">debug</span>
            <span class="s0">? defineName(name, </span><span class="s1">function </span><span class="s0">() {</span>
                <span class="s1">const </span><span class="s0">args = Array.prototype.slice.call(arguments);</span>
                <span class="s1">let </span><span class="s0">debugArgs = [</span><span class="s2">`</span><span class="s0">${name}</span><span class="s2">(</span><span class="s0">${Array.from({ length: arguments.length }).map(() =&gt; </span><span class="s2">'%d'</span><span class="s0">).join(</span><span class="s2">', '</span><span class="s0">)}</span><span class="s2">)`</span><span class="s0">];</span>
                <span class="s0">debugArgs = debugArgs.concat(args);</span>
                <span class="s0">console.debug.apply(console, debugArgs);</span>
                <span class="s1">return </span><span class="s0">tryCall(f, self, args);</span>
            <span class="s0">})</span>
            <span class="s0">: defineName(name, </span><span class="s1">function </span><span class="s0">() {</span>
                <span class="s1">return </span><span class="s0">tryCall(f, self, arguments);</span>
            <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">resolvePathSync(fs, fileDescriptor, path, flags) {</span>
        <span class="s1">let </span><span class="s0">resolvedPath = resolve(fileDescriptor.realPath, path);</span>
        <span class="s1">if </span><span class="s0">((flags &amp; </span><span class="s4">1</span><span class="s0">) === </span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s1">try </span><span class="s0">{</span>
                <span class="s0">resolvedPath = fs.readlinkSync(resolvedPath);</span>
            <span class="s0">}</span>
            <span class="s1">catch </span><span class="s0">(err) {</span>
                <span class="s1">if </span><span class="s0">(err.code !== </span><span class="s2">'EINVAL' </span><span class="s0">&amp;&amp; err.code !== </span><span class="s2">'ENOENT'</span><span class="s0">) {</span>
                    <span class="s1">throw </span><span class="s0">err;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">resolvedPath;</span>
    <span class="s0">}</span>
    <span class="s0">async </span><span class="s1">function </span><span class="s0">resolvePathAsync(fs, fileDescriptor, path, flags) {</span>
        <span class="s1">let </span><span class="s0">resolvedPath = resolve(fileDescriptor.realPath, path);</span>
        <span class="s1">if </span><span class="s0">((flags &amp; </span><span class="s4">1</span><span class="s0">) === </span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s1">try </span><span class="s0">{</span>
                <span class="s0">resolvedPath = </span><span class="s1">await </span><span class="s0">fs.promises.readlink(resolvedPath);</span>
            <span class="s0">}</span>
            <span class="s1">catch </span><span class="s0">(err) {</span>
                <span class="s1">if </span><span class="s0">(err.code !== </span><span class="s2">'EINVAL' </span><span class="s0">&amp;&amp; err.code !== </span><span class="s2">'ENOENT'</span><span class="s0">) {</span>
                    <span class="s1">throw </span><span class="s0">err;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">resolvedPath;</span>
    <span class="s0">}</span>
    <span class="s3">// eslint-disable-next-line spaced-comment</span>
    <span class="s1">const </span><span class="s0">encoder = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">new </span><span class="s0">TextEncoder();</span>
    <span class="s3">// eslint-disable-next-line spaced-comment</span>
    <span class="s1">const </span><span class="s0">decoder = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">new </span><span class="s0">TextDecoder();</span>
    <span class="s1">const </span><span class="s0">INT64_MAX = (BigInt(</span><span class="s4">1</span><span class="s0">) &lt;&lt; BigInt(</span><span class="s4">63</span><span class="s0">)) - BigInt(</span><span class="s4">1</span><span class="s0">);</span>
    <span class="s1">function </span><span class="s0">readStdin() {</span>
        <span class="s1">const </span><span class="s0">value = window.prompt();</span>
        <span class="s1">if </span><span class="s0">(value === </span><span class="s1">null</span><span class="s0">)</span>
            <span class="s1">return new </span><span class="s0">Uint8Array();</span>
        <span class="s1">const </span><span class="s0">buffer = </span><span class="s1">new </span><span class="s0">TextEncoder().encode(value + </span><span class="s2">'</span><span class="s6">\n</span><span class="s2">'</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">buffer;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">validateFstFlagsOrReturn(flags) {</span>
        <span class="s1">return </span><span class="s0">(Boolean((flags) &amp; ~(</span><span class="s4">1 </span><span class="s3">/* WasiFstFlag.SET_ATIM */ </span><span class="s0">| </span><span class="s4">2 </span><span class="s3">/* WasiFstFlag.SET_ATIM_NOW */ </span><span class="s0">|</span>
            <span class="s4">4 </span><span class="s3">/* WasiFstFlag.SET_MTIM */ </span><span class="s0">| </span><span class="s4">8 </span><span class="s3">/* WasiFstFlag.SET_MTIM_NOW */</span><span class="s0">)) ||</span>
            <span class="s0">((flags) &amp; (</span><span class="s4">1 </span><span class="s3">/* WasiFstFlag.SET_ATIM */ </span><span class="s0">| </span><span class="s4">2 </span><span class="s3">/* WasiFstFlag.SET_ATIM_NOW */</span><span class="s0">)) ===</span>
                <span class="s0">(</span><span class="s4">1 </span><span class="s3">/* WasiFstFlag.SET_ATIM */ </span><span class="s0">| </span><span class="s4">2 </span><span class="s3">/* WasiFstFlag.SET_ATIM_NOW */</span><span class="s0">) ||</span>
            <span class="s0">((flags) &amp; (</span><span class="s4">4 </span><span class="s3">/* WasiFstFlag.SET_MTIM */ </span><span class="s0">| </span><span class="s4">8 </span><span class="s3">/* WasiFstFlag.SET_MTIM_NOW */</span><span class="s0">)) ===</span>
                <span class="s0">(</span><span class="s4">4 </span><span class="s3">/* WasiFstFlag.SET_MTIM */ </span><span class="s0">| </span><span class="s4">8 </span><span class="s3">/* WasiFstFlag.SET_MTIM_NOW */</span><span class="s0">));</span>
    <span class="s0">}</span>
    <span class="s1">class </span><span class="s0">WASI$1 {</span>
        <span class="s0">constructor(args, env, fds, asyncFs, fs, asyncify) {</span>
            <span class="s1">this</span><span class="s0">.args_get = syscallWrap(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'args_get'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(argv, argv_buf) {</span>
                <span class="s0">argv = Number(argv);</span>
                <span class="s0">argv_buf = Number(argv_buf);</span>
                <span class="s1">if </span><span class="s0">(argv === </span><span class="s4">0 </span><span class="s0">|| argv_buf === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8, view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">args = wasi.args;</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; args.length; ++i) {</span>
                    <span class="s1">const </span><span class="s0">arg = args[i];</span>
                    <span class="s0">view.setInt32(argv, argv_buf, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s0">argv += </span><span class="s4">4</span><span class="s0">;</span>
                    <span class="s1">const </span><span class="s0">data = encoder.encode(arg + </span><span class="s2">'</span><span class="s6">\0</span><span class="s2">'</span><span class="s0">);</span>
                    <span class="s0">HEAPU8.set(data, argv_buf);</span>
                    <span class="s0">argv_buf += data.length;</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.args_sizes_get = syscallWrap(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'args_sizes_get'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(argc, argv_buf_size) {</span>
                <span class="s0">argc = Number(argc);</span>
                <span class="s0">argv_buf_size = Number(argv_buf_size);</span>
                <span class="s1">if </span><span class="s0">(argc === </span><span class="s4">0 </span><span class="s0">|| argv_buf_size === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">args = wasi.args;</span>
                <span class="s0">view.setUint32(argc, args.length, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s0">view.setUint32(argv_buf_size, encoder.encode(args.join(</span><span class="s2">'</span><span class="s6">\0</span><span class="s2">'</span><span class="s0">) + </span><span class="s2">'</span><span class="s6">\0</span><span class="s2">'</span><span class="s0">).length, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.environ_get = syscallWrap(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'environ_get'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(environ, environ_buf) {</span>
                <span class="s0">environ = Number(environ);</span>
                <span class="s0">environ_buf = Number(environ_buf);</span>
                <span class="s1">if </span><span class="s0">(environ === </span><span class="s4">0 </span><span class="s0">|| environ_buf === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8, view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">env = wasi.env;</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; env.length; ++i) {</span>
                    <span class="s1">const </span><span class="s0">pair = env[i];</span>
                    <span class="s0">view.setInt32(environ, environ_buf, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s0">environ += </span><span class="s4">4</span><span class="s0">;</span>
                    <span class="s1">const </span><span class="s0">data = encoder.encode(pair + </span><span class="s2">'</span><span class="s6">\0</span><span class="s2">'</span><span class="s0">);</span>
                    <span class="s0">HEAPU8.set(data, environ_buf);</span>
                    <span class="s0">environ_buf += data.length;</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.environ_sizes_get = syscallWrap(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'environ_sizes_get'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(len, buflen) {</span>
                <span class="s0">len = Number(len);</span>
                <span class="s0">buflen = Number(buflen);</span>
                <span class="s1">if </span><span class="s0">(len === </span><span class="s4">0 </span><span class="s0">|| buflen === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">view.setUint32(len, wasi.env.length, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s0">view.setUint32(buflen, encoder.encode(wasi.env.join(</span><span class="s2">'</span><span class="s6">\0</span><span class="s2">'</span><span class="s0">) + </span><span class="s2">'</span><span class="s6">\0</span><span class="s2">'</span><span class="s0">).length, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.clock_res_get = syscallWrap(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'clock_res_get'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(id, resolution) {</span>
                <span class="s0">resolution = Number(resolution);</span>
                <span class="s1">if </span><span class="s0">(resolution === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">switch </span><span class="s0">(id) {</span>
                    <span class="s1">case </span><span class="s4">0 </span><span class="s3">/* WasiClockid.REALTIME */</span><span class="s0">:</span>
                        <span class="s0">view.setBigUint64(resolution, BigInt(</span><span class="s4">1000000</span><span class="s0">), </span><span class="s1">true</span><span class="s0">);</span>
                        <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
                    <span class="s1">case </span><span class="s4">1 </span><span class="s3">/* WasiClockid.MONOTONIC */</span><span class="s0">:</span>
                    <span class="s1">case </span><span class="s4">2 </span><span class="s3">/* WasiClockid.PROCESS_CPUTIME_ID */</span><span class="s0">:</span>
                    <span class="s1">case </span><span class="s4">3 </span><span class="s3">/* WasiClockid.THREAD_CPUTIME_ID */</span><span class="s0">:</span>
                        <span class="s0">view.setBigUint64(resolution, BigInt(</span><span class="s4">1000</span><span class="s0">), </span><span class="s1">true</span><span class="s0">);</span>
                        <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
                    <span class="s1">default</span><span class="s0">: </span><span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.clock_time_get = syscallWrap(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'clock_time_get'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(id, _percision, time) {</span>
                <span class="s0">time = Number(time);</span>
                <span class="s1">if </span><span class="s0">(time === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">switch </span><span class="s0">(id) {</span>
                    <span class="s1">case </span><span class="s4">0 </span><span class="s3">/* WasiClockid.REALTIME */</span><span class="s0">:</span>
                        <span class="s0">view.setBigUint64(time, BigInt(Date.now()) * BigInt(</span><span class="s4">1000000</span><span class="s0">), </span><span class="s1">true</span><span class="s0">);</span>
                        <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
                    <span class="s1">case </span><span class="s4">1 </span><span class="s3">/* WasiClockid.MONOTONIC */</span><span class="s0">:</span>
                    <span class="s1">case </span><span class="s4">2 </span><span class="s3">/* WasiClockid.PROCESS_CPUTIME_ID */</span><span class="s0">:</span>
                    <span class="s1">case </span><span class="s4">3 </span><span class="s3">/* WasiClockid.THREAD_CPUTIME_ID */</span><span class="s0">: {</span>
                        <span class="s1">const </span><span class="s0">t = performance.now() / </span><span class="s4">1000</span><span class="s0">;</span>
                        <span class="s1">const </span><span class="s0">s = Math.trunc(t);</span>
                        <span class="s1">const </span><span class="s0">ms = Math.floor((t - s) * </span><span class="s4">1000</span><span class="s0">);</span>
                        <span class="s1">const </span><span class="s0">result = BigInt(s) * BigInt(</span><span class="s4">1000000000</span><span class="s0">) + BigInt(ms) * BigInt(</span><span class="s4">1000000</span><span class="s0">);</span>
                        <span class="s0">view.setBigUint64(time, result, </span><span class="s1">true</span><span class="s0">);</span>
                        <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">default</span><span class="s0">: </span><span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.fd_advise = syscallWrap(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'fd_advise'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_fd, _offset, _len, _advice) {</span>
                <span class="s1">return </span><span class="s4">52 </span><span class="s3">/* WasiErrno.ENOSYS */</span><span class="s0">;</span>
            <span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.fd_fdstat_get = syscallWrap(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'fd_fdstat_get'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(fd, fdstat) {</span>
                <span class="s0">fdstat = Number(fdstat);</span>
                <span class="s1">if </span><span class="s0">(fdstat === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, BigInt(</span><span class="s4">0</span><span class="s0">), BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">const </span><span class="s0">{ view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">view.setUint16(fdstat, fileDescriptor.type, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s0">view.setUint16(fdstat + </span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s0">view.setBigUint64(fdstat + </span><span class="s4">8</span><span class="s0">, fileDescriptor.rightsBase, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s0">view.setBigUint64(fdstat + </span><span class="s4">16</span><span class="s0">, fileDescriptor.rightsInheriting, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.fd_fdstat_set_flags = syscallWrap(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'fd_fdstat_set_flags'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_fd, _flags) {</span>
                <span class="s1">return </span><span class="s4">52 </span><span class="s3">/* WasiErrno.ENOSYS */</span><span class="s0">;</span>
            <span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.fd_fdstat_set_rights = syscallWrap(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'fd_fdstat_set_rights'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(fd, rightsBase, rightsInheriting) {</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, BigInt(</span><span class="s4">0</span><span class="s0">), BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">if </span><span class="s0">((rightsBase | fileDescriptor.rightsBase) &gt; fileDescriptor.rightsBase) {</span>
                    <span class="s1">return </span><span class="s4">76 </span><span class="s3">/* WasiErrno.ENOTCAPABLE */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">((rightsInheriting | fileDescriptor.rightsInheriting) &gt;</span>
                    <span class="s0">fileDescriptor.rightsInheriting) {</span>
                    <span class="s1">return </span><span class="s4">76 </span><span class="s3">/* WasiErrno.ENOTCAPABLE */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">fileDescriptor.rightsBase = rightsBase;</span>
                <span class="s0">fileDescriptor.rightsInheriting = rightsInheriting;</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.fd_prestat_get = syscallWrap(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'fd_prestat_get'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(fd, prestat) {</span>
                <span class="s0">prestat = Number(prestat);</span>
                <span class="s1">if </span><span class="s0">(prestat === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">let </span><span class="s0">fileDescriptor;</span>
                <span class="s1">try </span><span class="s0">{</span>
                    <span class="s0">fileDescriptor = wasi.fds.get(fd, BigInt(</span><span class="s4">0</span><span class="s0">), BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s0">}</span>
                <span class="s1">catch </span><span class="s0">(err) {</span>
                    <span class="s1">if </span><span class="s0">(err </span><span class="s1">instanceof </span><span class="s0">WasiError)</span>
                        <span class="s1">return </span><span class="s0">err.errno;</span>
                    <span class="s1">throw </span><span class="s0">err;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(fileDescriptor.preopen !== </span><span class="s4">1</span><span class="s0">)</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">{ view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s3">// preopen type is dir(0)</span>
                <span class="s0">view.setUint32(prestat, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s0">view.setUint32(prestat + </span><span class="s4">4</span><span class="s0">, encoder.encode(fileDescriptor.path).length, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.fd_prestat_dir_name = syscallWrap(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'fd_prestat_dir_name'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(fd, path, path_len) {</span>
                <span class="s0">path = Number(path);</span>
                <span class="s0">path_len = Number(path_len);</span>
                <span class="s1">if </span><span class="s0">(path === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, BigInt(</span><span class="s4">0</span><span class="s0">), BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">if </span><span class="s0">(fileDescriptor.preopen !== </span><span class="s4">1</span><span class="s0">)</span>
                    <span class="s1">return </span><span class="s4">8 </span><span class="s3">/* WasiErrno.EBADF */</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">buffer = encoder.encode(fileDescriptor.path);</span>
                <span class="s1">const </span><span class="s0">size = buffer.length;</span>
                <span class="s1">if </span><span class="s0">(size &gt; path_len)</span>
                    <span class="s1">return </span><span class="s4">42 </span><span class="s3">/* WasiErrno.ENOBUFS */</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8 } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">HEAPU8.set(buffer, path);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.fd_seek = syscallWrap(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'fd_seek'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(fd, offset, whence, newOffset) {</span>
                <span class="s0">newOffset = Number(newOffset);</span>
                <span class="s1">if </span><span class="s0">(newOffset === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(fd === </span><span class="s4">0 </span><span class="s0">|| fd === </span><span class="s4">1 </span><span class="s0">|| fd === </span><span class="s4">2</span><span class="s0">)</span>
                    <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_SEEK, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">const </span><span class="s0">r = fileDescriptor.seek(offset, whence);</span>
                <span class="s1">const </span><span class="s0">{ view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">view.setBigUint64(newOffset, r, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.fd_tell = syscallWrap(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'fd_tell'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(fd, offset) {</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_TELL, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">const </span><span class="s0">pos = BigInt(fileDescriptor.pos);</span>
                <span class="s1">const </span><span class="s0">{ view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">view.setBigUint64(Number(offset), pos, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.poll_oneoff = syscallWrap(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'poll_oneoff'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(in_ptr, out_ptr, nsubscriptions, nevents) {</span>
                <span class="s0">in_ptr = Number(in_ptr);</span>
                <span class="s0">out_ptr = Number(out_ptr);</span>
                <span class="s0">nevents = Number(nevents);</span>
                <span class="s0">nsubscriptions = Number(nsubscriptions);</span>
                <span class="s0">nsubscriptions = nsubscriptions &gt;&gt;&gt; </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(in_ptr === </span><span class="s4">0 </span><span class="s0">|| out_ptr === </span><span class="s4">0 </span><span class="s0">|| nsubscriptions === </span><span class="s4">0 </span><span class="s0">|| nevents === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">view.setUint32(nevents, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s1">let </span><span class="s0">timer_userdata = BigInt(</span><span class="s4">0</span><span class="s0">);</span>
                <span class="s1">let </span><span class="s0">cur_timeout = BigInt(</span><span class="s4">0</span><span class="s0">);</span>
                <span class="s1">let </span><span class="s0">has_timeout = </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s1">let </span><span class="s0">min_timeout = BigInt(</span><span class="s4">0</span><span class="s0">);</span>
                <span class="s1">let </span><span class="s0">sub;</span>
                <span class="s1">const </span><span class="s0">subscriptions = Array(nsubscriptions);</span>
                <span class="s1">for </span><span class="s0">(i = </span><span class="s4">0</span><span class="s0">; i &lt; nsubscriptions; i++) {</span>
                    <span class="s0">sub = in_ptr + i * </span><span class="s4">48</span><span class="s0">;</span>
                    <span class="s1">const </span><span class="s0">userdata = view.getBigUint64(sub, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">type = view.getUint8(sub + </span><span class="s4">8</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">clockIdOrFd = view.getUint32(sub + </span><span class="s4">16</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">timeout = view.getBigUint64(sub + </span><span class="s4">24</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">precision = view.getBigUint64(sub + </span><span class="s4">32</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">flags = view.getUint16(sub + </span><span class="s4">40</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s0">subscriptions[i] = {</span>
                        <span class="s0">userdata,</span>
                        <span class="s0">type,</span>
                        <span class="s0">u: {</span>
                            <span class="s0">clock: {</span>
                                <span class="s0">clock_id: clockIdOrFd,</span>
                                <span class="s0">timeout,</span>
                                <span class="s0">precision,</span>
                                <span class="s0">flags</span>
                            <span class="s0">},</span>
                            <span class="s0">fd_readwrite: {</span>
                                <span class="s0">fd: clockIdOrFd</span>
                            <span class="s0">}</span>
                        <span class="s0">}</span>
                    <span class="s0">};</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">fdevents = [];</span>
                <span class="s1">for </span><span class="s0">(i = </span><span class="s4">0</span><span class="s0">; i &lt; nsubscriptions; i++) {</span>
                    <span class="s0">sub = subscriptions[i];</span>
                    <span class="s1">switch </span><span class="s0">(sub.type) {</span>
                        <span class="s1">case </span><span class="s4">0 </span><span class="s3">/* WasiEventType.CLOCK */</span><span class="s0">: {</span>
                            <span class="s1">if </span><span class="s0">(sub.u.clock.flags === </span><span class="s4">1 </span><span class="s3">/* WasiSubclockflags.ABSTIME */</span><span class="s0">) {</span>
                                <span class="s3">/* Convert absolute time to relative delay. */</span>
                                <span class="s1">const </span><span class="s0">now = BigInt(Date.now()) * BigInt(</span><span class="s4">1000000</span><span class="s0">);</span>
                                <span class="s0">cur_timeout = sub.u.clock.timeout - now;</span>
                            <span class="s0">}</span>
                            <span class="s1">else </span><span class="s0">{</span>
                                <span class="s0">cur_timeout = sub.u.clock.timeout;</span>
                            <span class="s0">}</span>
                            <span class="s1">if </span><span class="s0">(has_timeout === </span><span class="s4">0 </span><span class="s0">|| cur_timeout &lt; min_timeout) {</span>
                                <span class="s0">min_timeout = cur_timeout;</span>
                                <span class="s0">timer_userdata = sub.userdata;</span>
                                <span class="s0">has_timeout = </span><span class="s4">1</span><span class="s0">;</span>
                            <span class="s0">}</span>
                            <span class="s1">break</span><span class="s0">;</span>
                        <span class="s0">}</span>
                        <span class="s1">case </span><span class="s4">1 </span><span class="s3">/* WasiEventType.FD_READ */</span><span class="s0">:</span>
                        <span class="s1">case </span><span class="s4">2 </span><span class="s3">/* WasiEventType.FD_WRITE */</span><span class="s0">:</span>
                            <span class="s0">fdevents.push(sub);</span>
                            <span class="s1">break</span><span class="s0">;</span>
                        <span class="s1">default</span><span class="s0">: </span><span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(fdevents.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">for </span><span class="s0">(i = </span><span class="s4">0</span><span class="s0">; i &lt; fdevents.length; i++) {</span>
                        <span class="s1">const </span><span class="s0">fdevent = fdevents[i];</span>
                        <span class="s1">const </span><span class="s0">event = out_ptr + </span><span class="s4">32 </span><span class="s0">* i;</span>
                        <span class="s0">view.setBigUint64(event, fdevent.userdata, </span><span class="s1">true</span><span class="s0">);</span>
                        <span class="s0">view.setUint32(event + </span><span class="s4">8</span><span class="s0">, </span><span class="s4">52 </span><span class="s3">/* WasiErrno.ENOSYS */</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                        <span class="s0">view.setUint32(event + </span><span class="s4">12</span><span class="s0">, fdevent.type, </span><span class="s1">true</span><span class="s0">);</span>
                        <span class="s0">view.setBigUint64(event + </span><span class="s4">16</span><span class="s0">, BigInt(</span><span class="s4">0</span><span class="s0">), </span><span class="s1">true</span><span class="s0">);</span>
                        <span class="s0">view.setUint16(event + </span><span class="s4">24</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                        <span class="s0">view.setUint32(nevents, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s0">}</span>
                    <span class="s0">view.setUint32(nevents, fdevents.length, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(has_timeout) {</span>
                    <span class="s1">const </span><span class="s0">delay = Number(min_timeout / BigInt(</span><span class="s4">1000000</span><span class="s0">));</span>
                    <span class="s3">// if (isMainThread || typeof SharedArrayBuffer !== 'function') {</span>
                    <span class="s0">sleepBreakIf(delay, () =&gt; </span><span class="s1">false</span><span class="s0">);</span>
                    <span class="s3">// } else {</span>
                    <span class="s3">//   const buf = new SharedArrayBuffer(4)</span>
                    <span class="s3">//   const arr = new Int32Array(buf)</span>
                    <span class="s3">//   postMsg({</span>
                    <span class="s3">//     __tybys_wasm_util_wasi__: {</span>
                    <span class="s3">//       type: 'set-timeout',</span>
                    <span class="s3">//       payload: {</span>
                    <span class="s3">//         buffer: buf,</span>
                    <span class="s3">//         delay</span>
                    <span class="s3">//       }</span>
                    <span class="s3">//     }</span>
                    <span class="s3">//   })</span>
                    <span class="s3">//   Atomics.wait(arr, 0, 0)</span>
                    <span class="s3">// }</span>
                    <span class="s1">const </span><span class="s0">event = out_ptr;</span>
                    <span class="s0">view.setBigUint64(event, timer_userdata, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s0">view.setUint32(event + </span><span class="s4">8</span><span class="s0">, </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s0">view.setUint32(event + </span><span class="s4">12</span><span class="s0">, </span><span class="s4">0 </span><span class="s3">/* WasiEventType.CLOCK */</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s0">view.setUint32(nevents, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.proc_exit = syscallWrap(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'proc_exit'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(rval) {</span>
                <span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">process === </span><span class="s2">'object'</span><span class="s0">) &amp;&amp; (process !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; (</span><span class="s1">typeof </span><span class="s0">process.exit === </span><span class="s2">'function'</span><span class="s0">)) {</span>
                    <span class="s0">process.exit(rval);</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.proc_raise = syscallWrap(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'proc_raise'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_sig) {</span>
                <span class="s1">return </span><span class="s4">52 </span><span class="s3">/* WasiErrno.ENOSYS */</span><span class="s0">;</span>
            <span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.sched_yield = syscallWrap(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'sched_yield'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">() {</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.random_get = </span><span class="s1">typeof </span><span class="s0">crypto !== </span><span class="s2">'undefined' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">crypto.getRandomValues === </span><span class="s2">'function'</span>
                <span class="s0">? syscallWrap(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'random_get'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(buf, buf_len) {</span>
                    <span class="s0">buf = Number(buf);</span>
                    <span class="s1">if </span><span class="s0">(buf === </span><span class="s4">0</span><span class="s0">) {</span>
                        <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s0">buf_len = Number(buf_len);</span>
                    <span class="s1">const </span><span class="s0">{ HEAPU8, view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                    <span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">SharedArrayBuffer === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; HEAPU8.buffer </span><span class="s1">instanceof </span><span class="s0">SharedArrayBuffer) ||</span>
                        <span class="s0">(Object.prototype.toString.call(HEAPU8.buffer) === </span><span class="s2">'[object SharedArrayBuffer]'</span><span class="s0">)) {</span>
                        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = buf; i &lt; buf + buf_len; ++i) {</span>
                            <span class="s0">view.setUint8(i, Math.floor(Math.random() * </span><span class="s4">256</span><span class="s0">));</span>
                        <span class="s0">}</span>
                        <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">let </span><span class="s0">pos;</span>
                    <span class="s1">const </span><span class="s0">stride = </span><span class="s4">65536</span><span class="s0">;</span>
                    <span class="s1">for </span><span class="s0">(pos = </span><span class="s4">0</span><span class="s0">; pos + stride &lt; buf_len; pos += stride) {</span>
                        <span class="s0">crypto.getRandomValues(HEAPU8.subarray(buf + pos, buf + pos + stride));</span>
                    <span class="s0">}</span>
                    <span class="s0">crypto.getRandomValues(HEAPU8.subarray(buf + pos, buf + buf_len));</span>
                    <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
                <span class="s0">})</span>
                <span class="s0">: syscallWrap(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'random_get'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(buf, buf_len) {</span>
                    <span class="s0">buf = Number(buf);</span>
                    <span class="s1">if </span><span class="s0">(buf === </span><span class="s4">0</span><span class="s0">) {</span>
                        <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s0">buf_len = Number(buf_len);</span>
                    <span class="s1">const </span><span class="s0">{ view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                    <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = buf; i &lt; buf + buf_len; ++i) {</span>
                        <span class="s0">view.setUint8(i, Math.floor(Math.random() * </span><span class="s4">256</span><span class="s0">));</span>
                    <span class="s0">}</span>
                    <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
                <span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.sock_recv = syscallWrap(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'sock_recv'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">() {</span>
                <span class="s1">return </span><span class="s4">58 </span><span class="s3">/* WasiErrno.ENOTSUP */</span><span class="s0">;</span>
            <span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.sock_send = syscallWrap(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'sock_send'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">() {</span>
                <span class="s1">return </span><span class="s4">58 </span><span class="s3">/* WasiErrno.ENOTSUP */</span><span class="s0">;</span>
            <span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.sock_shutdown = syscallWrap(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'sock_shutdown'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">() {</span>
                <span class="s1">return </span><span class="s4">58 </span><span class="s3">/* WasiErrno.ENOTSUP */</span><span class="s0">;</span>
            <span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.sock_accept = syscallWrap(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'sock_accept'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">() {</span>
                <span class="s1">return </span><span class="s4">58 </span><span class="s3">/* WasiErrno.ENOTSUP */</span><span class="s0">;</span>
            <span class="s0">});</span>
            <span class="s0">_wasi.set(</span><span class="s1">this</span><span class="s0">, {</span>
                <span class="s0">fds,</span>
                <span class="s0">args,</span>
                <span class="s0">env</span>
            <span class="s0">});</span>
            <span class="s1">if </span><span class="s0">(fs)</span>
                <span class="s0">_fs.set(</span><span class="s1">this</span><span class="s0">, fs);</span>
            <span class="s3">// eslint-disable-next-line @typescript-eslint/no-this-alias</span>
            <span class="s1">const </span><span class="s0">_this = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">function </span><span class="s0">defineImport(name, syncVersion, asyncVersion, parameterType, returnType) {</span>
                <span class="s1">if </span><span class="s0">(asyncFs) {</span>
                    <span class="s1">if </span><span class="s0">(asyncify) {</span>
                        <span class="s0">_this[name] = asyncify.wrapImportFunction(syscallWrap(_this, name, asyncVersion));</span>
                    <span class="s0">}</span>
                    <span class="s1">else </span><span class="s0">{</span>
                        <span class="s0">_this[name] = wrapAsyncImport(syscallWrap(_this, name, asyncVersion), parameterType, returnType);</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">_this[name] = syscallWrap(_this, name, syncVersion);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">defineImport(</span><span class="s2">'fd_allocate'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">fd_allocate(fd, offset, len) {</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_ALLOCATE, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">const </span><span class="s0">stat = fs.fstatSync(fileDescriptor.fd, { bigint: </span><span class="s1">true </span><span class="s0">});</span>
                <span class="s1">if </span><span class="s0">(stat.size &lt; offset + len) {</span>
                    <span class="s0">fs.ftruncateSync(fileDescriptor.fd, Number(offset + len));</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, async </span><span class="s1">function </span><span class="s0">fd_allocate(fd, offset, len) {</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_ALLOCATE, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">const </span><span class="s0">h = fileDescriptor.fd;</span>
                <span class="s1">const </span><span class="s0">stat = </span><span class="s1">await </span><span class="s0">h.stat({ bigint: </span><span class="s1">true </span><span class="s0">});</span>
                <span class="s1">if </span><span class="s0">(stat.size &lt; offset + len) {</span>
                    <span class="s1">await </span><span class="s0">h.truncate(Number(offset + len));</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, [</span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i64'</span><span class="s0">, </span><span class="s2">'f64'</span><span class="s0">], [</span><span class="s2">'i32'</span><span class="s0">]);</span>
            <span class="s0">defineImport(</span><span class="s2">'fd_close'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">fd_close(fd) {</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, BigInt(</span><span class="s4">0</span><span class="s0">), BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">fs.closeSync(fileDescriptor.fd);</span>
                <span class="s0">wasi.fds.remove(fd);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, async </span><span class="s1">function </span><span class="s0">fd_close(fd) {</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, BigInt(</span><span class="s4">0</span><span class="s0">), BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">await </span><span class="s0">fileDescriptor.fd.close();</span>
                <span class="s0">wasi.fds.remove(fd);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, [</span><span class="s2">'i32'</span><span class="s0">], [</span><span class="s2">'i32'</span><span class="s0">]);</span>
            <span class="s0">defineImport(</span><span class="s2">'fd_datasync'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">fd_datasync(fd) {</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_DATASYNC, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">fs.fdatasyncSync(fileDescriptor.fd);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, async </span><span class="s1">function </span><span class="s0">fd_datasync(fd) {</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_DATASYNC, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">await </span><span class="s0">fileDescriptor.fd.datasync();</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, [</span><span class="s2">'i32'</span><span class="s0">], [</span><span class="s2">'i32'</span><span class="s0">]);</span>
            <span class="s0">defineImport(</span><span class="s2">'fd_filestat_get'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">fd_filestat_get(fd, buf) {</span>
                <span class="s0">buf = Number(buf);</span>
                <span class="s1">if </span><span class="s0">(buf === </span><span class="s4">0</span><span class="s0">)</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_FILESTAT_GET, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">stat = fs.fstatSync(fileDescriptor.fd, { bigint: </span><span class="s1">true </span><span class="s0">});</span>
                <span class="s1">const </span><span class="s0">{ view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">toFileStat(view, buf, stat);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, async </span><span class="s1">function </span><span class="s0">fd_filestat_get(fd, buf) {</span>
                <span class="s0">buf = Number(buf);</span>
                <span class="s1">if </span><span class="s0">(buf === </span><span class="s4">0</span><span class="s0">)</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_FILESTAT_GET, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">const </span><span class="s0">h = fileDescriptor.fd;</span>
                <span class="s1">const </span><span class="s0">stat = </span><span class="s1">await </span><span class="s0">h.stat({ bigint: </span><span class="s1">true </span><span class="s0">});</span>
                <span class="s1">const </span><span class="s0">{ view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">toFileStat(view, buf, stat);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, [</span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">], [</span><span class="s2">'i32'</span><span class="s0">]);</span>
            <span class="s0">defineImport(</span><span class="s2">'fd_filestat_set_size'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">fd_filestat_set_size(fd, size) {</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_FILESTAT_SET_SIZE, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">fs.ftruncateSync(fileDescriptor.fd, Number(size));</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, async </span><span class="s1">function </span><span class="s0">fd_filestat_set_size(fd, size) {</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_FILESTAT_SET_SIZE, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">const </span><span class="s0">h = fileDescriptor.fd;</span>
                <span class="s1">await </span><span class="s0">h.truncate(Number(size));</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, [</span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i64'</span><span class="s0">], [</span><span class="s2">'i32'</span><span class="s0">]);</span>
            <span class="s1">function </span><span class="s0">fdFilestatGetTimes(fd, atim, mtim, flags) {</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_FILESTAT_SET_TIMES, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">if </span><span class="s0">((flags &amp; </span><span class="s4">2 </span><span class="s3">/* WasiFstFlag.SET_ATIM_NOW */</span><span class="s0">) === </span><span class="s4">2 </span><span class="s3">/* WasiFstFlag.SET_ATIM_NOW */</span><span class="s0">) {</span>
                    <span class="s0">atim = BigInt(Date.now() * </span><span class="s4">1000000</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">((flags &amp; </span><span class="s4">8 </span><span class="s3">/* WasiFstFlag.SET_MTIM_NOW */</span><span class="s0">) === </span><span class="s4">8 </span><span class="s3">/* WasiFstFlag.SET_MTIM_NOW */</span><span class="s0">) {</span>
                    <span class="s0">mtim = BigInt(Date.now() * </span><span class="s4">1000000</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">{ fileDescriptor, atim, mtim };</span>
            <span class="s0">}</span>
            <span class="s0">defineImport(</span><span class="s2">'fd_filestat_set_times'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">fd_filestat_set_times(fd, atim, mtim, flags) {</span>
                <span class="s1">if </span><span class="s0">(validateFstFlagsOrReturn(flags)) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ fileDescriptor, atim: atimRes, mtim: mtimRes } = fdFilestatGetTimes.call(</span><span class="s1">this</span><span class="s0">, fd, atim, mtim, flags);</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">fs.futimesSync(fileDescriptor.fd, Number(atimRes), Number(mtimRes));</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, async </span><span class="s1">function </span><span class="s0">fd_filestat_set_times(fd, atim, mtim, flags) {</span>
                <span class="s1">if </span><span class="s0">(validateFstFlagsOrReturn(flags)) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ fileDescriptor, atim: atimRes, mtim: mtimRes } = fdFilestatGetTimes.call(</span><span class="s1">this</span><span class="s0">, fd, atim, mtim, flags);</span>
                <span class="s1">const </span><span class="s0">h = fileDescriptor.fd;</span>
                <span class="s1">await </span><span class="s0">h.utimes(Number(atimRes), Number(mtimRes));</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, [</span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i64'</span><span class="s0">, </span><span class="s2">'i64'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">], [</span><span class="s2">'i32'</span><span class="s0">]);</span>
            <span class="s0">defineImport(</span><span class="s2">'fd_pread'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">fd_pread(fd, iovs, iovslen, offset, size) {</span>
                <span class="s0">iovs = Number(iovs);</span>
                <span class="s0">size = Number(size);</span>
                <span class="s1">if </span><span class="s0">((iovs === </span><span class="s4">0 </span><span class="s0">&amp;&amp; iovslen) || size === </span><span class="s4">0 </span><span class="s0">|| offset &gt; INT64_MAX) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8, view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_READ | WasiRights.FD_SEEK, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">if </span><span class="s0">(!iovslen) {</span>
                    <span class="s0">view.setUint32(size, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">let </span><span class="s0">totalSize = </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">ioVecs = Array.from({ length: Number(iovslen) }, (_, i) =&gt; {</span>
                    <span class="s1">const </span><span class="s0">offset = iovs + (i * </span><span class="s4">8</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">buf = view.getInt32(offset, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">bufLen = view.getUint32(offset + </span><span class="s4">4</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s0">totalSize += bufLen;</span>
                    <span class="s1">return </span><span class="s0">HEAPU8.subarray(buf, buf + bufLen);</span>
                <span class="s0">});</span>
                <span class="s1">let </span><span class="s0">nread = </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">buffer = (() =&gt; {</span>
                    <span class="s1">try </span><span class="s0">{</span>
                        <span class="s1">return new </span><span class="s0">Uint8Array(</span><span class="s1">new </span><span class="s0">SharedArrayBuffer(totalSize));</span>
                    <span class="s0">}</span>
                    <span class="s1">catch </span><span class="s0">(_) {</span>
                        <span class="s1">return new </span><span class="s0">Uint8Array(totalSize);</span>
                    <span class="s0">}</span>
                <span class="s0">})();</span>
                <span class="s0">buffer._isBuffer = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">bytesRead = fs.readSync(fileDescriptor.fd, buffer, </span><span class="s4">0</span><span class="s0">, buffer.length, Number(offset));</span>
                <span class="s0">nread = buffer ? copyMemory(ioVecs, buffer.subarray(</span><span class="s4">0</span><span class="s0">, bytesRead)) : </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s0">view.setUint32(size, nread, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, async </span><span class="s1">function </span><span class="s0">(fd, iovs, iovslen, offset, size) {</span>
                <span class="s0">iovs = Number(iovs);</span>
                <span class="s0">size = Number(size);</span>
                <span class="s1">if </span><span class="s0">((iovs === </span><span class="s4">0 </span><span class="s0">&amp;&amp; iovslen) || size === </span><span class="s4">0 </span><span class="s0">|| offset &gt; INT64_MAX) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8, view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_READ | WasiRights.FD_SEEK, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">if </span><span class="s0">(!iovslen) {</span>
                    <span class="s0">view.setUint32(size, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">let </span><span class="s0">totalSize = </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">ioVecs = Array.from({ length: Number(iovslen) }, (_, i) =&gt; {</span>
                    <span class="s1">const </span><span class="s0">offset = iovs + (i * </span><span class="s4">8</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">buf = view.getInt32(offset, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">bufLen = view.getUint32(offset + </span><span class="s4">4</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s0">totalSize += bufLen;</span>
                    <span class="s1">return </span><span class="s0">HEAPU8.subarray(buf, buf + bufLen);</span>
                <span class="s0">});</span>
                <span class="s1">let </span><span class="s0">nread = </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">buffer = </span><span class="s1">new </span><span class="s0">Uint8Array(totalSize);</span>
                <span class="s0">buffer._isBuffer = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">{ bytesRead } = </span><span class="s1">await </span><span class="s0">fileDescriptor.fd.read(buffer, </span><span class="s4">0</span><span class="s0">, buffer.length, Number(offset));</span>
                <span class="s0">nread = buffer ? copyMemory(ioVecs, buffer.subarray(</span><span class="s4">0</span><span class="s0">, bytesRead)) : </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s0">view.setUint32(size, nread, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, [</span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i64'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">], [</span><span class="s2">'i32'</span><span class="s0">]);</span>
            <span class="s0">defineImport(</span><span class="s2">'fd_pwrite'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">fd_pwrite(fd, iovs, iovslen, offset, size) {</span>
                <span class="s0">iovs = Number(iovs);</span>
                <span class="s0">size = Number(size);</span>
                <span class="s1">if </span><span class="s0">((iovs === </span><span class="s4">0 </span><span class="s0">&amp;&amp; iovslen) || size === </span><span class="s4">0 </span><span class="s0">|| offset &gt; INT64_MAX) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8, view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_WRITE | WasiRights.FD_SEEK, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">if </span><span class="s0">(!iovslen) {</span>
                    <span class="s0">view.setUint32(size, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">buffer = concatBuffer(Array.from({ length: Number(iovslen) }, (_, i) =&gt; {</span>
                    <span class="s1">const </span><span class="s0">offset = iovs + (i * </span><span class="s4">8</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">buf = view.getInt32(offset, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">bufLen = view.getUint32(offset + </span><span class="s4">4</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">return </span><span class="s0">HEAPU8.subarray(buf, buf + bufLen);</span>
                <span class="s0">}));</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">nwritten = fs.writeSync(fileDescriptor.fd, buffer, </span><span class="s4">0</span><span class="s0">, buffer.length, Number(offset));</span>
                <span class="s0">view.setUint32(size, nwritten, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, async </span><span class="s1">function </span><span class="s0">fd_pwrite(fd, iovs, iovslen, offset, size) {</span>
                <span class="s0">iovs = Number(iovs);</span>
                <span class="s0">size = Number(size);</span>
                <span class="s1">if </span><span class="s0">((iovs === </span><span class="s4">0 </span><span class="s0">&amp;&amp; iovslen) || size === </span><span class="s4">0 </span><span class="s0">|| offset &gt; INT64_MAX) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8, view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_WRITE | WasiRights.FD_SEEK, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">if </span><span class="s0">(!iovslen) {</span>
                    <span class="s0">view.setUint32(size, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">buffer = concatBuffer(Array.from({ length: Number(iovslen) }, (_, i) =&gt; {</span>
                    <span class="s1">const </span><span class="s0">offset = iovs + (i * </span><span class="s4">8</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">buf = view.getInt32(offset, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">bufLen = view.getUint32(offset + </span><span class="s4">4</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">return </span><span class="s0">HEAPU8.subarray(buf, buf + bufLen);</span>
                <span class="s0">}));</span>
                <span class="s1">const </span><span class="s0">{ bytesWritten } = </span><span class="s1">await </span><span class="s0">fileDescriptor.fd.write(buffer, </span><span class="s4">0</span><span class="s0">, buffer.length, Number(offset));</span>
                <span class="s0">view.setUint32(size, bytesWritten, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, [</span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i64'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">], [</span><span class="s2">'i32'</span><span class="s0">]);</span>
            <span class="s0">defineImport(</span><span class="s2">'fd_read'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">fd_read(fd, iovs, iovslen, size) {</span>
                <span class="s0">iovs = Number(iovs);</span>
                <span class="s0">size = Number(size);</span>
                <span class="s1">if </span><span class="s0">((iovs === </span><span class="s4">0 </span><span class="s0">&amp;&amp; iovslen) || size === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8, view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_READ, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">if </span><span class="s0">(!iovslen) {</span>
                    <span class="s0">view.setUint32(size, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">let </span><span class="s0">totalSize = </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">ioVecs = Array.from({ length: Number(iovslen) }, (_, i) =&gt; {</span>
                    <span class="s1">const </span><span class="s0">offset = iovs + (i * </span><span class="s4">8</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">buf = view.getInt32(offset, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">bufLen = view.getUint32(offset + </span><span class="s4">4</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s0">totalSize += bufLen;</span>
                    <span class="s1">return </span><span class="s0">HEAPU8.subarray(buf, buf + bufLen);</span>
                <span class="s0">});</span>
                <span class="s1">let </span><span class="s0">buffer;</span>
                <span class="s1">let </span><span class="s0">nread = </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(fd === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">window === </span><span class="s2">'undefined' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">window.prompt !== </span><span class="s2">'function'</span><span class="s0">) {</span>
                        <span class="s1">return </span><span class="s4">58 </span><span class="s3">/* WasiErrno.ENOTSUP */</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s0">buffer = readStdin();</span>
                    <span class="s0">nread = buffer ? copyMemory(ioVecs, buffer) : </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">buffer = (() =&gt; {</span>
                        <span class="s1">try </span><span class="s0">{</span>
                            <span class="s1">return new </span><span class="s0">Uint8Array(</span><span class="s1">new </span><span class="s0">SharedArrayBuffer(totalSize));</span>
                        <span class="s0">}</span>
                        <span class="s1">catch </span><span class="s0">(_) {</span>
                            <span class="s1">return new </span><span class="s0">Uint8Array(totalSize);</span>
                        <span class="s0">}</span>
                    <span class="s0">})();</span>
                    <span class="s0">buffer._isBuffer = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">bytesRead = fs.readSync(fileDescriptor.fd, buffer, </span><span class="s4">0</span><span class="s0">, buffer.length, Number(fileDescriptor.pos));</span>
                    <span class="s0">nread = buffer ? copyMemory(ioVecs, buffer.subarray(</span><span class="s4">0</span><span class="s0">, bytesRead)) : </span><span class="s4">0</span><span class="s0">;</span>
                    <span class="s0">fileDescriptor.pos += BigInt(nread);</span>
                <span class="s0">}</span>
                <span class="s0">view.setUint32(size, nread, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, async </span><span class="s1">function </span><span class="s0">fd_read(fd, iovs, iovslen, size) {</span>
                <span class="s0">iovs = Number(iovs);</span>
                <span class="s0">size = Number(size);</span>
                <span class="s1">if </span><span class="s0">((iovs === </span><span class="s4">0 </span><span class="s0">&amp;&amp; iovslen) || size === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8, view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_READ, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">if </span><span class="s0">(!iovslen) {</span>
                    <span class="s0">view.setUint32(size, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">let </span><span class="s0">totalSize = </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">ioVecs = Array.from({ length: Number(iovslen) }, (_, i) =&gt; {</span>
                    <span class="s1">const </span><span class="s0">offset = iovs + (i * </span><span class="s4">8</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">buf = view.getInt32(offset, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">bufLen = view.getUint32(offset + </span><span class="s4">4</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s0">totalSize += bufLen;</span>
                    <span class="s1">return </span><span class="s0">HEAPU8.subarray(buf, buf + bufLen);</span>
                <span class="s0">});</span>
                <span class="s1">let </span><span class="s0">buffer;</span>
                <span class="s1">let </span><span class="s0">nread = </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(fd === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">window === </span><span class="s2">'undefined' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">window.prompt !== </span><span class="s2">'function'</span><span class="s0">) {</span>
                        <span class="s1">return </span><span class="s4">58 </span><span class="s3">/* WasiErrno.ENOTSUP */</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s0">buffer = readStdin();</span>
                    <span class="s0">nread = buffer ? copyMemory(ioVecs, buffer) : </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">buffer = </span><span class="s1">new </span><span class="s0">Uint8Array(totalSize);</span>
                    <span class="s0">buffer._isBuffer = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s1">const </span><span class="s0">{ bytesRead } = </span><span class="s1">await </span><span class="s0">fileDescriptor.fd.read(buffer, </span><span class="s4">0</span><span class="s0">, buffer.length, Number(fileDescriptor.pos));</span>
                    <span class="s0">nread = buffer ? copyMemory(ioVecs, buffer.subarray(</span><span class="s4">0</span><span class="s0">, bytesRead)) : </span><span class="s4">0</span><span class="s0">;</span>
                    <span class="s0">fileDescriptor.pos += BigInt(nread);</span>
                <span class="s0">}</span>
                <span class="s0">view.setUint32(size, nread, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, [</span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">], [</span><span class="s2">'i32'</span><span class="s0">]);</span>
            <span class="s0">defineImport(</span><span class="s2">'fd_readdir'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">fd_readdir(fd, buf, buf_len, cookie, bufused) {</span>
                <span class="s0">buf = Number(buf);</span>
                <span class="s0">buf_len = Number(buf_len);</span>
                <span class="s0">bufused = Number(bufused);</span>
                <span class="s1">if </span><span class="s0">(buf === </span><span class="s4">0 </span><span class="s0">|| bufused === </span><span class="s4">0</span><span class="s0">)</span>
                    <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_READDIR, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">entries = fs.readdirSync(fileDescriptor.realPath, { withFileTypes: </span><span class="s1">true </span><span class="s0">});</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8, view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">let </span><span class="s0">bufferUsed = </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = Number(cookie); i &lt; entries.length; i++) {</span>
                    <span class="s1">const </span><span class="s0">nameData = encoder.encode(entries[i].name);</span>
                    <span class="s1">const </span><span class="s0">entryInfo = fs.statSync(resolve(fileDescriptor.realPath, entries[i].name), { bigint: </span><span class="s1">true </span><span class="s0">});</span>
                    <span class="s1">const </span><span class="s0">entryData = </span><span class="s1">new </span><span class="s0">Uint8Array(</span><span class="s4">24 </span><span class="s0">+ nameData.byteLength);</span>
                    <span class="s1">const </span><span class="s0">entryView = </span><span class="s1">new </span><span class="s0">DataView(entryData.buffer);</span>
                    <span class="s0">entryView.setBigUint64(</span><span class="s4">0</span><span class="s0">, BigInt(i + </span><span class="s4">1</span><span class="s0">), </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s0">entryView.setBigUint64(</span><span class="s4">8</span><span class="s0">, BigInt(entryInfo.ino ? entryInfo.ino : </span><span class="s4">0</span><span class="s0">), </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s0">entryView.setUint32(</span><span class="s4">16</span><span class="s0">, nameData.byteLength, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">let </span><span class="s0">type;</span>
                    <span class="s1">if </span><span class="s0">(entries[i].isFile()) {</span>
                        <span class="s0">type = </span><span class="s4">4 </span><span class="s3">/* WasiFileType.REGULAR_FILE */</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">else if </span><span class="s0">(entries[i].isDirectory()) {</span>
                        <span class="s0">type = </span><span class="s4">3 </span><span class="s3">/* WasiFileType.DIRECTORY */</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">else if </span><span class="s0">(entries[i].isSymbolicLink()) {</span>
                        <span class="s0">type = </span><span class="s4">7 </span><span class="s3">/* WasiFileType.SYMBOLIC_LINK */</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">else if </span><span class="s0">(entries[i].isCharacterDevice()) {</span>
                        <span class="s0">type = </span><span class="s4">2 </span><span class="s3">/* WasiFileType.CHARACTER_DEVICE */</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">else if </span><span class="s0">(entries[i].isBlockDevice()) {</span>
                        <span class="s0">type = </span><span class="s4">1 </span><span class="s3">/* WasiFileType.BLOCK_DEVICE */</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">else if </span><span class="s0">(entries[i].isSocket()) {</span>
                        <span class="s0">type = </span><span class="s4">6 </span><span class="s3">/* WasiFileType.SOCKET_STREAM */</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">else </span><span class="s0">{</span>
                        <span class="s0">type = </span><span class="s4">0 </span><span class="s3">/* WasiFileType.UNKNOWN */</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s0">entryView.setUint8(</span><span class="s4">20</span><span class="s0">, type);</span>
                    <span class="s0">entryData.set(nameData, </span><span class="s4">24</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">data = entryData.slice(</span><span class="s4">0</span><span class="s0">, Math.min(entryData.length, buf_len - bufferUsed));</span>
                    <span class="s0">HEAPU8.set(data, buf + bufferUsed);</span>
                    <span class="s0">bufferUsed += data.byteLength;</span>
                <span class="s0">}</span>
                <span class="s0">view.setUint32(bufused, bufferUsed, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, async </span><span class="s1">function </span><span class="s0">fd_readdir(fd, buf, buf_len, cookie, bufused) {</span>
                <span class="s0">buf = Number(buf);</span>
                <span class="s0">buf_len = Number(buf_len);</span>
                <span class="s0">bufused = Number(bufused);</span>
                <span class="s1">if </span><span class="s0">(buf === </span><span class="s4">0 </span><span class="s0">|| bufused === </span><span class="s4">0</span><span class="s0">)</span>
                    <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_READDIR, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">entries = </span><span class="s1">await </span><span class="s0">fs.promises.readdir(fileDescriptor.realPath, { withFileTypes: </span><span class="s1">true </span><span class="s0">});</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8, view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">let </span><span class="s0">bufferUsed = </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = Number(cookie); i &lt; entries.length; i++) {</span>
                    <span class="s1">const </span><span class="s0">nameData = encoder.encode(entries[i].name);</span>
                    <span class="s1">const </span><span class="s0">entryInfo = </span><span class="s1">await </span><span class="s0">fs.promises.stat(resolve(fileDescriptor.realPath, entries[i].name), { bigint: </span><span class="s1">true </span><span class="s0">});</span>
                    <span class="s1">const </span><span class="s0">entryData = </span><span class="s1">new </span><span class="s0">Uint8Array(</span><span class="s4">24 </span><span class="s0">+ nameData.byteLength);</span>
                    <span class="s1">const </span><span class="s0">entryView = </span><span class="s1">new </span><span class="s0">DataView(entryData.buffer);</span>
                    <span class="s0">entryView.setBigUint64(</span><span class="s4">0</span><span class="s0">, BigInt(i + </span><span class="s4">1</span><span class="s0">), </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s0">entryView.setBigUint64(</span><span class="s4">8</span><span class="s0">, BigInt(entryInfo.ino ? entryInfo.ino : </span><span class="s4">0</span><span class="s0">), </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s0">entryView.setUint32(</span><span class="s4">16</span><span class="s0">, nameData.byteLength, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">let </span><span class="s0">type;</span>
                    <span class="s1">if </span><span class="s0">(entries[i].isFile()) {</span>
                        <span class="s0">type = </span><span class="s4">4 </span><span class="s3">/* WasiFileType.REGULAR_FILE */</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">else if </span><span class="s0">(entries[i].isDirectory()) {</span>
                        <span class="s0">type = </span><span class="s4">3 </span><span class="s3">/* WasiFileType.DIRECTORY */</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">else if </span><span class="s0">(entries[i].isSymbolicLink()) {</span>
                        <span class="s0">type = </span><span class="s4">7 </span><span class="s3">/* WasiFileType.SYMBOLIC_LINK */</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">else if </span><span class="s0">(entries[i].isCharacterDevice()) {</span>
                        <span class="s0">type = </span><span class="s4">2 </span><span class="s3">/* WasiFileType.CHARACTER_DEVICE */</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">else if </span><span class="s0">(entries[i].isBlockDevice()) {</span>
                        <span class="s0">type = </span><span class="s4">1 </span><span class="s3">/* WasiFileType.BLOCK_DEVICE */</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">else if </span><span class="s0">(entries[i].isSocket()) {</span>
                        <span class="s0">type = </span><span class="s4">6 </span><span class="s3">/* WasiFileType.SOCKET_STREAM */</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">else </span><span class="s0">{</span>
                        <span class="s0">type = </span><span class="s4">0 </span><span class="s3">/* WasiFileType.UNKNOWN */</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s0">entryView.setUint8(</span><span class="s4">20</span><span class="s0">, type);</span>
                    <span class="s0">entryData.set(nameData, </span><span class="s4">24</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">data = entryData.slice(</span><span class="s4">0</span><span class="s0">, Math.min(entryData.length, buf_len - bufferUsed));</span>
                    <span class="s0">HEAPU8.set(data, buf + bufferUsed);</span>
                    <span class="s0">bufferUsed += data.byteLength;</span>
                <span class="s0">}</span>
                <span class="s0">view.setUint32(bufused, bufferUsed, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, [</span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i64'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">], [</span><span class="s2">'i32'</span><span class="s0">]);</span>
            <span class="s0">defineImport(</span><span class="s2">'fd_renumber'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">fd_renumber(from, to) {</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">wasi.fds.renumber(to, from);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, async </span><span class="s1">function </span><span class="s0">fd_renumber(from, to) {</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">await </span><span class="s0">wasi.fds.renumber(to, from);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, [</span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">], [</span><span class="s2">'i32'</span><span class="s0">]);</span>
            <span class="s0">defineImport(</span><span class="s2">'fd_sync'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">fd_sync(fd) {</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_SYNC, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">fs.fsyncSync(fileDescriptor.fd);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, async </span><span class="s1">function </span><span class="s0">fd_sync(fd) {</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_SYNC, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">await </span><span class="s0">fileDescriptor.fd.sync();</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, [</span><span class="s2">'i32'</span><span class="s0">], [</span><span class="s2">'i32'</span><span class="s0">]);</span>
            <span class="s0">defineImport(</span><span class="s2">'fd_write'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">fd_write(fd, iovs, iovslen, size) {</span>
                <span class="s0">iovs = Number(iovs);</span>
                <span class="s0">size = Number(size);</span>
                <span class="s1">if </span><span class="s0">((iovs === </span><span class="s4">0 </span><span class="s0">&amp;&amp; iovslen) || size === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8, view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_WRITE, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">if </span><span class="s0">(!iovslen) {</span>
                    <span class="s0">view.setUint32(size, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">buffer = concatBuffer(Array.from({ length: Number(iovslen) }, (_, i) =&gt; {</span>
                    <span class="s1">const </span><span class="s0">offset = iovs + (i * </span><span class="s4">8</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">buf = view.getInt32(offset, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">bufLen = view.getUint32(offset + </span><span class="s4">4</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">return </span><span class="s0">HEAPU8.subarray(buf, buf + bufLen);</span>
                <span class="s0">}));</span>
                <span class="s1">let </span><span class="s0">nwritten;</span>
                <span class="s1">if </span><span class="s0">(fd === </span><span class="s4">1 </span><span class="s0">|| fd === </span><span class="s4">2</span><span class="s0">) {</span>
                    <span class="s0">nwritten = fileDescriptor.write(buffer);</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                    <span class="s0">nwritten = fs.writeSync(fileDescriptor.fd, buffer, </span><span class="s4">0</span><span class="s0">, buffer.length, Number(fileDescriptor.pos));</span>
                    <span class="s0">fileDescriptor.pos += BigInt(nwritten);</span>
                <span class="s0">}</span>
                <span class="s0">view.setUint32(size, nwritten, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, async </span><span class="s1">function </span><span class="s0">fd_write(fd, iovs, iovslen, size) {</span>
                <span class="s0">iovs = Number(iovs);</span>
                <span class="s0">size = Number(size);</span>
                <span class="s1">if </span><span class="s0">((iovs === </span><span class="s4">0 </span><span class="s0">&amp;&amp; iovslen) || size === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8, view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_WRITE, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">if </span><span class="s0">(!iovslen) {</span>
                    <span class="s0">view.setUint32(size, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">buffer = concatBuffer(Array.from({ length: Number(iovslen) }, (_, i) =&gt; {</span>
                    <span class="s1">const </span><span class="s0">offset = iovs + (i * </span><span class="s4">8</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">buf = view.getInt32(offset, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">bufLen = view.getUint32(offset + </span><span class="s4">4</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">return </span><span class="s0">HEAPU8.subarray(buf, buf + bufLen);</span>
                <span class="s0">}));</span>
                <span class="s1">let </span><span class="s0">nwritten;</span>
                <span class="s1">if </span><span class="s0">(fd === </span><span class="s4">1 </span><span class="s0">|| fd === </span><span class="s4">2</span><span class="s0">) {</span>
                    <span class="s0">nwritten = fileDescriptor.write(buffer);</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">nwritten = </span><span class="s1">await </span><span class="s0">(</span><span class="s1">await </span><span class="s0">(fileDescriptor.fd.write(buffer, </span><span class="s4">0</span><span class="s0">, buffer.length, Number(fileDescriptor.pos)))).bytesWritten;</span>
                    <span class="s0">fileDescriptor.pos += BigInt(nwritten);</span>
                <span class="s0">}</span>
                <span class="s0">view.setUint32(size, nwritten, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, [</span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">], [</span><span class="s2">'i32'</span><span class="s0">]);</span>
            <span class="s0">defineImport(</span><span class="s2">'path_create_directory'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">path_create_directory(fd, path, path_len) {</span>
                <span class="s0">path = Number(path);</span>
                <span class="s0">path_len = Number(path_len);</span>
                <span class="s1">if </span><span class="s0">(path === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8 } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_CREATE_DIRECTORY, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">let </span><span class="s0">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
                <span class="s0">pathString = resolve(fileDescriptor.realPath, pathString);</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">fs.mkdirSync(pathString);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, async </span><span class="s1">function </span><span class="s0">path_create_directory(fd, path, path_len) {</span>
                <span class="s0">path = Number(path);</span>
                <span class="s0">path_len = Number(path_len);</span>
                <span class="s1">if </span><span class="s0">(path === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8 } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_CREATE_DIRECTORY, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">let </span><span class="s0">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
                <span class="s0">pathString = resolve(fileDescriptor.realPath, pathString);</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">await </span><span class="s0">fs.promises.mkdir(pathString);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, [</span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">], [</span><span class="s2">'i32'</span><span class="s0">]);</span>
            <span class="s0">defineImport(</span><span class="s2">'path_filestat_get'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">path_filestat_get(fd, flags, path, path_len, filestat) {</span>
                <span class="s0">path = Number(path);</span>
                <span class="s0">path_len = Number(path_len);</span>
                <span class="s0">filestat = Number(filestat);</span>
                <span class="s1">if </span><span class="s0">(path === </span><span class="s4">0 </span><span class="s0">|| filestat === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8, view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_FILESTAT_GET, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">let </span><span class="s0">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">pathString = resolve(fileDescriptor.realPath, pathString);</span>
                <span class="s1">let </span><span class="s0">stat;</span>
                <span class="s1">if </span><span class="s0">((flags &amp; </span><span class="s4">1</span><span class="s0">) === </span><span class="s4">1</span><span class="s0">) {</span>
                    <span class="s0">stat = fs.statSync(pathString, { bigint: </span><span class="s1">true </span><span class="s0">});</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">stat = fs.lstatSync(pathString, { bigint: </span><span class="s1">true </span><span class="s0">});</span>
                <span class="s0">}</span>
                <span class="s0">toFileStat(view, filestat, stat);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, async </span><span class="s1">function </span><span class="s0">path_filestat_get(fd, flags, path, path_len, filestat) {</span>
                <span class="s0">path = Number(path);</span>
                <span class="s0">path_len = Number(path_len);</span>
                <span class="s0">filestat = Number(filestat);</span>
                <span class="s1">if </span><span class="s0">(path === </span><span class="s4">0 </span><span class="s0">|| filestat === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8, view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_FILESTAT_GET, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">let </span><span class="s0">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">pathString = resolve(fileDescriptor.realPath, pathString);</span>
                <span class="s1">let </span><span class="s0">stat;</span>
                <span class="s1">if </span><span class="s0">((flags &amp; </span><span class="s4">1</span><span class="s0">) === </span><span class="s4">1</span><span class="s0">) {</span>
                    <span class="s0">stat = </span><span class="s1">await </span><span class="s0">fs.promises.stat(pathString, { bigint: </span><span class="s1">true </span><span class="s0">});</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">stat = </span><span class="s1">await </span><span class="s0">fs.promises.lstat(pathString, { bigint: </span><span class="s1">true </span><span class="s0">});</span>
                <span class="s0">}</span>
                <span class="s0">toFileStat(view, filestat, stat);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, [</span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">], [</span><span class="s2">'i32'</span><span class="s0">]);</span>
            <span class="s0">defineImport(</span><span class="s2">'path_filestat_set_times'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">path_filestat_set_times(fd, flags, path, path_len, atim, mtim, fst_flags) {</span>
                <span class="s0">path = Number(path);</span>
                <span class="s0">path_len = Number(path_len);</span>
                <span class="s1">if </span><span class="s0">(path === </span><span class="s4">0</span><span class="s0">)</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8 } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_FILESTAT_SET_TIMES, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">if </span><span class="s0">(validateFstFlagsOrReturn(fst_flags)) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">resolvedPath = resolvePathSync(fs, fileDescriptor, decoder.decode(unsharedSlice(HEAPU8, path, path + path_len)), flags);</span>
                <span class="s1">if </span><span class="s0">((fst_flags &amp; </span><span class="s4">2 </span><span class="s3">/* WasiFstFlag.SET_ATIM_NOW */</span><span class="s0">) === </span><span class="s4">2 </span><span class="s3">/* WasiFstFlag.SET_ATIM_NOW */</span><span class="s0">) {</span>
                    <span class="s0">atim = BigInt(Date.now() * </span><span class="s4">1000000</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">((fst_flags &amp; </span><span class="s4">8 </span><span class="s3">/* WasiFstFlag.SET_MTIM_NOW */</span><span class="s0">) === </span><span class="s4">8 </span><span class="s3">/* WasiFstFlag.SET_MTIM_NOW */</span><span class="s0">) {</span>
                    <span class="s0">mtim = BigInt(Date.now() * </span><span class="s4">1000000</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s0">fs.utimesSync(resolvedPath, Number(atim), Number(mtim));</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, async </span><span class="s1">function </span><span class="s0">path_filestat_set_times(fd, flags, path, path_len, atim, mtim, fst_flags) {</span>
                <span class="s0">path = Number(path);</span>
                <span class="s0">path_len = Number(path_len);</span>
                <span class="s1">if </span><span class="s0">(path === </span><span class="s4">0</span><span class="s0">)</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8 } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_FILESTAT_SET_TIMES, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">if </span><span class="s0">(validateFstFlagsOrReturn(fst_flags)) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">resolvedPath = </span><span class="s1">await </span><span class="s0">resolvePathAsync(fs, fileDescriptor, decoder.decode(unsharedSlice(HEAPU8, path, path + path_len)), flags);</span>
                <span class="s1">if </span><span class="s0">((fst_flags &amp; </span><span class="s4">2 </span><span class="s3">/* WasiFstFlag.SET_ATIM_NOW */</span><span class="s0">) === </span><span class="s4">2 </span><span class="s3">/* WasiFstFlag.SET_ATIM_NOW */</span><span class="s0">) {</span>
                    <span class="s0">atim = BigInt(Date.now() * </span><span class="s4">1000000</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">((fst_flags &amp; </span><span class="s4">8 </span><span class="s3">/* WasiFstFlag.SET_MTIM_NOW */</span><span class="s0">) === </span><span class="s4">8 </span><span class="s3">/* WasiFstFlag.SET_MTIM_NOW */</span><span class="s0">) {</span>
                    <span class="s0">mtim = BigInt(Date.now() * </span><span class="s4">1000000</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s1">await </span><span class="s0">fs.promises.utimes(resolvedPath, Number(atim), Number(mtim));</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, [</span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i64'</span><span class="s0">, </span><span class="s2">'i64'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">], [</span><span class="s2">'i32'</span><span class="s0">]);</span>
            <span class="s0">defineImport(</span><span class="s2">'path_link'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">path_link(old_fd, old_flags, old_path, old_path_len, new_fd, new_path, new_path_len) {</span>
                <span class="s0">old_path = Number(old_path);</span>
                <span class="s0">old_path_len = Number(old_path_len);</span>
                <span class="s0">new_path = Number(new_path);</span>
                <span class="s0">new_path_len = Number(new_path_len);</span>
                <span class="s1">if </span><span class="s0">(old_path === </span><span class="s4">0 </span><span class="s0">|| new_path === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">let </span><span class="s0">oldWrap;</span>
                <span class="s1">let </span><span class="s0">newWrap;</span>
                <span class="s1">if </span><span class="s0">(old_fd === new_fd) {</span>
                    <span class="s0">oldWrap = newWrap = wasi.fds.get(old_fd, WasiRights.PATH_LINK_SOURCE | WasiRights.PATH_LINK_TARGET, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">oldWrap = wasi.fds.get(old_fd, WasiRights.PATH_LINK_SOURCE, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                    <span class="s0">newWrap = wasi.fds.get(new_fd, WasiRights.PATH_LINK_TARGET, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8 } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">resolvedOldPath = resolvePathSync(fs, oldWrap, decoder.decode(unsharedSlice(HEAPU8, old_path, old_path + old_path_len)), old_flags);</span>
                <span class="s1">const </span><span class="s0">resolvedNewPath = resolve(newWrap.realPath, decoder.decode(unsharedSlice(HEAPU8, new_path, new_path + new_path_len)));</span>
                <span class="s0">fs.linkSync(resolvedOldPath, resolvedNewPath);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, async </span><span class="s1">function </span><span class="s0">path_link(old_fd, old_flags, old_path, old_path_len, new_fd, new_path, new_path_len) {</span>
                <span class="s0">old_path = Number(old_path);</span>
                <span class="s0">old_path_len = Number(old_path_len);</span>
                <span class="s0">new_path = Number(new_path);</span>
                <span class="s0">new_path_len = Number(new_path_len);</span>
                <span class="s1">if </span><span class="s0">(old_path === </span><span class="s4">0 </span><span class="s0">|| new_path === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">let </span><span class="s0">oldWrap;</span>
                <span class="s1">let </span><span class="s0">newWrap;</span>
                <span class="s1">if </span><span class="s0">(old_fd === new_fd) {</span>
                    <span class="s0">oldWrap = newWrap = wasi.fds.get(old_fd, WasiRights.PATH_LINK_SOURCE | WasiRights.PATH_LINK_TARGET, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">oldWrap = wasi.fds.get(old_fd, WasiRights.PATH_LINK_SOURCE, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                    <span class="s0">newWrap = wasi.fds.get(new_fd, WasiRights.PATH_LINK_TARGET, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8 } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">resolvedOldPath = </span><span class="s1">await </span><span class="s0">resolvePathAsync(fs, oldWrap, decoder.decode(unsharedSlice(HEAPU8, old_path, old_path + old_path_len)), old_flags);</span>
                <span class="s1">const </span><span class="s0">resolvedNewPath = resolve(newWrap.realPath, decoder.decode(unsharedSlice(HEAPU8, new_path, new_path + new_path_len)));</span>
                <span class="s1">await </span><span class="s0">fs.promises.link(resolvedOldPath, resolvedNewPath);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, [</span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">], [</span><span class="s2">'i32'</span><span class="s0">]);</span>
            <span class="s1">function </span><span class="s0">pathOpen(o_flags, fs_rights_base, fs_rights_inheriting, fs_flags) {</span>
                <span class="s1">const </span><span class="s0">read = (fs_rights_base &amp; (WasiRights.FD_READ |</span>
                    <span class="s0">WasiRights.FD_READDIR)) !== BigInt(</span><span class="s4">0</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">write = (fs_rights_base &amp; (WasiRights.FD_DATASYNC |</span>
                    <span class="s0">WasiRights.FD_WRITE |</span>
                    <span class="s0">WasiRights.FD_ALLOCATE |</span>
                    <span class="s0">WasiRights.FD_FILESTAT_SET_SIZE)) !== BigInt(</span><span class="s4">0</span><span class="s0">);</span>
                <span class="s1">let </span><span class="s0">flags = write ? read ? </span><span class="s4">2 </span><span class="s3">/* FileControlFlag.O_RDWR */ </span><span class="s0">: </span><span class="s4">1 </span><span class="s3">/* FileControlFlag.O_WRONLY */ </span><span class="s0">: </span><span class="s4">0 </span><span class="s3">/* FileControlFlag.O_RDONLY */</span><span class="s0">;</span>
                <span class="s1">let </span><span class="s0">needed_base = WasiRights.PATH_OPEN;</span>
                <span class="s1">let </span><span class="s0">needed_inheriting = fs_rights_base | fs_rights_inheriting;</span>
                <span class="s1">if </span><span class="s0">((o_flags &amp; </span><span class="s4">1 </span><span class="s3">/* WasiFileControlFlag.O_CREAT */</span><span class="s0">) !== </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s0">flags |= </span><span class="s4">64 </span><span class="s3">/* FileControlFlag.O_CREAT */</span><span class="s0">;</span>
                    <span class="s0">needed_base |= WasiRights.PATH_CREATE_FILE;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">((o_flags &amp; </span><span class="s4">2 </span><span class="s3">/* WasiFileControlFlag.O_DIRECTORY */</span><span class="s0">) !== </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s0">flags |= </span><span class="s4">65536 </span><span class="s3">/* FileControlFlag.O_DIRECTORY */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">((o_flags &amp; </span><span class="s4">4 </span><span class="s3">/* WasiFileControlFlag.O_EXCL */</span><span class="s0">) !== </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s0">flags |= </span><span class="s4">128 </span><span class="s3">/* FileControlFlag.O_EXCL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">((o_flags &amp; </span><span class="s4">8 </span><span class="s3">/* WasiFileControlFlag.O_TRUNC */</span><span class="s0">) !== </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s0">flags |= </span><span class="s4">512 </span><span class="s3">/* FileControlFlag.O_TRUNC */</span><span class="s0">;</span>
                    <span class="s0">needed_base |= WasiRights.PATH_FILESTAT_SET_SIZE;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">((fs_flags &amp; </span><span class="s4">1 </span><span class="s3">/* WasiFdFlag.APPEND */</span><span class="s0">) !== </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s0">flags |= </span><span class="s4">1024 </span><span class="s3">/* FileControlFlag.O_APPEND */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">((fs_flags &amp; </span><span class="s4">2 </span><span class="s3">/* WasiFdFlag.DSYNC */</span><span class="s0">) !== </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s3">// flags |= FileControlFlag.O_DSYNC;</span>
                    <span class="s0">needed_inheriting |= WasiRights.FD_DATASYNC;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">((fs_flags &amp; </span><span class="s4">4 </span><span class="s3">/* WasiFdFlag.NONBLOCK */</span><span class="s0">) !== </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s0">flags |= </span><span class="s4">2048 </span><span class="s3">/* FileControlFlag.O_NONBLOCK */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">((fs_flags &amp; </span><span class="s4">8 </span><span class="s3">/* WasiFdFlag.RSYNC */</span><span class="s0">) !== </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s0">flags |= </span><span class="s4">1052672 </span><span class="s3">/* FileControlFlag.O_SYNC */</span><span class="s0">;</span>
                    <span class="s0">needed_inheriting |= WasiRights.FD_SYNC;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">((fs_flags &amp; </span><span class="s4">16 </span><span class="s3">/* WasiFdFlag.SYNC */</span><span class="s0">) !== </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s0">flags |= </span><span class="s4">1052672 </span><span class="s3">/* FileControlFlag.O_SYNC */</span><span class="s0">;</span>
                    <span class="s0">needed_inheriting |= WasiRights.FD_SYNC;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(write &amp;&amp; (flags &amp; (</span><span class="s4">1024 </span><span class="s3">/* FileControlFlag.O_APPEND */ </span><span class="s0">| </span><span class="s4">512 </span><span class="s3">/* FileControlFlag.O_TRUNC */</span><span class="s0">)) === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s0">needed_inheriting |= WasiRights.FD_SEEK;</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">{ flags, needed_base, needed_inheriting };</span>
            <span class="s0">}</span>
            <span class="s0">defineImport(</span><span class="s2">'path_open'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">path_open(dirfd, dirflags, path, path_len, o_flags, fs_rights_base, fs_rights_inheriting, fs_flags, fd) {</span>
                <span class="s0">path = Number(path);</span>
                <span class="s0">fd = Number(fd);</span>
                <span class="s1">if </span><span class="s0">(path === </span><span class="s4">0 </span><span class="s0">|| fd === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">path_len = Number(path_len);</span>
                <span class="s0">fs_rights_base = BigInt(fs_rights_base);</span>
                <span class="s0">fs_rights_inheriting = BigInt(fs_rights_inheriting);</span>
                <span class="s1">const </span><span class="s0">{ flags: flagsRes, needed_base: neededBase, needed_inheriting: neededInheriting } = pathOpen(o_flags, fs_rights_base, fs_rights_inheriting, fs_flags);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(dirfd, neededBase, neededInheriting);</span>
                <span class="s1">const </span><span class="s0">memory = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">HEAPU8 = memory.HEAPU8;</span>
                <span class="s1">const </span><span class="s0">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">resolved_path = resolvePathSync(fs, fileDescriptor, pathString, dirflags);</span>
                <span class="s1">const </span><span class="s0">r = fs.openSync(resolved_path, flagsRes, </span><span class="s4">0o666</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">filetype = wasi.fds.getFileTypeByFd(r);</span>
                <span class="s1">if </span><span class="s0">((filetype !== </span><span class="s4">3 </span><span class="s3">/* WasiFileType.DIRECTORY */</span><span class="s0">) &amp;&amp;</span>
                    <span class="s0">((o_flags &amp; </span><span class="s4">2 </span><span class="s3">/* WasiFileControlFlag.O_DIRECTORY */</span><span class="s0">) !== </span><span class="s4">0 </span><span class="s0">||</span>
                        <span class="s0">(resolved_path.endsWith(</span><span class="s2">'/'</span><span class="s0">)))) {</span>
                    <span class="s1">return </span><span class="s4">54 </span><span class="s3">/* WasiErrno.ENOTDIR */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ base: max_base, inheriting: max_inheriting } = getRights(wasi.fds.stdio, r, flagsRes, filetype);</span>
                <span class="s1">const </span><span class="s0">wrap = wasi.fds.insert(r, resolved_path, resolved_path, filetype, fs_rights_base &amp; max_base, fs_rights_inheriting &amp; max_inheriting, </span><span class="s4">0</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">stat = fs.fstatSync(r, { bigint: </span><span class="s1">true </span><span class="s0">});</span>
                <span class="s1">if </span><span class="s0">(stat.isFile()) {</span>
                    <span class="s0">wrap.size = stat.size;</span>
                    <span class="s1">if </span><span class="s0">((flagsRes &amp; </span><span class="s4">1024 </span><span class="s3">/* FileControlFlag.O_APPEND */</span><span class="s0">) !== </span><span class="s4">0</span><span class="s0">) {</span>
                        <span class="s0">wrap.pos = stat.size;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">view = memory.view;</span>
                <span class="s0">view.setInt32(fd, wrap.id, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, async </span><span class="s1">function </span><span class="s0">path_open(dirfd, dirflags, path, path_len, o_flags, fs_rights_base, fs_rights_inheriting, fs_flags, fd) {</span>
                <span class="s0">path = Number(path);</span>
                <span class="s0">fd = Number(fd);</span>
                <span class="s1">if </span><span class="s0">(path === </span><span class="s4">0 </span><span class="s0">|| fd === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">path_len = Number(path_len);</span>
                <span class="s0">fs_rights_base = BigInt(fs_rights_base);</span>
                <span class="s0">fs_rights_inheriting = BigInt(fs_rights_inheriting);</span>
                <span class="s1">const </span><span class="s0">{ flags: flagsRes, needed_base: neededBase, needed_inheriting: neededInheriting } = pathOpen(o_flags, fs_rights_base, fs_rights_inheriting, fs_flags);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(dirfd, neededBase, neededInheriting);</span>
                <span class="s1">const </span><span class="s0">memory = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">HEAPU8 = memory.HEAPU8;</span>
                <span class="s1">const </span><span class="s0">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">resolved_path = </span><span class="s1">await </span><span class="s0">resolvePathAsync(fs, fileDescriptor, pathString, dirflags);</span>
                <span class="s1">const </span><span class="s0">r = </span><span class="s1">await </span><span class="s0">fs.promises.open(resolved_path, flagsRes, </span><span class="s4">0o666</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">filetype = </span><span class="s1">await </span><span class="s0">wasi.fds.getFileTypeByFd(r);</span>
                <span class="s1">if </span><span class="s0">((o_flags &amp; </span><span class="s4">2 </span><span class="s3">/* WasiFileControlFlag.O_DIRECTORY */</span><span class="s0">) !== </span><span class="s4">0 </span><span class="s0">&amp;&amp; filetype !== </span><span class="s4">3 </span><span class="s3">/* WasiFileType.DIRECTORY */</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">54 </span><span class="s3">/* WasiErrno.ENOTDIR */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ base: max_base, inheriting: max_inheriting } = getRights(wasi.fds.stdio, r.fd, flagsRes, filetype);</span>
                <span class="s1">const </span><span class="s0">wrap = wasi.fds.insert(r, resolved_path, resolved_path, filetype, fs_rights_base &amp; max_base, fs_rights_inheriting &amp; max_inheriting, </span><span class="s4">0</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">stat = </span><span class="s1">await </span><span class="s0">r.stat({ bigint: </span><span class="s1">true </span><span class="s0">});</span>
                <span class="s1">if </span><span class="s0">(stat.isFile()) {</span>
                    <span class="s0">wrap.size = stat.size;</span>
                    <span class="s1">if </span><span class="s0">((flagsRes &amp; </span><span class="s4">1024 </span><span class="s3">/* FileControlFlag.O_APPEND */</span><span class="s0">) !== </span><span class="s4">0</span><span class="s0">) {</span>
                        <span class="s0">wrap.pos = stat.size;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">view = memory.view;</span>
                <span class="s0">view.setInt32(fd, wrap.id, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, [</span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i64'</span><span class="s0">, </span><span class="s2">'i64'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">], [</span><span class="s2">'i32'</span><span class="s0">]);</span>
            <span class="s0">defineImport(</span><span class="s2">'path_readlink'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">path_readlink(fd, path, path_len, buf, buf_len, bufused) {</span>
                <span class="s0">path = Number(path);</span>
                <span class="s0">path_len = Number(path_len);</span>
                <span class="s0">buf = Number(buf);</span>
                <span class="s0">buf_len = Number(buf_len);</span>
                <span class="s0">bufused = Number(bufused);</span>
                <span class="s1">if </span><span class="s0">(path === </span><span class="s4">0 </span><span class="s0">|| buf === </span><span class="s4">0 </span><span class="s0">|| bufused === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8, view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_READLINK, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">let </span><span class="s0">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
                <span class="s0">pathString = resolve(fileDescriptor.realPath, pathString);</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">link = fs.readlinkSync(pathString);</span>
                <span class="s1">const </span><span class="s0">linkData = encoder.encode(link);</span>
                <span class="s1">const </span><span class="s0">len = Math.min(linkData.length, buf_len);</span>
                <span class="s1">if </span><span class="s0">(len &gt;= buf_len)</span>
                    <span class="s1">return </span><span class="s4">42 </span><span class="s3">/* WasiErrno.ENOBUFS */</span><span class="s0">;</span>
                <span class="s0">HEAPU8.set(linkData.subarray(</span><span class="s4">0</span><span class="s0">, len), buf);</span>
                <span class="s0">HEAPU8[buf + len] = </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s0">view.setUint32(bufused, len, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, async </span><span class="s1">function </span><span class="s0">path_readlink(fd, path, path_len, buf, buf_len, bufused) {</span>
                <span class="s0">path = Number(path);</span>
                <span class="s0">path_len = Number(path_len);</span>
                <span class="s0">buf = Number(buf);</span>
                <span class="s0">buf_len = Number(buf_len);</span>
                <span class="s0">bufused = Number(bufused);</span>
                <span class="s1">if </span><span class="s0">(path === </span><span class="s4">0 </span><span class="s0">|| buf === </span><span class="s4">0 </span><span class="s0">|| bufused === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8, view } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_READLINK, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">let </span><span class="s0">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
                <span class="s0">pathString = resolve(fileDescriptor.realPath, pathString);</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">link = </span><span class="s1">await </span><span class="s0">fs.promises.readlink(pathString);</span>
                <span class="s1">const </span><span class="s0">linkData = encoder.encode(link);</span>
                <span class="s1">const </span><span class="s0">len = Math.min(linkData.length, buf_len);</span>
                <span class="s1">if </span><span class="s0">(len &gt;= buf_len)</span>
                    <span class="s1">return </span><span class="s4">42 </span><span class="s3">/* WasiErrno.ENOBUFS */</span><span class="s0">;</span>
                <span class="s0">HEAPU8.set(linkData.subarray(</span><span class="s4">0</span><span class="s0">, len), buf);</span>
                <span class="s0">HEAPU8[buf + len] = </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s0">view.setUint32(bufused, len, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, [</span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">], [</span><span class="s2">'i32'</span><span class="s0">]);</span>
            <span class="s0">defineImport(</span><span class="s2">'path_remove_directory'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">path_remove_directory(fd, path, path_len) {</span>
                <span class="s0">path = Number(path);</span>
                <span class="s0">path_len = Number(path_len);</span>
                <span class="s1">if </span><span class="s0">(path === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8 } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_REMOVE_DIRECTORY, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">let </span><span class="s0">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
                <span class="s0">pathString = resolve(fileDescriptor.realPath, pathString);</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">fs.rmdirSync(pathString);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, async </span><span class="s1">function </span><span class="s0">path_remove_directory(fd, path, path_len) {</span>
                <span class="s0">path = Number(path);</span>
                <span class="s0">path_len = Number(path_len);</span>
                <span class="s1">if </span><span class="s0">(path === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8 } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_REMOVE_DIRECTORY, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">let </span><span class="s0">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
                <span class="s0">pathString = resolve(fileDescriptor.realPath, pathString);</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">await </span><span class="s0">fs.promises.rmdir(pathString);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, [</span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">], [</span><span class="s2">'i32'</span><span class="s0">]);</span>
            <span class="s0">defineImport(</span><span class="s2">'path_rename'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">path_rename(old_fd, old_path, old_path_len, new_fd, new_path, new_path_len) {</span>
                <span class="s0">old_path = Number(old_path);</span>
                <span class="s0">old_path_len = Number(old_path_len);</span>
                <span class="s0">new_path = Number(new_path);</span>
                <span class="s0">new_path_len = Number(new_path_len);</span>
                <span class="s1">if </span><span class="s0">(old_path === </span><span class="s4">0 </span><span class="s0">|| new_path === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">let </span><span class="s0">oldWrap;</span>
                <span class="s1">let </span><span class="s0">newWrap;</span>
                <span class="s1">if </span><span class="s0">(old_fd === new_fd) {</span>
                    <span class="s0">oldWrap = newWrap = wasi.fds.get(old_fd, WasiRights.PATH_RENAME_SOURCE | WasiRights.PATH_RENAME_TARGET, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">oldWrap = wasi.fds.get(old_fd, WasiRights.PATH_RENAME_SOURCE, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                    <span class="s0">newWrap = wasi.fds.get(new_fd, WasiRights.PATH_RENAME_TARGET, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8 } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">resolvedOldPath = resolve(oldWrap.realPath, decoder.decode(unsharedSlice(HEAPU8, old_path, old_path + old_path_len)));</span>
                <span class="s1">const </span><span class="s0">resolvedNewPath = resolve(newWrap.realPath, decoder.decode(unsharedSlice(HEAPU8, new_path, new_path + new_path_len)));</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">fs.renameSync(resolvedOldPath, resolvedNewPath);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, async </span><span class="s1">function </span><span class="s0">path_rename(old_fd, old_path, old_path_len, new_fd, new_path, new_path_len) {</span>
                <span class="s0">old_path = Number(old_path);</span>
                <span class="s0">old_path_len = Number(old_path_len);</span>
                <span class="s0">new_path = Number(new_path);</span>
                <span class="s0">new_path_len = Number(new_path_len);</span>
                <span class="s1">if </span><span class="s0">(old_path === </span><span class="s4">0 </span><span class="s0">|| new_path === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">let </span><span class="s0">oldWrap;</span>
                <span class="s1">let </span><span class="s0">newWrap;</span>
                <span class="s1">if </span><span class="s0">(old_fd === new_fd) {</span>
                    <span class="s0">oldWrap = newWrap = wasi.fds.get(old_fd, WasiRights.PATH_RENAME_SOURCE | WasiRights.PATH_RENAME_TARGET, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">oldWrap = wasi.fds.get(old_fd, WasiRights.PATH_RENAME_SOURCE, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                    <span class="s0">newWrap = wasi.fds.get(new_fd, WasiRights.PATH_RENAME_TARGET, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8 } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">resolvedOldPath = resolve(oldWrap.realPath, decoder.decode(unsharedSlice(HEAPU8, old_path, old_path + old_path_len)));</span>
                <span class="s1">const </span><span class="s0">resolvedNewPath = resolve(newWrap.realPath, decoder.decode(unsharedSlice(HEAPU8, new_path, new_path + new_path_len)));</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">await </span><span class="s0">fs.promises.rename(resolvedOldPath, resolvedNewPath);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, [</span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">], [</span><span class="s2">'i32'</span><span class="s0">]);</span>
            <span class="s0">defineImport(</span><span class="s2">'path_symlink'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">path_symlink(old_path, old_path_len, fd, new_path, new_path_len) {</span>
                <span class="s0">old_path = Number(old_path);</span>
                <span class="s0">old_path_len = Number(old_path_len);</span>
                <span class="s0">new_path = Number(new_path);</span>
                <span class="s0">new_path_len = Number(new_path_len);</span>
                <span class="s1">if </span><span class="s0">(old_path === </span><span class="s4">0 </span><span class="s0">|| new_path === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8 } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_SYMLINK, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">const </span><span class="s0">oldPath = decoder.decode(unsharedSlice(HEAPU8, old_path, old_path + old_path_len));</span>
                <span class="s1">if </span><span class="s0">(oldPath.length &gt; </span><span class="s4">0 </span><span class="s0">&amp;&amp; oldPath[</span><span class="s4">0</span><span class="s0">] === </span><span class="s2">'/'</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">63 </span><span class="s3">/* WasiErrno.EPERM */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">let </span><span class="s0">newPath = decoder.decode(unsharedSlice(HEAPU8, new_path, new_path + new_path_len));</span>
                <span class="s0">newPath = resolve(fileDescriptor.realPath, newPath);</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">fs.symlinkSync(oldPath, newPath);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, async </span><span class="s1">function </span><span class="s0">path_symlink(old_path, old_path_len, fd, new_path, new_path_len) {</span>
                <span class="s0">old_path = Number(old_path);</span>
                <span class="s0">old_path_len = Number(old_path_len);</span>
                <span class="s0">new_path = Number(new_path);</span>
                <span class="s0">new_path_len = Number(new_path_len);</span>
                <span class="s1">if </span><span class="s0">(old_path === </span><span class="s4">0 </span><span class="s0">|| new_path === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8 } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_SYMLINK, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">const </span><span class="s0">oldPath = decoder.decode(unsharedSlice(HEAPU8, old_path, old_path + old_path_len));</span>
                <span class="s1">let </span><span class="s0">newPath = decoder.decode(unsharedSlice(HEAPU8, new_path, new_path + new_path_len));</span>
                <span class="s0">newPath = resolve(fileDescriptor.realPath, newPath);</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">await </span><span class="s0">fs.promises.symlink(oldPath, newPath);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, [</span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">], [</span><span class="s2">'i32'</span><span class="s0">]);</span>
            <span class="s0">defineImport(</span><span class="s2">'path_unlink_file'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">path_unlink_file(fd, path, path_len) {</span>
                <span class="s0">path = Number(path);</span>
                <span class="s0">path_len = Number(path_len);</span>
                <span class="s1">if </span><span class="s0">(path === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8 } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_UNLINK_FILE, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">let </span><span class="s0">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
                <span class="s0">pathString = resolve(fileDescriptor.realPath, pathString);</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">fs.unlinkSync(pathString);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, async </span><span class="s1">function </span><span class="s0">path_unlink_file(fd, path, path_len) {</span>
                <span class="s0">path = Number(path);</span>
                <span class="s0">path_len = Number(path_len);</span>
                <span class="s1">if </span><span class="s0">(path === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ HEAPU8 } = getMemory(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">wasi = _wasi.get(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_UNLINK_FILE, BigInt(</span><span class="s4">0</span><span class="s0">));</span>
                <span class="s1">let </span><span class="s0">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
                <span class="s0">pathString = resolve(fileDescriptor.realPath, pathString);</span>
                <span class="s1">const </span><span class="s0">fs = getFs(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">await </span><span class="s0">fs.promises.unlink(pathString);</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s0">;</span>
            <span class="s0">}, [</span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">, </span><span class="s2">'i32'</span><span class="s0">], [</span><span class="s2">'i32'</span><span class="s0">]);</span>
            <span class="s1">this</span><span class="s0">._setMemory = </span><span class="s1">function </span><span class="s0">setMemory(m) {</span>
                <span class="s1">if </span><span class="s0">(!(m </span><span class="s1">instanceof </span><span class="s0">_WebAssembly.Memory)) {</span>
                    <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'&quot;instance.exports.memory&quot; property must be a WebAssembly.Memory'</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s0">_memory.set(_this, extendMemory(m));</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">static </span><span class="s0">createSync(args, env, preopens, stdio, fs, print, printErr) {</span>
            <span class="s1">const </span><span class="s0">fds = </span><span class="s1">new </span><span class="s0">SyncTable({</span>
                <span class="s0">size: </span><span class="s4">3</span><span class="s0">,</span>
                <span class="s1">in</span><span class="s0">: stdio[</span><span class="s4">0</span><span class="s0">],</span>
                <span class="s0">out: stdio[</span><span class="s4">1</span><span class="s0">],</span>
                <span class="s0">err: stdio[</span><span class="s4">2</span><span class="s0">],</span>
                <span class="s0">fs,</span>
                <span class="s0">print,</span>
                <span class="s0">printErr</span>
            <span class="s0">});</span>
            <span class="s1">const </span><span class="s0">_this = </span><span class="s1">new </span><span class="s0">WASI$1(args, env, fds, </span><span class="s1">false</span><span class="s0">, fs);</span>
            <span class="s1">if </span><span class="s0">(preopens.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; preopens.length; ++i) {</span>
                    <span class="s1">const </span><span class="s0">realPath = fs.realpathSync(preopens[i].realPath, </span><span class="s2">'utf8'</span><span class="s0">);</span>
                    <span class="s1">const </span><span class="s0">fd = fs.openSync(realPath, </span><span class="s2">'r'</span><span class="s0">, </span><span class="s4">0o666</span><span class="s0">);</span>
                    <span class="s0">fds.insertPreopen(fd, preopens[i].mappedPath, realPath);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">_this;</span>
        <span class="s0">}</span>
        <span class="s1">static </span><span class="s0">async createAsync(args, env, preopens, stdio, fs, print, printErr, asyncify) {</span>
            <span class="s1">const </span><span class="s0">fds = </span><span class="s1">new </span><span class="s0">AsyncTable({</span>
                <span class="s0">size: </span><span class="s4">3</span><span class="s0">,</span>
                <span class="s1">in</span><span class="s0">: stdio[</span><span class="s4">0</span><span class="s0">],</span>
                <span class="s0">out: stdio[</span><span class="s4">1</span><span class="s0">],</span>
                <span class="s0">err: stdio[</span><span class="s4">2</span><span class="s0">],</span>
                <span class="s0">print,</span>
                <span class="s0">printErr</span>
            <span class="s0">});</span>
            <span class="s1">const </span><span class="s0">_this = </span><span class="s1">new </span><span class="s0">WASI$1(args, env, fds, </span><span class="s1">true</span><span class="s0">, fs, asyncify);</span>
            <span class="s1">if </span><span class="s0">(preopens.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; preopens.length; ++i) {</span>
                    <span class="s1">const </span><span class="s0">entry = preopens[i];</span>
                    <span class="s1">const </span><span class="s0">realPath = </span><span class="s1">await </span><span class="s0">fs.promises.realpath(entry.realPath);</span>
                    <span class="s1">const </span><span class="s0">fd = </span><span class="s1">await </span><span class="s0">fs.promises.open(realPath, </span><span class="s2">'r'</span><span class="s0">, </span><span class="s4">0o666</span><span class="s0">);</span>
                    <span class="s1">await </span><span class="s0">fds.insertPreopen(fd, entry.mappedPath, realPath);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">_this;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s3">// eslint-disable-next-line spaced-comment</span>
    <span class="s1">const </span><span class="s0">kEmptyObject = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">Object.freeze(</span><span class="s3">/*#__PURE__*/ </span><span class="s0">Object.create(</span><span class="s1">null</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">kExitCode = Symbol(</span><span class="s2">'kExitCode'</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">kSetMemory = Symbol(</span><span class="s2">'kSetMemory'</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">kStarted = Symbol(</span><span class="s2">'kStarted'</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">kInstance = Symbol(</span><span class="s2">'kInstance'</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">kBindingName = Symbol(</span><span class="s2">'kBindingName'</span><span class="s0">);</span>
    <span class="s1">function </span><span class="s0">validateOptions(options) {</span>
        <span class="s1">var </span><span class="s0">_a;</span>
        <span class="s0">validateObject(options, </span><span class="s2">'options'</span><span class="s0">);</span>
        <span class="s1">let </span><span class="s0">_WASI;</span>
        <span class="s1">if </span><span class="s0">(options.version !== undefined) {</span>
            <span class="s0">validateString(options.version, </span><span class="s2">'options.version'</span><span class="s0">);</span>
            <span class="s1">switch </span><span class="s0">(options.version) {</span>
                <span class="s1">case </span><span class="s2">'unstable'</span><span class="s0">:</span>
                    <span class="s0">_WASI = WASI$1;</span>
                    <span class="s1">this</span><span class="s0">[kBindingName] = </span><span class="s2">'wasi_unstable'</span><span class="s0">;</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s1">case </span><span class="s2">'preview1'</span><span class="s0">:</span>
                    <span class="s0">_WASI = WASI$1;</span>
                    <span class="s1">this</span><span class="s0">[kBindingName] = </span><span class="s2">'wasi_snapshot_preview1'</span><span class="s0">;</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s1">default</span><span class="s0">:</span>
                    <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">`unsupported WASI version &quot;</span><span class="s0">${options.version}</span><span class="s2">&quot;`</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s0">_WASI = WASI$1;</span>
            <span class="s1">this</span><span class="s0">[kBindingName] = </span><span class="s2">'wasi_snapshot_preview1'</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(options.args !== undefined) {</span>
            <span class="s0">validateArray(options.args, </span><span class="s2">'options.args'</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">args = ((_a = options.args) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _a !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _a : []).map(String);</span>
        <span class="s1">const </span><span class="s0">env = [];</span>
        <span class="s1">if </span><span class="s0">(options.env !== undefined) {</span>
            <span class="s0">validateObject(options.env, </span><span class="s2">'options.env'</span><span class="s0">);</span>
            <span class="s0">Object.entries(options.env).forEach(({ </span><span class="s4">0</span><span class="s0">: key, </span><span class="s4">1</span><span class="s0">: value }) =&gt; {</span>
                <span class="s1">if </span><span class="s0">(value !== undefined) {</span>
                    <span class="s0">env.push(</span><span class="s2">`</span><span class="s0">${key}</span><span class="s2">=</span><span class="s0">${value}</span><span class="s2">`</span><span class="s0">);</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">preopens = [];</span>
        <span class="s1">if </span><span class="s0">(options.preopens !== undefined) {</span>
            <span class="s0">validateObject(options.preopens, </span><span class="s2">'options.preopens'</span><span class="s0">);</span>
            <span class="s0">Object.entries(options.preopens).forEach(({ </span><span class="s4">0</span><span class="s0">: key, </span><span class="s4">1</span><span class="s0">: value }) =&gt; preopens.push({ mappedPath: String(key), realPath: String(value) }));</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(preopens.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(options.fs === undefined) {</span>
                <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'filesystem is disabled, can not preopen directory'</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">try </span><span class="s0">{</span>
                <span class="s0">validateObject(options.fs, </span><span class="s2">'options.fs'</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">catch </span><span class="s0">(_) {</span>
                <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'Node.js fs like implementation is not provided'</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s3">// if (options.filesystem !== undefined) {</span>
        <span class="s3">//   validateObject(options.filesystem, 'options.filesystem')</span>
        <span class="s3">//   validateString(options.filesystem.type, 'options.filesystem.type')</span>
        <span class="s3">//   if (options.filesystem.type !== 'memfs' &amp;&amp; options.filesystem.type !== 'file-system-access-api') {</span>
        <span class="s3">//     throw new Error(`Filesystem type ${(options.filesystem as any).type as string} is not supported, only &quot;memfs&quot; and &quot;file-system-access-api&quot; is supported currently`)</span>
        <span class="s3">//   }</span>
        <span class="s3">//   try {</span>
        <span class="s3">//     validateObject(options.filesystem.fs, 'options.filesystem.fs')</span>
        <span class="s3">//   } catch (_) {</span>
        <span class="s3">//     throw new Error('Node.js fs like implementation is not provided')</span>
        <span class="s3">//   }</span>
        <span class="s3">// }</span>
        <span class="s1">if </span><span class="s0">(options.print !== undefined)</span>
            <span class="s0">validateFunction(options.print, </span><span class="s2">'options.print'</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(options.printErr !== undefined)</span>
            <span class="s0">validateFunction(options.printErr, </span><span class="s2">'options.printErr'</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(options.returnOnExit !== undefined) {</span>
            <span class="s0">validateBoolean(options.returnOnExit, </span><span class="s2">'options.returnOnExit'</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s3">// const { stdin = 0, stdout = 1, stderr = 2 } = options</span>
        <span class="s3">// validateInt32(stdin, 'options.stdin', 0)</span>
        <span class="s3">// validateInt32(stdout, 'options.stdout', 0)</span>
        <span class="s3">// validateInt32(stderr, 'options.stderr', 0)</span>
        <span class="s3">// const stdio = [stdin, stdout, stderr] as const</span>
        <span class="s1">const </span><span class="s0">stdio = [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">];</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">args,</span>
            <span class="s0">env,</span>
            <span class="s0">preopens,</span>
            <span class="s0">stdio,</span>
            <span class="s0">_WASI</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">initWASI(setMemory, wrap) {</span>
        <span class="s1">this</span><span class="s0">[kSetMemory] = setMemory;</span>
        <span class="s1">this</span><span class="s0">.wasiImport = wrap;</span>
        <span class="s1">this</span><span class="s0">[kStarted] = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">this</span><span class="s0">[kExitCode] = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">this</span><span class="s0">[kInstance] = undefined;</span>
    <span class="s0">}</span>
    <span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
    <span class="s1">class </span><span class="s0">WASI {</span>
        <span class="s0">constructor(options = kEmptyObject) {</span>
            <span class="s1">const </span><span class="s0">{ args, env, preopens, stdio, _WASI } = validateOptions.call(</span><span class="s1">this</span><span class="s0">, options);</span>
            <span class="s1">const </span><span class="s0">wrap = _WASI.createSync(args, env, preopens, stdio, options.fs, options.print, options.printErr);</span>
            <span class="s1">const </span><span class="s0">setMemory = wrap._setMemory;</span>
            <span class="s1">delete </span><span class="s0">wrap._setMemory;</span>
            <span class="s0">initWASI.call(</span><span class="s1">this</span><span class="s0">, setMemory, wrap);</span>
            <span class="s1">if </span><span class="s0">(options.returnOnExit) {</span>
                <span class="s0">wrap.proc_exit = wasiReturnOnProcExit.bind(</span><span class="s1">this</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">finalizeBindings(instance, _a) {</span>
            <span class="s1">var </span><span class="s0">_b;</span>
            <span class="s1">var </span><span class="s0">{ memory = (_b = instance === </span><span class="s1">null </span><span class="s0">|| instance === </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: instance.exports) === </span><span class="s1">null </span><span class="s0">|| _b === </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: _b.memory } = _a === </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? {} : _a;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">[kStarted]) {</span>
                <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'WASI instance has already started'</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s0">validateObject(instance, </span><span class="s2">'instance'</span><span class="s0">);</span>
            <span class="s0">validateObject(instance.exports, </span><span class="s2">'instance.exports'</span><span class="s0">);</span>
            <span class="s1">this</span><span class="s0">[kSetMemory](memory);</span>
            <span class="s1">this</span><span class="s0">[kInstance] = instance;</span>
            <span class="s1">this</span><span class="s0">[kStarted] = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s3">// Must not export _initialize, must export _start</span>
        <span class="s0">start(instance) {</span>
            <span class="s1">this</span><span class="s0">.finalizeBindings(instance);</span>
            <span class="s1">const </span><span class="s0">{ _start, _initialize } = </span><span class="s1">this</span><span class="s0">[kInstance].exports;</span>
            <span class="s0">validateFunction(_start, </span><span class="s2">'instance.exports._start'</span><span class="s0">);</span>
            <span class="s0">validateUndefined(_initialize, </span><span class="s2">'instance.exports._initialize'</span><span class="s0">);</span>
            <span class="s1">let </span><span class="s0">ret;</span>
            <span class="s1">try </span><span class="s0">{</span>
                <span class="s0">ret = _start();</span>
            <span class="s0">}</span>
            <span class="s1">catch </span><span class="s0">(err) {</span>
                <span class="s1">if </span><span class="s0">(err !== kExitCode) {</span>
                    <span class="s1">throw </span><span class="s0">err;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(ret </span><span class="s1">instanceof </span><span class="s0">Promise) {</span>
                <span class="s1">return </span><span class="s0">ret.then(() =&gt; </span><span class="s1">this</span><span class="s0">[kExitCode], (err) =&gt; {</span>
                    <span class="s1">if </span><span class="s0">(err !== kExitCode) {</span>
                        <span class="s1">throw </span><span class="s0">err;</span>
                    <span class="s0">}</span>
                    <span class="s1">return this</span><span class="s0">[kExitCode];</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s1">return this</span><span class="s0">[kExitCode];</span>
        <span class="s0">}</span>
        <span class="s3">// Must not export _start, may optionally export _initialize</span>
        <span class="s0">initialize(instance) {</span>
            <span class="s1">this</span><span class="s0">.finalizeBindings(instance);</span>
            <span class="s1">const </span><span class="s0">{ _start, _initialize } = </span><span class="s1">this</span><span class="s0">[kInstance].exports;</span>
            <span class="s0">validateUndefined(_start, </span><span class="s2">'instance.exports._start'</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(_initialize !== undefined) {</span>
                <span class="s0">validateFunction(_initialize, </span><span class="s2">'instance.exports._initialize'</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s0">_initialize();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">getImportObject() {</span>
            <span class="s1">return </span><span class="s0">{ [</span><span class="s1">this</span><span class="s0">[kBindingName]]: </span><span class="s1">this</span><span class="s0">.wasiImport };</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">wasiReturnOnProcExit(rval) {</span>
        <span class="s1">this</span><span class="s0">[kExitCode] = rval;</span>
        <span class="s3">// eslint-disable-next-line @typescript-eslint/no-throw-literal</span>
        <span class="s1">throw </span><span class="s0">kExitCode;</span>
    <span class="s0">}</span>
    <span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
    <span class="s0">async </span><span class="s1">function </span><span class="s0">createAsyncWASI(options = kEmptyObject) {</span>
        <span class="s1">const </span><span class="s0">_this = Object.create(WASI.prototype);</span>
        <span class="s1">const </span><span class="s0">{ args, env, preopens, stdio, _WASI } = validateOptions.call(_this, options);</span>
        <span class="s1">if </span><span class="s0">(options.asyncify !== undefined) {</span>
            <span class="s0">validateObject(options.asyncify, </span><span class="s2">'options.asyncify'</span><span class="s0">);</span>
            <span class="s0">validateFunction(options.asyncify.wrapImportFunction, </span><span class="s2">'options.asyncify.wrapImportFunction'</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">wrap = </span><span class="s1">await </span><span class="s0">_WASI.createAsync(args, env, preopens, stdio, options.fs, options.print, options.printErr, options.asyncify);</span>
        <span class="s1">const </span><span class="s0">setMemory = wrap._setMemory;</span>
        <span class="s1">delete </span><span class="s0">wrap._setMemory;</span>
        <span class="s0">initWASI.call(_this, setMemory, wrap);</span>
        <span class="s1">if </span><span class="s0">(options.returnOnExit) {</span>
            <span class="s0">wrap.proc_exit = wasiReturnOnProcExit.bind(_this);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">_this;</span>
    <span class="s0">}</span>

    <span class="s0">exports.Asyncify = Asyncify;</span>
    <span class="s0">exports.Memory = Memory;</span>
    <span class="s0">exports.WASI = WASI;</span>
    <span class="s0">exports.WebAssemblyMemory = WebAssemblyMemory;</span>
    <span class="s0">exports.asyncifyLoad = asyncifyLoad;</span>
    <span class="s0">exports.asyncifyLoadSync = asyncifyLoadSync;</span>
    <span class="s0">exports.createAsyncWASI = createAsyncWASI;</span>
    <span class="s0">exports.extendMemory = extendMemory;</span>
    <span class="s0">exports.load = load;</span>
    <span class="s0">exports.loadSync = loadSync;</span>
    <span class="s0">exports.wrapAsyncExport = wrapAsyncExport;</span>
    <span class="s0">exports.wrapAsyncImport = wrapAsyncImport;</span>
    <span class="s0">exports.wrapExports = wrapExports;</span>

    <span class="s0">Object.defineProperty(exports, </span><span class="s2">'__esModule'</span><span class="s0">, { value: </span><span class="s1">true </span><span class="s0">});</span>

<span class="s0">}));</span>
</pre>
</body>
</html>