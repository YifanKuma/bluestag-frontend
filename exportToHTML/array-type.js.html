<html>
<head>
<title>array-type.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
array-type.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s2">const </span><span class="s1">utils_1 = require(</span><span class="s0">&quot;@typescript-eslint/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">util_1 = require(</span><span class="s0">&quot;../util&quot;</span><span class="s1">);</span>
<span class="s3">/**</span>
 <span class="s3">* Check whatever node can be considered as simple</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">node the node to be evaluated.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">isSimpleType(node) {</span>
    <span class="s2">switch </span><span class="s1">(node.type) {</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.Identifier:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSAnyKeyword:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSBooleanKeyword:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSNeverKeyword:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSNumberKeyword:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSBigIntKeyword:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSObjectKeyword:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSStringKeyword:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSSymbolKeyword:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSUnknownKeyword:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSVoidKeyword:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSNullKeyword:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSArrayType:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSUndefinedKeyword:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSThisType:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSQualifiedName:</span>
            <span class="s2">return true</span><span class="s1">;</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSTypeReference:</span>
            <span class="s2">if </span><span class="s1">(node.typeName.type === utils_1.AST_NODE_TYPES.Identifier &amp;&amp;</span>
                <span class="s1">node.typeName.name === </span><span class="s0">'Array'</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(!node.typeArguments) {</span>
                    <span class="s2">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(node.typeArguments.params.length === </span><span class="s5">1</span><span class="s1">) {</span>
                    <span class="s2">return </span><span class="s1">isSimpleType(node.typeArguments.params[</span><span class="s5">0</span><span class="s1">]);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(node.typeArguments) {</span>
                    <span class="s2">return false</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">isSimpleType(node.typeName);</span>
            <span class="s1">}</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Check if node needs parentheses</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">node the node to be evaluated.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">typeNeedsParentheses(node) {</span>
    <span class="s2">switch </span><span class="s1">(node.type) {</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSTypeReference:</span>
            <span class="s2">return </span><span class="s1">typeNeedsParentheses(node.typeName);</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSUnionType:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSFunctionType:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSIntersectionType:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSTypeOperator:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSInferType:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSConstructorType:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSConditionalType:</span>
            <span class="s2">return true</span><span class="s1">;</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.Identifier:</span>
            <span class="s2">return </span><span class="s1">node.name === </span><span class="s0">'ReadonlyArray'</span><span class="s1">;</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.default = (</span><span class="s5">0</span><span class="s1">, util_1.createRule)({</span>
    <span class="s1">name: </span><span class="s0">'array-type'</span><span class="s1">,</span>
    <span class="s1">meta: {</span>
        <span class="s1">type: </span><span class="s0">'suggestion'</span><span class="s1">,</span>
        <span class="s1">docs: {</span>
            <span class="s1">description: </span><span class="s0">'Require consistently using either `T[]` or `Array&lt;T&gt;` for arrays'</span><span class="s1">,</span>
            <span class="s1">recommended: </span><span class="s0">'stylistic'</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">fixable: </span><span class="s0">'code'</span><span class="s1">,</span>
        <span class="s1">messages: {</span>
            <span class="s1">errorStringArray: </span><span class="s0">&quot;Array type using '{{className}}&lt;{{type}}&gt;' is forbidden. Use '{{readonlyPrefix}}{{type}}[]' instead.&quot;</span><span class="s1">,</span>
            <span class="s1">errorStringArrayReadonly: </span><span class="s0">&quot;Array type using '{{className}}&lt;{{type}}&gt;' is forbidden. Use '{{readonlyPrefix}}{{type}}' instead.&quot;</span><span class="s1">,</span>
            <span class="s1">errorStringArraySimple: </span><span class="s0">&quot;Array type using '{{className}}&lt;{{type}}&gt;' is forbidden for simple types. Use '{{readonlyPrefix}}{{type}}[]' instead.&quot;</span><span class="s1">,</span>
            <span class="s1">errorStringArraySimpleReadonly: </span><span class="s0">&quot;Array type using '{{className}}&lt;{{type}}&gt;' is forbidden for simple types. Use '{{readonlyPrefix}}{{type}}' instead.&quot;</span><span class="s1">,</span>
            <span class="s1">errorStringGeneric: </span><span class="s0">&quot;Array type using '{{readonlyPrefix}}{{type}}[]' is forbidden. Use '{{className}}&lt;{{type}}&gt;' instead.&quot;</span><span class="s1">,</span>
            <span class="s1">errorStringGenericSimple: </span><span class="s0">&quot;Array type using '{{readonlyPrefix}}{{type}}[]' is forbidden for non-simple types. Use '{{className}}&lt;{{type}}&gt;' instead.&quot;</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">schema: [</span>
            <span class="s1">{</span>
                <span class="s1">type: </span><span class="s0">'object'</span><span class="s1">,</span>
                <span class="s1">$defs: {</span>
                    <span class="s1">arrayOption: {</span>
                        <span class="s1">type: </span><span class="s0">'string'</span><span class="s1">,</span>
                        <span class="s2">enum</span><span class="s1">: [</span><span class="s0">'array'</span><span class="s1">, </span><span class="s0">'generic'</span><span class="s1">, </span><span class="s0">'array-simple'</span><span class="s1">],</span>
                    <span class="s1">},</span>
                <span class="s1">},</span>
                <span class="s1">additionalProperties: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">properties: {</span>
                    <span class="s2">default</span><span class="s1">: {</span>
                        <span class="s1">$ref: </span><span class="s0">'#/items/0/$defs/arrayOption'</span><span class="s1">,</span>
                        <span class="s1">description: </span><span class="s0">'The array type expected for mutable cases.'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">readonly: {</span>
                        <span class="s1">$ref: </span><span class="s0">'#/items/0/$defs/arrayOption'</span><span class="s1">,</span>
                        <span class="s1">description: </span><span class="s0">'The array type expected for readonly cases. If omitted, the value for `default` will be used.'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                <span class="s1">},</span>
            <span class="s1">},</span>
        <span class="s1">],</span>
    <span class="s1">},</span>
    <span class="s1">defaultOptions: [</span>
        <span class="s1">{</span>
            <span class="s2">default</span><span class="s1">: </span><span class="s0">'array'</span><span class="s1">,</span>
        <span class="s1">},</span>
    <span class="s1">],</span>
    <span class="s1">create(context, [options]) {</span>
        <span class="s2">const </span><span class="s1">defaultOption = options.default;</span>
        <span class="s2">const </span><span class="s1">readonlyOption = options.readonly ?? defaultOption;</span>
        <span class="s3">/**</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">node the node to be evaluated.</span>
         <span class="s3">*/</span>
        <span class="s2">function </span><span class="s1">getMessageType(node) {</span>
            <span class="s2">if </span><span class="s1">(isSimpleType(node)) {</span>
                <span class="s2">return </span><span class="s1">context.sourceCode.getText(node);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s0">'T'</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">TSArrayType(node) {</span>
                <span class="s2">const </span><span class="s1">isReadonly = node.parent.type === utils_1.AST_NODE_TYPES.TSTypeOperator &amp;&amp;</span>
                    <span class="s1">node.parent.operator === </span><span class="s0">'readonly'</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">currentOption = isReadonly ? readonlyOption : defaultOption;</span>
                <span class="s2">if </span><span class="s1">(currentOption === </span><span class="s0">'array' </span><span class="s1">||</span>
                    <span class="s1">(currentOption === </span><span class="s0">'array-simple' </span><span class="s1">&amp;&amp; isSimpleType(node.elementType))) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">messageId = currentOption === </span><span class="s0">'generic'</span>
                    <span class="s1">? </span><span class="s0">'errorStringGeneric'</span>
                    <span class="s1">: </span><span class="s0">'errorStringGenericSimple'</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">errorNode = isReadonly ? node.parent : node;</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node: errorNode,</span>
                    <span class="s1">messageId,</span>
                    <span class="s1">data: {</span>
                        <span class="s1">type: getMessageType(node.elementType),</span>
                        <span class="s1">className: isReadonly ? </span><span class="s0">'ReadonlyArray' </span><span class="s1">: </span><span class="s0">'Array'</span><span class="s1">,</span>
                        <span class="s1">readonlyPrefix: isReadonly ? </span><span class="s0">'readonly ' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">fix(fixer) {</span>
                        <span class="s2">const </span><span class="s1">typeNode = node.elementType;</span>
                        <span class="s2">const </span><span class="s1">arrayType = isReadonly ? </span><span class="s0">'ReadonlyArray' </span><span class="s1">: </span><span class="s0">'Array'</span><span class="s1">;</span>
                        <span class="s2">return </span><span class="s1">[</span>
                            <span class="s1">fixer.replaceTextRange([errorNode.range[</span><span class="s5">0</span><span class="s1">], typeNode.range[</span><span class="s5">0</span><span class="s1">]], </span><span class="s0">`</span><span class="s1">${arrayType}</span><span class="s0">&lt;`</span><span class="s1">),</span>
                            <span class="s1">fixer.replaceTextRange([typeNode.range[</span><span class="s5">1</span><span class="s1">], errorNode.range[</span><span class="s5">1</span><span class="s1">]], </span><span class="s0">'&gt;'</span><span class="s1">),</span>
                        <span class="s1">];</span>
                    <span class="s1">},</span>
                <span class="s1">});</span>
            <span class="s1">},</span>
            <span class="s1">TSTypeReference(node) {</span>
                <span class="s2">if </span><span class="s1">(node.typeName.type !== utils_1.AST_NODE_TYPES.Identifier ||</span>
                    <span class="s1">!(node.typeName.name === </span><span class="s0">'Array' </span><span class="s1">||</span>
                        <span class="s1">node.typeName.name === </span><span class="s0">'ReadonlyArray' </span><span class="s1">||</span>
                        <span class="s1">node.typeName.name === </span><span class="s0">'Readonly'</span><span class="s1">) ||</span>
                    <span class="s1">(node.typeName.name === </span><span class="s0">'Readonly' </span><span class="s1">&amp;&amp;</span>
                        <span class="s1">node.typeArguments?.params[</span><span class="s5">0</span><span class="s1">].type !== utils_1.AST_NODE_TYPES.TSArrayType)) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">isReadonlyWithGenericArrayType = node.typeName.name === </span><span class="s0">'Readonly' </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">node.typeArguments?.params[</span><span class="s5">0</span><span class="s1">].type === utils_1.AST_NODE_TYPES.TSArrayType;</span>
                <span class="s2">const </span><span class="s1">isReadonlyArrayType = node.typeName.name === </span><span class="s0">'ReadonlyArray' </span><span class="s1">||</span>
                    <span class="s1">isReadonlyWithGenericArrayType;</span>
                <span class="s2">const </span><span class="s1">currentOption = isReadonlyArrayType</span>
                    <span class="s1">? readonlyOption</span>
                    <span class="s1">: defaultOption;</span>
                <span class="s2">if </span><span class="s1">(currentOption === </span><span class="s0">'generic'</span><span class="s1">) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">readonlyPrefix = isReadonlyArrayType ? </span><span class="s0">'readonly ' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">typeParams = node.typeArguments?.params;</span>
                <span class="s2">const </span><span class="s1">messageId = currentOption === </span><span class="s0">'array'</span>
                    <span class="s1">? isReadonlyWithGenericArrayType</span>
                        <span class="s1">? </span><span class="s0">'errorStringArrayReadonly'</span>
                        <span class="s1">: </span><span class="s0">'errorStringArray'</span>
                    <span class="s1">: isReadonlyArrayType &amp;&amp; node.typeName.name !== </span><span class="s0">'ReadonlyArray'</span>
                        <span class="s1">? </span><span class="s0">'errorStringArraySimpleReadonly'</span>
                        <span class="s1">: </span><span class="s0">'errorStringArraySimple'</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(!typeParams) {</span>
                    <span class="s3">// Create an 'any' array</span>
                    <span class="s1">context.report({</span>
                        <span class="s1">node,</span>
                        <span class="s1">messageId,</span>
                        <span class="s1">data: {</span>
                            <span class="s1">type: </span><span class="s0">'any'</span><span class="s1">,</span>
                            <span class="s1">className: isReadonlyArrayType ? </span><span class="s0">'ReadonlyArray' </span><span class="s1">: </span><span class="s0">'Array'</span><span class="s1">,</span>
                            <span class="s1">readonlyPrefix,</span>
                        <span class="s1">},</span>
                        <span class="s1">fix(fixer) {</span>
                            <span class="s2">return </span><span class="s1">fixer.replaceText(node, </span><span class="s0">`</span><span class="s1">${readonlyPrefix}</span><span class="s0">any[]`</span><span class="s1">);</span>
                        <span class="s1">},</span>
                    <span class="s1">});</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(typeParams.length !== </span><span class="s5">1 </span><span class="s1">||</span>
                    <span class="s1">(currentOption === </span><span class="s0">'array-simple' </span><span class="s1">&amp;&amp; !isSimpleType(typeParams[</span><span class="s5">0</span><span class="s1">]))) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">type = typeParams[</span><span class="s5">0</span><span class="s1">];</span>
                <span class="s2">const </span><span class="s1">typeParens = typeNeedsParentheses(type);</span>
                <span class="s2">const </span><span class="s1">parentParens = readonlyPrefix &amp;&amp;</span>
                    <span class="s1">node.parent.type === utils_1.AST_NODE_TYPES.TSArrayType &amp;&amp;</span>
                    <span class="s1">!(</span><span class="s5">0</span><span class="s1">, util_1.isParenthesized)(node.parent.elementType, context.sourceCode);</span>
                <span class="s2">const </span><span class="s1">start = </span><span class="s0">`</span><span class="s1">${parentParens ? </span><span class="s0">'(' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">}${readonlyPrefix}${typeParens ? </span><span class="s0">'(' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">}</span><span class="s0">`</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">end = </span><span class="s0">`</span><span class="s1">${typeParens ? </span><span class="s0">')' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">}${isReadonlyWithGenericArrayType ? </span><span class="s0">'' </span><span class="s1">: </span><span class="s0">`[]`</span><span class="s1">}${parentParens ? </span><span class="s0">')' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">}</span><span class="s0">`</span><span class="s1">;</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node,</span>
                    <span class="s1">messageId,</span>
                    <span class="s1">data: {</span>
                        <span class="s1">type: getMessageType(type),</span>
                        <span class="s1">className: isReadonlyArrayType ? node.typeName.name : </span><span class="s0">'Array'</span><span class="s1">,</span>
                        <span class="s1">readonlyPrefix,</span>
                    <span class="s1">},</span>
                    <span class="s1">fix(fixer) {</span>
                        <span class="s2">return </span><span class="s1">[</span>
                            <span class="s1">fixer.replaceTextRange([node.range[</span><span class="s5">0</span><span class="s1">], type.range[</span><span class="s5">0</span><span class="s1">]], start),</span>
                            <span class="s1">fixer.replaceTextRange([type.range[</span><span class="s5">1</span><span class="s1">], node.range[</span><span class="s5">1</span><span class="s1">]], end),</span>
                        <span class="s1">];</span>
                    <span class="s1">},</span>
                <span class="s1">});</span>
            <span class="s1">},</span>
        <span class="s1">};</span>
    <span class="s1">},</span>
<span class="s1">});</span>
</pre>
</body>
</html>