<html>
<head>
<title>boolean-prop-naming.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
boolean-prop-naming.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">Enforces consistent naming for boolean props</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Ev Haus</span>
 <span class="s0">*/</span>

<span class="s3">'use strict'</span><span class="s2">;</span>

<span class="s4">const </span><span class="s2">flatMap = require(</span><span class="s3">'array.prototype.flatmap'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">values = require(</span><span class="s3">'object.values'</span><span class="s2">);</span>

<span class="s4">const </span><span class="s2">Components = require(</span><span class="s3">'../util/Components'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">propsUtil = require(</span><span class="s3">'../util/props'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">astUtil = require(</span><span class="s3">'../util/ast'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">docsUrl = require(</span><span class="s3">'../util/docsUrl'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">propWrapperUtil = require(</span><span class="s3">'../util/propWrapper'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">report = require(</span><span class="s3">'../util/report'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">eslintUtil = require(</span><span class="s3">'../util/eslint'</span><span class="s2">);</span>

<span class="s4">const </span><span class="s2">getSourceCode = eslintUtil.getSourceCode;</span>
<span class="s4">const </span><span class="s2">getText = eslintUtil.getText;</span>

<span class="s0">/**</span>
 <span class="s0">* Checks if prop is nested</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} prop Property object, single prop type declaration</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean}</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">nestedPropTypes(prop) {</span>
  <span class="s4">return </span><span class="s2">(</span>
    <span class="s2">prop.type === </span><span class="s3">'Property'</span>
    <span class="s2">&amp;&amp; astUtil.isCallExpression(prop.value)</span>
  <span class="s2">);</span>
<span class="s2">}</span>

<span class="s0">// ------------------------------------------------------------------------------</span>
<span class="s0">// Rule Definition</span>
<span class="s0">// ------------------------------------------------------------------------------</span>

<span class="s4">const </span><span class="s2">messages = {</span>
  <span class="s2">patternMismatch: </span><span class="s3">'Prop name `{{propName}}` doesnâ€™t match rule `{{pattern}}`'</span><span class="s2">,</span>
<span class="s2">};</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{import('eslint').Rule.RuleModule} */</span>
<span class="s2">module.exports = {</span>
  <span class="s2">meta: {</span>
    <span class="s2">docs: {</span>
      <span class="s2">category: </span><span class="s3">'Stylistic Issues'</span><span class="s2">,</span>
      <span class="s2">description: </span><span class="s3">'Enforces consistent naming for boolean props'</span><span class="s2">,</span>
      <span class="s2">recommended: </span><span class="s4">false</span><span class="s2">,</span>
      <span class="s2">url: docsUrl(</span><span class="s3">'boolean-prop-naming'</span><span class="s2">),</span>
    <span class="s2">},</span>

    <span class="s2">messages,</span>

    <span class="s2">schema: [{</span>
      <span class="s2">additionalProperties: </span><span class="s4">false</span><span class="s2">,</span>
      <span class="s2">properties: {</span>
        <span class="s2">propTypeNames: {</span>
          <span class="s2">items: {</span>
            <span class="s2">type: </span><span class="s3">'string'</span><span class="s2">,</span>
          <span class="s2">},</span>
          <span class="s2">minItems: </span><span class="s5">1</span><span class="s2">,</span>
          <span class="s2">type: </span><span class="s3">'array'</span><span class="s2">,</span>
          <span class="s2">uniqueItems: </span><span class="s4">true</span><span class="s2">,</span>
        <span class="s2">},</span>
        <span class="s2">rule: {</span>
          <span class="s4">default</span><span class="s2">: </span><span class="s3">'^(is|has)[A-Z]([A-Za-z0-9]?)+'</span><span class="s2">,</span>
          <span class="s2">minLength: </span><span class="s5">1</span><span class="s2">,</span>
          <span class="s2">type: </span><span class="s3">'string'</span><span class="s2">,</span>
        <span class="s2">},</span>
        <span class="s2">message: {</span>
          <span class="s2">minLength: </span><span class="s5">1</span><span class="s2">,</span>
          <span class="s2">type: </span><span class="s3">'string'</span><span class="s2">,</span>
        <span class="s2">},</span>
        <span class="s2">validateNested: {</span>
          <span class="s4">default</span><span class="s2">: </span><span class="s4">false</span><span class="s2">,</span>
          <span class="s2">type: </span><span class="s3">'boolean'</span><span class="s2">,</span>
        <span class="s2">},</span>
      <span class="s2">},</span>
      <span class="s2">type: </span><span class="s3">'object'</span><span class="s2">,</span>
    <span class="s2">}],</span>
  <span class="s2">},</span>

  <span class="s2">create: Components.detect((context, components, utils) =&gt; {</span>
    <span class="s4">const </span><span class="s2">config = context.options[</span><span class="s5">0</span><span class="s2">] || {};</span>
    <span class="s4">const </span><span class="s2">rule = config.rule ? </span><span class="s4">new </span><span class="s2">RegExp(config.rule) : </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s4">const </span><span class="s2">propTypeNames = config.propTypeNames || [</span><span class="s3">'bool'</span><span class="s2">];</span>

    <span class="s0">// Remembers all Flowtype object definitions</span>
    <span class="s4">const </span><span class="s2">objectTypeAnnotations = </span><span class="s4">new </span><span class="s2">Map();</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the prop key to ensure we handle the following cases:</span>
     <span class="s0">* propTypes: {</span>
     <span class="s0">*   full: React.PropTypes.bool,</span>
     <span class="s0">*   short: PropTypes.bool,</span>
     <span class="s0">*   direct: bool,</span>
     <span class="s0">*   required: PropTypes.bool.isRequired</span>
     <span class="s0">* }</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} node The node we're getting the name of</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string | null}</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">getPropKey(node) {</span>
      <span class="s0">// Check for `ExperimentalSpreadProperty` (eslint 3/4) and `SpreadElement` (eslint 5)</span>
      <span class="s0">// so we can skip validation of those fields.</span>
      <span class="s0">// Otherwise it will look for `node.value.property` which doesn't exist and breaks eslint.</span>
      <span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">'ExperimentalSpreadProperty' </span><span class="s2">|| node.type === </span><span class="s3">'SpreadElement'</span><span class="s2">) {</span>
        <span class="s4">return null</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(node.value &amp;&amp; node.value.property) {</span>
        <span class="s4">const </span><span class="s2">name = node.value.property.name;</span>
        <span class="s4">if </span><span class="s2">(name === </span><span class="s3">'isRequired'</span><span class="s2">) {</span>
          <span class="s4">if </span><span class="s2">(node.value.object &amp;&amp; node.value.object.property) {</span>
            <span class="s4">return </span><span class="s2">node.value.object.property.name;</span>
          <span class="s2">}</span>
          <span class="s4">return null</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s4">return </span><span class="s2">name;</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(node.value &amp;&amp; node.value.type === </span><span class="s3">'Identifier'</span><span class="s2">) {</span>
        <span class="s4">return </span><span class="s2">node.value.name;</span>
      <span class="s2">}</span>
      <span class="s4">return null</span><span class="s2">;</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the name of the given node (prop)</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} node The node we're getting the name of</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string}</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">getPropName(node) {</span>
      <span class="s0">// Due to this bug https://github.com/babel/babel-eslint/issues/307</span>
      <span class="s0">// we can't get the name of the Flow object key name. So we have</span>
      <span class="s0">// to hack around it for now.</span>
      <span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">'ObjectTypeProperty'</span><span class="s2">) {</span>
        <span class="s4">return </span><span class="s2">getSourceCode(context).getFirstToken(node).value;</span>
      <span class="s2">}</span>

      <span class="s4">return </span><span class="s2">node.key.name;</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Checks if prop is declared in flow way</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} prop Property object, single prop type declaration</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean}</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">flowCheck(prop) {</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">prop.type === </span><span class="s3">'ObjectTypeProperty'</span>
        <span class="s2">&amp;&amp; prop.value.type === </span><span class="s3">'BooleanTypeAnnotation'</span>
        <span class="s2">&amp;&amp; rule.test(getPropName(prop)) === </span><span class="s4">false</span>
      <span class="s2">);</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Checks if prop is declared in regular way</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} prop Property object, single prop type declaration</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean}</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">regularCheck(prop) {</span>
      <span class="s4">const </span><span class="s2">propKey = getPropKey(prop);</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">propKey</span>
        <span class="s2">&amp;&amp; propTypeNames.indexOf(propKey) &gt;= </span><span class="s5">0</span>
        <span class="s2">&amp;&amp; rule.test(getPropName(prop)) === </span><span class="s4">false</span>
      <span class="s2">);</span>
    <span class="s2">}</span>

    <span class="s4">function </span><span class="s2">tsCheck(prop) {</span>
      <span class="s4">if </span><span class="s2">(prop.type !== </span><span class="s3">'TSPropertySignature'</span><span class="s2">) </span><span class="s4">return false</span><span class="s2">;</span>
      <span class="s4">const </span><span class="s2">typeAnnotation = (prop.typeAnnotation || {}).typeAnnotation;</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">typeAnnotation</span>
        <span class="s2">&amp;&amp; typeAnnotation.type === </span><span class="s3">'TSBooleanKeyword'</span>
        <span class="s2">&amp;&amp; rule.test(getPropName(prop)) === </span><span class="s4">false</span>
      <span class="s2">);</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Runs recursive check on all proptypes</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array} proptypes A list of Property object (for each proptype defined)</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} addInvalidProp callback to run for each error</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">runCheck(proptypes, addInvalidProp) {</span>
      <span class="s4">if </span><span class="s2">(proptypes) {</span>
        <span class="s2">proptypes.forEach((prop) =&gt; {</span>
          <span class="s4">if </span><span class="s2">(config.validateNested &amp;&amp; nestedPropTypes(prop)) {</span>
            <span class="s2">runCheck(prop.value.arguments[</span><span class="s5">0</span><span class="s2">].properties, addInvalidProp);</span>
            <span class="s4">return</span><span class="s2">;</span>
          <span class="s2">}</span>
          <span class="s4">if </span><span class="s2">(flowCheck(prop) || regularCheck(prop) || tsCheck(prop)) {</span>
            <span class="s2">addInvalidProp(prop);</span>
          <span class="s2">}</span>
        <span class="s2">});</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Checks and mark props with invalid naming</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} node The component node we're testing</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array} proptypes A list of Property object (for each proptype defined)</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">validatePropNaming(node, proptypes) {</span>
      <span class="s4">const </span><span class="s2">component = components.get(node) || node;</span>
      <span class="s4">const </span><span class="s2">invalidProps = component.invalidProps || [];</span>

      <span class="s2">runCheck(proptypes, (prop) =&gt; {</span>
        <span class="s2">invalidProps.push(prop);</span>
      <span class="s2">});</span>

      <span class="s2">components.set(node, {</span>
        <span class="s2">invalidProps,</span>
      <span class="s2">});</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Reports invalid prop naming</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} component The component to process</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">reportInvalidNaming(component) {</span>
      <span class="s2">component.invalidProps.forEach((propNode) =&gt; {</span>
        <span class="s4">const </span><span class="s2">propName = getPropName(propNode);</span>
        <span class="s2">report(context, config.message || messages.patternMismatch, !config.message &amp;&amp; </span><span class="s3">'patternMismatch'</span><span class="s2">, {</span>
          <span class="s2">node: propNode,</span>
          <span class="s2">data: {</span>
            <span class="s2">component: propName,</span>
            <span class="s2">propName,</span>
            <span class="s2">pattern: config.rule,</span>
          <span class="s2">},</span>
        <span class="s2">});</span>
      <span class="s2">});</span>
    <span class="s2">}</span>

    <span class="s4">function </span><span class="s2">checkPropWrapperArguments(node, args) {</span>
      <span class="s4">if </span><span class="s2">(!node || !Array.isArray(args)) {</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s2">args.filter((arg) =&gt; arg.type === </span><span class="s3">'ObjectExpression'</span><span class="s2">).forEach((object) =&gt; validatePropNaming(node, object.properties));</span>
    <span class="s2">}</span>

    <span class="s4">function </span><span class="s2">getComponentTypeAnnotation(component) {</span>
      <span class="s0">// If this is a functional component that uses a global type, check it</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">(component.node.type === </span><span class="s3">'FunctionDeclaration' </span><span class="s2">|| component.node.type === </span><span class="s3">'ArrowFunctionExpression'</span><span class="s2">)</span>
        <span class="s2">&amp;&amp; component.node.params</span>
        <span class="s2">&amp;&amp; component.node.params.length &gt; </span><span class="s5">0</span>
        <span class="s2">&amp;&amp; component.node.params[</span><span class="s5">0</span><span class="s2">].typeAnnotation</span>
      <span class="s2">) {</span>
        <span class="s4">return </span><span class="s2">component.node.params[</span><span class="s5">0</span><span class="s2">].typeAnnotation.typeAnnotation;</span>
      <span class="s2">}</span>

      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">!component.node.parent</span>
        <span class="s2">|| component.node.parent.type !== </span><span class="s3">'VariableDeclarator'</span>
        <span class="s2">|| !component.node.parent.id</span>
        <span class="s2">|| component.node.parent.id.type !== </span><span class="s3">'Identifier'</span>
        <span class="s2">|| !component.node.parent.id.typeAnnotation</span>
        <span class="s2">|| !component.node.parent.id.typeAnnotation.typeAnnotation</span>
      <span class="s2">) {</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s4">const </span><span class="s2">annotationTypeArguments = propsUtil.getTypeArguments(</span>
        <span class="s2">component.node.parent.id.typeAnnotation.typeAnnotation</span>
      <span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">annotationTypeArguments &amp;&amp; (</span>
          <span class="s2">annotationTypeArguments.type === </span><span class="s3">'TSTypeParameterInstantiation'</span>
          <span class="s2">|| annotationTypeArguments.type === </span><span class="s3">'TypeParameterInstantiation'</span>
        <span class="s2">)</span>
      <span class="s2">) {</span>
        <span class="s4">return </span><span class="s2">annotationTypeArguments.params.find(</span>
          <span class="s2">(param) =&gt; param.type === </span><span class="s3">'TSTypeReference' </span><span class="s2">|| param.type === </span><span class="s3">'GenericTypeAnnotation'</span>
        <span class="s2">);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s4">function </span><span class="s2">findAllTypeAnnotations(identifier, node) {</span>
      <span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">'TSTypeLiteral' </span><span class="s2">|| node.type === </span><span class="s3">'ObjectTypeAnnotation' </span><span class="s2">|| node.type === </span><span class="s3">'TSInterfaceBody'</span><span class="s2">) {</span>
        <span class="s4">const </span><span class="s2">currentNode = [].concat(</span>
          <span class="s2">objectTypeAnnotations.get(identifier.name) || [],</span>
          <span class="s2">node</span>
        <span class="s2">);</span>
        <span class="s2">objectTypeAnnotations.set(identifier.name, currentNode);</span>
      <span class="s2">} </span><span class="s4">else if </span><span class="s2">(</span>
        <span class="s2">node.type === </span><span class="s3">'TSParenthesizedType'</span>
        <span class="s2">&amp;&amp; (</span>
          <span class="s2">node.typeAnnotation.type === </span><span class="s3">'TSIntersectionType'</span>
          <span class="s2">|| node.typeAnnotation.type === </span><span class="s3">'TSUnionType'</span>
        <span class="s2">)</span>
      <span class="s2">) {</span>
        <span class="s2">node.typeAnnotation.types.forEach((type) =&gt; {</span>
          <span class="s2">findAllTypeAnnotations(identifier, type);</span>
        <span class="s2">});</span>
      <span class="s2">} </span><span class="s4">else if </span><span class="s2">(</span>
        <span class="s2">node.type === </span><span class="s3">'TSIntersectionType'</span>
        <span class="s2">|| node.type === </span><span class="s3">'TSUnionType'</span>
        <span class="s2">|| node.type === </span><span class="s3">'IntersectionTypeAnnotation'</span>
        <span class="s2">|| node.type === </span><span class="s3">'UnionTypeAnnotation'</span>
      <span class="s2">) {</span>
        <span class="s2">node.types.forEach((type) =&gt; {</span>
          <span class="s2">findAllTypeAnnotations(identifier, type);</span>
        <span class="s2">});</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s0">// --------------------------------------------------------------------------</span>
    <span class="s0">// Public</span>
    <span class="s0">// --------------------------------------------------------------------------</span>

    <span class="s4">return </span><span class="s2">{</span>
      <span class="s3">'ClassProperty, PropertyDefinition'</span><span class="s2">(node) {</span>
        <span class="s4">if </span><span class="s2">(!rule || !propsUtil.isPropTypesDeclaration(node)) {</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">node.value</span>
          <span class="s2">&amp;&amp; astUtil.isCallExpression(node.value)</span>
          <span class="s2">&amp;&amp; propWrapperUtil.isPropWrapperFunction(</span>
            <span class="s2">context,</span>
            <span class="s2">getText(context, node.value.callee)</span>
          <span class="s2">)</span>
        <span class="s2">) {</span>
          <span class="s2">checkPropWrapperArguments(node, node.value.arguments);</span>
        <span class="s2">}</span>
        <span class="s4">if </span><span class="s2">(node.value &amp;&amp; node.value.properties) {</span>
          <span class="s2">validatePropNaming(node, node.value.properties);</span>
        <span class="s2">}</span>
        <span class="s4">if </span><span class="s2">(node.typeAnnotation &amp;&amp; node.typeAnnotation.typeAnnotation) {</span>
          <span class="s2">validatePropNaming(node, node.typeAnnotation.typeAnnotation.properties);</span>
        <span class="s2">}</span>
      <span class="s2">},</span>

      <span class="s2">MemberExpression(node) {</span>
        <span class="s4">if </span><span class="s2">(!rule || !propsUtil.isPropTypesDeclaration(node)) {</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s4">const </span><span class="s2">component = utils.getRelatedComponent(node);</span>
        <span class="s4">if </span><span class="s2">(!component || !node.parent.right) {</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s4">const </span><span class="s2">right = node.parent.right;</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">astUtil.isCallExpression(right)</span>
          <span class="s2">&amp;&amp; propWrapperUtil.isPropWrapperFunction(</span>
            <span class="s2">context,</span>
            <span class="s2">getText(context, right.callee)</span>
          <span class="s2">)</span>
        <span class="s2">) {</span>
          <span class="s2">checkPropWrapperArguments(component.node, right.arguments);</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s2">validatePropNaming(component.node, node.parent.right.properties);</span>
      <span class="s2">},</span>

      <span class="s2">ObjectExpression(node) {</span>
        <span class="s4">if </span><span class="s2">(!rule) {</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s2">}</span>

        <span class="s0">// Search for the proptypes declaration</span>
        <span class="s2">node.properties.forEach((property) =&gt; {</span>
          <span class="s4">if </span><span class="s2">(!propsUtil.isPropTypesDeclaration(property)) {</span>
            <span class="s4">return</span><span class="s2">;</span>
          <span class="s2">}</span>
          <span class="s2">validatePropNaming(node, property.value.properties);</span>
        <span class="s2">});</span>
      <span class="s2">},</span>

      <span class="s2">TypeAlias(node) {</span>
        <span class="s2">findAllTypeAnnotations(node.id, node.right);</span>
      <span class="s2">},</span>

      <span class="s2">TSTypeAliasDeclaration(node) {</span>
        <span class="s2">findAllTypeAnnotations(node.id, node.typeAnnotation);</span>
      <span class="s2">},</span>

      <span class="s2">TSInterfaceDeclaration(node) {</span>
        <span class="s2">findAllTypeAnnotations(node.id, node.body);</span>
      <span class="s2">},</span>

      <span class="s0">// eslint-disable-next-line object-shorthand</span>
      <span class="s3">'Program:exit'</span><span class="s2">() {</span>
        <span class="s4">if </span><span class="s2">(!rule) {</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s2">}</span>

        <span class="s2">values(components.list()).forEach((component) =&gt; {</span>
          <span class="s4">const </span><span class="s2">annotation = getComponentTypeAnnotation(component);</span>

          <span class="s4">if </span><span class="s2">(annotation) {</span>
            <span class="s4">let </span><span class="s2">propType;</span>
            <span class="s4">if </span><span class="s2">(annotation.type === </span><span class="s3">'GenericTypeAnnotation'</span><span class="s2">) {</span>
              <span class="s2">propType = objectTypeAnnotations.get(annotation.id.name);</span>
            <span class="s2">} </span><span class="s4">else if </span><span class="s2">(annotation.type === </span><span class="s3">'ObjectTypeAnnotation' </span><span class="s2">|| annotation.type === </span><span class="s3">'TSTypeLiteral'</span><span class="s2">) {</span>
              <span class="s2">propType = annotation;</span>
            <span class="s2">} </span><span class="s4">else if </span><span class="s2">(annotation.type === </span><span class="s3">'TSTypeReference'</span><span class="s2">) {</span>
              <span class="s2">propType = objectTypeAnnotations.get(annotation.typeName.name);</span>
            <span class="s2">} </span><span class="s4">else if </span><span class="s2">(annotation.type === </span><span class="s3">'TSIntersectionType'</span><span class="s2">) {</span>
              <span class="s2">propType = flatMap(annotation.types, (type) =&gt; (</span>
                <span class="s2">type.type === </span><span class="s3">'TSTypeReference'</span>
                  <span class="s2">? objectTypeAnnotations.get(type.typeName.name)</span>
                  <span class="s2">: type</span>
              <span class="s2">));</span>
            <span class="s2">}</span>

            <span class="s4">if </span><span class="s2">(propType) {</span>
              <span class="s2">[].concat(propType).filter(Boolean).forEach((prop) =&gt; {</span>
                <span class="s2">validatePropNaming(</span>
                  <span class="s2">component.node,</span>
                  <span class="s2">prop.properties || prop.members || prop.body</span>
                <span class="s2">);</span>
              <span class="s2">});</span>
            <span class="s2">}</span>
          <span class="s2">}</span>

          <span class="s4">if </span><span class="s2">(component.invalidProps &amp;&amp; component.invalidProps.length &gt; </span><span class="s5">0</span><span class="s2">) {</span>
            <span class="s2">reportInvalidNaming(component);</span>
          <span class="s2">}</span>
        <span class="s2">});</span>

        <span class="s0">// Reset cache</span>
        <span class="s2">objectTypeAnnotations.clear();</span>
      <span class="s2">},</span>
    <span class="s2">};</span>
  <span class="s2">}),</span>
<span class="s2">};</span>
</pre>
</body>
</html>