<html>
<head>
<title>resolve-opengraph.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
resolve-opengraph.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">resolveImages: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">resolveOpenGraph: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">resolveTwitter: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">resolveImages: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">resolveImages;</span>
    <span class="s1">},</span>
    <span class="s1">resolveOpenGraph: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">resolveOpenGraph;</span>
    <span class="s1">},</span>
    <span class="s1">resolveTwitter: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">resolveTwitter;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_utils = require(</span><span class="s0">&quot;../generate/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_resolveurl = require(</span><span class="s0">&quot;./resolve-url&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_resolvetitle = require(</span><span class="s0">&quot;./resolve-title&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_url = require(</span><span class="s0">&quot;../../url&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_log = require(</span><span class="s0">&quot;../../../build/output/log&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">OgTypeFields = {</span>
    <span class="s1">article: [</span>
        <span class="s0">'authors'</span><span class="s1">,</span>
        <span class="s0">'tags'</span>
    <span class="s1">],</span>
    <span class="s1">song: [</span>
        <span class="s0">'albums'</span><span class="s1">,</span>
        <span class="s0">'musicians'</span>
    <span class="s1">],</span>
    <span class="s1">playlist: [</span>
        <span class="s0">'albums'</span><span class="s1">,</span>
        <span class="s0">'musicians'</span>
    <span class="s1">],</span>
    <span class="s1">radio: [</span>
        <span class="s0">'creators'</span>
    <span class="s1">],</span>
    <span class="s1">video: [</span>
        <span class="s0">'actors'</span><span class="s1">,</span>
        <span class="s0">'directors'</span><span class="s1">,</span>
        <span class="s0">'writers'</span><span class="s1">,</span>
        <span class="s0">'tags'</span>
    <span class="s1">],</span>
    <span class="s1">basic: [</span>
        <span class="s0">'emails'</span><span class="s1">,</span>
        <span class="s0">'phoneNumbers'</span><span class="s1">,</span>
        <span class="s0">'faxNumbers'</span><span class="s1">,</span>
        <span class="s0">'alternateLocale'</span><span class="s1">,</span>
        <span class="s0">'audio'</span><span class="s1">,</span>
        <span class="s0">'videos'</span>
    <span class="s1">]</span>
<span class="s1">};</span>
<span class="s2">function </span><span class="s1">resolveAndValidateImage(item, metadataBase, isStaticMetadataRouteFile) {</span>
    <span class="s2">if </span><span class="s1">(!item) </span><span class="s2">return </span><span class="s1">undefined;</span>
    <span class="s2">const </span><span class="s1">isItemUrl = (</span><span class="s3">0</span><span class="s1">, _resolveurl.isStringOrURL)(item);</span>
    <span class="s2">const </span><span class="s1">inputUrl = isItemUrl ? item : item.url;</span>
    <span class="s2">if </span><span class="s1">(!inputUrl) </span><span class="s2">return </span><span class="s1">undefined;</span>
    <span class="s4">// process.env.VERCEL is set to &quot;1&quot; when System Environment Variables are</span>
    <span class="s4">// exposed. When exposed, validation is not necessary since we are falling back to</span>
    <span class="s4">// process.env.VERCEL_PROJECT_PRODUCTION_URL, process.env.VERCEL_BRANCH_URL, or</span>
    <span class="s4">// process.env.VERCEL_URL for the `metadataBase`. process.env.VERCEL is undefined</span>
    <span class="s4">// when System Environment Variables are not exposed. When not exposed, we cannot</span>
    <span class="s4">// detect in the build environment if the deployment is a Vercel deployment or not.</span>
    <span class="s4">//</span>
    <span class="s4">// x-ref: https://vercel.com/docs/projects/environment-variables/system-environment-variables#system-environment-variables</span>
    <span class="s2">const </span><span class="s1">isUsingVercelSystemEnvironmentVariables = Boolean(process.env.VERCEL);</span>
    <span class="s2">const </span><span class="s1">isRelativeUrl = </span><span class="s2">typeof </span><span class="s1">inputUrl === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; !(</span><span class="s3">0</span><span class="s1">, _url.isFullStringUrl)(inputUrl);</span>
    <span class="s4">// When no explicit metadataBase is specified by the user, we'll override it with the fallback metadata</span>
    <span class="s4">// under the following conditions:</span>
    <span class="s4">// - The provided URL is relative (ie ./og-image).</span>
    <span class="s4">// - The image is statically generated by Next.js (such as the special `opengraph-image` route)</span>
    <span class="s4">// In both cases, we want to ensure that across all environments, the ogImage is a fully qualified URL.</span>
    <span class="s4">// In the `opengraph-image` case, since the user isn't explicitly passing a relative path, this ensures</span>
    <span class="s4">// the ogImage will be properly discovered across different environments without the user needing to</span>
    <span class="s4">// have a bunch of `process.env` checks when defining their `metadataBase`.</span>
    <span class="s2">if </span><span class="s1">(isRelativeUrl &amp;&amp; (!metadataBase || isStaticMetadataRouteFile)) {</span>
        <span class="s2">const </span><span class="s1">fallbackMetadataBase = (</span><span class="s3">0</span><span class="s1">, _resolveurl.getSocialImageMetadataBaseFallback)(metadataBase);</span>
        <span class="s4">// When not using Vercel environment variables for URL injection, we aren't able to determine</span>
        <span class="s4">// a fallback value for `metadataBase`. For self-hosted setups, we want to warn</span>
        <span class="s4">// about this since the only fallback we'll be able to generate is `localhost`.</span>
        <span class="s4">// In development, we'll only warn for relative metadata that isn't part of the static</span>
        <span class="s4">// metadata conventions (eg `opengraph-image`), as otherwise it's currently very noisy</span>
        <span class="s4">// for common cases. Eventually we should remove this warning all together in favor of</span>
        <span class="s4">// devtools.</span>
        <span class="s2">const </span><span class="s1">shouldWarn = !isUsingVercelSystemEnvironmentVariables &amp;&amp; !metadataBase &amp;&amp; (process.env.NODE_ENV === </span><span class="s0">'production' </span><span class="s1">|| !isStaticMetadataRouteFile);</span>
        <span class="s2">if </span><span class="s1">(shouldWarn) {</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _log.warnOnce)(</span><span class="s0">`metadataBase property in metadata export is not set for resolving social open graph or twitter images, using &quot;</span><span class="s1">${fallbackMetadataBase.origin}</span><span class="s0">&quot;. See https://nextjs.org/docs/app/api-reference/functions/generate-metadata#metadatabase`</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">metadataBase = fallbackMetadataBase;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">isItemUrl ? {</span>
        <span class="s1">url: (</span><span class="s3">0</span><span class="s1">, _resolveurl.resolveUrl)(inputUrl, metadataBase)</span>
    <span class="s1">} : {</span>
        <span class="s1">...item,</span>
        <span class="s4">// Update image descriptor url</span>
        <span class="s1">url: (</span><span class="s3">0</span><span class="s1">, _resolveurl.resolveUrl)(inputUrl, metadataBase)</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resolveImages(images, metadataBase, isStaticMetadataRouteFile) {</span>
    <span class="s2">const </span><span class="s1">resolvedImages = (</span><span class="s3">0</span><span class="s1">, _utils.resolveAsArrayOrUndefined)(images);</span>
    <span class="s2">if </span><span class="s1">(!resolvedImages) </span><span class="s2">return </span><span class="s1">resolvedImages;</span>
    <span class="s2">const </span><span class="s1">nonNullableImages = [];</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">item of resolvedImages){</span>
        <span class="s2">const </span><span class="s1">resolvedItem = resolveAndValidateImage(item, metadataBase, isStaticMetadataRouteFile);</span>
        <span class="s2">if </span><span class="s1">(!resolvedItem) </span><span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">nonNullableImages.push(resolvedItem);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">nonNullableImages;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">ogTypeToFields = {</span>
    <span class="s1">article: OgTypeFields.article,</span>
    <span class="s1">book: OgTypeFields.article,</span>
    <span class="s0">'music.song'</span><span class="s1">: OgTypeFields.song,</span>
    <span class="s0">'music.album'</span><span class="s1">: OgTypeFields.song,</span>
    <span class="s0">'music.playlist'</span><span class="s1">: OgTypeFields.playlist,</span>
    <span class="s0">'music.radio_station'</span><span class="s1">: OgTypeFields.radio,</span>
    <span class="s0">'video.movie'</span><span class="s1">: OgTypeFields.video,</span>
    <span class="s0">'video.episode'</span><span class="s1">: OgTypeFields.video</span>
<span class="s1">};</span>
<span class="s2">function </span><span class="s1">getFieldsByOgType(ogType) {</span>
    <span class="s2">if </span><span class="s1">(!ogType || !(ogType </span><span class="s2">in </span><span class="s1">ogTypeToFields)) </span><span class="s2">return </span><span class="s1">OgTypeFields.basic;</span>
    <span class="s2">return </span><span class="s1">ogTypeToFields[ogType].concat(OgTypeFields.basic);</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">resolveOpenGraph = async (openGraph, metadataBase, pathname, metadataContext, titleTemplate)=&gt;{</span>
    <span class="s2">if </span><span class="s1">(!openGraph) </span><span class="s2">return null</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">resolveProps(target, og) {</span>
        <span class="s2">const </span><span class="s1">ogType = og &amp;&amp; </span><span class="s0">'type' </span><span class="s2">in </span><span class="s1">og ? og.type : undefined;</span>
        <span class="s2">const </span><span class="s1">keys = getFieldsByOgType(ogType);</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">k of keys){</span>
            <span class="s2">const </span><span class="s1">key = k;</span>
            <span class="s2">if </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">og &amp;&amp; key !== </span><span class="s0">'url'</span><span class="s1">) {</span>
                <span class="s2">const </span><span class="s1">value = og[key];</span>
                <span class="s1">target[key] = value ? (</span><span class="s3">0</span><span class="s1">, _utils.resolveArray)(value) : </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">target.images = resolveImages(og.images, metadataBase, metadataContext.isStaticMetadataRouteFile);</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">resolved = {</span>
        <span class="s1">...openGraph,</span>
        <span class="s1">title: (</span><span class="s3">0</span><span class="s1">, _resolvetitle.resolveTitle)(openGraph.title, titleTemplate)</span>
    <span class="s1">};</span>
    <span class="s1">resolveProps(resolved, openGraph);</span>
    <span class="s1">resolved.url = openGraph.url ? (</span><span class="s3">0</span><span class="s1">, _resolveurl.resolveAbsoluteUrlWithPathname)(openGraph.url, metadataBase, </span><span class="s2">await </span><span class="s1">pathname, metadataContext) : </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">resolved;</span>
<span class="s1">};</span>
<span class="s2">const </span><span class="s1">TwitterBasicInfoKeys = [</span>
    <span class="s0">'site'</span><span class="s1">,</span>
    <span class="s0">'siteId'</span><span class="s1">,</span>
    <span class="s0">'creator'</span><span class="s1">,</span>
    <span class="s0">'creatorId'</span><span class="s1">,</span>
    <span class="s0">'description'</span>
<span class="s1">];</span>
<span class="s2">const </span><span class="s1">resolveTwitter = (twitter, metadataBase, metadataContext, titleTemplate)=&gt;{</span>
    <span class="s2">var </span><span class="s1">_resolved_images;</span>
    <span class="s2">if </span><span class="s1">(!twitter) </span><span class="s2">return null</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">card = </span><span class="s0">'card' </span><span class="s2">in </span><span class="s1">twitter ? twitter.card : undefined;</span>
    <span class="s2">const </span><span class="s1">resolved = {</span>
        <span class="s1">...twitter,</span>
        <span class="s1">title: (</span><span class="s3">0</span><span class="s1">, _resolvetitle.resolveTitle)(twitter.title, titleTemplate)</span>
    <span class="s1">};</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">infoKey of TwitterBasicInfoKeys){</span>
        <span class="s1">resolved[infoKey] = twitter[infoKey] || </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">resolved.images = resolveImages(twitter.images, metadataBase, metadataContext.isStaticMetadataRouteFile);</span>
    <span class="s1">card = card || (((_resolved_images = resolved.images) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _resolved_images.length) ? </span><span class="s0">'summary_large_image' </span><span class="s1">: </span><span class="s0">'summary'</span><span class="s1">);</span>
    <span class="s1">resolved.card = card;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s0">'card' </span><span class="s2">in </span><span class="s1">resolved) {</span>
        <span class="s2">switch</span><span class="s1">(resolved.card){</span>
            <span class="s2">case </span><span class="s0">'player'</span><span class="s1">:</span>
                <span class="s1">{</span>
                    <span class="s1">resolved.players = (</span><span class="s3">0</span><span class="s1">, _utils.resolveAsArrayOrUndefined)(resolved.players) || [];</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s2">case </span><span class="s0">'app'</span><span class="s1">:</span>
                <span class="s1">{</span>
                    <span class="s1">resolved.app = resolved.app || {};</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s2">case </span><span class="s0">'summary'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'summary_large_image'</span><span class="s1">:</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s1">resolved;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">resolved;</span>
<span class="s1">};</span>

<span class="s4">//# sourceMappingURL=resolve-opengraph.js.map</span></pre>
</body>
</html>