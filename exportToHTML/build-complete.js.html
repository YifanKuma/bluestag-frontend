<html>
<head>
<title>build-complete.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
build-complete.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;handleBuildComplete&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">handleBuildComplete;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_path = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;path&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_promises = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;fs/promises&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_util = require(</span><span class="s0">&quot;util&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_url = require(</span><span class="s0">&quot;url&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_log = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard(require(</span><span class="s0">&quot;../output/log&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_glob = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;next/dist/compiled/glob&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_interopdefault = require(</span><span class="s0">&quot;../../lib/interop-default&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils = require(</span><span class="s0">&quot;../utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_normalizepagepath = require(</span><span class="s0">&quot;../../shared/lib/page-path/normalize-page-path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_apppaths = require(</span><span class="s0">&quot;../../shared/lib/router/utils/app-paths&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants = require(</span><span class="s0">&quot;../../shared/lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_renderingmode = require(</span><span class="s0">&quot;../rendering-mode&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils1 = require(</span><span class="s0">&quot;../../shared/lib/router/utils&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">cacheBabelInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">var </span><span class="s1">cacheNodeInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s2">function</span><span class="s1">(nodeInterop) {</span>
        <span class="s2">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop;</span>
    <span class="s1">})(nodeInterop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_interop_require_wildcard(obj, nodeInterop) {</span>
    <span class="s2">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) {</span>
        <span class="s2">return </span><span class="s1">obj;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s2">default</span><span class="s1">: obj</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop);</span>
    <span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) {</span>
        <span class="s2">return </span><span class="s1">cache.get(obj);</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">newObj = {</span>
        <span class="s1">__proto__: </span><span class="s2">null</span>
    <span class="s1">};</span>
    <span class="s2">var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor;</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj){</span>
        <span class="s2">if </span><span class="s1">(key !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) {</span>
            <span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) {</span>
                <span class="s1">Object.defineProperty(newObj, key, desc);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">newObj[key] = obj[key];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">newObj.default = obj;</span>
    <span class="s2">if </span><span class="s1">(cache) {</span>
        <span class="s1">cache.set(obj, newObj);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">newObj;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">glob = (</span><span class="s4">0</span><span class="s1">, _util.promisify)(_glob.default);</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">handleBuildComplete({ </span><span class="s3">// dir,</span>
<span class="s1">distDir, tracingRoot, adapterPath, pageKeys, appPageKeys, hasNodeMiddleware, hasInstrumentationHook, requiredServerFiles, routesManifest, prerenderManifest, middlewareManifest, functionsConfigManifest, hasStatic404 }) {</span>
    <span class="s2">const </span><span class="s1">adapterMod = (</span><span class="s4">0</span><span class="s1">, _interopdefault.interopDefault)(</span><span class="s2">await import</span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _url.pathToFileURL)(require.resolve(adapterPath)).href));</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">adapterMod.onBuildComplete === </span><span class="s0">'function'</span><span class="s1">) {</span>
        <span class="s1">_log.info(</span><span class="s0">`Running onBuildComplete from </span><span class="s1">${adapterMod.name}</span><span class="s0">`</span><span class="s1">);</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">outputs = [];</span>
            <span class="s2">const </span><span class="s1">staticFiles = </span><span class="s2">await </span><span class="s1">glob(</span><span class="s0">'**/*'</span><span class="s1">, {</span>
                <span class="s1">cwd: _path.default.join(distDir, </span><span class="s0">'static'</span><span class="s1">)</span>
            <span class="s1">});</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">file of staticFiles){</span>
                <span class="s2">const </span><span class="s1">pathname = _path.default.posix.join(</span><span class="s0">'/_next/static'</span><span class="s1">, file);</span>
                <span class="s2">const </span><span class="s1">filePath = _path.default.join(distDir, </span><span class="s0">'static'</span><span class="s1">, file);</span>
                <span class="s1">outputs.push({</span>
                    <span class="s1">type: _constants.AdapterOutputType.STATIC_FILE,</span>
                    <span class="s1">id: _path.default.join(</span><span class="s0">'static'</span><span class="s1">, file),</span>
                    <span class="s1">pathname,</span>
                    <span class="s1">filePath</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">sharedNodeAssets = {};</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">file of requiredServerFiles){</span>
                <span class="s3">// add to shared node assets</span>
                <span class="s2">const </span><span class="s1">filePath = _path.default.join(distDir, file);</span>
                <span class="s2">const </span><span class="s1">fileOutputPath = _path.default.relative(tracingRoot, filePath);</span>
                <span class="s1">sharedNodeAssets[fileOutputPath] = filePath;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(hasInstrumentationHook) {</span>
                <span class="s2">const </span><span class="s1">assets = </span><span class="s2">await </span><span class="s1">handleTraceFiles(_path.default.join(distDir, </span><span class="s0">'server'</span><span class="s1">, </span><span class="s0">'instrumentation.js.nft.json'</span><span class="s1">));</span>
                <span class="s2">const </span><span class="s1">fileOutputPath = _path.default.relative(tracingRoot, _path.default.join(distDir, </span><span class="s0">'server'</span><span class="s1">, </span><span class="s0">'instrumentation.js'</span><span class="s1">));</span>
                <span class="s1">sharedNodeAssets[fileOutputPath] = _path.default.join(distDir, </span><span class="s0">'server'</span><span class="s1">, </span><span class="s0">'instrumentation.js'</span><span class="s1">);</span>
                <span class="s1">Object.assign(sharedNodeAssets, assets);</span>
            <span class="s1">}</span>
            <span class="s1">async </span><span class="s2">function </span><span class="s1">handleTraceFiles(traceFilePath) {</span>
                <span class="s2">const </span><span class="s1">assets = Object.assign({}, sharedNodeAssets);</span>
                <span class="s2">const </span><span class="s1">traceData = JSON.parse(</span><span class="s2">await </span><span class="s1">_promises.default.readFile(traceFilePath, </span><span class="s0">'utf8'</span><span class="s1">));</span>
                <span class="s2">const </span><span class="s1">traceFileDir = _path.default.dirname(traceFilePath);</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">relativeFile of traceData.files){</span>
                    <span class="s2">const </span><span class="s1">tracedFilePath = _path.default.join(traceFileDir, relativeFile);</span>
                    <span class="s2">const </span><span class="s1">fileOutputPath = _path.default.relative(tracingRoot, tracedFilePath);</span>
                    <span class="s1">assets[fileOutputPath] = tracedFilePath;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">assets;</span>
            <span class="s1">}</span>
            <span class="s1">async </span><span class="s2">function </span><span class="s1">handleEdgeFunction(page, isMiddleware = </span><span class="s2">false</span><span class="s1">) {</span>
                <span class="s2">let </span><span class="s1">type = _constants.AdapterOutputType.PAGES;</span>
                <span class="s2">const </span><span class="s1">isAppPrefix = page.page.startsWith(</span><span class="s0">'app/'</span><span class="s1">);</span>
                <span class="s2">const </span><span class="s1">isAppPage = isAppPrefix &amp;&amp; page.page.endsWith(</span><span class="s0">'/page'</span><span class="s1">);</span>
                <span class="s2">const </span><span class="s1">isAppRoute = isAppPrefix &amp;&amp; page.page.endsWith(</span><span class="s0">'/route'</span><span class="s1">);</span>
                <span class="s2">if </span><span class="s1">(isMiddleware) {</span>
                    <span class="s1">type = _constants.AdapterOutputType.MIDDLEWARE;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isAppPage) {</span>
                    <span class="s1">type = _constants.AdapterOutputType.APP_PAGE;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isAppRoute) {</span>
                    <span class="s1">type = _constants.AdapterOutputType.APP_ROUTE;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(page.page.startsWith(</span><span class="s0">'/api'</span><span class="s1">)) {</span>
                    <span class="s1">type = _constants.AdapterOutputType.PAGES_API;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">output = {</span>
                    <span class="s1">id: page.name,</span>
                    <span class="s1">runtime: </span><span class="s0">'edge'</span><span class="s1">,</span>
                    <span class="s1">pathname: isAppPrefix ? (</span><span class="s4">0</span><span class="s1">, _apppaths.normalizeAppPath)(page.name) : page.name,</span>
                    <span class="s1">filePath: _path.default.join(distDir, </span><span class="s0">'server'</span><span class="s1">, page.files.find((item)=&gt;item.startsWith(</span><span class="s0">'server/app'</span><span class="s1">) || item.startsWith(</span><span class="s0">'server/pages'</span><span class="s1">)) || </span><span class="s0">''</span><span class="s1">),</span>
                    <span class="s1">assets: {},</span>
                    <span class="s1">type,</span>
                    <span class="s1">config: type === _constants.AdapterOutputType.MIDDLEWARE ? {</span>
                        <span class="s1">matchers: page.matchers</span>
                    <span class="s1">} : {}</span>
                <span class="s1">};</span>
                <span class="s2">function </span><span class="s1">handleFile(file) {</span>
                    <span class="s2">const </span><span class="s1">originalPath = _path.default.join(distDir, file);</span>
                    <span class="s2">const </span><span class="s1">fileOutputPath = _path.default.join(_path.default.relative(tracingRoot, distDir), file);</span>
                    <span class="s2">if </span><span class="s1">(!output.assets) {</span>
                        <span class="s1">output.assets = {};</span>
                    <span class="s1">}</span>
                    <span class="s1">output.assets[fileOutputPath] = originalPath;</span>
                <span class="s1">}</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">file of page.files){</span>
                    <span class="s1">handleFile(file);</span>
                <span class="s1">}</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">item of [</span>
                    <span class="s1">...page.wasm || [],</span>
                    <span class="s1">...page.assets || []</span>
                <span class="s1">]){</span>
                    <span class="s1">handleFile(item.filePath);</span>
                <span class="s1">}</span>
                <span class="s1">outputs.push(output);</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">edgeFunctionHandlers = [];</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">middleware of Object.values(middlewareManifest.middleware)){</span>
                <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _utils.isMiddlewareFilename)(middleware.name)) {</span>
                    <span class="s1">edgeFunctionHandlers.push(handleEdgeFunction(middleware, </span><span class="s2">true</span><span class="s1">));</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">page of Object.values(middlewareManifest.functions)){</span>
                <span class="s1">edgeFunctionHandlers.push(handleEdgeFunction(page));</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">pagesDistDir = _path.default.join(distDir, </span><span class="s0">'server'</span><span class="s1">, </span><span class="s0">'pages'</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">pageOutputMap = {};</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">page of pageKeys){</span>
                <span class="s2">if </span><span class="s1">(middlewareManifest.functions.hasOwnProperty(page)) {</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">route = (</span><span class="s4">0</span><span class="s1">, _normalizepagepath.normalizePagePath)(page);</span>
                <span class="s2">const </span><span class="s1">pageFile = _path.default.join(pagesDistDir, </span><span class="s0">`</span><span class="s1">${(</span><span class="s4">0</span><span class="s1">, _normalizepagepath.normalizePagePath)(page)}</span><span class="s0">.js`</span><span class="s1">);</span>
                <span class="s2">const </span><span class="s1">pageTraceFile = </span><span class="s0">`</span><span class="s1">${pageFile}</span><span class="s0">.nft.json`</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">assets = </span><span class="s2">await </span><span class="s1">handleTraceFiles(pageTraceFile).catch((err)=&gt;{</span>
                    <span class="s2">if </span><span class="s1">(err.code !== </span><span class="s0">'ENOENT' </span><span class="s1">|| page !== </span><span class="s0">'/404' </span><span class="s1">&amp;&amp; page !== </span><span class="s0">'/500'</span><span class="s1">) {</span>
                        <span class="s1">_log.warn(</span><span class="s0">`Failed to locate traced assets for </span><span class="s1">${pageFile}</span><span class="s0">`</span><span class="s1">, err);</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">{};</span>
                <span class="s1">});</span>
                <span class="s2">const </span><span class="s1">functionConfig = functionsConfigManifest.functions[route] || {};</span>
                <span class="s2">const </span><span class="s1">output = {</span>
                    <span class="s1">id: route,</span>
                    <span class="s1">type: page.startsWith(</span><span class="s0">'/api'</span><span class="s1">) ? _constants.AdapterOutputType.PAGES_API : _constants.AdapterOutputType.PAGES,</span>
                    <span class="s1">filePath: pageTraceFile.replace(</span><span class="s5">/\.nft\.json$/</span><span class="s1">, </span><span class="s0">''</span><span class="s1">),</span>
                    <span class="s1">pathname: route,</span>
                    <span class="s1">assets,</span>
                    <span class="s1">runtime: </span><span class="s0">'nodejs'</span><span class="s1">,</span>
                    <span class="s1">config: {</span>
                        <span class="s1">maxDuration: functionConfig.maxDuration,</span>
                        <span class="s1">preferredRegion: functionConfig.regions</span>
                    <span class="s1">}</span>
                <span class="s1">};</span>
                <span class="s1">pageOutputMap[page] = output;</span>
                <span class="s1">outputs.push(output);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(hasNodeMiddleware) {</span>
                <span class="s2">const </span><span class="s1">middlewareFile = _path.default.join(distDir, </span><span class="s0">'server'</span><span class="s1">, </span><span class="s0">'middleware.js'</span><span class="s1">);</span>
                <span class="s2">const </span><span class="s1">middlewareTrace = </span><span class="s0">`</span><span class="s1">${middlewareFile}</span><span class="s0">.nft.json`</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">assets = </span><span class="s2">await </span><span class="s1">handleTraceFiles(middlewareTrace);</span>
                <span class="s2">const </span><span class="s1">functionConfig = functionsConfigManifest.functions[</span><span class="s0">'/_middleware'</span><span class="s1">] || {};</span>
                <span class="s1">outputs.push({</span>
                    <span class="s1">pathname: </span><span class="s0">'/_middleware'</span><span class="s1">,</span>
                    <span class="s1">id: </span><span class="s0">'/_middleware'</span><span class="s1">,</span>
                    <span class="s1">assets,</span>
                    <span class="s1">type: _constants.AdapterOutputType.MIDDLEWARE,</span>
                    <span class="s1">runtime: </span><span class="s0">'nodejs'</span><span class="s1">,</span>
                    <span class="s1">filePath: middlewareFile,</span>
                    <span class="s1">config: {</span>
                        <span class="s1">matchers: functionConfig.matchers</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">appOutputMap = {};</span>
            <span class="s2">const </span><span class="s1">appDistDir = _path.default.join(distDir, </span><span class="s0">'server'</span><span class="s1">, </span><span class="s0">'app'</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(appPageKeys) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">page of appPageKeys){</span>
                    <span class="s2">if </span><span class="s1">(middlewareManifest.functions.hasOwnProperty(page)) {</span>
                        <span class="s2">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">const </span><span class="s1">normalizedPage = (</span><span class="s4">0</span><span class="s1">, _apppaths.normalizeAppPath)(page);</span>
                    <span class="s2">const </span><span class="s1">pageFile = _path.default.join(appDistDir, </span><span class="s0">`</span><span class="s1">${page}</span><span class="s0">.js`</span><span class="s1">);</span>
                    <span class="s2">const </span><span class="s1">pageTraceFile = </span><span class="s0">`</span><span class="s1">${pageFile}</span><span class="s0">.nft.json`</span><span class="s1">;</span>
                    <span class="s2">const </span><span class="s1">assets = </span><span class="s2">await </span><span class="s1">handleTraceFiles(pageTraceFile).catch((err)=&gt;{</span>
                        <span class="s1">_log.warn(</span><span class="s0">`Failed to copy traced files for </span><span class="s1">${pageFile}</span><span class="s0">`</span><span class="s1">, err);</span>
                        <span class="s2">return </span><span class="s1">{};</span>
                    <span class="s1">});</span>
                    <span class="s2">const </span><span class="s1">functionConfig = functionsConfigManifest.functions[normalizedPage] || {};</span>
                    <span class="s2">const </span><span class="s1">output = {</span>
                        <span class="s1">pathname: normalizedPage,</span>
                        <span class="s1">id: normalizedPage,</span>
                        <span class="s1">assets,</span>
                        <span class="s1">type: page.endsWith(</span><span class="s0">'/route'</span><span class="s1">) ? _constants.AdapterOutputType.APP_ROUTE : _constants.AdapterOutputType.APP_PAGE,</span>
                        <span class="s1">runtime: </span><span class="s0">'nodejs'</span><span class="s1">,</span>
                        <span class="s1">filePath: pageFile,</span>
                        <span class="s1">config: {</span>
                            <span class="s1">maxDuration: functionConfig.maxDuration,</span>
                            <span class="s1">preferredRegion: functionConfig.regions</span>
                        <span class="s1">}</span>
                    <span class="s1">};</span>
                    <span class="s1">appOutputMap[normalizedPage] = output;</span>
                    <span class="s1">outputs.push(output);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">getParentOutput = (srcRoute, childRoute, allowMissing)=&gt;{</span>
                <span class="s2">const </span><span class="s1">parentOutput = pageOutputMap[srcRoute] || appOutputMap[srcRoute];</span>
                <span class="s2">if </span><span class="s1">(!parentOutput &amp;&amp; !allowMissing) {</span>
                    <span class="s1">console.error({</span>
                        <span class="s1">appOutputs: Object.keys(appOutputMap),</span>
                        <span class="s1">pageOutputs: Object.keys(pageOutputMap)</span>
                    <span class="s1">});</span>
                    <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Invariant: failed to find source route </span><span class="s1">${srcRoute} </span><span class="s0">for prerender </span><span class="s1">${childRoute}</span><span class="s0">`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E777&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">parentOutput;</span>
            <span class="s1">};</span>
            <span class="s2">const </span><span class="s1">{ prefetchSegmentDirSuffix, prefetchSegmentSuffix, varyHeader, didPostponeHeader, contentTypeHeader } = routesManifest.rsc;</span>
            <span class="s2">const </span><span class="s1">handleAppMeta = async (route, initialOutput)=&gt;{</span>
                <span class="s2">const </span><span class="s1">meta = JSON.parse(</span><span class="s2">await </span><span class="s1">_promises.default.readFile(_path.default.join(appDistDir, </span><span class="s0">`</span><span class="s1">${route}</span><span class="s0">.meta`</span><span class="s1">), </span><span class="s0">'utf8'</span><span class="s1">).catch(()=&gt;</span><span class="s0">'{}'</span><span class="s1">));</span>
                <span class="s2">if </span><span class="s1">(meta.postponed &amp;&amp; initialOutput.config) {</span>
                    <span class="s1">initialOutput.config.postponed = meta.postponed;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(meta == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: meta.segmentPaths) {</span>
                    <span class="s2">const </span><span class="s1">segmentsDir = _path.default.join(appDistDir, </span><span class="s0">`</span><span class="s1">${route}${prefetchSegmentDirSuffix}</span><span class="s0">`</span><span class="s1">);</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">segmentPath of meta.segmentPaths){</span>
                        <span class="s2">var </span><span class="s1">_initialOutput_fallback, _initialOutput_fallback1, _initialOutput_fallback2;</span>
                        <span class="s2">const </span><span class="s1">outputSegmentPath = _path.default.join(appDistDir, route + prefetchSegmentDirSuffix, segmentPath) + prefetchSegmentSuffix;</span>
                        <span class="s2">const </span><span class="s1">fallbackPathname = _path.default.join(segmentsDir, segmentPath + prefetchSegmentSuffix);</span>
                        <span class="s1">outputs.push({</span>
                            <span class="s1">id: outputSegmentPath,</span>
                            <span class="s1">pathname: outputSegmentPath,</span>
                            <span class="s1">type: _constants.AdapterOutputType.PRERENDER,</span>
                            <span class="s1">parentOutputId: initialOutput.parentOutputId,</span>
                            <span class="s1">config: {</span>
                                <span class="s1">...initialOutput.config</span>
                            <span class="s1">},</span>
                            <span class="s1">fallback: {</span>
                                <span class="s1">filePath: fallbackPathname,</span>
                                <span class="s1">initialExpiration: (_initialOutput_fallback = initialOutput.fallback) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _initialOutput_fallback.initialExpiration,</span>
                                <span class="s1">initialRevalidate: (_initialOutput_fallback1 = initialOutput.fallback) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _initialOutput_fallback1.initialRevalidate,</span>
                                <span class="s1">initialHeaders: {</span>
                                    <span class="s1">...(_initialOutput_fallback2 = initialOutput.fallback) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _initialOutput_fallback2.initialHeaders,</span>
                                    <span class="s1">vary: varyHeader,</span>
                                    <span class="s0">'content-type'</span><span class="s1">: contentTypeHeader,</span>
                                    <span class="s1">[didPostponeHeader]: </span><span class="s0">'2'</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">};</span>
            <span class="s2">for</span><span class="s1">(</span><span class="s2">const </span><span class="s1">route </span><span class="s2">in </span><span class="s1">prerenderManifest.routes){</span>
                <span class="s2">var </span><span class="s1">_routesManifest_dynamicRoutes_find;</span>
                <span class="s2">const </span><span class="s1">{ initialExpireSeconds: initialExpiration, initialRevalidateSeconds: initialRevalidate, initialHeaders, initialStatus, prefetchDataRoute, dataRoute, renderingMode, allowHeader, experimentalBypassFor } = prerenderManifest.routes[route];</span>
                <span class="s2">const </span><span class="s1">srcRoute = prerenderManifest.routes[route].srcRoute || route;</span>
                <span class="s2">const </span><span class="s1">isAppPage = Boolean(appOutputMap[srcRoute]) || srcRoute === </span><span class="s0">'/_not-found'</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">isNotFoundTrue = prerenderManifest.notFoundRoutes.includes(route);</span>
                <span class="s2">let </span><span class="s1">allowQuery;</span>
                <span class="s2">const </span><span class="s1">routeKeys = (_routesManifest_dynamicRoutes_find = routesManifest.dynamicRoutes.find((item)=&gt;item.page === srcRoute)) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _routesManifest_dynamicRoutes_find.routeKeys;</span>
                <span class="s2">if </span><span class="s1">(!(</span><span class="s4">0</span><span class="s1">, _utils1.isDynamicRoute)(srcRoute)) {</span>
                    <span class="s3">// for non-dynamic routes we use an empty array since</span>
                    <span class="s3">// no query values bust the cache for non-dynamic prerenders</span>
                    <span class="s3">// prerendered paths also do not pass allowQuery as they match</span>
                    <span class="s3">// during handle: 'filesystem' so should not cache differently</span>
                    <span class="s3">// by query values</span>
                    <span class="s1">allowQuery = [];</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(routeKeys) {</span>
                    <span class="s3">// if we have routeKeys in the routes-manifest we use those</span>
                    <span class="s3">// for allowQuery for dynamic routes</span>
                    <span class="s1">allowQuery = Object.values(routeKeys);</span>
                <span class="s1">}</span>
                <span class="s2">let </span><span class="s1">filePath = _path.default.join(isAppPage ? appDistDir : pagesDistDir, </span><span class="s0">`</span><span class="s1">${route}</span><span class="s0">.</span><span class="s1">${isAppPage &amp;&amp; !dataRoute ? </span><span class="s0">'body' </span><span class="s1">: </span><span class="s0">'html'</span><span class="s1">}</span><span class="s0">`</span><span class="s1">);</span>
                <span class="s3">// we use the static 404 for notFound: true if available</span>
                <span class="s3">// if not we do a blocking invoke on first request</span>
                <span class="s2">if </span><span class="s1">(isNotFoundTrue &amp;&amp; hasStatic404) {</span>
                    <span class="s1">filePath = _path.default.join(pagesDistDir, </span><span class="s0">'404.html'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">initialOutput = {</span>
                    <span class="s1">id: route,</span>
                    <span class="s1">type: _constants.AdapterOutputType.PRERENDER,</span>
                    <span class="s1">pathname: route,</span>
                    <span class="s1">parentOutputId: srcRoute === </span><span class="s0">'/_not-found' </span><span class="s1">? srcRoute : getParentOutput(srcRoute, route).id,</span>
                    <span class="s1">fallback: !isNotFoundTrue || isNotFoundTrue &amp;&amp; hasStatic404 ? {</span>
                        <span class="s1">filePath,</span>
                        <span class="s1">initialStatus,</span>
                        <span class="s1">initialHeaders: {</span>
                            <span class="s1">...initialHeaders,</span>
                            <span class="s1">vary: varyHeader,</span>
                            <span class="s0">'content-type'</span><span class="s1">: contentTypeHeader</span>
                        <span class="s1">},</span>
                        <span class="s1">initialExpiration,</span>
                        <span class="s1">initialRevalidate: initialRevalidate || </span><span class="s4">1</span>
                    <span class="s1">} : undefined,</span>
                    <span class="s1">config: {</span>
                        <span class="s1">allowQuery,</span>
                        <span class="s1">allowHeader,</span>
                        <span class="s1">renderingMode,</span>
                        <span class="s1">bypassFor: experimentalBypassFor,</span>
                        <span class="s1">bypassToken: prerenderManifest.preview.previewModeId</span>
                    <span class="s1">}</span>
                <span class="s1">};</span>
                <span class="s1">outputs.push(initialOutput);</span>
                <span class="s2">if </span><span class="s1">(dataRoute) {</span>
                    <span class="s2">let </span><span class="s1">dataFilePath = _path.default.join(pagesDistDir, </span><span class="s0">`</span><span class="s1">${route}</span><span class="s0">.json`</span><span class="s1">);</span>
                    <span class="s2">if </span><span class="s1">(isAppPage) {</span>
                        <span class="s3">// When experimental PPR is enabled, we expect that the data</span>
                        <span class="s3">// that should be served as a part of the prerender should</span>
                        <span class="s3">// be from the prefetch data route. If this isn't enabled</span>
                        <span class="s3">// for ppr, the only way to get the data is from the data</span>
                        <span class="s3">// route.</span>
                        <span class="s1">dataFilePath = _path.default.join(appDistDir, prefetchDataRoute &amp;&amp; renderingMode === _renderingmode.RenderingMode.PARTIALLY_STATIC ? prefetchDataRoute : dataRoute);</span>
                    <span class="s1">}</span>
                    <span class="s1">outputs.push({</span>
                        <span class="s1">...initialOutput,</span>
                        <span class="s1">id: dataRoute,</span>
                        <span class="s1">pathname: dataRoute,</span>
                        <span class="s1">fallback: isNotFoundTrue ? undefined : {</span>
                            <span class="s1">...initialOutput.fallback,</span>
                            <span class="s1">filePath: dataFilePath</span>
                        <span class="s1">}</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(isAppPage) {</span>
                    <span class="s2">await </span><span class="s1">handleAppMeta(route, initialOutput);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">for</span><span class="s1">(</span><span class="s2">const </span><span class="s1">dynamicRoute </span><span class="s2">in </span><span class="s1">prerenderManifest.dynamicRoutes){</span>
                <span class="s2">var </span><span class="s1">_routesManifest_dynamicRoutes_find1;</span>
                <span class="s2">const </span><span class="s1">{ fallback, fallbackExpire, fallbackRevalidate, fallbackHeaders, fallbackStatus, allowHeader, dataRoute, renderingMode, experimentalBypassFor } = prerenderManifest.dynamicRoutes[dynamicRoute];</span>
                <span class="s2">const </span><span class="s1">isAppPage = Boolean(appOutputMap[dynamicRoute]);</span>
                <span class="s2">const </span><span class="s1">allowQuery = Object.values(((_routesManifest_dynamicRoutes_find1 = routesManifest.dynamicRoutes.find((item)=&gt;item.page === dynamicRoute)) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _routesManifest_dynamicRoutes_find1.routeKeys) || {});</span>
                <span class="s2">const </span><span class="s1">initialOutput = {</span>
                    <span class="s1">id: dynamicRoute,</span>
                    <span class="s1">type: _constants.AdapterOutputType.PRERENDER,</span>
                    <span class="s1">pathname: dynamicRoute,</span>
                    <span class="s1">parentOutputId: getParentOutput(dynamicRoute, dynamicRoute).id,</span>
                    <span class="s1">config: {</span>
                        <span class="s1">allowQuery,</span>
                        <span class="s1">allowHeader,</span>
                        <span class="s1">renderingMode,</span>
                        <span class="s1">bypassFor: experimentalBypassFor,</span>
                        <span class="s1">bypassToken: prerenderManifest.preview.previewModeId</span>
                    <span class="s1">},</span>
                    <span class="s1">fallback: </span><span class="s2">typeof </span><span class="s1">fallback === </span><span class="s0">'string' </span><span class="s1">? {</span>
                        <span class="s1">filePath: _path.default.join(isAppPage ? appDistDir : pagesDistDir, fallback),</span>
                        <span class="s1">initialStatus: fallbackStatus,</span>
                        <span class="s1">initialHeaders: fallbackHeaders,</span>
                        <span class="s1">initialExpiration: fallbackExpire,</span>
                        <span class="s1">initialRevalidate: fallbackRevalidate || </span><span class="s4">1</span>
                    <span class="s1">} : undefined</span>
                <span class="s1">};</span>
                <span class="s1">outputs.push(initialOutput);</span>
                <span class="s2">if </span><span class="s1">(isAppPage) {</span>
                    <span class="s2">await </span><span class="s1">handleAppMeta(dynamicRoute, initialOutput);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(dataRoute) {</span>
                    <span class="s1">outputs.push({</span>
                        <span class="s1">...initialOutput,</span>
                        <span class="s1">id: dataRoute,</span>
                        <span class="s1">pathname: dataRoute,</span>
                        <span class="s1">fallback: undefined</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">await </span><span class="s1">adapterMod.onBuildComplete({</span>
                <span class="s1">routes: {</span>
                    <span class="s1">dynamicRoutes: routesManifest.dynamicRoutes,</span>
                    <span class="s1">rewrites: routesManifest.rewrites,</span>
                    <span class="s1">redirects: routesManifest.redirects,</span>
                    <span class="s1">headers: routesManifest.headers</span>
                <span class="s1">},</span>
                <span class="s1">outputs</span>
            <span class="s1">});</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
            <span class="s1">_log.error(</span><span class="s0">`Failed to run onBuildComplete from </span><span class="s1">${adapterMod.name}</span><span class="s0">`</span><span class="s1">);</span>
            <span class="s2">throw </span><span class="s1">err;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">//# sourceMappingURL=build-complete.js.map</span></pre>
</body>
</html>