<html>
<head>
<title>react-server-dom-webpack-client.node.production.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #1750eb;}
.s6 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
react-server-dom-webpack-client.node.production.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@license </span><span class="s0">React</span>
 <span class="s0">* react-server-dom-webpack-client.node.production.js</span>
 <span class="s0">*</span>
 <span class="s0">* Copyright (c) Meta Platforms, Inc. and affiliates.</span>
 <span class="s0">*</span>
 <span class="s0">* This source code is licensed under the MIT license found in the</span>
 <span class="s0">* LICENSE file in the root directory of this source tree.</span>
 <span class="s0">*/</span>

<span class="s3">&quot;use strict&quot;</span><span class="s2">;</span>
<span class="s4">var </span><span class="s2">util = require(</span><span class="s3">&quot;util&quot;</span><span class="s2">),</span>
  <span class="s2">ReactDOM = require(</span><span class="s3">&quot;react-dom&quot;</span><span class="s2">),</span>
  <span class="s2">decoderOptions = { stream: !</span><span class="s5">0 </span><span class="s2">};</span>
<span class="s4">function </span><span class="s2">resolveClientReference(bundlerConfig, metadata) {</span>
  <span class="s4">if </span><span class="s2">(bundlerConfig) {</span>
    <span class="s4">var </span><span class="s2">moduleExports = bundlerConfig[metadata[</span><span class="s5">0</span><span class="s2">]];</span>
    <span class="s4">if </span><span class="s2">((bundlerConfig = moduleExports &amp;&amp; moduleExports[metadata[</span><span class="s5">2</span><span class="s2">]]))</span>
      <span class="s2">moduleExports = bundlerConfig.name;</span>
    <span class="s4">else </span><span class="s2">{</span>
      <span class="s2">bundlerConfig = moduleExports &amp;&amp; moduleExports[</span><span class="s3">&quot;*&quot;</span><span class="s2">];</span>
      <span class="s4">if </span><span class="s2">(!bundlerConfig)</span>
        <span class="s4">throw </span><span class="s2">Error(</span>
          <span class="s3">'Could not find the module &quot;' </span><span class="s2">+</span>
            <span class="s2">metadata[</span><span class="s5">0</span><span class="s2">] +</span>
            <span class="s3">'&quot; in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.'</span>
        <span class="s2">);</span>
      <span class="s2">moduleExports = metadata[</span><span class="s5">2</span><span class="s2">];</span>
    <span class="s2">}</span>
    <span class="s4">return </span><span class="s5">4 </span><span class="s2">=== metadata.length</span>
      <span class="s2">? [bundlerConfig.id, bundlerConfig.chunks, moduleExports, </span><span class="s5">1</span><span class="s2">]</span>
      <span class="s2">: [bundlerConfig.id, bundlerConfig.chunks, moduleExports];</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">metadata;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">resolveServerReference(bundlerConfig, id) {</span>
  <span class="s4">var </span><span class="s2">name = </span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
    <span class="s2">resolvedModuleData = bundlerConfig[id];</span>
  <span class="s4">if </span><span class="s2">(resolvedModuleData) name = resolvedModuleData.name;</span>
  <span class="s4">else </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">idx = id.lastIndexOf(</span><span class="s3">&quot;#&quot;</span><span class="s2">);</span>
    <span class="s2">-</span><span class="s5">1 </span><span class="s2">!== idx &amp;&amp;</span>
      <span class="s2">((name = id.slice(idx + </span><span class="s5">1</span><span class="s2">)),</span>
      <span class="s2">(resolvedModuleData = bundlerConfig[id.slice(</span><span class="s5">0</span><span class="s2">, idx)]));</span>
    <span class="s4">if </span><span class="s2">(!resolvedModuleData)</span>
      <span class="s4">throw </span><span class="s2">Error(</span>
        <span class="s3">'Could not find the module &quot;' </span><span class="s2">+</span>
          <span class="s2">id +</span>
          <span class="s3">'&quot; in the React Server Manifest. This is probably a bug in the React Server Components bundler.'</span>
      <span class="s2">);</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">resolvedModuleData.async</span>
    <span class="s2">? [resolvedModuleData.id, resolvedModuleData.chunks, name, </span><span class="s5">1</span><span class="s2">]</span>
    <span class="s2">: [resolvedModuleData.id, resolvedModuleData.chunks, name];</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">chunkCache = </span><span class="s4">new </span><span class="s2">Map();</span>
<span class="s4">function </span><span class="s2">requireAsyncModule(id) {</span>
  <span class="s4">var </span><span class="s2">promise = globalThis.__next_require__(id);</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">promise.then || </span><span class="s3">&quot;fulfilled&quot; </span><span class="s2">=== promise.status)</span>
    <span class="s4">return null</span><span class="s2">;</span>
  <span class="s2">promise.then(</span>
    <span class="s4">function </span><span class="s2">(value) {</span>
      <span class="s2">promise.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">;</span>
      <span class="s2">promise.value = value;</span>
    <span class="s2">},</span>
    <span class="s4">function </span><span class="s2">(reason) {</span>
      <span class="s2">promise.status = </span><span class="s3">&quot;rejected&quot;</span><span class="s2">;</span>
      <span class="s2">promise.reason = reason;</span>
    <span class="s2">}</span>
  <span class="s2">);</span>
  <span class="s4">return </span><span class="s2">promise;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">ignoreReject() {}</span>
<span class="s4">function </span><span class="s2">preloadModule(metadata) {</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">chunks = metadata[</span><span class="s5">1</span><span class="s2">], promises = [], i = </span><span class="s5">0</span><span class="s2">; i &lt; chunks.length; ) {</span>
    <span class="s4">var </span><span class="s2">chunkId = chunks[i++];</span>
    <span class="s2">chunks[i++];</span>
    <span class="s4">var </span><span class="s2">entry = chunkCache.get(chunkId);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== entry) {</span>
      <span class="s2">entry = __webpack_chunk_load__(chunkId);</span>
      <span class="s2">promises.push(entry);</span>
      <span class="s4">var </span><span class="s2">resolve = chunkCache.set.bind(chunkCache, chunkId, </span><span class="s4">null</span><span class="s2">);</span>
      <span class="s2">entry.then(resolve, ignoreReject);</span>
      <span class="s2">chunkCache.set(chunkId, entry);</span>
    <span class="s2">} </span><span class="s4">else null </span><span class="s2">!== entry &amp;&amp; promises.push(entry);</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s5">4 </span><span class="s2">=== metadata.length</span>
    <span class="s2">? </span><span class="s5">0 </span><span class="s2">=== promises.length</span>
      <span class="s2">? requireAsyncModule(metadata[</span><span class="s5">0</span><span class="s2">])</span>
      <span class="s2">: Promise.all(promises).then(</span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">return </span><span class="s2">requireAsyncModule(metadata[</span><span class="s5">0</span><span class="s2">]);</span>
        <span class="s2">})</span>
    <span class="s2">: </span><span class="s5">0 </span><span class="s2">&lt; promises.length</span>
      <span class="s2">? Promise.all(promises)</span>
      <span class="s2">: </span><span class="s4">null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">requireModule(metadata) {</span>
  <span class="s4">var </span><span class="s2">moduleExports = globalThis.__next_require__(metadata[</span><span class="s5">0</span><span class="s2">]);</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">4 </span><span class="s2">=== metadata.length &amp;&amp; </span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">moduleExports.then)</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;fulfilled&quot; </span><span class="s2">=== moduleExports.status)</span>
      <span class="s2">moduleExports = moduleExports.value;</span>
    <span class="s4">else throw </span><span class="s2">moduleExports.reason;</span>
  <span class="s4">return </span><span class="s3">&quot;*&quot; </span><span class="s2">=== metadata[</span><span class="s5">2</span><span class="s2">]</span>
    <span class="s2">? moduleExports</span>
    <span class="s2">: </span><span class="s3">&quot;&quot; </span><span class="s2">=== metadata[</span><span class="s5">2</span><span class="s2">]</span>
      <span class="s2">? moduleExports.__esModule</span>
        <span class="s2">? moduleExports.default</span>
        <span class="s2">: moduleExports</span>
      <span class="s2">: moduleExports[metadata[</span><span class="s5">2</span><span class="s2">]];</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">prepareDestinationWithChunks(moduleLoading, chunks, nonce$jscomp$0) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== moduleLoading)</span>
    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">1</span><span class="s2">; i &lt; chunks.length; i += </span><span class="s5">2</span><span class="s2">) {</span>
      <span class="s4">var </span><span class="s2">nonce = nonce$jscomp$0,</span>
        <span class="s2">JSCompiler_temp_const = ReactDOMSharedInternals.d,</span>
        <span class="s2">JSCompiler_temp_const$jscomp$0 = JSCompiler_temp_const.X,</span>
        <span class="s2">JSCompiler_temp_const$jscomp$1 = moduleLoading.prefix + chunks[i];</span>
      <span class="s4">var </span><span class="s2">JSCompiler_inline_result = moduleLoading.crossOrigin;</span>
      <span class="s2">JSCompiler_inline_result =</span>
        <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">JSCompiler_inline_result</span>
          <span class="s2">? </span><span class="s3">&quot;use-credentials&quot; </span><span class="s2">=== JSCompiler_inline_result</span>
            <span class="s2">? JSCompiler_inline_result</span>
            <span class="s2">: </span><span class="s3">&quot;&quot;</span>
          <span class="s2">: </span><span class="s4">void </span><span class="s5">0</span><span class="s2">;</span>
      <span class="s2">JSCompiler_temp_const$jscomp$0.call(</span>
        <span class="s2">JSCompiler_temp_const,</span>
        <span class="s2">JSCompiler_temp_const$jscomp$1,</span>
        <span class="s2">{ crossOrigin: JSCompiler_inline_result, nonce: nonce }</span>
      <span class="s2">);</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">ReactDOMSharedInternals =</span>
    <span class="s2">ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,</span>
  <span class="s2">REACT_ELEMENT_TYPE = Symbol.for(</span><span class="s3">&quot;react.transitional.element&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_LAZY_TYPE = Symbol.for(</span><span class="s3">&quot;react.lazy&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_POSTPONE_TYPE = Symbol.for(</span><span class="s3">&quot;react.postpone&quot;</span><span class="s2">),</span>
  <span class="s2">MAYBE_ITERATOR_SYMBOL = Symbol.iterator;</span>
<span class="s4">function </span><span class="s2">getIteratorFn(maybeIterable) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== maybeIterable || </span><span class="s3">&quot;object&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">maybeIterable) </span><span class="s4">return null</span><span class="s2">;</span>
  <span class="s2">maybeIterable =</span>
    <span class="s2">(MAYBE_ITERATOR_SYMBOL &amp;&amp; maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||</span>
    <span class="s2">maybeIterable[</span><span class="s3">&quot;@@iterator&quot;</span><span class="s2">];</span>
  <span class="s4">return </span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">maybeIterable ? maybeIterable : </span><span class="s4">null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">ASYNC_ITERATOR = Symbol.asyncIterator,</span>
  <span class="s2">isArrayImpl = Array.isArray,</span>
  <span class="s2">getPrototypeOf = Object.getPrototypeOf,</span>
  <span class="s2">ObjectPrototype = Object.prototype,</span>
  <span class="s2">knownServerReferences = </span><span class="s4">new </span><span class="s2">WeakMap();</span>
<span class="s4">function </span><span class="s2">serializeNumber(number) {</span>
  <span class="s4">return </span><span class="s2">Number.isFinite(number)</span>
    <span class="s2">? </span><span class="s5">0 </span><span class="s2">=== number &amp;&amp; -Infinity === </span><span class="s5">1 </span><span class="s2">/ number</span>
      <span class="s2">? </span><span class="s3">&quot;$-0&quot;</span>
      <span class="s2">: number</span>
    <span class="s2">: Infinity === number</span>
      <span class="s2">? </span><span class="s3">&quot;$Infinity&quot;</span>
      <span class="s2">: -Infinity === number</span>
        <span class="s2">? </span><span class="s3">&quot;$-Infinity&quot;</span>
        <span class="s2">: </span><span class="s3">&quot;$NaN&quot;</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">processReply(</span>
  <span class="s2">root,</span>
  <span class="s2">formFieldPrefix,</span>
  <span class="s2">temporaryReferences,</span>
  <span class="s2">resolve,</span>
  <span class="s2">reject</span>
<span class="s2">) {</span>
  <span class="s4">function </span><span class="s2">serializeTypedArray(tag, typedArray) {</span>
    <span class="s2">typedArray = </span><span class="s4">new </span><span class="s2">Blob([</span>
      <span class="s4">new </span><span class="s2">Uint8Array(</span>
        <span class="s2">typedArray.buffer,</span>
        <span class="s2">typedArray.byteOffset,</span>
        <span class="s2">typedArray.byteLength</span>
      <span class="s2">)</span>
    <span class="s2">]);</span>
    <span class="s4">var </span><span class="s2">blobId = nextPartId++;</span>
    <span class="s4">null </span><span class="s2">=== formData &amp;&amp; (formData = </span><span class="s4">new </span><span class="s2">FormData());</span>
    <span class="s2">formData.append(formFieldPrefix + blobId, typedArray);</span>
    <span class="s4">return </span><span class="s3">&quot;$&quot; </span><span class="s2">+ tag + blobId.toString(</span><span class="s5">16</span><span class="s2">);</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">serializeBinaryReader(reader) {</span>
    <span class="s4">function </span><span class="s2">progress(entry) {</span>
      <span class="s2">entry.done</span>
        <span class="s2">? ((entry = nextPartId++),</span>
          <span class="s2">data.append(formFieldPrefix + entry, </span><span class="s4">new </span><span class="s2">Blob(buffer)),</span>
          <span class="s2">data.append(</span>
            <span class="s2">formFieldPrefix + streamId,</span>
            <span class="s3">'&quot;$o' </span><span class="s2">+ entry.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">'&quot;'</span>
          <span class="s2">),</span>
          <span class="s2">data.append(formFieldPrefix + streamId, </span><span class="s3">&quot;C&quot;</span><span class="s2">),</span>
          <span class="s2">pendingParts--,</span>
          <span class="s5">0 </span><span class="s2">=== pendingParts &amp;&amp; resolve(data))</span>
        <span class="s2">: (buffer.push(entry.value),</span>
          <span class="s2">reader.read(</span><span class="s4">new </span><span class="s2">Uint8Array(</span><span class="s5">1024</span><span class="s2">)).then(progress, reject));</span>
    <span class="s2">}</span>
    <span class="s4">null </span><span class="s2">=== formData &amp;&amp; (formData = </span><span class="s4">new </span><span class="s2">FormData());</span>
    <span class="s4">var </span><span class="s2">data = formData;</span>
    <span class="s2">pendingParts++;</span>
    <span class="s4">var </span><span class="s2">streamId = nextPartId++,</span>
      <span class="s2">buffer = [];</span>
    <span class="s2">reader.read(</span><span class="s4">new </span><span class="s2">Uint8Array(</span><span class="s5">1024</span><span class="s2">)).then(progress, reject);</span>
    <span class="s4">return </span><span class="s3">&quot;$r&quot; </span><span class="s2">+ streamId.toString(</span><span class="s5">16</span><span class="s2">);</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">serializeReader(reader) {</span>
    <span class="s4">function </span><span class="s2">progress(entry) {</span>
      <span class="s4">if </span><span class="s2">(entry.done)</span>
        <span class="s2">data.append(formFieldPrefix + streamId, </span><span class="s3">&quot;C&quot;</span><span class="s2">),</span>
          <span class="s2">pendingParts--,</span>
          <span class="s5">0 </span><span class="s2">=== pendingParts &amp;&amp; resolve(data);</span>
      <span class="s4">else</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s4">var </span><span class="s2">partJSON = JSON.stringify(entry.value, resolveToJSON);</span>
          <span class="s2">data.append(formFieldPrefix + streamId, partJSON);</span>
          <span class="s2">reader.read().then(progress, reject);</span>
        <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
          <span class="s2">reject(x);</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">null </span><span class="s2">=== formData &amp;&amp; (formData = </span><span class="s4">new </span><span class="s2">FormData());</span>
    <span class="s4">var </span><span class="s2">data = formData;</span>
    <span class="s2">pendingParts++;</span>
    <span class="s4">var </span><span class="s2">streamId = nextPartId++;</span>
    <span class="s2">reader.read().then(progress, reject);</span>
    <span class="s4">return </span><span class="s3">&quot;$R&quot; </span><span class="s2">+ streamId.toString(</span><span class="s5">16</span><span class="s2">);</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">serializeReadableStream(stream) {</span>
    <span class="s4">try </span><span class="s2">{</span>
      <span class="s4">var </span><span class="s2">binaryReader = stream.getReader({ mode: </span><span class="s3">&quot;byob&quot; </span><span class="s2">});</span>
    <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
      <span class="s4">return </span><span class="s2">serializeReader(stream.getReader());</span>
    <span class="s2">}</span>
    <span class="s4">return </span><span class="s2">serializeBinaryReader(binaryReader);</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">serializeAsyncIterable(iterable, iterator) {</span>
    <span class="s4">function </span><span class="s2">progress(entry) {</span>
      <span class="s4">if </span><span class="s2">(entry.done) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== entry.value)</span>
          <span class="s2">data.append(formFieldPrefix + streamId, </span><span class="s3">&quot;C&quot;</span><span class="s2">);</span>
        <span class="s4">else</span>
          <span class="s4">try </span><span class="s2">{</span>
            <span class="s4">var </span><span class="s2">partJSON = JSON.stringify(entry.value, resolveToJSON);</span>
            <span class="s2">data.append(formFieldPrefix + streamId, </span><span class="s3">&quot;C&quot; </span><span class="s2">+ partJSON);</span>
          <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
            <span class="s2">reject(x);</span>
            <span class="s4">return</span><span class="s2">;</span>
          <span class="s2">}</span>
        <span class="s2">pendingParts--;</span>
        <span class="s5">0 </span><span class="s2">=== pendingParts &amp;&amp; resolve(data);</span>
      <span class="s2">} </span><span class="s4">else</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s4">var </span><span class="s2">partJSON$21 = JSON.stringify(entry.value, resolveToJSON);</span>
          <span class="s2">data.append(formFieldPrefix + streamId, partJSON$21);</span>
          <span class="s2">iterator.next().then(progress, reject);</span>
        <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x$22) {</span>
          <span class="s2">reject(x$22);</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">null </span><span class="s2">=== formData &amp;&amp; (formData = </span><span class="s4">new </span><span class="s2">FormData());</span>
    <span class="s4">var </span><span class="s2">data = formData;</span>
    <span class="s2">pendingParts++;</span>
    <span class="s4">var </span><span class="s2">streamId = nextPartId++;</span>
    <span class="s2">iterable = iterable === iterator;</span>
    <span class="s2">iterator.next().then(progress, reject);</span>
    <span class="s4">return </span><span class="s3">&quot;$&quot; </span><span class="s2">+ (iterable ? </span><span class="s3">&quot;x&quot; </span><span class="s2">: </span><span class="s3">&quot;X&quot;</span><span class="s2">) + streamId.toString(</span><span class="s5">16</span><span class="s2">);</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">resolveToJSON(key, value) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== value) </span><span class="s4">return null</span><span class="s2">;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) {</span>
      <span class="s4">switch </span><span class="s2">(value.$$typeof) {</span>
        <span class="s4">case </span><span class="s2">REACT_ELEMENT_TYPE:</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== temporaryReferences &amp;&amp; -</span><span class="s5">1 </span><span class="s2">=== key.indexOf(</span><span class="s3">&quot;:&quot;</span><span class="s2">)) {</span>
            <span class="s4">var </span><span class="s2">parentReference = writtenObjects.get(</span><span class="s4">this</span><span class="s2">);</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== parentReference)</span>
              <span class="s4">return </span><span class="s2">(</span>
                <span class="s2">temporaryReferences.set(parentReference + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ key, value),</span>
                <span class="s3">&quot;$T&quot;</span>
              <span class="s2">);</span>
          <span class="s2">}</span>
          <span class="s4">throw </span><span class="s2">Error(</span>
            <span class="s3">&quot;React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options.&quot;</span>
          <span class="s2">);</span>
        <span class="s4">case </span><span class="s2">REACT_LAZY_TYPE:</span>
          <span class="s2">parentReference = value._payload;</span>
          <span class="s4">var </span><span class="s2">init = value._init;</span>
          <span class="s4">null </span><span class="s2">=== formData &amp;&amp; (formData = </span><span class="s4">new </span><span class="s2">FormData());</span>
          <span class="s2">pendingParts++;</span>
          <span class="s4">try </span><span class="s2">{</span>
            <span class="s4">var </span><span class="s2">resolvedModel = init(parentReference),</span>
              <span class="s2">lazyId = nextPartId++,</span>
              <span class="s2">partJSON = serializeModel(resolvedModel, lazyId);</span>
            <span class="s2">formData.append(formFieldPrefix + lazyId, partJSON);</span>
            <span class="s4">return </span><span class="s3">&quot;$&quot; </span><span class="s2">+ lazyId.toString(</span><span class="s5">16</span><span class="s2">);</span>
          <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
            <span class="s4">if </span><span class="s2">(</span>
              <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">x &amp;&amp;</span>
              <span class="s4">null </span><span class="s2">!== x &amp;&amp;</span>
              <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">x.then</span>
            <span class="s2">) {</span>
              <span class="s2">pendingParts++;</span>
              <span class="s4">var </span><span class="s2">lazyId$23 = nextPartId++;</span>
              <span class="s2">parentReference = </span><span class="s4">function </span><span class="s2">() {</span>
                <span class="s4">try </span><span class="s2">{</span>
                  <span class="s4">var </span><span class="s2">partJSON$24 = serializeModel(value, lazyId$23),</span>
                    <span class="s2">data$25 = formData;</span>
                  <span class="s2">data$25.append(formFieldPrefix + lazyId$23, partJSON$24);</span>
                  <span class="s2">pendingParts--;</span>
                  <span class="s5">0 </span><span class="s2">=== pendingParts &amp;&amp; resolve(data$25);</span>
                <span class="s2">} </span><span class="s4">catch </span><span class="s2">(reason) {</span>
                  <span class="s2">reject(reason);</span>
                <span class="s2">}</span>
              <span class="s2">};</span>
              <span class="s2">x.then(parentReference, parentReference);</span>
              <span class="s4">return </span><span class="s3">&quot;$&quot; </span><span class="s2">+ lazyId$23.toString(</span><span class="s5">16</span><span class="s2">);</span>
            <span class="s2">}</span>
            <span class="s2">reject(x);</span>
            <span class="s4">return null</span><span class="s2">;</span>
          <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
            <span class="s2">pendingParts--;</span>
          <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value.then) {</span>
        <span class="s4">null </span><span class="s2">=== formData &amp;&amp; (formData = </span><span class="s4">new </span><span class="s2">FormData());</span>
        <span class="s2">pendingParts++;</span>
        <span class="s4">var </span><span class="s2">promiseId = nextPartId++;</span>
        <span class="s2">value.then(</span><span class="s4">function </span><span class="s2">(partValue) {</span>
          <span class="s4">try </span><span class="s2">{</span>
            <span class="s4">var </span><span class="s2">partJSON$27 = serializeModel(partValue, promiseId);</span>
            <span class="s2">partValue = formData;</span>
            <span class="s2">partValue.append(formFieldPrefix + promiseId, partJSON$27);</span>
            <span class="s2">pendingParts--;</span>
            <span class="s5">0 </span><span class="s2">=== pendingParts &amp;&amp; resolve(partValue);</span>
          <span class="s2">} </span><span class="s4">catch </span><span class="s2">(reason) {</span>
            <span class="s2">reject(reason);</span>
          <span class="s2">}</span>
        <span class="s2">}, reject);</span>
        <span class="s4">return </span><span class="s3">&quot;$@&quot; </span><span class="s2">+ promiseId.toString(</span><span class="s5">16</span><span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s2">parentReference = writtenObjects.get(value);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== parentReference)</span>
        <span class="s4">if </span><span class="s2">(modelRoot === value) modelRoot = </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s4">else return </span><span class="s2">parentReference;</span>
      <span class="s4">else</span>
        <span class="s2">-</span><span class="s5">1 </span><span class="s2">=== key.indexOf(</span><span class="s3">&quot;:&quot;</span><span class="s2">) &amp;&amp;</span>
          <span class="s2">((parentReference = writtenObjects.get(</span><span class="s4">this</span><span class="s2">)),</span>
          <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== parentReference &amp;&amp;</span>
            <span class="s2">((key = parentReference + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ key),</span>
            <span class="s2">writtenObjects.set(value, key),</span>
            <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== temporaryReferences &amp;&amp;</span>
              <span class="s2">temporaryReferences.set(key, value)));</span>
      <span class="s4">if </span><span class="s2">(isArrayImpl(value)) </span><span class="s4">return </span><span class="s2">value;</span>
      <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">FormData) {</span>
        <span class="s4">null </span><span class="s2">=== formData &amp;&amp; (formData = </span><span class="s4">new </span><span class="s2">FormData());</span>
        <span class="s4">var </span><span class="s2">data$31 = formData;</span>
        <span class="s2">key = nextPartId++;</span>
        <span class="s4">var </span><span class="s2">prefix = formFieldPrefix + key + </span><span class="s3">&quot;_&quot;</span><span class="s2">;</span>
        <span class="s2">value.forEach(</span><span class="s4">function </span><span class="s2">(originalValue, originalKey) {</span>
          <span class="s2">data$31.append(prefix + originalKey, originalValue);</span>
        <span class="s2">});</span>
        <span class="s4">return </span><span class="s3">&quot;$K&quot; </span><span class="s2">+ key.toString(</span><span class="s5">16</span><span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Map)</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(key = nextPartId++),</span>
          <span class="s2">(parentReference = serializeModel(Array.from(value), key)),</span>
          <span class="s4">null </span><span class="s2">=== formData &amp;&amp; (formData = </span><span class="s4">new </span><span class="s2">FormData()),</span>
          <span class="s2">formData.append(formFieldPrefix + key, parentReference),</span>
          <span class="s3">&quot;$Q&quot; </span><span class="s2">+ key.toString(</span><span class="s5">16</span><span class="s2">)</span>
        <span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Set)</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(key = nextPartId++),</span>
          <span class="s2">(parentReference = serializeModel(Array.from(value), key)),</span>
          <span class="s4">null </span><span class="s2">=== formData &amp;&amp; (formData = </span><span class="s4">new </span><span class="s2">FormData()),</span>
          <span class="s2">formData.append(formFieldPrefix + key, parentReference),</span>
          <span class="s3">&quot;$W&quot; </span><span class="s2">+ key.toString(</span><span class="s5">16</span><span class="s2">)</span>
        <span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">ArrayBuffer)</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(key = </span><span class="s4">new </span><span class="s2">Blob([value])),</span>
          <span class="s2">(parentReference = nextPartId++),</span>
          <span class="s4">null </span><span class="s2">=== formData &amp;&amp; (formData = </span><span class="s4">new </span><span class="s2">FormData()),</span>
          <span class="s2">formData.append(formFieldPrefix + parentReference, key),</span>
          <span class="s3">&quot;$A&quot; </span><span class="s2">+ parentReference.toString(</span><span class="s5">16</span><span class="s2">)</span>
        <span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Int8Array) </span><span class="s4">return </span><span class="s2">serializeTypedArray(</span><span class="s3">&quot;O&quot;</span><span class="s2">, value);</span>
      <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Uint8Array) </span><span class="s4">return </span><span class="s2">serializeTypedArray(</span><span class="s3">&quot;o&quot;</span><span class="s2">, value);</span>
      <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Uint8ClampedArray)</span>
        <span class="s4">return </span><span class="s2">serializeTypedArray(</span><span class="s3">&quot;U&quot;</span><span class="s2">, value);</span>
      <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Int16Array) </span><span class="s4">return </span><span class="s2">serializeTypedArray(</span><span class="s3">&quot;S&quot;</span><span class="s2">, value);</span>
      <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Uint16Array) </span><span class="s4">return </span><span class="s2">serializeTypedArray(</span><span class="s3">&quot;s&quot;</span><span class="s2">, value);</span>
      <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Int32Array) </span><span class="s4">return </span><span class="s2">serializeTypedArray(</span><span class="s3">&quot;L&quot;</span><span class="s2">, value);</span>
      <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Uint32Array) </span><span class="s4">return </span><span class="s2">serializeTypedArray(</span><span class="s3">&quot;l&quot;</span><span class="s2">, value);</span>
      <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Float32Array) </span><span class="s4">return </span><span class="s2">serializeTypedArray(</span><span class="s3">&quot;G&quot;</span><span class="s2">, value);</span>
      <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Float64Array) </span><span class="s4">return </span><span class="s2">serializeTypedArray(</span><span class="s3">&quot;g&quot;</span><span class="s2">, value);</span>
      <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">BigInt64Array)</span>
        <span class="s4">return </span><span class="s2">serializeTypedArray(</span><span class="s3">&quot;M&quot;</span><span class="s2">, value);</span>
      <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">BigUint64Array)</span>
        <span class="s4">return </span><span class="s2">serializeTypedArray(</span><span class="s3">&quot;m&quot;</span><span class="s2">, value);</span>
      <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">DataView) </span><span class="s4">return </span><span class="s2">serializeTypedArray(</span><span class="s3">&quot;V&quot;</span><span class="s2">, value);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">Blob &amp;&amp; value </span><span class="s4">instanceof </span><span class="s2">Blob)</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s4">null </span><span class="s2">=== formData &amp;&amp; (formData = </span><span class="s4">new </span><span class="s2">FormData()),</span>
          <span class="s2">(key = nextPartId++),</span>
          <span class="s2">formData.append(formFieldPrefix + key, value),</span>
          <span class="s3">&quot;$B&quot; </span><span class="s2">+ key.toString(</span><span class="s5">16</span><span class="s2">)</span>
        <span class="s2">);</span>
      <span class="s4">if </span><span class="s2">((key = getIteratorFn(value)))</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(parentReference = key.call(value)),</span>
          <span class="s2">parentReference === value</span>
            <span class="s2">? ((key = nextPartId++),</span>
              <span class="s2">(parentReference = serializeModel(</span>
                <span class="s2">Array.from(parentReference),</span>
                <span class="s2">key</span>
              <span class="s2">)),</span>
              <span class="s4">null </span><span class="s2">=== formData &amp;&amp; (formData = </span><span class="s4">new </span><span class="s2">FormData()),</span>
              <span class="s2">formData.append(formFieldPrefix + key, parentReference),</span>
              <span class="s3">&quot;$i&quot; </span><span class="s2">+ key.toString(</span><span class="s5">16</span><span class="s2">))</span>
            <span class="s2">: Array.from(parentReference)</span>
        <span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">ReadableStream &amp;&amp;</span>
        <span class="s2">value </span><span class="s4">instanceof </span><span class="s2">ReadableStream</span>
      <span class="s2">)</span>
        <span class="s4">return </span><span class="s2">serializeReadableStream(value);</span>
      <span class="s2">key = value[ASYNC_ITERATOR];</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">key)</span>
        <span class="s4">return </span><span class="s2">serializeAsyncIterable(value, key.call(value));</span>
      <span class="s2">key = getPrototypeOf(value);</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">key !== ObjectPrototype &amp;&amp;</span>
        <span class="s2">(</span><span class="s4">null </span><span class="s2">=== key || </span><span class="s4">null </span><span class="s2">!== getPrototypeOf(key))</span>
      <span class="s2">) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== temporaryReferences)</span>
          <span class="s4">throw </span><span class="s2">Error(</span>
            <span class="s3">&quot;Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported.&quot;</span>
          <span class="s2">);</span>
        <span class="s4">return </span><span class="s3">&quot;$T&quot;</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s2">value;</span>
    <span class="s2">}</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;Z&quot; </span><span class="s2">=== value[value.length - </span><span class="s5">1</span><span class="s2">] &amp;&amp; </span><span class="s4">this</span><span class="s2">[key] </span><span class="s4">instanceof </span><span class="s2">Date)</span>
        <span class="s4">return </span><span class="s3">&quot;$D&quot; </span><span class="s2">+ value;</span>
      <span class="s2">key = </span><span class="s3">&quot;$&quot; </span><span class="s2">=== value[</span><span class="s5">0</span><span class="s2">] ? </span><span class="s3">&quot;$&quot; </span><span class="s2">+ value : value;</span>
      <span class="s4">return </span><span class="s2">key;</span>
    <span class="s2">}</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;boolean&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) </span><span class="s4">return </span><span class="s2">value;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;number&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) </span><span class="s4">return </span><span class="s2">serializeNumber(value);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;undefined&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) </span><span class="s4">return </span><span class="s3">&quot;$undefined&quot;</span><span class="s2">;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) {</span>
      <span class="s2">parentReference = knownServerReferences.get(value);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== parentReference)</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(key = JSON.stringify(</span>
            <span class="s2">{ id: parentReference.id, bound: parentReference.bound },</span>
            <span class="s2">resolveToJSON</span>
          <span class="s2">)),</span>
          <span class="s4">null </span><span class="s2">=== formData &amp;&amp; (formData = </span><span class="s4">new </span><span class="s2">FormData()),</span>
          <span class="s2">(parentReference = nextPartId++),</span>
          <span class="s2">formData.set(formFieldPrefix + parentReference, key),</span>
          <span class="s3">&quot;$F&quot; </span><span class="s2">+ parentReference.toString(</span><span class="s5">16</span><span class="s2">)</span>
        <span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== temporaryReferences &amp;&amp;</span>
        <span class="s2">-</span><span class="s5">1 </span><span class="s2">=== key.indexOf(</span><span class="s3">&quot;:&quot;</span><span class="s2">) &amp;&amp;</span>
        <span class="s2">((parentReference = writtenObjects.get(</span><span class="s4">this</span><span class="s2">)),</span>
        <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== parentReference)</span>
      <span class="s2">)</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">temporaryReferences.set(parentReference + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ key, value), </span><span class="s3">&quot;$T&quot;</span>
        <span class="s2">);</span>
      <span class="s4">throw </span><span class="s2">Error(</span>
        <span class="s3">&quot;Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again.&quot;</span>
      <span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;symbol&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) {</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== temporaryReferences &amp;&amp;</span>
        <span class="s2">-</span><span class="s5">1 </span><span class="s2">=== key.indexOf(</span><span class="s3">&quot;:&quot;</span><span class="s2">) &amp;&amp;</span>
        <span class="s2">((parentReference = writtenObjects.get(</span><span class="s4">this</span><span class="s2">)),</span>
        <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== parentReference)</span>
      <span class="s2">)</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">temporaryReferences.set(parentReference + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ key, value), </span><span class="s3">&quot;$T&quot;</span>
        <span class="s2">);</span>
      <span class="s4">throw </span><span class="s2">Error(</span>
        <span class="s3">&quot;Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options.&quot;</span>
      <span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;bigint&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) </span><span class="s4">return </span><span class="s3">&quot;$n&quot; </span><span class="s2">+ value.toString(</span><span class="s5">10</span><span class="s2">);</span>
    <span class="s4">throw </span><span class="s2">Error(</span>
      <span class="s3">&quot;Type &quot; </span><span class="s2">+</span>
        <span class="s4">typeof </span><span class="s2">value +</span>
        <span class="s3">&quot; is not supported as an argument to a Server Function.&quot;</span>
    <span class="s2">);</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">serializeModel(model, id) {</span>
    <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">model &amp;&amp;</span>
      <span class="s4">null </span><span class="s2">!== model &amp;&amp;</span>
      <span class="s2">((id = </span><span class="s3">&quot;$&quot; </span><span class="s2">+ id.toString(</span><span class="s5">16</span><span class="s2">)),</span>
      <span class="s2">writtenObjects.set(model, id),</span>
      <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== temporaryReferences &amp;&amp; temporaryReferences.set(id, model));</span>
    <span class="s2">modelRoot = model;</span>
    <span class="s4">return </span><span class="s2">JSON.stringify(model, resolveToJSON);</span>
  <span class="s2">}</span>
  <span class="s4">var </span><span class="s2">nextPartId = </span><span class="s5">1</span><span class="s2">,</span>
    <span class="s2">pendingParts = </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">formData = </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">writtenObjects = </span><span class="s4">new </span><span class="s2">WeakMap(),</span>
    <span class="s2">modelRoot = root,</span>
    <span class="s2">json = serializeModel(root, </span><span class="s5">0</span><span class="s2">);</span>
  <span class="s4">null </span><span class="s2">=== formData</span>
    <span class="s2">? resolve(json)</span>
    <span class="s2">: (formData.set(formFieldPrefix + </span><span class="s3">&quot;0&quot;</span><span class="s2">, json),</span>
      <span class="s5">0 </span><span class="s2">=== pendingParts &amp;&amp; resolve(formData));</span>
  <span class="s4">return function </span><span class="s2">() {</span>
    <span class="s5">0 </span><span class="s2">&lt; pendingParts &amp;&amp;</span>
      <span class="s2">((pendingParts = </span><span class="s5">0</span><span class="s2">),</span>
      <span class="s4">null </span><span class="s2">=== formData ? resolve(json) : resolve(formData));</span>
  <span class="s2">};</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">boundCache = </span><span class="s4">new </span><span class="s2">WeakMap();</span>
<span class="s4">function </span><span class="s2">encodeFormData(reference) {</span>
  <span class="s4">var </span><span class="s2">resolve,</span>
    <span class="s2">reject,</span>
    <span class="s2">thenable = </span><span class="s4">new </span><span class="s2">Promise(</span><span class="s4">function </span><span class="s2">(res, rej) {</span>
      <span class="s2">resolve = res;</span>
      <span class="s2">reject = rej;</span>
    <span class="s2">});</span>
  <span class="s2">processReply(</span>
    <span class="s2">reference,</span>
    <span class="s3">&quot;&quot;</span><span class="s2">,</span>
    <span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s4">function </span><span class="s2">(body) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">body) {</span>
        <span class="s4">var </span><span class="s2">data = </span><span class="s4">new </span><span class="s2">FormData();</span>
        <span class="s2">data.append(</span><span class="s3">&quot;0&quot;</span><span class="s2">, body);</span>
        <span class="s2">body = data;</span>
      <span class="s2">}</span>
      <span class="s2">thenable.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">;</span>
      <span class="s2">thenable.value = body;</span>
      <span class="s2">resolve(body);</span>
    <span class="s2">},</span>
    <span class="s4">function </span><span class="s2">(e) {</span>
      <span class="s2">thenable.status = </span><span class="s3">&quot;rejected&quot;</span><span class="s2">;</span>
      <span class="s2">thenable.reason = e;</span>
      <span class="s2">reject(e);</span>
    <span class="s2">}</span>
  <span class="s2">);</span>
  <span class="s4">return </span><span class="s2">thenable;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">defaultEncodeFormAction(identifierPrefix) {</span>
  <span class="s4">var </span><span class="s2">referenceClosure = knownServerReferences.get(</span><span class="s4">this</span><span class="s2">);</span>
  <span class="s4">if </span><span class="s2">(!referenceClosure)</span>
    <span class="s4">throw </span><span class="s2">Error(</span>
      <span class="s3">&quot;Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.&quot;</span>
    <span class="s2">);</span>
  <span class="s4">var </span><span class="s2">data = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== referenceClosure.bound) {</span>
    <span class="s2">data = boundCache.get(referenceClosure);</span>
    <span class="s2">data ||</span>
      <span class="s2">((data = encodeFormData({</span>
        <span class="s2">id: referenceClosure.id,</span>
        <span class="s2">bound: referenceClosure.bound</span>
      <span class="s2">})),</span>
      <span class="s2">boundCache.set(referenceClosure, data));</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;rejected&quot; </span><span class="s2">=== data.status) </span><span class="s4">throw </span><span class="s2">data.reason;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;fulfilled&quot; </span><span class="s2">!== data.status) </span><span class="s4">throw </span><span class="s2">data;</span>
    <span class="s2">referenceClosure = data.value;</span>
    <span class="s4">var </span><span class="s2">prefixedData = </span><span class="s4">new </span><span class="s2">FormData();</span>
    <span class="s2">referenceClosure.forEach(</span><span class="s4">function </span><span class="s2">(value, key) {</span>
      <span class="s2">prefixedData.append(</span><span class="s3">&quot;$ACTION_&quot; </span><span class="s2">+ identifierPrefix + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ key, value);</span>
    <span class="s2">});</span>
    <span class="s2">data = prefixedData;</span>
    <span class="s2">referenceClosure = </span><span class="s3">&quot;$ACTION_REF_&quot; </span><span class="s2">+ identifierPrefix;</span>
  <span class="s2">} </span><span class="s4">else </span><span class="s2">referenceClosure = </span><span class="s3">&quot;$ACTION_ID_&quot; </span><span class="s2">+ referenceClosure.id;</span>
  <span class="s4">return </span><span class="s2">{</span>
    <span class="s2">name: referenceClosure,</span>
    <span class="s2">method: </span><span class="s3">&quot;POST&quot;</span><span class="s2">,</span>
    <span class="s2">encType: </span><span class="s3">&quot;multipart/form-data&quot;</span><span class="s2">,</span>
    <span class="s2">data: data</span>
  <span class="s2">};</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">isSignatureEqual(referenceId, numberOfBoundArgs) {</span>
  <span class="s4">var </span><span class="s2">referenceClosure = knownServerReferences.get(</span><span class="s4">this</span><span class="s2">);</span>
  <span class="s4">if </span><span class="s2">(!referenceClosure)</span>
    <span class="s4">throw </span><span class="s2">Error(</span>
      <span class="s3">&quot;Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.&quot;</span>
    <span class="s2">);</span>
  <span class="s4">if </span><span class="s2">(referenceClosure.id !== referenceId) </span><span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">boundPromise = referenceClosure.bound;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== boundPromise) </span><span class="s4">return </span><span class="s5">0 </span><span class="s2">=== numberOfBoundArgs;</span>
  <span class="s4">switch </span><span class="s2">(boundPromise.status) {</span>
    <span class="s4">case </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">boundPromise.value.length === numberOfBoundArgs;</span>
    <span class="s4">case </span><span class="s3">&quot;pending&quot;</span><span class="s2">:</span>
      <span class="s4">throw </span><span class="s2">boundPromise;</span>
    <span class="s4">case </span><span class="s3">&quot;rejected&quot;</span><span class="s2">:</span>
      <span class="s4">throw </span><span class="s2">boundPromise.reason;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">throw </span><span class="s2">(</span>
        <span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">boundPromise.status &amp;&amp;</span>
          <span class="s2">((boundPromise.status = </span><span class="s3">&quot;pending&quot;</span><span class="s2">),</span>
          <span class="s2">boundPromise.then(</span>
            <span class="s4">function </span><span class="s2">(boundArgs) {</span>
              <span class="s2">boundPromise.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">;</span>
              <span class="s2">boundPromise.value = boundArgs;</span>
            <span class="s2">},</span>
            <span class="s4">function </span><span class="s2">(error) {</span>
              <span class="s2">boundPromise.status = </span><span class="s3">&quot;rejected&quot;</span><span class="s2">;</span>
              <span class="s2">boundPromise.reason = error;</span>
            <span class="s2">}</span>
          <span class="s2">)),</span>
        <span class="s2">boundPromise)</span>
      <span class="s2">);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">registerBoundServerReference(reference, id, bound, encodeFormAction) {</span>
  <span class="s2">knownServerReferences.has(reference) ||</span>
    <span class="s2">(knownServerReferences.set(reference, {</span>
      <span class="s2">id: id,</span>
      <span class="s2">originalBind: reference.bind,</span>
      <span class="s2">bound: bound</span>
    <span class="s2">}),</span>
    <span class="s2">Object.defineProperties(reference, {</span>
      <span class="s2">$$FORM_ACTION: {</span>
        <span class="s2">value:</span>
          <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== encodeFormAction</span>
            <span class="s2">? defaultEncodeFormAction</span>
            <span class="s2">: </span><span class="s4">function </span><span class="s2">() {</span>
                <span class="s4">var </span><span class="s2">referenceClosure = knownServerReferences.get(</span><span class="s4">this</span><span class="s2">);</span>
                <span class="s4">if </span><span class="s2">(!referenceClosure)</span>
                  <span class="s4">throw </span><span class="s2">Error(</span>
                    <span class="s3">&quot;Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.&quot;</span>
                  <span class="s2">);</span>
                <span class="s4">var </span><span class="s2">boundPromise = referenceClosure.bound;</span>
                <span class="s4">null </span><span class="s2">=== boundPromise &amp;&amp; (boundPromise = Promise.resolve([]));</span>
                <span class="s4">return </span><span class="s2">encodeFormAction(referenceClosure.id, boundPromise);</span>
              <span class="s2">}</span>
      <span class="s2">},</span>
      <span class="s2">$$IS_SIGNATURE_EQUAL: { value: isSignatureEqual },</span>
      <span class="s2">bind: { value: bind }</span>
    <span class="s2">}));</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">FunctionBind = Function.prototype.bind,</span>
  <span class="s2">ArraySlice = Array.prototype.slice;</span>
<span class="s4">function </span><span class="s2">bind() {</span>
  <span class="s4">var </span><span class="s2">referenceClosure = knownServerReferences.get(</span><span class="s4">this</span><span class="s2">);</span>
  <span class="s4">if </span><span class="s2">(!referenceClosure) </span><span class="s4">return </span><span class="s2">FunctionBind.apply(</span><span class="s4">this</span><span class="s2">, arguments);</span>
  <span class="s4">var </span><span class="s2">newFn = referenceClosure.originalBind.apply(</span><span class="s4">this</span><span class="s2">, arguments),</span>
    <span class="s2">args = ArraySlice.call(arguments, </span><span class="s5">1</span><span class="s2">),</span>
    <span class="s2">boundPromise = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">boundPromise =</span>
    <span class="s4">null </span><span class="s2">!== referenceClosure.bound</span>
      <span class="s2">? Promise.resolve(referenceClosure.bound).then(</span><span class="s4">function </span><span class="s2">(boundArgs) {</span>
          <span class="s4">return </span><span class="s2">boundArgs.concat(args);</span>
        <span class="s2">})</span>
      <span class="s2">: Promise.resolve(args);</span>
  <span class="s2">knownServerReferences.set(newFn, {</span>
    <span class="s2">id: referenceClosure.id,</span>
    <span class="s2">originalBind: newFn.bind,</span>
    <span class="s2">bound: boundPromise</span>
  <span class="s2">});</span>
  <span class="s2">Object.defineProperties(newFn, {</span>
    <span class="s2">$$FORM_ACTION: { value: </span><span class="s4">this</span><span class="s2">.$$FORM_ACTION },</span>
    <span class="s2">$$IS_SIGNATURE_EQUAL: { value: isSignatureEqual },</span>
    <span class="s2">bind: { value: bind }</span>
  <span class="s2">});</span>
  <span class="s4">return </span><span class="s2">newFn;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createBoundServerReference(metaData, callServer, encodeFormAction) {</span>
  <span class="s4">function </span><span class="s2">action() {</span>
    <span class="s4">var </span><span class="s2">args = Array.prototype.slice.call(arguments);</span>
    <span class="s4">return </span><span class="s2">bound</span>
      <span class="s2">? </span><span class="s3">&quot;fulfilled&quot; </span><span class="s2">=== bound.status</span>
        <span class="s2">? callServer(id, bound.value.concat(args))</span>
        <span class="s2">: Promise.resolve(bound).then(</span><span class="s4">function </span><span class="s2">(boundArgs) {</span>
            <span class="s4">return </span><span class="s2">callServer(id, boundArgs.concat(args));</span>
          <span class="s2">})</span>
      <span class="s2">: callServer(id, args);</span>
  <span class="s2">}</span>
  <span class="s4">var </span><span class="s2">id = metaData.id,</span>
    <span class="s2">bound = metaData.bound;</span>
  <span class="s2">registerBoundServerReference(action, id, bound, encodeFormAction);</span>
  <span class="s4">return </span><span class="s2">action;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createServerReference$1(id, callServer, encodeFormAction) {</span>
  <span class="s4">function </span><span class="s2">action() {</span>
    <span class="s4">var </span><span class="s2">args = Array.prototype.slice.call(arguments);</span>
    <span class="s4">return </span><span class="s2">callServer(id, args);</span>
  <span class="s2">}</span>
  <span class="s2">registerBoundServerReference(action, id, </span><span class="s4">null</span><span class="s2">, encodeFormAction);</span>
  <span class="s4">return </span><span class="s2">action;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">ReactPromise(status, value, reason) {</span>
  <span class="s4">this</span><span class="s2">.status = status;</span>
  <span class="s4">this</span><span class="s2">.value = value;</span>
  <span class="s4">this</span><span class="s2">.reason = reason;</span>
<span class="s2">}</span>
<span class="s2">ReactPromise.prototype = Object.create(Promise.prototype);</span>
<span class="s2">ReactPromise.prototype.then = </span><span class="s4">function </span><span class="s2">(resolve, reject) {</span>
  <span class="s4">switch </span><span class="s2">(</span><span class="s4">this</span><span class="s2">.status) {</span>
    <span class="s4">case </span><span class="s3">&quot;resolved_model&quot;</span><span class="s2">:</span>
      <span class="s2">initializeModelChunk(</span><span class="s4">this</span><span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;resolved_module&quot;</span><span class="s2">:</span>
      <span class="s2">initializeModuleChunk(</span><span class="s4">this</span><span class="s2">);</span>
  <span class="s2">}</span>
  <span class="s4">switch </span><span class="s2">(</span><span class="s4">this</span><span class="s2">.status) {</span>
    <span class="s4">case </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">:</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">resolve &amp;&amp; resolve(</span><span class="s4">this</span><span class="s2">.value);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;pending&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;blocked&quot;</span><span class="s2">:</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">resolve &amp;&amp;</span>
        <span class="s2">(</span><span class="s4">null </span><span class="s2">=== </span><span class="s4">this</span><span class="s2">.value &amp;&amp; (</span><span class="s4">this</span><span class="s2">.value = []), </span><span class="s4">this</span><span class="s2">.value.push(resolve));</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">reject &amp;&amp;</span>
        <span class="s2">(</span><span class="s4">null </span><span class="s2">=== </span><span class="s4">this</span><span class="s2">.reason &amp;&amp; (</span><span class="s4">this</span><span class="s2">.reason = []), </span><span class="s4">this</span><span class="s2">.reason.push(reject));</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;halted&quot;</span><span class="s2">:</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">reject &amp;&amp; reject(</span><span class="s4">this</span><span class="s2">.reason);</span>
  <span class="s2">}</span>
<span class="s2">};</span>
<span class="s4">function </span><span class="s2">readChunk(chunk) {</span>
  <span class="s4">switch </span><span class="s2">(chunk.status) {</span>
    <span class="s4">case </span><span class="s3">&quot;resolved_model&quot;</span><span class="s2">:</span>
      <span class="s2">initializeModelChunk(chunk);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;resolved_module&quot;</span><span class="s2">:</span>
      <span class="s2">initializeModuleChunk(chunk);</span>
  <span class="s2">}</span>
  <span class="s4">switch </span><span class="s2">(chunk.status) {</span>
    <span class="s4">case </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">chunk.value;</span>
    <span class="s4">case </span><span class="s3">&quot;pending&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;blocked&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;halted&quot;</span><span class="s2">:</span>
      <span class="s4">throw </span><span class="s2">chunk;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">throw </span><span class="s2">chunk.reason;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createErrorChunk(response, error) {</span>
  <span class="s4">return new </span><span class="s2">ReactPromise(</span><span class="s3">&quot;rejected&quot;</span><span class="s2">, </span><span class="s4">null</span><span class="s2">, error);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">wakeChunk(listeners, value) {</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; listeners.length; i++) {</span>
    <span class="s4">var </span><span class="s2">listener = listeners[i];</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">listener</span>
      <span class="s2">? listener(value)</span>
      <span class="s2">: fulfillReference(listener, value);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">rejectChunk(listeners, error) {</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; listeners.length; i++) {</span>
    <span class="s4">var </span><span class="s2">listener = listeners[i];</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">listener</span>
      <span class="s2">? listener(error)</span>
      <span class="s2">: rejectReference(listener, error);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">resolveBlockedCycle(resolvedChunk, reference) {</span>
  <span class="s4">var </span><span class="s2">referencedChunk = reference.handler.chunk;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== referencedChunk) </span><span class="s4">return null</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(referencedChunk === resolvedChunk) </span><span class="s4">return </span><span class="s2">reference.handler;</span>
  <span class="s2">reference = referencedChunk.value;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== reference)</span>
    <span class="s4">for </span><span class="s2">(</span>
      <span class="s2">referencedChunk = </span><span class="s5">0</span><span class="s2">;</span>
      <span class="s2">referencedChunk &lt; reference.length;</span>
      <span class="s2">referencedChunk++</span>
    <span class="s2">) {</span>
      <span class="s4">var </span><span class="s2">listener = reference[referencedChunk];</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">listener &amp;&amp;</span>
        <span class="s2">((listener = resolveBlockedCycle(resolvedChunk, listener)),</span>
        <span class="s4">null </span><span class="s2">!== listener)</span>
      <span class="s2">)</span>
        <span class="s4">return </span><span class="s2">listener;</span>
    <span class="s2">}</span>
  <span class="s4">return null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {</span>
  <span class="s4">switch </span><span class="s2">(chunk.status) {</span>
    <span class="s4">case </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">:</span>
      <span class="s2">wakeChunk(resolveListeners, chunk.value);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;blocked&quot;</span><span class="s2">:</span>
      <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; resolveListeners.length; i++) {</span>
        <span class="s4">var </span><span class="s2">listener = resolveListeners[i];</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">listener) {</span>
          <span class="s4">var </span><span class="s2">cyclicHandler = resolveBlockedCycle(chunk, listener);</span>
          <span class="s4">null </span><span class="s2">!== cyclicHandler &amp;&amp;</span>
            <span class="s2">(fulfillReference(listener, cyclicHandler.value),</span>
            <span class="s2">resolveListeners.splice(i, </span><span class="s5">1</span><span class="s2">),</span>
            <span class="s2">i--,</span>
            <span class="s4">null </span><span class="s2">!== rejectListeners &amp;&amp;</span>
              <span class="s2">((listener = rejectListeners.indexOf(listener)),</span>
              <span class="s2">-</span><span class="s5">1 </span><span class="s2">!== listener &amp;&amp; rejectListeners.splice(listener, </span><span class="s5">1</span><span class="s2">)));</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s4">case </span><span class="s3">&quot;pending&quot;</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(chunk.value)</span>
        <span class="s4">for </span><span class="s2">(i = </span><span class="s5">0</span><span class="s2">; i &lt; resolveListeners.length; i++)</span>
          <span class="s2">chunk.value.push(resolveListeners[i]);</span>
      <span class="s4">else </span><span class="s2">chunk.value = resolveListeners;</span>
      <span class="s4">if </span><span class="s2">(chunk.reason) {</span>
        <span class="s4">if </span><span class="s2">(rejectListeners)</span>
          <span class="s4">for </span><span class="s2">(</span>
            <span class="s2">resolveListeners = </span><span class="s5">0</span><span class="s2">;</span>
            <span class="s2">resolveListeners &lt; rejectListeners.length;</span>
            <span class="s2">resolveListeners++</span>
          <span class="s2">)</span>
            <span class="s2">chunk.reason.push(rejectListeners[resolveListeners]);</span>
      <span class="s2">} </span><span class="s4">else </span><span class="s2">chunk.reason = rejectListeners;</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;rejected&quot;</span><span class="s2">:</span>
      <span class="s2">rejectListeners &amp;&amp; rejectChunk(rejectListeners, chunk.reason);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">triggerErrorOnChunk(response, chunk, error) {</span>
  <span class="s3">&quot;pending&quot; </span><span class="s2">!== chunk.status &amp;&amp; </span><span class="s3">&quot;blocked&quot; </span><span class="s2">!== chunk.status</span>
    <span class="s2">? chunk.reason.error(error)</span>
    <span class="s2">: ((response = chunk.reason),</span>
      <span class="s2">(chunk.status = </span><span class="s3">&quot;rejected&quot;</span><span class="s2">),</span>
      <span class="s2">(chunk.reason = error),</span>
      <span class="s4">null </span><span class="s2">!== response &amp;&amp; rejectChunk(response, error));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createResolvedIteratorResultChunk(response, value, done) {</span>
  <span class="s4">return new </span><span class="s2">ReactPromise(</span>
    <span class="s3">&quot;resolved_model&quot;</span><span class="s2">,</span>
    <span class="s2">(done ? </span><span class="s3">'{&quot;done&quot;:true,&quot;value&quot;:' </span><span class="s2">: </span><span class="s3">'{&quot;done&quot;:false,&quot;value&quot;:'</span><span class="s2">) + value + </span><span class="s3">&quot;}&quot;</span><span class="s2">,</span>
    <span class="s2">response</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">resolveIteratorResultChunk(response, chunk, value, done) {</span>
  <span class="s2">resolveModelChunk(</span>
    <span class="s2">response,</span>
    <span class="s2">chunk,</span>
    <span class="s2">(done ? </span><span class="s3">'{&quot;done&quot;:true,&quot;value&quot;:' </span><span class="s2">: </span><span class="s3">'{&quot;done&quot;:false,&quot;value&quot;:'</span><span class="s2">) + value + </span><span class="s3">&quot;}&quot;</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">resolveModelChunk(response, chunk, value) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;pending&quot; </span><span class="s2">!== chunk.status) chunk.reason.enqueueModel(value);</span>
  <span class="s4">else </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">resolveListeners = chunk.value,</span>
      <span class="s2">rejectListeners = chunk.reason;</span>
    <span class="s2">chunk.status = </span><span class="s3">&quot;resolved_model&quot;</span><span class="s2">;</span>
    <span class="s2">chunk.value = value;</span>
    <span class="s2">chunk.reason = response;</span>
    <span class="s4">null </span><span class="s2">!== resolveListeners &amp;&amp;</span>
      <span class="s2">(initializeModelChunk(chunk),</span>
      <span class="s2">wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners));</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">resolveModuleChunk(response, chunk, value) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;pending&quot; </span><span class="s2">=== chunk.status || </span><span class="s3">&quot;blocked&quot; </span><span class="s2">=== chunk.status) {</span>
    <span class="s2">response = chunk.value;</span>
    <span class="s4">var </span><span class="s2">rejectListeners = chunk.reason;</span>
    <span class="s2">chunk.status = </span><span class="s3">&quot;resolved_module&quot;</span><span class="s2">;</span>
    <span class="s2">chunk.value = value;</span>
    <span class="s4">null </span><span class="s2">!== response &amp;&amp;</span>
      <span class="s2">(initializeModuleChunk(chunk),</span>
      <span class="s2">wakeChunkIfInitialized(chunk, response, rejectListeners));</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">initializingHandler = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">initializeModelChunk(chunk) {</span>
  <span class="s4">var </span><span class="s2">prevHandler = initializingHandler;</span>
  <span class="s2">initializingHandler = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">resolvedModel = chunk.value,</span>
    <span class="s2">response = chunk.reason;</span>
  <span class="s2">chunk.status = </span><span class="s3">&quot;blocked&quot;</span><span class="s2">;</span>
  <span class="s2">chunk.value = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">chunk.reason = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">value = JSON.parse(resolvedModel, response._fromJSON),</span>
      <span class="s2">resolveListeners = chunk.value;</span>
    <span class="s4">null </span><span class="s2">!== resolveListeners &amp;&amp;</span>
      <span class="s2">((chunk.value = </span><span class="s4">null</span><span class="s2">),</span>
      <span class="s2">(chunk.reason = </span><span class="s4">null</span><span class="s2">),</span>
      <span class="s2">wakeChunk(resolveListeners, value));</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== initializingHandler) {</span>
      <span class="s4">if </span><span class="s2">(initializingHandler.errored) </span><span class="s4">throw </span><span class="s2">initializingHandler.reason;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">&lt; initializingHandler.deps) {</span>
        <span class="s2">initializingHandler.value = value;</span>
        <span class="s2">initializingHandler.chunk = chunk;</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">chunk.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">;</span>
    <span class="s2">chunk.value = value;</span>
  <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
    <span class="s2">(chunk.status = </span><span class="s3">&quot;rejected&quot;</span><span class="s2">), (chunk.reason = error);</span>
  <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
    <span class="s2">initializingHandler = prevHandler;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">initializeModuleChunk(chunk) {</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">value = requireModule(chunk.value);</span>
    <span class="s2">chunk.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">;</span>
    <span class="s2">chunk.value = value;</span>
  <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
    <span class="s2">(chunk.status = </span><span class="s3">&quot;rejected&quot;</span><span class="s2">), (chunk.reason = error);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">reportGlobalError(weakResponse, error) {</span>
  <span class="s2">weakResponse._closed = !</span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">weakResponse._closedReason = error;</span>
  <span class="s2">weakResponse._chunks.forEach(</span><span class="s4">function </span><span class="s2">(chunk) {</span>
    <span class="s3">&quot;pending&quot; </span><span class="s2">=== chunk.status &amp;&amp;</span>
      <span class="s2">triggerErrorOnChunk(weakResponse, chunk, error);</span>
  <span class="s2">});</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createLazyChunkWrapper(chunk) {</span>
  <span class="s4">return </span><span class="s2">{ $$typeof: REACT_LAZY_TYPE, _payload: chunk, _init: readChunk };</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getChunk(response, id) {</span>
  <span class="s4">var </span><span class="s2">chunks = response._chunks,</span>
    <span class="s2">chunk = chunks.get(id);</span>
  <span class="s2">chunk ||</span>
    <span class="s2">((chunk = response._closed</span>
      <span class="s2">? createErrorChunk(response, response._closedReason)</span>
      <span class="s2">: </span><span class="s4">new </span><span class="s2">ReactPromise(</span><span class="s3">&quot;pending&quot;</span><span class="s2">, </span><span class="s4">null</span><span class="s2">, </span><span class="s4">null</span><span class="s2">)),</span>
    <span class="s2">chunks.set(id, chunk));</span>
  <span class="s4">return </span><span class="s2">chunk;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">fulfillReference(reference, value) {</span>
  <span class="s4">for </span><span class="s2">(</span>
    <span class="s4">var </span><span class="s2">response = reference.response,</span>
      <span class="s2">handler = reference.handler,</span>
      <span class="s2">parentObject = reference.parentObject,</span>
      <span class="s2">key = reference.key,</span>
      <span class="s2">map = reference.map,</span>
      <span class="s2">path = reference.path,</span>
      <span class="s2">i = </span><span class="s5">1</span><span class="s2">;</span>
    <span class="s2">i &lt; path.length;</span>
    <span class="s2">i++</span>
  <span class="s2">) {</span>
    <span class="s4">for </span><span class="s2">(; value.$$typeof === REACT_LAZY_TYPE; )</span>
      <span class="s4">if </span><span class="s2">(((value = value._payload), value === handler.chunk))</span>
        <span class="s2">value = handler.value;</span>
      <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">switch </span><span class="s2">(value.status) {</span>
          <span class="s4">case </span><span class="s3">&quot;resolved_model&quot;</span><span class="s2">:</span>
            <span class="s2">initializeModelChunk(value);</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s3">&quot;resolved_module&quot;</span><span class="s2">:</span>
            <span class="s2">initializeModuleChunk(value);</span>
        <span class="s2">}</span>
        <span class="s4">switch </span><span class="s2">(value.status) {</span>
          <span class="s4">case </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">:</span>
            <span class="s2">value = value.value;</span>
            <span class="s4">continue</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s3">&quot;blocked&quot;</span><span class="s2">:</span>
            <span class="s4">var </span><span class="s2">cyclicHandler = resolveBlockedCycle(value, reference);</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== cyclicHandler) {</span>
              <span class="s2">value = cyclicHandler.value;</span>
              <span class="s4">continue</span><span class="s2">;</span>
            <span class="s2">}</span>
          <span class="s4">case </span><span class="s3">&quot;pending&quot;</span><span class="s2">:</span>
            <span class="s2">path.splice(</span><span class="s5">0</span><span class="s2">, i - </span><span class="s5">1</span><span class="s2">);</span>
            <span class="s4">null </span><span class="s2">=== value.value</span>
              <span class="s2">? (value.value = [reference])</span>
              <span class="s2">: value.value.push(reference);</span>
            <span class="s4">null </span><span class="s2">=== value.reason</span>
              <span class="s2">? (value.reason = [reference])</span>
              <span class="s2">: value.reason.push(reference);</span>
            <span class="s4">return</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s3">&quot;halted&quot;</span><span class="s2">:</span>
            <span class="s4">return</span><span class="s2">;</span>
          <span class="s4">default</span><span class="s2">:</span>
            <span class="s2">rejectReference(reference, value.reason);</span>
            <span class="s4">return</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">value = value[path[i]];</span>
  <span class="s2">}</span>
  <span class="s2">reference = map(response, value, parentObject, key);</span>
  <span class="s2">parentObject[key] = reference;</span>
  <span class="s3">&quot;&quot; </span><span class="s2">=== key &amp;&amp; </span><span class="s4">null </span><span class="s2">=== handler.value &amp;&amp; (handler.value = reference);</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s2">parentObject[</span><span class="s5">0</span><span class="s2">] === REACT_ELEMENT_TYPE &amp;&amp;</span>
    <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">handler.value &amp;&amp;</span>
    <span class="s4">null </span><span class="s2">!== handler.value &amp;&amp;</span>
    <span class="s2">handler.value.$$typeof === REACT_ELEMENT_TYPE</span>
  <span class="s2">)</span>
    <span class="s4">switch </span><span class="s2">(((parentObject = handler.value), key)) {</span>
      <span class="s4">case </span><span class="s3">&quot;3&quot;</span><span class="s2">:</span>
        <span class="s2">parentObject.props = reference;</span>
    <span class="s2">}</span>
  <span class="s2">handler.deps--;</span>
  <span class="s5">0 </span><span class="s2">=== handler.deps &amp;&amp;</span>
    <span class="s2">((key = handler.chunk),</span>
    <span class="s4">null </span><span class="s2">!== key &amp;&amp;</span>
      <span class="s3">&quot;blocked&quot; </span><span class="s2">=== key.status &amp;&amp;</span>
      <span class="s2">((parentObject = key.value),</span>
      <span class="s2">(key.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">),</span>
      <span class="s2">(key.value = handler.value),</span>
      <span class="s2">(key.reason = handler.reason),</span>
      <span class="s4">null </span><span class="s2">!== parentObject &amp;&amp; wakeChunk(parentObject, handler.value)));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">rejectReference(reference, error) {</span>
  <span class="s4">var </span><span class="s2">handler = reference.handler;</span>
  <span class="s2">reference = reference.response;</span>
  <span class="s2">handler.errored ||</span>
    <span class="s2">((handler.errored = !</span><span class="s5">0</span><span class="s2">),</span>
    <span class="s2">(handler.value = </span><span class="s4">null</span><span class="s2">),</span>
    <span class="s2">(handler.reason = error),</span>
    <span class="s2">(handler = handler.chunk),</span>
    <span class="s4">null </span><span class="s2">!== handler &amp;&amp;</span>
      <span class="s3">&quot;blocked&quot; </span><span class="s2">=== handler.status &amp;&amp;</span>
      <span class="s2">triggerErrorOnChunk(reference, handler, error));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">waitForReference(</span>
  <span class="s2">referencedChunk,</span>
  <span class="s2">parentObject,</span>
  <span class="s2">key,</span>
  <span class="s2">response,</span>
  <span class="s2">map,</span>
  <span class="s2">path</span>
<span class="s2">) {</span>
  <span class="s4">if </span><span class="s2">(initializingHandler) {</span>
    <span class="s4">var </span><span class="s2">handler = initializingHandler;</span>
    <span class="s2">handler.deps++;</span>
  <span class="s2">} </span><span class="s4">else</span>
    <span class="s2">handler = initializingHandler = {</span>
      <span class="s2">parent: </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">chunk: </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">value: </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">reason: </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">deps: </span><span class="s5">1</span><span class="s2">,</span>
      <span class="s2">errored: !</span><span class="s5">1</span>
    <span class="s2">};</span>
  <span class="s2">parentObject = {</span>
    <span class="s2">response: response,</span>
    <span class="s2">handler: handler,</span>
    <span class="s2">parentObject: parentObject,</span>
    <span class="s2">key: key,</span>
    <span class="s2">map: map,</span>
    <span class="s2">path: path</span>
  <span class="s2">};</span>
  <span class="s4">null </span><span class="s2">=== referencedChunk.value</span>
    <span class="s2">? (referencedChunk.value = [parentObject])</span>
    <span class="s2">: referencedChunk.value.push(parentObject);</span>
  <span class="s4">null </span><span class="s2">=== referencedChunk.reason</span>
    <span class="s2">? (referencedChunk.reason = [parentObject])</span>
    <span class="s2">: referencedChunk.reason.push(parentObject);</span>
  <span class="s4">return null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">loadServerReference(response, metaData, parentObject, key) {</span>
  <span class="s4">if </span><span class="s2">(!response._serverReferenceConfig)</span>
    <span class="s4">return </span><span class="s2">createBoundServerReference(</span>
      <span class="s2">metaData,</span>
      <span class="s2">response._callServer,</span>
      <span class="s2">response._encodeFormAction</span>
    <span class="s2">);</span>
  <span class="s4">var </span><span class="s2">serverReference = resolveServerReference(</span>
      <span class="s2">response._serverReferenceConfig,</span>
      <span class="s2">metaData.id</span>
    <span class="s2">),</span>
    <span class="s2">promise = preloadModule(serverReference);</span>
  <span class="s4">if </span><span class="s2">(promise)</span>
    <span class="s2">metaData.bound &amp;&amp; (promise = Promise.all([promise, metaData.bound]));</span>
  <span class="s4">else if </span><span class="s2">(metaData.bound) promise = Promise.resolve(metaData.bound);</span>
  <span class="s4">else</span>
    <span class="s4">return </span><span class="s2">(</span>
      <span class="s2">(promise = requireModule(serverReference)),</span>
      <span class="s2">registerBoundServerReference(</span>
        <span class="s2">promise,</span>
        <span class="s2">metaData.id,</span>
        <span class="s2">metaData.bound,</span>
        <span class="s2">response._encodeFormAction</span>
      <span class="s2">),</span>
      <span class="s2">promise</span>
    <span class="s2">);</span>
  <span class="s4">if </span><span class="s2">(initializingHandler) {</span>
    <span class="s4">var </span><span class="s2">handler = initializingHandler;</span>
    <span class="s2">handler.deps++;</span>
  <span class="s2">} </span><span class="s4">else</span>
    <span class="s2">handler = initializingHandler = {</span>
      <span class="s2">parent: </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">chunk: </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">value: </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">reason: </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">deps: </span><span class="s5">1</span><span class="s2">,</span>
      <span class="s2">errored: !</span><span class="s5">1</span>
    <span class="s2">};</span>
  <span class="s2">promise.then(</span>
    <span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">var </span><span class="s2">resolvedValue = requireModule(serverReference);</span>
      <span class="s4">if </span><span class="s2">(metaData.bound) {</span>
        <span class="s4">var </span><span class="s2">boundArgs = metaData.bound.value.slice(</span><span class="s5">0</span><span class="s2">);</span>
        <span class="s2">boundArgs.unshift(</span><span class="s4">null</span><span class="s2">);</span>
        <span class="s2">resolvedValue = resolvedValue.bind.apply(resolvedValue, boundArgs);</span>
      <span class="s2">}</span>
      <span class="s2">registerBoundServerReference(</span>
        <span class="s2">resolvedValue,</span>
        <span class="s2">metaData.id,</span>
        <span class="s2">metaData.bound,</span>
        <span class="s2">response._encodeFormAction</span>
      <span class="s2">);</span>
      <span class="s2">parentObject[key] = resolvedValue;</span>
      <span class="s3">&quot;&quot; </span><span class="s2">=== key &amp;&amp; </span><span class="s4">null </span><span class="s2">=== handler.value &amp;&amp; (handler.value = resolvedValue);</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">parentObject[</span><span class="s5">0</span><span class="s2">] === REACT_ELEMENT_TYPE &amp;&amp;</span>
        <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">handler.value &amp;&amp;</span>
        <span class="s4">null </span><span class="s2">!== handler.value &amp;&amp;</span>
        <span class="s2">handler.value.$$typeof === REACT_ELEMENT_TYPE</span>
      <span class="s2">)</span>
        <span class="s4">switch </span><span class="s2">(((boundArgs = handler.value), key)) {</span>
          <span class="s4">case </span><span class="s3">&quot;3&quot;</span><span class="s2">:</span>
            <span class="s2">boundArgs.props = resolvedValue;</span>
        <span class="s2">}</span>
      <span class="s2">handler.deps--;</span>
      <span class="s5">0 </span><span class="s2">=== handler.deps &amp;&amp;</span>
        <span class="s2">((resolvedValue = handler.chunk),</span>
        <span class="s4">null </span><span class="s2">!== resolvedValue &amp;&amp;</span>
          <span class="s3">&quot;blocked&quot; </span><span class="s2">=== resolvedValue.status &amp;&amp;</span>
          <span class="s2">((boundArgs = resolvedValue.value),</span>
          <span class="s2">(resolvedValue.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">),</span>
          <span class="s2">(resolvedValue.value = handler.value),</span>
          <span class="s4">null </span><span class="s2">!== boundArgs &amp;&amp; wakeChunk(boundArgs, handler.value)));</span>
    <span class="s2">},</span>
    <span class="s4">function </span><span class="s2">(error) {</span>
      <span class="s4">if </span><span class="s2">(!handler.errored) {</span>
        <span class="s2">handler.errored = !</span><span class="s5">0</span><span class="s2">;</span>
        <span class="s2">handler.value = </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s2">handler.reason = error;</span>
        <span class="s4">var </span><span class="s2">chunk = handler.chunk;</span>
        <span class="s4">null </span><span class="s2">!== chunk &amp;&amp;</span>
          <span class="s3">&quot;blocked&quot; </span><span class="s2">=== chunk.status &amp;&amp;</span>
          <span class="s2">triggerErrorOnChunk(response, chunk, error);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
  <span class="s2">);</span>
  <span class="s4">return null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getOutlinedModel(response, reference, parentObject, key, map) {</span>
  <span class="s2">reference = reference.split(</span><span class="s3">&quot;:&quot;</span><span class="s2">);</span>
  <span class="s4">var </span><span class="s2">id = parseInt(reference[</span><span class="s5">0</span><span class="s2">], </span><span class="s5">16</span><span class="s2">);</span>
  <span class="s2">id = getChunk(response, id);</span>
  <span class="s4">switch </span><span class="s2">(id.status) {</span>
    <span class="s4">case </span><span class="s3">&quot;resolved_model&quot;</span><span class="s2">:</span>
      <span class="s2">initializeModelChunk(id);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;resolved_module&quot;</span><span class="s2">:</span>
      <span class="s2">initializeModuleChunk(id);</span>
  <span class="s2">}</span>
  <span class="s4">switch </span><span class="s2">(id.status) {</span>
    <span class="s4">case </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">:</span>
      <span class="s4">var </span><span class="s2">value = id.value;</span>
      <span class="s4">for </span><span class="s2">(id = </span><span class="s5">1</span><span class="s2">; id &lt; reference.length; id++) {</span>
        <span class="s4">for </span><span class="s2">(; value.$$typeof === REACT_LAZY_TYPE; ) {</span>
          <span class="s2">value = value._payload;</span>
          <span class="s4">switch </span><span class="s2">(value.status) {</span>
            <span class="s4">case </span><span class="s3">&quot;resolved_model&quot;</span><span class="s2">:</span>
              <span class="s2">initializeModelChunk(value);</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;resolved_module&quot;</span><span class="s2">:</span>
              <span class="s2">initializeModuleChunk(value);</span>
          <span class="s2">}</span>
          <span class="s4">switch </span><span class="s2">(value.status) {</span>
            <span class="s4">case </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">:</span>
              <span class="s2">value = value.value;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;blocked&quot;</span><span class="s2">:</span>
            <span class="s4">case </span><span class="s3">&quot;pending&quot;</span><span class="s2">:</span>
              <span class="s4">return </span><span class="s2">waitForReference(</span>
                <span class="s2">value,</span>
                <span class="s2">parentObject,</span>
                <span class="s2">key,</span>
                <span class="s2">response,</span>
                <span class="s2">map,</span>
                <span class="s2">reference.slice(id - </span><span class="s5">1</span><span class="s2">)</span>
              <span class="s2">);</span>
            <span class="s4">case </span><span class="s3">&quot;halted&quot;</span><span class="s2">:</span>
              <span class="s4">return </span><span class="s2">(</span>
                <span class="s2">initializingHandler</span>
                  <span class="s2">? ((response = initializingHandler), response.deps++)</span>
                  <span class="s2">: (initializingHandler = {</span>
                      <span class="s2">parent: </span><span class="s4">null</span><span class="s2">,</span>
                      <span class="s2">chunk: </span><span class="s4">null</span><span class="s2">,</span>
                      <span class="s2">value: </span><span class="s4">null</span><span class="s2">,</span>
                      <span class="s2">reason: </span><span class="s4">null</span><span class="s2">,</span>
                      <span class="s2">deps: </span><span class="s5">1</span><span class="s2">,</span>
                      <span class="s2">errored: !</span><span class="s5">1</span>
                    <span class="s2">}),</span>
                <span class="s4">null</span>
              <span class="s2">);</span>
            <span class="s4">default</span><span class="s2">:</span>
              <span class="s4">return </span><span class="s2">(</span>
                <span class="s2">initializingHandler</span>
                  <span class="s2">? ((initializingHandler.errored = !</span><span class="s5">0</span><span class="s2">),</span>
                    <span class="s2">(initializingHandler.value = </span><span class="s4">null</span><span class="s2">),</span>
                    <span class="s2">(initializingHandler.reason = value.reason))</span>
                  <span class="s2">: (initializingHandler = {</span>
                      <span class="s2">parent: </span><span class="s4">null</span><span class="s2">,</span>
                      <span class="s2">chunk: </span><span class="s4">null</span><span class="s2">,</span>
                      <span class="s2">value: </span><span class="s4">null</span><span class="s2">,</span>
                      <span class="s2">reason: value.reason,</span>
                      <span class="s2">deps: </span><span class="s5">0</span><span class="s2">,</span>
                      <span class="s2">errored: !</span><span class="s5">0</span>
                    <span class="s2">}),</span>
                <span class="s4">null</span>
              <span class="s2">);</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s2">value = value[reference[id]];</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s2">map(response, value, parentObject, key);</span>
    <span class="s4">case </span><span class="s3">&quot;pending&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;blocked&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">waitForReference(id, parentObject, key, response, map, reference);</span>
    <span class="s4">case </span><span class="s3">&quot;halted&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">initializingHandler</span>
          <span class="s2">? ((response = initializingHandler), response.deps++)</span>
          <span class="s2">: (initializingHandler = {</span>
              <span class="s2">parent: </span><span class="s4">null</span><span class="s2">,</span>
              <span class="s2">chunk: </span><span class="s4">null</span><span class="s2">,</span>
              <span class="s2">value: </span><span class="s4">null</span><span class="s2">,</span>
              <span class="s2">reason: </span><span class="s4">null</span><span class="s2">,</span>
              <span class="s2">deps: </span><span class="s5">1</span><span class="s2">,</span>
              <span class="s2">errored: !</span><span class="s5">1</span>
            <span class="s2">}),</span>
        <span class="s4">null</span>
      <span class="s2">);</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">initializingHandler</span>
          <span class="s2">? ((initializingHandler.errored = !</span><span class="s5">0</span><span class="s2">),</span>
            <span class="s2">(initializingHandler.value = </span><span class="s4">null</span><span class="s2">),</span>
            <span class="s2">(initializingHandler.reason = id.reason))</span>
          <span class="s2">: (initializingHandler = {</span>
              <span class="s2">parent: </span><span class="s4">null</span><span class="s2">,</span>
              <span class="s2">chunk: </span><span class="s4">null</span><span class="s2">,</span>
              <span class="s2">value: </span><span class="s4">null</span><span class="s2">,</span>
              <span class="s2">reason: id.reason,</span>
              <span class="s2">deps: </span><span class="s5">0</span><span class="s2">,</span>
              <span class="s2">errored: !</span><span class="s5">0</span>
            <span class="s2">}),</span>
        <span class="s4">null</span>
      <span class="s2">);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createMap(response, model) {</span>
  <span class="s4">return new </span><span class="s2">Map(model);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createSet(response, model) {</span>
  <span class="s4">return new </span><span class="s2">Set(model);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createBlob(response, model) {</span>
  <span class="s4">return new </span><span class="s2">Blob(model.slice(</span><span class="s5">1</span><span class="s2">), { type: model[</span><span class="s5">0</span><span class="s2">] });</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createFormData(response, model) {</span>
  <span class="s2">response = </span><span class="s4">new </span><span class="s2">FormData();</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; model.length; i++)</span>
    <span class="s2">response.append(model[i][</span><span class="s5">0</span><span class="s2">], model[i][</span><span class="s5">1</span><span class="s2">]);</span>
  <span class="s4">return </span><span class="s2">response;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">extractIterator(response, model) {</span>
  <span class="s4">return </span><span class="s2">model[Symbol.iterator]();</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createModel(response, model) {</span>
  <span class="s4">return </span><span class="s2">model;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">parseModelString(response, parentObject, key, value) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;$&quot; </span><span class="s2">=== value[</span><span class="s5">0</span><span class="s2">]) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;$&quot; </span><span class="s2">=== value)</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s4">null </span><span class="s2">!== initializingHandler &amp;&amp;</span>
          <span class="s3">&quot;0&quot; </span><span class="s2">=== key &amp;&amp;</span>
          <span class="s2">(initializingHandler = {</span>
            <span class="s2">parent: initializingHandler,</span>
            <span class="s2">chunk: </span><span class="s4">null</span><span class="s2">,</span>
            <span class="s2">value: </span><span class="s4">null</span><span class="s2">,</span>
            <span class="s2">reason: </span><span class="s4">null</span><span class="s2">,</span>
            <span class="s2">deps: </span><span class="s5">0</span><span class="s2">,</span>
            <span class="s2">errored: !</span><span class="s5">1</span>
          <span class="s2">}),</span>
        <span class="s2">REACT_ELEMENT_TYPE</span>
      <span class="s2">);</span>
    <span class="s4">switch </span><span class="s2">(value[</span><span class="s5">1</span><span class="s2">]) {</span>
      <span class="s4">case </span><span class="s3">&quot;$&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">value.slice(</span><span class="s5">1</span><span class="s2">);</span>
      <span class="s4">case </span><span class="s3">&quot;L&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(parentObject = parseInt(value.slice(</span><span class="s5">2</span><span class="s2">), </span><span class="s5">16</span><span class="s2">)),</span>
          <span class="s2">(response = getChunk(response, parentObject)),</span>
          <span class="s2">createLazyChunkWrapper(response)</span>
        <span class="s2">);</span>
      <span class="s4">case </span><span class="s3">&quot;@&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(parentObject = parseInt(value.slice(</span><span class="s5">2</span><span class="s2">), </span><span class="s5">16</span><span class="s2">)),</span>
          <span class="s2">getChunk(response, parentObject)</span>
        <span class="s2">);</span>
      <span class="s4">case </span><span class="s3">&quot;S&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">Symbol.for(value.slice(</span><span class="s5">2</span><span class="s2">));</span>
      <span class="s4">case </span><span class="s3">&quot;F&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(value = value.slice(</span><span class="s5">2</span><span class="s2">)),</span>
          <span class="s2">getOutlinedModel(</span>
            <span class="s2">response,</span>
            <span class="s2">value,</span>
            <span class="s2">parentObject,</span>
            <span class="s2">key,</span>
            <span class="s2">loadServerReference</span>
          <span class="s2">)</span>
        <span class="s2">);</span>
      <span class="s4">case </span><span class="s3">&quot;T&quot;</span><span class="s2">:</span>
        <span class="s2">parentObject = </span><span class="s3">&quot;$&quot; </span><span class="s2">+ value.slice(</span><span class="s5">2</span><span class="s2">);</span>
        <span class="s2">response = response._tempRefs;</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">== response)</span>
          <span class="s4">throw </span><span class="s2">Error(</span>
            <span class="s3">&quot;Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply.&quot;</span>
          <span class="s2">);</span>
        <span class="s4">return </span><span class="s2">response.get(parentObject);</span>
      <span class="s4">case </span><span class="s3">&quot;Q&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(value = value.slice(</span><span class="s5">2</span><span class="s2">)),</span>
          <span class="s2">getOutlinedModel(response, value, parentObject, key, createMap)</span>
        <span class="s2">);</span>
      <span class="s4">case </span><span class="s3">&quot;W&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(value = value.slice(</span><span class="s5">2</span><span class="s2">)),</span>
          <span class="s2">getOutlinedModel(response, value, parentObject, key, createSet)</span>
        <span class="s2">);</span>
      <span class="s4">case </span><span class="s3">&quot;B&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(value = value.slice(</span><span class="s5">2</span><span class="s2">)),</span>
          <span class="s2">getOutlinedModel(response, value, parentObject, key, createBlob)</span>
        <span class="s2">);</span>
      <span class="s4">case </span><span class="s3">&quot;K&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(value = value.slice(</span><span class="s5">2</span><span class="s2">)),</span>
          <span class="s2">getOutlinedModel(response, value, parentObject, key, createFormData)</span>
        <span class="s2">);</span>
      <span class="s4">case </span><span class="s3">&quot;Z&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">resolveErrorProd();</span>
      <span class="s4">case </span><span class="s3">&quot;i&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(value = value.slice(</span><span class="s5">2</span><span class="s2">)),</span>
          <span class="s2">getOutlinedModel(response, value, parentObject, key, extractIterator)</span>
        <span class="s2">);</span>
      <span class="s4">case </span><span class="s3">&quot;I&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">Infinity;</span>
      <span class="s4">case </span><span class="s3">&quot;-&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s3">&quot;$-0&quot; </span><span class="s2">=== value ? -</span><span class="s5">0 </span><span class="s2">: -Infinity;</span>
      <span class="s4">case </span><span class="s3">&quot;N&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">NaN;</span>
      <span class="s4">case </span><span class="s3">&quot;u&quot;</span><span class="s2">:</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s3">&quot;D&quot;</span><span class="s2">:</span>
        <span class="s4">return new </span><span class="s2">Date(Date.parse(value.slice(</span><span class="s5">2</span><span class="s2">)));</span>
      <span class="s4">case </span><span class="s3">&quot;n&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">BigInt(value.slice(</span><span class="s5">2</span><span class="s2">));</span>
      <span class="s4">default</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(value = value.slice(</span><span class="s5">1</span><span class="s2">)),</span>
          <span class="s2">getOutlinedModel(response, value, parentObject, key, createModel)</span>
        <span class="s2">);</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">value;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">missingCall() {</span>
  <span class="s4">throw </span><span class="s2">Error(</span>
    <span class="s3">'Trying to call a function from &quot;use server&quot; but the callServer option was not implemented in your router runtime.'</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">ResponseInstance(</span>
  <span class="s2">bundlerConfig,</span>
  <span class="s2">serverReferenceConfig,</span>
  <span class="s2">moduleLoading,</span>
  <span class="s2">callServer,</span>
  <span class="s2">encodeFormAction,</span>
  <span class="s2">nonce,</span>
  <span class="s2">temporaryReferences</span>
<span class="s2">) {</span>
  <span class="s4">var </span><span class="s2">chunks = </span><span class="s4">new </span><span class="s2">Map();</span>
  <span class="s4">this</span><span class="s2">._bundlerConfig = bundlerConfig;</span>
  <span class="s4">this</span><span class="s2">._serverReferenceConfig = serverReferenceConfig;</span>
  <span class="s4">this</span><span class="s2">._moduleLoading = moduleLoading;</span>
  <span class="s4">this</span><span class="s2">._callServer = </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== callServer ? callServer : missingCall;</span>
  <span class="s4">this</span><span class="s2">._encodeFormAction = encodeFormAction;</span>
  <span class="s4">this</span><span class="s2">._nonce = nonce;</span>
  <span class="s4">this</span><span class="s2">._chunks = chunks;</span>
  <span class="s4">this</span><span class="s2">._stringDecoder = </span><span class="s4">new </span><span class="s2">util.TextDecoder();</span>
  <span class="s4">this</span><span class="s2">._fromJSON = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">._closed = !</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">._closedReason = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">._tempRefs = temporaryReferences;</span>
  <span class="s4">this</span><span class="s2">._fromJSON = createFromJSONCallback(</span><span class="s4">this</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createStreamState() {</span>
  <span class="s4">return </span><span class="s2">{ _rowState: </span><span class="s5">0</span><span class="s2">, _rowID: </span><span class="s5">0</span><span class="s2">, _rowTag: </span><span class="s5">0</span><span class="s2">, _rowLength: </span><span class="s5">0</span><span class="s2">, _buffer: [] };</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">resolveBuffer(response, id, buffer) {</span>
  <span class="s2">response = response._chunks;</span>
  <span class="s4">var </span><span class="s2">chunk = response.get(id);</span>
  <span class="s2">chunk &amp;&amp; </span><span class="s3">&quot;pending&quot; </span><span class="s2">!== chunk.status</span>
    <span class="s2">? chunk.reason.enqueueValue(buffer)</span>
    <span class="s2">: response.set(id, </span><span class="s4">new </span><span class="s2">ReactPromise(</span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">, buffer, </span><span class="s4">null</span><span class="s2">));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">resolveModule(response, id, model) {</span>
  <span class="s4">var </span><span class="s2">chunks = response._chunks,</span>
    <span class="s2">chunk = chunks.get(id);</span>
  <span class="s2">model = JSON.parse(model, response._fromJSON);</span>
  <span class="s4">var </span><span class="s2">clientReference = resolveClientReference(response._bundlerConfig, model);</span>
  <span class="s2">prepareDestinationWithChunks(</span>
    <span class="s2">response._moduleLoading,</span>
    <span class="s2">model[</span><span class="s5">1</span><span class="s2">],</span>
    <span class="s2">response._nonce</span>
  <span class="s2">);</span>
  <span class="s4">if </span><span class="s2">((model = preloadModule(clientReference))) {</span>
    <span class="s4">if </span><span class="s2">(chunk) {</span>
      <span class="s4">var </span><span class="s2">blockedChunk = chunk;</span>
      <span class="s2">blockedChunk.status = </span><span class="s3">&quot;blocked&quot;</span><span class="s2">;</span>
    <span class="s2">} </span><span class="s4">else</span>
      <span class="s2">(blockedChunk = </span><span class="s4">new </span><span class="s2">ReactPromise(</span><span class="s3">&quot;blocked&quot;</span><span class="s2">, </span><span class="s4">null</span><span class="s2">, </span><span class="s4">null</span><span class="s2">)),</span>
        <span class="s2">chunks.set(id, blockedChunk);</span>
    <span class="s2">model.then(</span>
      <span class="s4">function </span><span class="s2">() {</span>
        <span class="s4">return </span><span class="s2">resolveModuleChunk(response, blockedChunk, clientReference);</span>
      <span class="s2">},</span>
      <span class="s4">function </span><span class="s2">(error) {</span>
        <span class="s4">return </span><span class="s2">triggerErrorOnChunk(response, blockedChunk, error);</span>
      <span class="s2">}</span>
    <span class="s2">);</span>
  <span class="s2">} </span><span class="s4">else</span>
    <span class="s2">chunk</span>
      <span class="s2">? resolveModuleChunk(response, chunk, clientReference)</span>
      <span class="s2">: chunks.set(</span>
          <span class="s2">id,</span>
          <span class="s4">new </span><span class="s2">ReactPromise(</span><span class="s3">&quot;resolved_module&quot;</span><span class="s2">, clientReference, </span><span class="s4">null</span><span class="s2">)</span>
        <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">resolveStream(response, id, stream, controller) {</span>
  <span class="s4">var </span><span class="s2">chunks = response._chunks;</span>
  <span class="s2">response = chunks.get(id);</span>
  <span class="s2">response</span>
    <span class="s2">? </span><span class="s3">&quot;pending&quot; </span><span class="s2">=== response.status &amp;&amp;</span>
      <span class="s2">((id = response.value),</span>
      <span class="s2">(response.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">),</span>
      <span class="s2">(response.value = stream),</span>
      <span class="s2">(response.reason = controller),</span>
      <span class="s4">null </span><span class="s2">!== id &amp;&amp; wakeChunk(id, response.value))</span>
    <span class="s2">: chunks.set(id, </span><span class="s4">new </span><span class="s2">ReactPromise(</span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">, stream, controller));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">startReadableStream(response, id, type) {</span>
  <span class="s4">var </span><span class="s2">controller = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">type = </span><span class="s4">new </span><span class="s2">ReadableStream({</span>
    <span class="s2">type: type,</span>
    <span class="s2">start: </span><span class="s4">function </span><span class="s2">(c) {</span>
      <span class="s2">controller = c;</span>
    <span class="s2">}</span>
  <span class="s2">});</span>
  <span class="s4">var </span><span class="s2">previousBlockedChunk = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">resolveStream(response, id, type, {</span>
    <span class="s2">enqueueValue: </span><span class="s4">function </span><span class="s2">(value) {</span>
      <span class="s4">null </span><span class="s2">=== previousBlockedChunk</span>
        <span class="s2">? controller.enqueue(value)</span>
        <span class="s2">: previousBlockedChunk.then(</span><span class="s4">function </span><span class="s2">() {</span>
            <span class="s2">controller.enqueue(value);</span>
          <span class="s2">});</span>
    <span class="s2">},</span>
    <span class="s2">enqueueModel: </span><span class="s4">function </span><span class="s2">(json) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== previousBlockedChunk) {</span>
        <span class="s4">var </span><span class="s2">chunk = </span><span class="s4">new </span><span class="s2">ReactPromise(</span><span class="s3">&quot;resolved_model&quot;</span><span class="s2">, json, response);</span>
        <span class="s2">initializeModelChunk(chunk);</span>
        <span class="s3">&quot;fulfilled&quot; </span><span class="s2">=== chunk.status</span>
          <span class="s2">? controller.enqueue(chunk.value)</span>
          <span class="s2">: (chunk.then(</span>
              <span class="s4">function </span><span class="s2">(v) {</span>
                <span class="s4">return </span><span class="s2">controller.enqueue(v);</span>
              <span class="s2">},</span>
              <span class="s4">function </span><span class="s2">(e) {</span>
                <span class="s4">return </span><span class="s2">controller.error(e);</span>
              <span class="s2">}</span>
            <span class="s2">),</span>
            <span class="s2">(previousBlockedChunk = chunk));</span>
      <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
        <span class="s2">chunk = previousBlockedChunk;</span>
        <span class="s4">var </span><span class="s2">chunk$52 = </span><span class="s4">new </span><span class="s2">ReactPromise(</span><span class="s3">&quot;pending&quot;</span><span class="s2">, </span><span class="s4">null</span><span class="s2">, </span><span class="s4">null</span><span class="s2">);</span>
        <span class="s2">chunk$52.then(</span>
          <span class="s4">function </span><span class="s2">(v) {</span>
            <span class="s4">return </span><span class="s2">controller.enqueue(v);</span>
          <span class="s2">},</span>
          <span class="s4">function </span><span class="s2">(e) {</span>
            <span class="s4">return </span><span class="s2">controller.error(e);</span>
          <span class="s2">}</span>
        <span class="s2">);</span>
        <span class="s2">previousBlockedChunk = chunk$52;</span>
        <span class="s2">chunk.then(</span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s2">previousBlockedChunk === chunk$52 &amp;&amp; (previousBlockedChunk = </span><span class="s4">null</span><span class="s2">);</span>
          <span class="s2">resolveModelChunk(response, chunk$52, json);</span>
        <span class="s2">});</span>
      <span class="s2">}</span>
    <span class="s2">},</span>
    <span class="s2">close: </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== previousBlockedChunk) controller.close();</span>
      <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">blockedChunk = previousBlockedChunk;</span>
        <span class="s2">previousBlockedChunk = </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s2">blockedChunk.then(</span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">return </span><span class="s2">controller.close();</span>
        <span class="s2">});</span>
      <span class="s2">}</span>
    <span class="s2">},</span>
    <span class="s2">error: </span><span class="s4">function </span><span class="s2">(error) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== previousBlockedChunk) controller.error(error);</span>
      <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">blockedChunk = previousBlockedChunk;</span>
        <span class="s2">previousBlockedChunk = </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s2">blockedChunk.then(</span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">return </span><span class="s2">controller.error(error);</span>
        <span class="s2">});</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
  <span class="s2">});</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">asyncIterator() {</span>
  <span class="s4">return this</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createIterator(next) {</span>
  <span class="s2">next = { next: next };</span>
  <span class="s2">next[ASYNC_ITERATOR] = asyncIterator;</span>
  <span class="s4">return </span><span class="s2">next;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">startAsyncIterable(response, id, iterator) {</span>
  <span class="s4">var </span><span class="s2">buffer = [],</span>
    <span class="s2">closed = !</span><span class="s5">1</span><span class="s2">,</span>
    <span class="s2">nextWriteIndex = </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">iterable = {};</span>
  <span class="s2">iterable[ASYNC_ITERATOR] = </span><span class="s4">function </span><span class="s2">() {</span>
    <span class="s4">var </span><span class="s2">nextReadIndex = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s4">return </span><span class="s2">createIterator(</span><span class="s4">function </span><span class="s2">(arg) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== arg)</span>
        <span class="s4">throw </span><span class="s2">Error(</span>
          <span class="s3">&quot;Values cannot be passed to next() of AsyncIterables passed to Client Components.&quot;</span>
        <span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(nextReadIndex === buffer.length) {</span>
        <span class="s4">if </span><span class="s2">(closed)</span>
          <span class="s4">return new </span><span class="s2">ReactPromise(</span>
            <span class="s3">&quot;fulfilled&quot;</span><span class="s2">,</span>
            <span class="s2">{ done: !</span><span class="s5">0</span><span class="s2">, value: </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">},</span>
            <span class="s4">null</span>
          <span class="s2">);</span>
        <span class="s2">buffer[nextReadIndex] = </span><span class="s4">new </span><span class="s2">ReactPromise(</span><span class="s3">&quot;pending&quot;</span><span class="s2">, </span><span class="s4">null</span><span class="s2">, </span><span class="s4">null</span><span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s2">buffer[nextReadIndex++];</span>
    <span class="s2">});</span>
  <span class="s2">};</span>
  <span class="s2">resolveStream(</span>
    <span class="s2">response,</span>
    <span class="s2">id,</span>
    <span class="s2">iterator ? iterable[ASYNC_ITERATOR]() : iterable,</span>
    <span class="s2">{</span>
      <span class="s2">enqueueValue: </span><span class="s4">function </span><span class="s2">(value) {</span>
        <span class="s4">if </span><span class="s2">(nextWriteIndex === buffer.length)</span>
          <span class="s2">buffer[nextWriteIndex] = </span><span class="s4">new </span><span class="s2">ReactPromise(</span>
            <span class="s3">&quot;fulfilled&quot;</span><span class="s2">,</span>
            <span class="s2">{ done: !</span><span class="s5">1</span><span class="s2">, value: value },</span>
            <span class="s4">null</span>
          <span class="s2">);</span>
        <span class="s4">else </span><span class="s2">{</span>
          <span class="s4">var </span><span class="s2">chunk = buffer[nextWriteIndex],</span>
            <span class="s2">resolveListeners = chunk.value,</span>
            <span class="s2">rejectListeners = chunk.reason;</span>
          <span class="s2">chunk.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">;</span>
          <span class="s2">chunk.value = { done: !</span><span class="s5">1</span><span class="s2">, value: value };</span>
          <span class="s4">null </span><span class="s2">!== resolveListeners &amp;&amp;</span>
            <span class="s2">wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);</span>
        <span class="s2">}</span>
        <span class="s2">nextWriteIndex++;</span>
      <span class="s2">},</span>
      <span class="s2">enqueueModel: </span><span class="s4">function </span><span class="s2">(value) {</span>
        <span class="s2">nextWriteIndex === buffer.length</span>
          <span class="s2">? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(</span>
              <span class="s2">response,</span>
              <span class="s2">value,</span>
              <span class="s2">!</span><span class="s5">1</span>
            <span class="s2">))</span>
          <span class="s2">: resolveIteratorResultChunk(</span>
              <span class="s2">response,</span>
              <span class="s2">buffer[nextWriteIndex],</span>
              <span class="s2">value,</span>
              <span class="s2">!</span><span class="s5">1</span>
            <span class="s2">);</span>
        <span class="s2">nextWriteIndex++;</span>
      <span class="s2">},</span>
      <span class="s2">close: </span><span class="s4">function </span><span class="s2">(value) {</span>
        <span class="s2">closed = !</span><span class="s5">0</span><span class="s2">;</span>
        <span class="s2">nextWriteIndex === buffer.length</span>
          <span class="s2">? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(</span>
              <span class="s2">response,</span>
              <span class="s2">value,</span>
              <span class="s2">!</span><span class="s5">0</span>
            <span class="s2">))</span>
          <span class="s2">: resolveIteratorResultChunk(</span>
              <span class="s2">response,</span>
              <span class="s2">buffer[nextWriteIndex],</span>
              <span class="s2">value,</span>
              <span class="s2">!</span><span class="s5">0</span>
            <span class="s2">);</span>
        <span class="s4">for </span><span class="s2">(nextWriteIndex++; nextWriteIndex &lt; buffer.length; )</span>
          <span class="s2">resolveIteratorResultChunk(</span>
            <span class="s2">response,</span>
            <span class="s2">buffer[nextWriteIndex++],</span>
            <span class="s3">'&quot;$undefined&quot;'</span><span class="s2">,</span>
            <span class="s2">!</span><span class="s5">0</span>
          <span class="s2">);</span>
      <span class="s2">},</span>
      <span class="s2">error: </span><span class="s4">function </span><span class="s2">(error) {</span>
        <span class="s2">closed = !</span><span class="s5">0</span><span class="s2">;</span>
        <span class="s4">for </span><span class="s2">(</span>
          <span class="s2">nextWriteIndex === buffer.length &amp;&amp;</span>
          <span class="s2">(buffer[nextWriteIndex] = </span><span class="s4">new </span><span class="s2">ReactPromise(</span><span class="s3">&quot;pending&quot;</span><span class="s2">, </span><span class="s4">null</span><span class="s2">, </span><span class="s4">null</span><span class="s2">));</span>
          <span class="s2">nextWriteIndex &lt; buffer.length;</span>

        <span class="s2">)</span>
          <span class="s2">triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">resolveErrorProd() {</span>
  <span class="s4">var </span><span class="s2">error = Error(</span>
    <span class="s3">&quot;An error occurred in the Server Components render. The specific message is omitted in production builds to avoid leaking sensitive details. A digest property is included on this error instance which may provide additional details about the nature of the error.&quot;</span>
  <span class="s2">);</span>
  <span class="s2">error.stack = </span><span class="s3">&quot;Error: &quot; </span><span class="s2">+ error.message;</span>
  <span class="s4">return </span><span class="s2">error;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">mergeBuffer(buffer, lastChunk) {</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">l = buffer.length, byteLength = lastChunk.length, i = </span><span class="s5">0</span><span class="s2">; i &lt; l; i++)</span>
    <span class="s2">byteLength += buffer[i].byteLength;</span>
  <span class="s2">byteLength = </span><span class="s4">new </span><span class="s2">Uint8Array(byteLength);</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i$53 = (i = </span><span class="s5">0</span><span class="s2">); i$53 &lt; l; i$53++) {</span>
    <span class="s4">var </span><span class="s2">chunk = buffer[i$53];</span>
    <span class="s2">byteLength.set(chunk, i);</span>
    <span class="s2">i += chunk.byteLength;</span>
  <span class="s2">}</span>
  <span class="s2">byteLength.set(lastChunk, i);</span>
  <span class="s4">return </span><span class="s2">byteLength;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">resolveTypedArray(</span>
  <span class="s2">response,</span>
  <span class="s2">id,</span>
  <span class="s2">buffer,</span>
  <span class="s2">lastChunk,</span>
  <span class="s2">constructor,</span>
  <span class="s2">bytesPerElement</span>
<span class="s2">) {</span>
  <span class="s2">buffer =</span>
    <span class="s5">0 </span><span class="s2">=== buffer.length &amp;&amp; </span><span class="s5">0 </span><span class="s2">=== lastChunk.byteOffset % bytesPerElement</span>
      <span class="s2">? lastChunk</span>
      <span class="s2">: mergeBuffer(buffer, lastChunk);</span>
  <span class="s2">constructor = </span><span class="s4">new </span><span class="s2">constructor(</span>
    <span class="s2">buffer.buffer,</span>
    <span class="s2">buffer.byteOffset,</span>
    <span class="s2">buffer.byteLength / bytesPerElement</span>
  <span class="s2">);</span>
  <span class="s2">resolveBuffer(response, id, constructor);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">processFullBinaryRow(response, id, tag, buffer, chunk) {</span>
  <span class="s4">switch </span><span class="s2">(tag) {</span>
    <span class="s4">case </span><span class="s5">65</span><span class="s2">:</span>
      <span class="s2">resolveBuffer(response, id, mergeBuffer(buffer, chunk).buffer);</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">79</span><span class="s2">:</span>
      <span class="s2">resolveTypedArray(response, id, buffer, chunk, Int8Array, </span><span class="s5">1</span><span class="s2">);</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">111</span><span class="s2">:</span>
      <span class="s2">resolveBuffer(</span>
        <span class="s2">response,</span>
        <span class="s2">id,</span>
        <span class="s5">0 </span><span class="s2">=== buffer.length ? chunk : mergeBuffer(buffer, chunk)</span>
      <span class="s2">);</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">85</span><span class="s2">:</span>
      <span class="s2">resolveTypedArray(response, id, buffer, chunk, Uint8ClampedArray, </span><span class="s5">1</span><span class="s2">);</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">83</span><span class="s2">:</span>
      <span class="s2">resolveTypedArray(response, id, buffer, chunk, Int16Array, </span><span class="s5">2</span><span class="s2">);</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">115</span><span class="s2">:</span>
      <span class="s2">resolveTypedArray(response, id, buffer, chunk, Uint16Array, </span><span class="s5">2</span><span class="s2">);</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">76</span><span class="s2">:</span>
      <span class="s2">resolveTypedArray(response, id, buffer, chunk, Int32Array, </span><span class="s5">4</span><span class="s2">);</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">108</span><span class="s2">:</span>
      <span class="s2">resolveTypedArray(response, id, buffer, chunk, Uint32Array, </span><span class="s5">4</span><span class="s2">);</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">71</span><span class="s2">:</span>
      <span class="s2">resolveTypedArray(response, id, buffer, chunk, Float32Array, </span><span class="s5">4</span><span class="s2">);</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">103</span><span class="s2">:</span>
      <span class="s2">resolveTypedArray(response, id, buffer, chunk, Float64Array, </span><span class="s5">8</span><span class="s2">);</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">77</span><span class="s2">:</span>
      <span class="s2">resolveTypedArray(response, id, buffer, chunk, BigInt64Array, </span><span class="s5">8</span><span class="s2">);</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">109</span><span class="s2">:</span>
      <span class="s2">resolveTypedArray(response, id, buffer, chunk, BigUint64Array, </span><span class="s5">8</span><span class="s2">);</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">86</span><span class="s2">:</span>
      <span class="s2">resolveTypedArray(response, id, buffer, chunk, DataView, </span><span class="s5">1</span><span class="s2">);</span>
      <span class="s4">return</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s4">for </span><span class="s2">(</span>
    <span class="s4">var </span><span class="s2">stringDecoder = response._stringDecoder, row = </span><span class="s3">&quot;&quot;</span><span class="s2">, i = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">i &lt; buffer.length;</span>
    <span class="s2">i++</span>
  <span class="s2">)</span>
    <span class="s2">row += stringDecoder.decode(buffer[i], decoderOptions);</span>
  <span class="s2">row += stringDecoder.decode(chunk);</span>
  <span class="s2">processFullStringRow(response, id, tag, row);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">processFullStringRow(response, id, tag, row) {</span>
  <span class="s4">switch </span><span class="s2">(tag) {</span>
    <span class="s4">case </span><span class="s5">73</span><span class="s2">:</span>
      <span class="s2">resolveModule(response, id, row);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">72</span><span class="s2">:</span>
      <span class="s2">id = row[</span><span class="s5">0</span><span class="s2">];</span>
      <span class="s2">row = row.slice(</span><span class="s5">1</span><span class="s2">);</span>
      <span class="s2">response = JSON.parse(row, response._fromJSON);</span>
      <span class="s2">row = ReactDOMSharedInternals.d;</span>
      <span class="s4">switch </span><span class="s2">(id) {</span>
        <span class="s4">case </span><span class="s3">&quot;D&quot;</span><span class="s2">:</span>
          <span class="s2">row.D(response);</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;C&quot;</span><span class="s2">:</span>
          <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">response</span>
            <span class="s2">? row.C(response)</span>
            <span class="s2">: row.C(response[</span><span class="s5">0</span><span class="s2">], response[</span><span class="s5">1</span><span class="s2">]);</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;L&quot;</span><span class="s2">:</span>
          <span class="s2">id = response[</span><span class="s5">0</span><span class="s2">];</span>
          <span class="s2">tag = response[</span><span class="s5">1</span><span class="s2">];</span>
          <span class="s5">3 </span><span class="s2">=== response.length ? row.L(id, tag, response[</span><span class="s5">2</span><span class="s2">]) : row.L(id, tag);</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;m&quot;</span><span class="s2">:</span>
          <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">response</span>
            <span class="s2">? row.m(response)</span>
            <span class="s2">: row.m(response[</span><span class="s5">0</span><span class="s2">], response[</span><span class="s5">1</span><span class="s2">]);</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;X&quot;</span><span class="s2">:</span>
          <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">response</span>
            <span class="s2">? row.X(response)</span>
            <span class="s2">: row.X(response[</span><span class="s5">0</span><span class="s2">], response[</span><span class="s5">1</span><span class="s2">]);</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;S&quot;</span><span class="s2">:</span>
          <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">response</span>
            <span class="s2">? row.S(response)</span>
            <span class="s2">: row.S(</span>
                <span class="s2">response[</span><span class="s5">0</span><span class="s2">],</span>
                <span class="s5">0 </span><span class="s2">=== response[</span><span class="s5">1</span><span class="s2">] ? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">: response[</span><span class="s5">1</span><span class="s2">],</span>
                <span class="s5">3 </span><span class="s2">=== response.length ? response[</span><span class="s5">2</span><span class="s2">] : </span><span class="s4">void </span><span class="s5">0</span>
              <span class="s2">);</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;M&quot;</span><span class="s2">:</span>
          <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">response</span>
            <span class="s2">? row.M(response)</span>
            <span class="s2">: row.M(response[</span><span class="s5">0</span><span class="s2">], response[</span><span class="s5">1</span><span class="s2">]);</span>
      <span class="s2">}</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">69</span><span class="s2">:</span>
      <span class="s2">tag = response._chunks;</span>
      <span class="s4">var </span><span class="s2">chunk = tag.get(id);</span>
      <span class="s2">row = JSON.parse(row);</span>
      <span class="s4">var </span><span class="s2">error = resolveErrorProd();</span>
      <span class="s2">error.digest = row.digest;</span>
      <span class="s2">chunk</span>
        <span class="s2">? triggerErrorOnChunk(response, chunk, error)</span>
        <span class="s2">: tag.set(id, createErrorChunk(response, error));</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">84</span><span class="s2">:</span>
      <span class="s2">response = response._chunks;</span>
      <span class="s2">(tag = response.get(id)) &amp;&amp; </span><span class="s3">&quot;pending&quot; </span><span class="s2">!== tag.status</span>
        <span class="s2">? tag.reason.enqueueValue(row)</span>
        <span class="s2">: response.set(id, </span><span class="s4">new </span><span class="s2">ReactPromise(</span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">, row, </span><span class="s4">null</span><span class="s2">));</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">78</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">68</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">74</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s5">87</span><span class="s2">:</span>
      <span class="s4">throw </span><span class="s2">Error(</span>
        <span class="s3">&quot;Failed to read a RSC payload created by a development version of React on the server while using a production version on the client. Always use matching versions on the server and the client.&quot;</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s5">82</span><span class="s2">:</span>
      <span class="s2">startReadableStream(response, id, </span><span class="s4">void </span><span class="s5">0</span><span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">114</span><span class="s2">:</span>
      <span class="s2">startReadableStream(response, id, </span><span class="s3">&quot;bytes&quot;</span><span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">88</span><span class="s2">:</span>
      <span class="s2">startAsyncIterable(response, id, !</span><span class="s5">1</span><span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">120</span><span class="s2">:</span>
      <span class="s2">startAsyncIterable(response, id, !</span><span class="s5">0</span><span class="s2">);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">67</span><span class="s2">:</span>
      <span class="s2">(response = response._chunks.get(id)) &amp;&amp;</span>
        <span class="s3">&quot;fulfilled&quot; </span><span class="s2">=== response.status &amp;&amp;</span>
        <span class="s2">response.reason.close(</span><span class="s3">&quot;&quot; </span><span class="s2">=== row ? </span><span class="s3">'&quot;$undefined&quot;' </span><span class="s2">: row);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s5">80</span><span class="s2">:</span>
      <span class="s2">row = Error(</span>
        <span class="s3">&quot;A Server Component was postponed. The reason is omitted in production builds to avoid leaking sensitive details.&quot;</span>
      <span class="s2">);</span>
      <span class="s2">row.$$typeof = REACT_POSTPONE_TYPE;</span>
      <span class="s2">row.stack = </span><span class="s3">&quot;Error: &quot; </span><span class="s2">+ row.message;</span>
      <span class="s2">tag = response._chunks;</span>
      <span class="s2">(chunk = tag.get(id))</span>
        <span class="s2">? triggerErrorOnChunk(response, chunk, row)</span>
        <span class="s2">: tag.set(id, createErrorChunk(response, row));</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s2">(tag = response._chunks),</span>
        <span class="s2">(chunk = tag.get(id))</span>
          <span class="s2">? resolveModelChunk(response, chunk, row)</span>
          <span class="s2">: tag.set(id, </span><span class="s4">new </span><span class="s2">ReactPromise(</span><span class="s3">&quot;resolved_model&quot;</span><span class="s2">, row, response));</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">processBinaryChunk(weakResponse, streamState, chunk) {</span>
  <span class="s4">for </span><span class="s2">(</span>
    <span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">rowState = streamState._rowState,</span>
      <span class="s2">rowID = streamState._rowID,</span>
      <span class="s2">rowTag = streamState._rowTag,</span>
      <span class="s2">rowLength = streamState._rowLength,</span>
      <span class="s2">buffer = streamState._buffer,</span>
      <span class="s2">chunkLength = chunk.length;</span>
    <span class="s2">i &lt; chunkLength;</span>

  <span class="s2">) {</span>
    <span class="s4">var </span><span class="s2">lastIdx = -</span><span class="s5">1</span><span class="s2">;</span>
    <span class="s4">switch </span><span class="s2">(rowState) {</span>
      <span class="s4">case </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s2">lastIdx = chunk[i++];</span>
        <span class="s5">58 </span><span class="s2">=== lastIdx</span>
          <span class="s2">? (rowState = </span><span class="s5">1</span><span class="s2">)</span>
          <span class="s2">: (rowID =</span>
              <span class="s2">(rowID &lt;&lt; </span><span class="s5">4</span><span class="s2">) | (</span><span class="s5">96 </span><span class="s2">&lt; lastIdx ? lastIdx - </span><span class="s5">87 </span><span class="s2">: lastIdx - </span><span class="s5">48</span><span class="s2">));</span>
        <span class="s4">continue</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s2">rowState = chunk[i];</span>
        <span class="s5">84 </span><span class="s2">=== rowState ||</span>
        <span class="s5">65 </span><span class="s2">=== rowState ||</span>
        <span class="s5">79 </span><span class="s2">=== rowState ||</span>
        <span class="s5">111 </span><span class="s2">=== rowState ||</span>
        <span class="s5">85 </span><span class="s2">=== rowState ||</span>
        <span class="s5">83 </span><span class="s2">=== rowState ||</span>
        <span class="s5">115 </span><span class="s2">=== rowState ||</span>
        <span class="s5">76 </span><span class="s2">=== rowState ||</span>
        <span class="s5">108 </span><span class="s2">=== rowState ||</span>
        <span class="s5">71 </span><span class="s2">=== rowState ||</span>
        <span class="s5">103 </span><span class="s2">=== rowState ||</span>
        <span class="s5">77 </span><span class="s2">=== rowState ||</span>
        <span class="s5">109 </span><span class="s2">=== rowState ||</span>
        <span class="s5">86 </span><span class="s2">=== rowState</span>
          <span class="s2">? ((rowTag = rowState), (rowState = </span><span class="s5">2</span><span class="s2">), i++)</span>
          <span class="s2">: (</span><span class="s5">64 </span><span class="s2">&lt; rowState &amp;&amp; </span><span class="s5">91 </span><span class="s2">&gt; rowState) ||</span>
              <span class="s5">35 </span><span class="s2">=== rowState ||</span>
              <span class="s5">114 </span><span class="s2">=== rowState ||</span>
              <span class="s5">120 </span><span class="s2">=== rowState</span>
            <span class="s2">? ((rowTag = rowState), (rowState = </span><span class="s5">3</span><span class="s2">), i++)</span>
            <span class="s2">: ((rowTag = </span><span class="s5">0</span><span class="s2">), (rowState = </span><span class="s5">3</span><span class="s2">));</span>
        <span class="s4">continue</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s5">2</span><span class="s2">:</span>
        <span class="s2">lastIdx = chunk[i++];</span>
        <span class="s5">44 </span><span class="s2">=== lastIdx</span>
          <span class="s2">? (rowState = </span><span class="s5">4</span><span class="s2">)</span>
          <span class="s2">: (rowLength =</span>
              <span class="s2">(rowLength &lt;&lt; </span><span class="s5">4</span><span class="s2">) | (</span><span class="s5">96 </span><span class="s2">&lt; lastIdx ? lastIdx - </span><span class="s5">87 </span><span class="s2">: lastIdx - </span><span class="s5">48</span><span class="s2">));</span>
        <span class="s4">continue</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
        <span class="s2">lastIdx = chunk.indexOf(</span><span class="s5">10</span><span class="s2">, i);</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s5">4</span><span class="s2">:</span>
        <span class="s2">(lastIdx = i + rowLength), lastIdx &gt; chunk.length &amp;&amp; (lastIdx = -</span><span class="s5">1</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">var </span><span class="s2">offset = chunk.byteOffset + i;</span>
    <span class="s4">if </span><span class="s2">(-</span><span class="s5">1 </span><span class="s2">&lt; lastIdx)</span>
      <span class="s2">(rowLength = </span><span class="s4">new </span><span class="s2">Uint8Array(chunk.buffer, offset, lastIdx - i)),</span>
        <span class="s2">processFullBinaryRow(weakResponse, rowID, rowTag, buffer, rowLength),</span>
        <span class="s2">(i = lastIdx),</span>
        <span class="s5">3 </span><span class="s2">=== rowState &amp;&amp; i++,</span>
        <span class="s2">(rowLength = rowID = rowTag = rowState = </span><span class="s5">0</span><span class="s2">),</span>
        <span class="s2">(buffer.length = </span><span class="s5">0</span><span class="s2">);</span>
    <span class="s4">else </span><span class="s2">{</span>
      <span class="s2">weakResponse = </span><span class="s4">new </span><span class="s2">Uint8Array(chunk.buffer, offset, chunk.byteLength - i);</span>
      <span class="s2">buffer.push(weakResponse);</span>
      <span class="s2">rowLength -= weakResponse.byteLength;</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s2">streamState._rowState = rowState;</span>
  <span class="s2">streamState._rowID = rowID;</span>
  <span class="s2">streamState._rowTag = rowTag;</span>
  <span class="s2">streamState._rowLength = rowLength;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createFromJSONCallback(response) {</span>
  <span class="s4">return function </span><span class="s2">(key, value) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value)</span>
      <span class="s4">return </span><span class="s2">parseModelString(response, </span><span class="s4">this</span><span class="s2">, key, value);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value &amp;&amp; </span><span class="s4">null </span><span class="s2">!== value) {</span>
      <span class="s4">if </span><span class="s2">(value[</span><span class="s5">0</span><span class="s2">] === REACT_ELEMENT_TYPE) {</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">((key = {</span>
            <span class="s2">$$typeof: REACT_ELEMENT_TYPE,</span>
            <span class="s2">type: value[</span><span class="s5">1</span><span class="s2">],</span>
            <span class="s2">key: value[</span><span class="s5">2</span><span class="s2">],</span>
            <span class="s2">ref: </span><span class="s4">null</span><span class="s2">,</span>
            <span class="s2">props: value[</span><span class="s5">3</span><span class="s2">]</span>
          <span class="s2">}),</span>
          <span class="s4">null </span><span class="s2">!== initializingHandler)</span>
        <span class="s2">)</span>
          <span class="s4">if </span><span class="s2">(</span>
            <span class="s2">((value = initializingHandler),</span>
            <span class="s2">(initializingHandler = value.parent),</span>
            <span class="s2">value.errored)</span>
          <span class="s2">)</span>
            <span class="s2">(key = createErrorChunk(response, value.reason)),</span>
              <span class="s2">(key = createLazyChunkWrapper(key));</span>
          <span class="s4">else if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">&lt; value.deps) {</span>
            <span class="s4">var </span><span class="s2">blockedChunk = </span><span class="s4">new </span><span class="s2">ReactPromise(</span><span class="s3">&quot;blocked&quot;</span><span class="s2">, </span><span class="s4">null</span><span class="s2">, </span><span class="s4">null</span><span class="s2">);</span>
            <span class="s2">value.value = key;</span>
            <span class="s2">value.chunk = blockedChunk;</span>
            <span class="s2">key = createLazyChunkWrapper(blockedChunk);</span>
          <span class="s2">}</span>
      <span class="s2">} </span><span class="s4">else </span><span class="s2">key = value;</span>
      <span class="s4">return </span><span class="s2">key;</span>
    <span class="s2">}</span>
    <span class="s4">return </span><span class="s2">value;</span>
  <span class="s2">};</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">close(weakResponse) {</span>
  <span class="s2">reportGlobalError(weakResponse, Error(</span><span class="s3">&quot;Connection closed.&quot;</span><span class="s2">));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">noServerCall$1() {</span>
  <span class="s4">throw </span><span class="s2">Error(</span>
    <span class="s3">&quot;Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead.&quot;</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createResponseFromOptions(options) {</span>
  <span class="s4">return new </span><span class="s2">ResponseInstance(</span>
    <span class="s2">options.serverConsumerManifest.moduleMap,</span>
    <span class="s2">options.serverConsumerManifest.serverModuleMap,</span>
    <span class="s2">options.serverConsumerManifest.moduleLoading,</span>
    <span class="s2">noServerCall$1,</span>
    <span class="s2">options.encodeFormAction,</span>
    <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options.nonce ? options.nonce : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">options &amp;&amp; options.temporaryReferences</span>
      <span class="s2">? options.temporaryReferences</span>
      <span class="s2">: </span><span class="s4">void </span><span class="s5">0</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">startReadingFromStream(response, stream) {</span>
  <span class="s4">function </span><span class="s2">progress(_ref) {</span>
    <span class="s4">var </span><span class="s2">value = _ref.value;</span>
    <span class="s4">if </span><span class="s2">(_ref.done) close(response);</span>
    <span class="s4">else</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">processBinaryChunk(response, streamState, value),</span>
        <span class="s2">reader.read().then(progress).catch(error)</span>
      <span class="s2">);</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">error(e) {</span>
    <span class="s2">reportGlobalError(response, e);</span>
  <span class="s2">}</span>
  <span class="s4">var </span><span class="s2">streamState = createStreamState(),</span>
    <span class="s2">reader = stream.getReader();</span>
  <span class="s2">reader.read().then(progress).catch(error);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">noServerCall() {</span>
  <span class="s4">throw </span><span class="s2">Error(</span>
    <span class="s3">&quot;Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead.&quot;</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s2">exports.createFromFetch = </span><span class="s4">function </span><span class="s2">(promiseForResponse, options) {</span>
  <span class="s4">var </span><span class="s2">response = createResponseFromOptions(options);</span>
  <span class="s2">promiseForResponse.then(</span>
    <span class="s4">function </span><span class="s2">(r) {</span>
      <span class="s2">startReadingFromStream(response, r.body);</span>
    <span class="s2">},</span>
    <span class="s4">function </span><span class="s2">(e) {</span>
      <span class="s2">reportGlobalError(response, e);</span>
    <span class="s2">}</span>
  <span class="s2">);</span>
  <span class="s4">return </span><span class="s2">getChunk(response, </span><span class="s5">0</span><span class="s2">);</span>
<span class="s2">};</span>
<span class="s2">exports.createFromNodeStream = </span><span class="s4">function </span><span class="s2">(</span>
  <span class="s2">stream,</span>
  <span class="s2">serverConsumerManifest,</span>
  <span class="s2">options</span>
<span class="s2">) {</span>
  <span class="s4">var </span><span class="s2">response = </span><span class="s4">new </span><span class="s2">ResponseInstance(</span>
      <span class="s2">serverConsumerManifest.moduleMap,</span>
      <span class="s2">serverConsumerManifest.serverModuleMap,</span>
      <span class="s2">serverConsumerManifest.moduleLoading,</span>
      <span class="s2">noServerCall,</span>
      <span class="s2">options ? options.encodeFormAction : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">options &amp;&amp; </span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options.nonce ? options.nonce : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s4">void </span><span class="s5">0</span>
    <span class="s2">),</span>
    <span class="s2">streamState = createStreamState();</span>
  <span class="s2">stream.on(</span><span class="s3">&quot;data&quot;</span><span class="s2">, </span><span class="s4">function </span><span class="s2">(chunk) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">chunk) {</span>
      <span class="s4">for </span><span class="s2">(</span>
        <span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">,</span>
          <span class="s2">rowState = streamState._rowState,</span>
          <span class="s2">rowID = streamState._rowID,</span>
          <span class="s2">rowTag = streamState._rowTag,</span>
          <span class="s2">rowLength = streamState._rowLength,</span>
          <span class="s2">buffer = streamState._buffer,</span>
          <span class="s2">chunkLength = chunk.length;</span>
        <span class="s2">i &lt; chunkLength;</span>

      <span class="s2">) {</span>
        <span class="s4">var </span><span class="s2">lastIdx = -</span><span class="s5">1</span><span class="s2">;</span>
        <span class="s4">switch </span><span class="s2">(rowState) {</span>
          <span class="s4">case </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s2">lastIdx = chunk.charCodeAt(i++);</span>
            <span class="s5">58 </span><span class="s2">=== lastIdx</span>
              <span class="s2">? (rowState = </span><span class="s5">1</span><span class="s2">)</span>
              <span class="s2">: (rowID =</span>
                  <span class="s2">(rowID &lt;&lt; </span><span class="s5">4</span><span class="s2">) | (</span><span class="s5">96 </span><span class="s2">&lt; lastIdx ? lastIdx - </span><span class="s5">87 </span><span class="s2">: lastIdx - </span><span class="s5">48</span><span class="s2">));</span>
            <span class="s4">continue</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s2">rowState = chunk.charCodeAt(i);</span>
            <span class="s5">84 </span><span class="s2">=== rowState ||</span>
            <span class="s5">65 </span><span class="s2">=== rowState ||</span>
            <span class="s5">79 </span><span class="s2">=== rowState ||</span>
            <span class="s5">111 </span><span class="s2">=== rowState ||</span>
            <span class="s5">85 </span><span class="s2">=== rowState ||</span>
            <span class="s5">83 </span><span class="s2">=== rowState ||</span>
            <span class="s5">115 </span><span class="s2">=== rowState ||</span>
            <span class="s5">76 </span><span class="s2">=== rowState ||</span>
            <span class="s5">108 </span><span class="s2">=== rowState ||</span>
            <span class="s5">71 </span><span class="s2">=== rowState ||</span>
            <span class="s5">103 </span><span class="s2">=== rowState ||</span>
            <span class="s5">77 </span><span class="s2">=== rowState ||</span>
            <span class="s5">109 </span><span class="s2">=== rowState ||</span>
            <span class="s5">86 </span><span class="s2">=== rowState</span>
              <span class="s2">? ((rowTag = rowState), (rowState = </span><span class="s5">2</span><span class="s2">), i++)</span>
              <span class="s2">: (</span><span class="s5">64 </span><span class="s2">&lt; rowState &amp;&amp; </span><span class="s5">91 </span><span class="s2">&gt; rowState) ||</span>
                  <span class="s5">114 </span><span class="s2">=== rowState ||</span>
                  <span class="s5">120 </span><span class="s2">=== rowState</span>
                <span class="s2">? ((rowTag = rowState), (rowState = </span><span class="s5">3</span><span class="s2">), i++)</span>
                <span class="s2">: ((rowTag = </span><span class="s5">0</span><span class="s2">), (rowState = </span><span class="s5">3</span><span class="s2">));</span>
            <span class="s4">continue</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s2">lastIdx = chunk.charCodeAt(i++);</span>
            <span class="s5">44 </span><span class="s2">=== lastIdx</span>
              <span class="s2">? (rowState = </span><span class="s5">4</span><span class="s2">)</span>
              <span class="s2">: (rowLength =</span>
                  <span class="s2">(rowLength &lt;&lt; </span><span class="s5">4</span><span class="s2">) |</span>
                  <span class="s2">(</span><span class="s5">96 </span><span class="s2">&lt; lastIdx ? lastIdx - </span><span class="s5">87 </span><span class="s2">: lastIdx - </span><span class="s5">48</span><span class="s2">));</span>
            <span class="s4">continue</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
            <span class="s2">lastIdx = chunk.indexOf(</span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">, i);</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s5">4</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s5">84 </span><span class="s2">!== rowTag)</span>
              <span class="s4">throw </span><span class="s2">Error(</span>
                <span class="s3">&quot;Binary RSC chunks cannot be encoded as strings. This is a bug in the wiring of the React streams.&quot;</span>
              <span class="s2">);</span>
            <span class="s4">if </span><span class="s2">(rowLength &lt; chunk.length || chunk.length &gt; </span><span class="s5">3 </span><span class="s2">* rowLength)</span>
              <span class="s4">throw </span><span class="s2">Error(</span>
                <span class="s3">&quot;String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.&quot;</span>
              <span class="s2">);</span>
            <span class="s2">lastIdx = chunk.length;</span>
        <span class="s2">}</span>
        <span class="s4">if </span><span class="s2">(-</span><span class="s5">1 </span><span class="s2">&lt; lastIdx) {</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">&lt; buffer.length)</span>
            <span class="s4">throw </span><span class="s2">Error(</span>
              <span class="s3">&quot;String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.&quot;</span>
            <span class="s2">);</span>
          <span class="s2">i = chunk.slice(i, lastIdx);</span>
          <span class="s2">processFullStringRow(response, rowID, rowTag, i);</span>
          <span class="s2">i = lastIdx;</span>
          <span class="s5">3 </span><span class="s2">=== rowState &amp;&amp; i++;</span>
          <span class="s2">rowLength = rowID = rowTag = rowState = </span><span class="s5">0</span><span class="s2">;</span>
          <span class="s2">buffer.length = </span><span class="s5">0</span><span class="s2">;</span>
        <span class="s2">} </span><span class="s4">else if </span><span class="s2">(chunk.length !== i)</span>
          <span class="s4">throw </span><span class="s2">Error(</span>
            <span class="s3">&quot;String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.&quot;</span>
          <span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s2">streamState._rowState = rowState;</span>
      <span class="s2">streamState._rowID = rowID;</span>
      <span class="s2">streamState._rowTag = rowTag;</span>
      <span class="s2">streamState._rowLength = rowLength;</span>
    <span class="s2">} </span><span class="s4">else </span><span class="s2">processBinaryChunk(response, streamState, chunk);</span>
  <span class="s2">});</span>
  <span class="s2">stream.on(</span><span class="s3">&quot;error&quot;</span><span class="s2">, </span><span class="s4">function </span><span class="s2">(error) {</span>
    <span class="s2">reportGlobalError(response, error);</span>
  <span class="s2">});</span>
  <span class="s2">stream.on(</span><span class="s3">&quot;end&quot;</span><span class="s2">, </span><span class="s4">function </span><span class="s2">() {</span>
    <span class="s4">return </span><span class="s2">close(response);</span>
  <span class="s2">});</span>
  <span class="s4">return </span><span class="s2">getChunk(response, </span><span class="s5">0</span><span class="s2">);</span>
<span class="s2">};</span>
<span class="s2">exports.createFromReadableStream = </span><span class="s4">function </span><span class="s2">(stream, options) {</span>
  <span class="s2">options = createResponseFromOptions(options);</span>
  <span class="s2">startReadingFromStream(options, stream);</span>
  <span class="s4">return </span><span class="s2">getChunk(options, </span><span class="s5">0</span><span class="s2">);</span>
<span class="s2">};</span>
<span class="s2">exports.createServerReference = </span><span class="s4">function </span><span class="s2">(id) {</span>
  <span class="s4">return </span><span class="s2">createServerReference$1(id, noServerCall$1);</span>
<span class="s2">};</span>
<span class="s2">exports.createTemporaryReferenceSet = </span><span class="s4">function </span><span class="s2">() {</span>
  <span class="s4">return new </span><span class="s2">Map();</span>
<span class="s2">};</span>
<span class="s2">exports.encodeReply = </span><span class="s4">function </span><span class="s2">(value, options) {</span>
  <span class="s4">return new </span><span class="s2">Promise(</span><span class="s4">function </span><span class="s2">(resolve, reject) {</span>
    <span class="s4">var </span><span class="s2">abort = processReply(</span>
      <span class="s2">value,</span>
      <span class="s3">&quot;&quot;</span><span class="s2">,</span>
      <span class="s2">options &amp;&amp; options.temporaryReferences</span>
        <span class="s2">? options.temporaryReferences</span>
        <span class="s2">: </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">resolve,</span>
      <span class="s2">reject</span>
    <span class="s2">);</span>
    <span class="s4">if </span><span class="s2">(options &amp;&amp; options.signal) {</span>
      <span class="s4">var </span><span class="s2">signal = options.signal;</span>
      <span class="s4">if </span><span class="s2">(signal.aborted) abort(signal.reason);</span>
      <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">listener = </span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s2">abort(signal.reason);</span>
          <span class="s2">signal.removeEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, listener);</span>
        <span class="s2">};</span>
        <span class="s2">signal.addEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, listener);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
  <span class="s2">});</span>
<span class="s2">};</span>
<span class="s2">exports.registerServerReference = </span><span class="s4">function </span><span class="s2">(reference, id, encodeFormAction) {</span>
  <span class="s2">registerBoundServerReference(reference, id, </span><span class="s4">null</span><span class="s2">, encodeFormAction);</span>
  <span class="s4">return </span><span class="s2">reference;</span>
<span class="s2">};</span>
</pre>
</body>
</html>