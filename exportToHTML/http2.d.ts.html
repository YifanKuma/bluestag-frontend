<html>
<head>
<title>http2.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
http2.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* The `node:http2` module provides an implementation of the [HTTP/2](https://tools.ietf.org/html/rfc7540) protocol.</span>
 <span class="s0">* It can be accessed using:</span>
 <span class="s0">*</span>
 <span class="s0">* ```js</span>
 <span class="s0">* import http2 from 'node:http2';</span>
 <span class="s0">* ```</span>
 <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[source](https://github.com/nodejs/node/blob/v20.13.1/lib/http2.js)</span>
 <span class="s0">*/</span>
<span class="s2">declare module </span><span class="s3">&quot;http2&quot; </span><span class="s2">{</span>
    <span class="s4">import </span><span class="s2">EventEmitter = require(</span><span class="s3">&quot;node:events&quot;</span><span class="s2">);</span>
    <span class="s4">import </span><span class="s2">* as fs from </span><span class="s3">&quot;node:fs&quot;</span><span class="s2">;</span>
    <span class="s4">import </span><span class="s2">* as net from </span><span class="s3">&quot;node:net&quot;</span><span class="s2">;</span>
    <span class="s4">import </span><span class="s2">* as stream from </span><span class="s3">&quot;node:stream&quot;</span><span class="s2">;</span>
    <span class="s4">import </span><span class="s2">* as tls from </span><span class="s3">&quot;node:tls&quot;</span><span class="s2">;</span>
    <span class="s4">import </span><span class="s2">* as url from </span><span class="s3">&quot;node:url&quot;</span><span class="s2">;</span>
    <span class="s4">import </span><span class="s2">{</span>
        <span class="s2">IncomingHttpHeaders as Http1IncomingHttpHeaders,</span>
        <span class="s2">IncomingMessage,</span>
        <span class="s2">OutgoingHttpHeaders,</span>
        <span class="s2">ServerResponse,</span>
    <span class="s2">} from </span><span class="s3">&quot;node:http&quot;</span><span class="s2">;</span>
    <span class="s4">export </span><span class="s2">{ OutgoingHttpHeaders } from </span><span class="s3">&quot;node:http&quot;</span><span class="s2">;</span>
    <span class="s4">export interface </span><span class="s2">IncomingHttpStatusHeader {</span>
        <span class="s3">&quot;:status&quot;</span><span class="s2">?: number | undefined;</span>
    <span class="s2">}</span>
    <span class="s4">export interface </span><span class="s2">IncomingHttpHeaders </span><span class="s4">extends </span><span class="s2">Http1IncomingHttpHeaders {</span>
        <span class="s3">&quot;:path&quot;</span><span class="s2">?: string | undefined;</span>
        <span class="s3">&quot;:method&quot;</span><span class="s2">?: string | undefined;</span>
        <span class="s3">&quot;:authority&quot;</span><span class="s2">?: string | undefined;</span>
        <span class="s3">&quot;:scheme&quot;</span><span class="s2">?: string | undefined;</span>
    <span class="s2">}</span>
    <span class="s0">// Http2Stream</span>
    <span class="s4">export interface </span><span class="s2">StreamPriorityOptions {</span>
        <span class="s2">exclusive?: boolean | undefined;</span>
        <span class="s2">parent?: number | undefined;</span>
        <span class="s2">weight?: number | undefined;</span>
        <span class="s2">silent?: boolean | undefined;</span>
    <span class="s2">}</span>
    <span class="s4">export interface </span><span class="s2">StreamState {</span>
        <span class="s2">localWindowSize?: number | undefined;</span>
        <span class="s2">state?: number | undefined;</span>
        <span class="s2">localClose?: number | undefined;</span>
        <span class="s2">remoteClose?: number | undefined;</span>
        <span class="s2">sumDependencyWeight?: number | undefined;</span>
        <span class="s2">weight?: number | undefined;</span>
    <span class="s2">}</span>
    <span class="s4">export interface </span><span class="s2">ServerStreamResponseOptions {</span>
        <span class="s2">endStream?: boolean | undefined;</span>
        <span class="s2">waitForTrailers?: boolean | undefined;</span>
    <span class="s2">}</span>
    <span class="s4">export interface </span><span class="s2">StatOptions {</span>
        <span class="s2">offset: number;</span>
        <span class="s2">length: number;</span>
    <span class="s2">}</span>
    <span class="s4">export interface </span><span class="s2">ServerStreamFileResponseOptions {</span>
        <span class="s0">// eslint-disable-next-line @typescript-eslint/no-invalid-void-type</span>
        <span class="s2">statCheck?(stats: fs.Stats, headers: OutgoingHttpHeaders, statOptions: StatOptions): </span><span class="s4">void </span><span class="s2">| boolean;</span>
        <span class="s2">waitForTrailers?: boolean | undefined;</span>
        <span class="s2">offset?: number | undefined;</span>
        <span class="s2">length?: number | undefined;</span>
    <span class="s2">}</span>
    <span class="s4">export interface </span><span class="s2">ServerStreamFileResponseOptionsWithError </span><span class="s4">extends </span><span class="s2">ServerStreamFileResponseOptions {</span>
        <span class="s2">onError?(err: NodeJS.ErrnoException): </span><span class="s4">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">export interface </span><span class="s2">Http2Stream </span><span class="s4">extends </span><span class="s2">stream.Duplex {</span>
        <span class="s0">/**</span>
         <span class="s0">* Set to `true` if the `Http2Stream` instance was aborted abnormally. When set,</span>
         <span class="s0">* the `'aborted'` event will have been emitted.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly aborted: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* This property shows the number of characters currently buffered to be written.</span>
         <span class="s0">* See `net.Socket.bufferSize` for details.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v11.2.0, v10.16.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly bufferSize: number;</span>
        <span class="s0">/**</span>
         <span class="s0">* Set to `true` if the `Http2Stream` instance has been closed.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v9.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly closed: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Set to `true` if the `Http2Stream` instance has been destroyed and is no longer</span>
         <span class="s0">* usable.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly destroyed: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Set to `true` if the `END_STREAM` flag was set in the request or response</span>
         <span class="s0">* HEADERS frame received, indicating that no additional data should be received</span>
         <span class="s0">* and the readable side of the `Http2Stream` will be closed.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v10.11.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly endAfterHeaders: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* The numeric stream identifier of this `Http2Stream` instance. Set to `undefined` if the stream identifier has not yet been assigned.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly id?: number | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* Set to `true` if the `Http2Stream` instance has not yet been assigned a</span>
         <span class="s0">* numeric stream identifier.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v9.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly pending: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Set to the `RST_STREAM` `error code` reported when the `Http2Stream` is</span>
         <span class="s0">* destroyed after either receiving an `RST_STREAM` frame from the connected peer,</span>
         <span class="s0">* calling `http2stream.close()`, or `http2stream.destroy()`. Will be `undefined` if the `Http2Stream` has not been closed.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly rstCode: number;</span>
        <span class="s0">/**</span>
         <span class="s0">* An object containing the outbound headers sent for this `Http2Stream`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v9.5.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly sentHeaders: OutgoingHttpHeaders;</span>
        <span class="s0">/**</span>
         <span class="s0">* An array of objects containing the outbound informational (additional) headers</span>
         <span class="s0">* sent for this `Http2Stream`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v9.5.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly sentInfoHeaders?: OutgoingHttpHeaders[] | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* An object containing the outbound trailers sent for this `HttpStream`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v9.5.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly sentTrailers?: OutgoingHttpHeaders | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* A reference to the `Http2Session` instance that owns this `Http2Stream`. The</span>
         <span class="s0">* value will be `undefined` after the `Http2Stream` instance is destroyed.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly session: Http2Session | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* Provides miscellaneous information about the current state of the `Http2Stream`.</span>
         <span class="s0">*</span>
         <span class="s0">* A current state of this `Http2Stream`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly state: StreamState;</span>
        <span class="s0">/**</span>
         <span class="s0">* Closes the `Http2Stream` instance by sending an `RST_STREAM` frame to the</span>
         <span class="s0">* connected HTTP/2 peer.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">[code=http2.constants.NGHTTP2_NO_ERROR] Unsigned 32-bit integer identifying the error code.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">callback An optional function registered to listen for the `'close'` event.</span>
         <span class="s0">*/</span>
        <span class="s2">close(code?: number, callback?: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Updates the priority for this `Http2Stream` instance.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">priority(options: StreamPriorityOptions): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import http2 from 'node:http2';</span>
         <span class="s0">* const client = http2.connect('http://example.org:8000');</span>
         <span class="s0">* const { NGHTTP2_CANCEL } = http2.constants;</span>
         <span class="s0">* const req = client.request({ ':path': '/' });</span>
         <span class="s0">*</span>
         <span class="s0">* // Cancel the stream if there's no activity after 5 seconds</span>
         <span class="s0">* req.setTimeout(5000, () =&gt; req.close(NGHTTP2_CANCEL));</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">setTimeout(msecs: number, callback?: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sends a trailing `HEADERS` frame to the connected HTTP/2 peer. This method</span>
         <span class="s0">* will cause the `Http2Stream` to be immediately closed and must only be</span>
         <span class="s0">* called after the `'wantTrailers'` event has been emitted. When sending a</span>
         <span class="s0">* request or sending a response, the `options.waitForTrailers` option must be set</span>
         <span class="s0">* in order to keep the `Http2Stream` open after the final `DATA` frame so that</span>
         <span class="s0">* trailers can be sent.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import http2 from 'node:http2';</span>
         <span class="s0">* const server = http2.createServer();</span>
         <span class="s0">* server.on('stream', (stream) =&gt; {</span>
         <span class="s0">*   stream.respond(undefined, { waitForTrailers: true });</span>
         <span class="s0">*   stream.on('wantTrailers', () =&gt; {</span>
         <span class="s0">*     stream.sendTrailers({ xyz: 'abc' });</span>
         <span class="s0">*   });</span>
         <span class="s0">*   stream.end('Hello World');</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* The HTTP/1 specification forbids trailers from containing HTTP/2 pseudo-header</span>
         <span class="s0">* fields (e.g. `':method'`, `':path'`, etc).</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v10.0.0</span>
         <span class="s0">*/</span>
        <span class="s2">sendTrailers(headers: OutgoingHttpHeaders): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;aborted&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;close&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;data&quot;</span><span class="s2">, listener: (chunk: Buffer | string) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;drain&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;end&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;error&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;finish&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;frameError&quot;</span><span class="s2">, listener: (frameType: number, errorCode: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;pipe&quot;</span><span class="s2">, listener: (src: stream.Readable) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;unpipe&quot;</span><span class="s2">, listener: (src: stream.Readable) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;streamClosed&quot;</span><span class="s2">, listener: (code: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;timeout&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;trailers&quot;</span><span class="s2">, listener: (trailers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;wantTrailers&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;aborted&quot;</span><span class="s2">): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;close&quot;</span><span class="s2">): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;data&quot;</span><span class="s2">, chunk: Buffer | string): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;drain&quot;</span><span class="s2">): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;end&quot;</span><span class="s2">): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;error&quot;</span><span class="s2">, err: Error): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;finish&quot;</span><span class="s2">): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;frameError&quot;</span><span class="s2">, frameType: number, errorCode: number): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;pipe&quot;</span><span class="s2">, src: stream.Readable): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;unpipe&quot;</span><span class="s2">, src: stream.Readable): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;streamClosed&quot;</span><span class="s2">, code: number): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;timeout&quot;</span><span class="s2">): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;trailers&quot;</span><span class="s2">, trailers: IncomingHttpHeaders, flags: number): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;wantTrailers&quot;</span><span class="s2">): boolean;</span>
        <span class="s2">emit(event: string | symbol, ...args: any[]): boolean;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;aborted&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;close&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;data&quot;</span><span class="s2">, listener: (chunk: Buffer | string) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;drain&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;end&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;error&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;finish&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;frameError&quot;</span><span class="s2">, listener: (frameType: number, errorCode: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;pipe&quot;</span><span class="s2">, listener: (src: stream.Readable) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;unpipe&quot;</span><span class="s2">, listener: (src: stream.Readable) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;streamClosed&quot;</span><span class="s2">, listener: (code: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;timeout&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;trailers&quot;</span><span class="s2">, listener: (trailers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;wantTrailers&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;aborted&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;close&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;data&quot;</span><span class="s2">, listener: (chunk: Buffer | string) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;drain&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;end&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;error&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;finish&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;frameError&quot;</span><span class="s2">, listener: (frameType: number, errorCode: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;pipe&quot;</span><span class="s2">, listener: (src: stream.Readable) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;unpipe&quot;</span><span class="s2">, listener: (src: stream.Readable) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;streamClosed&quot;</span><span class="s2">, listener: (code: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;timeout&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;trailers&quot;</span><span class="s2">, listener: (trailers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;wantTrailers&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;aborted&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;close&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;data&quot;</span><span class="s2">, listener: (chunk: Buffer | string) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;drain&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;end&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;error&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;finish&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;frameError&quot;</span><span class="s2">, listener: (frameType: number, errorCode: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;pipe&quot;</span><span class="s2">, listener: (src: stream.Readable) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;unpipe&quot;</span><span class="s2">, listener: (src: stream.Readable) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;streamClosed&quot;</span><span class="s2">, listener: (code: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;timeout&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;trailers&quot;</span><span class="s2">, listener: (trailers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;wantTrailers&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;aborted&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;close&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;data&quot;</span><span class="s2">, listener: (chunk: Buffer | string) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;drain&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;end&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;error&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;finish&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;frameError&quot;</span><span class="s2">, listener: (frameType: number, errorCode: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;pipe&quot;</span><span class="s2">, listener: (src: stream.Readable) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;unpipe&quot;</span><span class="s2">, listener: (src: stream.Readable) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;streamClosed&quot;</span><span class="s2">, listener: (code: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;timeout&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;trailers&quot;</span><span class="s2">, listener: (trailers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;wantTrailers&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">export interface </span><span class="s2">ClientHttp2Stream </span><span class="s4">extends </span><span class="s2">Http2Stream {</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;continue&quot;</span><span class="s2">, listener: () =&gt; {}): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;headers&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (headers: IncomingHttpHeaders &amp; IncomingHttpStatusHeader, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;push&quot;</span><span class="s2">, listener: (headers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;response&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (headers: IncomingHttpHeaders &amp; IncomingHttpStatusHeader, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;continue&quot;</span><span class="s2">): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;headers&quot;</span><span class="s2">, headers: IncomingHttpHeaders &amp; IncomingHttpStatusHeader, flags: number): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;push&quot;</span><span class="s2">, headers: IncomingHttpHeaders, flags: number): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;response&quot;</span><span class="s2">, headers: IncomingHttpHeaders &amp; IncomingHttpStatusHeader, flags: number): boolean;</span>
        <span class="s2">emit(event: string | symbol, ...args: any[]): boolean;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;continue&quot;</span><span class="s2">, listener: () =&gt; {}): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(</span>
            <span class="s2">event: </span><span class="s3">&quot;headers&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (headers: IncomingHttpHeaders &amp; IncomingHttpStatusHeader, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;push&quot;</span><span class="s2">, listener: (headers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(</span>
            <span class="s2">event: </span><span class="s3">&quot;response&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (headers: IncomingHttpHeaders &amp; IncomingHttpStatusHeader, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;continue&quot;</span><span class="s2">, listener: () =&gt; {}): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(</span>
            <span class="s2">event: </span><span class="s3">&quot;headers&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (headers: IncomingHttpHeaders &amp; IncomingHttpStatusHeader, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;push&quot;</span><span class="s2">, listener: (headers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(</span>
            <span class="s2">event: </span><span class="s3">&quot;response&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (headers: IncomingHttpHeaders &amp; IncomingHttpStatusHeader, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;continue&quot;</span><span class="s2">, listener: () =&gt; {}): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;headers&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (headers: IncomingHttpHeaders &amp; IncomingHttpStatusHeader, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;push&quot;</span><span class="s2">, listener: (headers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;response&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (headers: IncomingHttpHeaders &amp; IncomingHttpStatusHeader, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;continue&quot;</span><span class="s2">, listener: () =&gt; {}): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;headers&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (headers: IncomingHttpHeaders &amp; IncomingHttpStatusHeader, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;push&quot;</span><span class="s2">, listener: (headers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;response&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (headers: IncomingHttpHeaders &amp; IncomingHttpStatusHeader, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">export interface </span><span class="s2">ServerHttp2Stream </span><span class="s4">extends </span><span class="s2">Http2Stream {</span>
        <span class="s0">/**</span>
         <span class="s0">* True if headers were sent, false otherwise (read-only).</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly headersSent: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Read-only property mapped to the `SETTINGS_ENABLE_PUSH` flag of the remote</span>
         <span class="s0">* client's most recent `SETTINGS` frame. Will be `true` if the remote peer</span>
         <span class="s0">* accepts push streams, `false` otherwise. Settings are the same for every `Http2Stream` in the same `Http2Session`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly pushAllowed: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sends an additional informational `HEADERS` frame to the connected HTTP/2 peer.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">additionalHeaders(headers: OutgoingHttpHeaders): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Initiates a push stream. The callback is invoked with the new `Http2Stream` instance created for the push stream passed as the second argument, or an `Error` passed as the first argument.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import http2 from 'node:http2';</span>
         <span class="s0">* const server = http2.createServer();</span>
         <span class="s0">* server.on('stream', (stream) =&gt; {</span>
         <span class="s0">*   stream.respond({ ':status': 200 });</span>
         <span class="s0">*   stream.pushStream({ ':path': '/' }, (err, pushStream, headers) =&gt; {</span>
         <span class="s0">*     if (err) throw err;</span>
         <span class="s0">*     pushStream.respond({ ':status': 200 });</span>
         <span class="s0">*     pushStream.end('some pushed data');</span>
         <span class="s0">*   });</span>
         <span class="s0">*   stream.end('some data');</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* Setting the weight of a push stream is not allowed in the `HEADERS` frame. Pass</span>
         <span class="s0">* a `weight` value to `http2stream.priority` with the `silent` option set to `true` to enable server-side bandwidth balancing between concurrent streams.</span>
         <span class="s0">*</span>
         <span class="s0">* Calling `http2stream.pushStream()` from within a pushed stream is not permitted</span>
         <span class="s0">* and will throw an error.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">callback Callback that is called once the push stream has been initiated.</span>
         <span class="s0">*/</span>
        <span class="s2">pushStream(</span>
            <span class="s2">headers: OutgoingHttpHeaders,</span>
            <span class="s2">callback?: (err: Error | </span><span class="s4">null</span><span class="s2">, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s2">pushStream(</span>
            <span class="s2">headers: OutgoingHttpHeaders,</span>
            <span class="s2">options?: StreamPriorityOptions,</span>
            <span class="s2">callback?: (err: Error | </span><span class="s4">null</span><span class="s2">, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import http2 from 'node:http2';</span>
         <span class="s0">* const server = http2.createServer();</span>
         <span class="s0">* server.on('stream', (stream) =&gt; {</span>
         <span class="s0">*   stream.respond({ ':status': 200 });</span>
         <span class="s0">*   stream.end('some data');</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* Initiates a response. When the `options.waitForTrailers` option is set, the `'wantTrailers'` event</span>
         <span class="s0">* will be emitted immediately after queuing the last chunk of payload data to be sent.</span>
         <span class="s0">* The `http2stream.sendTrailers()` method can then be used to send trailing header fields to the peer.</span>
         <span class="s0">*</span>
         <span class="s0">* When `options.waitForTrailers` is set, the `Http2Stream` will not automatically</span>
         <span class="s0">* close when the final `DATA` frame is transmitted. User code must call either `http2stream.sendTrailers()` or `http2stream.close()` to close the `Http2Stream`.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import http2 from 'node:http2';</span>
         <span class="s0">* const server = http2.createServer();</span>
         <span class="s0">* server.on('stream', (stream) =&gt; {</span>
         <span class="s0">*   stream.respond({ ':status': 200 }, { waitForTrailers: true });</span>
         <span class="s0">*   stream.on('wantTrailers', () =&gt; {</span>
         <span class="s0">*     stream.sendTrailers({ ABC: 'some value to send' });</span>
         <span class="s0">*   });</span>
         <span class="s0">*   stream.end('some data');</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">respond(headers?: OutgoingHttpHeaders, options?: ServerStreamResponseOptions): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Initiates a response whose data is read from the given file descriptor. No</span>
         <span class="s0">* validation is performed on the given file descriptor. If an error occurs while</span>
         <span class="s0">* attempting to read data using the file descriptor, the `Http2Stream` will be</span>
         <span class="s0">* closed using an `RST_STREAM` frame using the standard `INTERNAL_ERROR` code.</span>
         <span class="s0">*</span>
         <span class="s0">* When used, the `Http2Stream` object's `Duplex` interface will be closed</span>
         <span class="s0">* automatically.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import http2 from 'node:http2';</span>
         <span class="s0">* import fs from 'node:fs';</span>
         <span class="s0">*</span>
         <span class="s0">* const server = http2.createServer();</span>
         <span class="s0">* server.on('stream', (stream) =&gt; {</span>
         <span class="s0">*   const fd = fs.openSync('/some/file', 'r');</span>
         <span class="s0">*</span>
         <span class="s0">*   const stat = fs.fstatSync(fd);</span>
         <span class="s0">*   const headers = {</span>
         <span class="s0">*     'content-length': stat.size,</span>
         <span class="s0">*     'last-modified': stat.mtime.toUTCString(),</span>
         <span class="s0">*     'content-type': 'text/plain; charset=utf-8',</span>
         <span class="s0">*   };</span>
         <span class="s0">*   stream.respondWithFD(fd, headers);</span>
         <span class="s0">*   stream.on('close', () =&gt; fs.closeSync(fd));</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* The optional `options.statCheck` function may be specified to give user code</span>
         <span class="s0">* an opportunity to set additional content headers based on the `fs.Stat` details</span>
         <span class="s0">* of the given fd. If the `statCheck` function is provided, the `http2stream.respondWithFD()` method will</span>
         <span class="s0">* perform an `fs.fstat()` call to collect details on the provided file descriptor.</span>
         <span class="s0">*</span>
         <span class="s0">* The `offset` and `length` options may be used to limit the response to a</span>
         <span class="s0">* specific range subset. This can be used, for instance, to support HTTP Range</span>
         <span class="s0">* requests.</span>
         <span class="s0">*</span>
         <span class="s0">* The file descriptor or `FileHandle` is not closed when the stream is closed,</span>
         <span class="s0">* so it will need to be closed manually once it is no longer needed.</span>
         <span class="s0">* Using the same file descriptor concurrently for multiple streams</span>
         <span class="s0">* is not supported and may result in data loss. Re-using a file descriptor</span>
         <span class="s0">* after a stream has finished is supported.</span>
         <span class="s0">*</span>
         <span class="s0">* When the `options.waitForTrailers` option is set, the `'wantTrailers'` event</span>
         <span class="s0">* will be emitted immediately after queuing the last chunk of payload data to be</span>
         <span class="s0">* sent. The `http2stream.sendTrailers()` method can then be used to sent trailing</span>
         <span class="s0">* header fields to the peer.</span>
         <span class="s0">*</span>
         <span class="s0">* When `options.waitForTrailers` is set, the `Http2Stream` will not automatically</span>
         <span class="s0">* close when the final `DATA` frame is transmitted. User code _must_ call either `http2stream.sendTrailers()`</span>
         <span class="s0">* or `http2stream.close()` to close the `Http2Stream`.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import http2 from 'node:http2';</span>
         <span class="s0">* import fs from 'node:fs';</span>
         <span class="s0">*</span>
         <span class="s0">* const server = http2.createServer();</span>
         <span class="s0">* server.on('stream', (stream) =&gt; {</span>
         <span class="s0">*   const fd = fs.openSync('/some/file', 'r');</span>
         <span class="s0">*</span>
         <span class="s0">*   const stat = fs.fstatSync(fd);</span>
         <span class="s0">*   const headers = {</span>
         <span class="s0">*     'content-length': stat.size,</span>
         <span class="s0">*     'last-modified': stat.mtime.toUTCString(),</span>
         <span class="s0">*     'content-type': 'text/plain; charset=utf-8',</span>
         <span class="s0">*   };</span>
         <span class="s0">*   stream.respondWithFD(fd, headers, { waitForTrailers: true });</span>
         <span class="s0">*   stream.on('wantTrailers', () =&gt; {</span>
         <span class="s0">*     stream.sendTrailers({ ABC: 'some value to send' });</span>
         <span class="s0">*   });</span>
         <span class="s0">*</span>
         <span class="s0">*   stream.on('close', () =&gt; fs.closeSync(fd));</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">fd A readable file descriptor.</span>
         <span class="s0">*/</span>
        <span class="s2">respondWithFD(</span>
            <span class="s2">fd: number | fs.promises.FileHandle,</span>
            <span class="s2">headers?: OutgoingHttpHeaders,</span>
            <span class="s2">options?: ServerStreamFileResponseOptions,</span>
        <span class="s2">): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sends a regular file as the response. The `path` must specify a regular file</span>
         <span class="s0">* or an `'error'` event will be emitted on the `Http2Stream` object.</span>
         <span class="s0">*</span>
         <span class="s0">* When used, the `Http2Stream` object's `Duplex` interface will be closed</span>
         <span class="s0">* automatically.</span>
         <span class="s0">*</span>
         <span class="s0">* The optional `options.statCheck` function may be specified to give user code</span>
         <span class="s0">* an opportunity to set additional content headers based on the `fs.Stat` details</span>
         <span class="s0">* of the given file:</span>
         <span class="s0">*</span>
         <span class="s0">* If an error occurs while attempting to read the file data, the `Http2Stream` will be closed using an</span>
         <span class="s0">* `RST_STREAM` frame using the standard `INTERNAL_ERROR` code.</span>
         <span class="s0">* If the `onError` callback is defined, then it will be called. Otherwise, the stream will be destroyed.</span>
         <span class="s0">*</span>
         <span class="s0">* Example using a file path:</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import http2 from 'node:http2';</span>
         <span class="s0">* const server = http2.createServer();</span>
         <span class="s0">* server.on('stream', (stream) =&gt; {</span>
         <span class="s0">*   function statCheck(stat, headers) {</span>
         <span class="s0">*     headers['last-modified'] = stat.mtime.toUTCString();</span>
         <span class="s0">*   }</span>
         <span class="s0">*</span>
         <span class="s0">*   function onError(err) {</span>
         <span class="s0">*     // stream.respond() can throw if the stream has been destroyed by</span>
         <span class="s0">*     // the other side.</span>
         <span class="s0">*     try {</span>
         <span class="s0">*       if (err.code === 'ENOENT') {</span>
         <span class="s0">*         stream.respond({ ':status': 404 });</span>
         <span class="s0">*       } else {</span>
         <span class="s0">*         stream.respond({ ':status': 500 });</span>
         <span class="s0">*       }</span>
         <span class="s0">*     } catch (err) {</span>
         <span class="s0">*       // Perform actual error handling.</span>
         <span class="s0">*       console.error(err);</span>
         <span class="s0">*     }</span>
         <span class="s0">*     stream.end();</span>
         <span class="s0">*   }</span>
         <span class="s0">*</span>
         <span class="s0">*   stream.respondWithFile('/some/file',</span>
         <span class="s0">*                          { 'content-type': 'text/plain; charset=utf-8' },</span>
         <span class="s0">*                          { statCheck, onError });</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* The `options.statCheck` function may also be used to cancel the send operation</span>
         <span class="s0">* by returning `false`. For instance, a conditional request may check the stat</span>
         <span class="s0">* results to determine if the file has been modified to return an appropriate `304` response:</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import http2 from 'node:http2';</span>
         <span class="s0">* const server = http2.createServer();</span>
         <span class="s0">* server.on('stream', (stream) =&gt; {</span>
         <span class="s0">*   function statCheck(stat, headers) {</span>
         <span class="s0">*     // Check the stat here...</span>
         <span class="s0">*     stream.respond({ ':status': 304 });</span>
         <span class="s0">*     return false; // Cancel the send operation</span>
         <span class="s0">*   }</span>
         <span class="s0">*   stream.respondWithFile('/some/file',</span>
         <span class="s0">*                          { 'content-type': 'text/plain; charset=utf-8' },</span>
         <span class="s0">*                          { statCheck });</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* The `content-length` header field will be automatically set.</span>
         <span class="s0">*</span>
         <span class="s0">* The `offset` and `length` options may be used to limit the response to a</span>
         <span class="s0">* specific range subset. This can be used, for instance, to support HTTP Range</span>
         <span class="s0">* requests.</span>
         <span class="s0">*</span>
         <span class="s0">* The `options.onError` function may also be used to handle all the errors</span>
         <span class="s0">* that could happen before the delivery of the file is initiated. The</span>
         <span class="s0">* default behavior is to destroy the stream.</span>
         <span class="s0">*</span>
         <span class="s0">* When the `options.waitForTrailers` option is set, the `'wantTrailers'` event</span>
         <span class="s0">* will be emitted immediately after queuing the last chunk of payload data to be</span>
         <span class="s0">* sent. The `http2stream.sendTrailers()` method can then be used to sent trailing</span>
         <span class="s0">* header fields to the peer.</span>
         <span class="s0">*</span>
         <span class="s0">* When `options.waitForTrailers` is set, the `Http2Stream` will not automatically</span>
         <span class="s0">* close when the final `DATA` frame is transmitted. User code must call either`http2stream.sendTrailers()` or `http2stream.close()` to close the`Http2Stream`.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import http2 from 'node:http2';</span>
         <span class="s0">* const server = http2.createServer();</span>
         <span class="s0">* server.on('stream', (stream) =&gt; {</span>
         <span class="s0">*   stream.respondWithFile('/some/file',</span>
         <span class="s0">*                          { 'content-type': 'text/plain; charset=utf-8' },</span>
         <span class="s0">*                          { waitForTrailers: true });</span>
         <span class="s0">*   stream.on('wantTrailers', () =&gt; {</span>
         <span class="s0">*     stream.sendTrailers({ ABC: 'some value to send' });</span>
         <span class="s0">*   });</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">respondWithFile(</span>
            <span class="s2">path: string,</span>
            <span class="s2">headers?: OutgoingHttpHeaders,</span>
            <span class="s2">options?: ServerStreamFileResponseOptionsWithError,</span>
        <span class="s2">): </span><span class="s4">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s0">// Http2Session</span>
    <span class="s4">export interface </span><span class="s2">Settings {</span>
        <span class="s2">headerTableSize?: number | undefined;</span>
        <span class="s2">enablePush?: boolean | undefined;</span>
        <span class="s2">initialWindowSize?: number | undefined;</span>
        <span class="s2">maxFrameSize?: number | undefined;</span>
        <span class="s2">maxConcurrentStreams?: number | undefined;</span>
        <span class="s2">maxHeaderListSize?: number | undefined;</span>
        <span class="s2">enableConnectProtocol?: boolean | undefined;</span>
    <span class="s2">}</span>
    <span class="s4">export interface </span><span class="s2">ClientSessionRequestOptions {</span>
        <span class="s2">endStream?: boolean | undefined;</span>
        <span class="s2">exclusive?: boolean | undefined;</span>
        <span class="s2">parent?: number | undefined;</span>
        <span class="s2">weight?: number | undefined;</span>
        <span class="s2">waitForTrailers?: boolean | undefined;</span>
        <span class="s2">signal?: AbortSignal | undefined;</span>
    <span class="s2">}</span>
    <span class="s4">export interface </span><span class="s2">SessionState {</span>
        <span class="s2">effectiveLocalWindowSize?: number | undefined;</span>
        <span class="s2">effectiveRecvDataLength?: number | undefined;</span>
        <span class="s2">nextStreamID?: number | undefined;</span>
        <span class="s2">localWindowSize?: number | undefined;</span>
        <span class="s2">lastProcStreamID?: number | undefined;</span>
        <span class="s2">remoteWindowSize?: number | undefined;</span>
        <span class="s2">outboundQueueSize?: number | undefined;</span>
        <span class="s2">deflateDynamicTableSize?: number | undefined;</span>
        <span class="s2">inflateDynamicTableSize?: number | undefined;</span>
    <span class="s2">}</span>
    <span class="s4">export interface </span><span class="s2">Http2Session </span><span class="s4">extends </span><span class="s2">EventEmitter {</span>
        <span class="s0">/**</span>
         <span class="s0">* Value will be `undefined` if the `Http2Session` is not yet connected to a</span>
         <span class="s0">* socket, `h2c` if the `Http2Session` is not connected to a `TLSSocket`, or</span>
         <span class="s0">* will return the value of the connected `TLSSocket`'s own `alpnProtocol` property.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v9.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly alpnProtocol?: string | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* Will be `true` if this `Http2Session` instance has been closed, otherwise `false`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v9.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly closed: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Will be `true` if this `Http2Session` instance is still connecting, will be set</span>
         <span class="s0">* to `false` before emitting `connect` event and/or calling the `http2.connect` callback.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v10.0.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly connecting: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Will be `true` if this `Http2Session` instance has been destroyed and must no</span>
         <span class="s0">* longer be used, otherwise `false`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly destroyed: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Value is `undefined` if the `Http2Session` session socket has not yet been</span>
         <span class="s0">* connected, `true` if the `Http2Session` is connected with a `TLSSocket`,</span>
         <span class="s0">* and `false` if the `Http2Session` is connected to any other kind of socket</span>
         <span class="s0">* or stream.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v9.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly encrypted?: boolean | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* A prototype-less object describing the current local settings of this `Http2Session`.</span>
         <span class="s0">* The local settings are local to _this_`Http2Session` instance.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly localSettings: Settings;</span>
        <span class="s0">/**</span>
         <span class="s0">* If the `Http2Session` is connected to a `TLSSocket`, the `originSet` property</span>
         <span class="s0">* will return an `Array` of origins for which the `Http2Session` may be</span>
         <span class="s0">* considered authoritative.</span>
         <span class="s0">*</span>
         <span class="s0">* The `originSet` property is only available when using a secure TLS connection.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v9.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly originSet?: string[] | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* Indicates whether the `Http2Session` is currently waiting for acknowledgment of</span>
         <span class="s0">* a sent `SETTINGS` frame. Will be `true` after calling the `http2session.settings()` method.</span>
         <span class="s0">* Will be `false` once all sent `SETTINGS` frames have been acknowledged.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly pendingSettingsAck: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* A prototype-less object describing the current remote settings of this`Http2Session`.</span>
         <span class="s0">* The remote settings are set by the _connected_ HTTP/2 peer.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly remoteSettings: Settings;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns a `Proxy` object that acts as a `net.Socket` (or `tls.TLSSocket`) but</span>
         <span class="s0">* limits available methods to ones safe to use with HTTP/2.</span>
         <span class="s0">*</span>
         <span class="s0">* `destroy`, `emit`, `end`, `pause`, `read`, `resume`, and `write` will throw</span>
         <span class="s0">* an error with code `ERR_HTTP2_NO_SOCKET_MANIPULATION`. See `Http2Session and Sockets` for more information.</span>
         <span class="s0">*</span>
         <span class="s0">* `setTimeout` method will be called on this `Http2Session`.</span>
         <span class="s0">*</span>
         <span class="s0">* All other interactions will be routed directly to the socket.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly socket: net.Socket | tls.TLSSocket;</span>
        <span class="s0">/**</span>
         <span class="s0">* Provides miscellaneous information about the current state of the`Http2Session`.</span>
         <span class="s0">*</span>
         <span class="s0">* An object describing the current status of this `Http2Session`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly state: SessionState;</span>
        <span class="s0">/**</span>
         <span class="s0">* The `http2session.type` will be equal to `http2.constants.NGHTTP2_SESSION_SERVER` if this `Http2Session` instance is a</span>
         <span class="s0">* server, and `http2.constants.NGHTTP2_SESSION_CLIENT` if the instance is a</span>
         <span class="s0">* client.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly type: number;</span>
        <span class="s0">/**</span>
         <span class="s0">* Gracefully closes the `Http2Session`, allowing any existing streams to</span>
         <span class="s0">* complete on their own and preventing new `Http2Stream` instances from being</span>
         <span class="s0">* created. Once closed, `http2session.destroy()`_might_ be called if there</span>
         <span class="s0">* are no open `Http2Stream` instances.</span>
         <span class="s0">*</span>
         <span class="s0">* If specified, the `callback` function is registered as a handler for the`'close'` event.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v9.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">close(callback?: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Immediately terminates the `Http2Session` and the associated `net.Socket` or `tls.TLSSocket`.</span>
         <span class="s0">*</span>
         <span class="s0">* Once destroyed, the `Http2Session` will emit the `'close'` event. If `error` is not undefined, an `'error'` event will be emitted immediately before the `'close'` event.</span>
         <span class="s0">*</span>
         <span class="s0">* If there are any remaining open `Http2Streams` associated with the `Http2Session`, those will also be destroyed.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">error An `Error` object if the `Http2Session` is being destroyed due to an error.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">code The HTTP/2 error code to send in the final `GOAWAY` frame. If unspecified, and `error` is not undefined, the default is `INTERNAL_ERROR`, otherwise defaults to `NO_ERROR`.</span>
         <span class="s0">*/</span>
        <span class="s2">destroy(error?: Error, code?: number): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Transmits a `GOAWAY` frame to the connected peer _without_ shutting down the`Http2Session`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v9.4.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">code An HTTP/2 error code</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">lastStreamID The numeric ID of the last processed `Http2Stream`</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">opaqueData A `TypedArray` or `DataView` instance containing additional data to be carried within the `GOAWAY` frame.</span>
         <span class="s0">*/</span>
        <span class="s2">goaway(code?: number, lastStreamID?: number, opaqueData?: NodeJS.ArrayBufferView): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sends a `PING` frame to the connected HTTP/2 peer. A `callback` function must</span>
         <span class="s0">* be provided. The method will return `true` if the `PING` was sent, `false` otherwise.</span>
         <span class="s0">*</span>
         <span class="s0">* The maximum number of outstanding (unacknowledged) pings is determined by the `maxOutstandingPings` configuration option. The default maximum is 10.</span>
         <span class="s0">*</span>
         <span class="s0">* If provided, the `payload` must be a `Buffer`, `TypedArray`, or `DataView` containing 8 bytes of data that will be transmitted with the `PING` and</span>
         <span class="s0">* returned with the ping acknowledgment.</span>
         <span class="s0">*</span>
         <span class="s0">* The callback will be invoked with three arguments: an error argument that will</span>
         <span class="s0">* be `null` if the `PING` was successfully acknowledged, a `duration` argument</span>
         <span class="s0">* that reports the number of milliseconds elapsed since the ping was sent and the</span>
         <span class="s0">* acknowledgment was received, and a `Buffer` containing the 8-byte `PING` payload.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* session.ping(Buffer.from('abcdefgh'), (err, duration, payload) =&gt; {</span>
         <span class="s0">*   if (!err) {</span>
         <span class="s0">*     console.log(`Ping acknowledged in ${duration} milliseconds`);</span>
         <span class="s0">*     console.log(`With payload '${payload.toString()}'`);</span>
         <span class="s0">*   }</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* If the `payload` argument is not specified, the default payload will be the</span>
         <span class="s0">* 64-bit timestamp (little endian) marking the start of the `PING` duration.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.9.3</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">payload Optional ping payload.</span>
         <span class="s0">*/</span>
        <span class="s2">ping(callback: (err: Error | </span><span class="s4">null</span><span class="s2">, duration: number, payload: Buffer) =&gt; </span><span class="s4">void</span><span class="s2">): boolean;</span>
        <span class="s2">ping(</span>
            <span class="s2">payload: NodeJS.ArrayBufferView,</span>
            <span class="s2">callback: (err: Error | </span><span class="s4">null</span><span class="s2">, duration: number, payload: Buffer) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Calls `ref()` on this `Http2Session` instance's underlying `net.Socket`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v9.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">ref(): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sets the local endpoint's window size.</span>
         <span class="s0">* The `windowSize` is the total window size to set, not</span>
         <span class="s0">* the delta.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import http2 from 'node:http2';</span>
         <span class="s0">*</span>
         <span class="s0">* const server = http2.createServer();</span>
         <span class="s0">* const expectedWindowSize = 2 ** 20;</span>
         <span class="s0">* server.on('connect', (session) =&gt; {</span>
         <span class="s0">*</span>
         <span class="s0">*   // Set local window size to be 2 ** 20</span>
         <span class="s0">*   session.setLocalWindowSize(expectedWindowSize);</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v15.3.0, v14.18.0</span>
         <span class="s0">*/</span>
        <span class="s2">setLocalWindowSize(windowSize: number): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Used to set a callback function that is called when there is no activity on</span>
         <span class="s0">* the `Http2Session` after `msecs` milliseconds. The given `callback` is</span>
         <span class="s0">* registered as a listener on the `'timeout'` event.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">setTimeout(msecs: number, callback?: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Updates the current local settings for this `Http2Session` and sends a new `SETTINGS` frame to the connected HTTP/2 peer.</span>
         <span class="s0">*</span>
         <span class="s0">* Once called, the `http2session.pendingSettingsAck` property will be `true` while the session is waiting for the remote peer to acknowledge the new</span>
         <span class="s0">* settings.</span>
         <span class="s0">*</span>
         <span class="s0">* The new settings will not become effective until the `SETTINGS` acknowledgment</span>
         <span class="s0">* is received and the `'localSettings'` event is emitted. It is possible to send</span>
         <span class="s0">* multiple `SETTINGS` frames while acknowledgment is still pending.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">callback Callback that is called once the session is connected or right away if the session is already connected.</span>
         <span class="s0">*/</span>
        <span class="s2">settings(</span>
            <span class="s2">settings: Settings,</span>
            <span class="s2">callback?: (err: Error | </span><span class="s4">null</span><span class="s2">, settings: Settings, duration: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Calls `unref()` on this `Http2Session`instance's underlying `net.Socket`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v9.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">unref(): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;close&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;error&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;frameError&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (frameType: number, errorCode: number, streamID: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;goaway&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;localSettings&quot;</span><span class="s2">, listener: (settings: Settings) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;ping&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;remoteSettings&quot;</span><span class="s2">, listener: (settings: Settings) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;timeout&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;close&quot;</span><span class="s2">): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;error&quot;</span><span class="s2">, err: Error): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;frameError&quot;</span><span class="s2">, frameType: number, errorCode: number, streamID: number): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;goaway&quot;</span><span class="s2">, errorCode: number, lastStreamID: number, opaqueData?: Buffer): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;localSettings&quot;</span><span class="s2">, settings: Settings): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;ping&quot;</span><span class="s2">): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;remoteSettings&quot;</span><span class="s2">, settings: Settings): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;timeout&quot;</span><span class="s2">): boolean;</span>
        <span class="s2">emit(event: string | symbol, ...args: any[]): boolean;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;close&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;error&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;frameError&quot;</span><span class="s2">, listener: (frameType: number, errorCode: number, streamID: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;goaway&quot;</span><span class="s2">, listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;localSettings&quot;</span><span class="s2">, listener: (settings: Settings) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;ping&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;remoteSettings&quot;</span><span class="s2">, listener: (settings: Settings) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;timeout&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;close&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;error&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;frameError&quot;</span><span class="s2">, listener: (frameType: number, errorCode: number, streamID: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;goaway&quot;</span><span class="s2">, listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;localSettings&quot;</span><span class="s2">, listener: (settings: Settings) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;ping&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;remoteSettings&quot;</span><span class="s2">, listener: (settings: Settings) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;timeout&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;close&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;error&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;frameError&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (frameType: number, errorCode: number, streamID: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;goaway&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;localSettings&quot;</span><span class="s2">, listener: (settings: Settings) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;ping&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;remoteSettings&quot;</span><span class="s2">, listener: (settings: Settings) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;timeout&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;close&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;error&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;frameError&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (frameType: number, errorCode: number, streamID: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;goaway&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;localSettings&quot;</span><span class="s2">, listener: (settings: Settings) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;ping&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;remoteSettings&quot;</span><span class="s2">, listener: (settings: Settings) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;timeout&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">export interface </span><span class="s2">ClientHttp2Session </span><span class="s4">extends </span><span class="s2">Http2Session {</span>
        <span class="s0">/**</span>
         <span class="s0">* For HTTP/2 Client `Http2Session` instances only, the `http2session.request()` creates and returns an `Http2Stream` instance that can be used to send an</span>
         <span class="s0">* HTTP/2 request to the connected server.</span>
         <span class="s0">*</span>
         <span class="s0">* When a `ClientHttp2Session` is first created, the socket may not yet be</span>
         <span class="s0">* connected. if `clienthttp2session.request()` is called during this time, the</span>
         <span class="s0">* actual request will be deferred until the socket is ready to go.</span>
         <span class="s0">* If the `session` is closed before the actual request be executed, an `ERR_HTTP2_GOAWAY_SESSION` is thrown.</span>
         <span class="s0">*</span>
         <span class="s0">* This method is only available if `http2session.type` is equal to `http2.constants.NGHTTP2_SESSION_CLIENT`.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import http2 from 'node:http2';</span>
         <span class="s0">* const clientSession = http2.connect('https://localhost:1234');</span>
         <span class="s0">* const {</span>
         <span class="s0">*   HTTP2_HEADER_PATH,</span>
         <span class="s0">*   HTTP2_HEADER_STATUS,</span>
         <span class="s0">* } = http2.constants;</span>
         <span class="s0">*</span>
         <span class="s0">* const req = clientSession.request({ [HTTP2_HEADER_PATH]: '/' });</span>
         <span class="s0">* req.on('response', (headers) =&gt; {</span>
         <span class="s0">*   console.log(headers[HTTP2_HEADER_STATUS]);</span>
         <span class="s0">*   req.on('data', (chunk) =&gt; { // ..  });</span>
         <span class="s0">*   req.on('end', () =&gt; { // ..  });</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* When the `options.waitForTrailers` option is set, the `'wantTrailers'` event</span>
         <span class="s0">* is emitted immediately after queuing the last chunk of payload data to be sent.</span>
         <span class="s0">* The `http2stream.sendTrailers()` method can then be called to send trailing</span>
         <span class="s0">* headers to the peer.</span>
         <span class="s0">*</span>
         <span class="s0">* When `options.waitForTrailers` is set, the `Http2Stream` will not automatically</span>
         <span class="s0">* close when the final `DATA` frame is transmitted. User code must call either`http2stream.sendTrailers()` or `http2stream.close()` to close the`Http2Stream`.</span>
         <span class="s0">*</span>
         <span class="s0">* When `options.signal` is set with an `AbortSignal` and then `abort` on the</span>
         <span class="s0">* corresponding `AbortController` is called, the request will emit an `'error'`event with an `AbortError` error.</span>
         <span class="s0">*</span>
         <span class="s0">* The `:method` and `:path` pseudo-headers are not specified within `headers`,</span>
         <span class="s0">* they respectively default to:</span>
         <span class="s0">*</span>
         <span class="s0">* * `:method` \= `'GET'`</span>
         <span class="s0">* * `:path` \= `/`</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">request(headers?: OutgoingHttpHeaders, options?: ClientSessionRequestOptions): ClientHttp2Stream;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;altsvc&quot;</span><span class="s2">, listener: (alt: string, origin: string, stream: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;origin&quot;</span><span class="s2">, listener: (origins: string[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;connect&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;stream&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (</span>
                <span class="s2">stream: ClientHttp2Stream,</span>
                <span class="s2">headers: IncomingHttpHeaders &amp; IncomingHttpStatusHeader,</span>
                <span class="s2">flags: number,</span>
            <span class="s2">) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;altsvc&quot;</span><span class="s2">, alt: string, origin: string, stream: number): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;origin&quot;</span><span class="s2">, origins: readonly string[]): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;connect&quot;</span><span class="s2">, session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket): boolean;</span>
        <span class="s2">emit(</span>
            <span class="s2">event: </span><span class="s3">&quot;stream&quot;</span><span class="s2">,</span>
            <span class="s2">stream: ClientHttp2Stream,</span>
            <span class="s2">headers: IncomingHttpHeaders &amp; IncomingHttpStatusHeader,</span>
            <span class="s2">flags: number,</span>
        <span class="s2">): boolean;</span>
        <span class="s2">emit(event: string | symbol, ...args: any[]): boolean;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;altsvc&quot;</span><span class="s2">, listener: (alt: string, origin: string, stream: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;origin&quot;</span><span class="s2">, listener: (origins: string[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;connect&quot;</span><span class="s2">, listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(</span>
            <span class="s2">event: </span><span class="s3">&quot;stream&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (</span>
                <span class="s2">stream: ClientHttp2Stream,</span>
                <span class="s2">headers: IncomingHttpHeaders &amp; IncomingHttpStatusHeader,</span>
                <span class="s2">flags: number,</span>
            <span class="s2">) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;altsvc&quot;</span><span class="s2">, listener: (alt: string, origin: string, stream: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;origin&quot;</span><span class="s2">, listener: (origins: string[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(</span>
            <span class="s2">event: </span><span class="s3">&quot;connect&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(</span>
            <span class="s2">event: </span><span class="s3">&quot;stream&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (</span>
                <span class="s2">stream: ClientHttp2Stream,</span>
                <span class="s2">headers: IncomingHttpHeaders &amp; IncomingHttpStatusHeader,</span>
                <span class="s2">flags: number,</span>
            <span class="s2">) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;altsvc&quot;</span><span class="s2">, listener: (alt: string, origin: string, stream: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;origin&quot;</span><span class="s2">, listener: (origins: string[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;connect&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;stream&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (</span>
                <span class="s2">stream: ClientHttp2Stream,</span>
                <span class="s2">headers: IncomingHttpHeaders &amp; IncomingHttpStatusHeader,</span>
                <span class="s2">flags: number,</span>
            <span class="s2">) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;altsvc&quot;</span><span class="s2">, listener: (alt: string, origin: string, stream: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;origin&quot;</span><span class="s2">, listener: (origins: string[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;connect&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;stream&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (</span>
                <span class="s2">stream: ClientHttp2Stream,</span>
                <span class="s2">headers: IncomingHttpHeaders &amp; IncomingHttpStatusHeader,</span>
                <span class="s2">flags: number,</span>
            <span class="s2">) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">export interface </span><span class="s2">AlternativeServiceOptions {</span>
        <span class="s2">origin: number | string | url.URL;</span>
    <span class="s2">}</span>
    <span class="s4">export interface </span><span class="s2">ServerHttp2Session&lt;</span>
        <span class="s2">Http1Request </span><span class="s4">extends typeof </span><span class="s2">IncomingMessage = </span><span class="s4">typeof </span><span class="s2">IncomingMessage,</span>
        <span class="s2">Http1Response </span><span class="s4">extends typeof </span><span class="s2">ServerResponse&lt;InstanceType&lt;Http1Request&gt;&gt; = </span><span class="s4">typeof </span><span class="s2">ServerResponse,</span>
        <span class="s2">Http2Request </span><span class="s4">extends typeof </span><span class="s2">Http2ServerRequest = </span><span class="s4">typeof </span><span class="s2">Http2ServerRequest,</span>
        <span class="s2">Http2Response </span><span class="s4">extends typeof </span><span class="s2">Http2ServerResponse&lt;InstanceType&lt;Http2Request&gt;&gt; = </span><span class="s4">typeof </span><span class="s2">Http2ServerResponse,</span>
    <span class="s2">&gt; </span><span class="s4">extends </span><span class="s2">Http2Session {</span>
        <span class="s2">readonly server:</span>
            <span class="s2">| Http2Server&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;</span>
            <span class="s2">| Http2SecureServer&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Submits an `ALTSVC` frame (as defined by [RFC 7838](https://tools.ietf.org/html/rfc7838)) to the connected client.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import http2 from 'node:http2';</span>
         <span class="s0">*</span>
         <span class="s0">* const server = http2.createServer();</span>
         <span class="s0">* server.on('session', (session) =&gt; {</span>
         <span class="s0">*   // Set altsvc for origin https://example.org:80</span>
         <span class="s0">*   session.altsvc('h2=&quot;:8000&quot;', 'https://example.org:80');</span>
         <span class="s0">* });</span>
         <span class="s0">*</span>
         <span class="s0">* server.on('stream', (stream) =&gt; {</span>
         <span class="s0">*   // Set altsvc for a specific stream</span>
         <span class="s0">*   stream.session.altsvc('h2=&quot;:8000&quot;', stream.id);</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* Sending an `ALTSVC` frame with a specific stream ID indicates that the alternate</span>
         <span class="s0">* service is associated with the origin of the given `Http2Stream`.</span>
         <span class="s0">*</span>
         <span class="s0">* The `alt` and origin string _must_ contain only ASCII bytes and are</span>
         <span class="s0">* strictly interpreted as a sequence of ASCII bytes. The special value `'clear'`may be passed to clear any previously set alternative service for a given</span>
         <span class="s0">* domain.</span>
         <span class="s0">*</span>
         <span class="s0">* When a string is passed for the `originOrStream` argument, it will be parsed as</span>
         <span class="s0">* a URL and the origin will be derived. For instance, the origin for the</span>
         <span class="s0">* HTTP URL `'https://example.org/foo/bar'` is the ASCII string`'https://example.org'`. An error will be thrown if either the given string</span>
         <span class="s0">* cannot be parsed as a URL or if a valid origin cannot be derived.</span>
         <span class="s0">*</span>
         <span class="s0">* A `URL` object, or any object with an `origin` property, may be passed as`originOrStream`, in which case the value of the `origin` property will be</span>
         <span class="s0">* used. The value of the `origin` property _must_ be a properly serialized</span>
         <span class="s0">* ASCII origin.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v9.4.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">alt A description of the alternative service configuration as defined by `RFC 7838`.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">originOrStream Either a URL string specifying the origin (or an `Object` with an `origin` property) or the numeric identifier of an active `Http2Stream` as given by the</span>
         <span class="s0">* `http2stream.id` property.</span>
         <span class="s0">*/</span>
        <span class="s2">altsvc(alt: string, originOrStream: number | string | url.URL | AlternativeServiceOptions): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Submits an `ORIGIN` frame (as defined by [RFC 8336](https://tools.ietf.org/html/rfc8336)) to the connected client</span>
         <span class="s0">* to advertise the set of origins for which the server is capable of providing</span>
         <span class="s0">* authoritative responses.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import http2 from 'node:http2';</span>
         <span class="s0">* const options = getSecureOptionsSomehow();</span>
         <span class="s0">* const server = http2.createSecureServer(options);</span>
         <span class="s0">* server.on('stream', (stream) =&gt; {</span>
         <span class="s0">*   stream.respond();</span>
         <span class="s0">*   stream.end('ok');</span>
         <span class="s0">* });</span>
         <span class="s0">* server.on('session', (session) =&gt; {</span>
         <span class="s0">*   session.origin('https://example.com', 'https://example.org');</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* When a string is passed as an `origin`, it will be parsed as a URL and the</span>
         <span class="s0">* origin will be derived. For instance, the origin for the HTTP URL `'https://example.org/foo/bar'` is the ASCII string` 'https://example.org'`. An error will be thrown if either the given</span>
         <span class="s0">* string</span>
         <span class="s0">* cannot be parsed as a URL or if a valid origin cannot be derived.</span>
         <span class="s0">*</span>
         <span class="s0">* A `URL` object, or any object with an `origin` property, may be passed as</span>
         <span class="s0">* an `origin`, in which case the value of the `origin` property will be</span>
         <span class="s0">* used. The value of the `origin` property _must_ be a properly serialized</span>
         <span class="s0">* ASCII origin.</span>
         <span class="s0">*</span>
         <span class="s0">* Alternatively, the `origins` option may be used when creating a new HTTP/2</span>
         <span class="s0">* server using the `http2.createSecureServer()` method:</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import http2 from 'node:http2';</span>
         <span class="s0">* const options = getSecureOptionsSomehow();</span>
         <span class="s0">* options.origins = ['https://example.com', 'https://example.org'];</span>
         <span class="s0">* const server = http2.createSecureServer(options);</span>
         <span class="s0">* server.on('stream', (stream) =&gt; {</span>
         <span class="s0">*   stream.respond();</span>
         <span class="s0">*   stream.end('ok');</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v10.12.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">origins One or more URL Strings passed as separate arguments.</span>
         <span class="s0">*/</span>
        <span class="s2">origin(</span>
            <span class="s2">...origins: Array&lt;</span>
                <span class="s2">| string</span>
                <span class="s2">| url.URL</span>
                <span class="s2">| {</span>
                    <span class="s2">origin: string;</span>
                <span class="s2">}</span>
            <span class="s2">&gt;</span>
        <span class="s2">): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s2">addListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;connect&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (</span>
                <span class="s2">session: ServerHttp2Session&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;,</span>
                <span class="s2">socket: net.Socket | tls.TLSSocket,</span>
            <span class="s2">) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;stream&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">emit(</span>
            <span class="s2">event: </span><span class="s3">&quot;connect&quot;</span><span class="s2">,</span>
            <span class="s2">session: ServerHttp2Session&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;,</span>
            <span class="s2">socket: net.Socket | tls.TLSSocket,</span>
        <span class="s2">): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;stream&quot;</span><span class="s2">, stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;</span>
        <span class="s2">emit(event: string | symbol, ...args: any[]): boolean;</span>
        <span class="s2">on(</span>
            <span class="s2">event: </span><span class="s3">&quot;connect&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (</span>
                <span class="s2">session: ServerHttp2Session&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;,</span>
                <span class="s2">socket: net.Socket | tls.TLSSocket,</span>
            <span class="s2">) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(</span>
            <span class="s2">event: </span><span class="s3">&quot;stream&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(</span>
            <span class="s2">event: </span><span class="s3">&quot;connect&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (</span>
                <span class="s2">session: ServerHttp2Session&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;,</span>
                <span class="s2">socket: net.Socket | tls.TLSSocket,</span>
            <span class="s2">) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(</span>
            <span class="s2">event: </span><span class="s3">&quot;stream&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;connect&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (</span>
                <span class="s2">session: ServerHttp2Session&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;,</span>
                <span class="s2">socket: net.Socket | tls.TLSSocket,</span>
            <span class="s2">) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;stream&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;connect&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (</span>
                <span class="s2">session: ServerHttp2Session&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;,</span>
                <span class="s2">socket: net.Socket | tls.TLSSocket,</span>
            <span class="s2">) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;stream&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s0">// Http2Server</span>
    <span class="s4">export interface </span><span class="s2">SessionOptions {</span>
        <span class="s0">/**</span>
         <span class="s0">* Sets the maximum dynamic table size for deflating header fields.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">4Kib</span>
         <span class="s0">*/</span>
        <span class="s2">maxDeflateDynamicTableSize?: number | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sets the maximum number of settings entries per `SETTINGS` frame.</span>
         <span class="s0">* The minimum value allowed is `1`.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">32</span>
         <span class="s0">*/</span>
        <span class="s2">maxSettings?: number | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sets the maximum memory that the `Http2Session` is permitted to use.</span>
         <span class="s0">* The value is expressed in terms of number of megabytes, e.g. `1` equal 1 megabyte.</span>
         <span class="s0">* The minimum value allowed is `1`.</span>
         <span class="s0">* This is a credit based limit, existing `Http2Stream`s may cause this limit to be exceeded,</span>
         <span class="s0">* but new `Http2Stream` instances will be rejected while this limit is exceeded.</span>
         <span class="s0">* The current number of `Http2Stream` sessions, the current memory use of the header compression tables,</span>
         <span class="s0">* current data queued to be sent, and unacknowledged `PING` and `SETTINGS` frames are all counted towards the current limit.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">10</span>
         <span class="s0">*/</span>
        <span class="s2">maxSessionMemory?: number | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sets the maximum number of header entries.</span>
         <span class="s0">* This is similar to `server.maxHeadersCount` or `request.maxHeadersCount` in the `node:http` module.</span>
         <span class="s0">* The minimum value is `1`.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">128</span>
         <span class="s0">*/</span>
        <span class="s2">maxHeaderListPairs?: number | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sets the maximum number of outstanding, unacknowledged pings.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">10</span>
         <span class="s0">*/</span>
        <span class="s2">maxOutstandingPings?: number | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sets the maximum allowed size for a serialized, compressed block of headers.</span>
         <span class="s0">* Attempts to send headers that exceed this limit will result in</span>
         <span class="s0">* a `'frameError'` event being emitted and the stream being closed and destroyed.</span>
         <span class="s0">*/</span>
        <span class="s2">maxSendHeaderBlockLength?: number | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* Strategy used for determining the amount of padding to use for `HEADERS` and `DATA` frames.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">http2.constants.PADDING_STRATEGY_NONE</span>
         <span class="s0">*/</span>
        <span class="s2">paddingStrategy?: number | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sets the maximum number of concurrent streams for the remote peer as if a `SETTINGS` frame had been received.</span>
         <span class="s0">* Will be overridden if the remote peer sets its own value for `maxConcurrentStreams`.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">100</span>
         <span class="s0">*/</span>
        <span class="s2">peerMaxConcurrentStreams?: number | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* The initial settings to send to the remote peer upon connection.</span>
         <span class="s0">*/</span>
        <span class="s2">settings?: Settings | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* The array of integer values determines the settings types,</span>
         <span class="s0">* which are included in the `CustomSettings`-property of the received remoteSettings.</span>
         <span class="s0">* Please see the `CustomSettings`-property of the `Http2Settings` object for more information, on the allowed setting types.</span>
         <span class="s0">*/</span>
        <span class="s2">remoteCustomSettings?: number[] | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* Specifies a timeout in milliseconds that</span>
         <span class="s0">* a server should wait when an [`'unknownProtocol'`][] is emitted. If the</span>
         <span class="s0">* socket has not been destroyed by that time the server will destroy it.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">100000</span>
         <span class="s0">*/</span>
        <span class="s2">unknownProtocolTimeout?: number | undefined;</span>
    <span class="s2">}</span>
    <span class="s4">export interface </span><span class="s2">ClientSessionOptions </span><span class="s4">extends </span><span class="s2">SessionOptions {</span>
        <span class="s0">/**</span>
         <span class="s0">* Sets the maximum number of reserved push streams the client will accept at any given time.</span>
         <span class="s0">* Once the current number of currently reserved push streams exceeds reaches this limit,</span>
         <span class="s0">* new push streams sent by the server will be automatically rejected.</span>
         <span class="s0">* The minimum allowed value is 0. The maximum allowed value is 2&lt;sup&gt;32&lt;/sup&gt;-1.</span>
         <span class="s0">* A negative value sets this option to the maximum allowed value.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">200</span>
         <span class="s0">*/</span>
        <span class="s2">maxReservedRemoteStreams?: number | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* An optional callback that receives the `URL` instance passed to `connect` and the `options` object,</span>
         <span class="s0">* and returns any `Duplex` stream that is to be used as the connection for this session.</span>
         <span class="s0">*/</span>
        <span class="s2">createConnection?: ((authority: url.URL, option: SessionOptions) =&gt; stream.Duplex) | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* The protocol to connect with, if not set in the `authority`.</span>
         <span class="s0">* Value may be either `'http:'` or `'https:'`.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">'https:'</span>
         <span class="s0">*/</span>
        <span class="s2">protocol?: </span><span class="s3">&quot;http:&quot; </span><span class="s2">| </span><span class="s3">&quot;https:&quot; </span><span class="s2">| undefined;</span>
    <span class="s2">}</span>
    <span class="s4">export interface </span><span class="s2">ServerSessionOptions&lt;</span>
        <span class="s2">Http1Request </span><span class="s4">extends typeof </span><span class="s2">IncomingMessage = </span><span class="s4">typeof </span><span class="s2">IncomingMessage,</span>
        <span class="s2">Http1Response </span><span class="s4">extends typeof </span><span class="s2">ServerResponse&lt;InstanceType&lt;Http1Request&gt;&gt; = </span><span class="s4">typeof </span><span class="s2">ServerResponse,</span>
        <span class="s2">Http2Request </span><span class="s4">extends typeof </span><span class="s2">Http2ServerRequest = </span><span class="s4">typeof </span><span class="s2">Http2ServerRequest,</span>
        <span class="s2">Http2Response </span><span class="s4">extends typeof </span><span class="s2">Http2ServerResponse&lt;InstanceType&lt;Http2Request&gt;&gt; = </span><span class="s4">typeof </span><span class="s2">Http2ServerResponse,</span>
    <span class="s2">&gt; </span><span class="s4">extends </span><span class="s2">SessionOptions {</span>
        <span class="s2">Http1IncomingMessage?: Http1Request | undefined;</span>
        <span class="s2">Http1ServerResponse?: Http1Response | undefined;</span>
        <span class="s2">Http2ServerRequest?: Http2Request | undefined;</span>
        <span class="s2">Http2ServerResponse?: Http2Response | undefined;</span>
    <span class="s2">}</span>
    <span class="s4">export interface </span><span class="s2">SecureClientSessionOptions </span><span class="s4">extends </span><span class="s2">ClientSessionOptions, tls.ConnectionOptions {}</span>
    <span class="s4">export interface </span><span class="s2">SecureServerSessionOptions&lt;</span>
        <span class="s2">Http1Request </span><span class="s4">extends typeof </span><span class="s2">IncomingMessage = </span><span class="s4">typeof </span><span class="s2">IncomingMessage,</span>
        <span class="s2">Http1Response </span><span class="s4">extends typeof </span><span class="s2">ServerResponse&lt;InstanceType&lt;Http1Request&gt;&gt; = </span><span class="s4">typeof </span><span class="s2">ServerResponse,</span>
        <span class="s2">Http2Request </span><span class="s4">extends typeof </span><span class="s2">Http2ServerRequest = </span><span class="s4">typeof </span><span class="s2">Http2ServerRequest,</span>
        <span class="s2">Http2Response </span><span class="s4">extends typeof </span><span class="s2">Http2ServerResponse&lt;InstanceType&lt;Http2Request&gt;&gt; = </span><span class="s4">typeof </span><span class="s2">Http2ServerResponse,</span>
    <span class="s2">&gt; </span><span class="s4">extends </span><span class="s2">ServerSessionOptions&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;, tls.TlsOptions {}</span>
    <span class="s4">export interface </span><span class="s2">ServerOptions&lt;</span>
        <span class="s2">Http1Request </span><span class="s4">extends typeof </span><span class="s2">IncomingMessage = </span><span class="s4">typeof </span><span class="s2">IncomingMessage,</span>
        <span class="s2">Http1Response </span><span class="s4">extends typeof </span><span class="s2">ServerResponse&lt;InstanceType&lt;Http1Request&gt;&gt; = </span><span class="s4">typeof </span><span class="s2">ServerResponse,</span>
        <span class="s2">Http2Request </span><span class="s4">extends typeof </span><span class="s2">Http2ServerRequest = </span><span class="s4">typeof </span><span class="s2">Http2ServerRequest,</span>
        <span class="s2">Http2Response </span><span class="s4">extends typeof </span><span class="s2">Http2ServerResponse&lt;InstanceType&lt;Http2Request&gt;&gt; = </span><span class="s4">typeof </span><span class="s2">Http2ServerResponse,</span>
    <span class="s2">&gt; </span><span class="s4">extends </span><span class="s2">ServerSessionOptions&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt; {}</span>
    <span class="s4">export interface </span><span class="s2">SecureServerOptions&lt;</span>
        <span class="s2">Http1Request </span><span class="s4">extends typeof </span><span class="s2">IncomingMessage = </span><span class="s4">typeof </span><span class="s2">IncomingMessage,</span>
        <span class="s2">Http1Response </span><span class="s4">extends typeof </span><span class="s2">ServerResponse&lt;InstanceType&lt;Http1Request&gt;&gt; = </span><span class="s4">typeof </span><span class="s2">ServerResponse,</span>
        <span class="s2">Http2Request </span><span class="s4">extends typeof </span><span class="s2">Http2ServerRequest = </span><span class="s4">typeof </span><span class="s2">Http2ServerRequest,</span>
        <span class="s2">Http2Response </span><span class="s4">extends typeof </span><span class="s2">Http2ServerResponse&lt;InstanceType&lt;Http2Request&gt;&gt; = </span><span class="s4">typeof </span><span class="s2">Http2ServerResponse,</span>
    <span class="s2">&gt; </span><span class="s4">extends </span><span class="s2">SecureServerSessionOptions&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt; {</span>
        <span class="s2">allowHTTP1?: boolean | undefined;</span>
        <span class="s2">origins?: string[] | undefined;</span>
    <span class="s2">}</span>
    <span class="s4">interface </span><span class="s2">HTTP2ServerCommon {</span>
        <span class="s2">setTimeout(msec?: number, callback?: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Throws ERR_HTTP2_INVALID_SETTING_VALUE for invalid settings values.</span>
         <span class="s0">* Throws ERR_INVALID_ARG_TYPE for invalid settings argument.</span>
         <span class="s0">*/</span>
        <span class="s2">updateSettings(settings: Settings): </span><span class="s4">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">export interface </span><span class="s2">Http2Server&lt;</span>
        <span class="s2">Http1Request </span><span class="s4">extends typeof </span><span class="s2">IncomingMessage = </span><span class="s4">typeof </span><span class="s2">IncomingMessage,</span>
        <span class="s2">Http1Response </span><span class="s4">extends typeof </span><span class="s2">ServerResponse&lt;InstanceType&lt;Http1Request&gt;&gt; = </span><span class="s4">typeof </span><span class="s2">ServerResponse,</span>
        <span class="s2">Http2Request </span><span class="s4">extends typeof </span><span class="s2">Http2ServerRequest = </span><span class="s4">typeof </span><span class="s2">Http2ServerRequest,</span>
        <span class="s2">Http2Response </span><span class="s4">extends typeof </span><span class="s2">Http2ServerResponse&lt;InstanceType&lt;Http2Request&gt;&gt; = </span><span class="s4">typeof </span><span class="s2">Http2ServerResponse,</span>
    <span class="s2">&gt; </span><span class="s4">extends </span><span class="s2">net.Server, HTTP2ServerCommon {</span>
        <span class="s2">addListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;checkContinue&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (request: InstanceType&lt;Http2Request&gt;, response: InstanceType&lt;Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;request&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (request: InstanceType&lt;Http2Request&gt;, response: InstanceType&lt;Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;session&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (session: ServerHttp2Session&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;sessionError&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;stream&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;timeout&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">emit(</span>
            <span class="s2">event: </span><span class="s3">&quot;checkContinue&quot;</span><span class="s2">,</span>
            <span class="s2">request: InstanceType&lt;Http2Request&gt;,</span>
            <span class="s2">response: InstanceType&lt;Http2Response&gt;,</span>
        <span class="s2">): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;request&quot;</span><span class="s2">, request: InstanceType&lt;Http2Request&gt;, response: InstanceType&lt;Http2Response&gt;): boolean;</span>
        <span class="s2">emit(</span>
            <span class="s2">event: </span><span class="s3">&quot;session&quot;</span><span class="s2">,</span>
            <span class="s2">session: ServerHttp2Session&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;,</span>
        <span class="s2">): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;sessionError&quot;</span><span class="s2">, err: Error): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;stream&quot;</span><span class="s2">, stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;timeout&quot;</span><span class="s2">): boolean;</span>
        <span class="s2">emit(event: string | symbol, ...args: any[]): boolean;</span>
        <span class="s2">on(</span>
            <span class="s2">event: </span><span class="s3">&quot;checkContinue&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (request: InstanceType&lt;Http2Request&gt;, response: InstanceType&lt;Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(</span>
            <span class="s2">event: </span><span class="s3">&quot;request&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (request: InstanceType&lt;Http2Request&gt;, response: InstanceType&lt;Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(</span>
            <span class="s2">event: </span><span class="s3">&quot;session&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (session: ServerHttp2Session&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;sessionError&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(</span>
            <span class="s2">event: </span><span class="s3">&quot;stream&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;timeout&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(</span>
            <span class="s2">event: </span><span class="s3">&quot;checkContinue&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (request: InstanceType&lt;Http2Request&gt;, response: InstanceType&lt;Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(</span>
            <span class="s2">event: </span><span class="s3">&quot;request&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (request: InstanceType&lt;Http2Request&gt;, response: InstanceType&lt;Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(</span>
            <span class="s2">event: </span><span class="s3">&quot;session&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (session: ServerHttp2Session&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;sessionError&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(</span>
            <span class="s2">event: </span><span class="s3">&quot;stream&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;timeout&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;checkContinue&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (request: InstanceType&lt;Http2Request&gt;, response: InstanceType&lt;Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;request&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (request: InstanceType&lt;Http2Request&gt;, response: InstanceType&lt;Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;session&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (session: ServerHttp2Session&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;sessionError&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;stream&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;timeout&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;checkContinue&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (request: InstanceType&lt;Http2Request&gt;, response: InstanceType&lt;Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;request&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (request: InstanceType&lt;Http2Request&gt;, response: InstanceType&lt;Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;session&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (session: ServerHttp2Session&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;sessionError&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;stream&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;timeout&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">export interface </span><span class="s2">Http2SecureServer&lt;</span>
        <span class="s2">Http1Request </span><span class="s4">extends typeof </span><span class="s2">IncomingMessage = </span><span class="s4">typeof </span><span class="s2">IncomingMessage,</span>
        <span class="s2">Http1Response </span><span class="s4">extends typeof </span><span class="s2">ServerResponse&lt;InstanceType&lt;Http1Request&gt;&gt; = </span><span class="s4">typeof </span><span class="s2">ServerResponse,</span>
        <span class="s2">Http2Request </span><span class="s4">extends typeof </span><span class="s2">Http2ServerRequest = </span><span class="s4">typeof </span><span class="s2">Http2ServerRequest,</span>
        <span class="s2">Http2Response </span><span class="s4">extends typeof </span><span class="s2">Http2ServerResponse&lt;InstanceType&lt;Http2Request&gt;&gt; = </span><span class="s4">typeof </span><span class="s2">Http2ServerResponse,</span>
    <span class="s2">&gt; </span><span class="s4">extends </span><span class="s2">tls.Server, HTTP2ServerCommon {</span>
        <span class="s2">addListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;checkContinue&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (request: InstanceType&lt;Http2Request&gt;, response: InstanceType&lt;Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;request&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (request: InstanceType&lt;Http2Request&gt;, response: InstanceType&lt;Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;session&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (session: ServerHttp2Session&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;sessionError&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;stream&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;timeout&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;unknownProtocol&quot;</span><span class="s2">, listener: (socket: tls.TLSSocket) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">emit(</span>
            <span class="s2">event: </span><span class="s3">&quot;checkContinue&quot;</span><span class="s2">,</span>
            <span class="s2">request: InstanceType&lt;Http2Request&gt;,</span>
            <span class="s2">response: InstanceType&lt;Http2Response&gt;,</span>
        <span class="s2">): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;request&quot;</span><span class="s2">, request: InstanceType&lt;Http2Request&gt;, response: InstanceType&lt;Http2Response&gt;): boolean;</span>
        <span class="s2">emit(</span>
            <span class="s2">event: </span><span class="s3">&quot;session&quot;</span><span class="s2">,</span>
            <span class="s2">session: ServerHttp2Session&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;,</span>
        <span class="s2">): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;sessionError&quot;</span><span class="s2">, err: Error): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;stream&quot;</span><span class="s2">, stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;timeout&quot;</span><span class="s2">): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;unknownProtocol&quot;</span><span class="s2">, socket: tls.TLSSocket): boolean;</span>
        <span class="s2">emit(event: string | symbol, ...args: any[]): boolean;</span>
        <span class="s2">on(</span>
            <span class="s2">event: </span><span class="s3">&quot;checkContinue&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (request: InstanceType&lt;Http2Request&gt;, response: InstanceType&lt;Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(</span>
            <span class="s2">event: </span><span class="s3">&quot;request&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (request: InstanceType&lt;Http2Request&gt;, response: InstanceType&lt;Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(</span>
            <span class="s2">event: </span><span class="s3">&quot;session&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (session: ServerHttp2Session&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;sessionError&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(</span>
            <span class="s2">event: </span><span class="s3">&quot;stream&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;timeout&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;unknownProtocol&quot;</span><span class="s2">, listener: (socket: tls.TLSSocket) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(</span>
            <span class="s2">event: </span><span class="s3">&quot;checkContinue&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (request: InstanceType&lt;Http2Request&gt;, response: InstanceType&lt;Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(</span>
            <span class="s2">event: </span><span class="s3">&quot;request&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (request: InstanceType&lt;Http2Request&gt;, response: InstanceType&lt;Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(</span>
            <span class="s2">event: </span><span class="s3">&quot;session&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (session: ServerHttp2Session&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;sessionError&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(</span>
            <span class="s2">event: </span><span class="s3">&quot;stream&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;timeout&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;unknownProtocol&quot;</span><span class="s2">, listener: (socket: tls.TLSSocket) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;checkContinue&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (request: InstanceType&lt;Http2Request&gt;, response: InstanceType&lt;Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;request&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (request: InstanceType&lt;Http2Request&gt;, response: InstanceType&lt;Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;session&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (session: ServerHttp2Session&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;sessionError&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;stream&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;timeout&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;unknownProtocol&quot;</span><span class="s2">, listener: (socket: tls.TLSSocket) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;checkContinue&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (request: InstanceType&lt;Http2Request&gt;, response: InstanceType&lt;Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;request&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (request: InstanceType&lt;Http2Request&gt;, response: InstanceType&lt;Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;session&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (session: ServerHttp2Session&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;sessionError&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(</span>
            <span class="s2">event: </span><span class="s3">&quot;stream&quot;</span><span class="s2">,</span>
            <span class="s2">listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;timeout&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;unknownProtocol&quot;</span><span class="s2">, listener: (socket: tls.TLSSocket) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A `Http2ServerRequest` object is created by {</span><span class="s1">@link </span><span class="s0">Server} or {</span><span class="s1">@link </span><span class="s0">SecureServer} and passed as the first argument to the `'request'` event. It may be used to access a request status,</span>
     <span class="s0">* headers, and</span>
     <span class="s0">* data.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
     <span class="s0">*/</span>
    <span class="s4">export class </span><span class="s2">Http2ServerRequest </span><span class="s4">extends </span><span class="s2">stream.Readable {</span>
        <span class="s2">constructor(</span>
            <span class="s2">stream: ServerHttp2Stream,</span>
            <span class="s2">headers: IncomingHttpHeaders,</span>
            <span class="s2">options: stream.ReadableOptions,</span>
            <span class="s2">rawHeaders: readonly string[],</span>
        <span class="s2">);</span>
        <span class="s0">/**</span>
         <span class="s0">* The `request.aborted` property will be `true` if the request has</span>
         <span class="s0">* been aborted.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v10.1.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly aborted: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* The request authority pseudo header field. Because HTTP/2 allows requests</span>
         <span class="s0">* to set either `:authority` or `host`, this value is derived from `req.headers[':authority']` if present. Otherwise, it is derived from `req.headers['host']`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly authority: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* See `request.socket`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">* </span><span class="s1">@deprecated </span><span class="s0">Since v13.0.0 - Use `socket`.</span>
         <span class="s0">*/</span>
        <span class="s2">readonly connection: net.Socket | tls.TLSSocket;</span>
        <span class="s0">/**</span>
         <span class="s0">* The `request.complete` property will be `true` if the request has</span>
         <span class="s0">* been completed, aborted, or destroyed.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v12.10.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly complete: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* The request/response headers object.</span>
         <span class="s0">*</span>
         <span class="s0">* Key-value pairs of header names and values. Header names are lower-cased.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* // Prints something like:</span>
         <span class="s0">* //</span>
         <span class="s0">* // { 'user-agent': 'curl/7.22.0',</span>
         <span class="s0">* //   host: '127.0.0.1:8000',</span>
         <span class="s0">* //   accept: '*' }</span>
         <span class="s0">* console.log(request.headers);</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* See `HTTP/2 Headers Object`.</span>
         <span class="s0">*</span>
         <span class="s0">* In HTTP/2, the request path, host name, protocol, and method are represented as</span>
         <span class="s0">* special headers prefixed with the `:` character (e.g. `':path'`). These special</span>
         <span class="s0">* headers will be included in the `request.headers` object. Care must be taken not</span>
         <span class="s0">* to inadvertently modify these special headers or errors may occur. For instance,</span>
         <span class="s0">* removing all headers from the request will cause errors to occur:</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* removeAllHeaders(request.headers);</span>
         <span class="s0">* assert(request.url);   // Fails because the :path header has been removed</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly headers: IncomingHttpHeaders;</span>
        <span class="s0">/**</span>
         <span class="s0">* In case of server request, the HTTP version sent by the client. In the case of</span>
         <span class="s0">* client response, the HTTP version of the connected-to server. Returns `'2.0'`.</span>
         <span class="s0">*</span>
         <span class="s0">* Also `message.httpVersionMajor` is the first integer and `message.httpVersionMinor` is the second.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly httpVersion: string;</span>
        <span class="s2">readonly httpVersionMinor: number;</span>
        <span class="s2">readonly httpVersionMajor: number;</span>
        <span class="s0">/**</span>
         <span class="s0">* The request method as a string. Read-only. Examples: `'GET'`, `'DELETE'`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly method: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* The raw request/response headers list exactly as they were received.</span>
         <span class="s0">*</span>
         <span class="s0">* The keys and values are in the same list. It is _not_ a</span>
         <span class="s0">* list of tuples. So, the even-numbered offsets are key values, and the</span>
         <span class="s0">* odd-numbered offsets are the associated values.</span>
         <span class="s0">*</span>
         <span class="s0">* Header names are not lowercased, and duplicates are not merged.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* // Prints something like:</span>
         <span class="s0">* //</span>
         <span class="s0">* // [ 'user-agent',</span>
         <span class="s0">* //   'this is invalid because there can be only one',</span>
         <span class="s0">* //   'User-Agent',</span>
         <span class="s0">* //   'curl/7.22.0',</span>
         <span class="s0">* //   'Host',</span>
         <span class="s0">* //   '127.0.0.1:8000',</span>
         <span class="s0">* //   'ACCEPT',</span>
         <span class="s0">* //   '*' ]</span>
         <span class="s0">* console.log(request.rawHeaders);</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly rawHeaders: string[];</span>
        <span class="s0">/**</span>
         <span class="s0">* The raw request/response trailer keys and values exactly as they were</span>
         <span class="s0">* received. Only populated at the `'end'` event.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly rawTrailers: string[];</span>
        <span class="s0">/**</span>
         <span class="s0">* The request scheme pseudo header field indicating the scheme</span>
         <span class="s0">* portion of the target URL.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly scheme: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns a `Proxy` object that acts as a `net.Socket` (or `tls.TLSSocket`) but</span>
         <span class="s0">* applies getters, setters, and methods based on HTTP/2 logic.</span>
         <span class="s0">*</span>
         <span class="s0">* `destroyed`, `readable`, and `writable` properties will be retrieved from and</span>
         <span class="s0">* set on `request.stream`.</span>
         <span class="s0">*</span>
         <span class="s0">* `destroy`, `emit`, `end`, `on` and `once` methods will be called on `request.stream`.</span>
         <span class="s0">*</span>
         <span class="s0">* `setTimeout` method will be called on `request.stream.session`.</span>
         <span class="s0">*</span>
         <span class="s0">* `pause`, `read`, `resume`, and `write` will throw an error with code `ERR_HTTP2_NO_SOCKET_MANIPULATION`. See `Http2Session and Sockets` for</span>
         <span class="s0">* more information.</span>
         <span class="s0">*</span>
         <span class="s0">* All other interactions will be routed directly to the socket. With TLS support,</span>
         <span class="s0">* use `request.socket.getPeerCertificate()` to obtain the client's</span>
         <span class="s0">* authentication details.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly socket: net.Socket | tls.TLSSocket;</span>
        <span class="s0">/**</span>
         <span class="s0">* The `Http2Stream` object backing the request.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly stream: ServerHttp2Stream;</span>
        <span class="s0">/**</span>
         <span class="s0">* The request/response trailers object. Only populated at the `'end'` event.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly trailers: IncomingHttpHeaders;</span>
        <span class="s0">/**</span>
         <span class="s0">* Request URL string. This contains only the URL that is present in the actual</span>
         <span class="s0">* HTTP request. If the request is:</span>
         <span class="s0">*</span>
         <span class="s0">* ```http</span>
         <span class="s0">* GET /status?name=ryan HTTP/1.1</span>
         <span class="s0">* Accept: text/plain</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* Then `request.url` will be:</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* '/status?name=ryan'</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* To parse the url into its parts, `new URL()` can be used:</span>
         <span class="s0">*</span>
         <span class="s0">* ```console</span>
         <span class="s0">* $ node</span>
         <span class="s0">* &gt; new URL('/status?name=ryan', 'http://example.com')</span>
         <span class="s0">* URL {</span>
         <span class="s0">*   href: 'http://example.com/status?name=ryan',</span>
         <span class="s0">*   origin: 'http://example.com',</span>
         <span class="s0">*   protocol: 'http:',</span>
         <span class="s0">*   username: '',</span>
         <span class="s0">*   password: '',</span>
         <span class="s0">*   host: 'example.com',</span>
         <span class="s0">*   hostname: 'example.com',</span>
         <span class="s0">*   port: '',</span>
         <span class="s0">*   pathname: '/status',</span>
         <span class="s0">*   search: '?name=ryan',</span>
         <span class="s0">*   searchParams: URLSearchParams { 'name' =&gt; 'ryan' },</span>
         <span class="s0">*   hash: ''</span>
         <span class="s0">* }</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">url: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sets the `Http2Stream`'s timeout value to `msecs`. If a callback is</span>
         <span class="s0">* provided, then it is added as a listener on the `'timeout'` event on</span>
         <span class="s0">* the response object.</span>
         <span class="s0">*</span>
         <span class="s0">* If no `'timeout'` listener is added to the request, the response, or</span>
         <span class="s0">* the server, then `Http2Stream`s are destroyed when they time out. If a</span>
         <span class="s0">* handler is assigned to the request, the response, or the server's `'timeout'`events, timed out sockets must be handled explicitly.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">setTimeout(msecs: number, callback?: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s2">read(size?: number): Buffer | string | </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;aborted&quot;</span><span class="s2">, listener: (hadError: boolean, code: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;close&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;data&quot;</span><span class="s2">, listener: (chunk: Buffer | string) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;end&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;readable&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;error&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;aborted&quot;</span><span class="s2">, hadError: boolean, code: number): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;close&quot;</span><span class="s2">): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;data&quot;</span><span class="s2">, chunk: Buffer | string): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;end&quot;</span><span class="s2">): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;readable&quot;</span><span class="s2">): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;error&quot;</span><span class="s2">, err: Error): boolean;</span>
        <span class="s2">emit(event: string | symbol, ...args: any[]): boolean;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;aborted&quot;</span><span class="s2">, listener: (hadError: boolean, code: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;close&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;data&quot;</span><span class="s2">, listener: (chunk: Buffer | string) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;end&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;readable&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;error&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;aborted&quot;</span><span class="s2">, listener: (hadError: boolean, code: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;close&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;data&quot;</span><span class="s2">, listener: (chunk: Buffer | string) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;end&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;readable&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;error&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;aborted&quot;</span><span class="s2">, listener: (hadError: boolean, code: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;close&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;data&quot;</span><span class="s2">, listener: (chunk: Buffer | string) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;end&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;readable&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;error&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;aborted&quot;</span><span class="s2">, listener: (hadError: boolean, code: number) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;close&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;data&quot;</span><span class="s2">, listener: (chunk: Buffer | string) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;end&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;readable&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;error&quot;</span><span class="s2">, listener: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s0">/**</span>
     <span class="s0">* This object is created internally by an HTTP server, not by the user. It is</span>
     <span class="s0">* passed as the second parameter to the `'request'` event.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
     <span class="s0">*/</span>
    <span class="s4">export class </span><span class="s2">Http2ServerResponse&lt;Request </span><span class="s4">extends </span><span class="s2">Http2ServerRequest = Http2ServerRequest&gt; </span><span class="s4">extends </span><span class="s2">stream.Writable {</span>
        <span class="s2">constructor(stream: ServerHttp2Stream);</span>
        <span class="s0">/**</span>
         <span class="s0">* See `response.socket`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">* </span><span class="s1">@deprecated </span><span class="s0">Since v13.0.0 - Use `socket`.</span>
         <span class="s0">*/</span>
        <span class="s2">readonly connection: net.Socket | tls.TLSSocket;</span>
        <span class="s0">/**</span>
         <span class="s0">* Append a single header value to the header object.</span>
         <span class="s0">*</span>
         <span class="s0">* If the value is an array, this is equivalent to calling this method multiple times.</span>
         <span class="s0">*</span>
         <span class="s0">* If there were no previous values for the header, this is equivalent to calling {</span><span class="s1">@link </span><span class="s0">setHeader}.</span>
         <span class="s0">*</span>
         <span class="s0">* Attempting to set a header field name or value that contains invalid characters will result in a</span>
         <span class="s0">* [TypeError](https://nodejs.org/docs/latest-v20.x/api/errors.html#class-typeerror) being thrown.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* // Returns headers including &quot;set-cookie: a&quot; and &quot;set-cookie: b&quot;</span>
         <span class="s0">* const server = http2.createServer((req, res) =&gt; {</span>
         <span class="s0">*   res.setHeader('set-cookie', 'a');</span>
         <span class="s0">*   res.appendHeader('set-cookie', 'b');</span>
         <span class="s0">*   res.writeHead(200);</span>
         <span class="s0">*   res.end('ok');</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.12.0</span>
         <span class="s0">*/</span>
        <span class="s2">appendHeader(name: string, value: string | string[]): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Boolean value that indicates whether the response has completed. Starts</span>
         <span class="s0">* as `false`. After `response.end()` executes, the value will be `true`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">* </span><span class="s1">@deprecated </span><span class="s0">Since v13.4.0,v12.16.0 - Use `writableEnded`.</span>
         <span class="s0">*/</span>
        <span class="s2">readonly finished: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* True if headers were sent, false otherwise (read-only).</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly headersSent: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* A reference to the original HTTP2 `request` object.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v15.7.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly req: Request;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns a `Proxy` object that acts as a `net.Socket` (or `tls.TLSSocket`) but</span>
         <span class="s0">* applies getters, setters, and methods based on HTTP/2 logic.</span>
         <span class="s0">*</span>
         <span class="s0">* `destroyed`, `readable`, and `writable` properties will be retrieved from and</span>
         <span class="s0">* set on `response.stream`.</span>
         <span class="s0">*</span>
         <span class="s0">* `destroy`, `emit`, `end`, `on` and `once` methods will be called on `response.stream`.</span>
         <span class="s0">*</span>
         <span class="s0">* `setTimeout` method will be called on `response.stream.session`.</span>
         <span class="s0">*</span>
         <span class="s0">* `pause`, `read`, `resume`, and `write` will throw an error with code `ERR_HTTP2_NO_SOCKET_MANIPULATION`. See `Http2Session and Sockets` for</span>
         <span class="s0">* more information.</span>
         <span class="s0">*</span>
         <span class="s0">* All other interactions will be routed directly to the socket.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import http2 from 'node:http2';</span>
         <span class="s0">* const server = http2.createServer((req, res) =&gt; {</span>
         <span class="s0">*   const ip = req.socket.remoteAddress;</span>
         <span class="s0">*   const port = req.socket.remotePort;</span>
         <span class="s0">*   res.end(`Your IP address is ${ip} and your source port is ${port}.`);</span>
         <span class="s0">* }).listen(3000);</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly socket: net.Socket | tls.TLSSocket;</span>
        <span class="s0">/**</span>
         <span class="s0">* The `Http2Stream` object backing the response.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly stream: ServerHttp2Stream;</span>
        <span class="s0">/**</span>
         <span class="s0">* When true, the Date header will be automatically generated and sent in</span>
         <span class="s0">* the response if it is not already present in the headers. Defaults to true.</span>
         <span class="s0">*</span>
         <span class="s0">* This should only be disabled for testing; HTTP requires the Date header</span>
         <span class="s0">* in responses.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">sendDate: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* When using implicit headers (not calling `response.writeHead()` explicitly),</span>
         <span class="s0">* this property controls the status code that will be sent to the client when</span>
         <span class="s0">* the headers get flushed.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* response.statusCode = 404;</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* After response header was sent to the client, this property indicates the</span>
         <span class="s0">* status code which was sent out.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">statusCode: number;</span>
        <span class="s0">/**</span>
         <span class="s0">* Status message is not supported by HTTP/2 (RFC 7540 8.1.2.4). It returns</span>
         <span class="s0">* an empty string.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">statusMessage: </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This method adds HTTP trailing headers (a header but at the end of the</span>
         <span class="s0">* message) to the response.</span>
         <span class="s0">*</span>
         <span class="s0">* Attempting to set a header field name or value that contains invalid characters</span>
         <span class="s0">* will result in a `TypeError` being thrown.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">addTrailers(trailers: OutgoingHttpHeaders): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This method signals to the server that all of the response headers and body</span>
         <span class="s0">* have been sent; that server should consider this message complete.</span>
         <span class="s0">* The method, `response.end()`, MUST be called on each response.</span>
         <span class="s0">*</span>
         <span class="s0">* If `data` is specified, it is equivalent to calling `response.write(data, encoding)` followed by `response.end(callback)`.</span>
         <span class="s0">*</span>
         <span class="s0">* If `callback` is specified, it will be called when the response stream</span>
         <span class="s0">* is finished.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">end(callback?: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">end(data: string | Uint8Array, callback?: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">end(data: string | Uint8Array, encoding: BufferEncoding, callback?: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Reads out a header that has already been queued but not sent to the client.</span>
         <span class="s0">* The name is case-insensitive.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* const contentType = response.getHeader('content-type');</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">getHeader(name: string): string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns an array containing the unique names of the current outgoing headers.</span>
         <span class="s0">* All header names are lowercase.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* response.setHeader('Foo', 'bar');</span>
         <span class="s0">* response.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);</span>
         <span class="s0">*</span>
         <span class="s0">* const headerNames = response.getHeaderNames();</span>
         <span class="s0">* // headerNames === ['foo', 'set-cookie']</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">getHeaderNames(): string[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns a shallow copy of the current outgoing headers. Since a shallow copy</span>
         <span class="s0">* is used, array values may be mutated without additional calls to various</span>
         <span class="s0">* header-related http module methods. The keys of the returned object are the</span>
         <span class="s0">* header names and the values are the respective header values. All header names</span>
         <span class="s0">* are lowercase.</span>
         <span class="s0">*</span>
         <span class="s0">* The object returned by the `response.getHeaders()` method _does not_ prototypically inherit from the JavaScript `Object`. This means that typical `Object` methods such as `obj.toString()`,</span>
         <span class="s0">* `obj.hasOwnProperty()`, and others</span>
         <span class="s0">* are not defined and _will not work_.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* response.setHeader('Foo', 'bar');</span>
         <span class="s0">* response.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);</span>
         <span class="s0">*</span>
         <span class="s0">* const headers = response.getHeaders();</span>
         <span class="s0">* // headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">getHeaders(): OutgoingHttpHeaders;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns `true` if the header identified by `name` is currently set in the</span>
         <span class="s0">* outgoing headers. The header name matching is case-insensitive.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* const hasContentType = response.hasHeader('content-type');</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">hasHeader(name: string): boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Removes a header that has been queued for implicit sending.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* response.removeHeader('Content-Encoding');</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">removeHeader(name: string): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sets a single header value for implicit headers. If this header already exists</span>
         <span class="s0">* in the to-be-sent headers, its value will be replaced. Use an array of strings</span>
         <span class="s0">* here to send multiple headers with the same name.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* response.setHeader('Content-Type', 'text/html; charset=utf-8');</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* or</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* response.setHeader('Set-Cookie', ['type=ninja', 'language=javascript']);</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* Attempting to set a header field name or value that contains invalid characters</span>
         <span class="s0">* will result in a `TypeError` being thrown.</span>
         <span class="s0">*</span>
         <span class="s0">* When headers have been set with `response.setHeader()`, they will be merged</span>
         <span class="s0">* with any headers passed to `response.writeHead()`, with the headers passed</span>
         <span class="s0">* to `response.writeHead()` given precedence.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* // Returns content-type = text/plain</span>
         <span class="s0">* const server = http2.createServer((req, res) =&gt; {</span>
         <span class="s0">*   res.setHeader('Content-Type', 'text/html; charset=utf-8');</span>
         <span class="s0">*   res.setHeader('X-Foo', 'bar');</span>
         <span class="s0">*   res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });</span>
         <span class="s0">*   res.end('ok');</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">setHeader(name: string, value: number | string | readonly string[]): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sets the `Http2Stream`'s timeout value to `msecs`. If a callback is</span>
         <span class="s0">* provided, then it is added as a listener on the `'timeout'` event on</span>
         <span class="s0">* the response object.</span>
         <span class="s0">*</span>
         <span class="s0">* If no `'timeout'` listener is added to the request, the response, or</span>
         <span class="s0">* the server, then `Http2Stream` s are destroyed when they time out. If a</span>
         <span class="s0">* handler is assigned to the request, the response, or the server's `'timeout'` events, timed out sockets must be handled explicitly.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">setTimeout(msecs: number, callback?: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If this method is called and `response.writeHead()` has not been called,</span>
         <span class="s0">* it will switch to implicit header mode and flush the implicit headers.</span>
         <span class="s0">*</span>
         <span class="s0">* This sends a chunk of the response body. This method may</span>
         <span class="s0">* be called multiple times to provide successive parts of the body.</span>
         <span class="s0">*</span>
         <span class="s0">* In the `node:http` module, the response body is omitted when the</span>
         <span class="s0">* request is a HEAD request. Similarly, the `204` and `304` responses _must not_ include a message body.</span>
         <span class="s0">*</span>
         <span class="s0">* `chunk` can be a string or a buffer. If `chunk` is a string,</span>
         <span class="s0">* the second parameter specifies how to encode it into a byte stream.</span>
         <span class="s0">* By default the `encoding` is `'utf8'`. `callback` will be called when this chunk</span>
         <span class="s0">* of data is flushed.</span>
         <span class="s0">*</span>
         <span class="s0">* This is the raw HTTP body and has nothing to do with higher-level multi-part</span>
         <span class="s0">* body encodings that may be used.</span>
         <span class="s0">*</span>
         <span class="s0">* The first time `response.write()` is called, it will send the buffered</span>
         <span class="s0">* header information and the first chunk of the body to the client. The second</span>
         <span class="s0">* time `response.write()` is called, Node.js assumes data will be streamed,</span>
         <span class="s0">* and sends the new data separately. That is, the response is buffered up to the</span>
         <span class="s0">* first chunk of the body.</span>
         <span class="s0">*</span>
         <span class="s0">* Returns `true` if the entire data was flushed successfully to the kernel</span>
         <span class="s0">* buffer. Returns `false` if all or part of the data was queued in user memory.`'drain'` will be emitted when the buffer is free again.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">write(chunk: string | Uint8Array, callback?: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): boolean;</span>
        <span class="s2">write(chunk: string | Uint8Array, encoding: BufferEncoding, callback?: (err: Error) =&gt; </span><span class="s4">void</span><span class="s2">): boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sends a status `100 Continue` to the client, indicating that the request body</span>
         <span class="s0">* should be sent. See the `'checkContinue'` event on `Http2Server` and `Http2SecureServer`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">writeContinue(): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sends a status `103 Early Hints` to the client with a Link header,</span>
         <span class="s0">* indicating that the user agent can preload/preconnect the linked resources.</span>
         <span class="s0">* The `hints` is an object containing the values of headers to be sent with</span>
         <span class="s0">* early hints message.</span>
         <span class="s0">*</span>
         <span class="s0">* **Example**</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* const earlyHintsLink = '&lt;/styles.css&gt;; rel=preload; as=style';</span>
         <span class="s0">* response.writeEarlyHints({</span>
         <span class="s0">*   'link': earlyHintsLink,</span>
         <span class="s0">* });</span>
         <span class="s0">*</span>
         <span class="s0">* const earlyHintsLinks = [</span>
         <span class="s0">*   '&lt;/styles.css&gt;; rel=preload; as=style',</span>
         <span class="s0">*   '&lt;/scripts.js&gt;; rel=preload; as=script',</span>
         <span class="s0">* ];</span>
         <span class="s0">* response.writeEarlyHints({</span>
         <span class="s0">*   'link': earlyHintsLinks,</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.11.0</span>
         <span class="s0">*/</span>
        <span class="s2">writeEarlyHints(hints: Record&lt;string, string | string[]&gt;): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sends a response header to the request. The status code is a 3-digit HTTP</span>
         <span class="s0">* status code, like `404`. The last argument, `headers`, are the response headers.</span>
         <span class="s0">*</span>
         <span class="s0">* Returns a reference to the `Http2ServerResponse`, so that calls can be chained.</span>
         <span class="s0">*</span>
         <span class="s0">* For compatibility with `HTTP/1`, a human-readable `statusMessage` may be</span>
         <span class="s0">* passed as the second argument. However, because the `statusMessage` has no</span>
         <span class="s0">* meaning within HTTP/2, the argument will have no effect and a process warning</span>
         <span class="s0">* will be emitted.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* const body = 'hello world';</span>
         <span class="s0">* response.writeHead(200, {</span>
         <span class="s0">*   'Content-Length': Buffer.byteLength(body),</span>
         <span class="s0">*   'Content-Type': 'text/plain; charset=utf-8',</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* `Content-Length` is given in bytes not characters. The`Buffer.byteLength()` API may be used to determine the number of bytes in a</span>
         <span class="s0">* given encoding. On outbound messages, Node.js does not check if Content-Length</span>
         <span class="s0">* and the length of the body being transmitted are equal or not. However, when</span>
         <span class="s0">* receiving messages, Node.js will automatically reject messages when the `Content-Length` does not match the actual payload size.</span>
         <span class="s0">*</span>
         <span class="s0">* This method may be called at most one time on a message before `response.end()` is called.</span>
         <span class="s0">*</span>
         <span class="s0">* If `response.write()` or `response.end()` are called before calling</span>
         <span class="s0">* this, the implicit/mutable headers will be calculated and call this function.</span>
         <span class="s0">*</span>
         <span class="s0">* When headers have been set with `response.setHeader()`, they will be merged</span>
         <span class="s0">* with any headers passed to `response.writeHead()`, with the headers passed</span>
         <span class="s0">* to `response.writeHead()` given precedence.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* // Returns content-type = text/plain</span>
         <span class="s0">* const server = http2.createServer((req, res) =&gt; {</span>
         <span class="s0">*   res.setHeader('Content-Type', 'text/html; charset=utf-8');</span>
         <span class="s0">*   res.setHeader('X-Foo', 'bar');</span>
         <span class="s0">*   res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });</span>
         <span class="s0">*   res.end('ok');</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* Attempting to set a header field name or value that contains invalid characters</span>
         <span class="s0">* will result in a `TypeError` being thrown.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">writeHead(statusCode: number, headers?: OutgoingHttpHeaders): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">writeHead(statusCode: number, statusMessage: string, headers?: OutgoingHttpHeaders): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Call `http2stream.pushStream()` with the given headers, and wrap the</span>
         <span class="s0">* given `Http2Stream` on a newly created `Http2ServerResponse` as the callback</span>
         <span class="s0">* parameter if successful. When `Http2ServerRequest` is closed, the callback is</span>
         <span class="s0">* called with an error `ERR_HTTP2_INVALID_STREAM`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">headers An object describing the headers</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">callback Called once `http2stream.pushStream()` is finished, or either when the attempt to create the pushed `Http2Stream` has failed or has been rejected, or the state of</span>
         <span class="s0">* `Http2ServerRequest` is closed prior to calling the `http2stream.pushStream()` method</span>
         <span class="s0">*/</span>
        <span class="s2">createPushResponse(</span>
            <span class="s2">headers: OutgoingHttpHeaders,</span>
            <span class="s2">callback: (err: Error | </span><span class="s4">null</span><span class="s2">, res: Http2ServerResponse) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
        <span class="s2">): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;close&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;drain&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;error&quot;</span><span class="s2">, listener: (error: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;finish&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;pipe&quot;</span><span class="s2">, listener: (src: stream.Readable) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: </span><span class="s3">&quot;unpipe&quot;</span><span class="s2">, listener: (src: stream.Readable) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">addListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;close&quot;</span><span class="s2">): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;drain&quot;</span><span class="s2">): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;error&quot;</span><span class="s2">, error: Error): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;finish&quot;</span><span class="s2">): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;pipe&quot;</span><span class="s2">, src: stream.Readable): boolean;</span>
        <span class="s2">emit(event: </span><span class="s3">&quot;unpipe&quot;</span><span class="s2">, src: stream.Readable): boolean;</span>
        <span class="s2">emit(event: string | symbol, ...args: any[]): boolean;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;close&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;drain&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;error&quot;</span><span class="s2">, listener: (error: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;finish&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;pipe&quot;</span><span class="s2">, listener: (src: stream.Readable) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: </span><span class="s3">&quot;unpipe&quot;</span><span class="s2">, listener: (src: stream.Readable) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">on(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;close&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;drain&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;error&quot;</span><span class="s2">, listener: (error: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;finish&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;pipe&quot;</span><span class="s2">, listener: (src: stream.Readable) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: </span><span class="s3">&quot;unpipe&quot;</span><span class="s2">, listener: (src: stream.Readable) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">once(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;close&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;drain&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;error&quot;</span><span class="s2">, listener: (error: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;finish&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;pipe&quot;</span><span class="s2">, listener: (src: stream.Readable) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: </span><span class="s3">&quot;unpipe&quot;</span><span class="s2">, listener: (src: stream.Readable) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;close&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;drain&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;error&quot;</span><span class="s2">, listener: (error: Error) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;finish&quot;</span><span class="s2">, listener: () =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;pipe&quot;</span><span class="s2">, listener: (src: stream.Readable) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: </span><span class="s3">&quot;unpipe&quot;</span><span class="s2">, listener: (src: stream.Readable) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
        <span class="s2">prependOnceListener(event: string | symbol, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s2">): </span><span class="s4">this</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">export </span><span class="s2">namespace constants {</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_SESSION_SERVER: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_SESSION_CLIENT: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_STREAM_STATE_IDLE: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_STREAM_STATE_OPEN: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_STREAM_STATE_RESERVED_LOCAL: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_STREAM_STATE_RESERVED_REMOTE: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_STREAM_STATE_CLOSED: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_NO_ERROR: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_PROTOCOL_ERROR: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_INTERNAL_ERROR: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_FLOW_CONTROL_ERROR: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_SETTINGS_TIMEOUT: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_STREAM_CLOSED: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_FRAME_SIZE_ERROR: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_REFUSED_STREAM: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_CANCEL: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_COMPRESSION_ERROR: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_CONNECT_ERROR: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_ENHANCE_YOUR_CALM: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_INADEQUATE_SECURITY: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_HTTP_1_1_REQUIRED: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_ERR_FRAME_SIZE_ERROR: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_FLAG_NONE: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_FLAG_END_STREAM: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_FLAG_END_HEADERS: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_FLAG_ACK: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_FLAG_PADDED: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_FLAG_PRIORITY: number;</span>
        <span class="s4">const </span><span class="s2">DEFAULT_SETTINGS_HEADER_TABLE_SIZE: number;</span>
        <span class="s4">const </span><span class="s2">DEFAULT_SETTINGS_ENABLE_PUSH: number;</span>
        <span class="s4">const </span><span class="s2">DEFAULT_SETTINGS_INITIAL_WINDOW_SIZE: number;</span>
        <span class="s4">const </span><span class="s2">DEFAULT_SETTINGS_MAX_FRAME_SIZE: number;</span>
        <span class="s4">const </span><span class="s2">MAX_MAX_FRAME_SIZE: number;</span>
        <span class="s4">const </span><span class="s2">MIN_MAX_FRAME_SIZE: number;</span>
        <span class="s4">const </span><span class="s2">MAX_INITIAL_WINDOW_SIZE: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_DEFAULT_WEIGHT: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_SETTINGS_HEADER_TABLE_SIZE: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_SETTINGS_ENABLE_PUSH: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_SETTINGS_MAX_FRAME_SIZE: number;</span>
        <span class="s4">const </span><span class="s2">NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE: number;</span>
        <span class="s4">const </span><span class="s2">PADDING_STRATEGY_NONE: number;</span>
        <span class="s4">const </span><span class="s2">PADDING_STRATEGY_MAX: number;</span>
        <span class="s4">const </span><span class="s2">PADDING_STRATEGY_CALLBACK: number;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_STATUS: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_METHOD: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_AUTHORITY: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_SCHEME: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_PATH: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_ACCEPT_CHARSET: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_ACCEPT_ENCODING: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_ACCEPT_LANGUAGE: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_ACCEPT_RANGES: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_ACCEPT: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_ACCESS_CONTROL_ALLOW_HEADERS: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_ACCESS_CONTROL_ALLOW_METHODS: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_ACCESS_CONTROL_REQUEST_HEADERS: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_ACCESS_CONTROL_REQUEST_METHOD: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_AGE: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_ALLOW: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_AUTHORIZATION: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_CACHE_CONTROL: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_CONNECTION: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_CONTENT_DISPOSITION: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_CONTENT_ENCODING: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_CONTENT_LANGUAGE: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_CONTENT_LENGTH: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_CONTENT_LOCATION: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_CONTENT_MD5: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_CONTENT_RANGE: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_CONTENT_TYPE: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_COOKIE: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_DATE: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_ETAG: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_EXPECT: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_EXPIRES: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_FROM: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_HOST: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_IF_MATCH: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_IF_MODIFIED_SINCE: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_IF_NONE_MATCH: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_IF_RANGE: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_IF_UNMODIFIED_SINCE: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_LAST_MODIFIED: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_LINK: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_LOCATION: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_MAX_FORWARDS: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_PREFER: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_PROXY_AUTHENTICATE: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_PROXY_AUTHORIZATION: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_RANGE: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_REFERER: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_REFRESH: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_RETRY_AFTER: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_SERVER: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_SET_COOKIE: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_STRICT_TRANSPORT_SECURITY: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_TRANSFER_ENCODING: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_TE: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_UPGRADE: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_USER_AGENT: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_VARY: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_VIA: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_WWW_AUTHENTICATE: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_HTTP2_SETTINGS: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_KEEP_ALIVE: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_HEADER_PROXY_CONNECTION: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_ACL: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_BASELINE_CONTROL: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_BIND: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_CHECKIN: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_CHECKOUT: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_CONNECT: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_COPY: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_DELETE: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_GET: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_HEAD: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_LABEL: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_LINK: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_LOCK: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_MERGE: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_MKACTIVITY: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_MKCALENDAR: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_MKCOL: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_MKREDIRECTREF: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_MKWORKSPACE: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_MOVE: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_OPTIONS: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_ORDERPATCH: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_PATCH: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_POST: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_PRI: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_PROPFIND: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_PROPPATCH: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_PUT: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_REBIND: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_REPORT: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_SEARCH: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_TRACE: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_UNBIND: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_UNCHECKOUT: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_UNLINK: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_UNLOCK: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_UPDATE: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_UPDATEREDIRECTREF: string;</span>
        <span class="s4">const </span><span class="s2">HTTP2_METHOD_VERSION_CONTROL: string;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_CONTINUE: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_SWITCHING_PROTOCOLS: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_PROCESSING: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_OK: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_CREATED: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_ACCEPTED: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_NO_CONTENT: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_RESET_CONTENT: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_PARTIAL_CONTENT: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_MULTI_STATUS: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_ALREADY_REPORTED: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_IM_USED: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_MULTIPLE_CHOICES: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_MOVED_PERMANENTLY: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_FOUND: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_SEE_OTHER: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_NOT_MODIFIED: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_USE_PROXY: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_TEMPORARY_REDIRECT: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_PERMANENT_REDIRECT: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_BAD_REQUEST: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_UNAUTHORIZED: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_PAYMENT_REQUIRED: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_FORBIDDEN: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_NOT_FOUND: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_METHOD_NOT_ALLOWED: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_NOT_ACCEPTABLE: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_REQUEST_TIMEOUT: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_CONFLICT: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_GONE: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_LENGTH_REQUIRED: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_PRECONDITION_FAILED: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_PAYLOAD_TOO_LARGE: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_URI_TOO_LONG: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_RANGE_NOT_SATISFIABLE: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_EXPECTATION_FAILED: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_TEAPOT: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_MISDIRECTED_REQUEST: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_UNPROCESSABLE_ENTITY: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_LOCKED: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_FAILED_DEPENDENCY: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_UNORDERED_COLLECTION: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_UPGRADE_REQUIRED: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_PRECONDITION_REQUIRED: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_TOO_MANY_REQUESTS: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_INTERNAL_SERVER_ERROR: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_NOT_IMPLEMENTED: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_BAD_GATEWAY: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_SERVICE_UNAVAILABLE: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_GATEWAY_TIMEOUT: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_VARIANT_ALSO_NEGOTIATES: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_INSUFFICIENT_STORAGE: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_LOOP_DETECTED: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_NOT_EXTENDED: number;</span>
        <span class="s4">const </span><span class="s2">HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED: number;</span>
    <span class="s2">}</span>
    <span class="s0">/**</span>
     <span class="s0">* This symbol can be set as a property on the HTTP/2 headers object with</span>
     <span class="s0">* an array value in order to provide a list of headers considered sensitive.</span>
     <span class="s0">*/</span>
    <span class="s4">export const </span><span class="s2">sensitiveHeaders: symbol;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns an object containing the default settings for an `Http2Session` instance. This method returns a new object instance every time it is called</span>
     <span class="s0">* so instances returned may be safely modified for use.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
     <span class="s0">*/</span>
    <span class="s4">export function </span><span class="s2">getDefaultSettings(): Settings;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns a `Buffer` instance containing serialized representation of the given</span>
     <span class="s0">* HTTP/2 settings as specified in the [HTTP/2](https://tools.ietf.org/html/rfc7540) specification. This is intended</span>
     <span class="s0">* for use with the `HTTP2-Settings` header field.</span>
     <span class="s0">*</span>
     <span class="s0">* ```js</span>
     <span class="s0">* import http2 from 'node:http2';</span>
     <span class="s0">*</span>
     <span class="s0">* const packed = http2.getPackedSettings({ enablePush: false });</span>
     <span class="s0">*</span>
     <span class="s0">* console.log(packed.toString('base64'));</span>
     <span class="s0">* // Prints: AAIAAAAA</span>
     <span class="s0">* ```</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
     <span class="s0">*/</span>
    <span class="s4">export function </span><span class="s2">getPackedSettings(settings: Settings): Buffer;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns a `HTTP/2 Settings Object` containing the deserialized settings from</span>
     <span class="s0">* the given `Buffer` as generated by `http2.getPackedSettings()`.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">buf The packed settings.</span>
     <span class="s0">*/</span>
    <span class="s4">export function </span><span class="s2">getUnpackedSettings(buf: Uint8Array): Settings;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns a `net.Server` instance that creates and manages `Http2Session` instances.</span>
     <span class="s0">*</span>
     <span class="s0">* Since there are no browsers known that support [unencrypted HTTP/2](https://http2.github.io/faq/#does-http2-require-encryption), the use of {</span><span class="s1">@link </span><span class="s0">createSecureServer} is necessary when</span>
     <span class="s0">* communicating</span>
     <span class="s0">* with browser clients.</span>
     <span class="s0">*</span>
     <span class="s0">* ```js</span>
     <span class="s0">* import http2 from 'node:http2';</span>
     <span class="s0">*</span>
     <span class="s0">* // Create an unencrypted HTTP/2 server.</span>
     <span class="s0">* // Since there are no browsers known that support</span>
     <span class="s0">* // unencrypted HTTP/2, the use of `http2.createSecureServer()`</span>
     <span class="s0">* // is necessary when communicating with browser clients.</span>
     <span class="s0">* const server = http2.createServer();</span>
     <span class="s0">*</span>
     <span class="s0">* server.on('stream', (stream, headers) =&gt; {</span>
     <span class="s0">*   stream.respond({</span>
     <span class="s0">*     'content-type': 'text/html; charset=utf-8',</span>
     <span class="s0">*     ':status': 200,</span>
     <span class="s0">*   });</span>
     <span class="s0">*   stream.end('&lt;h1&gt;Hello World&lt;/h1&gt;');</span>
     <span class="s0">* });</span>
     <span class="s0">*</span>
     <span class="s0">* server.listen(8000);</span>
     <span class="s0">* ```</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">onRequestHandler See `Compatibility API`</span>
     <span class="s0">*/</span>
    <span class="s4">export function </span><span class="s2">createServer(</span>
        <span class="s2">onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
    <span class="s2">): Http2Server;</span>
    <span class="s4">export function </span><span class="s2">createServer&lt;</span>
        <span class="s2">Http1Request </span><span class="s4">extends typeof </span><span class="s2">IncomingMessage = </span><span class="s4">typeof </span><span class="s2">IncomingMessage,</span>
        <span class="s2">Http1Response </span><span class="s4">extends typeof </span><span class="s2">ServerResponse&lt;InstanceType&lt;Http1Request&gt;&gt; = </span><span class="s4">typeof </span><span class="s2">ServerResponse,</span>
        <span class="s2">Http2Request </span><span class="s4">extends typeof </span><span class="s2">Http2ServerRequest = </span><span class="s4">typeof </span><span class="s2">Http2ServerRequest,</span>
        <span class="s2">Http2Response </span><span class="s4">extends typeof </span><span class="s2">Http2ServerResponse&lt;InstanceType&lt;Http2Request&gt;&gt; = </span><span class="s4">typeof </span><span class="s2">Http2ServerResponse,</span>
    <span class="s2">&gt;(</span>
        <span class="s2">options: ServerOptions&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;,</span>
        <span class="s2">onRequestHandler?: (request: InstanceType&lt;Http2Request&gt;, response: InstanceType&lt;Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
    <span class="s2">): Http2Server&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns a `tls.Server` instance that creates and manages `Http2Session` instances.</span>
     <span class="s0">*</span>
     <span class="s0">* ```js</span>
     <span class="s0">* import http2 from 'node:http2';</span>
     <span class="s0">* import fs from 'node:fs';</span>
     <span class="s0">*</span>
     <span class="s0">* const options = {</span>
     <span class="s0">*   key: fs.readFileSync('server-key.pem'),</span>
     <span class="s0">*   cert: fs.readFileSync('server-cert.pem'),</span>
     <span class="s0">* };</span>
     <span class="s0">*</span>
     <span class="s0">* // Create a secure HTTP/2 server</span>
     <span class="s0">* const server = http2.createSecureServer(options);</span>
     <span class="s0">*</span>
     <span class="s0">* server.on('stream', (stream, headers) =&gt; {</span>
     <span class="s0">*   stream.respond({</span>
     <span class="s0">*     'content-type': 'text/html; charset=utf-8',</span>
     <span class="s0">*     ':status': 200,</span>
     <span class="s0">*   });</span>
     <span class="s0">*   stream.end('&lt;h1&gt;Hello World&lt;/h1&gt;');</span>
     <span class="s0">* });</span>
     <span class="s0">*</span>
     <span class="s0">* server.listen(8443);</span>
     <span class="s0">* ```</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">onRequestHandler See `Compatibility API`</span>
     <span class="s0">*/</span>
    <span class="s4">export function </span><span class="s2">createSecureServer(</span>
        <span class="s2">onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
    <span class="s2">): Http2SecureServer;</span>
    <span class="s4">export function </span><span class="s2">createSecureServer&lt;</span>
        <span class="s2">Http1Request </span><span class="s4">extends typeof </span><span class="s2">IncomingMessage = </span><span class="s4">typeof </span><span class="s2">IncomingMessage,</span>
        <span class="s2">Http1Response </span><span class="s4">extends typeof </span><span class="s2">ServerResponse&lt;InstanceType&lt;Http1Request&gt;&gt; = </span><span class="s4">typeof </span><span class="s2">ServerResponse,</span>
        <span class="s2">Http2Request </span><span class="s4">extends typeof </span><span class="s2">Http2ServerRequest = </span><span class="s4">typeof </span><span class="s2">Http2ServerRequest,</span>
        <span class="s2">Http2Response </span><span class="s4">extends typeof </span><span class="s2">Http2ServerResponse&lt;InstanceType&lt;Http2Request&gt;&gt; = </span><span class="s4">typeof </span><span class="s2">Http2ServerResponse,</span>
    <span class="s2">&gt;(</span>
        <span class="s2">options: SecureServerOptions&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;,</span>
        <span class="s2">onRequestHandler?: (request: InstanceType&lt;Http2Request&gt;, response: InstanceType&lt;Http2Response&gt;) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
    <span class="s2">): Http2SecureServer&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns a `ClientHttp2Session` instance.</span>
     <span class="s0">*</span>
     <span class="s0">* ```js</span>
     <span class="s0">* import http2 from 'node:http2';</span>
     <span class="s0">* const client = http2.connect('https://localhost:1234');</span>
     <span class="s0">*</span>
     <span class="s0">* // Use the client</span>
     <span class="s0">*</span>
     <span class="s0">* client.close();</span>
     <span class="s0">* ```</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.4.0</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">authority The remote HTTP/2 server to connect to. This must be in the form of a minimal, valid URL with the `http://` or `https://` prefix, host name, and IP port (if a non-default port</span>
     <span class="s0">* is used). Userinfo (user ID and password), path, querystring, and fragment details in the URL will be ignored.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">listener Will be registered as a one-time listener of the {</span><span class="s1">@link </span><span class="s0">'connect'} event.</span>
     <span class="s0">*/</span>
    <span class="s4">export function </span><span class="s2">connect(</span>
        <span class="s2">authority: string | url.URL,</span>
        <span class="s2">listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
    <span class="s2">): ClientHttp2Session;</span>
    <span class="s4">export function </span><span class="s2">connect(</span>
        <span class="s2">authority: string | url.URL,</span>
        <span class="s2">options?: ClientSessionOptions | SecureClientSessionOptions,</span>
        <span class="s2">listener?: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) =&gt; </span><span class="s4">void</span><span class="s2">,</span>
    <span class="s2">): ClientHttp2Session;</span>
    <span class="s0">/**</span>
     <span class="s0">* Create an HTTP/2 server session from an existing socket.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">socket A Duplex Stream</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Any `{@link createServer}` options can be provided.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.12.0</span>
     <span class="s0">*/</span>
    <span class="s4">export function </span><span class="s2">performServerHandshake&lt;</span>
        <span class="s2">Http1Request </span><span class="s4">extends typeof </span><span class="s2">IncomingMessage = </span><span class="s4">typeof </span><span class="s2">IncomingMessage,</span>
        <span class="s2">Http1Response </span><span class="s4">extends typeof </span><span class="s2">ServerResponse&lt;InstanceType&lt;Http1Request&gt;&gt; = </span><span class="s4">typeof </span><span class="s2">ServerResponse,</span>
        <span class="s2">Http2Request </span><span class="s4">extends typeof </span><span class="s2">Http2ServerRequest = </span><span class="s4">typeof </span><span class="s2">Http2ServerRequest,</span>
        <span class="s2">Http2Response </span><span class="s4">extends typeof </span><span class="s2">Http2ServerResponse&lt;InstanceType&lt;Http2Request&gt;&gt; = </span><span class="s4">typeof </span><span class="s2">Http2ServerResponse,</span>
    <span class="s2">&gt;(</span>
        <span class="s2">socket: stream.Duplex,</span>
        <span class="s2">options?: ServerOptions&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;,</span>
    <span class="s2">): ServerHttp2Session&lt;Http1Request, Http1Response, Http2Request, Http2Response&gt;;</span>
<span class="s2">}</span>
<span class="s2">declare module </span><span class="s3">&quot;node:http2&quot; </span><span class="s2">{</span>
    <span class="s4">export </span><span class="s2">* from </span><span class="s3">&quot;http2&quot;</span><span class="s2">;</span>
<span class="s2">}</span>
</pre>
</body>
</html>