<html>
<head>
<title>after-context.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
after-context.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/after/after-context.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import PromiseQueue from 'next/dist/compiled/p-queue'</span><span class="s3">\n</span><span class="s1">import type { RequestLifecycleOpts } from '../base-server'</span><span class="s3">\n</span><span class="s1">import type { AfterCallback, AfterTask } from './after'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../../shared/lib/invariant-error'</span><span class="s3">\n</span><span class="s1">import { isThenable } from '../../shared/lib/is-thenable'</span><span class="s3">\n</span><span class="s1">import { workAsyncStorage } from '../app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { withExecuteRevalidates } from '../revalidation-utils'</span><span class="s3">\n</span><span class="s1">import { bindSnapshot } from '../app-render/async-local-storage'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">workUnitAsyncStorage,</span><span class="s3">\n  </span><span class="s1">type WorkUnitStore,</span><span class="s3">\n</span><span class="s1">} from '../app-render/work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { afterTaskAsyncStorage } from '../app-render/after-task-async-storage.external'</span><span class="s3">\n\n</span><span class="s1">export type AfterContextOpts = {</span><span class="s3">\n  </span><span class="s1">waitUntil: RequestLifecycleOpts['waitUntil'] | undefined</span><span class="s3">\n  </span><span class="s1">onClose: RequestLifecycleOpts['onClose']</span><span class="s3">\n  </span><span class="s1">onTaskError: RequestLifecycleOpts['onAfterTaskError'] | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class AfterContext {</span><span class="s3">\n  </span><span class="s1">private waitUntil: RequestLifecycleOpts['waitUntil'] | undefined</span><span class="s3">\n  </span><span class="s1">private onClose: RequestLifecycleOpts['onClose']</span><span class="s3">\n  </span><span class="s1">private onTaskError: RequestLifecycleOpts['onAfterTaskError'] | undefined</span><span class="s3">\n\n  </span><span class="s1">private runCallbacksOnClosePromise: Promise&lt;void&gt; | undefined</span><span class="s3">\n  </span><span class="s1">private callbackQueue: PromiseQueue</span><span class="s3">\n  </span><span class="s1">private workUnitStores = new Set&lt;WorkUnitStore&gt;()</span><span class="s3">\n\n  </span><span class="s1">constructor({ waitUntil, onClose, onTaskError }: AfterContextOpts) {</span><span class="s3">\n    </span><span class="s1">this.waitUntil = waitUntil</span><span class="s3">\n    </span><span class="s1">this.onClose = onClose</span><span class="s3">\n    </span><span class="s1">this.onTaskError = onTaskError</span><span class="s3">\n\n    </span><span class="s1">this.callbackQueue = new PromiseQueue()</span><span class="s3">\n    </span><span class="s1">this.callbackQueue.pause()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public after(task: AfterTask): void {</span><span class="s3">\n    </span><span class="s1">if (isThenable(task)) {</span><span class="s3">\n      </span><span class="s1">if (!this.waitUntil) {</span><span class="s3">\n        </span><span class="s1">errorWaitUntilNotAvailable()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.waitUntil(</span><span class="s3">\n        </span><span class="s1">task.catch((error) =&gt; this.reportTaskError('promise', error))</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (typeof task === 'function') {</span><span class="s3">\n      </span><span class="s1">// TODO(after): implement tracing</span><span class="s3">\n      </span><span class="s1">this.addCallback(task)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">throw new Error('`after()`: Argument must be a promise or a function')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private addCallback(callback: AfterCallback) {</span><span class="s3">\n    </span><span class="s1">// if something is wrong, throw synchronously, bubbling up to the `after` callsite.</span><span class="s3">\n    </span><span class="s1">if (!this.waitUntil) {</span><span class="s3">\n      </span><span class="s1">errorWaitUntilNotAvailable()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n    </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n      </span><span class="s1">this.workUnitStores.add(workUnitStore)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const afterTaskStore = afterTaskAsyncStorage.getStore()</span><span class="s3">\n\n    </span><span class="s1">// This is used for checking if request APIs can be called inside `after`.</span><span class="s3">\n    </span><span class="s1">// Note that we need to check the phase in which the *topmost* `after` was called (which should be </span><span class="s3">\&quot;</span><span class="s1">action</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">// not the current phase (which might be </span><span class="s3">\&quot;</span><span class="s1">after</span><span class="s3">\&quot; </span><span class="s1">if we're in a nested after).</span><span class="s3">\n    </span><span class="s1">// Otherwise, we might allow `after(() =&gt; headers())`, but not `after(() =&gt; after(() =&gt; headers()))`.</span><span class="s3">\n    </span><span class="s1">const rootTaskSpawnPhase = afterTaskStore</span><span class="s3">\n      </span><span class="s1">? afterTaskStore.rootTaskSpawnPhase // nested after</span><span class="s3">\n      </span><span class="s1">: workUnitStore?.phase // topmost after</span><span class="s3">\n\n    </span><span class="s1">// this should only happen once.</span><span class="s3">\n    </span><span class="s1">if (!this.runCallbacksOnClosePromise) {</span><span class="s3">\n      </span><span class="s1">this.runCallbacksOnClosePromise = this.runCallbacksOnClose()</span><span class="s3">\n      </span><span class="s1">this.waitUntil(this.runCallbacksOnClosePromise)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Bind the callback to the current execution context (i.e. preserve all currently available ALS-es).</span><span class="s3">\n    </span><span class="s1">// We do this because we want all of these to be equivalent in every regard except timing:</span><span class="s3">\n    </span><span class="s1">//   after(() =&gt; x())</span><span class="s3">\n    </span><span class="s1">//   after(x())</span><span class="s3">\n    </span><span class="s1">//   await x()</span><span class="s3">\n    </span><span class="s1">const wrappedCallback = bindSnapshot(async () =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">await afterTaskAsyncStorage.run({ rootTaskSpawnPhase }, () =&gt;</span><span class="s3">\n          </span><span class="s1">callback()</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} catch (error) {</span><span class="s3">\n        </span><span class="s1">this.reportTaskError('function', error)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">this.callbackQueue.add(wrappedCallback)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async runCallbacksOnClose() {</span><span class="s3">\n    </span><span class="s1">await new Promise&lt;void&gt;((resolve) =&gt; this.onClose!(resolve))</span><span class="s3">\n    </span><span class="s1">return this.runCallbacks()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async runCallbacks(): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">if (this.callbackQueue.size === 0) return</span><span class="s3">\n\n    </span><span class="s1">for (const workUnitStore of this.workUnitStores) {</span><span class="s3">\n      </span><span class="s1">workUnitStore.phase = 'after'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const workStore = workAsyncStorage.getStore()</span><span class="s3">\n    </span><span class="s1">if (!workStore) {</span><span class="s3">\n      </span><span class="s1">throw new InvariantError('Missing workStore in AfterContext.runCallbacks')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return withExecuteRevalidates(workStore, () =&gt; {</span><span class="s3">\n      </span><span class="s1">this.callbackQueue.start()</span><span class="s3">\n      </span><span class="s1">return this.callbackQueue.onIdle()</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private reportTaskError(taskKind: 'promise' | 'function', error: unknown) {</span><span class="s3">\n    </span><span class="s1">// TODO(after): this is fine for now, but will need better intergration with our error reporting.</span><span class="s3">\n    </span><span class="s1">// TODO(after): should we log this if we have a onTaskError callback?</span><span class="s3">\n    </span><span class="s1">console.error(</span><span class="s3">\n      </span><span class="s1">taskKind === 'promise'</span><span class="s3">\n        </span><span class="s1">? `A promise passed to </span><span class="s3">\\</span><span class="s1">`after()</span><span class="s3">\\</span><span class="s1">` rejected:`</span><span class="s3">\n        </span><span class="s1">: `An error occurred in a function passed to </span><span class="s3">\\</span><span class="s1">`after()</span><span class="s3">\\</span><span class="s1">`:`,</span><span class="s3">\n      </span><span class="s1">error</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">if (this.onTaskError) {</span><span class="s3">\n      </span><span class="s1">// this is very defensive, but we really don't want anything to blow up in an error handler</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">this.onTaskError?.(error)</span><span class="s3">\n      </span><span class="s1">} catch (handlerError) {</span><span class="s3">\n        </span><span class="s1">console.error(</span><span class="s3">\n          </span><span class="s1">new InvariantError(</span><span class="s3">\n            </span><span class="s1">'`onTaskError` threw while handling an error thrown from an `after` task',</span><span class="s3">\n            </span><span class="s1">{</span><span class="s3">\n              </span><span class="s1">cause: handlerError,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function errorWaitUntilNotAvailable(): never {</span><span class="s3">\n  </span><span class="s1">throw new Error(</span><span class="s3">\n    </span><span class="s1">'`after()` will not work correctly, because `waitUntil` is not available in the current environment.'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;AfterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;waitUntil&quot;</span><span class="s0">,</span><span class="s1">&quot;onClose&quot;</span><span class="s0">,</span><span class="s1">&quot;onTaskError&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitStores&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;callbackQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;PromiseQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;pause&quot;</span><span class="s0">,</span><span class="s1">&quot;after&quot;</span><span class="s0">,</span><span class="s1">&quot;task&quot;</span><span class="s0">,</span><span class="s1">&quot;isThenable&quot;</span><span class="s0">,</span><span class="s1">&quot;errorWaitUntilNotAvailable&quot;</span><span class="s0">,</span><span class="s1">&quot;catch&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;reportTaskError&quot;</span><span class="s0">,</span><span class="s1">&quot;addCallback&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;callback&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitStore&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;getStore&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;afterTaskStore&quot;</span><span class="s0">,</span><span class="s1">&quot;afterTaskAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;rootTaskSpawnPhase&quot;</span><span class="s0">,</span><span class="s1">&quot;phase&quot;</span><span class="s0">,</span><span class="s1">&quot;runCallbacksOnClosePromise&quot;</span><span class="s0">,</span><span class="s1">&quot;runCallbacksOnClose&quot;</span><span class="s0">,</span><span class="s1">&quot;wrappedCallback&quot;</span><span class="s0">,</span><span class="s1">&quot;bindSnapshot&quot;</span><span class="s0">,</span><span class="s1">&quot;run&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;runCallbacks&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;workStore&quot;</span><span class="s0">,</span><span class="s1">&quot;workAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;InvariantError&quot;</span><span class="s0">,</span><span class="s1">&quot;withExecuteRevalidates&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;onIdle&quot;</span><span class="s0">,</span><span class="s1">&quot;taskKind&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;handlerError&quot;</span><span class="s0">,</span><span class="s1">&quot;cause&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>