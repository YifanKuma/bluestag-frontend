<html>
<head>
<title>typegen.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
typegen.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/server/lib/router-utils/typegen.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { RouteTypesManifest } from './route-types-utils'</span><span class="s3">\n</span><span class="s1">import { isDynamicRoute } from '../../../shared/lib/router/utils/is-dynamic'</span><span class="s3">\n\n</span><span class="s1">function generateRouteTypes(routesManifest: RouteTypesManifest): string {</span><span class="s3">\n  </span><span class="s1">const appRoutes = Object.keys(routesManifest.appRoutes).sort()</span><span class="s3">\n  </span><span class="s1">const pageRoutes = Object.keys(routesManifest.pageRoutes).sort()</span><span class="s3">\n  </span><span class="s1">const layoutRoutes = Object.keys(routesManifest.layoutRoutes).sort()</span><span class="s3">\n  </span><span class="s1">const redirectRoutes = Object.keys(routesManifest.redirectRoutes).sort()</span><span class="s3">\n  </span><span class="s1">const rewriteRoutes = Object.keys(routesManifest.rewriteRoutes).sort()</span><span class="s3">\n\n  </span><span class="s1">let result = ''</span><span class="s3">\n\n  </span><span class="s1">// Generate AppRoutes union type (pages only)</span><span class="s3">\n  </span><span class="s1">if (appRoutes.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">result += `type AppRoutes = ${appRoutes.map((route) =&gt; JSON.stringify(route)).join(' | ')}</span><span class="s3">\\</span><span class="s1">n`</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">result += 'type AppRoutes = never</span><span class="s3">\\</span><span class="s1">n'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Generate AppRouteHandlerRoutes union type for route handlers</span><span class="s3">\n  </span><span class="s1">const appRouteHandlerRoutes = Object.keys(</span><span class="s3">\n    </span><span class="s1">routesManifest.appRouteHandlerRoutes</span><span class="s3">\n  </span><span class="s1">).sort()</span><span class="s3">\n\n  </span><span class="s1">const hasAppRouteHandlers = appRouteHandlerRoutes.length &gt; 0</span><span class="s3">\n\n  </span><span class="s1">if (hasAppRouteHandlers) {</span><span class="s3">\n    </span><span class="s1">result += `type AppRouteHandlerRoutes = ${appRouteHandlerRoutes.map((route) =&gt; JSON.stringify(route)).join(' | ')}</span><span class="s3">\\</span><span class="s1">n`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Generate PageRoutes union type</span><span class="s3">\n  </span><span class="s1">if (pageRoutes.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">result += `type PageRoutes = ${pageRoutes.map((route) =&gt; JSON.stringify(route)).join(' | ')}</span><span class="s3">\\</span><span class="s1">n`</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">result += 'type PageRoutes = never</span><span class="s3">\\</span><span class="s1">n'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Generate LayoutRoutes union type</span><span class="s3">\n  </span><span class="s1">if (layoutRoutes.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">result += `type LayoutRoutes = ${layoutRoutes.map((route) =&gt; JSON.stringify(route)).join(' | ')}</span><span class="s3">\\</span><span class="s1">n`</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">result += 'type LayoutRoutes = never</span><span class="s3">\\</span><span class="s1">n'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Generate RedirectRoutes union type</span><span class="s3">\n  </span><span class="s1">if (redirectRoutes.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">result += `type RedirectRoutes = ${redirectRoutes</span><span class="s3">\n      </span><span class="s1">.map((route) =&gt; JSON.stringify(route))</span><span class="s3">\n      </span><span class="s1">.join(' | ')}</span><span class="s3">\\</span><span class="s1">n`</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">result += 'type RedirectRoutes = never</span><span class="s3">\\</span><span class="s1">n'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Generate RewriteRoutes union type</span><span class="s3">\n  </span><span class="s1">if (rewriteRoutes.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">result += `type RewriteRoutes = ${rewriteRoutes</span><span class="s3">\n      </span><span class="s1">.map((route) =&gt; JSON.stringify(route))</span><span class="s3">\n      </span><span class="s1">.join(' | ')}</span><span class="s3">\\</span><span class="s1">n`</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">result += 'type RewriteRoutes = never</span><span class="s3">\\</span><span class="s1">n'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Only include AppRouteHandlerRoutes in Routes union if there are actual route handlers</span><span class="s3">\n  </span><span class="s1">const routeUnionParts = [</span><span class="s3">\n    </span><span class="s1">'AppRoutes',</span><span class="s3">\n    </span><span class="s1">'PageRoutes',</span><span class="s3">\n    </span><span class="s1">'LayoutRoutes',</span><span class="s3">\n    </span><span class="s1">'RedirectRoutes',</span><span class="s3">\n    </span><span class="s1">'RewriteRoutes',</span><span class="s3">\n  </span><span class="s1">]</span><span class="s3">\n  </span><span class="s1">if (hasAppRouteHandlers) {</span><span class="s3">\n    </span><span class="s1">routeUnionParts.push('AppRouteHandlerRoutes')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">result += `type Routes = ${routeUnionParts.join(' | ')}</span><span class="s3">\\</span><span class="s1">n`</span><span class="s3">\n\n  </span><span class="s1">return result</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function generateParamTypes(routesManifest: RouteTypesManifest): string {</span><span class="s3">\n  </span><span class="s1">const allRoutes = {</span><span class="s3">\n    </span><span class="s1">...routesManifest.appRoutes,</span><span class="s3">\n    </span><span class="s1">...routesManifest.appRouteHandlerRoutes,</span><span class="s3">\n    </span><span class="s1">...routesManifest.pageRoutes,</span><span class="s3">\n    </span><span class="s1">...routesManifest.layoutRoutes,</span><span class="s3">\n    </span><span class="s1">...routesManifest.redirectRoutes,</span><span class="s3">\n    </span><span class="s1">...routesManifest.rewriteRoutes,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let paramTypes = 'interface ParamMap {</span><span class="s3">\\</span><span class="s1">n'</span><span class="s3">\n\n  </span><span class="s1">// Sort routes deterministically for consistent output</span><span class="s3">\n  </span><span class="s1">const sortedRoutes = Object.entries(allRoutes).sort(([a], [b]) =&gt;</span><span class="s3">\n    </span><span class="s1">a.localeCompare(b)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">for (const [route, routeInfo] of sortedRoutes) {</span><span class="s3">\n    </span><span class="s1">const { groups } = routeInfo</span><span class="s3">\n\n    </span><span class="s1">// For static routes (no dynamic segments), we can produce an empty parameter map.</span><span class="s3">\n    </span><span class="s1">if (!isDynamicRoute(route) || Object.keys(groups ?? {}).length === 0) {</span><span class="s3">\n      </span><span class="s1">paramTypes += `  ${JSON.stringify(route)}: {}</span><span class="s3">\\</span><span class="s1">n`</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let paramType = '{'</span><span class="s3">\n\n    </span><span class="s1">// Process each group based on its properties</span><span class="s3">\n    </span><span class="s1">for (const [key, group] of Object.entries(groups)) {</span><span class="s3">\n      </span><span class="s1">const escapedKey = JSON.stringify(key)</span><span class="s3">\n      </span><span class="s1">if (group.repeat) {</span><span class="s3">\n        </span><span class="s1">// Catch-all parameters</span><span class="s3">\n        </span><span class="s1">if (group.optional) {</span><span class="s3">\n          </span><span class="s1">paramType += ` ${escapedKey}?: string[];`</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">paramType += ` ${escapedKey}: string[];`</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// Regular parameters</span><span class="s3">\n        </span><span class="s1">if (group.optional) {</span><span class="s3">\n          </span><span class="s1">paramType += ` ${escapedKey}?: string;`</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">paramType += ` ${escapedKey}: string;`</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">paramType += ' }'</span><span class="s3">\n\n    </span><span class="s1">paramTypes += `  ${JSON.stringify(route)}: ${paramType}</span><span class="s3">\\</span><span class="s1">n`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">paramTypes += '}</span><span class="s3">\\</span><span class="s1">n'</span><span class="s3">\n  </span><span class="s1">return paramTypes</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function generateLayoutSlotMap(routesManifest: RouteTypesManifest): string {</span><span class="s3">\n  </span><span class="s1">let slotMap = 'interface LayoutSlotMap {</span><span class="s3">\\</span><span class="s1">n'</span><span class="s3">\n\n  </span><span class="s1">// Sort routes deterministically for consistent output</span><span class="s3">\n  </span><span class="s1">const sortedLayoutRoutes = Object.entries(routesManifest.layoutRoutes).sort(</span><span class="s3">\n    </span><span class="s1">([a], [b]) =&gt; a.localeCompare(b)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">for (const [route, routeInfo] of sortedLayoutRoutes) {</span><span class="s3">\n    </span><span class="s1">if ('slots' in routeInfo) {</span><span class="s3">\n      </span><span class="s1">const slots = routeInfo.slots.sort()</span><span class="s3">\n      </span><span class="s1">if (slots.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">slotMap += `  ${JSON.stringify(route)}: ${slots.map((slot) =&gt; JSON.stringify(slot)).join(' | ')}</span><span class="s3">\\</span><span class="s1">n`</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">slotMap += `  ${JSON.stringify(route)}: never</span><span class="s3">\\</span><span class="s1">n`</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">slotMap += `  ${JSON.stringify(route)}: never</span><span class="s3">\\</span><span class="s1">n`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">slotMap += '}</span><span class="s3">\\</span><span class="s1">n'</span><span class="s3">\n  </span><span class="s1">return slotMap</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Helper function to format routes to route types (matches the plugin logic exactly)</span><span class="s3">\n</span><span class="s1">function formatRouteToRouteType(route: string) {</span><span class="s3">\n  </span><span class="s1">const isDynamic = isDynamicRoute(route)</span><span class="s3">\n  </span><span class="s1">if (isDynamic) {</span><span class="s3">\n    </span><span class="s1">route = route</span><span class="s3">\n      </span><span class="s1">.split('/')</span><span class="s3">\n      </span><span class="s1">.map((part) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (part.startsWith('[') &amp;&amp; part.endsWith(']')) {</span><span class="s3">\n          </span><span class="s1">if (part.startsWith('[...')) {</span><span class="s3">\n            </span><span class="s1">// /[...slug]</span><span class="s3">\n            </span><span class="s1">return `</span><span class="s3">\\</span><span class="s1">${CatchAllSlug&lt;T&gt;}`</span><span class="s3">\n          </span><span class="s1">} else if (part.startsWith('[[...') &amp;&amp; part.endsWith(']]')) {</span><span class="s3">\n            </span><span class="s1">// /[[...slug]]</span><span class="s3">\n            </span><span class="s1">return `</span><span class="s3">\\</span><span class="s1">${OptionalCatchAllSlug&lt;T&gt;}`</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">// /[slug]</span><span class="s3">\n          </span><span class="s1">return `</span><span class="s3">\\</span><span class="s1">${SafeSlug&lt;T&gt;}`</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return part</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">.join('/')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">isDynamic,</span><span class="s3">\n    </span><span class="s1">routeType: route,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Helper function to serialize route types (matches the plugin logic exactly)</span><span class="s3">\n</span><span class="s1">function serializeRouteTypes(routeTypes: string[]) {</span><span class="s3">\n  </span><span class="s1">// route collection is not deterministic, this makes the output of the file deterministic</span><span class="s3">\n  </span><span class="s1">return routeTypes</span><span class="s3">\n    </span><span class="s1">.sort()</span><span class="s3">\n    </span><span class="s1">.map((route) =&gt; `</span><span class="s3">\\</span><span class="s1">n    | </span><span class="s3">\\</span><span class="s1">`${route}</span><span class="s3">\\</span><span class="s1">``)</span><span class="s3">\n    </span><span class="s1">.join('')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function generateLinkTypesFile(</span><span class="s3">\n  </span><span class="s1">routesManifest: RouteTypesManifest</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">// Generate serialized static and dynamic routes for the internal namespace</span><span class="s3">\n  </span><span class="s1">// Build a unified set of routes across app/pages/redirect/rewrite as well as</span><span class="s3">\n  </span><span class="s1">// app route handlers and Pages Router API routes.</span><span class="s3">\n  </span><span class="s1">const allRoutesSet = new Set&lt;string&gt;([</span><span class="s3">\n    </span><span class="s1">...Object.keys(routesManifest.appRoutes),</span><span class="s3">\n    </span><span class="s1">...Object.keys(routesManifest.pageRoutes),</span><span class="s3">\n    </span><span class="s1">...Object.keys(routesManifest.redirectRoutes),</span><span class="s3">\n    </span><span class="s1">...Object.keys(routesManifest.rewriteRoutes),</span><span class="s3">\n    </span><span class="s1">// Allow linking to App Route Handlers (e.g. `/logout/route.ts`)</span><span class="s3">\n    </span><span class="s1">...Object.keys(routesManifest.appRouteHandlerRoutes),</span><span class="s3">\n    </span><span class="s1">// Allow linking to Pages Router API routes (e.g. `/api/*`)</span><span class="s3">\n    </span><span class="s1">...Array.from(routesManifest.pageApiRoutes),</span><span class="s3">\n  </span><span class="s1">])</span><span class="s3">\n\n  </span><span class="s1">const staticRouteTypes: string[] = []</span><span class="s3">\n  </span><span class="s1">const dynamicRouteTypes: string[] = []</span><span class="s3">\n\n  </span><span class="s1">// Process each route using the same logic as the plugin</span><span class="s3">\n  </span><span class="s1">for (const route of allRoutesSet) {</span><span class="s3">\n    </span><span class="s1">const { isDynamic, routeType } = formatRouteToRouteType(route)</span><span class="s3">\n    </span><span class="s1">if (isDynamic) {</span><span class="s3">\n      </span><span class="s1">dynamicRouteTypes.push(routeType)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">staticRouteTypes.push(routeType)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const serializedStaticRouteTypes = serializeRouteTypes(staticRouteTypes)</span><span class="s3">\n  </span><span class="s1">const serializedDynamicRouteTypes = serializeRouteTypes(dynamicRouteTypes)</span><span class="s3">\n\n  </span><span class="s1">// If both StaticRoutes and DynamicRoutes are empty, fallback to type 'string &amp; {}'.</span><span class="s3">\n  </span><span class="s1">const routeTypesFallback =</span><span class="s3">\n    </span><span class="s1">!serializedStaticRouteTypes &amp;&amp; !serializedDynamicRouteTypes</span><span class="s3">\n      </span><span class="s1">? 'string &amp; {}'</span><span class="s3">\n      </span><span class="s1">: ''</span><span class="s3">\n\n  </span><span class="s1">return `// This file is generated automatically by Next.js</span><span class="s3">\n</span><span class="s1">// Do not edit this file manually</span><span class="s3">\n\n</span><span class="s1">// Type definitions for Next.js routes</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Internal types used by the Next.js router and Link component.</span><span class="s3">\n </span><span class="s1">* These types are not meant to be used directly.</span><span class="s3">\n </span><span class="s1">* @internal</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">declare namespace __next_route_internal_types__ {</span><span class="s3">\n  </span><span class="s1">type SearchOrHash = </span><span class="s3">\\</span><span class="s1">`?</span><span class="s3">\\</span><span class="s1">${string}</span><span class="s3">\\</span><span class="s1">` | </span><span class="s3">\\</span><span class="s1">`#</span><span class="s3">\\</span><span class="s1">${string}</span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\n  </span><span class="s1">type WithProtocol = </span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\\</span><span class="s1">${string}:</span><span class="s3">\\</span><span class="s1">${string}</span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\n\n  </span><span class="s1">type Suffix = '' | SearchOrHash</span><span class="s3">\n\n  </span><span class="s1">type SafeSlug&lt;S extends string&gt; = S extends </span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\\</span><span class="s1">${string}/</span><span class="s3">\\</span><span class="s1">${string}</span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\n    </span><span class="s1">? never</span><span class="s3">\n    </span><span class="s1">: S extends </span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\\</span><span class="s1">${string}</span><span class="s3">\\</span><span class="s1">${SearchOrHash}</span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\n    </span><span class="s1">? never</span><span class="s3">\n    </span><span class="s1">: S extends ''</span><span class="s3">\n    </span><span class="s1">? never</span><span class="s3">\n    </span><span class="s1">: S</span><span class="s3">\n\n  </span><span class="s1">type CatchAllSlug&lt;S extends string&gt; = S extends </span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\\</span><span class="s1">${string}</span><span class="s3">\\</span><span class="s1">${SearchOrHash}</span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\n    </span><span class="s1">? never</span><span class="s3">\n    </span><span class="s1">: S extends ''</span><span class="s3">\n    </span><span class="s1">? never</span><span class="s3">\n    </span><span class="s1">: S</span><span class="s3">\n\n  </span><span class="s1">type OptionalCatchAllSlug&lt;S extends string&gt; =</span><span class="s3">\n    </span><span class="s1">S extends </span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\\</span><span class="s1">${string}</span><span class="s3">\\</span><span class="s1">${SearchOrHash}</span><span class="s3">\\</span><span class="s1">` ? never : S</span><span class="s3">\n\n  </span><span class="s1">type StaticRoutes = ${serializedStaticRouteTypes || 'never'}</span><span class="s3">\n  </span><span class="s1">type DynamicRoutes&lt;T extends string = string&gt; = ${</span><span class="s3">\n    </span><span class="s1">serializedDynamicRouteTypes || 'never'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">type RouteImpl&lt;T&gt; = ${</span><span class="s3">\n    </span><span class="s1">routeTypesFallback ||</span><span class="s3">\n    </span><span class="s1">`</span><span class="s3">\n    </span><span class="s1">${</span><span class="s3">\n      </span><span class="s1">// This keeps autocompletion working for static routes.</span><span class="s3">\n      </span><span class="s1">'| StaticRoutes'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">| SearchOrHash</span><span class="s3">\n    </span><span class="s1">| WithProtocol</span><span class="s3">\n    </span><span class="s1">| </span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\\</span><span class="s1">${StaticRoutes}</span><span class="s3">\\</span><span class="s1">${SearchOrHash}</span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\n    </span><span class="s1">| (T extends </span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\\</span><span class="s1">${DynamicRoutes&lt;infer _&gt;}</span><span class="s3">\\</span><span class="s1">${Suffix}</span><span class="s3">\\</span><span class="s1">` ? T : never)</span><span class="s3">\n    </span><span class="s1">`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">declare module 'next' {</span><span class="s3">\n  </span><span class="s1">export { default } from 'next/types.js'</span><span class="s3">\n  </span><span class="s1">export * from 'next/types.js'</span><span class="s3">\n\n  </span><span class="s1">export type Route&lt;T extends string = string&gt; =</span><span class="s3">\n    </span><span class="s1">__next_route_internal_types__.RouteImpl&lt;T&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">declare module 'next/link' {</span><span class="s3">\n  </span><span class="s1">import type { LinkProps as OriginalLinkProps } from 'next/dist/client/link.js'</span><span class="s3">\n  </span><span class="s1">import type { AnchorHTMLAttributes, DetailedHTMLProps } from 'react'</span><span class="s3">\n  </span><span class="s1">import type { UrlObject } from 'url'</span><span class="s3">\n\n  </span><span class="s1">type LinkRestProps = Omit&lt;</span><span class="s3">\n    </span><span class="s1">Omit&lt;</span><span class="s3">\n      </span><span class="s1">DetailedHTMLProps&lt;</span><span class="s3">\n        </span><span class="s1">AnchorHTMLAttributes&lt;HTMLAnchorElement&gt;,</span><span class="s3">\n        </span><span class="s1">HTMLAnchorElement</span><span class="s3">\n      </span><span class="s1">&gt;,</span><span class="s3">\n      </span><span class="s1">keyof OriginalLinkProps</span><span class="s3">\n    </span><span class="s1">&gt; &amp;</span><span class="s3">\n      </span><span class="s1">OriginalLinkProps,</span><span class="s3">\n    </span><span class="s1">'href'</span><span class="s3">\n  </span><span class="s1">&gt;</span><span class="s3">\n\n  </span><span class="s1">export type LinkProps&lt;RouteInferType&gt; = LinkRestProps &amp; {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The path or URL to navigate to. This is the only required prop. It can also be an object.</span><span class="s3">\n     </span><span class="s1">* @see https://nextjs.org/docs/api-reference/next/link</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">href: __next_route_internal_types__.RouteImpl&lt;RouteInferType&gt; | UrlObject</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">export default function Link&lt;RouteType&gt;(props: LinkProps&lt;RouteType&gt;): JSX.Element</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">declare module 'next/navigation' {</span><span class="s3">\n  </span><span class="s1">export * from 'next/dist/client/components/navigation.js'</span><span class="s3">\n\n  </span><span class="s1">import type { NavigateOptions, AppRouterInstance as OriginalAppRouterInstance } from 'next/dist/shared/lib/app-router-context.shared-runtime.js'</span><span class="s3">\n  </span><span class="s1">import type { RedirectType } from 'next/dist/client/components/redirect-error.js'</span><span class="s3">\n  \n  </span><span class="s1">interface AppRouterInstance extends OriginalAppRouterInstance {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Navigate to the provided href.</span><span class="s3">\n     </span><span class="s1">* Pushes a new history entry.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">push&lt;RouteType&gt;(href: __next_route_internal_types__.RouteImpl&lt;RouteType&gt;, options?: NavigateOptions): void</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Navigate to the provided href.</span><span class="s3">\n     </span><span class="s1">* Replaces the current history entry.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">replace&lt;RouteType&gt;(href: __next_route_internal_types__.RouteImpl&lt;RouteType&gt;, options?: NavigateOptions): void</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Prefetch the provided href.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">prefetch&lt;RouteType&gt;(href: __next_route_internal_types__.RouteImpl&lt;RouteType&gt;): void</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">export function useRouter(): AppRouterInstance;</span><span class="s3">\n  \n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This function allows you to redirect the user to another URL. It can be used in</span><span class="s3">\n   </span><span class="s1">* [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),</span><span class="s3">\n   </span><span class="s1">* [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and</span><span class="s3">\n   </span><span class="s1">* [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* - In a Server Component, this will insert a meta tag to redirect the user to the target page.</span><span class="s3">\n   </span><span class="s1">* - In a Route Handler or Server Action, it will serve a 307/303 to the caller.</span><span class="s3">\n   </span><span class="s1">* - In a Server Action, type defaults to 'push' and 'replace' elsewhere.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Read more: [Next.js Docs: redirect](https://nextjs.org/docs/app/api-reference/functions/redirect)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">export function redirect&lt;RouteType&gt;(</span><span class="s3">\n    </span><span class="s1">/** The URL to redirect to */</span><span class="s3">\n    </span><span class="s1">url: __next_route_internal_types__.RouteImpl&lt;RouteType&gt;,</span><span class="s3">\n    </span><span class="s1">type?: RedirectType</span><span class="s3">\n  </span><span class="s1">): never;</span><span class="s3">\n  \n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This function allows you to redirect the user to another URL. It can be used in</span><span class="s3">\n   </span><span class="s1">* [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),</span><span class="s3">\n   </span><span class="s1">* [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and</span><span class="s3">\n   </span><span class="s1">* [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* - In a Server Component, this will insert a meta tag to redirect the user to the target page.</span><span class="s3">\n   </span><span class="s1">* - In a Route Handler or Server Action, it will serve a 308/303 to the caller.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Read more: [Next.js Docs: redirect](https://nextjs.org/docs/app/api-reference/functions/redirect)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">export function permanentRedirect&lt;RouteType&gt;(</span><span class="s3">\n    </span><span class="s1">/** The URL to redirect to */</span><span class="s3">\n    </span><span class="s1">url: __next_route_internal_types__.RouteImpl&lt;RouteType&gt;,</span><span class="s3">\n    </span><span class="s1">type?: RedirectType</span><span class="s3">\n  </span><span class="s1">): never;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">declare module 'next/form' {</span><span class="s3">\n  </span><span class="s1">import type { FormProps as OriginalFormProps } from 'next/dist/client/form.js'</span><span class="s3">\n\n  </span><span class="s1">type FormRestProps = Omit&lt;OriginalFormProps, 'action'&gt;</span><span class="s3">\n\n  </span><span class="s1">export type FormProps&lt;RouteInferType&gt; = {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* </span><span class="s3">\\</span><span class="s1">`action</span><span class="s3">\\</span><span class="s1">` can be either a </span><span class="s3">\\</span><span class="s1">`string</span><span class="s3">\\</span><span class="s1">` or a function.</span><span class="s3">\n     </span><span class="s1">* - If </span><span class="s3">\\</span><span class="s1">`action</span><span class="s3">\\</span><span class="s1">` is a string, it will be interpreted as a path or URL to navigate to when the form is submitted.</span><span class="s3">\n     </span><span class="s1">*   The path will be prefetched when the form becomes visible.</span><span class="s3">\n     </span><span class="s1">* - If </span><span class="s3">\\</span><span class="s1">`action</span><span class="s3">\\</span><span class="s1">` is a function, it will be called when the form is submitted. See the [React docs](https://react.dev/reference/react-dom/components/form#props) for more.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">action: __next_route_internal_types__.RouteImpl&lt;RouteInferType&gt; | ((formData: FormData) =&gt; void)</span><span class="s3">\n  </span><span class="s1">} &amp; FormRestProps</span><span class="s3">\n\n  </span><span class="s1">export default function Form&lt;RouteType&gt;(props: FormProps&lt;RouteType&gt;): JSX.Element</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function generateValidatorFile(</span><span class="s3">\n  </span><span class="s1">routesManifest: RouteTypesManifest</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">const generateValidations = (</span><span class="s3">\n    </span><span class="s1">paths: string[],</span><span class="s3">\n    </span><span class="s1">type:</span><span class="s3">\n      </span><span class="s1">| 'AppPageConfig'</span><span class="s3">\n      </span><span class="s1">| 'PagesPageConfig'</span><span class="s3">\n      </span><span class="s1">| 'LayoutConfig'</span><span class="s3">\n      </span><span class="s1">| 'RouteHandlerConfig'</span><span class="s3">\n      </span><span class="s1">| 'ApiRouteConfig',</span><span class="s3">\n    </span><span class="s1">pathToRouteMap?: Map&lt;string, string&gt;</span><span class="s3">\n  </span><span class="s1">) =&gt;</span><span class="s3">\n    </span><span class="s1">paths</span><span class="s3">\n      </span><span class="s1">.sort()</span><span class="s3">\n      </span><span class="s1">// Only validate TypeScript files - JavaScript files have too many type inference limitations</span><span class="s3">\n      </span><span class="s1">.filter(</span><span class="s3">\n        </span><span class="s1">(filePath) =&gt; filePath.endsWith('.ts') || filePath.endsWith('.tsx')</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">.filter(</span><span class="s3">\n        </span><span class="s1">// Don't include metadata routes or pages</span><span class="s3">\n        </span><span class="s1">// (e.g. /manifest.webmanifest)</span><span class="s3">\n        </span><span class="s1">(filePath) =&gt;</span><span class="s3">\n          </span><span class="s1">type !== 'AppPageConfig' ||</span><span class="s3">\n          </span><span class="s1">filePath.endsWith('page.ts') ||</span><span class="s3">\n          </span><span class="s1">filePath.endsWith('page.tsx')</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">.map((filePath) =&gt; {</span><span class="s3">\n        </span><span class="s1">// Keep the file extension for TypeScript imports to support node16 module resolution</span><span class="s3">\n        </span><span class="s1">const importPath = filePath</span><span class="s3">\n        </span><span class="s1">const route = pathToRouteMap?.get(filePath)</span><span class="s3">\n        </span><span class="s1">const typeWithRoute =</span><span class="s3">\n          </span><span class="s1">route &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(type === 'AppPageConfig' ||</span><span class="s3">\n            </span><span class="s1">type === 'LayoutConfig' ||</span><span class="s3">\n            </span><span class="s1">type === 'RouteHandlerConfig')</span><span class="s3">\n            </span><span class="s1">? `${type}&lt;${JSON.stringify(route)}&gt;`</span><span class="s3">\n            </span><span class="s1">: type</span><span class="s3">\n        </span><span class="s1">return `// Validate ${filePath}</span><span class="s3">\n</span><span class="s1">{</span><span class="s3">\n  </span><span class="s1">type __IsExpected&lt;Specific extends ${typeWithRoute}&gt; = Specific</span><span class="s3">\n  </span><span class="s1">const handler = {} as typeof import(${JSON.stringify(</span><span class="s3">\n    </span><span class="s1">importPath.replace(/</span><span class="s3">\\</span><span class="s1">.tsx?$/, '.js')</span><span class="s3">\n  </span><span class="s1">)})</span><span class="s3">\n  </span><span class="s1">type __Check = __IsExpected&lt;typeof handler&gt;</span><span class="s3">\n  </span><span class="s1">// @ts-ignore</span><span class="s3">\n  </span><span class="s1">type __Unused = __Check</span><span class="s3">\n</span><span class="s1">}`</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">.join('</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n')</span><span class="s3">\n\n  </span><span class="s1">// Use direct mappings from the manifest</span><span class="s3">\n\n  </span><span class="s1">// Generate validations for different route types</span><span class="s3">\n  </span><span class="s1">const appPageValidations = generateValidations(</span><span class="s3">\n    </span><span class="s1">Array.from(routesManifest.appPagePaths).sort(),</span><span class="s3">\n    </span><span class="s1">'AppPageConfig',</span><span class="s3">\n    </span><span class="s1">routesManifest.filePathToRoute</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const appRouteHandlerValidations = generateValidations(</span><span class="s3">\n    </span><span class="s1">Array.from(routesManifest.appRouteHandlers).sort(),</span><span class="s3">\n    </span><span class="s1">'RouteHandlerConfig',</span><span class="s3">\n    </span><span class="s1">routesManifest.filePathToRoute</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const pagesRouterPageValidations = generateValidations(</span><span class="s3">\n    </span><span class="s1">Array.from(routesManifest.pagesRouterPagePaths).sort(),</span><span class="s3">\n    </span><span class="s1">'PagesPageConfig'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const pagesApiRouteValidations = generateValidations(</span><span class="s3">\n    </span><span class="s1">Array.from(routesManifest.pageApiRoutes).sort(),</span><span class="s3">\n    </span><span class="s1">'ApiRouteConfig'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const layoutValidations = generateValidations(</span><span class="s3">\n    </span><span class="s1">Array.from(routesManifest.layoutPaths).sort(),</span><span class="s3">\n    </span><span class="s1">'LayoutConfig',</span><span class="s3">\n    </span><span class="s1">routesManifest.filePathToRoute</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const hasAppRouteHandlers =</span><span class="s3">\n    </span><span class="s1">Object.keys(routesManifest.appRouteHandlerRoutes).length &gt; 0</span><span class="s3">\n\n  </span><span class="s1">// Build type definitions based on what's actually used</span><span class="s3">\n  </span><span class="s1">let typeDefinitions = ''</span><span class="s3">\n\n  </span><span class="s1">if (appPageValidations) {</span><span class="s3">\n    </span><span class="s1">typeDefinitions += `type AppPageConfig&lt;Route extends AppRoutes = AppRoutes&gt; = {</span><span class="s3">\n  </span><span class="s1">default: React.ComponentType&lt;{ params: Promise&lt;ParamMap[Route]&gt; } &amp; any&gt; | ((props: { params: Promise&lt;ParamMap[Route]&gt; } &amp; any) =&gt; React.ReactNode | Promise&lt;React.ReactNode&gt; | never | void | Promise&lt;void&gt;)</span><span class="s3">\n  </span><span class="s1">generateStaticParams?: (props: { params: ParamMap[Route] }) =&gt; Promise&lt;any[]&gt; | any[]</span><span class="s3">\n  </span><span class="s1">generateMetadata?: (</span><span class="s3">\n    </span><span class="s1">props: { params: Promise&lt;ParamMap[Route]&gt; } &amp; any,</span><span class="s3">\n    </span><span class="s1">parent: ResolvingMetadata</span><span class="s3">\n  </span><span class="s1">) =&gt; Promise&lt;any&gt; | any</span><span class="s3">\n  </span><span class="s1">generateViewport?: (</span><span class="s3">\n    </span><span class="s1">props: { params: Promise&lt;ParamMap[Route]&gt; } &amp; any,</span><span class="s3">\n    </span><span class="s1">parent: ResolvingViewport</span><span class="s3">\n  </span><span class="s1">) =&gt; Promise&lt;any&gt; | any</span><span class="s3">\n  </span><span class="s1">metadata?: any</span><span class="s3">\n  </span><span class="s1">viewport?: any</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (pagesRouterPageValidations) {</span><span class="s3">\n    </span><span class="s1">typeDefinitions += `type PagesPageConfig = {</span><span class="s3">\n  </span><span class="s1">default: React.ComponentType&lt;any&gt; | ((props: any) =&gt; React.ReactNode | Promise&lt;React.ReactNode&gt; | never | void)</span><span class="s3">\n  </span><span class="s1">getStaticProps?: (context: any) =&gt; Promise&lt;any&gt; | any</span><span class="s3">\n  </span><span class="s1">getStaticPaths?: (context: any) =&gt; Promise&lt;any&gt; | any</span><span class="s3">\n  </span><span class="s1">getServerSideProps?: (context: any) =&gt; Promise&lt;any&gt; | any</span><span class="s3">\n  </span><span class="s1">getInitialProps?: (context: any) =&gt; Promise&lt;any&gt; | any</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Segment configuration for legacy Pages Router pages.</span><span class="s3">\n   </span><span class="s1">* Validated at build-time by parsePagesSegmentConfig.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">config?: {</span><span class="s3">\n    </span><span class="s1">amp?: boolean | 'hybrid' | string // necessary for JS</span><span class="s3">\n    </span><span class="s1">maxDuration?: number</span><span class="s3">\n    </span><span class="s1">runtime?: 'edge' | 'experimental-edge' | 'nodejs' | string // necessary unless config is exported as const</span><span class="s3">\n    </span><span class="s1">regions?: string[]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (layoutValidations) {</span><span class="s3">\n    </span><span class="s1">typeDefinitions += `type LayoutConfig&lt;Route extends LayoutRoutes = LayoutRoutes&gt; = {</span><span class="s3">\n  </span><span class="s1">default: React.ComponentType&lt;LayoutProps&lt;Route&gt;&gt; | ((props: LayoutProps&lt;Route&gt;) =&gt; React.ReactNode | Promise&lt;React.ReactNode&gt; | never | void | Promise&lt;void&gt;)</span><span class="s3">\n  </span><span class="s1">generateStaticParams?: (props: { params: ParamMap[Route] }) =&gt; Promise&lt;any[]&gt; | any[]</span><span class="s3">\n  </span><span class="s1">generateMetadata?: (</span><span class="s3">\n    </span><span class="s1">props: { params: Promise&lt;ParamMap[Route]&gt; } &amp; any,</span><span class="s3">\n    </span><span class="s1">parent: ResolvingMetadata</span><span class="s3">\n  </span><span class="s1">) =&gt; Promise&lt;any&gt; | any</span><span class="s3">\n  </span><span class="s1">generateViewport?: (</span><span class="s3">\n    </span><span class="s1">props: { params: Promise&lt;ParamMap[Route]&gt; } &amp; any,</span><span class="s3">\n    </span><span class="s1">parent: ResolvingViewport</span><span class="s3">\n  </span><span class="s1">) =&gt; Promise&lt;any&gt; | any</span><span class="s3">\n  </span><span class="s1">metadata?: any</span><span class="s3">\n  </span><span class="s1">viewport?: any</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (appRouteHandlerValidations) {</span><span class="s3">\n    </span><span class="s1">typeDefinitions += `type RouteHandlerConfig&lt;Route extends AppRouteHandlerRoutes = AppRouteHandlerRoutes&gt; = {</span><span class="s3">\n  </span><span class="s1">GET?: (request: NextRequest, context: { params: Promise&lt;ParamMap[Route]&gt; }) =&gt; Promise&lt;Response | void&gt; | Response | void</span><span class="s3">\n  </span><span class="s1">POST?: (request: NextRequest, context: { params: Promise&lt;ParamMap[Route]&gt; }) =&gt; Promise&lt;Response | void&gt; | Response | void</span><span class="s3">\n  </span><span class="s1">PUT?: (request: NextRequest, context: { params: Promise&lt;ParamMap[Route]&gt; }) =&gt; Promise&lt;Response | void&gt; | Response | void</span><span class="s3">\n  </span><span class="s1">PATCH?: (request: NextRequest, context: { params: Promise&lt;ParamMap[Route]&gt; }) =&gt; Promise&lt;Response | void&gt; | Response | void</span><span class="s3">\n  </span><span class="s1">DELETE?: (request: NextRequest, context: { params: Promise&lt;ParamMap[Route]&gt; }) =&gt; Promise&lt;Response | void&gt; | Response | void</span><span class="s3">\n  </span><span class="s1">HEAD?: (request: NextRequest, context: { params: Promise&lt;ParamMap[Route]&gt; }) =&gt; Promise&lt;Response | void&gt; | Response | void</span><span class="s3">\n  </span><span class="s1">OPTIONS?: (request: NextRequest, context: { params: Promise&lt;ParamMap[Route]&gt; }) =&gt; Promise&lt;Response | void&gt; | Response | void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (pagesApiRouteValidations) {</span><span class="s3">\n    </span><span class="s1">typeDefinitions += `type ApiRouteConfig = {</span><span class="s3">\n  </span><span class="s1">default: (req: any, res: any) =&gt; ReturnType&lt;NextApiHandler&gt;</span><span class="s3">\n  </span><span class="s1">config?: {</span><span class="s3">\n    </span><span class="s1">api?: {</span><span class="s3">\n      </span><span class="s1">bodyParser?: boolean | { sizeLimit?: string }</span><span class="s3">\n      </span><span class="s1">responseLimit?: string | number | boolean</span><span class="s3">\n      </span><span class="s1">externalResolver?: boolean</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">runtime?: 'edge' | 'experimental-edge' | 'nodejs' | string // necessary unless config is exported as const</span><span class="s3">\n    </span><span class="s1">maxDuration?: number</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Build import statement based on what's actually needed</span><span class="s3">\n  </span><span class="s1">const routeImports = []</span><span class="s3">\n\n  </span><span class="s1">// Only import AppRoutes if there are app pages</span><span class="s3">\n  </span><span class="s1">if (appPageValidations) {</span><span class="s3">\n    </span><span class="s1">routeImports.push('AppRoutes')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Only import LayoutRoutes if there are layouts</span><span class="s3">\n  </span><span class="s1">if (layoutValidations) {</span><span class="s3">\n    </span><span class="s1">routeImports.push('LayoutRoutes')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Only import ParamMap if there are routes that use it</span><span class="s3">\n  </span><span class="s1">if (appPageValidations || layoutValidations || appRouteHandlerValidations) {</span><span class="s3">\n    </span><span class="s1">routeImports.push('ParamMap')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (hasAppRouteHandlers) {</span><span class="s3">\n    </span><span class="s1">routeImports.push('AppRouteHandlerRoutes')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const routeImportStatement =</span><span class="s3">\n    </span><span class="s1">routeImports.length &gt; 0</span><span class="s3">\n      </span><span class="s1">? `import type { ${routeImports.join(', ')} } from </span><span class="s3">\&quot;</span><span class="s1">./routes.js</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n      </span><span class="s1">: ''</span><span class="s3">\n\n  </span><span class="s1">const nextRequestImport = hasAppRouteHandlers</span><span class="s3">\n    </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">import type { NextRequest } from 'next/server.js'</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot;\n    </span><span class="s1">: ''</span><span class="s3">\n\n  </span><span class="s1">// Conditionally import types from next/types, merged into a single statement</span><span class="s3">\n  </span><span class="s1">const nextTypes: string[] = []</span><span class="s3">\n  </span><span class="s1">if (pagesApiRouteValidations) {</span><span class="s3">\n    </span><span class="s1">nextTypes.push('NextApiHandler')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (appPageValidations || layoutValidations) {</span><span class="s3">\n    </span><span class="s1">nextTypes.push('ResolvingMetadata', 'ResolvingViewport')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const nextTypesImport =</span><span class="s3">\n    </span><span class="s1">nextTypes.length &gt; 0</span><span class="s3">\n      </span><span class="s1">? `import type { ${nextTypes.join(', ')} } from </span><span class="s3">\&quot;</span><span class="s1">next/types.js</span><span class="s3">\&quot;\\</span><span class="s1">n`</span><span class="s3">\n      </span><span class="s1">: ''</span><span class="s3">\n\n  </span><span class="s1">return `// This file is generated automatically by Next.js</span><span class="s3">\n</span><span class="s1">// Do not edit this file manually</span><span class="s3">\n</span><span class="s1">// This file validates that all pages and layouts export the correct types</span><span class="s3">\n\n</span><span class="s1">${routeImportStatement}</span><span class="s3">\n</span><span class="s1">${nextTypesImport}${nextRequestImport}</span><span class="s3">\n</span><span class="s1">${typeDefinitions}</span><span class="s3">\n</span><span class="s1">${appPageValidations}</span><span class="s3">\n\n</span><span class="s1">${appRouteHandlerValidations}</span><span class="s3">\n\n</span><span class="s1">${pagesRouterPageValidations}</span><span class="s3">\n\n</span><span class="s1">${pagesApiRouteValidations}</span><span class="s3">\n\n</span><span class="s1">${layoutValidations}</span><span class="s3">\n</span><span class="s1">`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function generateRouteTypesFile(</span><span class="s3">\n  </span><span class="s1">routesManifest: RouteTypesManifest</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">const routeTypes = generateRouteTypes(routesManifest)</span><span class="s3">\n  </span><span class="s1">const paramTypes = generateParamTypes(routesManifest)</span><span class="s3">\n  </span><span class="s1">const layoutSlotMap = generateLayoutSlotMap(routesManifest)</span><span class="s3">\n\n  </span><span class="s1">const hasAppRouteHandlers =</span><span class="s3">\n    </span><span class="s1">Object.keys(routesManifest.appRouteHandlerRoutes).length &gt; 0</span><span class="s3">\n\n  </span><span class="s1">// Build export statement based on what's actually generated</span><span class="s3">\n  </span><span class="s1">const routeExports = [</span><span class="s3">\n    </span><span class="s1">'AppRoutes',</span><span class="s3">\n    </span><span class="s1">'PageRoutes',</span><span class="s3">\n    </span><span class="s1">'LayoutRoutes',</span><span class="s3">\n    </span><span class="s1">'RedirectRoutes',</span><span class="s3">\n    </span><span class="s1">'RewriteRoutes',</span><span class="s3">\n    </span><span class="s1">'ParamMap',</span><span class="s3">\n  </span><span class="s1">]</span><span class="s3">\n  </span><span class="s1">if (hasAppRouteHandlers) {</span><span class="s3">\n    </span><span class="s1">routeExports.push('AppRouteHandlerRoutes')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const exportStatement = `export type { ${routeExports.join(', ')} }`</span><span class="s3">\n\n  </span><span class="s1">const routeContextInterface = hasAppRouteHandlers</span><span class="s3">\n    </span><span class="s1">? `</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Context for Next.js App Router route handlers</span><span class="s3">\n   </span><span class="s1">* @example</span><span class="s3">\n   </span><span class="s1">* </span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`tsx</span><span class="s3">\n   </span><span class="s1">* export async function GET(request: NextRequest, context: RouteContext&lt;'/api/users/[id]'&gt;) {</span><span class="s3">\n   </span><span class="s1">*   const { id } = await context.params</span><span class="s3">\n   </span><span class="s1">*   return Response.json({ id })</span><span class="s3">\n   </span><span class="s1">* }</span><span class="s3">\n   </span><span class="s1">* </span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">interface RouteContext&lt;AppRouteHandlerRoute extends AppRouteHandlerRoutes&gt; {</span><span class="s3">\n    </span><span class="s1">params: Promise&lt;ParamMap[AppRouteHandlerRoute]&gt;</span><span class="s3">\n  </span><span class="s1">}`</span><span class="s3">\n    </span><span class="s1">: ''</span><span class="s3">\n\n  </span><span class="s1">return `// This file is generated automatically by Next.js</span><span class="s3">\n</span><span class="s1">// Do not edit this file manually</span><span class="s3">\n\n</span><span class="s1">${routeTypes}</span><span class="s3">\n\n</span><span class="s1">${paramTypes}</span><span class="s3">\n\n</span><span class="s1">export type ParamsOf&lt;Route extends Routes&gt; = ParamMap[Route]</span><span class="s3">\n\n</span><span class="s1">${layoutSlotMap}</span><span class="s3">\n\n</span><span class="s1">${exportStatement}</span><span class="s3">\n\n</span><span class="s1">declare global {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Props for Next.js App Router page components</span><span class="s3">\n   </span><span class="s1">* @example</span><span class="s3">\n   </span><span class="s1">* </span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`tsx</span><span class="s3">\n   </span><span class="s1">* export default function Page(props: PageProps&lt;'/blog/[slug]'&gt;) {</span><span class="s3">\n   </span><span class="s1">*   const { slug } = await props.params</span><span class="s3">\n   </span><span class="s1">*   return &lt;div&gt;Blog post: {slug}&lt;/div&gt;</span><span class="s3">\n   </span><span class="s1">* }</span><span class="s3">\n   </span><span class="s1">* </span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">interface PageProps&lt;AppRoute extends AppRoutes&gt; {</span><span class="s3">\n    </span><span class="s1">params: Promise&lt;ParamMap[AppRoute]&gt;</span><span class="s3">\n    </span><span class="s1">searchParams: Promise&lt;Record&lt;string, string | string[] | undefined&gt;&gt;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Props for Next.js App Router layout components</span><span class="s3">\n   </span><span class="s1">* @example</span><span class="s3">\n   </span><span class="s1">* </span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`tsx</span><span class="s3">\n   </span><span class="s1">* export default function Layout(props: LayoutProps&lt;'/dashboard'&gt;) {</span><span class="s3">\n   </span><span class="s1">*   return &lt;div&gt;{props.children}&lt;/div&gt;</span><span class="s3">\n   </span><span class="s1">* }</span><span class="s3">\n   </span><span class="s1">* </span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">type LayoutProps&lt;LayoutRoute extends LayoutRoutes&gt; = {</span><span class="s3">\n    </span><span class="s1">params: Promise&lt;ParamMap[LayoutRoute]&gt;</span><span class="s3">\n    </span><span class="s1">children: React.ReactNode</span><span class="s3">\n  </span><span class="s1">} &amp; {</span><span class="s3">\n    </span><span class="s1">[K in LayoutSlotMap[LayoutRoute]]: React.ReactNode</span><span class="s3">\n  </span><span class="s1">}${routeContextInterface}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;generateLinkTypesFile&quot;</span><span class="s0">,</span><span class="s1">&quot;generateRouteTypesFile&quot;</span><span class="s0">,</span><span class="s1">&quot;generateValidatorFile&quot;</span><span class="s0">,</span><span class="s1">&quot;generateRouteTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;routesManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;appRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;sort&quot;</span><span class="s0">,</span><span class="s1">&quot;pageRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;layoutRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;redirectRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;appRouteHandlerRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;hasAppRouteHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;routeUnionParts&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;generateParamTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;allRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;paramTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;sortedRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;a&quot;</span><span class="s0">,</span><span class="s1">&quot;b&quot;</span><span class="s0">,</span><span class="s1">&quot;localeCompare&quot;</span><span class="s0">,</span><span class="s1">&quot;routeInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;groups&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;paramType&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;group&quot;</span><span class="s0">,</span><span class="s1">&quot;escapedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;repeat&quot;</span><span class="s0">,</span><span class="s1">&quot;optional&quot;</span><span class="s0">,</span><span class="s1">&quot;generateLayoutSlotMap&quot;</span><span class="s0">,</span><span class="s1">&quot;slotMap&quot;</span><span class="s0">,</span><span class="s1">&quot;sortedLayoutRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;slots&quot;</span><span class="s0">,</span><span class="s1">&quot;slot&quot;</span><span class="s0">,</span><span class="s1">&quot;formatRouteToRouteType&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;part&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;routeType&quot;</span><span class="s0">,</span><span class="s1">&quot;serializeRouteTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;routeTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;allRoutesSet&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;pageApiRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;staticRouteTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicRouteTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;serializedStaticRouteTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;serializedDynamicRouteTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;routeTypesFallback&quot;</span><span class="s0">,</span><span class="s1">&quot;generateValidations&quot;</span><span class="s0">,</span><span class="s1">&quot;paths&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;pathToRouteMap&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;filePath&quot;</span><span class="s0">,</span><span class="s1">&quot;importPath&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;typeWithRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;appPageValidations&quot;</span><span class="s0">,</span><span class="s1">&quot;appPagePaths&quot;</span><span class="s0">,</span><span class="s1">&quot;filePathToRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;appRouteHandlerValidations&quot;</span><span class="s0">,</span><span class="s1">&quot;appRouteHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;pagesRouterPageValidations&quot;</span><span class="s0">,</span><span class="s1">&quot;pagesRouterPagePaths&quot;</span><span class="s0">,</span><span class="s1">&quot;pagesApiRouteValidations&quot;</span><span class="s0">,</span><span class="s1">&quot;layoutValidations&quot;</span><span class="s0">,</span><span class="s1">&quot;layoutPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;typeDefinitions&quot;</span><span class="s0">,</span><span class="s1">&quot;routeImports&quot;</span><span class="s0">,</span><span class="s1">&quot;routeImportStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;nextRequestImport&quot;</span><span class="s0">,</span><span class="s1">&quot;nextTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;nextTypesImport&quot;</span><span class="s0">,</span><span class="s1">&quot;layoutSlotMap&quot;</span><span class="s0">,</span><span class="s1">&quot;routeExports&quot;</span><span class="s0">,</span><span class="s1">&quot;exportStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;routeContextInterface&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;IAuMgBA,qBAAqB;eAArBA;;IA+bAC,sBAAsB;eAAtBA;;IA9OAC,qBAAqB;eAArBA;;;2BAvZe;AAE/B,SAASC,mBAAmBC,cAAkC;IAC5D,MAAMC,YAAYC,OAAOC,IAAI,CAACH,eAAeC,SAAS,EAAEG,IAAI;IAC5D,MAAMC,aAAaH,OAAOC,IAAI,CAACH,eAAeK,UAAU,EAAED,IAAI;IAC9D,MAAME,eAAeJ,OAAOC,IAAI,CAACH,eAAeM,YAAY,EAAEF,IAAI;IAClE,MAAMG,iBAAiBL,OAAOC,IAAI,CAACH,eAAeO,cAAc,EAAEH,IAAI;IACtE,MAAMI,gBAAgBN,OAAOC,IAAI,CAACH,eAAeQ,aAAa,EAAEJ,IAAI;IAEpE,IAAIK,SAAS;IAEb,6CAA6C;IAC7C,IAAIR,UAAUS,MAAM,GAAG,GAAG;QACxBD,UAAU,CAAC,iBAAiB,EAAER,UAAUU,GAAG,CAAC,CAACC,QAAUC,KAAKC,SAAS,CAACF,QAAQG,IAAI,CAAC,OAAO,EAAE,CAAC;IAC/F,OAAO;QACLN,UAAU;IACZ;IAEA,+DAA+D;IAC/D,MAAMO,wBAAwBd,OAAOC,IAAI,CACvCH,eAAegB,qBAAqB,EACpCZ,IAAI;IAEN,MAAMa,sBAAsBD,sBAAsBN,MAAM,GAAG;IAE3D,IAAIO,qBAAqB;QACvBR,UAAU,CAAC,6BAA6B,EAAEO,sBAAsBL,GAAG,CAAC,CAACC,QAAUC,KAAKC,SAAS,CAACF,QAAQG,IAAI,CAAC,OAAO,EAAE,CAAC;IACvH;IAEA,iCAAiC;IACjC,IAAIV,WAAWK,MAAM,GAAG,GAAG;QACzBD,UAAU,CAAC,kBAAkB,EAAEJ,WAAWM,GAAG,CAAC,CAACC,QAAUC,KAAKC,SAAS,CAACF,QAAQG,IAAI,CAAC,OAAO,EAAE,CAAC;IACjG,OAAO;QACLN,UAAU;IACZ;IAEA,mCAAmC;IACnC,IAAIH,aAAaI,MAAM,GAAG,GAAG;QAC3BD,UAAU,CAAC,oBAAoB,EAAEH,aAAaK,GAAG,CAAC,CAACC,QAAUC,KAAKC,SAAS,CAACF,QAAQG,IAAI,CAAC,OAAO,EAAE,CAAC;IACrG,OAAO;QACLN,UAAU;IACZ;IAEA,qCAAqC;IACrC,IAAIF,eAAeG,MAAM,GAAG,GAAG;QAC7BD,UAAU,CAAC,sBAAsB,EAAEF,eAChCI,GAAG,CAAC,CAACC,QAAUC,KAAKC,SAAS,CAACF,QAC9BG,IAAI,CAAC,OAAO,EAAE,CAAC;IACpB,OAAO;QACLN,UAAU;IACZ;IAEA,oCAAoC;IACpC,IAAID,cAAcE,MAAM,GAAG,GAAG;QAC5BD,UAAU,CAAC,qBAAqB,EAAED,cAC/BG,GAAG,CAAC,CAACC,QAAUC,KAAKC,SAAS,CAACF,QAC9BG,IAAI,CAAC,OAAO,EAAE,CAAC;IACpB,OAAO;QACLN,UAAU;IACZ;IAEA,wFAAwF;IACxF,MAAMS,kBAAkB;QACtB;QACA;QACA;QACA;QACA;KACD;IACD,IAAID,qBAAqB;QACvBC,gBAAgBC,IAAI,CAAC;IACvB;IAEAV,UAAU,CAAC,cAAc,EAAES,gBAAgBH,IAAI,CAAC,OAAO,EAAE,CAAC;IAE1D,OAAON;AACT;AAEA,SAASW,mBAAmBpB,cAAkC;IAC5D,MAAMqB,YAAY;QAChB,GAAGrB,eAAeC,SAAS;QAC3B,GAAGD,eAAegB,qBAAqB;QACvC,GAAGhB,eAAeK,UAAU;QAC5B,GAAGL,eAAeM,YAAY;QAC9B,GAAGN,eAAeO,cAAc;QAChC,GAAGP,eAAeQ,aAAa;IACjC;IAEA,IAAIc,aAAa;IAEjB,sDAAsD;IACtD,MAAMC,eAAerB,OAAOsB,OAAO,CAACH,WAAWjB,IAAI,CAAC,CAAC,CAACqB,EAAE,EAAE,CAACC,EAAE,GAC3DD,EAAEE,aAAa,CAACD;IAGlB,KAAK,MAAM,CAACd,OAAOgB,UAAU,IAAIL,aAAc;QAC7C,MAAM,EAAEM,MAAM,EAAE,GAAGD;QAEnB,kFAAkF;QAClF,IAAI,CAACE,IAAAA,yBAAc,EAAClB,UAAUV,OAAOC,IAAI,CAAC0B,UAAU,CAAC,GAAGnB,MAAM,KAAK,GAAG;YACpEY,cAAc,CAAC,EAAE,EAAET,KAAKC,SAAS,CAACF,OAAO,MAAM,CAAC;YAChD;QACF;QAEA,IAAImB,YAAY;QAEhB,6CAA6C;QAC7C,KAAK,MAAM,CAACC,KAAKC,MAAM,IAAI/B,OAAOsB,OAAO,CAACK,QAAS;YACjD,MAAMK,aAAarB,KAAKC,SAAS,CAACkB;YAClC,IAAIC,MAAME,MAAM,EAAE;gBAChB,uBAAuB;gBACvB,IAAIF,MAAMG,QAAQ,EAAE;oBAClBL,aAAa,CAAC,CAAC,EAAEG,WAAW,YAAY,CAAC;gBAC3C,OAAO;oBACLH,aAAa,CAAC,CAAC,EAAEG,WAAW,WAAW,CAAC;gBAC1C;YACF,OAAO;gBACL,qBAAqB;gBACrB,IAAID,MAAMG,QAAQ,EAAE;oBAClBL,aAAa,CAAC,CAAC,EAAEG,WAAW,UAAU,CAAC;gBACzC,OAAO;oBACLH,aAAa,CAAC,CAAC,EAAEG,WAAW,SAAS,CAAC;gBACxC;YACF;QACF;QAEAH,aAAa;QAEbT,cAAc,CAAC,EAAE,EAAET,KAAKC,SAAS,CAACF,OAAO,EAAE,EAAEmB,UAAU,EAAE,CAAC;IAC5D;IAEAT,cAAc;IACd,OAAOA;AACT;AAEA,SAASe,sBAAsBrC,cAAkC;IAC/D,IAAIsC,UAAU;IAEd,sDAAsD;IACtD,MAAMC,qBAAqBrC,OAAOsB,OAAO,CAACxB,eAAeM,YAAY,EAAEF,IAAI,CACzE,CAAC,CAACqB,EAAE,EAAE,CAACC,EAAE,GAAKD,EAAEE,aAAa,CAACD;IAGhC,KAAK,MAAM,CAACd,OAAOgB,UAAU,IAAIW,mBAAoB;QACnD,IAAI,WAAWX,WAAW;YACxB,MAAMY,QAAQZ,UAAUY,KAAK,CAACpC,IAAI;YAClC,IAAIoC,MAAM9B,MAAM,GAAG,GAAG;gBACpB4B,WAAW,CAAC,EAAE,EAAEzB,KAAKC,SAAS,CAACF,OAAO,EAAE,EAAE4B,MAAM7B,GAAG,CAAC,CAAC8B,OAAS5B,KAAKC,SAAS,CAAC2B,OAAO1B,IAAI,CAAC,OAAO,EAAE,CAAC;YACrG,OAAO;gBACLuB,WAAW,CAAC,EAAE,EAAEzB,KAAKC,SAAS,CAACF,OAAO,SAAS,CAAC;YAClD;QACF,OAAO;YACL0B,WAAW,CAAC,EAAE,EAAEzB,KAAKC,SAAS,CAACF,OAAO,SAAS,CAAC;QAClD;IACF;IAEA0B,WAAW;IACX,OAAOA;AACT;AAEA,qFAAqF;AACrF,SAASI,uBAAuB9B,KAAa;IAC3C,MAAM+B,YAAYb,IAAAA,yBAAc,EAAClB;IACjC,IAAI+B,WAAW;QACb/B,QAAQA,MACLgC,KAAK,CAAC,KACNjC,GAAG,CAAC,CAACkC;YACJ,IAAIA,KAAKC,UAAU,CAAC,QAAQD,KAAKE,QAAQ,CAAC,MAAM;gBAC9C,IAAIF,KAAKC,UAAU,CAAC,SAAS;oBAC3B,aAAa;oBACb,OAAO,CAAC,mBAAmB,CAAC;gBAC9B,OAAO,IAAID,KAAKC,UAAU,CAAC,YAAYD,KAAKE,QAAQ,CAAC,OAAO;oBAC1D,eAAe;oBACf,OAAO,CAAC,2BAA2B,CAAC;gBACtC;gBACA,UAAU;gBACV,OAAO,CAAC,eAAe,CAAC;YAC1B;YACA,OAAOF;QACT,GACC9B,IAAI,CAAC;IACV;IAEA,OAAO;QACL4B;QACAK,WAAWpC;IACb;AACF;AAEA,8EAA8E;AAC9E,SAASqC,oBAAoBC,UAAoB;IAC/C,yFAAyF;IACzF,OAAOA,WACJ9C,IAAI,GACJO,GAAG,CAAC,CAACC,QAAU,CAAC,UAAU,EAAEA,MAAM,EAAE,CAAC,EACrCG,IAAI,CAAC;AACV;AAEO,SAASnB,sBACdI,cAAkC;IAElC,2EAA2E;IAC3E,6EAA6E;IAC7E,kDAAkD;IAClD,MAAMmD,eAAe,IAAIC,IAAY;WAChClD,OAAOC,IAAI,CAACH,eAAeC,SAAS;WACpCC,OAAOC,IAAI,CAACH,eAAeK,UAAU;WACrCH,OAAOC,IAAI,CAACH,eAAeO,cAAc;WACzCL,OAAOC,IAAI,CAACH,eAAeQ,aAAa;QAC3C,gEAAgE;WAC7DN,OAAOC,IAAI,CAACH,eAAegB,qBAAqB;QACnD,2DAA2D;WACxDqC,MAAMC,IAAI,CAACtD,eAAeuD,aAAa;KAC3C;IAED,MAAMC,mBAA6B,EAAE;IACrC,MAAMC,oBAA8B,EAAE;IAEtC,wDAAwD;IACxD,KAAK,MAAM7C,SAASuC,aAAc;QAChC,MAAM,EAAER,SAAS,EAAEK,SAAS,EAAE,GAAGN,uBAAuB9B;QACxD,IAAI+B,WAAW;YACbc,kBAAkBtC,IAAI,CAAC6B;QACzB,OAAO;YACLQ,iBAAiBrC,IAAI,CAAC6B;QACxB;IACF;IAEA,MAAMU,6BAA6BT,oBAAoBO;IACvD,MAAMG,8BAA8BV,oBAAoBQ;IAExD,oFAAoF;IACpF,MAAMG,qBACJ,CAACF,8BAA8B,CAACC,8BAC5B,gBACA;IAEN,OAAO,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sBAiCY,EAAED,8BAA8B,QAAQ;kDACZ,EAC9CC,+BAA+B,QAChC;;sBAEmB,EAClBC,sBACA,CAAC;IACD,EACE,uDAAuD;IACvD,iBACD;;;;;IAKD,CAAC,CACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqHH,CAAC;AACD;AAEO,SAAS9D,sBACdE,cAAkC;IAElC,MAAM6D,sBAAsB,CAC1BC,OACAC,MAMAC,iBAEAF,MACG1D,IAAI,EACL,6FAA6F;SAC5F6D,MAAM,CACL,CAACC,WAAaA,SAASnB,QAAQ,CAAC,UAAUmB,SAASnB,QAAQ,CAAC,SAE7DkB,MAAM,CACL,yCAAyC;QACzC,+BAA+B;QAC/B,CAACC,WACCH,SAAS,mBACTG,SAASnB,QAAQ,CAAC,cAClBmB,SAASnB,QAAQ,CAAC,aAErBpC,GAAG,CAAC,CAACuD;YACJ,qFAAqF;YACrF,MAAMC,aAAaD;YACnB,MAAMtD,QAAQoD,kCAAAA,eAAgBI,GAAG,CAACF;YAClC,MAAMG,gBACJzD,SACCmD,CAAAA,SAAS,mBACRA,SAAS,kBACTA,SAAS,oBAAmB,IAC1B,GAAGA,KAAK,CAAC,EAAElD,KAAKC,SAAS,CAACF,OAAO,CAAC,CAAC,GACnCmD;YACN,OAAO,CAAC,YAAY,EAAEG,SAAS;;qCAEF,EAAEG,cAAc;sCACf,EAAExD,KAAKC,SAAS,CAClDqD,WAAWG,OAAO,CAAC,WAAW,QAC9B;;;;CAIH,CAAC;QACI,GACCvD,IAAI,CAAC;IAEV,wCAAwC;IAExC,iDAAiD;IACjD,MAAMwD,qBAAqBV,oBACzBR,MAAMC,IAAI,CAACtD,eAAewE,YAAY,EAAEpE,IAAI,IAC5C,iBACAJ,eAAeyE,eAAe;IAEhC,MAAMC,6BAA6Bb,oBACjCR,MAAMC,IAAI,CAACtD,eAAe2E,gBAAgB,EAAEvE,IAAI,IAChD,sBACAJ,eAAeyE,eAAe;IAEhC,MAAMG,6BAA6Bf,oBACjCR,MAAMC,IAAI,CAACtD,eAAe6E,oBAAoB,EAAEzE,IAAI,IACpD;IAEF,MAAM0E,2BAA2BjB,oBAC/BR,MAAMC,IAAI,CAACtD,eAAeuD,aAAa,EAAEnD,IAAI,IAC7C;IAEF,MAAM2E,oBAAoBlB,oBACxBR,MAAMC,IAAI,CAACtD,eAAegF,WAAW,EAAE5E,IAAI,IAC3C,gBACAJ,eAAeyE,eAAe;IAGhC,MAAMxD,sBACJf,OAAOC,IAAI,CAACH,eAAegB,qBAAqB,EAAEN,MAAM,GAAG;IAE7D,uDAAuD;IACvD,IAAIuE,kBAAkB;IAEtB,IAAIV,oBAAoB;QACtBU,mBAAmB,CAAC;;;;;;;;;;;;;;;AAexB,CAAC;IACC;IAEA,IAAIL,4BAA4B;QAC9BK,mBAAmB,CAAC;;;;;;;;;;;;;;;;;;AAkBxB,CAAC;IACC;IAEA,IAAIF,mBAAmB;QACrBE,mBAAmB,CAAC;;;;;;;;;;;;;;;AAexB,CAAC;IACC;IAEA,IAAIP,4BAA4B;QAC9BO,mBAAmB,CAAC;;;;;;;;;;AAUxB,CAAC;IACC;IAEA,IAAIH,0BAA0B;QAC5BG,mBAAmB,CAAC;;;;;;;;;;;;;AAaxB,CAAC;IACC;IAEA,yDAAyD;IACzD,MAAMC,eAAe,EAAE;IAEvB,+CAA+C;IAC/C,IAAIX,oBAAoB;QACtBW,aAAa/D,IAAI,CAAC;IACpB;IAEA,gDAAgD;IAChD,IAAI4D,mBAAmB;QACrBG,aAAa/D,IAAI,CAAC;IACpB;IAEA,uDAAuD;IACvD,IAAIoD,sBAAsBQ,qBAAqBL,4BAA4B;QACzEQ,aAAa/D,IAAI,CAAC;IACpB;IAEA,IAAIF,qBAAqB;QACvBiE,aAAa/D,IAAI,CAAC;IACpB;IAEA,MAAMgE,uBACJD,aAAaxE,MAAM,GAAG,IAClB,CAAC,cAAc,EAAEwE,aAAanE,IAAI,CAAC,MAAM,qBAAqB,CAAC,GAC/D;IAEN,MAAMqE,oBAAoBnE,sBACtB,wDACA;IAEJ,6EAA6E;IAC7E,MAAMoE,YAAsB,EAAE;IAC9B,IAAIP,0BAA0B;QAC5BO,UAAUlE,IAAI,CAAC;IACjB;IACA,IAAIoD,sBAAsBQ,mBAAmB;QAC3CM,UAAUlE,IAAI,CAAC,qBAAqB;IACtC;IACA,MAAMmE,kBACJD,UAAU3E,MAAM,GAAG,IACf,CAAC,cAAc,EAAE2E,UAAUtE,IAAI,CAAC,MAAM,yBAAyB,CAAC,GAChE;IAEN,OAAO,CAAC;;;;AAIV,EAAEoE,qBAAqB;AACvB,EAAEG,kBAAkBF,kBAAkB;AACtC,EAAEH,gBAAgB;AAClB,EAAEV,mBAAmB;;AAErB,EAAEG,2BAA2B;;AAE7B,EAAEE,2BAA2B;;AAE7B,EAAEE,yBAAyB;;AAE3B,EAAEC,kBAAkB;AACpB,CAAC;AACD;AAEO,SAASlF,uBACdG,cAAkC;IAElC,MAAMkD,aAAanD,mBAAmBC;IACtC,MAAMsB,aAAaF,mBAAmBpB;IACtC,MAAMuF,gBAAgBlD,sBAAsBrC;IAE5C,MAAMiB,sBACJf,OAAOC,IAAI,CAACH,eAAegB,qBAAqB,EAAEN,MAAM,GAAG;IAE7D,4DAA4D;IAC5D,MAAM8E,eAAe;QACnB;QACA;QACA;QACA;QACA;QACA;KACD;IACD,IAAIvE,qBAAqB;QACvBuE,aAAarE,IAAI,CAAC;IACpB;IAEA,MAAMsE,kBAAkB,CAAC,cAAc,EAAED,aAAazE,IAAI,CAAC,MAAM,EAAE,CAAC;IAEpE,MAAM2E,wBAAwBzE,sBAC1B,CAAC;;;;;;;;;;;;;;GAcJ,CAAC,GACE;IAEJ,OAAO,CAAC;;;AAGV,EAAEiC,WAAW;;AAEb,EAAE5B,WAAW;;;;AAIb,EAAEiE,cAAc;;AAEhB,EAAEE,gBAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAgCf,EAAEC,sBAAsB;;AAE3B,CAAC;AACD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>