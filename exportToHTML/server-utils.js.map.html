<html>
<head>
<title>server-utils.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
server-utils.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/server/server-utils.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { Rewrite } from '../lib/load-custom-routes'</span><span class="s3">\n</span><span class="s1">import type { RouteMatchFn } from '../shared/lib/router/utils/route-matcher'</span><span class="s3">\n</span><span class="s1">import type { NextConfig } from './config'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from './base-http'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import type { UrlWithParsedQuery } from 'url'</span><span class="s3">\n\n</span><span class="s1">import { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path'</span><span class="s3">\n</span><span class="s1">import { getPathMatch } from '../shared/lib/router/utils/path-match'</span><span class="s3">\n</span><span class="s1">import { getNamedRouteRegex } from '../shared/lib/router/utils/route-regex'</span><span class="s3">\n</span><span class="s1">import { getRouteMatcher } from '../shared/lib/router/utils/route-matcher'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">matchHas,</span><span class="s3">\n  </span><span class="s1">prepareDestination,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/router/utils/prepare-destination'</span><span class="s3">\n</span><span class="s1">import { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'</span><span class="s3">\n</span><span class="s1">import { normalizeRscURL } from '../shared/lib/router/utils/app-paths'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_CACHE_REVALIDATED_TAGS_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_INTERCEPTION_MARKER_PREFIX,</span><span class="s3">\n  </span><span class="s1">NEXT_QUERY_PARAM_PREFIX,</span><span class="s3">\n</span><span class="s1">} from '../lib/constants'</span><span class="s3">\n</span><span class="s1">import { normalizeNextQueryParam } from './web/utils'</span><span class="s3">\n</span><span class="s1">import type { IncomingHttpHeaders, IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import { decodeQueryPathParameter } from './lib/decode-query-path-parameter'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../shared/lib/deep-readonly'</span><span class="s3">\n</span><span class="s1">import { parseReqUrl } from '../lib/url'</span><span class="s3">\n</span><span class="s1">import { formatUrl } from '../shared/lib/router/utils/format-url'</span><span class="s3">\n</span><span class="s1">import { parseAndValidateFlightRouterState } from './app-render/parse-and-validate-flight-router-state'</span><span class="s3">\n</span><span class="s1">import { isInterceptionRouteRewrite } from '../lib/generate-interception-routes-rewrites'</span><span class="s3">\n</span><span class="s1">import { NEXT_ROUTER_STATE_TREE_HEADER } from '../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import { getSelectedParams } from '../client/components/router-reducer/compute-changed-path'</span><span class="s3">\n\n</span><span class="s1">function filterInternalQuery(</span><span class="s3">\n  </span><span class="s1">query: Record&lt;string, undefined | string | string[]&gt;,</span><span class="s3">\n  </span><span class="s1">paramKeys: string[]</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// this is used to pass query information in rewrites</span><span class="s3">\n  </span><span class="s1">// but should not be exposed in final query</span><span class="s3">\n  </span><span class="s1">delete query['nextInternalLocale']</span><span class="s3">\n\n  </span><span class="s1">for (const key in query) {</span><span class="s3">\n    </span><span class="s1">const isNextQueryPrefix =</span><span class="s3">\n      </span><span class="s1">key !== NEXT_QUERY_PARAM_PREFIX &amp;&amp; key.startsWith(NEXT_QUERY_PARAM_PREFIX)</span><span class="s3">\n\n    </span><span class="s1">const isNextInterceptionMarkerPrefix =</span><span class="s3">\n      </span><span class="s1">key !== NEXT_INTERCEPTION_MARKER_PREFIX &amp;&amp;</span><span class="s3">\n      </span><span class="s1">key.startsWith(NEXT_INTERCEPTION_MARKER_PREFIX)</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">isNextQueryPrefix ||</span><span class="s3">\n      </span><span class="s1">isNextInterceptionMarkerPrefix ||</span><span class="s3">\n      </span><span class="s1">paramKeys.includes(key)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">delete query[key]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function normalizeCdnUrl(</span><span class="s3">\n  </span><span class="s1">req: BaseNextRequest | IncomingMessage,</span><span class="s3">\n  </span><span class="s1">paramKeys: string[]</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// make sure to normalize req.url from CDNs to strip dynamic and rewrite</span><span class="s3">\n  </span><span class="s1">// params from the query which are added during routing</span><span class="s3">\n  </span><span class="s1">const _parsedUrl = parseReqUrl(req.url!)</span><span class="s3">\n\n  </span><span class="s1">// we can't normalize if we can't parse</span><span class="s3">\n  </span><span class="s1">if (!_parsedUrl) {</span><span class="s3">\n    </span><span class="s1">return req.url</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">delete (_parsedUrl as any).search</span><span class="s3">\n  </span><span class="s1">filterInternalQuery(_parsedUrl.query, paramKeys)</span><span class="s3">\n\n  </span><span class="s1">req.url = formatUrl(_parsedUrl)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function interpolateDynamicPath(</span><span class="s3">\n  </span><span class="s1">pathname: string,</span><span class="s3">\n  </span><span class="s1">params: ParsedUrlQuery,</span><span class="s3">\n  </span><span class="s1">defaultRouteRegex?: ReturnType&lt;typeof getNamedRouteRegex&gt; | undefined</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!defaultRouteRegex) return pathname</span><span class="s3">\n\n  </span><span class="s1">for (const param of Object.keys(defaultRouteRegex.groups)) {</span><span class="s3">\n    </span><span class="s1">const { optional, repeat } = defaultRouteRegex.groups[param]</span><span class="s3">\n    </span><span class="s1">let builtParam = `[${repeat ? '...' : ''}${param}]`</span><span class="s3">\n\n    </span><span class="s1">if (optional) {</span><span class="s3">\n      </span><span class="s1">builtParam = `[${builtParam}]`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let paramValue: string</span><span class="s3">\n    </span><span class="s1">const value = params[param]</span><span class="s3">\n\n    </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n      </span><span class="s1">paramValue = value.map((v) =&gt; v &amp;&amp; encodeURIComponent(v)).join('/')</span><span class="s3">\n    </span><span class="s1">} else if (value) {</span><span class="s3">\n      </span><span class="s1">paramValue = encodeURIComponent(value)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">paramValue = ''</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (paramValue || optional) {</span><span class="s3">\n      </span><span class="s1">pathname = pathname.replaceAll(builtParam, paramValue)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return pathname</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function normalizeDynamicRouteParams(</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery,</span><span class="s3">\n  </span><span class="s1">defaultRouteRegex: ReturnType&lt;typeof getNamedRouteRegex&gt;,</span><span class="s3">\n  </span><span class="s1">defaultRouteMatches: ParsedUrlQuery,</span><span class="s3">\n  </span><span class="s1">ignoreMissingOptional: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let hasValidParams = true</span><span class="s3">\n  </span><span class="s1">let params: ParsedUrlQuery = {}</span><span class="s3">\n\n  </span><span class="s1">for (const key of Object.keys(defaultRouteRegex.groups)) {</span><span class="s3">\n    </span><span class="s1">let value: string | string[] | undefined = query[key]</span><span class="s3">\n\n    </span><span class="s1">if (typeof value === 'string') {</span><span class="s3">\n      </span><span class="s1">value = normalizeRscURL(value)</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(value)) {</span><span class="s3">\n      </span><span class="s1">value = value.map(normalizeRscURL)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// if the value matches the default value we can't rely</span><span class="s3">\n    </span><span class="s1">// on the parsed params, this is used to signal if we need</span><span class="s3">\n    </span><span class="s1">// to parse x-now-route-matches or not</span><span class="s3">\n    </span><span class="s1">const defaultValue = defaultRouteMatches![key]</span><span class="s3">\n    </span><span class="s1">const isOptional = defaultRouteRegex!.groups[key].optional</span><span class="s3">\n\n    </span><span class="s1">const isDefaultValue = Array.isArray(defaultValue)</span><span class="s3">\n      </span><span class="s1">? defaultValue.some((defaultVal) =&gt; {</span><span class="s3">\n          </span><span class="s1">return Array.isArray(value)</span><span class="s3">\n            </span><span class="s1">? value.some((val) =&gt; val.includes(defaultVal))</span><span class="s3">\n            </span><span class="s1">: value?.includes(defaultVal)</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">: value?.includes(defaultValue as string)</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">isDefaultValue ||</span><span class="s3">\n      </span><span class="s1">(typeof value === 'undefined' &amp;&amp; !(isOptional &amp;&amp; ignoreMissingOptional))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return { params: {}, hasValidParams: false }</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// non-provided optional values should be undefined so normalize</span><span class="s3">\n    </span><span class="s1">// them to undefined</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">isOptional &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(!value ||</span><span class="s3">\n        </span><span class="s1">(Array.isArray(value) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">value.length === 1 &amp;&amp;</span><span class="s3">\n          </span><span class="s1">// fallback optional catch-all SSG pages have</span><span class="s3">\n          </span><span class="s1">// [[...paramName]] for the root path on Vercel</span><span class="s3">\n          </span><span class="s1">(value[0] === 'index' || value[0] === `[[...${key}]]`)))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">value = undefined</span><span class="s3">\n      </span><span class="s1">delete query[key]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// query values from the proxy aren't already split into arrays</span><span class="s3">\n    </span><span class="s1">// so make sure to normalize catch-all values</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">value &amp;&amp;</span><span class="s3">\n      </span><span class="s1">typeof value === 'string' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">defaultRouteRegex!.groups[key].repeat</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">value = value.split('/')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (value) {</span><span class="s3">\n      </span><span class="s1">params[key] = value</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">params,</span><span class="s3">\n    </span><span class="s1">hasValidParams,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getServerUtils({</span><span class="s3">\n  </span><span class="s1">page,</span><span class="s3">\n  </span><span class="s1">i18n,</span><span class="s3">\n  </span><span class="s1">basePath,</span><span class="s3">\n  </span><span class="s1">rewrites,</span><span class="s3">\n  </span><span class="s1">pageIsDynamic,</span><span class="s3">\n  </span><span class="s1">trailingSlash,</span><span class="s3">\n  </span><span class="s1">caseSensitive,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">page: string</span><span class="s3">\n  </span><span class="s1">i18n?: NextConfig['i18n']</span><span class="s3">\n  </span><span class="s1">basePath: string</span><span class="s3">\n  </span><span class="s1">rewrites: DeepReadonly&lt;{</span><span class="s3">\n    </span><span class="s1">fallback?: ReadonlyArray&lt;Rewrite&gt;</span><span class="s3">\n    </span><span class="s1">afterFiles?: ReadonlyArray&lt;Rewrite&gt;</span><span class="s3">\n    </span><span class="s1">beforeFiles?: ReadonlyArray&lt;Rewrite&gt;</span><span class="s3">\n  </span><span class="s1">}&gt;</span><span class="s3">\n  </span><span class="s1">pageIsDynamic: boolean</span><span class="s3">\n  </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n  </span><span class="s1">caseSensitive: boolean</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">let defaultRouteRegex: ReturnType&lt;typeof getNamedRouteRegex&gt; | undefined</span><span class="s3">\n  </span><span class="s1">let dynamicRouteMatcher: RouteMatchFn | undefined</span><span class="s3">\n  </span><span class="s1">let defaultRouteMatches: ParsedUrlQuery | undefined</span><span class="s3">\n\n  </span><span class="s1">if (pageIsDynamic) {</span><span class="s3">\n    </span><span class="s1">defaultRouteRegex = getNamedRouteRegex(page, {</span><span class="s3">\n      </span><span class="s1">prefixRouteKeys: false,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">dynamicRouteMatcher = getRouteMatcher(defaultRouteRegex)</span><span class="s3">\n    </span><span class="s1">defaultRouteMatches = dynamicRouteMatcher(page) as ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function handleRewrites(</span><span class="s3">\n    </span><span class="s1">req: BaseNextRequest | IncomingMessage,</span><span class="s3">\n    </span><span class="s1">parsedUrl: UrlWithParsedQuery</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const rewriteParams: Record&lt;string, string&gt; = {}</span><span class="s3">\n    </span><span class="s1">let fsPathname = parsedUrl.pathname</span><span class="s3">\n\n    </span><span class="s1">const matchesPage = () =&gt; {</span><span class="s3">\n      </span><span class="s1">const fsPathnameNoSlash = removeTrailingSlash(fsPathname || '')</span><span class="s3">\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">fsPathnameNoSlash === removeTrailingSlash(page) ||</span><span class="s3">\n        </span><span class="s1">dynamicRouteMatcher?.(fsPathnameNoSlash)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const checkRewrite = (rewrite: DeepReadonly&lt;Rewrite&gt;): boolean =&gt; {</span><span class="s3">\n      </span><span class="s1">const matcher = getPathMatch(</span><span class="s3">\n        </span><span class="s1">rewrite.source + (trailingSlash ? '(/)?' : ''),</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">removeUnnamedParams: true,</span><span class="s3">\n          </span><span class="s1">strict: true,</span><span class="s3">\n          </span><span class="s1">sensitive: !!caseSensitive,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">if (!parsedUrl.pathname) return false</span><span class="s3">\n\n      </span><span class="s1">let params = matcher(parsedUrl.pathname)</span><span class="s3">\n\n      </span><span class="s1">if ((rewrite.has || rewrite.missing) &amp;&amp; params) {</span><span class="s3">\n        </span><span class="s1">const hasParams = matchHas(</span><span class="s3">\n          </span><span class="s1">req,</span><span class="s3">\n          </span><span class="s1">parsedUrl.query,</span><span class="s3">\n          </span><span class="s1">rewrite.has as Rewrite['has'],</span><span class="s3">\n          </span><span class="s1">rewrite.missing as Rewrite['missing']</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">if (hasParams) {</span><span class="s3">\n          </span><span class="s1">Object.assign(params, hasParams)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">params = false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (params) {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">// An interception rewrite might reference a dynamic param for a route the user</span><span class="s3">\n          </span><span class="s1">// is currently on, which wouldn't be extractable from the matched route params.</span><span class="s3">\n          </span><span class="s1">// This attempts to extract the dynamic params from the provided router state.</span><span class="s3">\n          </span><span class="s1">if (isInterceptionRouteRewrite(rewrite as Rewrite)) {</span><span class="s3">\n            </span><span class="s1">const stateHeader = req.headers[NEXT_ROUTER_STATE_TREE_HEADER]</span><span class="s3">\n\n            </span><span class="s1">if (stateHeader) {</span><span class="s3">\n              </span><span class="s1">params = {</span><span class="s3">\n                </span><span class="s1">...getSelectedParams(</span><span class="s3">\n                  </span><span class="s1">parseAndValidateFlightRouterState(stateHeader)</span><span class="s3">\n                </span><span class="s1">),</span><span class="s3">\n                </span><span class="s1">...params,</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} catch (err) {</span><span class="s3">\n          </span><span class="s1">// this is a no-op -- we couldn't extract dynamic params from the provided router state,</span><span class="s3">\n          </span><span class="s1">// so we'll just use the params from the route matcher</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const { parsedDestination, destQuery } = prepareDestination({</span><span class="s3">\n          </span><span class="s1">appendParamsToQuery: true,</span><span class="s3">\n          </span><span class="s1">destination: rewrite.destination,</span><span class="s3">\n          </span><span class="s1">params: params,</span><span class="s3">\n          </span><span class="s1">query: parsedUrl.query,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">// if the rewrite destination is external break rewrite chain</span><span class="s3">\n        </span><span class="s1">if (parsedDestination.protocol) {</span><span class="s3">\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">Object.assign(rewriteParams, destQuery, params)</span><span class="s3">\n        </span><span class="s1">Object.assign(parsedUrl.query, parsedDestination.query)</span><span class="s3">\n        </span><span class="s1">delete (parsedDestination as any).query</span><span class="s3">\n\n        </span><span class="s1">// for each property in parsedUrl.query, if the value is parametrized (eg :foo), look up the value</span><span class="s3">\n        </span><span class="s1">// in rewriteParams and replace the parametrized value with the actual value</span><span class="s3">\n        </span><span class="s1">// this is used when the rewrite destination does not contain the original source param</span><span class="s3">\n        </span><span class="s1">// and so the value is still parametrized and needs to be replaced with the actual rewrite param</span><span class="s3">\n        </span><span class="s1">Object.entries(parsedUrl.query).forEach(([key, value]) =&gt; {</span><span class="s3">\n          </span><span class="s1">if (value &amp;&amp; typeof value === 'string' &amp;&amp; value.startsWith(':')) {</span><span class="s3">\n            </span><span class="s1">const paramName = value.slice(1)</span><span class="s3">\n            </span><span class="s1">const actualValue = rewriteParams[paramName]</span><span class="s3">\n            </span><span class="s1">if (actualValue) {</span><span class="s3">\n              </span><span class="s1">parsedUrl.query[key] = actualValue</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">Object.assign(parsedUrl, parsedDestination)</span><span class="s3">\n\n        </span><span class="s1">fsPathname = parsedUrl.pathname</span><span class="s3">\n        </span><span class="s1">if (!fsPathname) return false</span><span class="s3">\n\n        </span><span class="s1">if (basePath) {</span><span class="s3">\n          </span><span class="s1">fsPathname = fsPathname.replace(new RegExp(`^${basePath}`), '') || '/'</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (i18n) {</span><span class="s3">\n          </span><span class="s1">const result = normalizeLocalePath(fsPathname, i18n.locales)</span><span class="s3">\n          </span><span class="s1">fsPathname = result.pathname</span><span class="s3">\n          </span><span class="s1">parsedUrl.query.nextInternalLocale =</span><span class="s3">\n            </span><span class="s1">result.detectedLocale || params.nextInternalLocale</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (fsPathname === page) {</span><span class="s3">\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (pageIsDynamic &amp;&amp; dynamicRouteMatcher) {</span><span class="s3">\n          </span><span class="s1">const dynamicParams = dynamicRouteMatcher(fsPathname)</span><span class="s3">\n          </span><span class="s1">if (dynamicParams) {</span><span class="s3">\n            </span><span class="s1">parsedUrl.query = {</span><span class="s3">\n              </span><span class="s1">...parsedUrl.query,</span><span class="s3">\n              </span><span class="s1">...dynamicParams,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return true</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const rewrite of rewrites.beforeFiles || []) {</span><span class="s3">\n      </span><span class="s1">checkRewrite(rewrite)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (fsPathname !== page) {</span><span class="s3">\n      </span><span class="s1">let finished = false</span><span class="s3">\n\n      </span><span class="s1">for (const rewrite of rewrites.afterFiles || []) {</span><span class="s3">\n        </span><span class="s1">finished = checkRewrite(rewrite)</span><span class="s3">\n        </span><span class="s1">if (finished) break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (!finished &amp;&amp; !matchesPage()) {</span><span class="s3">\n        </span><span class="s1">for (const rewrite of rewrites.fallback || []) {</span><span class="s3">\n          </span><span class="s1">finished = checkRewrite(rewrite)</span><span class="s3">\n          </span><span class="s1">if (finished) break</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return rewriteParams</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function getParamsFromRouteMatches(routeMatchesHeader: string) {</span><span class="s3">\n    </span><span class="s1">// If we don't have a default route regex, we can't get params from route</span><span class="s3">\n    </span><span class="s1">// matches</span><span class="s3">\n    </span><span class="s1">if (!defaultRouteRegex) return null</span><span class="s3">\n\n    </span><span class="s1">const { groups, routeKeys } = defaultRouteRegex</span><span class="s3">\n\n    </span><span class="s1">const matcher = getRouteMatcher({</span><span class="s3">\n      </span><span class="s1">re: {</span><span class="s3">\n        </span><span class="s1">// Simulate a RegExp match from the </span><span class="s3">\\</span><span class="s1">`req.url</span><span class="s3">\\</span><span class="s1">` input</span><span class="s3">\n        </span><span class="s1">exec: (str: string) =&gt; {</span><span class="s3">\n          </span><span class="s1">// Normalize all the prefixed query params.</span><span class="s3">\n          </span><span class="s1">const obj: Record&lt;string, string&gt; = Object.fromEntries(</span><span class="s3">\n            </span><span class="s1">new URLSearchParams(str)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">for (const [key, value] of Object.entries(obj)) {</span><span class="s3">\n            </span><span class="s1">const normalizedKey = normalizeNextQueryParam(key)</span><span class="s3">\n            </span><span class="s1">if (!normalizedKey) continue</span><span class="s3">\n\n            </span><span class="s1">obj[normalizedKey] = value</span><span class="s3">\n            </span><span class="s1">delete obj[key]</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// Use all the named route keys.</span><span class="s3">\n          </span><span class="s1">const result = {} as RegExpExecArray</span><span class="s3">\n          </span><span class="s1">for (const keyName of Object.keys(routeKeys)) {</span><span class="s3">\n            </span><span class="s1">const paramName = routeKeys[keyName]</span><span class="s3">\n\n            </span><span class="s1">// If this param name is not a valid parameter name, then skip it.</span><span class="s3">\n            </span><span class="s1">if (!paramName) continue</span><span class="s3">\n\n            </span><span class="s1">const group = groups[paramName]</span><span class="s3">\n            </span><span class="s1">const value = obj[keyName]</span><span class="s3">\n\n            </span><span class="s1">// When we're missing a required param, we can't match the route.</span><span class="s3">\n            </span><span class="s1">if (!group.optional &amp;&amp; !value) return null</span><span class="s3">\n\n            </span><span class="s1">result[group.pos] = value</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">return result</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">groups,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">const routeMatches = matcher(routeMatchesHeader)</span><span class="s3">\n    </span><span class="s1">if (!routeMatches) return null</span><span class="s3">\n\n    </span><span class="s1">return routeMatches</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function normalizeQueryParams(</span><span class="s3">\n    </span><span class="s1">query: Record&lt;string, string | string[] | undefined&gt;,</span><span class="s3">\n    </span><span class="s1">routeParamKeys: Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// this is used to pass query information in rewrites</span><span class="s3">\n    </span><span class="s1">// but should not be exposed in final query</span><span class="s3">\n    </span><span class="s1">delete query['nextInternalLocale']</span><span class="s3">\n\n    </span><span class="s1">for (const [key, value] of Object.entries(query)) {</span><span class="s3">\n      </span><span class="s1">const normalizedKey = normalizeNextQueryParam(key)</span><span class="s3">\n      </span><span class="s1">if (!normalizedKey) continue</span><span class="s3">\n\n      </span><span class="s1">// Remove the prefixed key from the query params because we want</span><span class="s3">\n      </span><span class="s1">// to consume it for the dynamic route matcher.</span><span class="s3">\n      </span><span class="s1">delete query[key]</span><span class="s3">\n      </span><span class="s1">routeParamKeys.add(normalizedKey)</span><span class="s3">\n\n      </span><span class="s1">if (typeof value === 'undefined') continue</span><span class="s3">\n\n      </span><span class="s1">query[normalizedKey] = Array.isArray(value)</span><span class="s3">\n        </span><span class="s1">? value.map((v) =&gt; decodeQueryPathParameter(v))</span><span class="s3">\n        </span><span class="s1">: decodeQueryPathParameter(value)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">handleRewrites,</span><span class="s3">\n    </span><span class="s1">defaultRouteRegex,</span><span class="s3">\n    </span><span class="s1">dynamicRouteMatcher,</span><span class="s3">\n    </span><span class="s1">defaultRouteMatches,</span><span class="s3">\n    </span><span class="s1">normalizeQueryParams,</span><span class="s3">\n    </span><span class="s1">getParamsFromRouteMatches,</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Normalize dynamic route params.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param query - The query params to normalize.</span><span class="s3">\n     </span><span class="s1">* @param ignoreMissingOptional - Whether to ignore missing optional params.</span><span class="s3">\n     </span><span class="s1">* @returns The normalized params and whether they are valid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">normalizeDynamicRouteParams: (</span><span class="s3">\n      </span><span class="s1">query: ParsedUrlQuery,</span><span class="s3">\n      </span><span class="s1">ignoreMissingOptional: boolean</span><span class="s3">\n    </span><span class="s1">) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (!defaultRouteRegex || !defaultRouteMatches) {</span><span class="s3">\n        </span><span class="s1">return { params: {}, hasValidParams: false }</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return normalizeDynamicRouteParams(</span><span class="s3">\n        </span><span class="s1">query,</span><span class="s3">\n        </span><span class="s1">defaultRouteRegex,</span><span class="s3">\n        </span><span class="s1">defaultRouteMatches,</span><span class="s3">\n        </span><span class="s1">ignoreMissingOptional</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">normalizeCdnUrl: (</span><span class="s3">\n      </span><span class="s1">req: BaseNextRequest | IncomingMessage,</span><span class="s3">\n      </span><span class="s1">paramKeys: string[]</span><span class="s3">\n    </span><span class="s1">) =&gt; normalizeCdnUrl(req, paramKeys),</span><span class="s3">\n\n    </span><span class="s1">interpolateDynamicPath: (</span><span class="s3">\n      </span><span class="s1">pathname: string,</span><span class="s3">\n      </span><span class="s1">params: Record&lt;string, undefined | string | string[]&gt;</span><span class="s3">\n    </span><span class="s1">) =&gt; interpolateDynamicPath(pathname, params, defaultRouteRegex),</span><span class="s3">\n\n    </span><span class="s1">filterInternalQuery: (query: ParsedUrlQuery, paramKeys: string[]) =&gt;</span><span class="s3">\n      </span><span class="s1">filterInternalQuery(query, paramKeys),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getPreviouslyRevalidatedTags(</span><span class="s3">\n  </span><span class="s1">headers: IncomingHttpHeaders,</span><span class="s3">\n  </span><span class="s1">previewModeId: string | undefined</span><span class="s3">\n</span><span class="s1">): string[] {</span><span class="s3">\n  </span><span class="s1">return typeof headers[NEXT_CACHE_REVALIDATED_TAGS_HEADER] === 'string' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">headers[NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER] === previewModeId</span><span class="s3">\n    </span><span class="s1">? headers[NEXT_CACHE_REVALIDATED_TAGS_HEADER].split(',')</span><span class="s3">\n    </span><span class="s1">: []</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;getPreviouslyRevalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;getServerUtils&quot;</span><span class="s0">,</span><span class="s1">&quot;interpolateDynamicPath&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeCdnUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeDynamicRouteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;filterInternalQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;query&quot;</span><span class="s0">,</span><span class="s1">&quot;paramKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;isNextQueryPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_QUERY_PARAM_PREFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;isNextInterceptionMarkerPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_INTERCEPTION_MARKER_PREFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;req&quot;</span><span class="s0">,</span><span class="s1">&quot;_parsedUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parseReqUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;formatUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultRouteRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;param&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;groups&quot;</span><span class="s0">,</span><span class="s1">&quot;optional&quot;</span><span class="s0">,</span><span class="s1">&quot;repeat&quot;</span><span class="s0">,</span><span class="s1">&quot;builtParam&quot;</span><span class="s0">,</span><span class="s1">&quot;paramValue&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;v&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceAll&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultRouteMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreMissingOptional&quot;</span><span class="s0">,</span><span class="s1">&quot;hasValidParams&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeRscURL&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultValue&quot;</span><span class="s0">,</span><span class="s1">&quot;isOptional&quot;</span><span class="s0">,</span><span class="s1">&quot;isDefaultValue&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultVal&quot;</span><span class="s0">,</span><span class="s1">&quot;val&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;page&quot;</span><span class="s0">,</span><span class="s1">&quot;i18n&quot;</span><span class="s0">,</span><span class="s1">&quot;basePath&quot;</span><span class="s0">,</span><span class="s1">&quot;rewrites&quot;</span><span class="s0">,</span><span class="s1">&quot;pageIsDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;caseSensitive&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;getNamedRouteRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;prefixRouteKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;handleRewrites&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;fsPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;matchesPage&quot;</span><span class="s0">,</span><span class="s1">&quot;fsPathnameNoSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;removeTrailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;checkRewrite&quot;</span><span class="s0">,</span><span class="s1">&quot;rewrite&quot;</span><span class="s0">,</span><span class="s1">&quot;matcher&quot;</span><span class="s0">,</span><span class="s1">&quot;getPathMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;removeUnnamedParams&quot;</span><span class="s0">,</span><span class="s1">&quot;strict&quot;</span><span class="s0">,</span><span class="s1">&quot;sensitive&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;missing&quot;</span><span class="s0">,</span><span class="s1">&quot;hasParams&quot;</span><span class="s0">,</span><span class="s1">&quot;matchHas&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;isInterceptionRouteRewrite&quot;</span><span class="s0">,</span><span class="s1">&quot;stateHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_STATE_TREE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;getSelectedParams&quot;</span><span class="s0">,</span><span class="s1">&quot;parseAndValidateFlightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedDestination&quot;</span><span class="s0">,</span><span class="s1">&quot;destQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;prepareDestination&quot;</span><span class="s0">,</span><span class="s1">&quot;appendParamsToQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;destination&quot;</span><span class="s0">,</span><span class="s1">&quot;protocol&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;paramName&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;actualValue&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeLocalePath&quot;</span><span class="s0">,</span><span class="s1">&quot;locales&quot;</span><span class="s0">,</span><span class="s1">&quot;nextInternalLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;detectedLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicParams&quot;</span><span class="s0">,</span><span class="s1">&quot;beforeFiles&quot;</span><span class="s0">,</span><span class="s1">&quot;finished&quot;</span><span class="s0">,</span><span class="s1">&quot;afterFiles&quot;</span><span class="s0">,</span><span class="s1">&quot;fallback&quot;</span><span class="s0">,</span><span class="s1">&quot;getParamsFromRouteMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;routeMatchesHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;routeKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;re&quot;</span><span class="s0">,</span><span class="s1">&quot;exec&quot;</span><span class="s0">,</span><span class="s1">&quot;str&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;fromEntries&quot;</span><span class="s0">,</span><span class="s1">&quot;URLSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeNextQueryParam&quot;</span><span class="s0">,</span><span class="s1">&quot;keyName&quot;</span><span class="s0">,</span><span class="s1">&quot;group&quot;</span><span class="s0">,</span><span class="s1">&quot;pos&quot;</span><span class="s0">,</span><span class="s1">&quot;routeMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeQueryParams&quot;</span><span class="s0">,</span><span class="s1">&quot;routeParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeQueryPathParameter&quot;</span><span class="s0">,</span><span class="s1">&quot;previewModeId&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_CACHE_REVALIDATED_TAGS_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;IA8egBA,4BAA4B;eAA5BA;;IAnTAC,cAAc;eAAdA;;IA7GAC,sBAAsB;eAAtBA;;IAlBAC,eAAe;eAAfA;;IAoDAC,2BAA2B;eAA3BA;;;qCAzGoB;2BACP;4BACM;8BACH;oCAIzB;qCAC6B;0BACJ;2BAMzB;uBACiC;0CAEC;qBAEb;2BACF;mDACwB;oDACP;kCACG;oCACZ;AAElC,SAASC,oBACPC,KAAoD,EACpDC,SAAmB;IAEnB,qDAAqD;IACrD,2CAA2C;IAC3C,OAAOD,KAAK,CAAC,qBAAqB;IAElC,IAAK,MAAME,OAAOF,MAAO;QACvB,MAAMG,oBACJD,QAAQE,kCAAuB,IAAIF,IAAIG,UAAU,CAACD,kCAAuB;QAE3E,MAAME,iCACJJ,QAAQK,0CAA+B,IACvCL,IAAIG,UAAU,CAACE,0CAA+B;QAEhD,IACEJ,qBACAG,kCACAL,UAAUO,QAAQ,CAACN,MACnB;YACA,OAAOF,KAAK,CAACE,IAAI;QACnB;IACF;AACF;AAEO,SAASL,gBACdY,GAAsC,EACtCR,SAAmB;IAEnB,wEAAwE;IACxE,uDAAuD;IACvD,MAAMS,aAAaC,IAAAA,gBAAW,EAACF,IAAIG,GAAG;IAEtC,uCAAuC;IACvC,IAAI,CAACF,YAAY;QACf,OAAOD,IAAIG,GAAG;IAChB;IACA,OAAO,AAACF,WAAmBG,MAAM;IACjCd,oBAAoBW,WAAWV,KAAK,EAAEC;IAEtCQ,IAAIG,GAAG,GAAGE,IAAAA,oBAAS,EAACJ;AACtB;AAEO,SAASd,uBACdmB,QAAgB,EAChBC,MAAsB,EACtBC,iBAAqE;IAErE,IAAI,CAACA,mBAAmB,OAAOF;IAE/B,KAAK,MAAMG,SAASC,OAAOC,IAAI,CAACH,kBAAkBI,MAAM,EAAG;QACzD,MAAM,EAAEC,QAAQ,EAAEC,MAAM,EAAE,GAAGN,kBAAkBI,MAAM,CAACH,MAAM;QAC5D,IAAIM,aAAa,CAAC,CAAC,EAAED,SAAS,QAAQ,KAAKL,MAAM,CAAC,CAAC;QAEnD,IAAII,UAAU;YACZE,aAAa,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC;QAChC;QAEA,IAAIC;QACJ,MAAMC,QAAQV,MAAM,CAACE,MAAM;QAE3B,IAAIS,MAAMC,OAAO,CAACF,QAAQ;YACxBD,aAAaC,MAAMG,GAAG,CAAC,CAACC,IAAMA,KAAKC,mBAAmBD,IAAIE,IAAI,CAAC;QACjE,OAAO,IAAIN,OAAO;YAChBD,aAAaM,mBAAmBL;QAClC,OAAO;YACLD,aAAa;QACf;QAEA,IAAIA,cAAcH,UAAU;YAC1BP,WAAWA,SAASkB,UAAU,CAACT,YAAYC;QAC7C;IACF;IAEA,OAAOV;AACT;AAEO,SAASjB,4BACdE,KAAqB,EACrBiB,iBAAwD,EACxDiB,mBAAmC,EACnCC,qBAA8B;IAE9B,IAAIC,iBAAiB;IACrB,IAAIpB,SAAyB,CAAC;IAE9B,KAAK,MAAMd,OAAOiB,OAAOC,IAAI,CAACH,kBAAkBI,MAAM,EAAG;QACvD,IAAIK,QAAuC1B,KAAK,CAACE,IAAI;QAErD,IAAI,OAAOwB,UAAU,UAAU;YAC7BA,QAAQW,IAAAA,yBAAe,EAACX;QAC1B,OAAO,IAAIC,MAAMC,OAAO,CAACF,QAAQ;YAC/BA,QAAQA,MAAMG,GAAG,CAACQ,yBAAe;QACnC;QAEA,uDAAuD;QACvD,0DAA0D;QAC1D,sCAAsC;QACtC,MAAMC,eAAeJ,mBAAoB,CAAChC,IAAI;QAC9C,MAAMqC,aAAatB,kBAAmBI,MAAM,CAACnB,IAAI,CAACoB,QAAQ;QAE1D,MAAMkB,iBAAiBb,MAAMC,OAAO,CAACU,gBACjCA,aAAaG,IAAI,CAAC,CAACC;YACjB,OAAOf,MAAMC,OAAO,CAACF,SACjBA,MAAMe,IAAI,CAAC,CAACE,MAAQA,IAAInC,QAAQ,CAACkC,eACjChB,yBAAAA,MAAOlB,QAAQ,CAACkC;QACtB,KACAhB,yBAAAA,MAAOlB,QAAQ,CAAC8B;QAEpB,IACEE,kBACC,OAAOd,UAAU,eAAe,CAAEa,CAAAA,cAAcJ,qBAAoB,GACrE;YACA,OAAO;gBAAEnB,QAAQ,CAAC;gBAAGoB,gBAAgB;YAAM;QAC7C;QAEA,gEAAgE;QAChE,oBAAoB;QACpB,IACEG,cACC,CAAA,CAACb,SACCC,MAAMC,OAAO,CAACF,UACbA,MAAMkB,MAAM,KAAK,KACjB,6CAA6C;QAC7C,+CAA+C;QAC9ClB,CAAAA,KAAK,CAAC,EAAE,KAAK,WAAWA,KAAK,CAAC,EAAE,KAAK,CAAC,KAAK,EAAExB,IAAI,EAAE,CAAC,AAAD,CAAE,GAC1D;YACAwB,QAAQmB;YACR,OAAO7C,KAAK,CAACE,IAAI;QACnB;QAEA,+DAA+D;QAC/D,6CAA6C;QAC7C,IACEwB,SACA,OAAOA,UAAU,YACjBT,kBAAmBI,MAAM,CAACnB,IAAI,CAACqB,MAAM,EACrC;YACAG,QAAQA,MAAMoB,KAAK,CAAC;QACtB;QAEA,IAAIpB,OAAO;YACTV,MAAM,CAACd,IAAI,GAAGwB;QAChB;IACF;IAEA,OAAO;QACLV;QACAoB;IACF;AACF;AAEO,SAASzC,eAAe,EAC7BoD,IAAI,EACJC,IAAI,EACJC,QAAQ,EACRC,QAAQ,EACRC,aAAa,EACbC,aAAa,EACbC,aAAa,EAad;IACC,IAAIpC;IACJ,IAAIqC;IACJ,IAAIpB;IAEJ,IAAIiB,eAAe;QACjBlC,oBAAoBsC,IAAAA,8BAAkB,EAACR,MAAM;YAC3CS,iBAAiB;QACnB;QACAF,sBAAsBG,IAAAA,6BAAe,EAACxC;QACtCiB,sBAAsBoB,oBAAoBP;IAC5C;IAEA,SAASW,eACPjD,GAAsC,EACtCkD,SAA6B;QAE7B,MAAMC,gBAAwC,CAAC;QAC/C,IAAIC,aAAaF,UAAU5C,QAAQ;QAEnC,MAAM+C,cAAc;YAClB,MAAMC,oBAAoBC,IAAAA,wCAAmB,EAACH,cAAc;YAC5D,OACEE,sBAAsBC,IAAAA,wCAAmB,EAACjB,UAC1CO,uCAAAA,oBAAsBS;QAE1B;QAEA,MAAME,eAAe,CAACC;YACpB,MAAMC,UAAUC,IAAAA,uBAAY,EAC1BF,QAAQG,MAAM,GAAIjB,CAAAA,gBAAgB,SAAS,EAAC,GAC5C;gBACEkB,qBAAqB;gBACrBC,QAAQ;gBACRC,WAAW,CAAC,CAACnB;YACf;YAGF,IAAI,CAACM,UAAU5C,QAAQ,EAAE,OAAO;YAEhC,IAAIC,SAASmD,QAAQR,UAAU5C,QAAQ;YAEvC,IAAI,AAACmD,CAAAA,QAAQO,GAAG,IAAIP,QAAQQ,OAAO,AAAD,KAAM1D,QAAQ;gBAC9C,MAAM2D,YAAYC,IAAAA,4BAAQ,EACxBnE,KACAkD,UAAU3D,KAAK,EACfkE,QAAQO,GAAG,EACXP,QAAQQ,OAAO;gBAGjB,IAAIC,WAAW;oBACbxD,OAAO0D,MAAM,CAAC7D,QAAQ2D;gBACxB,OAAO;oBACL3D,SAAS;gBACX;YACF;YAEA,IAAIA,QAAQ;gBACV,IAAI;oBACF,+EAA+E;oBAC/E,gFAAgF;oBAChF,8EAA8E;oBAC9E,IAAI8D,IAAAA,8DAA0B,EAACZ,UAAqB;wBAClD,MAAMa,cAActE,IAAIuE,OAAO,CAACC,+CAA6B,CAAC;wBAE9D,IAAIF,aAAa;4BACf/D,SAAS;gCACP,GAAGkE,IAAAA,qCAAiB,EAClBC,IAAAA,oEAAiC,EAACJ,aACnC;gCACD,GAAG/D,MAAM;4BACX;wBACF;oBACF;gBACF,EAAE,OAAOoE,KAAK;gBACZ,wFAAwF;gBACxF,sDAAsD;gBACxD;gBAEA,MAAM,EAAEC,iBAAiB,EAAEC,SAAS,EAAE,GAAGC,IAAAA,sCAAkB,EAAC;oBAC1DC,qBAAqB;oBACrBC,aAAavB,QAAQuB,WAAW;oBAChCzE,QAAQA;oBACRhB,OAAO2D,UAAU3D,KAAK;gBACxB;gBAEA,6DAA6D;gBAC7D,IAAIqF,kBAAkBK,QAAQ,EAAE;oBAC9B,OAAO;gBACT;gBAEAvE,OAAO0D,MAAM,CAACjB,eAAe0B,WAAWtE;gBACxCG,OAAO0D,MAAM,CAAClB,UAAU3D,KAAK,EAAEqF,kBAAkBrF,KAAK;gBACtD,OAAO,AAACqF,kBAA0BrF,KAAK;gBAEvC,kGAAkG;gBAClG,4EAA4E;gBAC5E,uFAAuF;gBACvF,gGAAgG;gBAChGmB,OAAOwE,OAAO,CAAChC,UAAU3D,KAAK,EAAE4F,OAAO,CAAC,CAAC,CAAC1F,KAAKwB,MAAM;oBACnD,IAAIA,SAAS,OAAOA,UAAU,YAAYA,MAAMrB,UAAU,CAAC,MAAM;wBAC/D,MAAMwF,YAAYnE,MAAMoE,KAAK,CAAC;wBAC9B,MAAMC,cAAcnC,aAAa,CAACiC,UAAU;wBAC5C,IAAIE,aAAa;4BACfpC,UAAU3D,KAAK,CAACE,IAAI,GAAG6F;wBACzB;oBACF;gBACF;gBAEA5E,OAAO0D,MAAM,CAAClB,WAAW0B;gBAEzBxB,aAAaF,UAAU5C,QAAQ;gBAC/B,IAAI,CAAC8C,YAAY,OAAO;gBAExB,IAAIZ,UAAU;oBACZY,aAAaA,WAAWmC,OAAO,CAAC,IAAIC,OAAO,CAAC,CAAC,EAAEhD,UAAU,GAAG,OAAO;gBACrE;gBAEA,IAAID,MAAM;oBACR,MAAMkD,SAASC,IAAAA,wCAAmB,EAACtC,YAAYb,KAAKoD,OAAO;oBAC3DvC,aAAaqC,OAAOnF,QAAQ;oBAC5B4C,UAAU3D,KAAK,CAACqG,kBAAkB,GAChCH,OAAOI,cAAc,IAAItF,OAAOqF,kBAAkB;gBACtD;gBAEA,IAAIxC,eAAed,MAAM;oBACvB,OAAO;gBACT;gBAEA,IAAII,iBAAiBG,qBAAqB;oBACxC,MAAMiD,gBAAgBjD,oBAAoBO;oBAC1C,IAAI0C,eAAe;wBACjB5C,UAAU3D,KAAK,GAAG;4BAChB,GAAG2D,UAAU3D,KAAK;4BAClB,GAAGuG,aAAa;wBAClB;wBACA,OAAO;oBACT;gBACF;YACF;YACA,OAAO;QACT;QAEA,KAAK,MAAMrC,WAAWhB,SAASsD,WAAW,IAAI,EAAE,CAAE;YAChDvC,aAAaC;QACf;QAEA,IAAIL,eAAed,MAAM;YACvB,IAAI0D,WAAW;YAEf,KAAK,MAAMvC,WAAWhB,SAASwD,UAAU,IAAI,EAAE,CAAE;gBAC/CD,WAAWxC,aAAaC;gBACxB,IAAIuC,UAAU;YAChB;YAEA,IAAI,CAACA,YAAY,CAAC3C,eAAe;gBAC/B,KAAK,MAAMI,WAAWhB,SAASyD,QAAQ,IAAI,EAAE,CAAE;oBAC7CF,WAAWxC,aAAaC;oBACxB,IAAIuC,UAAU;gBAChB;YACF;QACF;QACA,OAAO7C;IACT;IAEA,SAASgD,0BAA0BC,kBAA0B;QAC3D,yEAAyE;QACzE,UAAU;QACV,IAAI,CAAC5F,mBAAmB,OAAO;QAE/B,MAAM,EAAEI,MAAM,EAAEyF,SAAS,EAAE,GAAG7F;QAE9B,MAAMkD,UAAUV,IAAAA,6BAAe,EAAC;YAC9BsD,IAAI;gBACF,qDAAqD;gBACrDC,MAAM,CAACC;oBACL,2CAA2C;oBAC3C,MAAMC,MAA8B/F,OAAOgG,WAAW,CACpD,IAAIC,gBAAgBH;oBAEtB,KAAK,MAAM,CAAC/G,KAAKwB,MAAM,IAAIP,OAAOwE,OAAO,CAACuB,KAAM;wBAC9C,MAAMG,gBAAgBC,IAAAA,8BAAuB,EAACpH;wBAC9C,IAAI,CAACmH,eAAe;wBAEpBH,GAAG,CAACG,cAAc,GAAG3F;wBACrB,OAAOwF,GAAG,CAAChH,IAAI;oBACjB;oBAEA,gCAAgC;oBAChC,MAAMgG,SAAS,CAAC;oBAChB,KAAK,MAAMqB,WAAWpG,OAAOC,IAAI,CAAC0F,WAAY;wBAC5C,MAAMjB,YAAYiB,SAAS,CAACS,QAAQ;wBAEpC,kEAAkE;wBAClE,IAAI,CAAC1B,WAAW;wBAEhB,MAAM2B,QAAQnG,MAAM,CAACwE,UAAU;wBAC/B,MAAMnE,QAAQwF,GAAG,CAACK,QAAQ;wBAE1B,iEAAiE;wBACjE,IAAI,CAACC,MAAMlG,QAAQ,IAAI,CAACI,OAAO,OAAO;wBAEtCwE,MAAM,CAACsB,MAAMC,GAAG,CAAC,GAAG/F;oBACtB;oBAEA,OAAOwE;gBACT;YACF;YACA7E;QACF;QAEA,MAAMqG,eAAevD,QAAQ0C;QAC7B,IAAI,CAACa,cAAc,OAAO;QAE1B,OAAOA;IACT;IAEA,SAASC,qBACP3H,KAAoD,EACpD4H,cAA2B;QAE3B,qDAAqD;QACrD,2CAA2C;QAC3C,OAAO5H,KAAK,CAAC,qBAAqB;QAElC,KAAK,MAAM,CAACE,KAAKwB,MAAM,IAAIP,OAAOwE,OAAO,CAAC3F,OAAQ;YAChD,MAAMqH,gBAAgBC,IAAAA,8BAAuB,EAACpH;YAC9C,IAAI,CAACmH,eAAe;YAEpB,gEAAgE;YAChE,+CAA+C;YAC/C,OAAOrH,KAAK,CAACE,IAAI;YACjB0H,eAAeC,GAAG,CAACR;YAEnB,IAAI,OAAO3F,UAAU,aAAa;YAElC1B,KAAK,CAACqH,cAAc,GAAG1F,MAAMC,OAAO,CAACF,SACjCA,MAAMG,GAAG,CAAC,CAACC,IAAMgG,IAAAA,kDAAwB,EAAChG,MAC1CgG,IAAAA,kDAAwB,EAACpG;QAC/B;IACF;IAEA,OAAO;QACLgC;QACAzC;QACAqC;QACApB;QACAyF;QACAf;QACA;;;;;;KAMC,GACD9G,6BAA6B,CAC3BE,OACAmC;YAEA,IAAI,CAAClB,qBAAqB,CAACiB,qBAAqB;gBAC9C,OAAO;oBAAElB,QAAQ,CAAC;oBAAGoB,gBAAgB;gBAAM;YAC7C;YAEA,OAAOtC,4BACLE,OACAiB,mBACAiB,qBACAC;QAEJ;QAEAtC,iBAAiB,CACfY,KACAR,YACGJ,gBAAgBY,KAAKR;QAE1BL,wBAAwB,CACtBmB,UACAC,SACGpB,uBAAuBmB,UAAUC,QAAQC;QAE9ClB,qBAAqB,CAACC,OAAuBC,YAC3CF,oBAAoBC,OAAOC;IAC/B;AACF;AAEO,SAASP,6BACdsF,OAA4B,EAC5B+C,aAAiC;IAEjC,OAAO,OAAO/C,OAAO,CAACgD,6CAAkC,CAAC,KAAK,YAC5DhD,OAAO,CAACiD,iDAAsC,CAAC,KAAKF,gBAClD/C,OAAO,CAACgD,6CAAkC,CAAC,CAAClF,KAAK,CAAC,OAClD,EAAE;AACR&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>