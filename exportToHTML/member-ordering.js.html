<html>
<head>
<title>member-ordering.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #8c8c8c; font-style: italic;}
.s3 { color: #0033b3;}
.s4 { color: #1750eb;}
.s5 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
member-ordering.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">// This rule was feature-frozen before we enabled no-property-in-node.</span>
<span class="s2">/* eslint-disable eslint-plugin/no-property-in-node */</span>
<span class="s3">var </span><span class="s1">__importDefault = (</span><span class="s3">this </span><span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.__importDefault) || </span><span class="s3">function </span><span class="s1">(mod) {</span>
    <span class="s3">return </span><span class="s1">(mod &amp;&amp; mod.__esModule) ? mod : { </span><span class="s0">&quot;default&quot;</span><span class="s1">: mod };</span>
<span class="s1">};</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s3">true </span><span class="s1">});</span>
<span class="s1">exports.defaultOrder = </span><span class="s3">void </span><span class="s4">0</span><span class="s1">;</span>
<span class="s3">const </span><span class="s1">utils_1 = require(</span><span class="s0">&quot;@typescript-eslint/utils&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">natural_compare_1 = __importDefault(require(</span><span class="s0">&quot;natural-compare&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">util_1 = require(</span><span class="s0">&quot;../util&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">neverConfig = {</span>
    <span class="s1">type: </span><span class="s0">'string'</span><span class="s1">,</span>
    <span class="s3">enum</span><span class="s1">: [</span><span class="s0">'never'</span><span class="s1">],</span>
<span class="s1">};</span>
<span class="s3">const </span><span class="s1">arrayConfig = (memberTypes) =&gt; ({</span>
    <span class="s1">type: </span><span class="s0">'array'</span><span class="s1">,</span>
    <span class="s1">items: {</span>
        <span class="s1">oneOf: [</span>
            <span class="s1">{</span>
                <span class="s1">$ref: memberTypes,</span>
            <span class="s1">},</span>
            <span class="s1">{</span>
                <span class="s1">type: </span><span class="s0">'array'</span><span class="s1">,</span>
                <span class="s1">items: {</span>
                    <span class="s1">$ref: memberTypes,</span>
                <span class="s1">},</span>
            <span class="s1">},</span>
        <span class="s1">],</span>
    <span class="s1">},</span>
<span class="s1">});</span>
<span class="s3">const </span><span class="s1">objectConfig = (memberTypes) =&gt; ({</span>
    <span class="s1">type: </span><span class="s0">'object'</span><span class="s1">,</span>
    <span class="s1">additionalProperties: </span><span class="s3">false</span><span class="s1">,</span>
    <span class="s1">properties: {</span>
        <span class="s1">memberTypes: {</span>
            <span class="s1">oneOf: [arrayConfig(memberTypes), neverConfig],</span>
        <span class="s1">},</span>
        <span class="s1">optionalityOrder: {</span>
            <span class="s1">$ref: </span><span class="s0">'#/items/0/$defs/optionalityOrderOptions'</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">order: {</span>
            <span class="s1">$ref: </span><span class="s0">'#/items/0/$defs/orderOptions'</span><span class="s1">,</span>
        <span class="s1">},</span>
    <span class="s1">},</span>
<span class="s1">});</span>
<span class="s1">exports.defaultOrder = [</span>
    <span class="s2">// Index signature</span>
    <span class="s0">'signature'</span><span class="s1">,</span>
    <span class="s0">'call-signature'</span><span class="s1">,</span>
    <span class="s2">// Fields</span>
    <span class="s0">'public-static-field'</span><span class="s1">,</span>
    <span class="s0">'protected-static-field'</span><span class="s1">,</span>
    <span class="s0">'private-static-field'</span><span class="s1">,</span>
    <span class="s0">'#private-static-field'</span><span class="s1">,</span>
    <span class="s0">'public-decorated-field'</span><span class="s1">,</span>
    <span class="s0">'protected-decorated-field'</span><span class="s1">,</span>
    <span class="s0">'private-decorated-field'</span><span class="s1">,</span>
    <span class="s0">'public-instance-field'</span><span class="s1">,</span>
    <span class="s0">'protected-instance-field'</span><span class="s1">,</span>
    <span class="s0">'private-instance-field'</span><span class="s1">,</span>
    <span class="s0">'#private-instance-field'</span><span class="s1">,</span>
    <span class="s0">'public-abstract-field'</span><span class="s1">,</span>
    <span class="s0">'protected-abstract-field'</span><span class="s1">,</span>
    <span class="s0">'public-field'</span><span class="s1">,</span>
    <span class="s0">'protected-field'</span><span class="s1">,</span>
    <span class="s0">'private-field'</span><span class="s1">,</span>
    <span class="s0">'#private-field'</span><span class="s1">,</span>
    <span class="s0">'static-field'</span><span class="s1">,</span>
    <span class="s0">'instance-field'</span><span class="s1">,</span>
    <span class="s0">'abstract-field'</span><span class="s1">,</span>
    <span class="s0">'decorated-field'</span><span class="s1">,</span>
    <span class="s0">'field'</span><span class="s1">,</span>
    <span class="s2">// Static initialization</span>
    <span class="s0">'static-initialization'</span><span class="s1">,</span>
    <span class="s2">// Constructors</span>
    <span class="s0">'public-constructor'</span><span class="s1">,</span>
    <span class="s0">'protected-constructor'</span><span class="s1">,</span>
    <span class="s0">'private-constructor'</span><span class="s1">,</span>
    <span class="s0">'constructor'</span><span class="s1">,</span>
    <span class="s2">// Accessors</span>
    <span class="s0">'public-static-accessor'</span><span class="s1">,</span>
    <span class="s0">'protected-static-accessor'</span><span class="s1">,</span>
    <span class="s0">'private-static-accessor'</span><span class="s1">,</span>
    <span class="s0">'#private-static-accessor'</span><span class="s1">,</span>
    <span class="s0">'public-decorated-accessor'</span><span class="s1">,</span>
    <span class="s0">'protected-decorated-accessor'</span><span class="s1">,</span>
    <span class="s0">'private-decorated-accessor'</span><span class="s1">,</span>
    <span class="s0">'public-instance-accessor'</span><span class="s1">,</span>
    <span class="s0">'protected-instance-accessor'</span><span class="s1">,</span>
    <span class="s0">'private-instance-accessor'</span><span class="s1">,</span>
    <span class="s0">'#private-instance-accessor'</span><span class="s1">,</span>
    <span class="s0">'public-abstract-accessor'</span><span class="s1">,</span>
    <span class="s0">'protected-abstract-accessor'</span><span class="s1">,</span>
    <span class="s0">'public-accessor'</span><span class="s1">,</span>
    <span class="s0">'protected-accessor'</span><span class="s1">,</span>
    <span class="s0">'private-accessor'</span><span class="s1">,</span>
    <span class="s0">'#private-accessor'</span><span class="s1">,</span>
    <span class="s0">'static-accessor'</span><span class="s1">,</span>
    <span class="s0">'instance-accessor'</span><span class="s1">,</span>
    <span class="s0">'abstract-accessor'</span><span class="s1">,</span>
    <span class="s0">'decorated-accessor'</span><span class="s1">,</span>
    <span class="s0">'accessor'</span><span class="s1">,</span>
    <span class="s2">// Getters</span>
    <span class="s0">'public-static-get'</span><span class="s1">,</span>
    <span class="s0">'protected-static-get'</span><span class="s1">,</span>
    <span class="s0">'private-static-get'</span><span class="s1">,</span>
    <span class="s0">'#private-static-get'</span><span class="s1">,</span>
    <span class="s0">'public-decorated-get'</span><span class="s1">,</span>
    <span class="s0">'protected-decorated-get'</span><span class="s1">,</span>
    <span class="s0">'private-decorated-get'</span><span class="s1">,</span>
    <span class="s0">'public-instance-get'</span><span class="s1">,</span>
    <span class="s0">'protected-instance-get'</span><span class="s1">,</span>
    <span class="s0">'private-instance-get'</span><span class="s1">,</span>
    <span class="s0">'#private-instance-get'</span><span class="s1">,</span>
    <span class="s0">'public-abstract-get'</span><span class="s1">,</span>
    <span class="s0">'protected-abstract-get'</span><span class="s1">,</span>
    <span class="s0">'public-get'</span><span class="s1">,</span>
    <span class="s0">'protected-get'</span><span class="s1">,</span>
    <span class="s0">'private-get'</span><span class="s1">,</span>
    <span class="s0">'#private-get'</span><span class="s1">,</span>
    <span class="s0">'static-get'</span><span class="s1">,</span>
    <span class="s0">'instance-get'</span><span class="s1">,</span>
    <span class="s0">'abstract-get'</span><span class="s1">,</span>
    <span class="s0">'decorated-get'</span><span class="s1">,</span>
    <span class="s0">'get'</span><span class="s1">,</span>
    <span class="s2">// Setters</span>
    <span class="s0">'public-static-set'</span><span class="s1">,</span>
    <span class="s0">'protected-static-set'</span><span class="s1">,</span>
    <span class="s0">'private-static-set'</span><span class="s1">,</span>
    <span class="s0">'#private-static-set'</span><span class="s1">,</span>
    <span class="s0">'public-decorated-set'</span><span class="s1">,</span>
    <span class="s0">'protected-decorated-set'</span><span class="s1">,</span>
    <span class="s0">'private-decorated-set'</span><span class="s1">,</span>
    <span class="s0">'public-instance-set'</span><span class="s1">,</span>
    <span class="s0">'protected-instance-set'</span><span class="s1">,</span>
    <span class="s0">'private-instance-set'</span><span class="s1">,</span>
    <span class="s0">'#private-instance-set'</span><span class="s1">,</span>
    <span class="s0">'public-abstract-set'</span><span class="s1">,</span>
    <span class="s0">'protected-abstract-set'</span><span class="s1">,</span>
    <span class="s0">'public-set'</span><span class="s1">,</span>
    <span class="s0">'protected-set'</span><span class="s1">,</span>
    <span class="s0">'private-set'</span><span class="s1">,</span>
    <span class="s0">'#private-set'</span><span class="s1">,</span>
    <span class="s0">'static-set'</span><span class="s1">,</span>
    <span class="s0">'instance-set'</span><span class="s1">,</span>
    <span class="s0">'abstract-set'</span><span class="s1">,</span>
    <span class="s0">'decorated-set'</span><span class="s1">,</span>
    <span class="s0">'set'</span><span class="s1">,</span>
    <span class="s2">// Methods</span>
    <span class="s0">'public-static-method'</span><span class="s1">,</span>
    <span class="s0">'protected-static-method'</span><span class="s1">,</span>
    <span class="s0">'private-static-method'</span><span class="s1">,</span>
    <span class="s0">'#private-static-method'</span><span class="s1">,</span>
    <span class="s0">'public-decorated-method'</span><span class="s1">,</span>
    <span class="s0">'protected-decorated-method'</span><span class="s1">,</span>
    <span class="s0">'private-decorated-method'</span><span class="s1">,</span>
    <span class="s0">'public-instance-method'</span><span class="s1">,</span>
    <span class="s0">'protected-instance-method'</span><span class="s1">,</span>
    <span class="s0">'private-instance-method'</span><span class="s1">,</span>
    <span class="s0">'#private-instance-method'</span><span class="s1">,</span>
    <span class="s0">'public-abstract-method'</span><span class="s1">,</span>
    <span class="s0">'protected-abstract-method'</span><span class="s1">,</span>
    <span class="s0">'public-method'</span><span class="s1">,</span>
    <span class="s0">'protected-method'</span><span class="s1">,</span>
    <span class="s0">'private-method'</span><span class="s1">,</span>
    <span class="s0">'#private-method'</span><span class="s1">,</span>
    <span class="s0">'static-method'</span><span class="s1">,</span>
    <span class="s0">'instance-method'</span><span class="s1">,</span>
    <span class="s0">'abstract-method'</span><span class="s1">,</span>
    <span class="s0">'decorated-method'</span><span class="s1">,</span>
    <span class="s0">'method'</span><span class="s1">,</span>
<span class="s1">];</span>
<span class="s3">const </span><span class="s1">allMemberTypes = [</span>
    <span class="s1">...</span><span class="s3">new </span><span class="s1">Set([</span>
        <span class="s0">'readonly-signature'</span><span class="s1">,</span>
        <span class="s0">'signature'</span><span class="s1">,</span>
        <span class="s0">'readonly-field'</span><span class="s1">,</span>
        <span class="s0">'field'</span><span class="s1">,</span>
        <span class="s0">'method'</span><span class="s1">,</span>
        <span class="s0">'call-signature'</span><span class="s1">,</span>
        <span class="s0">'constructor'</span><span class="s1">,</span>
        <span class="s0">'accessor'</span><span class="s1">,</span>
        <span class="s0">'get'</span><span class="s1">,</span>
        <span class="s0">'set'</span><span class="s1">,</span>
        <span class="s0">'static-initialization'</span><span class="s1">,</span>
    <span class="s1">].flatMap(type =&gt; [</span>
        <span class="s1">type,</span>
        <span class="s1">...[</span><span class="s0">'public'</span><span class="s1">, </span><span class="s0">'protected'</span><span class="s1">, </span><span class="s0">'private'</span><span class="s1">, </span><span class="s0">'#private'</span><span class="s1">]</span>
            <span class="s1">.flatMap(accessibility =&gt; [</span>
            <span class="s1">type !== </span><span class="s0">'readonly-signature' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">type !== </span><span class="s0">'signature' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">type !== </span><span class="s0">'static-initialization' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">type !== </span><span class="s0">'call-signature' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">!(type === </span><span class="s0">'constructor' </span><span class="s1">&amp;&amp; accessibility === </span><span class="s0">'#private'</span><span class="s1">)</span>
                <span class="s1">? </span><span class="s0">`</span><span class="s1">${accessibility}</span><span class="s0">-</span><span class="s1">${type}</span><span class="s0">` </span><span class="s2">// e.g. `public-field`</span>
                <span class="s1">: [],</span>
            <span class="s2">// Only class instance fields, methods, accessors, get and set can have decorators attached to them</span>
            <span class="s1">accessibility !== </span><span class="s0">'#private' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">(type === </span><span class="s0">'readonly-field' </span><span class="s1">||</span>
                    <span class="s1">type === </span><span class="s0">'field' </span><span class="s1">||</span>
                    <span class="s1">type === </span><span class="s0">'method' </span><span class="s1">||</span>
                    <span class="s1">type === </span><span class="s0">'accessor' </span><span class="s1">||</span>
                    <span class="s1">type === </span><span class="s0">'get' </span><span class="s1">||</span>
                    <span class="s1">type === </span><span class="s0">'set'</span><span class="s1">)</span>
                <span class="s1">? [</span><span class="s0">`</span><span class="s1">${accessibility}</span><span class="s0">-decorated-</span><span class="s1">${type}</span><span class="s0">`</span><span class="s1">, </span><span class="s0">`decorated-</span><span class="s1">${type}</span><span class="s0">`</span><span class="s1">]</span>
                <span class="s1">: [],</span>
            <span class="s1">type !== </span><span class="s0">'constructor' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">type !== </span><span class="s0">'readonly-signature' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">type !== </span><span class="s0">'signature' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">type !== </span><span class="s0">'call-signature'</span>
                <span class="s1">? [</span>
                    <span class="s0">'static'</span><span class="s1">,</span>
                    <span class="s0">'instance'</span><span class="s1">,</span>
                    <span class="s2">// There is no `static-constructor` or `instance-constructor` or `abstract-constructor`</span>
                    <span class="s1">...(accessibility === </span><span class="s0">'#private' </span><span class="s1">||</span>
                        <span class="s1">accessibility === </span><span class="s0">'private'</span>
                        <span class="s1">? []</span>
                        <span class="s1">: [</span><span class="s0">'abstract'</span><span class="s1">]),</span>
                <span class="s1">].flatMap(scope =&gt; [</span>
                    <span class="s0">`</span><span class="s1">${scope}</span><span class="s0">-</span><span class="s1">${type}</span><span class="s0">`</span><span class="s1">,</span>
                    <span class="s0">`</span><span class="s1">${accessibility}</span><span class="s0">-</span><span class="s1">${scope}</span><span class="s0">-</span><span class="s1">${type}</span><span class="s0">`</span><span class="s1">,</span>
                <span class="s1">])</span>
                <span class="s1">: [],</span>
        <span class="s1">])</span>
            <span class="s1">.flat(),</span>
    <span class="s1">])),</span>
<span class="s1">];</span>
<span class="s3">const </span><span class="s1">functionExpressions = [</span>
    <span class="s1">utils_1.AST_NODE_TYPES.FunctionExpression,</span>
    <span class="s1">utils_1.AST_NODE_TYPES.ArrowFunctionExpression,</span>
<span class="s1">];</span>
<span class="s2">/**</span>
 <span class="s2">* Gets the node type.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">node the node to be evaluated.</span>
 <span class="s2">*/</span>
<span class="s3">function </span><span class="s1">getNodeType(node) {</span>
    <span class="s3">switch </span><span class="s1">(node.type) {</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.MethodDefinition:</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSMethodSignature:</span>
            <span class="s3">return </span><span class="s1">node.kind;</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration:</span>
            <span class="s3">return </span><span class="s0">'call-signature'</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration:</span>
            <span class="s3">return </span><span class="s0">'constructor'</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition:</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSPropertySignature:</span>
            <span class="s3">return </span><span class="s1">node.readonly ? </span><span class="s0">'readonly-field' </span><span class="s1">: </span><span class="s0">'field'</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSAbstractAccessorProperty:</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.AccessorProperty:</span>
            <span class="s3">return </span><span class="s0">'accessor'</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.PropertyDefinition:</span>
            <span class="s3">return </span><span class="s1">node.value &amp;&amp; functionExpressions.includes(node.value.type)</span>
                <span class="s1">? </span><span class="s0">'method'</span>
                <span class="s1">: node.readonly</span>
                    <span class="s1">? </span><span class="s0">'readonly-field'</span>
                    <span class="s1">: </span><span class="s0">'field'</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSIndexSignature:</span>
            <span class="s3">return </span><span class="s1">node.readonly ? </span><span class="s0">'readonly-signature' </span><span class="s1">: </span><span class="s0">'signature'</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.StaticBlock:</span>
            <span class="s3">return </span><span class="s0">'static-initialization'</span><span class="s1">;</span>
        <span class="s3">default</span><span class="s1">:</span>
            <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">/**</span>
 <span class="s2">* Gets the raw string value of a member's name</span>
 <span class="s2">*/</span>
<span class="s3">function </span><span class="s1">getMemberRawName(member, sourceCode) {</span>
    <span class="s3">const </span><span class="s1">{ name, type } = (</span><span class="s4">0</span><span class="s1">, util_1.getNameFromMember)(member, sourceCode);</span>
    <span class="s3">if </span><span class="s1">(type === util_1.MemberNameType.Quoted) {</span>
        <span class="s3">return </span><span class="s1">name.slice(</span><span class="s4">1</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(type === util_1.MemberNameType.Private) {</span>
        <span class="s3">return </span><span class="s1">name.slice(</span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">name;</span>
<span class="s1">}</span>
<span class="s2">/**</span>
 <span class="s2">* Gets the member name based on the member type.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">node the node to be evaluated.</span>
 <span class="s2">*/</span>
<span class="s3">function </span><span class="s1">getMemberName(node, sourceCode) {</span>
    <span class="s3">switch </span><span class="s1">(node.type) {</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSPropertySignature:</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSMethodSignature:</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSAbstractAccessorProperty:</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition:</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.AccessorProperty:</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.PropertyDefinition:</span>
            <span class="s3">return </span><span class="s1">getMemberRawName(node, sourceCode);</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.MethodDefinition:</span>
            <span class="s3">return </span><span class="s1">node.kind === </span><span class="s0">'constructor'</span>
                <span class="s1">? </span><span class="s0">'constructor'</span>
                <span class="s1">: getMemberRawName(node, sourceCode);</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration:</span>
            <span class="s3">return </span><span class="s0">'new'</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration:</span>
            <span class="s3">return </span><span class="s0">'call'</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSIndexSignature:</span>
            <span class="s3">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, util_1.getNameFromIndexSignature)(node);</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.StaticBlock:</span>
            <span class="s3">return </span><span class="s0">'static block'</span><span class="s1">;</span>
        <span class="s3">default</span><span class="s1">:</span>
            <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">/**</span>
 <span class="s2">* Returns true if the member is optional based on the member type.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">node the node to be evaluated.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">Whether the member is optional, or false if it cannot be optional at all.</span>
 <span class="s2">*/</span>
<span class="s3">function </span><span class="s1">isMemberOptional(node) {</span>
    <span class="s3">switch </span><span class="s1">(node.type) {</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSPropertySignature:</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSMethodSignature:</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSAbstractAccessorProperty:</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition:</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.AccessorProperty:</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.PropertyDefinition:</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:</span>
        <span class="s3">case </span><span class="s1">utils_1.AST_NODE_TYPES.MethodDefinition:</span>
            <span class="s3">return </span><span class="s1">node.optional;</span>
    <span class="s1">}</span>
    <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">/**</span>
 <span class="s2">* Gets the calculated rank using the provided method definition.</span>
 <span class="s2">* The algorithm is as follows:</span>
 <span class="s2">* - Get the rank based on the accessibility-scope-type name, e.g. public-instance-field</span>
 <span class="s2">* - If there is no order for accessibility-scope-type, then strip out the accessibility.</span>
 <span class="s2">* - If there is no order for scope-type, then strip out the scope.</span>
 <span class="s2">* - If there is no order for type, then return -1</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">memberGroups the valid names to be validated.</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">orderConfig the current order to be validated.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@return </span><span class="s2">Index of the matching member type in the order configuration.</span>
 <span class="s2">*/</span>
<span class="s3">function </span><span class="s1">getRankOrder(memberGroups, orderConfig) {</span>
    <span class="s3">let </span><span class="s1">rank = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s1">stack = [...memberGroups]; </span><span class="s2">// Get a copy of the member groups</span>
    <span class="s3">while </span><span class="s1">(stack.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; rank === -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s2">// eslint-disable-next-line @typescript-eslint/no-non-null-assertion</span>
        <span class="s3">const </span><span class="s1">memberGroup = stack.shift();</span>
        <span class="s1">rank = orderConfig.findIndex(memberType =&gt; Array.isArray(memberType)</span>
            <span class="s1">? memberType.includes(memberGroup)</span>
            <span class="s1">: memberType === memberGroup);</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">rank;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getAccessibility(node) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s0">'accessibility' </span><span class="s3">in </span><span class="s1">node &amp;&amp; node.accessibility) {</span>
        <span class="s3">return </span><span class="s1">node.accessibility;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s0">'key' </span><span class="s3">in </span><span class="s1">node &amp;&amp; node.key.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {</span>
        <span class="s3">return </span><span class="s0">'#private'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s0">'public'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">/**</span>
 <span class="s2">* Gets the rank of the node given the order.</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">node the node to be evaluated.</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">orderConfig the current order to be validated.</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">supportsModifiers a flag indicating whether the type supports modifiers (scope or accessibility) or not.</span>
 <span class="s2">*/</span>
<span class="s3">function </span><span class="s1">getRank(node, orderConfig, supportsModifiers) {</span>
    <span class="s3">const </span><span class="s1">type = getNodeType(node);</span>
    <span class="s3">if </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.MethodDefinition &amp;&amp;</span>
        <span class="s1">node.value.type === utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression) {</span>
        <span class="s3">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(type == </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s2">// shouldn't happen but just in case, put it on the end</span>
        <span class="s3">return </span><span class="s1">orderConfig.length - </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">const </span><span class="s1">abstract = node.type === utils_1.AST_NODE_TYPES.TSAbstractAccessorProperty ||</span>
        <span class="s1">node.type === utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition ||</span>
        <span class="s1">node.type === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition;</span>
    <span class="s3">const </span><span class="s1">scope = </span><span class="s0">'static' </span><span class="s3">in </span><span class="s1">node &amp;&amp; node.static</span>
        <span class="s1">? </span><span class="s0">'static'</span>
        <span class="s1">: abstract</span>
            <span class="s1">? </span><span class="s0">'abstract'</span>
            <span class="s1">: </span><span class="s0">'instance'</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s1">accessibility = getAccessibility(node);</span>
    <span class="s2">// Collect all existing member groups that apply to this node...</span>
    <span class="s2">// (e.g. 'public-instance-field', 'instance-field', 'public-field', 'constructor' etc.)</span>
    <span class="s3">const </span><span class="s1">memberGroups = [];</span>
    <span class="s3">if </span><span class="s1">(supportsModifiers) {</span>
        <span class="s3">const </span><span class="s1">decorated = </span><span class="s0">'decorators' </span><span class="s3">in </span><span class="s1">node &amp;&amp; node.decorators.length &gt; </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(decorated &amp;&amp;</span>
            <span class="s1">(type === </span><span class="s0">'readonly-field' </span><span class="s1">||</span>
                <span class="s1">type === </span><span class="s0">'field' </span><span class="s1">||</span>
                <span class="s1">type === </span><span class="s0">'method' </span><span class="s1">||</span>
                <span class="s1">type === </span><span class="s0">'accessor' </span><span class="s1">||</span>
                <span class="s1">type === </span><span class="s0">'get' </span><span class="s1">||</span>
                <span class="s1">type === </span><span class="s0">'set'</span><span class="s1">)) {</span>
            <span class="s1">memberGroups.push(</span><span class="s0">`</span><span class="s1">${accessibility}</span><span class="s0">-decorated-</span><span class="s1">${type}</span><span class="s0">`</span><span class="s1">);</span>
            <span class="s1">memberGroups.push(</span><span class="s0">`decorated-</span><span class="s1">${type}</span><span class="s0">`</span><span class="s1">);</span>
            <span class="s3">if </span><span class="s1">(type === </span><span class="s0">'readonly-field'</span><span class="s1">) {</span>
                <span class="s1">memberGroups.push(</span><span class="s0">`</span><span class="s1">${accessibility}</span><span class="s0">-decorated-field`</span><span class="s1">);</span>
                <span class="s1">memberGroups.push(</span><span class="s0">`decorated-field`</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(type !== </span><span class="s0">'readonly-signature' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">type !== </span><span class="s0">'signature' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">type !== </span><span class="s0">'static-initialization'</span><span class="s1">) {</span>
            <span class="s3">if </span><span class="s1">(type !== </span><span class="s0">'constructor'</span><span class="s1">) {</span>
                <span class="s2">// Constructors have no scope</span>
                <span class="s1">memberGroups.push(</span><span class="s0">`</span><span class="s1">${accessibility}</span><span class="s0">-</span><span class="s1">${scope}</span><span class="s0">-</span><span class="s1">${type}</span><span class="s0">`</span><span class="s1">);</span>
                <span class="s1">memberGroups.push(</span><span class="s0">`</span><span class="s1">${scope}</span><span class="s0">-</span><span class="s1">${type}</span><span class="s0">`</span><span class="s1">);</span>
                <span class="s3">if </span><span class="s1">(type === </span><span class="s0">'readonly-field'</span><span class="s1">) {</span>
                    <span class="s1">memberGroups.push(</span><span class="s0">`</span><span class="s1">${accessibility}</span><span class="s0">-</span><span class="s1">${scope}</span><span class="s0">-field`</span><span class="s1">);</span>
                    <span class="s1">memberGroups.push(</span><span class="s0">`</span><span class="s1">${scope}</span><span class="s0">-field`</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">memberGroups.push(</span><span class="s0">`</span><span class="s1">${accessibility}</span><span class="s0">-</span><span class="s1">${type}</span><span class="s0">`</span><span class="s1">);</span>
            <span class="s3">if </span><span class="s1">(type === </span><span class="s0">'readonly-field'</span><span class="s1">) {</span>
                <span class="s1">memberGroups.push(</span><span class="s0">`</span><span class="s1">${accessibility}</span><span class="s0">-field`</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">memberGroups.push(type);</span>
    <span class="s3">if </span><span class="s1">(type === </span><span class="s0">'readonly-signature'</span><span class="s1">) {</span>
        <span class="s1">memberGroups.push(</span><span class="s0">'signature'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">else if </span><span class="s1">(type === </span><span class="s0">'readonly-field'</span><span class="s1">) {</span>
        <span class="s1">memberGroups.push(</span><span class="s0">'field'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">// ...then get the rank order for those member groups based on the node</span>
    <span class="s3">return </span><span class="s1">getRankOrder(memberGroups, orderConfig);</span>
<span class="s1">}</span>
<span class="s2">/**</span>
 <span class="s2">* Groups members into arrays of consecutive members with the same rank.</span>
 <span class="s2">* If, for example, the memberSet parameter looks like the following...</span>
 <span class="s2">* </span><span class="s5">@example</span>
 <span class="s2">* ```</span>
 <span class="s2">* interface Foo {</span>
 <span class="s2">*   [a: string]: number;</span>
 <span class="s2">*</span>
 <span class="s2">*   a: x;</span>
 <span class="s2">*   B: x;</span>
 <span class="s2">*   c: x;</span>
 <span class="s2">*</span>
 <span class="s2">*   c(): void;</span>
 <span class="s2">*   B(): void;</span>
 <span class="s2">*   a(): void;</span>
 <span class="s2">*</span>
 <span class="s2">*   (): Baz;</span>
 <span class="s2">*</span>
 <span class="s2">*   new (): Bar;</span>
 <span class="s2">* }</span>
 <span class="s2">* ```</span>
 <span class="s2">* ...the resulting array will look like: [[a, B, c], [c, B, a]].</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">memberSet The members to be grouped.</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">memberType The configured order of member types.</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">supportsModifiers It'll get passed to getRank().</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The array of groups of members.</span>
 <span class="s2">*/</span>
<span class="s3">function </span><span class="s1">groupMembersByType(members, memberTypes, supportsModifiers) {</span>
    <span class="s3">const </span><span class="s1">groupedMembers = [];</span>
    <span class="s3">const </span><span class="s1">memberRanks = members.map(member =&gt; getRank(member, memberTypes, supportsModifiers));</span>
    <span class="s3">let </span><span class="s1">previousRank = undefined;</span>
    <span class="s1">members.forEach((member, index) =&gt; {</span>
        <span class="s3">if </span><span class="s1">(index === members.length - </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">const </span><span class="s1">rankOfCurrentMember = memberRanks[index];</span>
        <span class="s3">const </span><span class="s1">rankOfNextMember = memberRanks[index + </span><span class="s4">1</span><span class="s1">];</span>
        <span class="s3">if </span><span class="s1">(rankOfCurrentMember === previousRank) {</span>
            <span class="s1">groupedMembers.at(-</span><span class="s4">1</span><span class="s1">)?.push(member);</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(rankOfCurrentMember === rankOfNextMember) {</span>
            <span class="s1">groupedMembers.push([member]);</span>
            <span class="s1">previousRank = rankOfCurrentMember;</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s3">return </span><span class="s1">groupedMembers;</span>
<span class="s1">}</span>
<span class="s2">/**</span>
 <span class="s2">* Gets the lowest possible rank(s) higher than target.</span>
 <span class="s2">* e.g. given the following order:</span>
 <span class="s2">*   ...</span>
 <span class="s2">*   public-static-method</span>
 <span class="s2">*   protected-static-method</span>
 <span class="s2">*   private-static-method</span>
 <span class="s2">*   public-instance-method</span>
 <span class="s2">*   protected-instance-method</span>
 <span class="s2">*   private-instance-method</span>
 <span class="s2">*   ...</span>
 <span class="s2">* and considering that a public-instance-method has already been declared, so ranks contains</span>
 <span class="s2">* public-instance-method, then the lowest possible rank for public-static-method is</span>
 <span class="s2">* public-instance-method.</span>
 <span class="s2">* If a lowest possible rank is a member group, a comma separated list of ranks is returned.</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">ranks the existing ranks in the object.</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">target the minimum target rank to filter on.</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">order the current order to be validated.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">the name(s) of the lowest possible rank without dashes (-).</span>
 <span class="s2">*/</span>
<span class="s3">function </span><span class="s1">getLowestRank(ranks, target, order) {</span>
    <span class="s3">let </span><span class="s1">lowest = ranks[ranks.length - </span><span class="s4">1</span><span class="s1">];</span>
    <span class="s1">ranks.forEach(rank =&gt; {</span>
        <span class="s3">if </span><span class="s1">(rank &gt; target) {</span>
            <span class="s1">lowest = Math.min(lowest, rank);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s3">const </span><span class="s1">lowestRank = order[lowest];</span>
    <span class="s3">const </span><span class="s1">lowestRanks = Array.isArray(lowestRank) ? lowestRank : [lowestRank];</span>
    <span class="s3">return </span><span class="s1">lowestRanks.map(rank =&gt; rank.replaceAll(</span><span class="s0">'-'</span><span class="s1">, </span><span class="s0">' '</span><span class="s1">)).join(</span><span class="s0">', '</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s1">exports.default = (</span><span class="s4">0</span><span class="s1">, util_1.createRule)({</span>
    <span class="s1">name: </span><span class="s0">'member-ordering'</span><span class="s1">,</span>
    <span class="s1">meta: {</span>
        <span class="s1">type: </span><span class="s0">'suggestion'</span><span class="s1">,</span>
        <span class="s1">docs: {</span>
            <span class="s1">description: </span><span class="s0">'Require a consistent member declaration order'</span><span class="s1">,</span>
            <span class="s1">frozen: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">messages: {</span>
            <span class="s1">incorrectGroupOrder: </span><span class="s0">'Member {{name}} should be declared before all {{rank}} definitions.'</span><span class="s1">,</span>
            <span class="s1">incorrectOrder: </span><span class="s0">'Member {{member}} should be declared before member {{beforeMember}}.'</span><span class="s1">,</span>
            <span class="s1">incorrectRequiredMembersOrder: </span><span class="s0">`Member {{member}} should be declared after all {{optionalOrRequired}} members.`</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">schema: [</span>
            <span class="s1">{</span>
                <span class="s1">type: </span><span class="s0">'object'</span><span class="s1">,</span>
                <span class="s1">$defs: {</span>
                    <span class="s1">allItems: {</span>
                        <span class="s1">type: </span><span class="s0">'string'</span><span class="s1">,</span>
                        <span class="s3">enum</span><span class="s1">: allMemberTypes,</span>
                    <span class="s1">},</span>
                    <span class="s1">optionalityOrderOptions: {</span>
                        <span class="s1">type: </span><span class="s0">'string'</span><span class="s1">,</span>
                        <span class="s3">enum</span><span class="s1">: [</span><span class="s0">'optional-first'</span><span class="s1">, </span><span class="s0">'required-first'</span><span class="s1">],</span>
                    <span class="s1">},</span>
                    <span class="s1">orderOptions: {</span>
                        <span class="s1">type: </span><span class="s0">'string'</span><span class="s1">,</span>
                        <span class="s3">enum</span><span class="s1">: [</span>
                            <span class="s0">'alphabetically'</span><span class="s1">,</span>
                            <span class="s0">'alphabetically-case-insensitive'</span><span class="s1">,</span>
                            <span class="s0">'as-written'</span><span class="s1">,</span>
                            <span class="s0">'natural'</span><span class="s1">,</span>
                            <span class="s0">'natural-case-insensitive'</span><span class="s1">,</span>
                        <span class="s1">],</span>
                    <span class="s1">},</span>
                    <span class="s1">typeItems: {</span>
                        <span class="s1">type: </span><span class="s0">'string'</span><span class="s1">,</span>
                        <span class="s3">enum</span><span class="s1">: [</span>
                            <span class="s0">'readonly-signature'</span><span class="s1">,</span>
                            <span class="s0">'signature'</span><span class="s1">,</span>
                            <span class="s0">'readonly-field'</span><span class="s1">,</span>
                            <span class="s0">'field'</span><span class="s1">,</span>
                            <span class="s0">'method'</span><span class="s1">,</span>
                            <span class="s0">'constructor'</span><span class="s1">,</span>
                        <span class="s1">],</span>
                    <span class="s1">},</span>
                    <span class="s2">// ajv is order-dependent; these configs must come last</span>
                    <span class="s1">baseConfig: {</span>
                        <span class="s1">oneOf: [</span>
                            <span class="s1">neverConfig,</span>
                            <span class="s1">arrayConfig(</span><span class="s0">'#/items/0/$defs/allItems'</span><span class="s1">),</span>
                            <span class="s1">objectConfig(</span><span class="s0">'#/items/0/$defs/allItems'</span><span class="s1">),</span>
                        <span class="s1">],</span>
                    <span class="s1">},</span>
                    <span class="s1">typesConfig: {</span>
                        <span class="s1">oneOf: [</span>
                            <span class="s1">neverConfig,</span>
                            <span class="s1">arrayConfig(</span><span class="s0">'#/items/0/$defs/typeItems'</span><span class="s1">),</span>
                            <span class="s1">objectConfig(</span><span class="s0">'#/items/0/$defs/typeItems'</span><span class="s1">),</span>
                        <span class="s1">],</span>
                    <span class="s1">},</span>
                <span class="s1">},</span>
                <span class="s1">additionalProperties: </span><span class="s3">false</span><span class="s1">,</span>
                <span class="s1">properties: {</span>
                    <span class="s1">classes: {</span>
                        <span class="s1">$ref: </span><span class="s0">'#/items/0/$defs/baseConfig'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">classExpressions: {</span>
                        <span class="s1">$ref: </span><span class="s0">'#/items/0/$defs/baseConfig'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s3">default</span><span class="s1">: {</span>
                        <span class="s1">$ref: </span><span class="s0">'#/items/0/$defs/baseConfig'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">interfaces: {</span>
                        <span class="s1">$ref: </span><span class="s0">'#/items/0/$defs/typesConfig'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">typeLiterals: {</span>
                        <span class="s1">$ref: </span><span class="s0">'#/items/0/$defs/typesConfig'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                <span class="s1">},</span>
            <span class="s1">},</span>
        <span class="s1">],</span>
    <span class="s1">},</span>
    <span class="s1">defaultOptions: [</span>
        <span class="s1">{</span>
            <span class="s3">default</span><span class="s1">: {</span>
                <span class="s1">memberTypes: exports.defaultOrder,</span>
            <span class="s1">},</span>
        <span class="s1">},</span>
    <span class="s1">],</span>
    <span class="s1">create(context, [options]) {</span>
        <span class="s2">/**</span>
         <span class="s2">* Checks if the member groups are correctly sorted.</span>
         <span class="s2">*</span>
         <span class="s2">* </span><span class="s5">@param </span><span class="s2">members Members to be validated.</span>
         <span class="s2">* </span><span class="s5">@param </span><span class="s2">groupOrder Group order to be validated.</span>
         <span class="s2">* </span><span class="s5">@param </span><span class="s2">supportsModifiers A flag indicating whether the type supports modifiers (scope or accessibility) or not.</span>
         <span class="s2">*</span>
         <span class="s2">* </span><span class="s5">@return </span><span class="s2">Array of member groups or null if one of the groups is not correctly sorted.</span>
         <span class="s2">*/</span>
        <span class="s3">function </span><span class="s1">checkGroupSort(members, groupOrder, supportsModifiers) {</span>
            <span class="s3">const </span><span class="s1">previousRanks = [];</span>
            <span class="s3">const </span><span class="s1">memberGroups = [];</span>
            <span class="s3">let </span><span class="s1">isCorrectlySorted = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s2">// Find first member which isn't correctly sorted</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">member of members) {</span>
                <span class="s3">const </span><span class="s1">rank = getRank(member, groupOrder, supportsModifiers);</span>
                <span class="s3">const </span><span class="s1">name = getMemberName(member, context.sourceCode);</span>
                <span class="s3">const </span><span class="s1">rankLastMember = previousRanks[previousRanks.length - </span><span class="s4">1</span><span class="s1">];</span>
                <span class="s3">if </span><span class="s1">(rank === -</span><span class="s4">1</span><span class="s1">) {</span>
                    <span class="s3">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">// Works for 1st item because x &lt; undefined === false for any x (typeof string)</span>
                <span class="s3">if </span><span class="s1">(rank &lt; rankLastMember) {</span>
                    <span class="s1">context.report({</span>
                        <span class="s1">node: member,</span>
                        <span class="s1">messageId: </span><span class="s0">'incorrectGroupOrder'</span><span class="s1">,</span>
                        <span class="s1">data: {</span>
                            <span class="s1">name,</span>
                            <span class="s1">rank: getLowestRank(previousRanks, rank, groupOrder),</span>
                        <span class="s1">},</span>
                    <span class="s1">});</span>
                    <span class="s1">isCorrectlySorted = </span><span class="s3">false</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">else if </span><span class="s1">(rank === rankLastMember) {</span>
                    <span class="s2">// Same member group --&gt; Push to existing member group array</span>
                    <span class="s1">memberGroups[memberGroups.length - </span><span class="s4">1</span><span class="s1">].push(member);</span>
                <span class="s1">}</span>
                <span class="s3">else </span><span class="s1">{</span>
                    <span class="s2">// New member group --&gt; Create new member group array</span>
                    <span class="s1">previousRanks.push(rank);</span>
                    <span class="s1">memberGroups.push([member]);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">isCorrectlySorted ? memberGroups : </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">/**</span>
         <span class="s2">* Checks if the members are alphabetically sorted.</span>
         <span class="s2">*</span>
         <span class="s2">* </span><span class="s5">@param </span><span class="s2">members Members to be validated.</span>
         <span class="s2">* </span><span class="s5">@param </span><span class="s2">order What order the members should be sorted in.</span>
         <span class="s2">*</span>
         <span class="s2">* </span><span class="s5">@return </span><span class="s2">True if all members are correctly sorted.</span>
         <span class="s2">*/</span>
        <span class="s3">function </span><span class="s1">checkAlphaSort(members, order) {</span>
            <span class="s3">let </span><span class="s1">previousName = </span><span class="s0">''</span><span class="s1">;</span>
            <span class="s3">let </span><span class="s1">isCorrectlySorted = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s2">// Find first member which isn't correctly sorted</span>
            <span class="s1">members.forEach(member =&gt; {</span>
                <span class="s3">const </span><span class="s1">name = getMemberName(member, context.sourceCode);</span>
                <span class="s2">// Note: Not all members have names</span>
                <span class="s3">if </span><span class="s1">(name) {</span>
                    <span class="s3">if </span><span class="s1">(naturalOutOfOrder(name, previousName, order)) {</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node: member,</span>
                            <span class="s1">messageId: </span><span class="s0">'incorrectOrder'</span><span class="s1">,</span>
                            <span class="s1">data: {</span>
                                <span class="s1">beforeMember: previousName,</span>
                                <span class="s1">member: name,</span>
                            <span class="s1">},</span>
                        <span class="s1">});</span>
                        <span class="s1">isCorrectlySorted = </span><span class="s3">false</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s1">previousName = name;</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s3">return </span><span class="s1">isCorrectlySorted;</span>
        <span class="s1">}</span>
        <span class="s3">function </span><span class="s1">naturalOutOfOrder(name, previousName, order) {</span>
            <span class="s3">if </span><span class="s1">(name === previousName) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">switch </span><span class="s1">(order) {</span>
                <span class="s3">case </span><span class="s0">'alphabetically'</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">name &lt; previousName;</span>
                <span class="s3">case </span><span class="s0">'alphabetically-case-insensitive'</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">name.toLowerCase() &lt; previousName.toLowerCase();</span>
                <span class="s3">case </span><span class="s0">'natural'</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, natural_compare_1.default)(name, previousName) !== </span><span class="s4">1</span><span class="s1">;</span>
                <span class="s3">case </span><span class="s0">'natural-case-insensitive'</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, natural_compare_1.default)(name.toLowerCase(), previousName.toLowerCase()) !== </span><span class="s4">1</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">/**</span>
         <span class="s2">* Checks if the order of optional and required members is correct based</span>
         <span class="s2">* on the given 'required' parameter.</span>
         <span class="s2">*</span>
         <span class="s2">* </span><span class="s5">@param </span><span class="s2">members Members to be validated.</span>
         <span class="s2">* </span><span class="s5">@param </span><span class="s2">optionalityOrder Where to place optional members, if not intermixed.</span>
         <span class="s2">*</span>
         <span class="s2">* </span><span class="s5">@return </span><span class="s2">True if all required and optional members are correctly sorted.</span>
         <span class="s2">*/</span>
        <span class="s3">function </span><span class="s1">checkRequiredOrder(members, optionalityOrder) {</span>
            <span class="s3">const </span><span class="s1">switchIndex = members.findIndex((member, i) =&gt; i &amp;&amp; isMemberOptional(member) !== isMemberOptional(members[i - </span><span class="s4">1</span><span class="s1">]));</span>
            <span class="s3">const </span><span class="s1">report = (member) =&gt; context.report({</span>
                <span class="s1">loc: member.loc,</span>
                <span class="s1">messageId: </span><span class="s0">'incorrectRequiredMembersOrder'</span><span class="s1">,</span>
                <span class="s1">data: {</span>
                    <span class="s1">member: getMemberName(member, context.sourceCode),</span>
                    <span class="s1">optionalOrRequired: optionalityOrder === </span><span class="s0">'required-first' </span><span class="s1">? </span><span class="s0">'required' </span><span class="s1">: </span><span class="s0">'optional'</span><span class="s1">,</span>
                <span class="s1">},</span>
            <span class="s1">});</span>
            <span class="s2">// if the optionality of the first item is correct (based on optionalityOrder)</span>
            <span class="s2">// then the first 0 inclusive to switchIndex exclusive members all</span>
            <span class="s2">// have the correct optionality</span>
            <span class="s3">if </span><span class="s1">(isMemberOptional(members[</span><span class="s4">0</span><span class="s1">]) !==</span>
                <span class="s1">(optionalityOrder === </span><span class="s0">'optional-first'</span><span class="s1">)) {</span>
                <span class="s1">report(members[</span><span class="s4">0</span><span class="s1">]);</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = switchIndex + </span><span class="s4">1</span><span class="s1">; i &lt; members.length; i++) {</span>
                <span class="s3">if </span><span class="s1">(isMemberOptional(members[i]) !==</span>
                    <span class="s1">isMemberOptional(members[switchIndex])) {</span>
                    <span class="s1">report(members[switchIndex]);</span>
                    <span class="s3">return false</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">/**</span>
         <span class="s2">* Validates if all members are correctly sorted.</span>
         <span class="s2">*</span>
         <span class="s2">* </span><span class="s5">@param </span><span class="s2">members Members to be validated.</span>
         <span class="s2">* </span><span class="s5">@param </span><span class="s2">orderConfig Order config to be validated.</span>
         <span class="s2">* </span><span class="s5">@param </span><span class="s2">supportsModifiers A flag indicating whether the type supports modifiers (scope or accessibility) or not.</span>
         <span class="s2">*/</span>
        <span class="s3">function </span><span class="s1">validateMembersOrder(members, orderConfig, supportsModifiers) {</span>
            <span class="s3">if </span><span class="s1">(orderConfig === </span><span class="s0">'never'</span><span class="s1">) {</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">// Standardize config</span>
            <span class="s3">let </span><span class="s1">order;</span>
            <span class="s3">let </span><span class="s1">memberTypes;</span>
            <span class="s3">let </span><span class="s1">optionalityOrder;</span>
            <span class="s2">/**</span>
             <span class="s2">* It runs an alphabetic sort on the groups of the members of the class in the source code.</span>
             <span class="s2">* </span><span class="s5">@param </span><span class="s2">memberSet The members in the class of the source code on which the grouping operation will be performed.</span>
             <span class="s2">*/</span>
            <span class="s3">const </span><span class="s1">checkAlphaSortForAllMembers = (memberSet) =&gt; {</span>
                <span class="s3">const </span><span class="s1">hasAlphaSort = !!(order &amp;&amp; order !== </span><span class="s0">'as-written'</span><span class="s1">);</span>
                <span class="s3">if </span><span class="s1">(hasAlphaSort &amp;&amp; Array.isArray(memberTypes)) {</span>
                    <span class="s1">groupMembersByType(memberSet, memberTypes, supportsModifiers).forEach(members =&gt; {</span>
                        <span class="s1">checkAlphaSort(members, order);</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">};</span>
            <span class="s2">// returns true if everything is good and false if an error was reported</span>
            <span class="s3">const </span><span class="s1">checkOrder = (memberSet) =&gt; {</span>
                <span class="s3">const </span><span class="s1">hasAlphaSort = !!(order &amp;&amp; order !== </span><span class="s0">'as-written'</span><span class="s1">);</span>
                <span class="s2">// Check order</span>
                <span class="s3">if </span><span class="s1">(Array.isArray(memberTypes)) {</span>
                    <span class="s3">const </span><span class="s1">grouped = checkGroupSort(memberSet, memberTypes, supportsModifiers);</span>
                    <span class="s3">if </span><span class="s1">(grouped == </span><span class="s3">null</span><span class="s1">) {</span>
                        <span class="s1">checkAlphaSortForAllMembers(members);</span>
                        <span class="s3">return false</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(hasAlphaSort) {</span>
                        <span class="s1">grouped.map(groupMember =&gt; checkAlphaSort(groupMember, order));</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">else if </span><span class="s1">(hasAlphaSort) {</span>
                    <span class="s3">return </span><span class="s1">checkAlphaSort(memberSet, order);</span>
                <span class="s1">}</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">};</span>
            <span class="s3">if </span><span class="s1">(Array.isArray(orderConfig)) {</span>
                <span class="s1">memberTypes = orderConfig;</span>
            <span class="s1">}</span>
            <span class="s3">else </span><span class="s1">{</span>
                <span class="s1">order = orderConfig.order;</span>
                <span class="s1">memberTypes = orderConfig.memberTypes;</span>
                <span class="s1">optionalityOrder = orderConfig.optionalityOrder;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(!optionalityOrder) {</span>
                <span class="s1">checkOrder(members);</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">const </span><span class="s1">switchIndex = members.findIndex((member, i) =&gt; i &amp;&amp; isMemberOptional(member) !== isMemberOptional(members[i - </span><span class="s4">1</span><span class="s1">]));</span>
            <span class="s3">if </span><span class="s1">(switchIndex !== -</span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s3">if </span><span class="s1">(!checkRequiredOrder(members, optionalityOrder)) {</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">checkOrder(members.slice(</span><span class="s4">0</span><span class="s1">, switchIndex));</span>
                <span class="s1">checkOrder(members.slice(switchIndex));</span>
            <span class="s1">}</span>
            <span class="s3">else </span><span class="s1">{</span>
                <span class="s1">checkOrder(members);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">// https://github.com/typescript-eslint/typescript-eslint/issues/5439</span>
        <span class="s2">/* eslint-disable @typescript-eslint/no-non-null-assertion */</span>
        <span class="s3">return </span><span class="s1">{</span>
            <span class="s1">ClassDeclaration(node) {</span>
                <span class="s1">validateMembersOrder(node.body.body, options.classes ?? options.default, </span><span class="s3">true</span><span class="s1">);</span>
            <span class="s1">},</span>
            <span class="s0">'ClassDeclaration, FunctionDeclaration'</span><span class="s1">(node) {</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s0">'superClass' </span><span class="s3">in </span><span class="s1">node) {</span>
                    <span class="s2">// ...</span>
                <span class="s1">}</span>
            <span class="s1">},</span>
            <span class="s1">ClassExpression(node) {</span>
                <span class="s1">validateMembersOrder(node.body.body, options.classExpressions ?? options.default, </span><span class="s3">true</span><span class="s1">);</span>
            <span class="s1">},</span>
            <span class="s1">TSInterfaceDeclaration(node) {</span>
                <span class="s1">validateMembersOrder(node.body.body, options.interfaces ?? options.default, </span><span class="s3">false</span><span class="s1">);</span>
            <span class="s1">},</span>
            <span class="s1">TSTypeLiteral(node) {</span>
                <span class="s1">validateMembersOrder(node.members, options.typeLiterals ?? options.default, </span><span class="s3">false</span><span class="s1">);</span>
            <span class="s1">},</span>
        <span class="s1">};</span>
        <span class="s2">/* eslint-enable @typescript-eslint/no-non-null-assertion */</span>
    <span class="s1">},</span>
<span class="s1">});</span>
</pre>
</body>
</html>