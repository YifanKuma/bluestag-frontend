<html>
<head>
<title>tuple-map.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
tuple-map.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/client/components/segment-cache-impl/tuple-map.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// Utility type. Prefix&lt;[A, B, C, D]&gt; matches [A], [A, B], [A, B, C] etc.</span><span class="s3">\n</span><span class="s1">export type Prefix&lt;T extends any[]&gt; = T extends [infer First, ...infer Rest]</span><span class="s3">\n  </span><span class="s1">? [] | [First] | [First, ...Prefix&lt;Rest&gt;]</span><span class="s3">\n  </span><span class="s1">: []</span><span class="s3">\n\n</span><span class="s1">export type TupleMap&lt;Keypath extends Array&lt;any&gt;, V&gt; = {</span><span class="s3">\n  </span><span class="s1">set(keys: Prefix&lt;Keypath&gt;, value: V): void</span><span class="s3">\n  </span><span class="s1">get(keys: Prefix&lt;Keypath&gt;): V | null</span><span class="s3">\n  </span><span class="s1">delete(keys: Prefix&lt;Keypath&gt;): void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a map whose keys are tuples. Tuples are compared per-element. This</span><span class="s3">\n </span><span class="s1">* is useful when a key has multiple parts, but you don't want to concatenate</span><span class="s3">\n </span><span class="s1">* them into a single string value.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* In the Segment Cache, we use this to store cache entries by both their href</span><span class="s3">\n </span><span class="s1">* and their Next-URL.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Example:</span><span class="s3">\n </span><span class="s1">*   map.set(['https://localhost', 'foo/bar/baz'], 'yay');</span><span class="s3">\n </span><span class="s1">*   map.get(['https://localhost', 'foo/bar/baz']); // returns 'yay'</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function createTupleMap&lt;Keypath extends Array&lt;any&gt;, V&gt;(): TupleMap&lt;</span><span class="s3">\n  </span><span class="s1">Keypath,</span><span class="s3">\n  </span><span class="s1">V</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">type MapEntryShared = {</span><span class="s3">\n    </span><span class="s1">parent: MapEntry | null</span><span class="s3">\n    </span><span class="s1">key: any</span><span class="s3">\n    </span><span class="s1">map: Map&lt;any, MapEntry&gt; | null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">type EmptyMapEntry = MapEntryShared &amp; {</span><span class="s3">\n    </span><span class="s1">value: null</span><span class="s3">\n    </span><span class="s1">hasValue: false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">type FullMapEntry = MapEntryShared &amp; {</span><span class="s3">\n    </span><span class="s1">value: V</span><span class="s3">\n    </span><span class="s1">hasValue: true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">type MapEntry = EmptyMapEntry | FullMapEntry</span><span class="s3">\n\n  </span><span class="s1">let rootEntry: MapEntry = {</span><span class="s3">\n    </span><span class="s1">parent: null,</span><span class="s3">\n    </span><span class="s1">key: null,</span><span class="s3">\n    </span><span class="s1">hasValue: false,</span><span class="s3">\n    </span><span class="s1">value: null,</span><span class="s3">\n    </span><span class="s1">map: null,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// To optimize successive lookups, we cache the last accessed keypath.</span><span class="s3">\n  </span><span class="s1">// Although it's not encoded in the type, these are both null or</span><span class="s3">\n  </span><span class="s1">// both non-null. It uses object equality, so to take advantage of this</span><span class="s3">\n  </span><span class="s1">// optimization, you must pass the same array instance to each successive</span><span class="s3">\n  </span><span class="s1">// method call, and you must also not mutate the array between calls.</span><span class="s3">\n  </span><span class="s1">let lastAccessedEntry: MapEntry | null = null</span><span class="s3">\n  </span><span class="s1">let lastAccessedKeys: Prefix&lt;Keypath&gt; | null = null</span><span class="s3">\n\n  </span><span class="s1">function getOrCreateEntry(keys: Prefix&lt;Keypath&gt;): MapEntry {</span><span class="s3">\n    </span><span class="s1">if (lastAccessedKeys === keys) {</span><span class="s3">\n      </span><span class="s1">return lastAccessedEntry!</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Go through each level of keys until we find the entry that matches,</span><span class="s3">\n    </span><span class="s1">// or create a new one if it doesn't already exist.</span><span class="s3">\n    </span><span class="s1">let entry = rootEntry</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; keys.length; i++) {</span><span class="s3">\n      </span><span class="s1">const key = keys[i]</span><span class="s3">\n      </span><span class="s1">let map = entry.map</span><span class="s3">\n      </span><span class="s1">if (map !== null) {</span><span class="s3">\n        </span><span class="s1">const existingEntry = map.get(key)</span><span class="s3">\n        </span><span class="s1">if (existingEntry !== undefined) {</span><span class="s3">\n          </span><span class="s1">// Found a match. Keep going.</span><span class="s3">\n          </span><span class="s1">entry = existingEntry</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">map = new Map()</span><span class="s3">\n        </span><span class="s1">entry.map = map</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// No entry exists yet at this level. Create a new one.</span><span class="s3">\n      </span><span class="s1">const newEntry: MapEntry = {</span><span class="s3">\n        </span><span class="s1">parent: entry,</span><span class="s3">\n        </span><span class="s1">key,</span><span class="s3">\n        </span><span class="s1">value: null,</span><span class="s3">\n        </span><span class="s1">hasValue: false,</span><span class="s3">\n        </span><span class="s1">map: null,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">map.set(key, newEntry)</span><span class="s3">\n      </span><span class="s1">entry = newEntry</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">lastAccessedKeys = keys</span><span class="s3">\n    </span><span class="s1">lastAccessedEntry = entry</span><span class="s3">\n\n    </span><span class="s1">return entry</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function getEntryIfExists(keys: Prefix&lt;Keypath&gt;): MapEntry | null {</span><span class="s3">\n    </span><span class="s1">if (lastAccessedKeys === keys) {</span><span class="s3">\n      </span><span class="s1">return lastAccessedEntry</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Go through each level of keys until we find the entry that matches, or</span><span class="s3">\n    </span><span class="s1">// return null if no match exists.</span><span class="s3">\n    </span><span class="s1">let entry = rootEntry</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; keys.length; i++) {</span><span class="s3">\n      </span><span class="s1">const key = keys[i]</span><span class="s3">\n      </span><span class="s1">let map = entry.map</span><span class="s3">\n      </span><span class="s1">if (map !== null) {</span><span class="s3">\n        </span><span class="s1">const existingEntry = map.get(key)</span><span class="s3">\n        </span><span class="s1">if (existingEntry !== undefined) {</span><span class="s3">\n          </span><span class="s1">// Found a match. Keep going.</span><span class="s3">\n          </span><span class="s1">entry = existingEntry</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// No entry exists at this level.</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">lastAccessedKeys = keys</span><span class="s3">\n    </span><span class="s1">lastAccessedEntry = entry</span><span class="s3">\n\n    </span><span class="s1">return entry</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function set(keys: Prefix&lt;Keypath&gt;, value: V): void {</span><span class="s3">\n    </span><span class="s1">const entry = getOrCreateEntry(keys)</span><span class="s3">\n    </span><span class="s1">entry.hasValue = true</span><span class="s3">\n    </span><span class="s1">entry.value = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function get(keys: Prefix&lt;Keypath&gt;): V | null {</span><span class="s3">\n    </span><span class="s1">const entry = getEntryIfExists(keys)</span><span class="s3">\n    </span><span class="s1">if (entry === null || !entry.hasValue) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return entry.value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function deleteEntry(keys: Prefix&lt;Keypath&gt;): void {</span><span class="s3">\n    </span><span class="s1">const entry = getEntryIfExists(keys)</span><span class="s3">\n    </span><span class="s1">if (entry === null || !entry.hasValue) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Found a match. Delete it from the cache.</span><span class="s3">\n    </span><span class="s1">const deletedEntry: EmptyMapEntry = entry as any</span><span class="s3">\n    </span><span class="s1">deletedEntry.hasValue = false</span><span class="s3">\n    </span><span class="s1">deletedEntry.value = null</span><span class="s3">\n\n    </span><span class="s1">// Check if we can garbage collect the entry.</span><span class="s3">\n    </span><span class="s1">if (deletedEntry.map === null) {</span><span class="s3">\n      </span><span class="s1">// Since this entry has no value, and also no child entries, we can</span><span class="s3">\n      </span><span class="s1">// garbage collect it. Remove it from its parent, and keep garbage</span><span class="s3">\n      </span><span class="s1">// collecting the parents until we reach a non-empty entry.</span><span class="s3">\n\n      </span><span class="s1">// Unlike a `set` operation, these are no longer valid because the entry</span><span class="s3">\n      </span><span class="s1">// itself is being modified, not just the value it contains.</span><span class="s3">\n      </span><span class="s1">lastAccessedEntry = null</span><span class="s3">\n      </span><span class="s1">lastAccessedKeys = null</span><span class="s3">\n\n      </span><span class="s1">let parent = deletedEntry.parent</span><span class="s3">\n      </span><span class="s1">let key = deletedEntry.key</span><span class="s3">\n      </span><span class="s1">while (parent !== null) {</span><span class="s3">\n        </span><span class="s1">const parentMap = parent.map</span><span class="s3">\n        </span><span class="s1">if (parentMap !== null) {</span><span class="s3">\n          </span><span class="s1">parentMap.delete(key)</span><span class="s3">\n          </span><span class="s1">if (parentMap.size === 0) {</span><span class="s3">\n            </span><span class="s1">// We just removed the last entry in the parent map.</span><span class="s3">\n            </span><span class="s1">parent.map = null</span><span class="s3">\n            </span><span class="s1">if (parent.value === null) {</span><span class="s3">\n              </span><span class="s1">// The parent node has no child entries, nor does it have a value</span><span class="s3">\n              </span><span class="s1">// on itself. It can be garbage collected. Keep going.</span><span class="s3">\n              </span><span class="s1">key = parent.key</span><span class="s3">\n              </span><span class="s1">parent = parent.parent</span><span class="s3">\n              </span><span class="s1">continue</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// The parent is not empty. Stop garbage collecting.</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">set,</span><span class="s3">\n    </span><span class="s1">get,</span><span class="s3">\n    </span><span class="s1">delete: deleteEntry,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;createTupleMap&quot;</span><span class="s0">,</span><span class="s1">&quot;rootEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;hasValue&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;lastAccessedEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;lastAccessedKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;getOrCreateEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;entry&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;existingEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;newEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;getEntryIfExists&quot;</span><span class="s0">,</span><span class="s1">&quot;deleteEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;deletedEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;parentMap&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>