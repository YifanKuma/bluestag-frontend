<html>
<head>
<title>wasi-threads.cjs.min.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #1750eb;}
.s4 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
wasi-threads.cjs.min.js</font>
</center></td></tr></table>
<pre><span class="s0">const </span><span class="s1">e=</span><span class="s2">&quot;undefined&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">WebAssembly?WebAssembly:</span><span class="s2">&quot;undefined&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">WXWebAssembly?WXWebAssembly:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,t=</span><span class="s2">&quot;object&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">process&amp;&amp;</span><span class="s0">null</span><span class="s1">!==process&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">process.versions&amp;&amp;</span><span class="s0">null</span><span class="s1">!==process.versions&amp;&amp;</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">process.versions.node;</span><span class="s0">function </span><span class="s1">r(e){</span><span class="s0">return</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof</span><span class="s1">(</span><span class="s0">null</span><span class="s1">==e?</span><span class="s0">void </span><span class="s3">0</span><span class="s1">:e.postMessage)?e.postMessage:</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">postMessage?postMessage:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}</span><span class="s0">function </span><span class="s1">s(e){</span><span class="s0">return</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">SharedArrayBuffer&amp;&amp;e </span><span class="s0">instanceof </span><span class="s1">SharedArrayBuffer||</span><span class="s2">&quot;[object SharedArrayBuffer]&quot;</span><span class="s1">===Object.prototype.toString.call(e)}</span><span class="s0">function </span><span class="s1">o(t){</span><span class="s0">try</span><span class="s1">{</span><span class="s0">return </span><span class="s1">t </span><span class="s0">instanceof </span><span class="s1">e.RuntimeError}</span><span class="s0">catch</span><span class="s1">(e){</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">}}</span><span class="s0">function </span><span class="s1">n(e,t){</span><span class="s0">return</span><span class="s1">{__emnapi__:{type:e,payload:t}}}</span><span class="s0">function </span><span class="s1">i(e){</span><span class="s0">if</span><span class="s1">(e){</span><span class="s0">if</span><span class="s1">(!s(e.buffer))</span><span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Multithread features require shared wasm memory. Try to compile with `-matomics -mbulk-memory` and use `--import-memory --shared-memory` during linking, then create WebAssembly.Memory with `shared: true` option&quot;</span><span class="s1">)}</span><span class="s0">else if</span><span class="s1">(</span><span class="s2">&quot;undefined&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">SharedArrayBuffer)</span><span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Current environment does not support SharedArrayBuffer, threads are not available!&quot;</span><span class="s1">)}</span><span class="s0">let </span><span class="s1">a=</span><span class="s3">0</span><span class="s1">;</span><span class="s0">class </span><span class="s1">d{get nextWorkerID(){</span><span class="s0">return </span><span class="s1">a}constructor(e){</span><span class="s0">var </span><span class="s1">t;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.unusedWorkers=[],</span><span class="s0">this</span><span class="s1">.runningWorkers=[],</span><span class="s0">this</span><span class="s1">.pthreads=Object.create(</span><span class="s0">null</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.wasmModule=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.wasmMemory=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.messageEvents=</span><span class="s0">new </span><span class="s1">WeakMap,!e)</span><span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">&quot;ThreadManager(): options is not provided&quot;</span><span class="s1">);</span><span class="s0">this</span><span class="s1">._childThread=</span><span class="s2">&quot;childThread&quot;</span><span class="s0">in </span><span class="s1">e&amp;&amp;Boolean(e.childThread),</span><span class="s0">this</span><span class="s1">._childThread?(</span><span class="s0">this</span><span class="s1">._onCreateWorker=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">._reuseWorker=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">._beforeLoad=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">):(</span><span class="s0">this</span><span class="s1">._onCreateWorker=e.onCreateWorker,</span><span class="s0">this</span><span class="s1">._reuseWorker=</span><span class="s0">function</span><span class="s1">(e){</span><span class="s0">var </span><span class="s1">t;</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;boolean&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e)</span><span class="s0">return</span><span class="s1">!!e&amp;&amp;{size:</span><span class="s3">0</span><span class="s1">,strict:!</span><span class="s3">1</span><span class="s1">};</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e){</span><span class="s0">if</span><span class="s1">(!(e&gt;=</span><span class="s3">0</span><span class="s1">))</span><span class="s0">throw new </span><span class="s1">RangeError(</span><span class="s2">&quot;reuseWorker: size must be a non-negative integer&quot;</span><span class="s1">);</span><span class="s0">return</span><span class="s1">{size:e,strict:!</span><span class="s3">1</span><span class="s1">}}</span><span class="s0">if</span><span class="s1">(!e)</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">const </span><span class="s1">r=</span><span class="s0">null</span><span class="s1">!==(t=Number(e.size))&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==t?t:</span><span class="s3">0</span><span class="s1">,s=Boolean(e.strict);</span><span class="s0">if</span><span class="s1">(!(r&gt;</span><span class="s3">0</span><span class="s1">)&amp;&amp;s)</span><span class="s0">throw new </span><span class="s1">RangeError(</span><span class="s2">&quot;reuseWorker: size must be set to positive integer if strict is set to true&quot;</span><span class="s1">);</span><span class="s0">return</span><span class="s1">{size:r,strict:s}}(e.reuseWorker),</span><span class="s0">this</span><span class="s1">._beforeLoad=e.beforeLoad),</span><span class="s0">this</span><span class="s1">.printErr=</span><span class="s0">null</span><span class="s1">!==(t=e.printErr)&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==t?t:console.error.bind(console)}init(){</span><span class="s0">this</span><span class="s1">._childThread||</span><span class="s0">this</span><span class="s1">.initMainThread()}initMainThread(){</span><span class="s0">this</span><span class="s1">.preparePool()}preparePool(){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">._reuseWorker&amp;&amp;</span><span class="s0">this</span><span class="s1">._reuseWorker.size){</span><span class="s0">let </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">._reuseWorker.size;</span><span class="s0">for</span><span class="s1">(;e--;){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.allocateUnusedWorker();t&amp;&amp;(e.once(</span><span class="s2">&quot;message&quot;</span><span class="s1">,()=&gt;{}),e.unref())}}}shouldPreloadWorkers(){</span><span class="s0">return</span><span class="s1">!</span><span class="s0">this</span><span class="s1">._childThread&amp;&amp;</span><span class="s0">this</span><span class="s1">._reuseWorker&amp;&amp;</span><span class="s0">this</span><span class="s1">._reuseWorker.size&gt;</span><span class="s3">0</span><span class="s1">}loadWasmModuleToAllWorkers(){</span><span class="s0">const </span><span class="s1">e=Array(</span><span class="s0">this</span><span class="s1">.unusedWorkers.length);</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">r=</span><span class="s3">0</span><span class="s1">;r&lt;</span><span class="s0">this</span><span class="s1">.unusedWorkers.length;++r){</span><span class="s0">const </span><span class="s1">s=</span><span class="s0">this</span><span class="s1">.unusedWorkers[r];t&amp;&amp;s.ref(),e[r]=</span><span class="s0">this</span><span class="s1">.loadWasmModuleToWorker(s).then(e=&gt;(t&amp;&amp;s.unref(),e),e=&gt;{</span><span class="s0">throw </span><span class="s1">t&amp;&amp;s.unref(),e})}</span><span class="s0">return </span><span class="s1">Promise.all(e).catch(e=&gt;{</span><span class="s0">throw this</span><span class="s1">.terminateAllThreads(),e})}preloadWorkers(){</span><span class="s0">return this</span><span class="s1">.shouldPreloadWorkers()?</span><span class="s0">this</span><span class="s1">.loadWasmModuleToAllWorkers():Promise.resolve([])}setup(e,t){</span><span class="s0">this</span><span class="s1">.wasmModule=e,</span><span class="s0">this</span><span class="s1">.wasmMemory=t}markId(e){</span><span class="s0">if</span><span class="s1">(e.__emnapi_tid)</span><span class="s0">return </span><span class="s1">e.__emnapi_tid;</span><span class="s0">const </span><span class="s1">t=a+</span><span class="s3">43</span><span class="s1">;</span><span class="s0">return </span><span class="s1">a=(a+</span><span class="s3">1</span><span class="s1">)%</span><span class="s3">536870869</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.pthreads[t]=e,e.__emnapi_tid=t,t}returnWorkerToPool(e){</span><span class="s0">var </span><span class="s1">r=e.__emnapi_tid;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==r&amp;&amp;</span><span class="s0">delete this</span><span class="s1">.pthreads[r],</span><span class="s0">this</span><span class="s1">.unusedWorkers.push(e),</span><span class="s0">this</span><span class="s1">.runningWorkers.splice(</span><span class="s0">this</span><span class="s1">.runningWorkers.indexOf(e),</span><span class="s3">1</span><span class="s1">),</span><span class="s0">delete </span><span class="s1">e.__emnapi_tid,t&amp;&amp;e.unref()}loadWasmModuleToWorker(e,r){</span><span class="s0">if</span><span class="s1">(e.whenLoaded)</span><span class="s0">return </span><span class="s1">e.whenLoaded;</span><span class="s0">const </span><span class="s1">s=</span><span class="s0">this</span><span class="s1">.printErr,o=</span><span class="s0">this</span><span class="s1">._beforeLoad,a=</span><span class="s0">this</span><span class="s1">;</span><span class="s0">return </span><span class="s1">e.whenLoaded=</span><span class="s0">new </span><span class="s1">Promise((d,h)=&gt;{</span><span class="s0">const </span><span class="s1">l=r=&gt;{</span><span class="s0">if</span><span class="s1">(r.__emnapi__){</span><span class="s0">const </span><span class="s1">s=r.__emnapi__.type,o=r.__emnapi__.payload;</span><span class="s2">&quot;loaded&quot;</span><span class="s1">===s?(e.loaded=!</span><span class="s3">0</span><span class="s1">,t&amp;&amp;!e.__emnapi_tid&amp;&amp;e.unref(),d(e)):</span><span class="s2">&quot;cleanup-thread&quot;</span><span class="s1">===s&amp;&amp;o.tid </span><span class="s0">in this</span><span class="s1">.pthreads&amp;&amp;</span><span class="s0">this</span><span class="s1">.cleanThread(e,o.tid)}};e.onmessage=t=&gt;{l(t.data),</span><span class="s0">this</span><span class="s1">.fireMessageEvent(e,t)},e.onerror=</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">let </span><span class="s1">r=</span><span class="s2">&quot;worker sent an error!&quot;</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==e.__emnapi_tid&amp;&amp;(r=</span><span class="s2">&quot;worker (tid = &quot;</span><span class="s1">+e.__emnapi_tid+</span><span class="s2">&quot;) sent an error!&quot;</span><span class="s1">),</span><span class="s2">&quot;message&quot;</span><span class="s0">in </span><span class="s1">t){</span><span class="s0">if</span><span class="s1">(s(r+</span><span class="s2">&quot; &quot;</span><span class="s1">+t.message),-</span><span class="s3">1</span><span class="s1">!==t.message.indexOf(</span><span class="s2">&quot;RuntimeError&quot;</span><span class="s1">)||-</span><span class="s3">1</span><span class="s1">!==t.message.indexOf(</span><span class="s2">&quot;unreachable&quot;</span><span class="s1">))</span><span class="s0">try</span><span class="s1">{a.terminateAllThreads()}</span><span class="s0">catch</span><span class="s1">(e){}}</span><span class="s0">else </span><span class="s1">s(r);</span><span class="s0">throw </span><span class="s1">h(t),t},t&amp;&amp;(e.on(</span><span class="s2">&quot;message&quot;</span><span class="s1">,</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">var </span><span class="s1">r,s;</span><span class="s0">null</span><span class="s1">===(s=(r=e).onmessage)||</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===s||s.call(r,{data:t})}),e.on(</span><span class="s2">&quot;error&quot;</span><span class="s1">,</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">var </span><span class="s1">r,s;</span><span class="s0">null</span><span class="s1">===(s=(r=e).onerror)||</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===s||s.call(r,t)}),e.on(</span><span class="s2">&quot;detachedExit&quot;</span><span class="s1">,</span><span class="s0">function</span><span class="s1">(){})),</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">o&amp;&amp;o(e);</span><span class="s0">try</span><span class="s1">{e.postMessage(n(</span><span class="s2">&quot;load&quot;</span><span class="s1">,{wasmModule:</span><span class="s0">this</span><span class="s1">.wasmModule,wasmMemory:</span><span class="s0">this</span><span class="s1">.wasmMemory,sab:r}))}</span><span class="s0">catch</span><span class="s1">(e){</span><span class="s0">throw </span><span class="s1">i(</span><span class="s0">this</span><span class="s1">.wasmMemory),e}}),e.whenLoaded}allocateUnusedWorker(){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">._onCreateWorker;</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;function&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">e)</span><span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">&quot;`options.onCreateWorker` is not provided&quot;</span><span class="s1">);</span><span class="s0">const </span><span class="s1">t=e({type:</span><span class="s2">&quot;thread&quot;</span><span class="s1">,name:</span><span class="s2">&quot;emnapi-pthread&quot;</span><span class="s1">});</span><span class="s0">return this</span><span class="s1">.unusedWorkers.push(t),t}getNewWorker(e){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">._reuseWorker){</span><span class="s0">if</span><span class="s1">(</span><span class="s3">0</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.unusedWorkers.length){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">._reuseWorker.strict&amp;&amp;!t){</span><span class="s0">return void</span><span class="s1">(</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.printErr)(</span><span class="s2">&quot;Tried to spawn a new thread, but the thread pool is exhausted.</span><span class="s4">\n</span><span class="s2">This might result in a deadlock unless some threads eventually exit or the code explicitly breaks out to the event loop.&quot;</span><span class="s1">)}</span><span class="s0">const </span><span class="s1">r=</span><span class="s0">this</span><span class="s1">.allocateUnusedWorker();</span><span class="s0">this</span><span class="s1">.loadWasmModuleToWorker(r,e)}</span><span class="s0">return this</span><span class="s1">.unusedWorkers.pop()}</span><span class="s0">const </span><span class="s1">r=</span><span class="s0">this</span><span class="s1">.allocateUnusedWorker();</span><span class="s0">return this</span><span class="s1">.loadWasmModuleToWorker(r,e),</span><span class="s0">this</span><span class="s1">.unusedWorkers.pop()}cleanThread(e,t,r){</span><span class="s0">if</span><span class="s1">(!r&amp;&amp;</span><span class="s0">this</span><span class="s1">._reuseWorker)</span><span class="s0">this</span><span class="s1">.returnWorkerToPool(e);</span><span class="s0">else</span><span class="s1">{</span><span class="s0">delete this</span><span class="s1">.pthreads[t];</span><span class="s0">const </span><span class="s1">r=</span><span class="s0">this</span><span class="s1">.runningWorkers.indexOf(e);-</span><span class="s3">1</span><span class="s1">!==r&amp;&amp;</span><span class="s0">this</span><span class="s1">.runningWorkers.splice(r,</span><span class="s3">1</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.terminateWorker(e),</span><span class="s0">delete </span><span class="s1">e.__emnapi_tid}}terminateWorker(e){</span><span class="s0">var </span><span class="s1">t;</span><span class="s0">const </span><span class="s1">r=e.__emnapi_tid;e.terminate(),</span><span class="s0">null</span><span class="s1">===(t=</span><span class="s0">this</span><span class="s1">.messageEvents.get(e))||</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===t||t.clear(),</span><span class="s0">this</span><span class="s1">.messageEvents.delete(e),e.onmessage=e=&gt;{</span><span class="s0">if</span><span class="s1">(e.data.__emnapi__){(</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.printErr)(</span><span class="s2">'received &quot;'</span><span class="s1">+e.data.__emnapi__.type+</span><span class="s2">'&quot; command from terminated worker: '</span><span class="s1">+r)}}}terminateAllThreads(){</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">0</span><span class="s1">;e&lt;</span><span class="s0">this</span><span class="s1">.runningWorkers.length;++e)</span><span class="s0">this</span><span class="s1">.terminateWorker(</span><span class="s0">this</span><span class="s1">.runningWorkers[e]);</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">0</span><span class="s1">;e&lt;</span><span class="s0">this</span><span class="s1">.unusedWorkers.length;++e)</span><span class="s0">this</span><span class="s1">.terminateWorker(</span><span class="s0">this</span><span class="s1">.unusedWorkers[e]);</span><span class="s0">this</span><span class="s1">.unusedWorkers=[],</span><span class="s0">this</span><span class="s1">.runningWorkers=[],</span><span class="s0">this</span><span class="s1">.pthreads=Object.create(</span><span class="s0">null</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.preparePool()}addMessageEventListener(e,t){</span><span class="s0">let </span><span class="s1">r=</span><span class="s0">this</span><span class="s1">.messageEvents.get(e);</span><span class="s0">return </span><span class="s1">r||(r=</span><span class="s0">new </span><span class="s1">Set,</span><span class="s0">this</span><span class="s1">.messageEvents.set(e,r)),r.add(t),()=&gt;{</span><span class="s0">null</span><span class="s1">==r||r.delete(t)}}fireMessageEvent(e,t){</span><span class="s0">const </span><span class="s1">r=</span><span class="s0">this</span><span class="s1">.messageEvents.get(e);</span><span class="s0">if</span><span class="s1">(!r)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">s=</span><span class="s0">this</span><span class="s1">.printErr;r.forEach(e=&gt;{</span><span class="s0">try</span><span class="s1">{e(t)}</span><span class="s0">catch</span><span class="s1">(e){s(e.stack)}})}}</span><span class="s0">const </span><span class="s1">h=Symbol(</span><span class="s2">&quot;kIsProxy&quot;</span><span class="s1">);</span><span class="s0">function </span><span class="s1">l(e,t){</span><span class="s0">if</span><span class="s1">(e[h])</span><span class="s0">return </span><span class="s1">e;</span><span class="s0">const </span><span class="s1">r=e.exports,s=</span><span class="s0">function</span><span class="s1">(e){</span><span class="s0">const </span><span class="s1">t=[</span><span class="s2">&quot;apply&quot;</span><span class="s1">,</span><span class="s2">&quot;construct&quot;</span><span class="s1">,</span><span class="s2">&quot;defineProperty&quot;</span><span class="s1">,</span><span class="s2">&quot;deleteProperty&quot;</span><span class="s1">,</span><span class="s2">&quot;get&quot;</span><span class="s1">,</span><span class="s2">&quot;getOwnPropertyDescriptor&quot;</span><span class="s1">,</span><span class="s2">&quot;getPrototypeOf&quot;</span><span class="s1">,</span><span class="s2">&quot;has&quot;</span><span class="s1">,</span><span class="s2">&quot;isExtensible&quot;</span><span class="s1">,</span><span class="s2">&quot;ownKeys&quot;</span><span class="s1">,</span><span class="s2">&quot;preventExtensions&quot;</span><span class="s1">,</span><span class="s2">&quot;set&quot;</span><span class="s1">,</span><span class="s2">&quot;setPrototypeOf&quot;</span><span class="s1">],r={};</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">s=</span><span class="s3">0</span><span class="s1">;s&lt;t.length;s++){</span><span class="s0">const </span><span class="s1">o=t[s];r[o]=</span><span class="s0">function</span><span class="s1">(){</span><span class="s0">const </span><span class="s1">t=Array.prototype.slice.call(arguments,</span><span class="s3">1</span><span class="s1">);</span><span class="s0">return </span><span class="s1">t.unshift(e),Reflect[o].apply(Reflect,t)}}</span><span class="s0">return </span><span class="s1">r}(r),o=()=&gt;{},n=()=&gt;</span><span class="s3">0</span><span class="s1">;s.get=</span><span class="s0">function</span><span class="s1">(e,s,i){</span><span class="s0">var </span><span class="s1">a;</span><span class="s0">return</span><span class="s2">&quot;memory&quot;</span><span class="s1">===s?</span><span class="s0">null</span><span class="s1">!==(a=</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t?t():t)&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==a?a:Reflect.get(r,s,i):</span><span class="s2">&quot;_initialize&quot;</span><span class="s1">===s?s </span><span class="s0">in </span><span class="s1">r?o:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">:</span><span class="s2">&quot;_start&quot;</span><span class="s1">===s?s </span><span class="s0">in </span><span class="s1">r?n:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">:Reflect.get(r,s,i)},s.has=</span><span class="s0">function</span><span class="s1">(e,t){</span><span class="s0">return</span><span class="s2">&quot;memory&quot;</span><span class="s1">===t||Reflect.has(r,t)};</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">new </span><span class="s1">Proxy(Object.create(</span><span class="s0">null</span><span class="s1">),s);</span><span class="s0">return new </span><span class="s1">Proxy(e,{get:(e,t,r)=&gt;</span><span class="s2">&quot;exports&quot;</span><span class="s1">===t?i:t===h||Reflect.get(e,t,r)})}</span><span class="s0">const </span><span class="s1">c=</span><span class="s0">new </span><span class="s1">WeakMap;</span><span class="s0">function </span><span class="s1">u(e,t){</span><span class="s0">const </span><span class="s1">r=Object.getOwnPropertySymbols(e),s=e=&gt;t=&gt;t.description?t.description===e:t.toString()===</span><span class="s2">`Symbol(</span><span class="s1">${e}</span><span class="s2">)`</span><span class="s1">;</span><span class="s0">return </span><span class="s1">Array.isArray(t)?t.map(e=&gt;r.filter(s(e))[</span><span class="s3">0</span><span class="s1">]):r.filter(s(t))[</span><span class="s3">0</span><span class="s1">]}</span><span class="s0">function </span><span class="s1">f(e,t,r){e&amp;&amp;(!</span><span class="s0">function</span><span class="s1">(e,t,r){</span><span class="s0">const </span><span class="s1">s=</span><span class="s0">new </span><span class="s1">Int32Array(e);</span><span class="s0">if</span><span class="s1">(Atomics.store(s,</span><span class="s3">0</span><span class="s1">,t),t&gt;</span><span class="s3">1</span><span class="s1">&amp;&amp;r){</span><span class="s0">const </span><span class="s1">t=r.name,o=r.message,n=r.stack,i=(</span><span class="s0">new </span><span class="s1">TextEncoder).encode(t),a=(</span><span class="s0">new </span><span class="s1">TextEncoder).encode(o),d=(</span><span class="s0">new </span><span class="s1">TextEncoder).encode(n);Atomics.store(s,</span><span class="s3">1</span><span class="s1">,i.length),Atomics.store(s,</span><span class="s3">2</span><span class="s1">,a.length),Atomics.store(s,</span><span class="s3">3</span><span class="s1">,d.length);</span><span class="s0">const </span><span class="s1">h=</span><span class="s0">new </span><span class="s1">Uint8Array(e);h.set(i,</span><span class="s3">16</span><span class="s1">),h.set(a,</span><span class="s3">16</span><span class="s1">+i.length),h.set(d,</span><span class="s3">16</span><span class="s1">+i.length+a.length)}}(e.buffer,t,r),Atomics.notify(e,</span><span class="s3">0</span><span class="s1">))}exports.ThreadManager=d,exports.ThreadMessageHandler=</span><span class="s0">class</span><span class="s1">{constructor(e){</span><span class="s0">const </span><span class="s1">t=r(e);</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;function&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">t)</span><span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">&quot;options.postMessage is not a function&quot;</span><span class="s1">);</span><span class="s0">this</span><span class="s1">.postMessage=t,</span><span class="s0">this</span><span class="s1">.onLoad=</span><span class="s0">null</span><span class="s1">==e?</span><span class="s0">void </span><span class="s3">0</span><span class="s1">:e.onLoad,</span><span class="s0">this</span><span class="s1">.onError=</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof</span><span class="s1">(</span><span class="s0">null</span><span class="s1">==e?</span><span class="s0">void </span><span class="s3">0</span><span class="s1">:e.onError)?e.onError:(e,t)=&gt;{</span><span class="s0">throw </span><span class="s1">t},</span><span class="s0">this</span><span class="s1">.instance=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.messagesBeforeLoad=[]}instantiate(e){</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof this</span><span class="s1">.onLoad)</span><span class="s0">return this</span><span class="s1">.onLoad(e);</span><span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">&quot;ThreadMessageHandler.prototype.instantiate is not implemented&quot;</span><span class="s1">)}handle(e){</span><span class="s0">var </span><span class="s1">t;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">null</span><span class="s1">===(t=</span><span class="s0">null</span><span class="s1">==e?</span><span class="s0">void </span><span class="s3">0</span><span class="s1">:e.data)||</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===t?</span><span class="s0">void </span><span class="s3">0</span><span class="s1">:t.__emnapi__){</span><span class="s0">const </span><span class="s1">t=e.data.__emnapi__.type,r=e.data.__emnapi__.payload;</span><span class="s0">try</span><span class="s1">{</span><span class="s2">&quot;load&quot;</span><span class="s1">===t?</span><span class="s0">this</span><span class="s1">._load(r):</span><span class="s2">&quot;start&quot;</span><span class="s1">===t&amp;&amp;</span><span class="s0">this</span><span class="s1">.handleAfterLoad(e,()=&gt;{</span><span class="s0">this</span><span class="s1">._start(r)})}</span><span class="s0">catch</span><span class="s1">(e){</span><span class="s0">this</span><span class="s1">.onError(e,t)}}}_load(e){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.instance)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">let </span><span class="s1">t;</span><span class="s0">try</span><span class="s1">{t=</span><span class="s0">this</span><span class="s1">.instantiate(e)}</span><span class="s0">catch</span><span class="s1">(t){</span><span class="s0">return void this</span><span class="s1">._loaded(t,</span><span class="s0">null</span><span class="s1">,e)}</span><span class="s0">const </span><span class="s1">r=t&amp;&amp;</span><span class="s2">&quot;then&quot;</span><span class="s0">in </span><span class="s1">t?t.then:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">;</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">r?r.call(t,t=&gt;{</span><span class="s0">this</span><span class="s1">._loaded(</span><span class="s0">null</span><span class="s1">,t,e)},t=&gt;{</span><span class="s0">this</span><span class="s1">._loaded(t,</span><span class="s0">null</span><span class="s1">,e)}):</span><span class="s0">this</span><span class="s1">._loaded(</span><span class="s0">null</span><span class="s1">,t,e)}_start(e){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.instance.exports.wasi_thread_start;</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;function&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">t){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">new </span><span class="s1">TypeError(</span><span class="s2">&quot;wasi_thread_start is not exported&quot;</span><span class="s1">);</span><span class="s0">throw </span><span class="s1">f(e.sab,</span><span class="s3">2</span><span class="s1">,t),t}</span><span class="s0">const </span><span class="s1">r=</span><span class="s0">this</span><span class="s1">.postMessage,s=e.tid,o=e.arg;f(e.sab,</span><span class="s3">1</span><span class="s1">);</span><span class="s0">try</span><span class="s1">{t(s,o)}</span><span class="s0">catch</span><span class="s1">(e){</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;unwind&quot;</span><span class="s1">!==e)</span><span class="s0">throw </span><span class="s1">e;</span><span class="s0">return</span><span class="s1">}r(n(</span><span class="s2">&quot;cleanup-thread&quot;</span><span class="s1">,{tid:s}))}_loaded(e,t,r){</span><span class="s0">if</span><span class="s1">(e)</span><span class="s0">throw </span><span class="s1">f(r.sab,</span><span class="s3">2</span><span class="s1">,e),e;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">null</span><span class="s1">==t){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">new </span><span class="s1">TypeError(</span><span class="s2">&quot;onLoad should return an object&quot;</span><span class="s1">);</span><span class="s0">throw </span><span class="s1">f(r.sab,</span><span class="s3">2</span><span class="s1">,e),e}</span><span class="s0">const </span><span class="s1">s=t.instance;</span><span class="s0">if</span><span class="s1">(!s){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">new </span><span class="s1">TypeError(</span><span class="s2">'onLoad should return an object which includes &quot;instance&quot;'</span><span class="s1">);</span><span class="s0">throw </span><span class="s1">f(r.sab,</span><span class="s3">2</span><span class="s1">,e),e}</span><span class="s0">this</span><span class="s1">.instance=s;(</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.postMessage)(n(</span><span class="s2">&quot;loaded&quot;</span><span class="s1">,{}));</span><span class="s0">const </span><span class="s1">o=</span><span class="s0">this</span><span class="s1">.messagesBeforeLoad;</span><span class="s0">this</span><span class="s1">.messagesBeforeLoad=[];</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">0</span><span class="s1">;e&lt;o.length;e++){</span><span class="s0">const </span><span class="s1">t=o[e];</span><span class="s0">this</span><span class="s1">.handle({data:t})}}handleAfterLoad(e,t){</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.instance?t.call(</span><span class="s0">this</span><span class="s1">,e):</span><span class="s0">this</span><span class="s1">.messagesBeforeLoad.push(e.data)}},exports.WASIThreads=</span><span class="s0">class</span><span class="s1">{constructor(s){</span><span class="s0">if</span><span class="s1">(!s)</span><span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">&quot;WASIThreads(): options is not provided&quot;</span><span class="s1">);</span><span class="s0">if</span><span class="s1">(!s.wasi)</span><span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">&quot;WASIThreads(): options.wasi is not provided&quot;</span><span class="s1">);c.set(</span><span class="s0">this</span><span class="s1">,</span><span class="s0">new </span><span class="s1">WeakSet);</span><span class="s0">const </span><span class="s1">a=s.wasi;!</span><span class="s0">function</span><span class="s1">(e,t){</span><span class="s0">const </span><span class="s1">r=c.get(e);</span><span class="s0">if</span><span class="s1">(r.has(t))</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">s=e,n=t.wasiImport;</span><span class="s0">if</span><span class="s1">(n){</span><span class="s0">const </span><span class="s1">e=n.proc_exit;n.proc_exit=</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">return </span><span class="s1">s.terminateAllThreads(),e.call(</span><span class="s0">this</span><span class="s1">,t)}}</span><span class="s0">if</span><span class="s1">(!s.childThread){</span><span class="s0">const </span><span class="s1">e=t.start;</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e&amp;&amp;(t.start=</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">try</span><span class="s1">{</span><span class="s0">return </span><span class="s1">e.call(</span><span class="s0">this</span><span class="s1">,t)}</span><span class="s0">catch</span><span class="s1">(e){</span><span class="s0">throw </span><span class="s1">o(e)&amp;&amp;s.terminateAllThreads(),e}})}r.add(t)}(</span><span class="s0">this</span><span class="s1">,a),</span><span class="s0">this</span><span class="s1">.wasi=a,</span><span class="s0">this</span><span class="s1">.childThread=</span><span class="s2">&quot;childThread&quot;</span><span class="s0">in </span><span class="s1">s&amp;&amp;Boolean(s.childThread),</span><span class="s0">this</span><span class="s1">.PThread=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s2">&quot;threadManager&quot;</span><span class="s0">in </span><span class="s1">s?</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">s.threadManager?</span><span class="s0">this</span><span class="s1">.PThread=s.threadManager():</span><span class="s0">this</span><span class="s1">.PThread=s.threadManager:</span><span class="s0">this</span><span class="s1">.childThread||(</span><span class="s0">this</span><span class="s1">.PThread=</span><span class="s0">new </span><span class="s1">d(s),</span><span class="s0">this</span><span class="s1">.PThread.init());</span><span class="s0">let </span><span class="s1">h=!</span><span class="s3">1</span><span class="s1">;</span><span class="s2">&quot;waitThreadStart&quot;</span><span class="s0">in </span><span class="s1">s&amp;&amp;(h=</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">s.waitThreadStart?s.waitThreadStart:Boolean(s.waitThreadStart));</span><span class="s0">const </span><span class="s1">l=r(s);</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.childThread&amp;&amp;</span><span class="s2">&quot;function&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">l)</span><span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">&quot;options.postMessage is not a function&quot;</span><span class="s1">);</span><span class="s0">this</span><span class="s1">.postMessage=l;</span><span class="s0">const </span><span class="s1">u=Boolean(s.wasm64),f=e=&gt;{</span><span class="s0">if</span><span class="s1">(e.data.__emnapi__){</span><span class="s0">const </span><span class="s1">t=e.data.__emnapi__.type,r=e.data.__emnapi__.payload;</span><span class="s2">&quot;spawn-thread&quot;</span><span class="s1">===t?p(r.startArg,r.errorOrTid):</span><span class="s2">&quot;terminate-all-threads&quot;</span><span class="s1">===t&amp;&amp;</span><span class="s0">this</span><span class="s1">.terminateAllThreads()}},p=(r,s)=&gt;{</span><span class="s0">var </span><span class="s1">o;</span><span class="s0">const </span><span class="s1">a=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==s;</span><span class="s0">try</span><span class="s1">{i(</span><span class="s0">this</span><span class="s1">.wasmMemory)}</span><span class="s0">catch</span><span class="s1">(e){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">null</span><span class="s1">===(o=</span><span class="s0">this</span><span class="s1">.PThread)||</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===o||o.printErr(e.stack),a){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">new </span><span class="s1">Int32Array(</span><span class="s0">this</span><span class="s1">.wasmMemory.buffer,s,</span><span class="s3">2</span><span class="s1">);</span><span class="s0">return </span><span class="s1">Atomics.store(e,</span><span class="s3">0</span><span class="s1">,</span><span class="s3">1</span><span class="s1">),Atomics.store(e,</span><span class="s3">1</span><span class="s1">,</span><span class="s3">6</span><span class="s1">),Atomics.notify(e,</span><span class="s3">1</span><span class="s1">),</span><span class="s3">1</span><span class="s1">}</span><span class="s0">return</span><span class="s1">-</span><span class="s3">6</span><span class="s1">}</span><span class="s0">if</span><span class="s1">(!a){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.wasmInstance.exports.malloc;</span><span class="s0">if</span><span class="s1">(!(s=u?Number(e(BigInt(</span><span class="s3">8</span><span class="s1">))):e(</span><span class="s3">8</span><span class="s1">)))</span><span class="s0">return</span><span class="s1">-</span><span class="s3">48</span><span class="s1">}</span><span class="s0">const </span><span class="s1">d=</span><span class="s0">this</span><span class="s1">.wasmInstance.exports.free,c=u?e=&gt;{d(BigInt(e))}:d,p=</span><span class="s0">new </span><span class="s1">Int32Array(</span><span class="s0">this</span><span class="s1">.wasmMemory.buffer,s,</span><span class="s3">2</span><span class="s1">);</span><span class="s0">if</span><span class="s1">(Atomics.store(p,</span><span class="s3">0</span><span class="s1">,</span><span class="s3">0</span><span class="s1">),Atomics.store(p,</span><span class="s3">1</span><span class="s1">,</span><span class="s3">0</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.childThread){l(n(</span><span class="s2">&quot;spawn-thread&quot;</span><span class="s1">,{startArg:r,errorOrTid:s})),Atomics.wait(p,</span><span class="s3">1</span><span class="s1">,</span><span class="s3">0</span><span class="s1">);</span><span class="s0">const </span><span class="s1">e=Atomics.load(p,</span><span class="s3">0</span><span class="s1">),t=Atomics.load(p,</span><span class="s3">1</span><span class="s1">);</span><span class="s0">return </span><span class="s1">a?e:(c(s),e?-t:t)}</span><span class="s0">const </span><span class="s1">m=h||</span><span class="s3">0</span><span class="s1">===h;</span><span class="s0">let </span><span class="s1">w,y,_;m&amp;&amp;(w=</span><span class="s0">new </span><span class="s1">Int32Array(</span><span class="s0">new </span><span class="s1">SharedArrayBuffer(</span><span class="s3">8208</span><span class="s1">)),Atomics.store(w,</span><span class="s3">0</span><span class="s1">,</span><span class="s3">0</span><span class="s1">));</span><span class="s0">const </span><span class="s1">g=</span><span class="s0">this</span><span class="s1">.PThread;</span><span class="s0">try</span><span class="s1">{</span><span class="s0">if</span><span class="s1">(y=g.getNewWorker(w),!y)</span><span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">&quot;failed to get new worker&quot;</span><span class="s1">);</span><span class="s0">if</span><span class="s1">(g.addMessageEventListener(y,f),_=g.markId(y),t&amp;&amp;y.ref(),y.postMessage(n(</span><span class="s2">&quot;start&quot;</span><span class="s1">,{tid:_,arg:r,sab:w})),m){</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">h){</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;timed-out&quot;</span><span class="s1">===Atomics.wait(w,</span><span class="s3">0</span><span class="s1">,</span><span class="s3">0</span><span class="s1">,h)){</span><span class="s0">try</span><span class="s1">{g.cleanThread(y,_,!</span><span class="s3">0</span><span class="s1">)}</span><span class="s0">catch</span><span class="s1">(e){}</span><span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Spawning thread timed out. Please check if the worker is created successfully and if message is handled properly in the worker.&quot;</span><span class="s1">)}}</span><span class="s0">else </span><span class="s1">Atomics.wait(w,</span><span class="s3">0</span><span class="s1">,</span><span class="s3">0</span><span class="s1">);</span><span class="s0">if</span><span class="s1">(Atomics.load(w,</span><span class="s3">0</span><span class="s1">)&gt;</span><span class="s3">1</span><span class="s1">){</span><span class="s0">try</span><span class="s1">{g.cleanThread(y,_,!</span><span class="s3">0</span><span class="s1">)}</span><span class="s0">catch</span><span class="s1">(e){}</span><span class="s0">throw function</span><span class="s1">(t){</span><span class="s0">var </span><span class="s1">r,s;</span><span class="s0">const </span><span class="s1">o=</span><span class="s0">new </span><span class="s1">Int32Array(t);</span><span class="s0">if</span><span class="s1">(Atomics.load(o,</span><span class="s3">0</span><span class="s1">)&lt;=</span><span class="s3">1</span><span class="s1">)</span><span class="s0">return null</span><span class="s1">;</span><span class="s0">const </span><span class="s1">n=Atomics.load(o,</span><span class="s3">1</span><span class="s1">),i=Atomics.load(o,</span><span class="s3">2</span><span class="s1">),a=Atomics.load(o,</span><span class="s3">3</span><span class="s1">),d=</span><span class="s0">new </span><span class="s1">Uint8Array(t),h=d.slice(</span><span class="s3">16</span><span class="s1">,</span><span class="s3">16</span><span class="s1">+n),l=d.slice(</span><span class="s3">16</span><span class="s1">+n,</span><span class="s3">16</span><span class="s1">+n+i),c=d.slice(</span><span class="s3">16</span><span class="s1">+n+i,</span><span class="s3">16</span><span class="s1">+n+i+a),u=(</span><span class="s0">new </span><span class="s1">TextDecoder).decode(h),f=(</span><span class="s0">new </span><span class="s1">TextDecoder).decode(l),p=(</span><span class="s0">new </span><span class="s1">TextDecoder).decode(c),m=</span><span class="s0">new</span><span class="s1">(</span><span class="s0">null</span><span class="s1">!==(r=globalThis[u])&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==r?r:</span><span class="s2">&quot;RuntimeError&quot;</span><span class="s1">===u&amp;&amp;</span><span class="s0">null</span><span class="s1">!==(s=e.RuntimeError)&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==s?s:Error)(f);</span><span class="s0">return </span><span class="s1">Object.defineProperty(m,</span><span class="s2">&quot;stack&quot;</span><span class="s1">,{value:p,writable:!</span><span class="s3">0</span><span class="s1">,enumerable:!</span><span class="s3">1</span><span class="s1">,configurable:!</span><span class="s3">0</span><span class="s1">}),m}(w.buffer)}}}</span><span class="s0">catch</span><span class="s1">(e){</span><span class="s0">return </span><span class="s1">Atomics.store(p,</span><span class="s3">0</span><span class="s1">,</span><span class="s3">1</span><span class="s1">),Atomics.store(p,</span><span class="s3">1</span><span class="s1">,</span><span class="s3">6</span><span class="s1">),Atomics.notify(p,</span><span class="s3">1</span><span class="s1">),</span><span class="s0">null</span><span class="s1">==g||g.printErr(e.stack),a?</span><span class="s3">1</span><span class="s1">:(c(s),-</span><span class="s3">6</span><span class="s1">)}</span><span class="s0">return </span><span class="s1">Atomics.store(p,</span><span class="s3">0</span><span class="s1">,</span><span class="s3">0</span><span class="s1">),Atomics.store(p,</span><span class="s3">1</span><span class="s1">,_),Atomics.notify(p,</span><span class="s3">1</span><span class="s1">),g.runningWorkers.push(y),m||y.whenLoaded.catch(e=&gt;{</span><span class="s0">throw delete </span><span class="s1">y.whenLoaded,g.cleanThread(y,_,!</span><span class="s3">0</span><span class="s1">),e}),a?</span><span class="s3">0</span><span class="s1">:(c(s),_)};</span><span class="s0">this</span><span class="s1">.threadSpawn=p}getImportObject(){</span><span class="s0">return</span><span class="s1">{wasi:{</span><span class="s2">&quot;thread-spawn&quot;</span><span class="s1">:</span><span class="s0">this</span><span class="s1">.threadSpawn}}}setup(e,t,r){</span><span class="s0">null</span><span class="s1">!=r||(r=e.exports.memory),</span><span class="s0">this</span><span class="s1">.wasmInstance=e,</span><span class="s0">this</span><span class="s1">.wasmMemory=r,</span><span class="s0">this</span><span class="s1">.PThread&amp;&amp;</span><span class="s0">this</span><span class="s1">.PThread.setup(t,r)}preloadWorkers(){</span><span class="s0">return this</span><span class="s1">.PThread?</span><span class="s0">this</span><span class="s1">.PThread.preloadWorkers():Promise.resolve([])}initialize(e,t,r){</span><span class="s0">const </span><span class="s1">s=e.exports;</span><span class="s0">null</span><span class="s1">!=r||(r=s.memory),</span><span class="s0">this</span><span class="s1">.childThread&amp;&amp;(e=l(e,r)),</span><span class="s0">this</span><span class="s1">.setup(e,t,r);</span><span class="s0">const </span><span class="s1">o=</span><span class="s0">this</span><span class="s1">.wasi;</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;_start&quot;</span><span class="s0">in </span><span class="s1">s&amp;&amp;</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">s._start)</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.childThread){o.start(e);</span><span class="s0">try</span><span class="s1">{o[u(o,</span><span class="s2">&quot;kStarted&quot;</span><span class="s1">)]=!</span><span class="s3">1</span><span class="s1">}</span><span class="s0">catch</span><span class="s1">(e){}}</span><span class="s0">else</span><span class="s1">!</span><span class="s0">function</span><span class="s1">(e,t){</span><span class="s0">const</span><span class="s1">[r,s]=u(e,[</span><span class="s2">&quot;kInstance&quot;</span><span class="s1">,</span><span class="s2">&quot;kSetMemory&quot;</span><span class="s1">]);e[r]=t,e[s](t.exports.memory)}(o,e);</span><span class="s0">else </span><span class="s1">o.initialize(e);</span><span class="s0">return </span><span class="s1">e}start(e,t,r){</span><span class="s0">const </span><span class="s1">s=e.exports;</span><span class="s0">null</span><span class="s1">!=r||(r=s.memory),</span><span class="s0">this</span><span class="s1">.childThread&amp;&amp;(e=l(e,r)),</span><span class="s0">this</span><span class="s1">.setup(e,t,r);</span><span class="s0">return</span><span class="s1">{exitCode:</span><span class="s0">this</span><span class="s1">.wasi.start(e),instance:e}}terminateAllThreads(){</span><span class="s0">var </span><span class="s1">e;</span><span class="s0">this</span><span class="s1">.childThread?</span><span class="s0">this</span><span class="s1">.postMessage(n(</span><span class="s2">&quot;terminate-all-threads&quot;</span><span class="s1">,{})):</span><span class="s0">null</span><span class="s1">===(e=</span><span class="s0">this</span><span class="s1">.PThread)||</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===e||e.terminateAllThreads()}},exports.createInstanceProxy=l,exports.isSharedArrayBuffer=s,exports.isTrapError=o;</span>
</pre>
</body>
</html>