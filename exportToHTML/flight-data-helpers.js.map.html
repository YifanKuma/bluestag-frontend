<html>
<head>
<title>flight-data-helpers.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
flight-data-helpers.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/client/flight-data-helpers.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">CacheNodeSeedData,</span><span class="s3">\n  </span><span class="s1">FlightData,</span><span class="s3">\n  </span><span class="s1">FlightDataPath,</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">FlightSegmentPath,</span><span class="s3">\n  </span><span class="s1">Segment,</span><span class="s3">\n</span><span class="s1">} from '../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import type { HeadData } from '../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { PAGE_SEGMENT_KEY } from '../shared/lib/segment'</span><span class="s3">\n\n</span><span class="s1">export type NormalizedFlightData = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The full `FlightSegmentPath` inclusive of the final `Segment`</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">segmentPath: FlightSegmentPath</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The `FlightSegmentPath` exclusive of the final `Segment`</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pathToSegment: FlightSegmentPath</span><span class="s3">\n  </span><span class="s1">segment: Segment</span><span class="s3">\n  </span><span class="s1">tree: FlightRouterState</span><span class="s3">\n  </span><span class="s1">seedData: CacheNodeSeedData | null</span><span class="s3">\n  </span><span class="s1">head: HeadData</span><span class="s3">\n  </span><span class="s1">isHeadPartial: boolean</span><span class="s3">\n  </span><span class="s1">isRootRender: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// TODO: We should only have to export `normalizeFlightData`, however because the initial flight data</span><span class="s3">\n</span><span class="s1">// that gets passed to `createInitialRouterState` doesn't conform to the `FlightDataPath` type (it's missing the root segment)</span><span class="s3">\n</span><span class="s1">// we're currently exporting it so we can use it directly. This should be fixed as part of the unification of</span><span class="s3">\n</span><span class="s1">// the different ways we express `FlightSegmentPath`.</span><span class="s3">\n</span><span class="s1">export function getFlightDataPartsFromPath(</span><span class="s3">\n  </span><span class="s1">flightDataPath: FlightDataPath</span><span class="s3">\n</span><span class="s1">): NormalizedFlightData {</span><span class="s3">\n  </span><span class="s1">// Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].</span><span class="s3">\n  </span><span class="s1">const flightDataPathLength = 4</span><span class="s3">\n  </span><span class="s1">// tree, seedData, and head are *always* the last three items in the `FlightDataPath`.</span><span class="s3">\n  </span><span class="s1">const [tree, seedData, head, isHeadPartial] =</span><span class="s3">\n    </span><span class="s1">flightDataPath.slice(-flightDataPathLength)</span><span class="s3">\n  </span><span class="s1">// The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.</span><span class="s3">\n  </span><span class="s1">const segmentPath = flightDataPath.slice(0, -flightDataPathLength)</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">// TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment (</span><span class="s3">\&quot;\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">// to the start of the segment path in some places which makes it hard to use solely the segment path.</span><span class="s3">\n    </span><span class="s1">// Look for </span><span class="s3">\&quot;</span><span class="s1">// TODO-APP: remove ''</span><span class="s3">\&quot; </span><span class="s1">in the codebase.</span><span class="s3">\n    </span><span class="s1">pathToSegment: segmentPath.slice(0, -1),</span><span class="s3">\n    </span><span class="s1">segmentPath,</span><span class="s3">\n    </span><span class="s1">// if the `FlightDataPath` corresponds with the root, there'll be no segment path,</span><span class="s3">\n    </span><span class="s1">// in which case we default to ''.</span><span class="s3">\n    </span><span class="s1">segment: segmentPath[segmentPath.length - 1] ?? '',</span><span class="s3">\n    </span><span class="s1">tree,</span><span class="s3">\n    </span><span class="s1">seedData,</span><span class="s3">\n    </span><span class="s1">head,</span><span class="s3">\n    </span><span class="s1">isHeadPartial,</span><span class="s3">\n    </span><span class="s1">isRootRender: flightDataPath.length === flightDataPathLength,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getNextFlightSegmentPath(</span><span class="s3">\n  </span><span class="s1">flightSegmentPath: FlightSegmentPath</span><span class="s3">\n</span><span class="s1">): FlightSegmentPath {</span><span class="s3">\n  </span><span class="s1">// Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items</span><span class="s3">\n  </span><span class="s1">// to get the next segment path.</span><span class="s3">\n  </span><span class="s1">return flightSegmentPath.slice(2)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function normalizeFlightData(</span><span class="s3">\n  </span><span class="s1">flightData: FlightData</span><span class="s3">\n</span><span class="s1">): NormalizedFlightData[] | string {</span><span class="s3">\n  </span><span class="s1">// FlightData can be a string when the server didn't respond with a proper flight response,</span><span class="s3">\n  </span><span class="s1">// or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.</span><span class="s3">\n  </span><span class="s1">if (typeof flightData === 'string') {</span><span class="s3">\n    </span><span class="s1">return flightData</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return flightData.map((flightDataPath) =&gt;</span><span class="s3">\n    </span><span class="s1">getFlightDataPartsFromPath(flightDataPath)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function is used to prepare the flight router state for the request.</span><span class="s3">\n </span><span class="s1">* It removes markers that are not needed by the server, and are purely used</span><span class="s3">\n </span><span class="s1">* for stashing state on the client.</span><span class="s3">\n </span><span class="s1">* @param flightRouterState - The flight router state to prepare.</span><span class="s3">\n </span><span class="s1">* @param isHmrRefresh - Whether this is an HMR refresh request.</span><span class="s3">\n </span><span class="s1">* @returns The prepared flight router state.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function prepareFlightRouterStateForRequest(</span><span class="s3">\n  </span><span class="s1">flightRouterState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">isHmrRefresh?: boolean</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">// HMR requests need the complete, unmodified state for proper functionality</span><span class="s3">\n  </span><span class="s1">if (isHmrRefresh) {</span><span class="s3">\n    </span><span class="s1">return encodeURIComponent(JSON.stringify(flightRouterState))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return encodeURIComponent(</span><span class="s3">\n    </span><span class="s1">JSON.stringify(stripClientOnlyDataFromFlightRouterState(flightRouterState))</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Recursively strips client-only data from FlightRouterState while preserving</span><span class="s3">\n </span><span class="s1">* server-needed information for proper rendering decisions.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function stripClientOnlyDataFromFlightRouterState(</span><span class="s3">\n  </span><span class="s1">flightRouterState: FlightRouterState</span><span class="s3">\n</span><span class="s1">): FlightRouterState {</span><span class="s3">\n  </span><span class="s1">const [</span><span class="s3">\n    </span><span class="s1">segment,</span><span class="s3">\n    </span><span class="s1">parallelRoutes,</span><span class="s3">\n    </span><span class="s1">_url, // Intentionally unused - URLs are client-only</span><span class="s3">\n    </span><span class="s1">refreshMarker,</span><span class="s3">\n    </span><span class="s1">isRootLayout,</span><span class="s3">\n    </span><span class="s1">hasLoadingBoundary,</span><span class="s3">\n  </span><span class="s1">] = flightRouterState</span><span class="s3">\n\n  </span><span class="s1">// __PAGE__ segments are always fetched from the server, so there's</span><span class="s3">\n  </span><span class="s1">// no need to send them up</span><span class="s3">\n  </span><span class="s1">const cleanedSegment = stripSearchParamsFromPageSegment(segment)</span><span class="s3">\n\n  </span><span class="s1">// Recursively process parallel routes</span><span class="s3">\n  </span><span class="s1">const cleanedParallelRoutes: { [key: string]: FlightRouterState } = {}</span><span class="s3">\n  </span><span class="s1">for (const [key, childState] of Object.entries(parallelRoutes)) {</span><span class="s3">\n    </span><span class="s1">cleanedParallelRoutes[key] =</span><span class="s3">\n      </span><span class="s1">stripClientOnlyDataFromFlightRouterState(childState)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const result: FlightRouterState = [</span><span class="s3">\n    </span><span class="s1">cleanedSegment,</span><span class="s3">\n    </span><span class="s1">cleanedParallelRoutes,</span><span class="s3">\n    </span><span class="s1">null, // URLs omitted - server reconstructs paths from segments</span><span class="s3">\n    </span><span class="s1">shouldPreserveRefreshMarker(refreshMarker) ? refreshMarker : null,</span><span class="s3">\n  </span><span class="s1">]</span><span class="s3">\n\n  </span><span class="s1">// Append optional fields if present</span><span class="s3">\n  </span><span class="s1">if (isRootLayout !== undefined) {</span><span class="s3">\n    </span><span class="s1">result[4] = isRootLayout</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (hasLoadingBoundary !== undefined) {</span><span class="s3">\n    </span><span class="s1">result[5] = hasLoadingBoundary</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return result</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Strips search parameters from __PAGE__ segments to prevent sensitive</span><span class="s3">\n </span><span class="s1">* client-side data from being sent to the server.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function stripSearchParamsFromPageSegment(segment: Segment): Segment {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">typeof segment === 'string' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">segment.startsWith(PAGE_SEGMENT_KEY + '?')</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return PAGE_SEGMENT_KEY</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return segment</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Determines whether the refresh marker should be sent to the server</span><span class="s3">\n </span><span class="s1">* Client-only markers like 'refresh' are stripped, while server-needed markers</span><span class="s3">\n </span><span class="s1">* like 'refetch' and 'inside-shared-layout' are preserved.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function shouldPreserveRefreshMarker(</span><span class="s3">\n  </span><span class="s1">refreshMarker: FlightRouterState[3]</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return Boolean(refreshMarker &amp;&amp; refreshMarker !== 'refresh')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;getFlightDataPartsFromPath&quot;</span><span class="s0">,</span><span class="s1">&quot;getNextFlightSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;prepareFlightRouterStateForRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;flightDataPath&quot;</span><span class="s0">,</span><span class="s1">&quot;flightDataPathLength&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;seedData&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;isHeadPartial&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;pathToSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootRender&quot;</span><span class="s0">,</span><span class="s1">&quot;flightSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;isHmrRefresh&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;stripClientOnlyDataFromFlightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;_url&quot;</span><span class="s0">,</span><span class="s1">&quot;refreshMarker&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;hasLoadingBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanedSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;stripSearchParamsFromPageSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanedParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;childState&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldPreserveRefreshMarker&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;PAGE_SEGMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;IAgCgBA,0BAA0B;eAA1BA;;IA4BAC,wBAAwB;eAAxBA;;IAQAC,mBAAmB;eAAnBA;;IAsBAC,kCAAkC;eAAlCA;;;yBAjFiB;AAuB1B,SAASH,2BACdI,cAA8B;IAE9B,wGAAwG;IACxG,MAAMC,uBAAuB;IAC7B,sFAAsF;IACtF,MAAM,CAACC,MAAMC,UAAUC,MAAMC,cAAc,GACzCL,eAAeM,KAAK,CAAC,CAACL;IACxB,6GAA6G;IAC7G,MAAMM,cAAcP,eAAeM,KAAK,CAAC,GAAG,CAACL;QAUlCM;IARX,OAAO;QACL,kGAAkG;QAClG,sGAAsG;QACtG,qDAAqD;QACrDC,eAAeD,YAAYD,KAAK,CAAC,GAAG,CAAC;QACrCC;QACA,kFAAkF;QAClF,kCAAkC;QAClCE,SAASF,CAAAA,gBAAAA,WAAW,CAACA,YAAYG,MAAM,GAAG,EAAE,YAAnCH,gBAAuC;QAChDL;QACAC;QACAC;QACAC;QACAM,cAAcX,eAAeU,MAAM,KAAKT;IAC1C;AACF;AAEO,SAASJ,yBACde,iBAAoC;IAEpC,4GAA4G;IAC5G,gCAAgC;IAChC,OAAOA,kBAAkBN,KAAK,CAAC;AACjC;AAEO,SAASR,oBACde,UAAsB;IAEtB,2FAA2F;IAC3F,kGAAkG;IAClG,IAAI,OAAOA,eAAe,UAAU;QAClC,OAAOA;IACT;IAEA,OAAOA,WAAWC,GAAG,CAAC,CAACd,iBACrBJ,2BAA2BI;AAE/B;AAUO,SAASD,mCACdgB,iBAAoC,EACpCC,YAAsB;IAEtB,4EAA4E;IAC5E,IAAIA,cAAc;QAChB,OAAOC,mBAAmBC,KAAKC,SAAS,CAACJ;IAC3C;IAEA,OAAOE,mBACLC,KAAKC,SAAS,CAACC,yCAAyCL;AAE5D;AAEA;;;CAGC,GACD,SAASK,yCACPL,iBAAoC;IAEpC,MAAM,CACJN,SACAY,gBACAC,MACAC,eACAC,cACAC,mBACD,GAAGV;IAEJ,mEAAmE;IACnE,0BAA0B;IAC1B,MAAMW,iBAAiBC,iCAAiClB;IAExD,sCAAsC;IACtC,MAAMmB,wBAA8D,CAAC;IACrE,KAAK,MAAM,CAACC,KAAKC,WAAW,IAAIC,OAAOC,OAAO,CAACX,gBAAiB;QAC9DO,qBAAqB,CAACC,IAAI,GACxBT,yCAAyCU;IAC7C;IAEA,MAAMG,SAA4B;QAChCP;QACAE;QACA;QACAM,4BAA4BX,iBAAiBA,gBAAgB;KAC9D;IAED,oCAAoC;IACpC,IAAIC,iBAAiBW,WAAW;QAC9BF,MAAM,CAAC,EAAE,GAAGT;IACd;IACA,IAAIC,uBAAuBU,WAAW;QACpCF,MAAM,CAAC,EAAE,GAAGR;IACd;IAEA,OAAOQ;AACT;AAEA;;;CAGC,GACD,SAASN,iCAAiClB,OAAgB;IACxD,IACE,OAAOA,YAAY,YACnBA,QAAQ2B,UAAU,CAACC,yBAAgB,GAAG,MACtC;QACA,OAAOA,yBAAgB;IACzB;IACA,OAAO5B;AACT;AAEA;;;;CAIC,GACD,SAASyB,4BACPX,aAAmC;IAEnC,OAAOe,QAAQf,iBAAiBA,kBAAkB;AACpD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>