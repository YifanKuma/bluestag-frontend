<html>
<head>
<title>key-spacing.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #1750eb;}
.s6 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
key-spacing.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">Rule to specify spacing of object literal keys and values</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Brandon Mills</span>
 <span class="s0">* </span><span class="s1">@deprecated </span><span class="s0">in ESLint v8.53.0</span>
 <span class="s0">*/</span>
<span class="s3">&quot;use strict&quot;</span><span class="s2">;</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Requirements</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s4">const </span><span class="s2">astUtils = require(</span><span class="s3">&quot;./utils/ast-utils&quot;</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">{ getGraphemeCount } = require(</span><span class="s3">&quot;../shared/string-utils&quot;</span><span class="s2">);</span>

<span class="s0">/**</span>
 <span class="s0">* Checks whether a string contains a line terminator as defined in</span>
 <span class="s0">* http://www.ecma-international.org/ecma-262/5.1/#sec-7.3</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} str String to test.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if str contains a line terminator.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">containsLineTerminator(str) {</span>
	<span class="s4">return </span><span class="s2">astUtils.LINEBREAK_MATCHER.test(str);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Gets the last element of an array.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array} arr An array.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{any} Last element of arr.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">last(arr) {</span>
	<span class="s4">return </span><span class="s2">arr.at(-</span><span class="s5">1</span><span class="s2">);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Checks whether a node is contained on a single line.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node AST Node being evaluated.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the node is a single line.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isSingleLine(node) {</span>
	<span class="s4">return </span><span class="s2">node.loc.end.line === node.loc.start.line;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Checks whether the properties on a single line.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode[]} properties List of Property AST nodes.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if all properties is on a single line.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isSingleLineProperties(properties) {</span>
	<span class="s4">const </span><span class="s2">[firstProp] = properties,</span>
		<span class="s2">lastProp = last(properties);</span>

	<span class="s4">return </span><span class="s2">firstProp.loc.start.line === lastProp.loc.end.line;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Initializes a single option property from the configuration with defaults for undefined values</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} toOptions Object to be initialized</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} fromOptions Object to be initialized from</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Object} The object with correctly initialized options and values</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">initOptionProperty(toOptions, fromOptions) {</span>
	<span class="s2">toOptions.mode = fromOptions.mode || </span><span class="s3">&quot;strict&quot;</span><span class="s2">;</span>

	<span class="s0">// Set value of beforeColon</span>
	<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">fromOptions.beforeColon !== </span><span class="s3">&quot;undefined&quot;</span><span class="s2">) {</span>
		<span class="s2">toOptions.beforeColon = +fromOptions.beforeColon;</span>
	<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
		<span class="s2">toOptions.beforeColon = </span><span class="s5">0</span><span class="s2">;</span>
	<span class="s2">}</span>

	<span class="s0">// Set value of afterColon</span>
	<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">fromOptions.afterColon !== </span><span class="s3">&quot;undefined&quot;</span><span class="s2">) {</span>
		<span class="s2">toOptions.afterColon = +fromOptions.afterColon;</span>
	<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
		<span class="s2">toOptions.afterColon = </span><span class="s5">1</span><span class="s2">;</span>
	<span class="s2">}</span>

	<span class="s0">// Set align if exists</span>
	<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">fromOptions.align !== </span><span class="s3">&quot;undefined&quot;</span><span class="s2">) {</span>
		<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">fromOptions.align === </span><span class="s3">&quot;object&quot;</span><span class="s2">) {</span>
			<span class="s2">toOptions.align = fromOptions.align;</span>
		<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
			<span class="s0">// &quot;string&quot;</span>
			<span class="s2">toOptions.align = {</span>
				<span class="s2">on: fromOptions.align,</span>
				<span class="s2">mode: toOptions.mode,</span>
				<span class="s2">beforeColon: toOptions.beforeColon,</span>
				<span class="s2">afterColon: toOptions.afterColon,</span>
			<span class="s2">};</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s4">return </span><span class="s2">toOptions;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Initializes all the option values (singleLine, multiLine and align) from the configuration with defaults for undefined values</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} toOptions Object to be initialized</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} fromOptions Object to be initialized from</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Object} The object with correctly initialized options and values</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">initOptions(toOptions, fromOptions) {</span>
	<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">fromOptions.align === </span><span class="s3">&quot;object&quot;</span><span class="s2">) {</span>
		<span class="s0">// Initialize the alignment configuration</span>
		<span class="s2">toOptions.align = initOptionProperty({}, fromOptions.align);</span>
		<span class="s2">toOptions.align.on = fromOptions.align.on || </span><span class="s3">&quot;colon&quot;</span><span class="s2">;</span>
		<span class="s2">toOptions.align.mode = fromOptions.align.mode || </span><span class="s3">&quot;strict&quot;</span><span class="s2">;</span>

		<span class="s2">toOptions.multiLine = initOptionProperty(</span>
			<span class="s2">{},</span>
			<span class="s2">fromOptions.multiLine || fromOptions,</span>
		<span class="s2">);</span>
		<span class="s2">toOptions.singleLine = initOptionProperty(</span>
			<span class="s2">{},</span>
			<span class="s2">fromOptions.singleLine || fromOptions,</span>
		<span class="s2">);</span>
	<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
		<span class="s0">// string or undefined</span>
		<span class="s2">toOptions.multiLine = initOptionProperty(</span>
			<span class="s2">{},</span>
			<span class="s2">fromOptions.multiLine || fromOptions,</span>
		<span class="s2">);</span>
		<span class="s2">toOptions.singleLine = initOptionProperty(</span>
			<span class="s2">{},</span>
			<span class="s2">fromOptions.singleLine || fromOptions,</span>
		<span class="s2">);</span>

		<span class="s0">// If alignment options are defined in multiLine, pull them out into the general align configuration</span>
		<span class="s4">if </span><span class="s2">(toOptions.multiLine.align) {</span>
			<span class="s2">toOptions.align = {</span>
				<span class="s2">on: toOptions.multiLine.align.on,</span>
				<span class="s2">mode:</span>
					<span class="s2">toOptions.multiLine.align.mode || toOptions.multiLine.mode,</span>
				<span class="s2">beforeColon: toOptions.multiLine.align.beforeColon,</span>
				<span class="s2">afterColon: toOptions.multiLine.align.afterColon,</span>
			<span class="s2">};</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s4">return </span><span class="s2">toOptions;</span>
<span class="s2">}</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Rule Definition</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{import('../types').Rule.RuleModule} */</span>
<span class="s2">module.exports = {</span>
	<span class="s2">meta: {</span>
		<span class="s2">deprecated: {</span>
			<span class="s2">message: </span><span class="s3">&quot;Formatting rules are being moved out of ESLint core.&quot;</span><span class="s2">,</span>
			<span class="s2">url: </span><span class="s3">&quot;https://eslint.org/blog/2023/10/deprecating-formatting-rules/&quot;</span><span class="s2">,</span>
			<span class="s2">deprecatedSince: </span><span class="s3">&quot;8.53.0&quot;</span><span class="s2">,</span>
			<span class="s2">availableUntil: </span><span class="s3">&quot;10.0.0&quot;</span><span class="s2">,</span>
			<span class="s2">replacedBy: [</span>
				<span class="s2">{</span>
					<span class="s2">message:</span>
						<span class="s3">&quot;ESLint Stylistic now maintains deprecated stylistic core rules.&quot;</span><span class="s2">,</span>
					<span class="s2">url: </span><span class="s3">&quot;https://eslint.style/guide/migration&quot;</span><span class="s2">,</span>
					<span class="s2">plugin: {</span>
						<span class="s2">name: </span><span class="s3">&quot;@stylistic/eslint-plugin&quot;</span><span class="s2">,</span>
						<span class="s2">url: </span><span class="s3">&quot;https://eslint.style&quot;</span><span class="s2">,</span>
					<span class="s2">},</span>
					<span class="s2">rule: {</span>
						<span class="s2">name: </span><span class="s3">&quot;key-spacing&quot;</span><span class="s2">,</span>
						<span class="s2">url: </span><span class="s3">&quot;https://eslint.style/rules/key-spacing&quot;</span><span class="s2">,</span>
					<span class="s2">},</span>
				<span class="s2">},</span>
			<span class="s2">],</span>
		<span class="s2">},</span>
		<span class="s2">type: </span><span class="s3">&quot;layout&quot;</span><span class="s2">,</span>

		<span class="s2">docs: {</span>
			<span class="s2">description:</span>
				<span class="s3">&quot;Enforce consistent spacing between keys and values in object literal properties&quot;</span><span class="s2">,</span>
			<span class="s2">recommended: </span><span class="s4">false</span><span class="s2">,</span>
			<span class="s2">url: </span><span class="s3">&quot;https://eslint.org/docs/latest/rules/key-spacing&quot;</span><span class="s2">,</span>
		<span class="s2">},</span>

		<span class="s2">fixable: </span><span class="s3">&quot;whitespace&quot;</span><span class="s2">,</span>

		<span class="s2">schema: [</span>
			<span class="s2">{</span>
				<span class="s2">anyOf: [</span>
					<span class="s2">{</span>
						<span class="s2">type: </span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
						<span class="s2">properties: {</span>
							<span class="s2">align: {</span>
								<span class="s2">anyOf: [</span>
									<span class="s2">{</span>
										<span class="s4">enum</span><span class="s2">: [</span><span class="s3">&quot;colon&quot;</span><span class="s2">, </span><span class="s3">&quot;value&quot;</span><span class="s2">],</span>
									<span class="s2">},</span>
									<span class="s2">{</span>
										<span class="s2">type: </span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
										<span class="s2">properties: {</span>
											<span class="s2">mode: {</span>
												<span class="s4">enum</span><span class="s2">: [</span><span class="s3">&quot;strict&quot;</span><span class="s2">, </span><span class="s3">&quot;minimum&quot;</span><span class="s2">],</span>
											<span class="s2">},</span>
											<span class="s2">on: {</span>
												<span class="s4">enum</span><span class="s2">: [</span><span class="s3">&quot;colon&quot;</span><span class="s2">, </span><span class="s3">&quot;value&quot;</span><span class="s2">],</span>
											<span class="s2">},</span>
											<span class="s2">beforeColon: {</span>
												<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
											<span class="s2">},</span>
											<span class="s2">afterColon: {</span>
												<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
											<span class="s2">},</span>
										<span class="s2">},</span>
										<span class="s2">additionalProperties: </span><span class="s4">false</span><span class="s2">,</span>
									<span class="s2">},</span>
								<span class="s2">],</span>
							<span class="s2">},</span>
							<span class="s2">mode: {</span>
								<span class="s4">enum</span><span class="s2">: [</span><span class="s3">&quot;strict&quot;</span><span class="s2">, </span><span class="s3">&quot;minimum&quot;</span><span class="s2">],</span>
							<span class="s2">},</span>
							<span class="s2">beforeColon: {</span>
								<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
							<span class="s2">},</span>
							<span class="s2">afterColon: {</span>
								<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
							<span class="s2">},</span>
						<span class="s2">},</span>
						<span class="s2">additionalProperties: </span><span class="s4">false</span><span class="s2">,</span>
					<span class="s2">},</span>
					<span class="s2">{</span>
						<span class="s2">type: </span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
						<span class="s2">properties: {</span>
							<span class="s2">singleLine: {</span>
								<span class="s2">type: </span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
								<span class="s2">properties: {</span>
									<span class="s2">mode: {</span>
										<span class="s4">enum</span><span class="s2">: [</span><span class="s3">&quot;strict&quot;</span><span class="s2">, </span><span class="s3">&quot;minimum&quot;</span><span class="s2">],</span>
									<span class="s2">},</span>
									<span class="s2">beforeColon: {</span>
										<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
									<span class="s2">},</span>
									<span class="s2">afterColon: {</span>
										<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
									<span class="s2">},</span>
								<span class="s2">},</span>
								<span class="s2">additionalProperties: </span><span class="s4">false</span><span class="s2">,</span>
							<span class="s2">},</span>
							<span class="s2">multiLine: {</span>
								<span class="s2">type: </span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
								<span class="s2">properties: {</span>
									<span class="s2">align: {</span>
										<span class="s2">anyOf: [</span>
											<span class="s2">{</span>
												<span class="s4">enum</span><span class="s2">: [</span><span class="s3">&quot;colon&quot;</span><span class="s2">, </span><span class="s3">&quot;value&quot;</span><span class="s2">],</span>
											<span class="s2">},</span>
											<span class="s2">{</span>
												<span class="s2">type: </span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
												<span class="s2">properties: {</span>
													<span class="s2">mode: {</span>
														<span class="s4">enum</span><span class="s2">: [</span>
															<span class="s3">&quot;strict&quot;</span><span class="s2">,</span>
															<span class="s3">&quot;minimum&quot;</span><span class="s2">,</span>
														<span class="s2">],</span>
													<span class="s2">},</span>
													<span class="s2">on: {</span>
														<span class="s4">enum</span><span class="s2">: [</span>
															<span class="s3">&quot;colon&quot;</span><span class="s2">,</span>
															<span class="s3">&quot;value&quot;</span><span class="s2">,</span>
														<span class="s2">],</span>
													<span class="s2">},</span>
													<span class="s2">beforeColon: {</span>
														<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
													<span class="s2">},</span>
													<span class="s2">afterColon: {</span>
														<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
													<span class="s2">},</span>
												<span class="s2">},</span>
												<span class="s2">additionalProperties: </span><span class="s4">false</span><span class="s2">,</span>
											<span class="s2">},</span>
										<span class="s2">],</span>
									<span class="s2">},</span>
									<span class="s2">mode: {</span>
										<span class="s4">enum</span><span class="s2">: [</span><span class="s3">&quot;strict&quot;</span><span class="s2">, </span><span class="s3">&quot;minimum&quot;</span><span class="s2">],</span>
									<span class="s2">},</span>
									<span class="s2">beforeColon: {</span>
										<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
									<span class="s2">},</span>
									<span class="s2">afterColon: {</span>
										<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
									<span class="s2">},</span>
								<span class="s2">},</span>
								<span class="s2">additionalProperties: </span><span class="s4">false</span><span class="s2">,</span>
							<span class="s2">},</span>
						<span class="s2">},</span>
						<span class="s2">additionalProperties: </span><span class="s4">false</span><span class="s2">,</span>
					<span class="s2">},</span>
					<span class="s2">{</span>
						<span class="s2">type: </span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
						<span class="s2">properties: {</span>
							<span class="s2">singleLine: {</span>
								<span class="s2">type: </span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
								<span class="s2">properties: {</span>
									<span class="s2">mode: {</span>
										<span class="s4">enum</span><span class="s2">: [</span><span class="s3">&quot;strict&quot;</span><span class="s2">, </span><span class="s3">&quot;minimum&quot;</span><span class="s2">],</span>
									<span class="s2">},</span>
									<span class="s2">beforeColon: {</span>
										<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
									<span class="s2">},</span>
									<span class="s2">afterColon: {</span>
										<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
									<span class="s2">},</span>
								<span class="s2">},</span>
								<span class="s2">additionalProperties: </span><span class="s4">false</span><span class="s2">,</span>
							<span class="s2">},</span>
							<span class="s2">multiLine: {</span>
								<span class="s2">type: </span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
								<span class="s2">properties: {</span>
									<span class="s2">mode: {</span>
										<span class="s4">enum</span><span class="s2">: [</span><span class="s3">&quot;strict&quot;</span><span class="s2">, </span><span class="s3">&quot;minimum&quot;</span><span class="s2">],</span>
									<span class="s2">},</span>
									<span class="s2">beforeColon: {</span>
										<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
									<span class="s2">},</span>
									<span class="s2">afterColon: {</span>
										<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
									<span class="s2">},</span>
								<span class="s2">},</span>
								<span class="s2">additionalProperties: </span><span class="s4">false</span><span class="s2">,</span>
							<span class="s2">},</span>
							<span class="s2">align: {</span>
								<span class="s2">type: </span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
								<span class="s2">properties: {</span>
									<span class="s2">mode: {</span>
										<span class="s4">enum</span><span class="s2">: [</span><span class="s3">&quot;strict&quot;</span><span class="s2">, </span><span class="s3">&quot;minimum&quot;</span><span class="s2">],</span>
									<span class="s2">},</span>
									<span class="s2">on: {</span>
										<span class="s4">enum</span><span class="s2">: [</span><span class="s3">&quot;colon&quot;</span><span class="s2">, </span><span class="s3">&quot;value&quot;</span><span class="s2">],</span>
									<span class="s2">},</span>
									<span class="s2">beforeColon: {</span>
										<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
									<span class="s2">},</span>
									<span class="s2">afterColon: {</span>
										<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
									<span class="s2">},</span>
								<span class="s2">},</span>
								<span class="s2">additionalProperties: </span><span class="s4">false</span><span class="s2">,</span>
							<span class="s2">},</span>
						<span class="s2">},</span>
						<span class="s2">additionalProperties: </span><span class="s4">false</span><span class="s2">,</span>
					<span class="s2">},</span>
				<span class="s2">],</span>
			<span class="s2">},</span>
		<span class="s2">],</span>
		<span class="s2">messages: {</span>
			<span class="s2">extraKey: </span><span class="s3">&quot;Extra space after {{computed}}key '{{key}}'.&quot;</span><span class="s2">,</span>
			<span class="s2">extraValue:</span>
				<span class="s3">&quot;Extra space before value for {{computed}}key '{{key}}'.&quot;</span><span class="s2">,</span>
			<span class="s2">missingKey: </span><span class="s3">&quot;Missing space after {{computed}}key '{{key}}'.&quot;</span><span class="s2">,</span>
			<span class="s2">missingValue:</span>
				<span class="s3">&quot;Missing space before value for {{computed}}key '{{key}}'.&quot;</span><span class="s2">,</span>
		<span class="s2">},</span>
	<span class="s2">},</span>

	<span class="s2">create(context) {</span>
		<span class="s0">/**</span>
		 <span class="s0">* OPTIONS</span>
		 <span class="s0">* &quot;key-spacing&quot;: [2, {</span>
		 <span class="s0">*     beforeColon: false,</span>
		 <span class="s0">*     afterColon: true,</span>
		 <span class="s0">*     align: &quot;colon&quot; // Optional, or &quot;value&quot;</span>
		 <span class="s0">* }</span>
		 <span class="s0">*/</span>
		<span class="s4">const </span><span class="s2">options = context.options[</span><span class="s5">0</span><span class="s2">] || {},</span>
			<span class="s2">ruleOptions = initOptions({}, options),</span>
			<span class="s2">multiLineOptions = ruleOptions.multiLine,</span>
			<span class="s2">singleLineOptions = ruleOptions.singleLine,</span>
			<span class="s2">alignmentOptions = ruleOptions.align || </span><span class="s4">null</span><span class="s2">;</span>

		<span class="s4">const </span><span class="s2">sourceCode = context.sourceCode;</span>

		<span class="s0">/**</span>
		 <span class="s0">* Determines if the given property is key-value property.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} property Property node to check.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} Whether the property is a key-value property.</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">isKeyValueProperty(property) {</span>
			<span class="s4">return </span><span class="s2">!(</span>
				<span class="s2">(</span>
					<span class="s2">property.method ||</span>
					<span class="s2">property.shorthand ||</span>
					<span class="s2">property.kind !== </span><span class="s3">&quot;init&quot; </span><span class="s2">||</span>
					<span class="s2">property.type !== </span><span class="s3">&quot;Property&quot;</span>
				<span class="s2">) </span><span class="s0">// Could be &quot;ExperimentalSpreadProperty&quot; or &quot;SpreadElement&quot;</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Starting from the given node (a property.key node here) looks forward</span>
		 <span class="s0">* until it finds the colon punctuator and returns it.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to start looking from.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ASTNode} The colon punctuator.</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">getNextColon(node) {</span>
			<span class="s4">return </span><span class="s2">sourceCode.getTokenAfter(node, astUtils.isColonToken);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Starting from the given node (a property.key node here) looks forward</span>
		 <span class="s0">* until it finds the last token before a colon punctuator and returns it.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to start looking from.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ASTNode} The last token before a colon punctuator.</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">getLastTokenBeforeColon(node) {</span>
			<span class="s4">const </span><span class="s2">colonToken = getNextColon(node);</span>

			<span class="s4">return </span><span class="s2">sourceCode.getTokenBefore(colonToken);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Starting from the given node (a property.key node here) looks forward</span>
		 <span class="s0">* until it finds the first token after a colon punctuator and returns it.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to start looking from.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ASTNode} The first token after a colon punctuator.</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">getFirstTokenAfterColon(node) {</span>
			<span class="s4">const </span><span class="s2">colonToken = getNextColon(node);</span>

			<span class="s4">return </span><span class="s2">sourceCode.getTokenAfter(colonToken);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Checks whether a property is a member of the property group it follows.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} lastMember The last Property known to be in the group.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} candidate The next Property that might be in the group.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the candidate property is part of the group.</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">continuesPropertyGroup(lastMember, candidate) {</span>
			<span class="s4">const </span><span class="s2">groupEndLine = lastMember.loc.start.line,</span>
				<span class="s2">candidateValueStartLine = (</span>
					<span class="s2">isKeyValueProperty(candidate)</span>
						<span class="s2">? getFirstTokenAfterColon(candidate.key)</span>
						<span class="s2">: candidate</span>
				<span class="s2">).loc.start.line;</span>

			<span class="s4">if </span><span class="s2">(candidateValueStartLine - groupEndLine &lt;= </span><span class="s5">1</span><span class="s2">) {</span>
				<span class="s4">return true</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s0">/* 
             * Check that the first comment is adjacent to the end of the group, the 
             * last comment is adjacent to the candidate property, and that successive 
             * comments are adjacent to each other. 
             */</span>
			<span class="s4">const </span><span class="s2">leadingComments = sourceCode.getCommentsBefore(candidate);</span>

			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">leadingComments.length &amp;&amp;</span>
				<span class="s2">leadingComments[</span><span class="s5">0</span><span class="s2">].loc.start.line - groupEndLine &lt;= </span><span class="s5">1 </span><span class="s2">&amp;&amp;</span>
				<span class="s2">candidateValueStartLine - last(leadingComments).loc.end.line &lt;=</span>
					<span class="s5">1</span>
			<span class="s2">) {</span>
				<span class="s4">for </span><span class="s2">(</span><span class="s4">let </span><span class="s2">i = </span><span class="s5">1</span><span class="s2">; i &lt; leadingComments.length; i++) {</span>
					<span class="s4">if </span><span class="s2">(</span>
						<span class="s2">leadingComments[i].loc.start.line -</span>
							<span class="s2">leadingComments[i - </span><span class="s5">1</span><span class="s2">].loc.end.line &gt;</span>
						<span class="s5">1</span>
					<span class="s2">) {</span>
						<span class="s4">return false</span><span class="s2">;</span>
					<span class="s2">}</span>
				<span class="s2">}</span>
				<span class="s4">return true</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s4">return false</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Gets an object literal property's key as the identifier name or string value.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} property Property node whose key to retrieve.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string} The property's key.</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">getKey(property) {</span>
			<span class="s4">const </span><span class="s2">key = property.key;</span>

			<span class="s4">if </span><span class="s2">(property.computed) {</span>
				<span class="s4">return </span><span class="s2">sourceCode.getText().slice(key.range[</span><span class="s5">0</span><span class="s2">], key.range[</span><span class="s5">1</span><span class="s2">]);</span>
			<span class="s2">}</span>
			<span class="s4">return </span><span class="s2">astUtils.getStaticPropertyName(property);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports an appropriately-formatted error if spacing is incorrect on one</span>
		 <span class="s0">* side of the colon.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} property Key-value pair in an object literal.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} side Side being verified - either &quot;key&quot; or &quot;value&quot;.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} whitespace Actual whitespace string.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} expected Expected whitespace length.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} mode Value of the mode as &quot;strict&quot; or &quot;minimum&quot;</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">report(property, side, whitespace, expected, mode) {</span>
			<span class="s4">const </span><span class="s2">diff = whitespace.length - expected;</span>

			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">((diff &amp;&amp; mode === </span><span class="s3">&quot;strict&quot;</span><span class="s2">) ||</span>
					<span class="s2">(diff &lt; </span><span class="s5">0 </span><span class="s2">&amp;&amp; mode === </span><span class="s3">&quot;minimum&quot;</span><span class="s2">) ||</span>
					<span class="s2">(diff &gt; </span><span class="s5">0 </span><span class="s2">&amp;&amp; !expected &amp;&amp; mode === </span><span class="s3">&quot;minimum&quot;</span><span class="s2">)) &amp;&amp;</span>
				<span class="s2">!(expected &amp;&amp; containsLineTerminator(whitespace))</span>
			<span class="s2">) {</span>
				<span class="s4">const </span><span class="s2">nextColon = getNextColon(property.key),</span>
					<span class="s2">tokenBeforeColon = sourceCode.getTokenBefore(nextColon, {</span>
						<span class="s2">includeComments: </span><span class="s4">true</span><span class="s2">,</span>
					<span class="s2">}),</span>
					<span class="s2">tokenAfterColon = sourceCode.getTokenAfter(nextColon, {</span>
						<span class="s2">includeComments: </span><span class="s4">true</span><span class="s2">,</span>
					<span class="s2">}),</span>
					<span class="s2">isKeySide = side === </span><span class="s3">&quot;key&quot;</span><span class="s2">,</span>
					<span class="s2">isExtra = diff &gt; </span><span class="s5">0</span><span class="s2">,</span>
					<span class="s2">diffAbs = Math.abs(diff),</span>
					<span class="s2">spaces = Array(diffAbs + </span><span class="s5">1</span><span class="s2">).join(</span><span class="s3">&quot; &quot;</span><span class="s2">);</span>

				<span class="s4">const </span><span class="s2">locStart = isKeySide</span>
					<span class="s2">? tokenBeforeColon.loc.end</span>
					<span class="s2">: nextColon.loc.start;</span>
				<span class="s4">const </span><span class="s2">locEnd = isKeySide</span>
					<span class="s2">? nextColon.loc.start</span>
					<span class="s2">: tokenAfterColon.loc.start;</span>
				<span class="s4">const </span><span class="s2">missingLoc = isKeySide</span>
					<span class="s2">? tokenBeforeColon.loc</span>
					<span class="s2">: tokenAfterColon.loc;</span>
				<span class="s4">const </span><span class="s2">loc = isExtra</span>
					<span class="s2">? { start: locStart, end: locEnd }</span>
					<span class="s2">: missingLoc;</span>

				<span class="s4">let </span><span class="s2">fix;</span>

				<span class="s4">if </span><span class="s2">(isExtra) {</span>
					<span class="s4">let </span><span class="s2">range;</span>

					<span class="s0">// Remove whitespace</span>
					<span class="s4">if </span><span class="s2">(isKeySide) {</span>
						<span class="s2">range = [</span>
							<span class="s2">tokenBeforeColon.range[</span><span class="s5">1</span><span class="s2">],</span>
							<span class="s2">tokenBeforeColon.range[</span><span class="s5">1</span><span class="s2">] + diffAbs,</span>
						<span class="s2">];</span>
					<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
						<span class="s2">range = [</span>
							<span class="s2">tokenAfterColon.range[</span><span class="s5">0</span><span class="s2">] - diffAbs,</span>
							<span class="s2">tokenAfterColon.range[</span><span class="s5">0</span><span class="s2">],</span>
						<span class="s2">];</span>
					<span class="s2">}</span>
					<span class="s2">fix = </span><span class="s4">function </span><span class="s2">(fixer) {</span>
						<span class="s4">return </span><span class="s2">fixer.removeRange(range);</span>
					<span class="s2">};</span>
				<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
					<span class="s0">// Add whitespace</span>
					<span class="s4">if </span><span class="s2">(isKeySide) {</span>
						<span class="s2">fix = </span><span class="s4">function </span><span class="s2">(fixer) {</span>
							<span class="s4">return </span><span class="s2">fixer.insertTextAfter(</span>
								<span class="s2">tokenBeforeColon,</span>
								<span class="s2">spaces,</span>
							<span class="s2">);</span>
						<span class="s2">};</span>
					<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
						<span class="s2">fix = </span><span class="s4">function </span><span class="s2">(fixer) {</span>
							<span class="s4">return </span><span class="s2">fixer.insertTextBefore(</span>
								<span class="s2">tokenAfterColon,</span>
								<span class="s2">spaces,</span>
							<span class="s2">);</span>
						<span class="s2">};</span>
					<span class="s2">}</span>
				<span class="s2">}</span>

				<span class="s4">let </span><span class="s2">messageId;</span>

				<span class="s4">if </span><span class="s2">(isExtra) {</span>
					<span class="s2">messageId = side === </span><span class="s3">&quot;key&quot; </span><span class="s2">? </span><span class="s3">&quot;extraKey&quot; </span><span class="s2">: </span><span class="s3">&quot;extraValue&quot;</span><span class="s2">;</span>
				<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
					<span class="s2">messageId = side === </span><span class="s3">&quot;key&quot; </span><span class="s2">? </span><span class="s3">&quot;missingKey&quot; </span><span class="s2">: </span><span class="s3">&quot;missingValue&quot;</span><span class="s2">;</span>
				<span class="s2">}</span>

				<span class="s2">context.report({</span>
					<span class="s2">node: property[side],</span>
					<span class="s2">loc,</span>
					<span class="s2">messageId,</span>
					<span class="s2">data: {</span>
						<span class="s2">computed: property.computed ? </span><span class="s3">&quot;computed &quot; </span><span class="s2">: </span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
						<span class="s2">key: getKey(property),</span>
					<span class="s2">},</span>
					<span class="s2">fix,</span>
				<span class="s2">});</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Gets the number of characters in a key, including quotes around string</span>
		 <span class="s0">* keys and braces around computed property keys.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} property Property of on object literal.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{number} Width of the key.</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">getKeyWidth(property) {</span>
			<span class="s4">const </span><span class="s2">startToken = sourceCode.getFirstToken(property);</span>
			<span class="s4">const </span><span class="s2">endToken = getLastTokenBeforeColon(property.key);</span>

			<span class="s4">return </span><span class="s2">getGraphemeCount(</span>
				<span class="s2">sourceCode</span>
					<span class="s2">.getText()</span>
					<span class="s2">.slice(startToken.range[</span><span class="s5">0</span><span class="s2">], endToken.range[</span><span class="s5">1</span><span class="s2">]),</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Gets the whitespace around the colon in an object literal property.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} property Property node from an object literal.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Object} Whitespace before and after the property's colon.</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">getPropertyWhitespace(property) {</span>
			<span class="s4">const </span><span class="s2">whitespace = </span><span class="s6">/(\s*):(\s*)/u</span><span class="s2">.exec(</span>
				<span class="s2">sourceCode</span>
					<span class="s2">.getText()</span>
					<span class="s2">.slice(property.key.range[</span><span class="s5">1</span><span class="s2">], property.value.range[</span><span class="s5">0</span><span class="s2">]),</span>
			<span class="s2">);</span>

			<span class="s4">if </span><span class="s2">(whitespace) {</span>
				<span class="s4">return </span><span class="s2">{</span>
					<span class="s2">beforeColon: whitespace[</span><span class="s5">1</span><span class="s2">],</span>
					<span class="s2">afterColon: whitespace[</span><span class="s5">2</span><span class="s2">],</span>
				<span class="s2">};</span>
			<span class="s2">}</span>
			<span class="s4">return null</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Creates groups of properties.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node ObjectExpression node being evaluated.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Array&lt;ASTNode[]&gt;} Groups of property AST node lists.</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">createGroups(node) {</span>
			<span class="s4">if </span><span class="s2">(node.properties.length === </span><span class="s5">1</span><span class="s2">) {</span>
				<span class="s4">return </span><span class="s2">[node.properties];</span>
			<span class="s2">}</span>

			<span class="s4">return </span><span class="s2">node.properties.reduce(</span>
				<span class="s2">(groups, property) =&gt; {</span>
					<span class="s4">const </span><span class="s2">currentGroup = last(groups),</span>
						<span class="s2">prev = last(currentGroup);</span>

					<span class="s4">if </span><span class="s2">(!prev || continuesPropertyGroup(prev, property)) {</span>
						<span class="s2">currentGroup.push(property);</span>
					<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
						<span class="s2">groups.push([property]);</span>
					<span class="s2">}</span>

					<span class="s4">return </span><span class="s2">groups;</span>
				<span class="s2">},</span>
				<span class="s2">[[]],</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Verifies correct vertical alignment of a group of properties.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode[]} properties List of Property AST nodes.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">verifyGroupAlignment(properties) {</span>
			<span class="s4">const </span><span class="s2">length = properties.length,</span>
				<span class="s2">widths = properties.map(getKeyWidth), </span><span class="s0">// Width of keys, including quotes</span>
				<span class="s2">align = alignmentOptions.on; </span><span class="s0">// &quot;value&quot; or &quot;colon&quot;</span>
			<span class="s4">let </span><span class="s2">targetWidth = Math.max(...widths),</span>
				<span class="s2">beforeColon,</span>
				<span class="s2">afterColon,</span>
				<span class="s2">mode;</span>

			<span class="s4">if </span><span class="s2">(alignmentOptions &amp;&amp; length &gt; </span><span class="s5">1</span><span class="s2">) {</span>
				<span class="s0">// When aligning values within a group, use the alignment configuration.</span>
				<span class="s2">beforeColon = alignmentOptions.beforeColon;</span>
				<span class="s2">afterColon = alignmentOptions.afterColon;</span>
				<span class="s2">mode = alignmentOptions.mode;</span>
			<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
				<span class="s2">beforeColon = multiLineOptions.beforeColon;</span>
				<span class="s2">afterColon = multiLineOptions.afterColon;</span>
				<span class="s2">mode = alignmentOptions.mode;</span>
			<span class="s2">}</span>

			<span class="s0">// Conditionally include one space before or after colon</span>
			<span class="s2">targetWidth += align === </span><span class="s3">&quot;colon&quot; </span><span class="s2">? beforeColon : afterColon;</span>

			<span class="s4">for </span><span class="s2">(</span><span class="s4">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; length; i++) {</span>
				<span class="s4">const </span><span class="s2">property = properties[i];</span>
				<span class="s4">const </span><span class="s2">whitespace = getPropertyWhitespace(property);</span>

				<span class="s4">if </span><span class="s2">(whitespace) {</span>
					<span class="s0">// Object literal getters/setters lack a colon</span>
					<span class="s4">const </span><span class="s2">width = widths[i];</span>

					<span class="s4">if </span><span class="s2">(align === </span><span class="s3">&quot;value&quot;</span><span class="s2">) {</span>
						<span class="s2">report(</span>
							<span class="s2">property,</span>
							<span class="s3">&quot;key&quot;</span><span class="s2">,</span>
							<span class="s2">whitespace.beforeColon,</span>
							<span class="s2">beforeColon,</span>
							<span class="s2">mode,</span>
						<span class="s2">);</span>
						<span class="s2">report(</span>
							<span class="s2">property,</span>
							<span class="s3">&quot;value&quot;</span><span class="s2">,</span>
							<span class="s2">whitespace.afterColon,</span>
							<span class="s2">targetWidth - width,</span>
							<span class="s2">mode,</span>
						<span class="s2">);</span>
					<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
						<span class="s0">// align = &quot;colon&quot;</span>
						<span class="s2">report(</span>
							<span class="s2">property,</span>
							<span class="s3">&quot;key&quot;</span><span class="s2">,</span>
							<span class="s2">whitespace.beforeColon,</span>
							<span class="s2">targetWidth - width,</span>
							<span class="s2">mode,</span>
						<span class="s2">);</span>
						<span class="s2">report(</span>
							<span class="s2">property,</span>
							<span class="s3">&quot;value&quot;</span><span class="s2">,</span>
							<span class="s2">whitespace.afterColon,</span>
							<span class="s2">afterColon,</span>
							<span class="s2">mode,</span>
						<span class="s2">);</span>
					<span class="s2">}</span>
				<span class="s2">}</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Verifies spacing of property conforms to specified options.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node Property node being evaluated.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} lineOptions Configured singleLine or multiLine options</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">verifySpacing(node, lineOptions) {</span>
			<span class="s4">const </span><span class="s2">actual = getPropertyWhitespace(node);</span>

			<span class="s4">if </span><span class="s2">(actual) {</span>
				<span class="s0">// Object literal getters/setters lack colons</span>
				<span class="s2">report(</span>
					<span class="s2">node,</span>
					<span class="s3">&quot;key&quot;</span><span class="s2">,</span>
					<span class="s2">actual.beforeColon,</span>
					<span class="s2">lineOptions.beforeColon,</span>
					<span class="s2">lineOptions.mode,</span>
				<span class="s2">);</span>
				<span class="s2">report(</span>
					<span class="s2">node,</span>
					<span class="s3">&quot;value&quot;</span><span class="s2">,</span>
					<span class="s2">actual.afterColon,</span>
					<span class="s2">lineOptions.afterColon,</span>
					<span class="s2">lineOptions.mode,</span>
				<span class="s2">);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Verifies spacing of each property in a list.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode[]} properties List of Property AST nodes.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} lineOptions Configured singleLine or multiLine options</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">verifyListSpacing(properties, lineOptions) {</span>
			<span class="s4">const </span><span class="s2">length = properties.length;</span>

			<span class="s4">for </span><span class="s2">(</span><span class="s4">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; length; i++) {</span>
				<span class="s2">verifySpacing(properties[i], lineOptions);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Verifies vertical alignment, taking into account groups of properties.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node ObjectExpression node being evaluated.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">verifyAlignment(node) {</span>
			<span class="s2">createGroups(node).forEach(group =&gt; {</span>
				<span class="s4">const </span><span class="s2">properties = group.filter(isKeyValueProperty);</span>

				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">properties.length &gt; </span><span class="s5">0 </span><span class="s2">&amp;&amp;</span>
					<span class="s2">isSingleLineProperties(properties)</span>
				<span class="s2">) {</span>
					<span class="s2">verifyListSpacing(properties, multiLineOptions);</span>
				<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
					<span class="s2">verifyGroupAlignment(properties);</span>
				<span class="s2">}</span>
			<span class="s2">});</span>
		<span class="s2">}</span>

		<span class="s0">//--------------------------------------------------------------------------</span>
		<span class="s0">// Public API</span>
		<span class="s0">//--------------------------------------------------------------------------</span>

		<span class="s4">if </span><span class="s2">(alignmentOptions) {</span>
			<span class="s0">// Verify vertical alignment</span>

			<span class="s4">return </span><span class="s2">{</span>
				<span class="s2">ObjectExpression(node) {</span>
					<span class="s4">if </span><span class="s2">(isSingleLine(node)) {</span>
						<span class="s2">verifyListSpacing(</span>
							<span class="s2">node.properties.filter(isKeyValueProperty),</span>
							<span class="s2">singleLineOptions,</span>
						<span class="s2">);</span>
					<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
						<span class="s2">verifyAlignment(node);</span>
					<span class="s2">}</span>
				<span class="s2">},</span>
			<span class="s2">};</span>
		<span class="s2">}</span>

		<span class="s0">// Obey beforeColon and afterColon in each property as configured</span>
		<span class="s4">return </span><span class="s2">{</span>
			<span class="s2">Property(node) {</span>
				<span class="s2">verifySpacing(</span>
					<span class="s2">node,</span>
					<span class="s2">isSingleLine(node.parent)</span>
						<span class="s2">? singleLineOptions</span>
						<span class="s2">: multiLineOptions,</span>
				<span class="s2">);</span>
			<span class="s2">},</span>
		<span class="s2">};</span>
	<span class="s2">},</span>
<span class="s2">};</span>
</pre>
</body>
</html>