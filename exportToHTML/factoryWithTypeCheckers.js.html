<html>
<head>
<title>factoryWithTypeCheckers.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #0033b3;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #1750eb;}
.s6 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
factoryWithTypeCheckers.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* Copyright (c) 2013-present, Facebook, Inc.</span>
 <span class="s0">*</span>
 <span class="s0">* This source code is licensed under the MIT license found in the</span>
 <span class="s0">* LICENSE file in the root directory of this source tree.</span>
 <span class="s0">*/</span>

<span class="s2">'use strict'</span><span class="s1">;</span>

<span class="s3">var </span><span class="s1">ReactIs = require(</span><span class="s2">'react-is'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">assign = require(</span><span class="s2">'object-assign'</span><span class="s1">);</span>

<span class="s3">var </span><span class="s1">ReactPropTypesSecret = require(</span><span class="s2">'./lib/ReactPropTypesSecret'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">has = require(</span><span class="s2">'./lib/has'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">checkPropTypes = require(</span><span class="s2">'./checkPropTypes'</span><span class="s1">);</span>

<span class="s3">var </span><span class="s1">printWarning = </span><span class="s3">function</span><span class="s1">() {};</span>

<span class="s3">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) {</span>
  <span class="s1">printWarning = </span><span class="s3">function</span><span class="s1">(text) {</span>
    <span class="s3">var </span><span class="s1">message = </span><span class="s2">'Warning: ' </span><span class="s1">+ text;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">console !== </span><span class="s2">'undefined'</span><span class="s1">) {</span>
      <span class="s1">console.error(message);</span>
    <span class="s1">}</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s0">// --- Welcome to debugging React ---</span>
      <span class="s0">// This error was thrown as a convenience so that you can use this stack</span>
      <span class="s0">// to find the callsite that caused this warning to fire.</span>
      <span class="s3">throw new </span><span class="s1">Error(message);</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(x) {}</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">emptyFunctionThatReturnsNull() {</span>
  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s1">module.exports = </span><span class="s3">function</span><span class="s1">(isValidElement, throwOnDirectAccess) {</span>
  <span class="s0">/* global Symbol */</span>
  <span class="s3">var </span><span class="s1">ITERATOR_SYMBOL = </span><span class="s3">typeof </span><span class="s1">Symbol === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; Symbol.iterator;</span>
  <span class="s3">var </span><span class="s1">FAUX_ITERATOR_SYMBOL = </span><span class="s2">'@@iterator'</span><span class="s1">; </span><span class="s0">// Before Symbol spec.</span>

  <span class="s0">/**</span>
   <span class="s0">* Returns the iterator method function contained on the iterable object.</span>
   <span class="s0">*</span>
   <span class="s0">* Be sure to invoke the function with the iterable as context:</span>
   <span class="s0">*</span>
   <span class="s0">*     var iteratorFn = getIteratorFn(myIterable);</span>
   <span class="s0">*     if (iteratorFn) {</span>
   <span class="s0">*       var iterator = iteratorFn.call(myIterable);</span>
   <span class="s0">*       ...</span>
   <span class="s0">*     }</span>
   <span class="s0">*</span>
   <span class="s0">* </span><span class="s4">@param </span><span class="s0">{?object} maybeIterable</span>
   <span class="s0">* </span><span class="s4">@return </span><span class="s0">{?function}</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">getIteratorFn(maybeIterable) {</span>
    <span class="s3">var </span><span class="s1">iteratorFn = maybeIterable &amp;&amp; (ITERATOR_SYMBOL &amp;&amp; maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">iteratorFn === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">iteratorFn;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/**</span>
   <span class="s0">* Collection of methods that allow declaration and validation of props that are</span>
   <span class="s0">* supplied to React components. Example usage:</span>
   <span class="s0">*</span>
   <span class="s0">*   var Props = require('ReactPropTypes');</span>
   <span class="s0">*   var MyArticle = React.createClass({</span>
   <span class="s0">*     propTypes: {</span>
   <span class="s0">*       // An optional string prop named &quot;description&quot;.</span>
   <span class="s0">*       description: Props.string,</span>
   <span class="s0">*</span>
   <span class="s0">*       // A required enum prop named &quot;category&quot;.</span>
   <span class="s0">*       category: Props.oneOf(['News','Photos']).isRequired,</span>
   <span class="s0">*</span>
   <span class="s0">*       // A prop named &quot;dialog&quot; that requires an instance of Dialog.</span>
   <span class="s0">*       dialog: Props.instanceOf(Dialog).isRequired</span>
   <span class="s0">*     },</span>
   <span class="s0">*     render: function() { ... }</span>
   <span class="s0">*   });</span>
   <span class="s0">*</span>
   <span class="s0">* A more formal specification of how these methods are used:</span>
   <span class="s0">*</span>
   <span class="s0">*   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)</span>
   <span class="s0">*   decl := ReactPropTypes.{type}(.isRequired)?</span>
   <span class="s0">*</span>
   <span class="s0">* Each and every declaration produces a function with the same signature. This</span>
   <span class="s0">* allows the creation of custom validation functions. For example:</span>
   <span class="s0">*</span>
   <span class="s0">*  var MyLink = React.createClass({</span>
   <span class="s0">*    propTypes: {</span>
   <span class="s0">*      // An optional string or URI prop named &quot;href&quot;.</span>
   <span class="s0">*      href: function(props, propName, componentName) {</span>
   <span class="s0">*        var propValue = props[propName];</span>
   <span class="s0">*        if (propValue != null &amp;&amp; typeof propValue !== 'string' &amp;&amp;</span>
   <span class="s0">*            !(propValue instanceof URI)) {</span>
   <span class="s0">*          return new Error(</span>
   <span class="s0">*            'Expected a string or an URI for ' + propName + ' in ' +</span>
   <span class="s0">*            componentName</span>
   <span class="s0">*          );</span>
   <span class="s0">*        }</span>
   <span class="s0">*      }</span>
   <span class="s0">*    },</span>
   <span class="s0">*    render: function() {...}</span>
   <span class="s0">*  });</span>
   <span class="s0">*</span>
   <span class="s0">* </span><span class="s4">@internal</span>
   <span class="s0">*/</span>

  <span class="s3">var </span><span class="s1">ANONYMOUS = </span><span class="s2">'&lt;&lt;anonymous&gt;&gt;'</span><span class="s1">;</span>

  <span class="s0">// Important!</span>
  <span class="s0">// Keep this list in sync with production version in `./factoryWithThrowingShims.js`.</span>
  <span class="s3">var </span><span class="s1">ReactPropTypes = {</span>
    <span class="s1">array: createPrimitiveTypeChecker(</span><span class="s2">'array'</span><span class="s1">),</span>
    <span class="s1">bigint: createPrimitiveTypeChecker(</span><span class="s2">'bigint'</span><span class="s1">),</span>
    <span class="s1">bool: createPrimitiveTypeChecker(</span><span class="s2">'boolean'</span><span class="s1">),</span>
    <span class="s1">func: createPrimitiveTypeChecker(</span><span class="s2">'function'</span><span class="s1">),</span>
    <span class="s1">number: createPrimitiveTypeChecker(</span><span class="s2">'number'</span><span class="s1">),</span>
    <span class="s1">object: createPrimitiveTypeChecker(</span><span class="s2">'object'</span><span class="s1">),</span>
    <span class="s1">string: createPrimitiveTypeChecker(</span><span class="s2">'string'</span><span class="s1">),</span>
    <span class="s1">symbol: createPrimitiveTypeChecker(</span><span class="s2">'symbol'</span><span class="s1">),</span>

    <span class="s1">any: createAnyTypeChecker(),</span>
    <span class="s1">arrayOf: createArrayOfTypeChecker,</span>
    <span class="s1">element: createElementTypeChecker(),</span>
    <span class="s1">elementType: createElementTypeTypeChecker(),</span>
    <span class="s1">instanceOf: createInstanceTypeChecker,</span>
    <span class="s1">node: createNodeChecker(),</span>
    <span class="s1">objectOf: createObjectOfTypeChecker,</span>
    <span class="s1">oneOf: createEnumTypeChecker,</span>
    <span class="s1">oneOfType: createUnionTypeChecker,</span>
    <span class="s1">shape: createShapeTypeChecker,</span>
    <span class="s1">exact: createStrictShapeTypeChecker,</span>
  <span class="s1">};</span>

  <span class="s0">/**</span>
   <span class="s0">* inlined Object.is polyfill to avoid requiring consumers ship their own</span>
   <span class="s0">* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is</span>
   <span class="s0">*/</span>
  <span class="s0">/*eslint-disable no-self-compare*/</span>
  <span class="s3">function </span><span class="s1">is(x, y) {</span>
    <span class="s0">// SameValue algorithm</span>
    <span class="s3">if </span><span class="s1">(x === y) {</span>
      <span class="s0">// Steps 1-5, 7-10</span>
      <span class="s0">// Steps 6.b-6.e: +0 != -0</span>
      <span class="s3">return </span><span class="s1">x !== </span><span class="s5">0 </span><span class="s1">|| </span><span class="s5">1 </span><span class="s1">/ x === </span><span class="s5">1 </span><span class="s1">/ y;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Step 6.a: NaN == NaN</span>
      <span class="s3">return </span><span class="s1">x !== x &amp;&amp; y !== y;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/*eslint-enable no-self-compare*/</span>

  <span class="s0">/**</span>
   <span class="s0">* We use an Error-like object for backward compatibility as people may call</span>
   <span class="s0">* PropTypes directly and inspect their output. However, we don't use real</span>
   <span class="s0">* Errors anymore. We don't inspect their stack anyway, and creating them</span>
   <span class="s0">* is prohibitively expensive if they are created too often, such as what</span>
   <span class="s0">* happens in oneOfType() for any type before the one that matched.</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">PropTypeError(message, data) {</span>
    <span class="s3">this</span><span class="s1">.message = message;</span>
    <span class="s3">this</span><span class="s1">.data = data &amp;&amp; </span><span class="s3">typeof </span><span class="s1">data === </span><span class="s2">'object' </span><span class="s1">? data: {};</span>
    <span class="s3">this</span><span class="s1">.stack = </span><span class="s2">''</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s0">// Make `instanceof Error` still work for returned errors.</span>
  <span class="s1">PropTypeError.prototype = Error.prototype;</span>

  <span class="s3">function </span><span class="s1">createChainableTypeChecker(validate) {</span>
    <span class="s3">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">manualPropTypeCallCache = {};</span>
      <span class="s3">var </span><span class="s1">manualPropTypeWarningCount = </span><span class="s5">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">checkType(isRequired, props, propName, componentName, location, propFullName, secret) {</span>
      <span class="s1">componentName = componentName || ANONYMOUS;</span>
      <span class="s1">propFullName = propFullName || propName;</span>

      <span class="s3">if </span><span class="s1">(secret !== ReactPropTypesSecret) {</span>
        <span class="s3">if </span><span class="s1">(throwOnDirectAccess) {</span>
          <span class="s0">// New behavior only for users of `prop-types` package</span>
          <span class="s3">var </span><span class="s1">err = </span><span class="s3">new </span><span class="s1">Error(</span>
            <span class="s2">'Calling PropTypes validators directly is not supported by the `prop-types` package. ' </span><span class="s1">+</span>
            <span class="s2">'Use `PropTypes.checkPropTypes()` to call them. ' </span><span class="s1">+</span>
            <span class="s2">'Read more at http://fb.me/use-check-prop-types'</span>
          <span class="s1">);</span>
          <span class="s1">err.name = </span><span class="s2">'Invariant Violation'</span><span class="s1">;</span>
          <span class="s3">throw </span><span class="s1">err;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s2">'production' </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">console !== </span><span class="s2">'undefined'</span><span class="s1">) {</span>
          <span class="s0">// Old behavior for people using React.PropTypes</span>
          <span class="s3">var </span><span class="s1">cacheKey = componentName + </span><span class="s2">':' </span><span class="s1">+ propName;</span>
          <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">!manualPropTypeCallCache[cacheKey] &amp;&amp;</span>
            <span class="s0">// Avoid spamming the console because they are often not actionable except for lib authors</span>
            <span class="s1">manualPropTypeWarningCount &lt; </span><span class="s5">3</span>
          <span class="s1">) {</span>
            <span class="s1">printWarning(</span>
              <span class="s2">'You are manually calling a React.PropTypes validation ' </span><span class="s1">+</span>
              <span class="s2">'function for the `' </span><span class="s1">+ propFullName + </span><span class="s2">'` prop on `' </span><span class="s1">+ componentName + </span><span class="s2">'`. This is deprecated ' </span><span class="s1">+</span>
              <span class="s2">'and will throw in the standalone `prop-types` package. ' </span><span class="s1">+</span>
              <span class="s2">'You may be seeing this warning due to a third-party PropTypes ' </span><span class="s1">+</span>
              <span class="s2">'library. See https://fb.me/react-warning-dont-call-proptypes ' </span><span class="s1">+ </span><span class="s2">'for details.'</span>
            <span class="s1">);</span>
            <span class="s1">manualPropTypeCallCache[cacheKey] = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">manualPropTypeWarningCount++;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(props[propName] == </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(isRequired) {</span>
          <span class="s3">if </span><span class="s1">(props[propName] === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">return new </span><span class="s1">PropTypeError(</span><span class="s2">'The ' </span><span class="s1">+ location + </span><span class="s2">' `' </span><span class="s1">+ propFullName + </span><span class="s2">'` is marked as required ' </span><span class="s1">+ (</span><span class="s2">'in `' </span><span class="s1">+ componentName + </span><span class="s2">'`, but its value is `null`.'</span><span class="s1">));</span>
          <span class="s1">}</span>
          <span class="s3">return new </span><span class="s1">PropTypeError(</span><span class="s2">'The ' </span><span class="s1">+ location + </span><span class="s2">' `' </span><span class="s1">+ propFullName + </span><span class="s2">'` is marked as required in ' </span><span class="s1">+ (</span><span class="s2">'`' </span><span class="s1">+ componentName + </span><span class="s2">'`, but its value is `undefined`.'</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">validate(props, propName, componentName, location, propFullName);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">chainedCheckType = checkType.bind(</span><span class="s3">null</span><span class="s1">, </span><span class="s3">false</span><span class="s1">);</span>
    <span class="s1">chainedCheckType.isRequired = checkType.bind(</span><span class="s3">null</span><span class="s1">, </span><span class="s3">true</span><span class="s1">);</span>

    <span class="s3">return </span><span class="s1">chainedCheckType;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createPrimitiveTypeChecker(expectedType) {</span>
    <span class="s3">function </span><span class="s1">validate(props, propName, componentName, location, propFullName, secret) {</span>
      <span class="s3">var </span><span class="s1">propValue = props[propName];</span>
      <span class="s3">var </span><span class="s1">propType = getPropType(propValue);</span>
      <span class="s3">if </span><span class="s1">(propType !== expectedType) {</span>
        <span class="s0">// `propValue` being instance of, say, date/regexp, pass the 'object'</span>
        <span class="s0">// check, but we can offer a more precise error message here rather than</span>
        <span class="s0">// 'of type `object`'.</span>
        <span class="s3">var </span><span class="s1">preciseType = getPreciseType(propValue);</span>

        <span class="s3">return new </span><span class="s1">PropTypeError(</span>
          <span class="s2">'Invalid ' </span><span class="s1">+ location + </span><span class="s2">' `' </span><span class="s1">+ propFullName + </span><span class="s2">'` of type ' </span><span class="s1">+ (</span><span class="s2">'`' </span><span class="s1">+ preciseType + </span><span class="s2">'` supplied to `' </span><span class="s1">+ componentName + </span><span class="s2">'`, expected '</span><span class="s1">) + (</span><span class="s2">'`' </span><span class="s1">+ expectedType + </span><span class="s2">'`.'</span><span class="s1">),</span>
          <span class="s1">{expectedType: expectedType}</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">createChainableTypeChecker(validate);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createAnyTypeChecker() {</span>
    <span class="s3">return </span><span class="s1">createChainableTypeChecker(emptyFunctionThatReturnsNull);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createArrayOfTypeChecker(typeChecker) {</span>
    <span class="s3">function </span><span class="s1">validate(props, propName, componentName, location, propFullName) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">typeChecker !== </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s3">return new </span><span class="s1">PropTypeError(</span><span class="s2">'Property `' </span><span class="s1">+ propFullName + </span><span class="s2">'` of component `' </span><span class="s1">+ componentName + </span><span class="s2">'` has invalid PropType notation inside arrayOf.'</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s3">var </span><span class="s1">propValue = props[propName];</span>
      <span class="s3">if </span><span class="s1">(!Array.isArray(propValue)) {</span>
        <span class="s3">var </span><span class="s1">propType = getPropType(propValue);</span>
        <span class="s3">return new </span><span class="s1">PropTypeError(</span><span class="s2">'Invalid ' </span><span class="s1">+ location + </span><span class="s2">' `' </span><span class="s1">+ propFullName + </span><span class="s2">'` of type ' </span><span class="s1">+ (</span><span class="s2">'`' </span><span class="s1">+ propType + </span><span class="s2">'` supplied to `' </span><span class="s1">+ componentName + </span><span class="s2">'`, expected an array.'</span><span class="s1">));</span>
      <span class="s1">}</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; propValue.length; i++) {</span>
        <span class="s3">var </span><span class="s1">error = typeChecker(propValue, i, componentName, location, propFullName + </span><span class="s2">'[' </span><span class="s1">+ i + </span><span class="s2">']'</span><span class="s1">, ReactPropTypesSecret);</span>
        <span class="s3">if </span><span class="s1">(error </span><span class="s3">instanceof </span><span class="s1">Error) {</span>
          <span class="s3">return </span><span class="s1">error;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">createChainableTypeChecker(validate);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createElementTypeChecker() {</span>
    <span class="s3">function </span><span class="s1">validate(props, propName, componentName, location, propFullName) {</span>
      <span class="s3">var </span><span class="s1">propValue = props[propName];</span>
      <span class="s3">if </span><span class="s1">(!isValidElement(propValue)) {</span>
        <span class="s3">var </span><span class="s1">propType = getPropType(propValue);</span>
        <span class="s3">return new </span><span class="s1">PropTypeError(</span><span class="s2">'Invalid ' </span><span class="s1">+ location + </span><span class="s2">' `' </span><span class="s1">+ propFullName + </span><span class="s2">'` of type ' </span><span class="s1">+ (</span><span class="s2">'`' </span><span class="s1">+ propType + </span><span class="s2">'` supplied to `' </span><span class="s1">+ componentName + </span><span class="s2">'`, expected a single ReactElement.'</span><span class="s1">));</span>
      <span class="s1">}</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">createChainableTypeChecker(validate);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createElementTypeTypeChecker() {</span>
    <span class="s3">function </span><span class="s1">validate(props, propName, componentName, location, propFullName) {</span>
      <span class="s3">var </span><span class="s1">propValue = props[propName];</span>
      <span class="s3">if </span><span class="s1">(!ReactIs.isValidElementType(propValue)) {</span>
        <span class="s3">var </span><span class="s1">propType = getPropType(propValue);</span>
        <span class="s3">return new </span><span class="s1">PropTypeError(</span><span class="s2">'Invalid ' </span><span class="s1">+ location + </span><span class="s2">' `' </span><span class="s1">+ propFullName + </span><span class="s2">'` of type ' </span><span class="s1">+ (</span><span class="s2">'`' </span><span class="s1">+ propType + </span><span class="s2">'` supplied to `' </span><span class="s1">+ componentName + </span><span class="s2">'`, expected a single ReactElement type.'</span><span class="s1">));</span>
      <span class="s1">}</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">createChainableTypeChecker(validate);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createInstanceTypeChecker(expectedClass) {</span>
    <span class="s3">function </span><span class="s1">validate(props, propName, componentName, location, propFullName) {</span>
      <span class="s3">if </span><span class="s1">(!(props[propName] </span><span class="s3">instanceof </span><span class="s1">expectedClass)) {</span>
        <span class="s3">var </span><span class="s1">expectedClassName = expectedClass.name || ANONYMOUS;</span>
        <span class="s3">var </span><span class="s1">actualClassName = getClassName(props[propName]);</span>
        <span class="s3">return new </span><span class="s1">PropTypeError(</span><span class="s2">'Invalid ' </span><span class="s1">+ location + </span><span class="s2">' `' </span><span class="s1">+ propFullName + </span><span class="s2">'` of type ' </span><span class="s1">+ (</span><span class="s2">'`' </span><span class="s1">+ actualClassName + </span><span class="s2">'` supplied to `' </span><span class="s1">+ componentName + </span><span class="s2">'`, expected '</span><span class="s1">) + (</span><span class="s2">'instance of `' </span><span class="s1">+ expectedClassName + </span><span class="s2">'`.'</span><span class="s1">));</span>
      <span class="s1">}</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">createChainableTypeChecker(validate);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createEnumTypeChecker(expectedValues) {</span>
    <span class="s3">if </span><span class="s1">(!Array.isArray(expectedValues)) {</span>
      <span class="s3">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(arguments.length &gt; </span><span class="s5">1</span><span class="s1">) {</span>
          <span class="s1">printWarning(</span>
            <span class="s2">'Invalid arguments supplied to oneOf, expected an array, got ' </span><span class="s1">+ arguments.length + </span><span class="s2">' arguments. ' </span><span class="s1">+</span>
            <span class="s2">'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'</span>
          <span class="s1">);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">printWarning(</span><span class="s2">'Invalid argument supplied to oneOf, expected an array.'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s3">return </span><span class="s1">emptyFunctionThatReturnsNull;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">validate(props, propName, componentName, location, propFullName) {</span>
      <span class="s3">var </span><span class="s1">propValue = props[propName];</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; expectedValues.length; i++) {</span>
        <span class="s3">if </span><span class="s1">(is(propValue, expectedValues[i])) {</span>
          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">valuesString = JSON.stringify(expectedValues, </span><span class="s3">function </span><span class="s1">replacer(key, value) {</span>
        <span class="s3">var </span><span class="s1">type = getPreciseType(value);</span>
        <span class="s3">if </span><span class="s1">(type === </span><span class="s2">'symbol'</span><span class="s1">) {</span>
          <span class="s3">return </span><span class="s1">String(value);</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">value;</span>
      <span class="s1">});</span>
      <span class="s3">return new </span><span class="s1">PropTypeError(</span><span class="s2">'Invalid ' </span><span class="s1">+ location + </span><span class="s2">' `' </span><span class="s1">+ propFullName + </span><span class="s2">'` of value `' </span><span class="s1">+ String(propValue) + </span><span class="s2">'` ' </span><span class="s1">+ (</span><span class="s2">'supplied to `' </span><span class="s1">+ componentName + </span><span class="s2">'`, expected one of ' </span><span class="s1">+ valuesString + </span><span class="s2">'.'</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">createChainableTypeChecker(validate);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createObjectOfTypeChecker(typeChecker) {</span>
    <span class="s3">function </span><span class="s1">validate(props, propName, componentName, location, propFullName) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">typeChecker !== </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s3">return new </span><span class="s1">PropTypeError(</span><span class="s2">'Property `' </span><span class="s1">+ propFullName + </span><span class="s2">'` of component `' </span><span class="s1">+ componentName + </span><span class="s2">'` has invalid PropType notation inside objectOf.'</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s3">var </span><span class="s1">propValue = props[propName];</span>
      <span class="s3">var </span><span class="s1">propType = getPropType(propValue);</span>
      <span class="s3">if </span><span class="s1">(propType !== </span><span class="s2">'object'</span><span class="s1">) {</span>
        <span class="s3">return new </span><span class="s1">PropTypeError(</span><span class="s2">'Invalid ' </span><span class="s1">+ location + </span><span class="s2">' `' </span><span class="s1">+ propFullName + </span><span class="s2">'` of type ' </span><span class="s1">+ (</span><span class="s2">'`' </span><span class="s1">+ propType + </span><span class="s2">'` supplied to `' </span><span class="s1">+ componentName + </span><span class="s2">'`, expected an object.'</span><span class="s1">));</span>
      <span class="s1">}</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">key </span><span class="s3">in </span><span class="s1">propValue) {</span>
        <span class="s3">if </span><span class="s1">(has(propValue, key)) {</span>
          <span class="s3">var </span><span class="s1">error = typeChecker(propValue, key, componentName, location, propFullName + </span><span class="s2">'.' </span><span class="s1">+ key, ReactPropTypesSecret);</span>
          <span class="s3">if </span><span class="s1">(error </span><span class="s3">instanceof </span><span class="s1">Error) {</span>
            <span class="s3">return </span><span class="s1">error;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">createChainableTypeChecker(validate);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createUnionTypeChecker(arrayOfTypeCheckers) {</span>
    <span class="s3">if </span><span class="s1">(!Array.isArray(arrayOfTypeCheckers)) {</span>
      <span class="s1">process.env.NODE_ENV !== </span><span class="s2">'production' </span><span class="s1">? printWarning(</span><span class="s2">'Invalid argument supplied to oneOfType, expected an instance of array.'</span><span class="s1">) : </span><span class="s3">void </span><span class="s5">0</span><span class="s1">;</span>
      <span class="s3">return </span><span class="s1">emptyFunctionThatReturnsNull;</span>
    <span class="s1">}</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; arrayOfTypeCheckers.length; i++) {</span>
      <span class="s3">var </span><span class="s1">checker = arrayOfTypeCheckers[i];</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">checker !== </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">printWarning(</span>
          <span class="s2">'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' </span><span class="s1">+</span>
          <span class="s2">'received ' </span><span class="s1">+ getPostfixForTypeWarning(checker) + </span><span class="s2">' at index ' </span><span class="s1">+ i + </span><span class="s2">'.'</span>
        <span class="s1">);</span>
        <span class="s3">return </span><span class="s1">emptyFunctionThatReturnsNull;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">validate(props, propName, componentName, location, propFullName) {</span>
      <span class="s3">var </span><span class="s1">expectedTypes = [];</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; arrayOfTypeCheckers.length; i++) {</span>
        <span class="s3">var </span><span class="s1">checker = arrayOfTypeCheckers[i];</span>
        <span class="s3">var </span><span class="s1">checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);</span>
        <span class="s3">if </span><span class="s1">(checkerResult == </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(checkerResult.data &amp;&amp; has(checkerResult.data, </span><span class="s2">'expectedType'</span><span class="s1">)) {</span>
          <span class="s1">expectedTypes.push(checkerResult.data.expectedType);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s3">var </span><span class="s1">expectedTypesMessage = (expectedTypes.length &gt; </span><span class="s5">0</span><span class="s1">) ? </span><span class="s2">', expected one of type [' </span><span class="s1">+ expectedTypes.join(</span><span class="s2">', '</span><span class="s1">) + </span><span class="s2">']'</span><span class="s1">: </span><span class="s2">''</span><span class="s1">;</span>
      <span class="s3">return new </span><span class="s1">PropTypeError(</span><span class="s2">'Invalid ' </span><span class="s1">+ location + </span><span class="s2">' `' </span><span class="s1">+ propFullName + </span><span class="s2">'` supplied to ' </span><span class="s1">+ (</span><span class="s2">'`' </span><span class="s1">+ componentName + </span><span class="s2">'`' </span><span class="s1">+ expectedTypesMessage + </span><span class="s2">'.'</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">createChainableTypeChecker(validate);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createNodeChecker() {</span>
    <span class="s3">function </span><span class="s1">validate(props, propName, componentName, location, propFullName) {</span>
      <span class="s3">if </span><span class="s1">(!isNode(props[propName])) {</span>
        <span class="s3">return new </span><span class="s1">PropTypeError(</span><span class="s2">'Invalid ' </span><span class="s1">+ location + </span><span class="s2">' `' </span><span class="s1">+ propFullName + </span><span class="s2">'` supplied to ' </span><span class="s1">+ (</span><span class="s2">'`' </span><span class="s1">+ componentName + </span><span class="s2">'`, expected a ReactNode.'</span><span class="s1">));</span>
      <span class="s1">}</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">createChainableTypeChecker(validate);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">invalidValidatorError(componentName, location, propFullName, key, type) {</span>
    <span class="s3">return new </span><span class="s1">PropTypeError(</span>
      <span class="s1">(componentName || </span><span class="s2">'React class'</span><span class="s1">) + </span><span class="s2">': ' </span><span class="s1">+ location + </span><span class="s2">' type `' </span><span class="s1">+ propFullName + </span><span class="s2">'.' </span><span class="s1">+ key + </span><span class="s2">'` is invalid; ' </span><span class="s1">+</span>
      <span class="s2">'it must be a function, usually from the `prop-types` package, but received `' </span><span class="s1">+ type + </span><span class="s2">'`.'</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createShapeTypeChecker(shapeTypes) {</span>
    <span class="s3">function </span><span class="s1">validate(props, propName, componentName, location, propFullName) {</span>
      <span class="s3">var </span><span class="s1">propValue = props[propName];</span>
      <span class="s3">var </span><span class="s1">propType = getPropType(propValue);</span>
      <span class="s3">if </span><span class="s1">(propType !== </span><span class="s2">'object'</span><span class="s1">) {</span>
        <span class="s3">return new </span><span class="s1">PropTypeError(</span><span class="s2">'Invalid ' </span><span class="s1">+ location + </span><span class="s2">' `' </span><span class="s1">+ propFullName + </span><span class="s2">'` of type `' </span><span class="s1">+ propType + </span><span class="s2">'` ' </span><span class="s1">+ (</span><span class="s2">'supplied to `' </span><span class="s1">+ componentName + </span><span class="s2">'`, expected `object`.'</span><span class="s1">));</span>
      <span class="s1">}</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">key </span><span class="s3">in </span><span class="s1">shapeTypes) {</span>
        <span class="s3">var </span><span class="s1">checker = shapeTypes[key];</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">checker !== </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s3">return </span><span class="s1">invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));</span>
        <span class="s1">}</span>
        <span class="s3">var </span><span class="s1">error = checker(propValue, key, componentName, location, propFullName + </span><span class="s2">'.' </span><span class="s1">+ key, ReactPropTypesSecret);</span>
        <span class="s3">if </span><span class="s1">(error) {</span>
          <span class="s3">return </span><span class="s1">error;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">createChainableTypeChecker(validate);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createStrictShapeTypeChecker(shapeTypes) {</span>
    <span class="s3">function </span><span class="s1">validate(props, propName, componentName, location, propFullName) {</span>
      <span class="s3">var </span><span class="s1">propValue = props[propName];</span>
      <span class="s3">var </span><span class="s1">propType = getPropType(propValue);</span>
      <span class="s3">if </span><span class="s1">(propType !== </span><span class="s2">'object'</span><span class="s1">) {</span>
        <span class="s3">return new </span><span class="s1">PropTypeError(</span><span class="s2">'Invalid ' </span><span class="s1">+ location + </span><span class="s2">' `' </span><span class="s1">+ propFullName + </span><span class="s2">'` of type `' </span><span class="s1">+ propType + </span><span class="s2">'` ' </span><span class="s1">+ (</span><span class="s2">'supplied to `' </span><span class="s1">+ componentName + </span><span class="s2">'`, expected `object`.'</span><span class="s1">));</span>
      <span class="s1">}</span>
      <span class="s0">// We need to check all keys in case some are required but missing from props.</span>
      <span class="s3">var </span><span class="s1">allKeys = assign({}, props[propName], shapeTypes);</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">key </span><span class="s3">in </span><span class="s1">allKeys) {</span>
        <span class="s3">var </span><span class="s1">checker = shapeTypes[key];</span>
        <span class="s3">if </span><span class="s1">(has(shapeTypes, key) &amp;&amp; </span><span class="s3">typeof </span><span class="s1">checker !== </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s3">return </span><span class="s1">invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(!checker) {</span>
          <span class="s3">return new </span><span class="s1">PropTypeError(</span>
            <span class="s2">'Invalid ' </span><span class="s1">+ location + </span><span class="s2">' `' </span><span class="s1">+ propFullName + </span><span class="s2">'` key `' </span><span class="s1">+ key + </span><span class="s2">'` supplied to `' </span><span class="s1">+ componentName + </span><span class="s2">'`.' </span><span class="s1">+</span>
            <span class="s2">'</span><span class="s6">\n</span><span class="s2">Bad object: ' </span><span class="s1">+ JSON.stringify(props[propName], </span><span class="s3">null</span><span class="s1">, </span><span class="s2">'  '</span><span class="s1">) +</span>
            <span class="s2">'</span><span class="s6">\n</span><span class="s2">Valid keys: ' </span><span class="s1">+ JSON.stringify(Object.keys(shapeTypes), </span><span class="s3">null</span><span class="s1">, </span><span class="s2">'  '</span><span class="s1">)</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s3">var </span><span class="s1">error = checker(propValue, key, componentName, location, propFullName + </span><span class="s2">'.' </span><span class="s1">+ key, ReactPropTypesSecret);</span>
        <span class="s3">if </span><span class="s1">(error) {</span>
          <span class="s3">return </span><span class="s1">error;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">createChainableTypeChecker(validate);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">isNode(propValue) {</span>
    <span class="s3">switch </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">propValue) {</span>
      <span class="s3">case </span><span class="s2">'number'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'string'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'undefined'</span><span class="s1">:</span>
        <span class="s3">return true</span><span class="s1">;</span>
      <span class="s3">case </span><span class="s2">'boolean'</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">!propValue;</span>
      <span class="s3">case </span><span class="s2">'object'</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">(Array.isArray(propValue)) {</span>
          <span class="s3">return </span><span class="s1">propValue.every(isNode);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(propValue === </span><span class="s3">null </span><span class="s1">|| isValidElement(propValue)) {</span>
          <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">iteratorFn = getIteratorFn(propValue);</span>
        <span class="s3">if </span><span class="s1">(iteratorFn) {</span>
          <span class="s3">var </span><span class="s1">iterator = iteratorFn.call(propValue);</span>
          <span class="s3">var </span><span class="s1">step;</span>
          <span class="s3">if </span><span class="s1">(iteratorFn !== propValue.entries) {</span>
            <span class="s3">while </span><span class="s1">(!(step = iterator.next()).done) {</span>
              <span class="s3">if </span><span class="s1">(!isNode(step.value)) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s0">// Iterator will provide entry [k,v] tuples rather than values.</span>
            <span class="s3">while </span><span class="s1">(!(step = iterator.next()).done) {</span>
              <span class="s3">var </span><span class="s1">entry = step.value;</span>
              <span class="s3">if </span><span class="s1">(entry) {</span>
                <span class="s3">if </span><span class="s1">(!isNode(entry[</span><span class="s5">1</span><span class="s1">])) {</span>
                  <span class="s3">return false</span><span class="s1">;</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">return true</span><span class="s1">;</span>
      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">isSymbol(propType, propValue) {</span>
    <span class="s0">// Native Symbol.</span>
    <span class="s3">if </span><span class="s1">(propType === </span><span class="s2">'symbol'</span><span class="s1">) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// falsy value can't be a Symbol</span>
    <span class="s3">if </span><span class="s1">(!propValue) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'</span>
    <span class="s3">if </span><span class="s1">(propValue[</span><span class="s2">'@@toStringTag'</span><span class="s1">] === </span><span class="s2">'Symbol'</span><span class="s1">) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// Fallback for non-spec compliant Symbols which are polyfilled.</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">Symbol === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; propValue </span><span class="s3">instanceof </span><span class="s1">Symbol) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">// Equivalent of `typeof` but with special handling for array and regexp.</span>
  <span class="s3">function </span><span class="s1">getPropType(propValue) {</span>
    <span class="s3">var </span><span class="s1">propType = </span><span class="s3">typeof </span><span class="s1">propValue;</span>
    <span class="s3">if </span><span class="s1">(Array.isArray(propValue)) {</span>
      <span class="s3">return </span><span class="s2">'array'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(propValue </span><span class="s3">instanceof </span><span class="s1">RegExp) {</span>
      <span class="s0">// Old webkits (at least until Android 4.0) return 'function' rather than</span>
      <span class="s0">// 'object' for typeof a RegExp. We'll normalize this here so that /bla/</span>
      <span class="s0">// passes PropTypes.object.</span>
      <span class="s3">return </span><span class="s2">'object'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(isSymbol(propType, propValue)) {</span>
      <span class="s3">return </span><span class="s2">'symbol'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">propType;</span>
  <span class="s1">}</span>

  <span class="s0">// This handles more types than `getPropType`. Only used for error messages.</span>
  <span class="s0">// See `createPrimitiveTypeChecker`.</span>
  <span class="s3">function </span><span class="s1">getPreciseType(propValue) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">propValue === </span><span class="s2">'undefined' </span><span class="s1">|| propValue === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s2">'' </span><span class="s1">+ propValue;</span>
    <span class="s1">}</span>
    <span class="s3">var </span><span class="s1">propType = getPropType(propValue);</span>
    <span class="s3">if </span><span class="s1">(propType === </span><span class="s2">'object'</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(propValue </span><span class="s3">instanceof </span><span class="s1">Date) {</span>
        <span class="s3">return </span><span class="s2">'date'</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(propValue </span><span class="s3">instanceof </span><span class="s1">RegExp) {</span>
        <span class="s3">return </span><span class="s2">'regexp'</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">propType;</span>
  <span class="s1">}</span>

  <span class="s0">// Returns a string that is postfixed to a warning about an invalid type.</span>
  <span class="s0">// For example, &quot;undefined&quot; or &quot;of type array&quot;</span>
  <span class="s3">function </span><span class="s1">getPostfixForTypeWarning(value) {</span>
    <span class="s3">var </span><span class="s1">type = getPreciseType(value);</span>
    <span class="s3">switch </span><span class="s1">(type) {</span>
      <span class="s3">case </span><span class="s2">'array'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'object'</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s2">'an ' </span><span class="s1">+ type;</span>
      <span class="s3">case </span><span class="s2">'boolean'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'date'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'regexp'</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s2">'a ' </span><span class="s1">+ type;</span>
      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">type;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// Returns class name of the object, if any.</span>
  <span class="s3">function </span><span class="s1">getClassName(propValue) {</span>
    <span class="s3">if </span><span class="s1">(!propValue.constructor || !propValue.constructor.name) {</span>
      <span class="s3">return </span><span class="s1">ANONYMOUS;</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">propValue.constructor.name;</span>
  <span class="s1">}</span>

  <span class="s1">ReactPropTypes.checkPropTypes = checkPropTypes;</span>
  <span class="s1">ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;</span>
  <span class="s1">ReactPropTypes.PropTypes = ReactPropTypes;</span>

  <span class="s3">return </span><span class="s1">ReactPropTypes;</span>
<span class="s1">};</span>
</pre>
</body>
</html>