<html>
<head>
<title>adapter.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
adapter.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/web/adapter.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { RequestData, FetchEventResult } from './types'</span><span class="s3">\n</span><span class="s1">import type { RequestInit } from './spec-extension/request'</span><span class="s3">\n</span><span class="s1">import { PageSignatureError } from './error'</span><span class="s3">\n</span><span class="s1">import { fromNodeOutgoingHttpHeaders, normalizeNextQueryParam } from './utils'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NextFetchEvent,</span><span class="s3">\n  </span><span class="s1">getWaitUntilPromiseFromEvent,</span><span class="s3">\n</span><span class="s1">} from './spec-extension/fetch-event'</span><span class="s3">\n</span><span class="s1">import { NextRequest } from './spec-extension/request'</span><span class="s3">\n</span><span class="s1">import { NextResponse } from './spec-extension/response'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">parseRelativeURL,</span><span class="s3">\n  </span><span class="s1">getRelativeURL,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/router/utils/relativize-url'</span><span class="s3">\n</span><span class="s1">import { NextURL } from './next-url'</span><span class="s3">\n</span><span class="s1">import { stripInternalSearchParams } from '../internal-utils'</span><span class="s3">\n</span><span class="s1">import { normalizeRscURL } from '../../shared/lib/router/utils/app-paths'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">FLIGHT_HEADERS,</span><span class="s3">\n  </span><span class="s1">NEXT_REWRITTEN_PATH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_REWRITTEN_QUERY_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_RSC_UNION_QUERY,</span><span class="s3">\n  </span><span class="s1">RSC_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import { ensureInstrumentationRegistered } from './globals'</span><span class="s3">\n</span><span class="s1">import { createRequestStoreForAPI } from '../async-storage/request-store'</span><span class="s3">\n</span><span class="s1">import { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { createWorkStore } from '../async-storage/work-store'</span><span class="s3">\n</span><span class="s1">import { workAsyncStorage } from '../app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { NEXT_ROUTER_PREFETCH_HEADER } from '../../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import { getTracer } from '../lib/trace/tracer'</span><span class="s3">\n</span><span class="s1">import type { TextMapGetter } from 'next/dist/compiled/@opentelemetry/api'</span><span class="s3">\n</span><span class="s1">import { MiddlewareSpan } from '../lib/trace/constants'</span><span class="s3">\n</span><span class="s1">import { CloseController } from './web-on-close'</span><span class="s3">\n</span><span class="s1">import { getEdgePreviewProps } from './get-edge-preview-props'</span><span class="s3">\n</span><span class="s1">import { getBuiltinRequestContext } from '../after/builtin-request-context'</span><span class="s3">\n</span><span class="s1">import { getImplicitTags } from '../lib/implicit-tags'</span><span class="s3">\n\n</span><span class="s1">export class NextRequestHint extends NextRequest {</span><span class="s3">\n  </span><span class="s1">sourcePage: string</span><span class="s3">\n  </span><span class="s1">fetchMetrics: FetchEventResult['fetchMetrics'] | undefined</span><span class="s3">\n\n  </span><span class="s1">constructor(params: {</span><span class="s3">\n    </span><span class="s1">init: RequestInit</span><span class="s3">\n    </span><span class="s1">input: Request | string</span><span class="s3">\n    </span><span class="s1">page: string</span><span class="s3">\n  </span><span class="s1">}) {</span><span class="s3">\n    </span><span class="s1">super(params.input, params.init)</span><span class="s3">\n    </span><span class="s1">this.sourcePage = params.page</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get request() {</span><span class="s3">\n    </span><span class="s1">throw new PageSignatureError({ page: this.sourcePage })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">respondWith() {</span><span class="s3">\n    </span><span class="s1">throw new PageSignatureError({ page: this.sourcePage })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">waitUntil() {</span><span class="s3">\n    </span><span class="s1">throw new PageSignatureError({ page: this.sourcePage })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const headersGetter: TextMapGetter&lt;Headers&gt; = {</span><span class="s3">\n  </span><span class="s1">keys: (headers) =&gt; Array.from(headers.keys()),</span><span class="s3">\n  </span><span class="s1">get: (headers, key) =&gt; headers.get(key) ?? undefined,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type AdapterOptions = {</span><span class="s3">\n  </span><span class="s1">handler: (req: NextRequestHint, event: NextFetchEvent) =&gt; Promise&lt;Response&gt;</span><span class="s3">\n  </span><span class="s1">page: string</span><span class="s3">\n  </span><span class="s1">request: RequestData</span><span class="s3">\n  </span><span class="s1">IncrementalCache?: typeof import('../lib/incremental-cache').IncrementalCache</span><span class="s3">\n  </span><span class="s1">incrementalCacheHandler?: typeof import('../lib/incremental-cache').CacheHandler</span><span class="s3">\n  </span><span class="s1">bypassNextUrl?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">let propagator: &lt;T&gt;(request: NextRequestHint, fn: () =&gt; T) =&gt; T = (</span><span class="s3">\n  </span><span class="s1">request,</span><span class="s3">\n  </span><span class="s1">fn</span><span class="s3">\n</span><span class="s1">) =&gt; {</span><span class="s3">\n  </span><span class="s1">const tracer = getTracer()</span><span class="s3">\n  </span><span class="s1">return tracer.withPropagatedContext(request.headers, fn, headersGetter)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">let testApisIntercepted = false</span><span class="s3">\n\n</span><span class="s1">function ensureTestApisIntercepted() {</span><span class="s3">\n  </span><span class="s1">if (!testApisIntercepted) {</span><span class="s3">\n    </span><span class="s1">testApisIntercepted = true</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_PRIVATE_TEST_PROXY === 'true') {</span><span class="s3">\n      </span><span class="s1">const { interceptTestApis, wrapRequestHandler } =</span><span class="s3">\n        </span><span class="s1">// eslint-disable-next-line @next/internal/typechecked-require -- experimental/testmode is not built ins next/dist/esm</span><span class="s3">\n        </span><span class="s1">require('next/dist/experimental/testmode/server-edge') as typeof import('../../experimental/testmode/server-edge')</span><span class="s3">\n      </span><span class="s1">interceptTestApis()</span><span class="s3">\n      </span><span class="s1">propagator = wrapRequestHandler(propagator)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function adapter(</span><span class="s3">\n  </span><span class="s1">params: AdapterOptions</span><span class="s3">\n</span><span class="s1">): Promise&lt;FetchEventResult&gt; {</span><span class="s3">\n  </span><span class="s1">ensureTestApisIntercepted()</span><span class="s3">\n  </span><span class="s1">await ensureInstrumentationRegistered()</span><span class="s3">\n\n  </span><span class="s1">// TODO-APP: use explicit marker for this</span><span class="s3">\n  </span><span class="s1">const isEdgeRendering =</span><span class="s3">\n    </span><span class="s1">typeof (globalThis as any).__BUILD_MANIFEST !== 'undefined'</span><span class="s3">\n\n  </span><span class="s1">params.request.url = normalizeRscURL(params.request.url)</span><span class="s3">\n\n  </span><span class="s1">const requestURL = params.bypassNextUrl</span><span class="s3">\n    </span><span class="s1">? new URL(params.request.url)</span><span class="s3">\n    </span><span class="s1">: new NextURL(params.request.url, {</span><span class="s3">\n        </span><span class="s1">headers: params.request.headers,</span><span class="s3">\n        </span><span class="s1">nextConfig: params.request.nextConfig,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">// Iterator uses an index to keep track of the current iteration. Because of deleting and appending below we can't just use the iterator.</span><span class="s3">\n  </span><span class="s1">// Instead we use the keys before iteration.</span><span class="s3">\n  </span><span class="s1">const keys = [...requestURL.searchParams.keys()]</span><span class="s3">\n  </span><span class="s1">for (const key of keys) {</span><span class="s3">\n    </span><span class="s1">const value = requestURL.searchParams.getAll(key)</span><span class="s3">\n\n    </span><span class="s1">const normalizedKey = normalizeNextQueryParam(key)</span><span class="s3">\n    </span><span class="s1">if (normalizedKey) {</span><span class="s3">\n      </span><span class="s1">requestURL.searchParams.delete(normalizedKey)</span><span class="s3">\n      </span><span class="s1">for (const val of value) {</span><span class="s3">\n        </span><span class="s1">requestURL.searchParams.append(normalizedKey, val)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">requestURL.searchParams.delete(key)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Ensure users only see page requests, never data requests.</span><span class="s3">\n  </span><span class="s1">let buildId = process.env.__NEXT_BUILD_ID || ''</span><span class="s3">\n  </span><span class="s1">if ('buildId' in requestURL) {</span><span class="s3">\n    </span><span class="s1">buildId = (requestURL as NextURL).buildId || ''</span><span class="s3">\n    </span><span class="s1">requestURL.buildId = ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const requestHeaders = fromNodeOutgoingHttpHeaders(params.request.headers)</span><span class="s3">\n  </span><span class="s1">const isNextDataRequest = requestHeaders.has('x-nextjs-data')</span><span class="s3">\n  </span><span class="s1">const isRSCRequest = requestHeaders.get(RSC_HEADER) === '1'</span><span class="s3">\n\n  </span><span class="s1">if (isNextDataRequest &amp;&amp; requestURL.pathname === '/index') {</span><span class="s3">\n    </span><span class="s1">requestURL.pathname = '/'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const flightHeaders = new Map()</span><span class="s3">\n\n  </span><span class="s1">// Headers should only be stripped for middleware</span><span class="s3">\n  </span><span class="s1">if (!isEdgeRendering) {</span><span class="s3">\n    </span><span class="s1">for (const header of FLIGHT_HEADERS) {</span><span class="s3">\n      </span><span class="s1">const value = requestHeaders.get(header)</span><span class="s3">\n      </span><span class="s1">if (value !== null) {</span><span class="s3">\n        </span><span class="s1">flightHeaders.set(header, value)</span><span class="s3">\n        </span><span class="s1">requestHeaders.delete(header)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const normalizeURL = process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE</span><span class="s3">\n    </span><span class="s1">? new URL(params.request.url)</span><span class="s3">\n    </span><span class="s1">: requestURL</span><span class="s3">\n\n  </span><span class="s1">const rscHash = normalizeURL.searchParams.get(NEXT_RSC_UNION_QUERY)</span><span class="s3">\n\n  </span><span class="s1">const request = new NextRequestHint({</span><span class="s3">\n    </span><span class="s1">page: params.page,</span><span class="s3">\n    </span><span class="s1">// Strip internal query parameters off the request.</span><span class="s3">\n    </span><span class="s1">input: stripInternalSearchParams(normalizeURL).toString(),</span><span class="s3">\n    </span><span class="s1">init: {</span><span class="s3">\n      </span><span class="s1">body: params.request.body,</span><span class="s3">\n      </span><span class="s1">headers: requestHeaders,</span><span class="s3">\n      </span><span class="s1">method: params.request.method,</span><span class="s3">\n      </span><span class="s1">nextConfig: params.request.nextConfig,</span><span class="s3">\n      </span><span class="s1">signal: params.request.signal,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This allows to identify the request as a data request. The user doesn't</span><span class="s3">\n   </span><span class="s1">* need to know about this property neither use it. We add it for testing</span><span class="s3">\n   </span><span class="s1">* purposes.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">if (isNextDataRequest) {</span><span class="s3">\n    </span><span class="s1">Object.defineProperty(request, '__isData', {</span><span class="s3">\n      </span><span class="s1">enumerable: false,</span><span class="s3">\n      </span><span class="s1">value: true,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">// If we are inside of the next start sandbox</span><span class="s3">\n    </span><span class="s1">// leverage the shared instance if not we need</span><span class="s3">\n    </span><span class="s1">// to create a fresh cache instance each time</span><span class="s3">\n    </span><span class="s1">!(globalThis as any).__incrementalCacheShared &amp;&amp;</span><span class="s3">\n    </span><span class="s1">(params as any).IncrementalCache</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">;(globalThis as any).__incrementalCache = new (</span><span class="s3">\n      </span><span class="s1">params as {</span><span class="s3">\n        </span><span class="s1">IncrementalCache: typeof import('../lib/incremental-cache').IncrementalCache</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">).IncrementalCache({</span><span class="s3">\n      </span><span class="s1">CurCacheHandler: params.incrementalCacheHandler,</span><span class="s3">\n      </span><span class="s1">minimalMode: process.env.NODE_ENV !== 'development',</span><span class="s3">\n      </span><span class="s1">fetchCacheKeyPrefix: process.env.__NEXT_FETCH_CACHE_KEY_PREFIX,</span><span class="s3">\n      </span><span class="s1">dev: process.env.NODE_ENV === 'development',</span><span class="s3">\n      </span><span class="s1">requestHeaders: params.request.headers as any,</span><span class="s3">\n\n      </span><span class="s1">getPrerenderManifest: () =&gt; {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">version: -1 as any, // letting us know this doesn't conform to spec</span><span class="s3">\n          </span><span class="s1">routes: {},</span><span class="s3">\n          </span><span class="s1">dynamicRoutes: {},</span><span class="s3">\n          </span><span class="s1">notFoundRoutes: [],</span><span class="s3">\n          </span><span class="s1">preview: getEdgePreviewProps(),</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// if we're in an edge runtime sandbox, we should use the waitUntil</span><span class="s3">\n  </span><span class="s1">// that we receive from the enclosing NextServer</span><span class="s3">\n  </span><span class="s1">const outerWaitUntil =</span><span class="s3">\n    </span><span class="s1">params.request.waitUntil ?? getBuiltinRequestContext()?.waitUntil</span><span class="s3">\n\n  </span><span class="s1">const event = new NextFetchEvent({</span><span class="s3">\n    </span><span class="s1">request,</span><span class="s3">\n    </span><span class="s1">page: params.page,</span><span class="s3">\n    </span><span class="s1">context: outerWaitUntil ? { waitUntil: outerWaitUntil } : undefined,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">let response</span><span class="s3">\n  </span><span class="s1">let cookiesFromResponse</span><span class="s3">\n\n  </span><span class="s1">response = await propagator(request, () =&gt; {</span><span class="s3">\n    </span><span class="s1">// we only care to make async storage available for middleware</span><span class="s3">\n    </span><span class="s1">const isMiddleware =</span><span class="s3">\n      </span><span class="s1">params.page === '/middleware' || params.page === '/src/middleware'</span><span class="s3">\n\n    </span><span class="s1">if (isMiddleware) {</span><span class="s3">\n      </span><span class="s1">// if we're in an edge function, we only get a subset of `nextConfig` (no `experimental`),</span><span class="s3">\n      </span><span class="s1">// so we have to inject it via DefinePlugin.</span><span class="s3">\n      </span><span class="s1">// in `next start` this will be passed normally (see `NextNodeServer.runMiddleware`).</span><span class="s3">\n\n      </span><span class="s1">const waitUntil = event.waitUntil.bind(event)</span><span class="s3">\n      </span><span class="s1">const closeController = new CloseController()</span><span class="s3">\n\n      </span><span class="s1">return getTracer().trace(</span><span class="s3">\n        </span><span class="s1">MiddlewareSpan.execute,</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">spanName: `middleware ${request.method} ${request.nextUrl.pathname}`,</span><span class="s3">\n          </span><span class="s1">attributes: {</span><span class="s3">\n            </span><span class="s1">'http.target': request.nextUrl.pathname,</span><span class="s3">\n            </span><span class="s1">'http.method': request.method,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">async () =&gt; {</span><span class="s3">\n          </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">const onUpdateCookies = (cookies: Array&lt;string&gt;) =&gt; {</span><span class="s3">\n              </span><span class="s1">cookiesFromResponse = cookies</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const previewProps = getEdgePreviewProps()</span><span class="s3">\n            </span><span class="s1">const page = '/' // Fake Work</span><span class="s3">\n            </span><span class="s1">const fallbackRouteParams = null</span><span class="s3">\n\n            </span><span class="s1">const implicitTags = await getImplicitTags(</span><span class="s3">\n              </span><span class="s1">page,</span><span class="s3">\n              </span><span class="s1">request.nextUrl,</span><span class="s3">\n              </span><span class="s1">fallbackRouteParams</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n\n            </span><span class="s1">const requestStore = createRequestStoreForAPI(</span><span class="s3">\n              </span><span class="s1">request,</span><span class="s3">\n              </span><span class="s1">request.nextUrl,</span><span class="s3">\n              </span><span class="s1">implicitTags,</span><span class="s3">\n              </span><span class="s1">onUpdateCookies,</span><span class="s3">\n              </span><span class="s1">previewProps</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n\n            </span><span class="s1">const workStore = createWorkStore({</span><span class="s3">\n              </span><span class="s1">page,</span><span class="s3">\n              </span><span class="s1">renderOpts: {</span><span class="s3">\n                </span><span class="s1">cacheLifeProfiles:</span><span class="s3">\n                  </span><span class="s1">params.request.nextConfig?.experimental?.cacheLife,</span><span class="s3">\n                </span><span class="s1">experimental: {</span><span class="s3">\n                  </span><span class="s1">isRoutePPREnabled: false,</span><span class="s3">\n                  </span><span class="s1">cacheComponents: false,</span><span class="s3">\n                  </span><span class="s1">authInterrupts:</span><span class="s3">\n                    </span><span class="s1">!!params.request.nextConfig?.experimental?.authInterrupts,</span><span class="s3">\n                </span><span class="s1">},</span><span class="s3">\n                </span><span class="s1">supportsDynamicResponse: true,</span><span class="s3">\n                </span><span class="s1">waitUntil,</span><span class="s3">\n                </span><span class="s1">onClose: closeController.onClose.bind(closeController),</span><span class="s3">\n                </span><span class="s1">onAfterTaskError: undefined,</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n              </span><span class="s1">isPrefetchRequest:</span><span class="s3">\n                </span><span class="s1">request.headers.get(NEXT_ROUTER_PREFETCH_HEADER) === '1',</span><span class="s3">\n              </span><span class="s1">buildId: buildId ?? '',</span><span class="s3">\n              </span><span class="s1">previouslyRevalidatedTags: [],</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n\n            </span><span class="s1">return await workAsyncStorage.run(workStore, () =&gt;</span><span class="s3">\n              </span><span class="s1">workUnitAsyncStorage.run(</span><span class="s3">\n                </span><span class="s1">requestStore,</span><span class="s3">\n                </span><span class="s1">params.handler,</span><span class="s3">\n                </span><span class="s1">request,</span><span class="s3">\n                </span><span class="s1">event</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">} finally {</span><span class="s3">\n            </span><span class="s1">// middleware cannot stream, so we can consider the response closed</span><span class="s3">\n            </span><span class="s1">// as soon as the handler returns.</span><span class="s3">\n            </span><span class="s1">// we can delay running it until a bit later --</span><span class="s3">\n            </span><span class="s1">// if it's needed, we'll have a `waitUntil` lock anyway.</span><span class="s3">\n            </span><span class="s1">setTimeout(() =&gt; {</span><span class="s3">\n              </span><span class="s1">closeController.dispatchClose()</span><span class="s3">\n            </span><span class="s1">}, 0)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return params.handler(request, event)</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">// check if response is a Response object</span><span class="s3">\n  </span><span class="s1">if (response &amp;&amp; !(response instanceof Response)) {</span><span class="s3">\n    </span><span class="s1">throw new TypeError('Expected an instance of Response to be returned')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (response &amp;&amp; cookiesFromResponse) {</span><span class="s3">\n    </span><span class="s1">response.headers.set('set-cookie', cookiesFromResponse)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* For rewrites we must always include the locale in the final pathname</span><span class="s3">\n   </span><span class="s1">* so we re-create the NextURL forcing it to include it when the it is</span><span class="s3">\n   </span><span class="s1">* an internal rewrite. Also we make sure the outgoing rewrite URL is</span><span class="s3">\n   </span><span class="s1">* a data URL if the request was a data request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const rewrite = response?.headers.get('x-middleware-rewrite')</span><span class="s3">\n  </span><span class="s1">if (response &amp;&amp; rewrite &amp;&amp; (isRSCRequest || !isEdgeRendering)) {</span><span class="s3">\n    </span><span class="s1">const destination = new NextURL(rewrite, {</span><span class="s3">\n      </span><span class="s1">forceLocale: true,</span><span class="s3">\n      </span><span class="s1">headers: params.request.headers,</span><span class="s3">\n      </span><span class="s1">nextConfig: params.request.nextConfig,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">if (!process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE &amp;&amp; !isEdgeRendering) {</span><span class="s3">\n      </span><span class="s1">if (destination.host === request.nextUrl.host) {</span><span class="s3">\n        </span><span class="s1">destination.buildId = buildId || destination.buildId</span><span class="s3">\n        </span><span class="s1">response.headers.set('x-middleware-rewrite', String(destination))</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* When the request is a data request we must show if there was a rewrite</span><span class="s3">\n     </span><span class="s1">* with an internal header so the client knows which component to load</span><span class="s3">\n     </span><span class="s1">* from the data request.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const { url: relativeDestination, isRelative } = parseRelativeURL(</span><span class="s3">\n      </span><span class="s1">destination.toString(),</span><span class="s3">\n      </span><span class="s1">requestURL.toString()</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!isEdgeRendering &amp;&amp;</span><span class="s3">\n      </span><span class="s1">isNextDataRequest &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// if the rewrite is external and external rewrite</span><span class="s3">\n      </span><span class="s1">// resolving config is enabled don't add this header</span><span class="s3">\n      </span><span class="s1">// so the upstream app can set it instead</span><span class="s3">\n      </span><span class="s1">!(</span><span class="s3">\n        </span><span class="s1">process.env.__NEXT_EXTERNAL_MIDDLEWARE_REWRITE_RESOLVE &amp;&amp;</span><span class="s3">\n        </span><span class="s1">relativeDestination.match(/http(s)?:</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">//)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">response.headers.set('x-nextjs-rewrite', relativeDestination)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If this is an RSC request, and the pathname or search has changed, and</span><span class="s3">\n    </span><span class="s1">// this isn't an external rewrite, we need to set the rewritten pathname and</span><span class="s3">\n    </span><span class="s1">// query headers.</span><span class="s3">\n    </span><span class="s1">if (isRSCRequest &amp;&amp; isRelative) {</span><span class="s3">\n      </span><span class="s1">if (requestURL.pathname !== destination.pathname) {</span><span class="s3">\n        </span><span class="s1">response.headers.set(NEXT_REWRITTEN_PATH_HEADER, destination.pathname)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (requestURL.search !== destination.search) {</span><span class="s3">\n        </span><span class="s1">response.headers.set(</span><span class="s3">\n          </span><span class="s1">NEXT_REWRITTEN_QUERY_HEADER,</span><span class="s3">\n          </span><span class="s1">// remove the leading ? from the search string</span><span class="s3">\n          </span><span class="s1">destination.search.slice(1)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Always forward the `_rsc` search parameter to the rewritten URL for RSC requests,</span><span class="s3">\n   </span><span class="s1">* unless it's already present. This is necessary to ensure that RSC hash validation</span><span class="s3">\n   </span><span class="s1">* works correctly after a rewrite. For internal rewrites, the server can validate the</span><span class="s3">\n   </span><span class="s1">* RSC hash using the original URL, so forwarding the `_rsc` parameter is less critical.</span><span class="s3">\n   </span><span class="s1">* However, for external rewrites (where the request is proxied to another Next.js server),</span><span class="s3">\n   </span><span class="s1">* the external server does not have access to the original URL or its search parameters.</span><span class="s3">\n   </span><span class="s1">* In these cases, forwarding the `_rsc` parameter is essential so that the external server</span><span class="s3">\n   </span><span class="s1">* can perform the correct RSC hash validation.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">if (response &amp;&amp; rewrite &amp;&amp; isRSCRequest &amp;&amp; rscHash) {</span><span class="s3">\n    </span><span class="s1">const rewriteURL = new URL(rewrite)</span><span class="s3">\n    </span><span class="s1">if (!rewriteURL.searchParams.has(NEXT_RSC_UNION_QUERY)) {</span><span class="s3">\n      </span><span class="s1">rewriteURL.searchParams.set(NEXT_RSC_UNION_QUERY, rscHash)</span><span class="s3">\n      </span><span class="s1">response.headers.set('x-middleware-rewrite', rewriteURL.toString())</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* For redirects we will not include the locale in case when it is the</span><span class="s3">\n   </span><span class="s1">* default and we must also make sure the outgoing URL is a data one if</span><span class="s3">\n   </span><span class="s1">* the incoming request was a data request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const redirect = response?.headers.get('Location')</span><span class="s3">\n  </span><span class="s1">if (response &amp;&amp; redirect &amp;&amp; !isEdgeRendering) {</span><span class="s3">\n    </span><span class="s1">const redirectURL = new NextURL(redirect, {</span><span class="s3">\n      </span><span class="s1">forceLocale: false,</span><span class="s3">\n      </span><span class="s1">headers: params.request.headers,</span><span class="s3">\n      </span><span class="s1">nextConfig: params.request.nextConfig,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Responses created from redirects have immutable headers so we have</span><span class="s3">\n     </span><span class="s1">* to clone the response to be able to modify it.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">response = new Response(response.body, response)</span><span class="s3">\n\n    </span><span class="s1">if (!process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE) {</span><span class="s3">\n      </span><span class="s1">if (redirectURL.host === requestURL.host) {</span><span class="s3">\n        </span><span class="s1">redirectURL.buildId = buildId || redirectURL.buildId</span><span class="s3">\n        </span><span class="s1">response.headers.set('Location', redirectURL.toString())</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* When the request is a data request we can't use the location header as</span><span class="s3">\n     </span><span class="s1">* it may end up with CORS error. Instead we map to an internal header so</span><span class="s3">\n     </span><span class="s1">* the client knows the destination.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (isNextDataRequest) {</span><span class="s3">\n      </span><span class="s1">response.headers.delete('Location')</span><span class="s3">\n      </span><span class="s1">response.headers.set(</span><span class="s3">\n        </span><span class="s1">'x-nextjs-redirect',</span><span class="s3">\n        </span><span class="s1">getRelativeURL(redirectURL.toString(), requestURL.toString())</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const finalResponse = response ? response : NextResponse.next()</span><span class="s3">\n\n  </span><span class="s1">// Flight headers are not overridable / removable so they are applied at the end.</span><span class="s3">\n  </span><span class="s1">const middlewareOverrideHeaders = finalResponse.headers.get(</span><span class="s3">\n    </span><span class="s1">'x-middleware-override-headers'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const overwrittenHeaders: string[] = []</span><span class="s3">\n  </span><span class="s1">if (middlewareOverrideHeaders) {</span><span class="s3">\n    </span><span class="s1">for (const [key, value] of flightHeaders) {</span><span class="s3">\n      </span><span class="s1">finalResponse.headers.set(`x-middleware-request-${key}`, value)</span><span class="s3">\n      </span><span class="s1">overwrittenHeaders.push(key)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (overwrittenHeaders.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">finalResponse.headers.set(</span><span class="s3">\n        </span><span class="s1">'x-middleware-override-headers',</span><span class="s3">\n        </span><span class="s1">middlewareOverrideHeaders + ',' + overwrittenHeaders.join(',')</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">response: finalResponse,</span><span class="s3">\n    </span><span class="s1">waitUntil: getWaitUntilPromiseFromEvent(event) ?? Promise.resolve(),</span><span class="s3">\n    </span><span class="s1">fetchMetrics: request.fetchMetrics,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;NextRequestHint&quot;</span><span class="s0">,</span><span class="s1">&quot;adapter&quot;</span><span class="s0">,</span><span class="s1">&quot;NextRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;input&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcePage&quot;</span><span class="s0">,</span><span class="s1">&quot;page&quot;</span><span class="s0">,</span><span class="s1">&quot;request&quot;</span><span class="s0">,</span><span class="s1">&quot;PageSignatureError&quot;</span><span class="s0">,</span><span class="s1">&quot;respondWith&quot;</span><span class="s0">,</span><span class="s1">&quot;waitUntil&quot;</span><span class="s0">,</span><span class="s1">&quot;headersGetter&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;propagator&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;tracer&quot;</span><span class="s0">,</span><span class="s1">&quot;getTracer&quot;</span><span class="s0">,</span><span class="s1">&quot;withPropagatedContext&quot;</span><span class="s0">,</span><span class="s1">&quot;testApisIntercepted&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureTestApisIntercepted&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_PRIVATE_TEST_PROXY&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptTestApis&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapRequestHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;getBuiltinRequestContext&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureInstrumentationRegistered&quot;</span><span class="s0">,</span><span class="s1">&quot;isEdgeRendering&quot;</span><span class="s0">,</span><span class="s1">&quot;globalThis&quot;</span><span class="s0">,</span><span class="s1">&quot;__BUILD_MANIFEST&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeRscURL&quot;</span><span class="s0">,</span><span class="s1">&quot;requestURL&quot;</span><span class="s0">,</span><span class="s1">&quot;bypassNextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;NextURL&quot;</span><span class="s0">,</span><span class="s1">&quot;nextConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;getAll&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeNextQueryParam&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;val&quot;</span><span class="s0">,</span><span class="s1">&quot;append&quot;</span><span class="s0">,</span><span class="s1">&quot;buildId&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_BUILD_ID&quot;</span><span class="s0">,</span><span class="s1">&quot;requestHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;fromNodeOutgoingHttpHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;isNextDataRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;isRSCRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;flightHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;header&quot;</span><span class="s0">,</span><span class="s1">&quot;FLIGHT_HEADERS&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeURL&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_NO_MIDDLEWARE_URL_NORMALIZE&quot;</span><span class="s0">,</span><span class="s1">&quot;rscHash&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_RSC_UNION_QUERY&quot;</span><span class="s0">,</span><span class="s1">&quot;stripInternalSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;signal&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;enumerable&quot;</span><span class="s0">,</span><span class="s1">&quot;__incrementalCacheShared&quot;</span><span class="s0">,</span><span class="s1">&quot;IncrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;__incrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;CurCacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;incrementalCacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;minimalMode&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchCacheKeyPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_FETCH_CACHE_KEY_PREFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;dev&quot;</span><span class="s0">,</span><span class="s1">&quot;getPrerenderManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;version&quot;</span><span class="s0">,</span><span class="s1">&quot;routes&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;notFoundRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;preview&quot;</span><span class="s0">,</span><span class="s1">&quot;getEdgePreviewProps&quot;</span><span class="s0">,</span><span class="s1">&quot;outerWaitUntil&quot;</span><span class="s0">,</span><span class="s1">&quot;event&quot;</span><span class="s0">,</span><span class="s1">&quot;NextFetchEvent&quot;</span><span class="s0">,</span><span class="s1">&quot;context&quot;</span><span class="s0">,</span><span class="s1">&quot;response&quot;</span><span class="s0">,</span><span class="s1">&quot;cookiesFromResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;isMiddleware&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;closeController&quot;</span><span class="s0">,</span><span class="s1">&quot;CloseController&quot;</span><span class="s0">,</span><span class="s1">&quot;trace&quot;</span><span class="s0">,</span><span class="s1">&quot;MiddlewareSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;execute&quot;</span><span class="s0">,</span><span class="s1">&quot;spanName&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;attributes&quot;</span><span class="s0">,</span><span class="s1">&quot;onUpdateCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;cookies&quot;</span><span class="s0">,</span><span class="s1">&quot;previewProps&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackRouteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;implicitTags&quot;</span><span class="s0">,</span><span class="s1">&quot;getImplicitTags&quot;</span><span class="s0">,</span><span class="s1">&quot;requestStore&quot;</span><span class="s0">,</span><span class="s1">&quot;createRequestStoreForAPI&quot;</span><span class="s0">,</span><span class="s1">&quot;workStore&quot;</span><span class="s0">,</span><span class="s1">&quot;createWorkStore&quot;</span><span class="s0">,</span><span class="s1">&quot;renderOpts&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheLifeProfiles&quot;</span><span class="s0">,</span><span class="s1">&quot;experimental&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheLife&quot;</span><span class="s0">,</span><span class="s1">&quot;isRoutePPREnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;authInterrupts&quot;</span><span class="s0">,</span><span class="s1">&quot;supportsDynamicResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;onClose&quot;</span><span class="s0">,</span><span class="s1">&quot;onAfterTaskError&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrefetchRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_PREFETCH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;previouslyRevalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;workAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;run&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;handler&quot;</span><span class="s0">,</span><span class="s1">&quot;setTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;dispatchClose&quot;</span><span class="s0">,</span><span class="s1">&quot;Response&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeError&quot;</span><span class="s0">,</span><span class="s1">&quot;rewrite&quot;</span><span class="s0">,</span><span class="s1">&quot;destination&quot;</span><span class="s0">,</span><span class="s1">&quot;forceLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;host&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;relativeDestination&quot;</span><span class="s0">,</span><span class="s1">&quot;isRelative&quot;</span><span class="s0">,</span><span class="s1">&quot;parseRelativeURL&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_EXTERNAL_MIDDLEWARE_REWRITE_RESOLVE&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_REWRITTEN_PATH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_REWRITTEN_QUERY_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteURL&quot;</span><span class="s0">,</span><span class="s1">&quot;redirect&quot;</span><span class="s0">,</span><span class="s1">&quot;redirectURL&quot;</span><span class="s0">,</span><span class="s1">&quot;getRelativeURL&quot;</span><span class="s0">,</span><span class="s1">&quot;finalResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;NextResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;middlewareOverrideHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;overwrittenHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;getWaitUntilPromiseFromEvent&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchMetrics&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>