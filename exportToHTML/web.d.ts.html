<html>
<head>
<title>web.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #0033b3;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
web.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">type _ByteLengthQueuingStrategy = </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any } ? {}</span>
    <span class="s0">: </span><span class="s1">import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).ByteLengthQueuingStrategy;</span>
<span class="s0">type _CompressionStream = </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any; ReportingObserver: any } ? {}</span>
    <span class="s0">: </span><span class="s1">import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).CompressionStream;</span>
<span class="s0">type _CountQueuingStrategy = </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any } ? {}</span>
    <span class="s0">: </span><span class="s1">import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).CountQueuingStrategy;</span>
<span class="s0">type _DecompressionStream = </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any; ReportingObserver: any } ? {}</span>
    <span class="s0">: </span><span class="s1">import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).DecompressionStream;</span>
<span class="s0">type _QueuingStrategy&lt;T = any&gt; = </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any } ? {}</span>
    <span class="s0">: </span><span class="s1">import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).QueuingStrategy&lt;T&gt;;</span>
<span class="s0">type _ReadableByteStreamController = </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any } ? {}</span>
    <span class="s0">: </span><span class="s1">import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).ReadableByteStreamController;</span>
<span class="s0">type _ReadableStream&lt;R = any&gt; = </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any } ? {}</span>
    <span class="s0">: </span><span class="s1">import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).ReadableStream&lt;R&gt;;</span>
<span class="s0">type _ReadableStreamBYOBReader = </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any } ? {}</span>
    <span class="s0">: </span><span class="s1">import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).ReadableStreamBYOBReader;</span>
<span class="s0">type _ReadableStreamBYOBRequest = </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any } ? {}</span>
    <span class="s0">: </span><span class="s1">import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).ReadableStreamBYOBRequest;</span>
<span class="s0">type _ReadableStreamDefaultController&lt;R = any&gt; = </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any } ? {}</span>
    <span class="s0">: </span><span class="s1">import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).ReadableStreamDefaultController&lt;R&gt;;</span>
<span class="s0">type _ReadableStreamDefaultReader&lt;R = any&gt; = </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any } ? {}</span>
    <span class="s0">: </span><span class="s1">import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).ReadableStreamDefaultReader&lt;R&gt;;</span>
<span class="s0">type _TextDecoderStream = </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any } ? {}</span>
    <span class="s0">: </span><span class="s1">import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).TextDecoderStream;</span>
<span class="s0">type _TextEncoderStream = </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any } ? {}</span>
    <span class="s0">: </span><span class="s1">import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).TextEncoderStream;</span>
<span class="s0">type _TransformStream&lt;I = any, O = any&gt; = </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any } ? {}</span>
    <span class="s0">: </span><span class="s1">import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).TransformStream&lt;I, O&gt;;</span>
<span class="s0">type _TransformStreamDefaultController&lt;O = any&gt; = </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any } ? {}</span>
    <span class="s0">: </span><span class="s1">import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).TransformStreamDefaultController&lt;O&gt;;</span>
<span class="s0">type _WritableStream&lt;W = any&gt; = </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any } ? {}</span>
    <span class="s0">: </span><span class="s1">import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).WritableStream&lt;W&gt;;</span>
<span class="s0">type _WritableStreamDefaultController = </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any } ? {}</span>
    <span class="s0">: </span><span class="s1">import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).WritableStreamDefaultController;</span>
<span class="s0">type _WritableStreamDefaultWriter&lt;W = any&gt; = </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any } ? {}</span>
    <span class="s0">: </span><span class="s1">import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).WritableStreamDefaultWriter&lt;W&gt;;</span>

<span class="s0">declare module </span><span class="s2">&quot;stream/web&quot; </span><span class="s0">{</span>
    <span class="s3">// stub module, pending copy&amp;paste from .d.ts or manual impl</span>
    <span class="s3">// copy from lib.dom.d.ts</span>
    <span class="s1">interface </span><span class="s0">ReadableWritablePair&lt;R = any, W = any&gt; {</span>
        <span class="s0">readable: ReadableStream&lt;R&gt;;</span>
        <span class="s3">/**</span>
         <span class="s3">* Provides a convenient, chainable way of piping this readable stream</span>
         <span class="s3">* through a transform stream (or any other { writable, readable }</span>
         <span class="s3">* pair). It simply pipes the stream into the writable side of the</span>
         <span class="s3">* supplied pair, and returns the readable side for further use.</span>
         <span class="s3">*</span>
         <span class="s3">* Piping a stream will lock it for the duration of the pipe, preventing</span>
         <span class="s3">* any other consumer from acquiring a reader.</span>
         <span class="s3">*/</span>
        <span class="s0">writable: WritableStream&lt;W&gt;;</span>
    <span class="s0">}</span>
    <span class="s1">interface </span><span class="s0">StreamPipeOptions {</span>
        <span class="s0">preventAbort?: boolean;</span>
        <span class="s0">preventCancel?: boolean;</span>
        <span class="s3">/**</span>
         <span class="s3">* Pipes this readable stream to a given writable stream destination.</span>
         <span class="s3">* The way in which the piping process behaves under various error</span>
         <span class="s3">* conditions can be customized with a number of passed options. It</span>
         <span class="s3">* returns a promise that fulfills when the piping process completes</span>
         <span class="s3">* successfully, or rejects if any errors were encountered.</span>
         <span class="s3">*</span>
         <span class="s3">* Piping a stream will lock it for the duration of the pipe, preventing</span>
         <span class="s3">* any other consumer from acquiring a reader.</span>
         <span class="s3">*</span>
         <span class="s3">* Errors and closures of the source and destination streams propagate</span>
         <span class="s3">* as follows:</span>
         <span class="s3">*</span>
         <span class="s3">* An error in this source readable stream will abort destination,</span>
         <span class="s3">* unless preventAbort is truthy. The returned promise will be rejected</span>
         <span class="s3">* with the source's error, or with any error that occurs during</span>
         <span class="s3">* aborting the destination.</span>
         <span class="s3">*</span>
         <span class="s3">* An error in destination will cancel this source readable stream,</span>
         <span class="s3">* unless preventCancel is truthy. The returned promise will be rejected</span>
         <span class="s3">* with the destination's error, or with any error that occurs during</span>
         <span class="s3">* canceling the source.</span>
         <span class="s3">*</span>
         <span class="s3">* When this source readable stream closes, destination will be closed,</span>
         <span class="s3">* unless preventClose is truthy. The returned promise will be fulfilled</span>
         <span class="s3">* once this process completes, unless an error is encountered while</span>
         <span class="s3">* closing the destination, in which case it will be rejected with that</span>
         <span class="s3">* error.</span>
         <span class="s3">*</span>
         <span class="s3">* If destination starts out closed or closing, this source readable</span>
         <span class="s3">* stream will be canceled, unless preventCancel is true. The returned</span>
         <span class="s3">* promise will be rejected with an error indicating piping to a closed</span>
         <span class="s3">* stream failed, or with any error that occurs during canceling the</span>
         <span class="s3">* source.</span>
         <span class="s3">*</span>
         <span class="s3">* The signal option can be set to an AbortSignal to allow aborting an</span>
         <span class="s3">* ongoing pipe operation via the corresponding AbortController. In this</span>
         <span class="s3">* case, this source readable stream will be canceled, and destination</span>
         <span class="s3">* aborted, unless the respective options preventCancel or preventAbort</span>
         <span class="s3">* are set.</span>
         <span class="s3">*/</span>
        <span class="s0">preventClose?: boolean;</span>
        <span class="s0">signal?: AbortSignal;</span>
    <span class="s0">}</span>
    <span class="s1">interface </span><span class="s0">ReadableStreamGenericReader {</span>
        <span class="s0">readonly closed: Promise&lt;</span><span class="s1">void</span><span class="s0">&gt;;</span>
        <span class="s0">cancel(reason?: any): Promise&lt;</span><span class="s1">void</span><span class="s0">&gt;;</span>
    <span class="s0">}</span>
    <span class="s0">type ReadableStreamController&lt;T&gt; = ReadableStreamDefaultController&lt;T&gt;;</span>
    <span class="s1">interface </span><span class="s0">ReadableStreamReadValueResult&lt;T&gt; {</span>
        <span class="s0">done: </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">value: T;</span>
    <span class="s0">}</span>
    <span class="s1">interface </span><span class="s0">ReadableStreamReadDoneResult&lt;T&gt; {</span>
        <span class="s0">done: </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">value?: T;</span>
    <span class="s0">}</span>
    <span class="s0">type ReadableStreamReadResult&lt;T&gt; = ReadableStreamReadValueResult&lt;T&gt; | ReadableStreamReadDoneResult&lt;T&gt;;</span>
    <span class="s1">interface </span><span class="s0">ReadableByteStreamControllerCallback {</span>
        <span class="s0">(controller: ReadableByteStreamController): </span><span class="s1">void </span><span class="s0">| PromiseLike&lt;</span><span class="s1">void</span><span class="s0">&gt;;</span>
    <span class="s0">}</span>
    <span class="s1">interface </span><span class="s0">UnderlyingSinkAbortCallback {</span>
        <span class="s0">(reason?: any): </span><span class="s1">void </span><span class="s0">| PromiseLike&lt;</span><span class="s1">void</span><span class="s0">&gt;;</span>
    <span class="s0">}</span>
    <span class="s1">interface </span><span class="s0">UnderlyingSinkCloseCallback {</span>
        <span class="s0">(): </span><span class="s1">void </span><span class="s0">| PromiseLike&lt;</span><span class="s1">void</span><span class="s0">&gt;;</span>
    <span class="s0">}</span>
    <span class="s1">interface </span><span class="s0">UnderlyingSinkStartCallback {</span>
        <span class="s0">(controller: WritableStreamDefaultController): any;</span>
    <span class="s0">}</span>
    <span class="s1">interface </span><span class="s0">UnderlyingSinkWriteCallback&lt;W&gt; {</span>
        <span class="s0">(chunk: W, controller: WritableStreamDefaultController): </span><span class="s1">void </span><span class="s0">| PromiseLike&lt;</span><span class="s1">void</span><span class="s0">&gt;;</span>
    <span class="s0">}</span>
    <span class="s1">interface </span><span class="s0">UnderlyingSourceCancelCallback {</span>
        <span class="s0">(reason?: any): </span><span class="s1">void </span><span class="s0">| PromiseLike&lt;</span><span class="s1">void</span><span class="s0">&gt;;</span>
    <span class="s0">}</span>
    <span class="s1">interface </span><span class="s0">UnderlyingSourcePullCallback&lt;R&gt; {</span>
        <span class="s0">(controller: ReadableStreamController&lt;R&gt;): </span><span class="s1">void </span><span class="s0">| PromiseLike&lt;</span><span class="s1">void</span><span class="s0">&gt;;</span>
    <span class="s0">}</span>
    <span class="s1">interface </span><span class="s0">UnderlyingSourceStartCallback&lt;R&gt; {</span>
        <span class="s0">(controller: ReadableStreamController&lt;R&gt;): any;</span>
    <span class="s0">}</span>
    <span class="s1">interface </span><span class="s0">TransformerFlushCallback&lt;O&gt; {</span>
        <span class="s0">(controller: TransformStreamDefaultController&lt;O&gt;): </span><span class="s1">void </span><span class="s0">| PromiseLike&lt;</span><span class="s1">void</span><span class="s0">&gt;;</span>
    <span class="s0">}</span>
    <span class="s1">interface </span><span class="s0">TransformerStartCallback&lt;O&gt; {</span>
        <span class="s0">(controller: TransformStreamDefaultController&lt;O&gt;): any;</span>
    <span class="s0">}</span>
    <span class="s1">interface </span><span class="s0">TransformerTransformCallback&lt;I, O&gt; {</span>
        <span class="s0">(chunk: I, controller: TransformStreamDefaultController&lt;O&gt;): </span><span class="s1">void </span><span class="s0">| PromiseLike&lt;</span><span class="s1">void</span><span class="s0">&gt;;</span>
    <span class="s0">}</span>
    <span class="s1">interface </span><span class="s0">UnderlyingByteSource {</span>
        <span class="s0">autoAllocateChunkSize?: number;</span>
        <span class="s0">cancel?: ReadableStreamErrorCallback;</span>
        <span class="s0">pull?: ReadableByteStreamControllerCallback;</span>
        <span class="s0">start?: ReadableByteStreamControllerCallback;</span>
        <span class="s0">type: </span><span class="s2">&quot;bytes&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">interface </span><span class="s0">UnderlyingSource&lt;R = any&gt; {</span>
        <span class="s0">cancel?: UnderlyingSourceCancelCallback;</span>
        <span class="s0">pull?: UnderlyingSourcePullCallback&lt;R&gt;;</span>
        <span class="s0">start?: UnderlyingSourceStartCallback&lt;R&gt;;</span>
        <span class="s0">type?: undefined;</span>
    <span class="s0">}</span>
    <span class="s1">interface </span><span class="s0">UnderlyingSink&lt;W = any&gt; {</span>
        <span class="s0">abort?: UnderlyingSinkAbortCallback;</span>
        <span class="s0">close?: UnderlyingSinkCloseCallback;</span>
        <span class="s0">start?: UnderlyingSinkStartCallback;</span>
        <span class="s0">type?: undefined;</span>
        <span class="s0">write?: UnderlyingSinkWriteCallback&lt;W&gt;;</span>
    <span class="s0">}</span>
    <span class="s1">interface </span><span class="s0">ReadableStreamErrorCallback {</span>
        <span class="s0">(reason: any): </span><span class="s1">void </span><span class="s0">| PromiseLike&lt;</span><span class="s1">void</span><span class="s0">&gt;;</span>
    <span class="s0">}</span>
    <span class="s1">interface </span><span class="s0">ReadableStreamAsyncIterator&lt;T&gt; </span><span class="s1">extends </span><span class="s0">NodeJS.AsyncIterator&lt;T, NodeJS.BuiltinIteratorReturn, unknown&gt; {</span>
        <span class="s0">[Symbol.asyncIterator](): ReadableStreamAsyncIterator&lt;T&gt;;</span>
    <span class="s0">}</span>
    <span class="s3">/** This Streams API interface represents a readable stream of byte data. */</span>
    <span class="s1">interface </span><span class="s0">ReadableStream&lt;R = any&gt; {</span>
        <span class="s0">readonly locked: boolean;</span>
        <span class="s0">cancel(reason?: any): Promise&lt;</span><span class="s1">void</span><span class="s0">&gt;;</span>
        <span class="s0">getReader(options: { mode: </span><span class="s2">&quot;byob&quot; </span><span class="s0">}): ReadableStreamBYOBReader;</span>
        <span class="s0">getReader(): ReadableStreamDefaultReader&lt;R&gt;;</span>
        <span class="s0">getReader(options?: ReadableStreamGetReaderOptions): ReadableStreamReader&lt;R&gt;;</span>
        <span class="s0">pipeThrough&lt;T&gt;(transform: ReadableWritablePair&lt;T, R&gt;, options?: StreamPipeOptions): ReadableStream&lt;T&gt;;</span>
        <span class="s0">pipeTo(destination: WritableStream&lt;R&gt;, options?: StreamPipeOptions): Promise&lt;</span><span class="s1">void</span><span class="s0">&gt;;</span>
        <span class="s0">tee(): [ReadableStream&lt;R&gt;, ReadableStream&lt;R&gt;];</span>
        <span class="s0">values(options?: { preventCancel?: boolean }): ReadableStreamAsyncIterator&lt;R&gt;;</span>
        <span class="s0">[Symbol.asyncIterator](): ReadableStreamAsyncIterator&lt;R&gt;;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">ReadableStream: {</span>
        <span class="s0">prototype: ReadableStream;</span>
        <span class="s0">from&lt;T&gt;(iterable: Iterable&lt;T&gt; | AsyncIterable&lt;T&gt;): ReadableStream&lt;T&gt;;</span>
        <span class="s1">new</span><span class="s0">(underlyingSource: UnderlyingByteSource, strategy?: QueuingStrategy&lt;Uint8Array&gt;): ReadableStream&lt;Uint8Array&gt;;</span>
        <span class="s1">new</span><span class="s0">&lt;R = any&gt;(underlyingSource?: UnderlyingSource&lt;R&gt;, strategy?: QueuingStrategy&lt;R&gt;): ReadableStream&lt;R&gt;;</span>
    <span class="s0">};</span>
    <span class="s0">type ReadableStreamReaderMode = </span><span class="s2">&quot;byob&quot;</span><span class="s0">;</span>
    <span class="s1">interface </span><span class="s0">ReadableStreamGetReaderOptions {</span>
        <span class="s3">/**</span>
         <span class="s3">* Creates a ReadableStreamBYOBReader and locks the stream to the new reader.</span>
         <span class="s3">*</span>
         <span class="s3">* This call behaves the same way as the no-argument variant, except that it only works on readable byte streams, i.e. streams which were constructed specifically with the ability to handle &quot;bring your own buffer&quot; reading. The returned BYOB reader provides the ability to directly read individual chunks from the stream via its read() method, into developer-supplied buffers, allowing more precise control over allocation.</span>
         <span class="s3">*/</span>
        <span class="s0">mode?: ReadableStreamReaderMode;</span>
    <span class="s0">}</span>
    <span class="s0">type ReadableStreamReader&lt;T&gt; = ReadableStreamDefaultReader&lt;T&gt; | ReadableStreamBYOBReader;</span>
    <span class="s1">interface </span><span class="s0">ReadableStreamDefaultReader&lt;R = any&gt; </span><span class="s1">extends </span><span class="s0">ReadableStreamGenericReader {</span>
        <span class="s0">read(): Promise&lt;ReadableStreamReadResult&lt;R&gt;&gt;;</span>
        <span class="s0">releaseLock(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBReader) */</span>
    <span class="s1">interface </span><span class="s0">ReadableStreamBYOBReader </span><span class="s1">extends </span><span class="s0">ReadableStreamGenericReader {</span>
        <span class="s3">/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBReader/read) */</span>
        <span class="s0">read&lt;T </span><span class="s1">extends </span><span class="s0">ArrayBufferView&gt;(</span>
            <span class="s0">view: T,</span>
            <span class="s0">options?: {</span>
                <span class="s0">min?: number;</span>
            <span class="s0">},</span>
        <span class="s0">): Promise&lt;ReadableStreamReadResult&lt;T&gt;&gt;;</span>
        <span class="s3">/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBReader/releaseLock) */</span>
        <span class="s0">releaseLock(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">ReadableStreamDefaultReader: {</span>
        <span class="s0">prototype: ReadableStreamDefaultReader;</span>
        <span class="s1">new</span><span class="s0">&lt;R = any&gt;(stream: ReadableStream&lt;R&gt;): ReadableStreamDefaultReader&lt;R&gt;;</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">ReadableStreamBYOBReader: {</span>
        <span class="s0">prototype: ReadableStreamBYOBReader;</span>
        <span class="s1">new</span><span class="s0">(stream: ReadableStream): ReadableStreamBYOBReader;</span>
    <span class="s0">};</span>
    <span class="s3">/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest) */</span>
    <span class="s1">interface </span><span class="s0">ReadableStreamBYOBRequest {</span>
        <span class="s3">/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest/view) */</span>
        <span class="s0">readonly view: ArrayBufferView | </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s3">/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest/respond) */</span>
        <span class="s0">respond(bytesWritten: number): </span><span class="s1">void</span><span class="s0">;</span>
        <span class="s3">/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest/respondWithNewView) */</span>
        <span class="s0">respondWithNewView(view: ArrayBufferView): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">ReadableStreamBYOBRequest: {</span>
        <span class="s0">prototype: ReadableStreamBYOBRequest;</span>
        <span class="s1">new</span><span class="s0">(): ReadableStreamBYOBRequest;</span>
    <span class="s0">};</span>
    <span class="s1">interface </span><span class="s0">ReadableByteStreamController {</span>
        <span class="s0">readonly byobRequest: undefined;</span>
        <span class="s0">readonly desiredSize: number | </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">close(): </span><span class="s1">void</span><span class="s0">;</span>
        <span class="s0">enqueue(chunk: ArrayBufferView): </span><span class="s1">void</span><span class="s0">;</span>
        <span class="s0">error(error?: any): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">ReadableByteStreamController: {</span>
        <span class="s0">prototype: ReadableByteStreamController;</span>
        <span class="s1">new</span><span class="s0">(): ReadableByteStreamController;</span>
    <span class="s0">};</span>
    <span class="s1">interface </span><span class="s0">ReadableStreamDefaultController&lt;R = any&gt; {</span>
        <span class="s0">readonly desiredSize: number | </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">close(): </span><span class="s1">void</span><span class="s0">;</span>
        <span class="s0">enqueue(chunk?: R): </span><span class="s1">void</span><span class="s0">;</span>
        <span class="s0">error(e?: any): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">ReadableStreamDefaultController: {</span>
        <span class="s0">prototype: ReadableStreamDefaultController;</span>
        <span class="s1">new</span><span class="s0">(): ReadableStreamDefaultController;</span>
    <span class="s0">};</span>
    <span class="s1">interface </span><span class="s0">Transformer&lt;I = any, O = any&gt; {</span>
        <span class="s0">flush?: TransformerFlushCallback&lt;O&gt;;</span>
        <span class="s0">readableType?: undefined;</span>
        <span class="s0">start?: TransformerStartCallback&lt;O&gt;;</span>
        <span class="s0">transform?: TransformerTransformCallback&lt;I, O&gt;;</span>
        <span class="s0">writableType?: undefined;</span>
    <span class="s0">}</span>
    <span class="s1">interface </span><span class="s0">TransformStream&lt;I = any, O = any&gt; {</span>
        <span class="s0">readonly readable: ReadableStream&lt;O&gt;;</span>
        <span class="s0">readonly writable: WritableStream&lt;I&gt;;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">TransformStream: {</span>
        <span class="s0">prototype: TransformStream;</span>
        <span class="s1">new</span><span class="s0">&lt;I = any, O = any&gt;(</span>
            <span class="s0">transformer?: Transformer&lt;I, O&gt;,</span>
            <span class="s0">writableStrategy?: QueuingStrategy&lt;I&gt;,</span>
            <span class="s0">readableStrategy?: QueuingStrategy&lt;O&gt;,</span>
        <span class="s0">): TransformStream&lt;I, O&gt;;</span>
    <span class="s0">};</span>
    <span class="s1">interface </span><span class="s0">TransformStreamDefaultController&lt;O = any&gt; {</span>
        <span class="s0">readonly desiredSize: number | </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">enqueue(chunk?: O): </span><span class="s1">void</span><span class="s0">;</span>
        <span class="s0">error(reason?: any): </span><span class="s1">void</span><span class="s0">;</span>
        <span class="s0">terminate(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">TransformStreamDefaultController: {</span>
        <span class="s0">prototype: TransformStreamDefaultController;</span>
        <span class="s1">new</span><span class="s0">(): TransformStreamDefaultController;</span>
    <span class="s0">};</span>
    <span class="s3">/**</span>
     <span class="s3">* This Streams API interface provides a standard abstraction for writing</span>
     <span class="s3">* streaming data to a destination, known as a sink. This object comes with</span>
     <span class="s3">* built-in back pressure and queuing.</span>
     <span class="s3">*/</span>
    <span class="s1">interface </span><span class="s0">WritableStream&lt;W = any&gt; {</span>
        <span class="s0">readonly locked: boolean;</span>
        <span class="s0">abort(reason?: any): Promise&lt;</span><span class="s1">void</span><span class="s0">&gt;;</span>
        <span class="s0">close(): Promise&lt;</span><span class="s1">void</span><span class="s0">&gt;;</span>
        <span class="s0">getWriter(): WritableStreamDefaultWriter&lt;W&gt;;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">WritableStream: {</span>
        <span class="s0">prototype: WritableStream;</span>
        <span class="s1">new</span><span class="s0">&lt;W = any&gt;(underlyingSink?: UnderlyingSink&lt;W&gt;, strategy?: QueuingStrategy&lt;W&gt;): WritableStream&lt;W&gt;;</span>
    <span class="s0">};</span>
    <span class="s3">/**</span>
     <span class="s3">* This Streams API interface is the object returned by</span>
     <span class="s3">* WritableStream.getWriter() and once created locks the &lt; writer to the</span>
     <span class="s3">* WritableStream ensuring that no other streams can write to the underlying</span>
     <span class="s3">* sink.</span>
     <span class="s3">*/</span>
    <span class="s1">interface </span><span class="s0">WritableStreamDefaultWriter&lt;W = any&gt; {</span>
        <span class="s0">readonly closed: Promise&lt;</span><span class="s1">void</span><span class="s0">&gt;;</span>
        <span class="s0">readonly desiredSize: number | </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">readonly ready: Promise&lt;</span><span class="s1">void</span><span class="s0">&gt;;</span>
        <span class="s0">abort(reason?: any): Promise&lt;</span><span class="s1">void</span><span class="s0">&gt;;</span>
        <span class="s0">close(): Promise&lt;</span><span class="s1">void</span><span class="s0">&gt;;</span>
        <span class="s0">releaseLock(): </span><span class="s1">void</span><span class="s0">;</span>
        <span class="s0">write(chunk?: W): Promise&lt;</span><span class="s1">void</span><span class="s0">&gt;;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">WritableStreamDefaultWriter: {</span>
        <span class="s0">prototype: WritableStreamDefaultWriter;</span>
        <span class="s1">new</span><span class="s0">&lt;W = any&gt;(stream: WritableStream&lt;W&gt;): WritableStreamDefaultWriter&lt;W&gt;;</span>
    <span class="s0">};</span>
    <span class="s3">/**</span>
     <span class="s3">* This Streams API interface represents a controller allowing control of a</span>
     <span class="s3">* WritableStream's state. When constructing a WritableStream, the</span>
     <span class="s3">* underlying sink is given a corresponding WritableStreamDefaultController</span>
     <span class="s3">* instance to manipulate.</span>
     <span class="s3">*/</span>
    <span class="s1">interface </span><span class="s0">WritableStreamDefaultController {</span>
        <span class="s0">error(e?: any): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">WritableStreamDefaultController: {</span>
        <span class="s0">prototype: WritableStreamDefaultController;</span>
        <span class="s1">new</span><span class="s0">(): WritableStreamDefaultController;</span>
    <span class="s0">};</span>
    <span class="s1">interface </span><span class="s0">QueuingStrategy&lt;T = any&gt; {</span>
        <span class="s0">highWaterMark?: number;</span>
        <span class="s0">size?: QueuingStrategySize&lt;T&gt;;</span>
    <span class="s0">}</span>
    <span class="s1">interface </span><span class="s0">QueuingStrategySize&lt;T = any&gt; {</span>
        <span class="s0">(chunk?: T): number;</span>
    <span class="s0">}</span>
    <span class="s1">interface </span><span class="s0">QueuingStrategyInit {</span>
        <span class="s3">/**</span>
         <span class="s3">* Creates a new ByteLengthQueuingStrategy with the provided high water</span>
         <span class="s3">* mark.</span>
         <span class="s3">*</span>
         <span class="s3">* Note that the provided high water mark will not be validated ahead of</span>
         <span class="s3">* time. Instead, if it is negative, NaN, or not a number, the resulting</span>
         <span class="s3">* ByteLengthQueuingStrategy will cause the corresponding stream</span>
         <span class="s3">* constructor to throw.</span>
         <span class="s3">*/</span>
        <span class="s0">highWaterMark: number;</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* This Streams API interface provides a built-in byte length queuing</span>
     <span class="s3">* strategy that can be used when constructing streams.</span>
     <span class="s3">*/</span>
    <span class="s1">interface </span><span class="s0">ByteLengthQueuingStrategy </span><span class="s1">extends </span><span class="s0">QueuingStrategy&lt;ArrayBufferView&gt; {</span>
        <span class="s0">readonly highWaterMark: number;</span>
        <span class="s0">readonly size: QueuingStrategySize&lt;ArrayBufferView&gt;;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">ByteLengthQueuingStrategy: {</span>
        <span class="s0">prototype: ByteLengthQueuingStrategy;</span>
        <span class="s1">new</span><span class="s0">(init: QueuingStrategyInit): ByteLengthQueuingStrategy;</span>
    <span class="s0">};</span>
    <span class="s3">/**</span>
     <span class="s3">* This Streams API interface provides a built-in byte length queuing</span>
     <span class="s3">* strategy that can be used when constructing streams.</span>
     <span class="s3">*/</span>
    <span class="s1">interface </span><span class="s0">CountQueuingStrategy </span><span class="s1">extends </span><span class="s0">QueuingStrategy {</span>
        <span class="s0">readonly highWaterMark: number;</span>
        <span class="s0">readonly size: QueuingStrategySize;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">CountQueuingStrategy: {</span>
        <span class="s0">prototype: CountQueuingStrategy;</span>
        <span class="s1">new</span><span class="s0">(init: QueuingStrategyInit): CountQueuingStrategy;</span>
    <span class="s0">};</span>
    <span class="s1">interface </span><span class="s0">TextEncoderStream {</span>
        <span class="s3">/** Returns &quot;utf-8&quot;. */</span>
        <span class="s0">readonly encoding: </span><span class="s2">&quot;utf-8&quot;</span><span class="s0">;</span>
        <span class="s0">readonly readable: ReadableStream&lt;Uint8Array&gt;;</span>
        <span class="s0">readonly writable: WritableStream&lt;string&gt;;</span>
        <span class="s0">readonly [Symbol.toStringTag]: string;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">TextEncoderStream: {</span>
        <span class="s0">prototype: TextEncoderStream;</span>
        <span class="s1">new</span><span class="s0">(): TextEncoderStream;</span>
    <span class="s0">};</span>
    <span class="s1">interface </span><span class="s0">TextDecoderOptions {</span>
        <span class="s0">fatal?: boolean;</span>
        <span class="s0">ignoreBOM?: boolean;</span>
    <span class="s0">}</span>
    <span class="s0">type BufferSource = ArrayBufferView | ArrayBuffer;</span>
    <span class="s1">interface </span><span class="s0">TextDecoderStream {</span>
        <span class="s3">/** Returns encoding's name, lower cased. */</span>
        <span class="s0">readonly encoding: string;</span>
        <span class="s3">/** Returns `true` if error mode is &quot;fatal&quot;, and `false` otherwise. */</span>
        <span class="s0">readonly fatal: boolean;</span>
        <span class="s3">/** Returns `true` if ignore BOM flag is set, and `false` otherwise. */</span>
        <span class="s0">readonly ignoreBOM: boolean;</span>
        <span class="s0">readonly readable: ReadableStream&lt;string&gt;;</span>
        <span class="s0">readonly writable: WritableStream&lt;BufferSource&gt;;</span>
        <span class="s0">readonly [Symbol.toStringTag]: string;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">TextDecoderStream: {</span>
        <span class="s0">prototype: TextDecoderStream;</span>
        <span class="s1">new</span><span class="s0">(encoding?: string, options?: TextDecoderOptions): TextDecoderStream;</span>
    <span class="s0">};</span>
    <span class="s1">interface </span><span class="s0">CompressionStream {</span>
        <span class="s0">readonly readable: ReadableStream;</span>
        <span class="s0">readonly writable: WritableStream;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">CompressionStream: {</span>
        <span class="s0">prototype: CompressionStream;</span>
        <span class="s1">new</span><span class="s0">(format: </span><span class="s2">&quot;deflate&quot; </span><span class="s0">| </span><span class="s2">&quot;deflate-raw&quot; </span><span class="s0">| </span><span class="s2">&quot;gzip&quot;</span><span class="s0">): CompressionStream;</span>
    <span class="s0">};</span>
    <span class="s1">interface </span><span class="s0">DecompressionStream {</span>
        <span class="s0">readonly writable: WritableStream;</span>
        <span class="s0">readonly readable: ReadableStream;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">DecompressionStream: {</span>
        <span class="s0">prototype: DecompressionStream;</span>
        <span class="s1">new</span><span class="s0">(format: </span><span class="s2">&quot;deflate&quot; </span><span class="s0">| </span><span class="s2">&quot;deflate-raw&quot; </span><span class="s0">| </span><span class="s2">&quot;gzip&quot;</span><span class="s0">): DecompressionStream;</span>
    <span class="s0">};</span>

    <span class="s0">global {</span>
        <span class="s1">interface </span><span class="s0">ByteLengthQueuingStrategy </span><span class="s1">extends </span><span class="s0">_ByteLengthQueuingStrategy {}</span>
        <span class="s1">var </span><span class="s0">ByteLengthQueuingStrategy: </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any; ByteLengthQueuingStrategy: infer T }</span>
            <span class="s0">? T</span>
            <span class="s0">: </span><span class="s1">typeof import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).ByteLengthQueuingStrategy;</span>

        <span class="s1">interface </span><span class="s0">CompressionStream </span><span class="s1">extends </span><span class="s0">_CompressionStream {}</span>
        <span class="s1">var </span><span class="s0">CompressionStream: </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{</span>
            <span class="s0">onmessage: any;</span>
            <span class="s3">// CompressionStream, DecompressionStream and ReportingObserver was introduced in the same commit.</span>
            <span class="s3">// If ReportingObserver check is removed, the type here will form a circular reference in TS5.0+lib.dom.d.ts</span>
            <span class="s0">ReportingObserver: any;</span>
            <span class="s0">CompressionStream: infer T;</span>
        <span class="s0">} ? T</span>
            <span class="s3">// TS 4.8, 4.9, 5.0</span>
            <span class="s0">: </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any; TransformStream: { prototype: infer T } } ? {</span>
                    <span class="s0">prototype: T;</span>
                    <span class="s1">new</span><span class="s0">(format: </span><span class="s2">&quot;deflate&quot; </span><span class="s0">| </span><span class="s2">&quot;deflate-raw&quot; </span><span class="s0">| </span><span class="s2">&quot;gzip&quot;</span><span class="s0">): T;</span>
                <span class="s0">}</span>
            <span class="s0">: </span><span class="s1">typeof import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).CompressionStream;</span>

        <span class="s1">interface </span><span class="s0">CountQueuingStrategy </span><span class="s1">extends </span><span class="s0">_CountQueuingStrategy {}</span>
        <span class="s1">var </span><span class="s0">CountQueuingStrategy: </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any; CountQueuingStrategy: infer T } ? T</span>
            <span class="s0">: </span><span class="s1">typeof import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).CountQueuingStrategy;</span>

        <span class="s1">interface </span><span class="s0">DecompressionStream </span><span class="s1">extends </span><span class="s0">_DecompressionStream {}</span>
        <span class="s1">var </span><span class="s0">DecompressionStream: </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{</span>
            <span class="s0">onmessage: any;</span>
            <span class="s3">// CompressionStream, DecompressionStream and ReportingObserver was introduced in the same commit.</span>
            <span class="s3">// If ReportingObserver check is removed, the type here will form a circular reference in TS5.0+lib.dom.d.ts</span>
            <span class="s0">ReportingObserver: any;</span>
            <span class="s0">DecompressionStream: infer T;</span>
        <span class="s0">} ? T</span>
            <span class="s3">// TS 4.8, 4.9, 5.0</span>
            <span class="s0">: </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any; TransformStream: { prototype: infer T } } ? {</span>
                    <span class="s0">prototype: T;</span>
                    <span class="s1">new</span><span class="s0">(format: </span><span class="s2">&quot;deflate&quot; </span><span class="s0">| </span><span class="s2">&quot;deflate-raw&quot; </span><span class="s0">| </span><span class="s2">&quot;gzip&quot;</span><span class="s0">): T;</span>
                <span class="s0">}</span>
            <span class="s0">: </span><span class="s1">typeof import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).DecompressionStream;</span>

        <span class="s1">interface </span><span class="s0">QueuingStrategy&lt;T = any&gt; </span><span class="s1">extends </span><span class="s0">_QueuingStrategy&lt;T&gt; {}</span>

        <span class="s1">interface </span><span class="s0">ReadableByteStreamController </span><span class="s1">extends </span><span class="s0">_ReadableByteStreamController {}</span>
        <span class="s1">var </span><span class="s0">ReadableByteStreamController: </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends</span>
            <span class="s0">{ onmessage: any; ReadableByteStreamController: infer T } ? T</span>
            <span class="s0">: </span><span class="s1">typeof import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).ReadableByteStreamController;</span>

        <span class="s1">interface </span><span class="s0">ReadableStream&lt;R = any&gt; </span><span class="s1">extends </span><span class="s0">_ReadableStream&lt;R&gt; {}</span>
        <span class="s1">var </span><span class="s0">ReadableStream: </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any; ReadableStream: infer T } ? T</span>
            <span class="s0">: </span><span class="s1">typeof import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).ReadableStream;</span>

        <span class="s1">interface </span><span class="s0">ReadableStreamBYOBReader </span><span class="s1">extends </span><span class="s0">_ReadableStreamBYOBReader {}</span>
        <span class="s1">var </span><span class="s0">ReadableStreamBYOBReader: </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any; ReadableStreamBYOBReader: infer T }</span>
            <span class="s0">? T</span>
            <span class="s0">: </span><span class="s1">typeof import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).ReadableStreamBYOBReader;</span>

        <span class="s1">interface </span><span class="s0">ReadableStreamBYOBRequest </span><span class="s1">extends </span><span class="s0">_ReadableStreamBYOBRequest {}</span>
        <span class="s1">var </span><span class="s0">ReadableStreamBYOBRequest: </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any; ReadableStreamBYOBRequest: infer T }</span>
            <span class="s0">? T</span>
            <span class="s0">: </span><span class="s1">typeof import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).ReadableStreamBYOBRequest;</span>

        <span class="s1">interface </span><span class="s0">ReadableStreamDefaultController&lt;R = any&gt; </span><span class="s1">extends </span><span class="s0">_ReadableStreamDefaultController&lt;R&gt; {}</span>
        <span class="s1">var </span><span class="s0">ReadableStreamDefaultController: </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends</span>
            <span class="s0">{ onmessage: any; ReadableStreamDefaultController: infer T } ? T</span>
            <span class="s0">: </span><span class="s1">typeof import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).ReadableStreamDefaultController;</span>

        <span class="s1">interface </span><span class="s0">ReadableStreamDefaultReader&lt;R = any&gt; </span><span class="s1">extends </span><span class="s0">_ReadableStreamDefaultReader&lt;R&gt; {}</span>
        <span class="s1">var </span><span class="s0">ReadableStreamDefaultReader: </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends</span>
            <span class="s0">{ onmessage: any; ReadableStreamDefaultReader: infer T } ? T</span>
            <span class="s0">: </span><span class="s1">typeof import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).ReadableStreamDefaultReader;</span>

        <span class="s1">interface </span><span class="s0">TextDecoderStream </span><span class="s1">extends </span><span class="s0">_TextDecoderStream {}</span>
        <span class="s1">var </span><span class="s0">TextDecoderStream: </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any; TextDecoderStream: infer T } ? T</span>
            <span class="s0">: </span><span class="s1">typeof import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).TextDecoderStream;</span>

        <span class="s1">interface </span><span class="s0">TextEncoderStream </span><span class="s1">extends </span><span class="s0">_TextEncoderStream {}</span>
        <span class="s1">var </span><span class="s0">TextEncoderStream: </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any; TextEncoderStream: infer T } ? T</span>
            <span class="s0">: </span><span class="s1">typeof import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).TextEncoderStream;</span>

        <span class="s1">interface </span><span class="s0">TransformStream&lt;I = any, O = any&gt; </span><span class="s1">extends </span><span class="s0">_TransformStream&lt;I, O&gt; {}</span>
        <span class="s1">var </span><span class="s0">TransformStream: </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any; TransformStream: infer T } ? T</span>
            <span class="s0">: </span><span class="s1">typeof import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).TransformStream;</span>

        <span class="s1">interface </span><span class="s0">TransformStreamDefaultController&lt;O = any&gt; </span><span class="s1">extends </span><span class="s0">_TransformStreamDefaultController&lt;O&gt; {}</span>
        <span class="s1">var </span><span class="s0">TransformStreamDefaultController: </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends</span>
            <span class="s0">{ onmessage: any; TransformStreamDefaultController: infer T } ? T</span>
            <span class="s0">: </span><span class="s1">typeof import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).TransformStreamDefaultController;</span>

        <span class="s1">interface </span><span class="s0">WritableStream&lt;W = any&gt; </span><span class="s1">extends </span><span class="s0">_WritableStream&lt;W&gt; {}</span>
        <span class="s1">var </span><span class="s0">WritableStream: </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends </span><span class="s0">{ onmessage: any; WritableStream: infer T } ? T</span>
            <span class="s0">: </span><span class="s1">typeof import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).WritableStream;</span>

        <span class="s1">interface </span><span class="s0">WritableStreamDefaultController </span><span class="s1">extends </span><span class="s0">_WritableStreamDefaultController {}</span>
        <span class="s1">var </span><span class="s0">WritableStreamDefaultController: </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends</span>
            <span class="s0">{ onmessage: any; WritableStreamDefaultController: infer T } ? T</span>
            <span class="s0">: </span><span class="s1">typeof import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).WritableStreamDefaultController;</span>

        <span class="s1">interface </span><span class="s0">WritableStreamDefaultWriter&lt;W = any&gt; </span><span class="s1">extends </span><span class="s0">_WritableStreamDefaultWriter&lt;W&gt; {}</span>
        <span class="s1">var </span><span class="s0">WritableStreamDefaultWriter: </span><span class="s1">typeof </span><span class="s0">globalThis </span><span class="s1">extends</span>
            <span class="s0">{ onmessage: any; WritableStreamDefaultWriter: infer T } ? T</span>
            <span class="s0">: </span><span class="s1">typeof import</span><span class="s0">(</span><span class="s2">&quot;stream/web&quot;</span><span class="s0">).WritableStreamDefaultWriter;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">declare module </span><span class="s2">&quot;node:stream/web&quot; </span><span class="s0">{</span>
    <span class="s1">export </span><span class="s0">* from </span><span class="s2">&quot;stream/web&quot;</span><span class="s0">;</span>
<span class="s0">}</span>
</pre>
</body>
</html>