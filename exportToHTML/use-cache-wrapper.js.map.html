<html>
<head>
<title>use-cache-wrapper.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
use-cache-wrapper.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/use-cache/use-cache-wrapper.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { DeepReadonly } from '../../shared/lib/deep-readonly'</span><span class="s3">\n</span><span class="s1">/* eslint-disable import/no-extraneous-dependencies */</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">renderToReadableStream,</span><span class="s3">\n  </span><span class="s1">decodeReply,</span><span class="s3">\n  </span><span class="s1">decodeReplyFromAsyncIterable,</span><span class="s3">\n  </span><span class="s1">createTemporaryReferenceSet as createServerTemporaryReferenceSet,</span><span class="s3">\n</span><span class="s1">} from 'react-server-dom-webpack/server'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">createFromReadableStream,</span><span class="s3">\n  </span><span class="s1">encodeReply,</span><span class="s3">\n  </span><span class="s1">createTemporaryReferenceSet as createClientTemporaryReferenceSet,</span><span class="s3">\n</span><span class="s1">} from 'react-server-dom-webpack/client'</span><span class="s3">\n</span><span class="s1">import { unstable_prerender as prerender } from 'react-server-dom-webpack/static'</span><span class="s3">\n</span><span class="s1">/* eslint-enable import/no-extraneous-dependencies */</span><span class="s3">\n\n</span><span class="s1">import type { WorkStore } from '../app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { workAsyncStorage } from '../app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">PrerenderStoreModernClient,</span><span class="s3">\n  </span><span class="s1">PrerenderStoreModernRuntime,</span><span class="s3">\n  </span><span class="s1">PrivateUseCacheStore,</span><span class="s3">\n  </span><span class="s1">RequestStore,</span><span class="s3">\n  </span><span class="s1">RevalidateStore,</span><span class="s3">\n  </span><span class="s1">UseCacheStore,</span><span class="s3">\n  </span><span class="s1">WorkUnitStore,</span><span class="s3">\n</span><span class="s1">} from '../app-render/work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getHmrRefreshHash,</span><span class="s3">\n  </span><span class="s1">getRenderResumeDataCache,</span><span class="s3">\n  </span><span class="s1">getPrerenderResumeDataCache,</span><span class="s3">\n  </span><span class="s1">workUnitAsyncStorage,</span><span class="s3">\n  </span><span class="s1">getDraftModeProviderForCacheScope,</span><span class="s3">\n  </span><span class="s1">getCacheSignal,</span><span class="s3">\n  </span><span class="s1">isHmrRefresh,</span><span class="s3">\n  </span><span class="s1">getServerComponentsHmrCache,</span><span class="s3">\n  </span><span class="s1">getRuntimeStagePromise,</span><span class="s3">\n</span><span class="s1">} from '../app-render/work-unit-async-storage.external'</span><span class="s3">\n\n</span><span class="s1">import { makeHangingPromise } from '../dynamic-rendering-utils'</span><span class="s3">\n\n</span><span class="s1">import type { ClientReferenceManifestForRsc } from '../../build/webpack/plugins/flight-manifest-plugin'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getClientReferenceManifestForRsc,</span><span class="s3">\n  </span><span class="s1">getServerModuleMap,</span><span class="s3">\n</span><span class="s1">} from '../app-render/encryption-utils'</span><span class="s3">\n</span><span class="s1">import type { CacheEntry } from '../lib/cache-handlers/types'</span><span class="s3">\n</span><span class="s1">import type { CacheSignal } from '../app-render/cache-signal'</span><span class="s3">\n</span><span class="s1">import { decryptActionBoundArgs } from '../app-render/encryption'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../../shared/lib/invariant-error'</span><span class="s3">\n</span><span class="s1">import { getDigestForWellKnownError } from '../app-render/create-error-handler'</span><span class="s3">\n</span><span class="s1">import { DYNAMIC_EXPIRE, RUNTIME_PREFETCH_DYNAMIC_STALE } from './constants'</span><span class="s3">\n</span><span class="s1">import { getCacheHandler } from './handlers'</span><span class="s3">\n</span><span class="s1">import { UseCacheTimeoutError } from './use-cache-errors'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">createHangingInputAbortSignal,</span><span class="s3">\n  </span><span class="s1">postponeWithTracking,</span><span class="s3">\n  </span><span class="s1">throwToInterruptStaticGeneration,</span><span class="s3">\n</span><span class="s1">} from '../app-render/dynamic-rendering'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">makeErroringSearchParamsForUseCache,</span><span class="s3">\n  </span><span class="s1">type SearchParams,</span><span class="s3">\n</span><span class="s1">} from '../request/search-params'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../request/params'</span><span class="s3">\n</span><span class="s1">import React from 'react'</span><span class="s3">\n</span><span class="s1">import { createLazyResult, isResolvedLazyResult } from '../lib/lazy-result'</span><span class="s3">\n</span><span class="s1">import { dynamicAccessAsyncStorage } from '../app-render/dynamic-access-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { isReactLargeShellError } from '../app-render/react-large-shell-error'</span><span class="s3">\n</span><span class="s1">import type { CacheLife } from './cache-life'</span><span class="s3">\n\n</span><span class="s1">interface PrivateCacheContext {</span><span class="s3">\n  </span><span class="s1">readonly kind: 'private'</span><span class="s3">\n  </span><span class="s1">readonly outerWorkUnitStore:</span><span class="s3">\n    </span><span class="s1">| RequestStore</span><span class="s3">\n    </span><span class="s1">| PrivateUseCacheStore</span><span class="s3">\n    </span><span class="s1">| PrerenderStoreModernRuntime</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface PublicCacheContext {</span><span class="s3">\n  </span><span class="s1">readonly kind: 'public'</span><span class="s3">\n  </span><span class="s1">// TODO: We should probably forbid nesting </span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot; </span><span class="s1">inside unstable_cache.</span><span class="s3">\n  </span><span class="s1">readonly outerWorkUnitStore:</span><span class="s3">\n    </span><span class="s1">| Exclude&lt;WorkUnitStore, PrerenderStoreModernClient&gt;</span><span class="s3">\n    </span><span class="s1">| undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type CacheContext = PrivateCacheContext | PublicCacheContext</span><span class="s3">\n\n</span><span class="s1">type CacheKeyParts =</span><span class="s3">\n  </span><span class="s1">| [buildId: string, id: string, args: unknown[]]</span><span class="s3">\n  </span><span class="s1">| [buildId: string, id: string, args: unknown[], hmrRefreshHash: string]</span><span class="s3">\n\n</span><span class="s1">interface UseCacheInnerPageComponentProps {</span><span class="s3">\n  </span><span class="s1">params: Promise&lt;Params&gt;</span><span class="s3">\n  </span><span class="s1">searchParams?: Promise&lt;SearchParams&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface UseCachePageComponentProps {</span><span class="s3">\n  </span><span class="s1">params: Promise&lt;Params&gt;</span><span class="s3">\n  </span><span class="s1">searchParams: Promise&lt;SearchParams&gt;</span><span class="s3">\n  </span><span class="s1">$$isPageComponent: true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type UseCacheLayoutComponentProps = {</span><span class="s3">\n  </span><span class="s1">params: Promise&lt;Params&gt;</span><span class="s3">\n  </span><span class="s1">$$isLayoutComponent: true</span><span class="s3">\n</span><span class="s1">} &amp; {</span><span class="s3">\n  </span><span class="s1">// The value type should be React.ReactNode. But such an index signature would</span><span class="s3">\n  </span><span class="s1">// be incompatible with the other two props.</span><span class="s3">\n  </span><span class="s1">[slot: string]: any</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'</span><span class="s3">\n\n</span><span class="s1">const debug = process.env.NEXT_PRIVATE_DEBUG_CACHE</span><span class="s3">\n  </span><span class="s1">? console.debug.bind(console, 'use-cache:')</span><span class="s3">\n  </span><span class="s1">: undefined</span><span class="s3">\n\n</span><span class="s1">const filterStackFrame =</span><span class="s3">\n  </span><span class="s1">process.env.NODE_ENV !== 'production'</span><span class="s3">\n    </span><span class="s1">? (require('../lib/source-maps') as typeof import('../lib/source-maps'))</span><span class="s3">\n        </span><span class="s1">.filterStackFrameDEV</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n</span><span class="s1">const findSourceMapURL =</span><span class="s3">\n  </span><span class="s1">process.env.NODE_ENV !== 'production'</span><span class="s3">\n    </span><span class="s1">? (require('../lib/source-maps') as typeof import('../lib/source-maps'))</span><span class="s3">\n        </span><span class="s1">.findSourceMapURLDEV</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n\n</span><span class="s1">function generateCacheEntry(</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">cacheContext: CacheContext,</span><span class="s3">\n  </span><span class="s1">clientReferenceManifest: DeepReadonly&lt;ClientReferenceManifestForRsc&gt;,</span><span class="s3">\n  </span><span class="s1">encodedArguments: FormData | string,</span><span class="s3">\n  </span><span class="s1">fn: (...args: unknown[]) =&gt; Promise&lt;unknown&gt;,</span><span class="s3">\n  </span><span class="s1">sharedErrorStack: string | undefined</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// We need to run this inside a clean AsyncLocalStorage snapshot so that the cache</span><span class="s3">\n  </span><span class="s1">// generation cannot read anything from the context we're currently executing which</span><span class="s3">\n  </span><span class="s1">// might include request specific things like cookies() inside a React.cache().</span><span class="s3">\n  </span><span class="s1">// Note: It is important that we await at least once before this because it lets us</span><span class="s3">\n  </span><span class="s1">// pop out of any stack specific contexts as well - aka </span><span class="s3">\&quot;</span><span class="s1">Sync</span><span class="s3">\&quot; </span><span class="s1">Local Storage.</span><span class="s3">\n  </span><span class="s1">return workStore.runInCleanSnapshot(</span><span class="s3">\n    </span><span class="s1">generateCacheEntryWithRestoredWorkStore,</span><span class="s3">\n    </span><span class="s1">workStore,</span><span class="s3">\n    </span><span class="s1">cacheContext,</span><span class="s3">\n    </span><span class="s1">clientReferenceManifest,</span><span class="s3">\n    </span><span class="s1">encodedArguments,</span><span class="s3">\n    </span><span class="s1">fn,</span><span class="s3">\n    </span><span class="s1">sharedErrorStack</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function generateCacheEntryWithRestoredWorkStore(</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">cacheContext: CacheContext,</span><span class="s3">\n  </span><span class="s1">clientReferenceManifest: DeepReadonly&lt;ClientReferenceManifestForRsc&gt;,</span><span class="s3">\n  </span><span class="s1">encodedArguments: FormData | string,</span><span class="s3">\n  </span><span class="s1">fn: (...args: unknown[]) =&gt; Promise&lt;unknown&gt;,</span><span class="s3">\n  </span><span class="s1">sharedErrorStack: string | undefined</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// Since we cleared the AsyncLocalStorage we need to restore the workStore.</span><span class="s3">\n  </span><span class="s1">// Note: We explicitly don't restore the RequestStore nor the PrerenderStore.</span><span class="s3">\n  </span><span class="s1">// We don't want any request specific information leaking an we don't want to create a</span><span class="s3">\n  </span><span class="s1">// bloated fake request mock for every cache call. So any feature that currently lives</span><span class="s3">\n  </span><span class="s1">// in RequestStore but should be available to Caches need to move to WorkStore.</span><span class="s3">\n  </span><span class="s1">// PrerenderStore is not needed inside the cache scope because the outer most one will</span><span class="s3">\n  </span><span class="s1">// be the one to report its result to the outer Prerender.</span><span class="s3">\n  </span><span class="s1">return workAsyncStorage.run(</span><span class="s3">\n    </span><span class="s1">workStore,</span><span class="s3">\n    </span><span class="s1">generateCacheEntryWithCacheContext,</span><span class="s3">\n    </span><span class="s1">workStore,</span><span class="s3">\n    </span><span class="s1">cacheContext,</span><span class="s3">\n    </span><span class="s1">clientReferenceManifest,</span><span class="s3">\n    </span><span class="s1">encodedArguments,</span><span class="s3">\n    </span><span class="s1">fn,</span><span class="s3">\n    </span><span class="s1">sharedErrorStack</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createUseCacheStore(</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">cacheContext: CacheContext,</span><span class="s3">\n  </span><span class="s1">defaultCacheLife: Required&lt;CacheLife&gt;</span><span class="s3">\n</span><span class="s1">): UseCacheStore {</span><span class="s3">\n  </span><span class="s1">if (cacheContext.kind === 'private') {</span><span class="s3">\n    </span><span class="s1">const outerWorkUnitStore = cacheContext.outerWorkUnitStore</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">type: 'private-cache',</span><span class="s3">\n      </span><span class="s1">phase: 'render',</span><span class="s3">\n      </span><span class="s1">implicitTags: outerWorkUnitStore?.implicitTags,</span><span class="s3">\n      </span><span class="s1">revalidate: defaultCacheLife.revalidate,</span><span class="s3">\n      </span><span class="s1">expire: defaultCacheLife.expire,</span><span class="s3">\n      </span><span class="s1">stale: defaultCacheLife.stale,</span><span class="s3">\n      </span><span class="s1">explicitRevalidate: undefined,</span><span class="s3">\n      </span><span class="s1">explicitExpire: undefined,</span><span class="s3">\n      </span><span class="s1">explicitStale: undefined,</span><span class="s3">\n      </span><span class="s1">tags: null,</span><span class="s3">\n      </span><span class="s1">hmrRefreshHash: getHmrRefreshHash(workStore, outerWorkUnitStore),</span><span class="s3">\n      </span><span class="s1">isHmrRefresh: isHmrRefresh(workStore, outerWorkUnitStore),</span><span class="s3">\n      </span><span class="s1">serverComponentsHmrCache: getServerComponentsHmrCache(</span><span class="s3">\n        </span><span class="s1">workStore,</span><span class="s3">\n        </span><span class="s1">outerWorkUnitStore</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">forceRevalidate: shouldForceRevalidate(workStore, outerWorkUnitStore),</span><span class="s3">\n      </span><span class="s1">runtimeStagePromise: getRuntimeStagePromise(outerWorkUnitStore),</span><span class="s3">\n      </span><span class="s1">draftMode: getDraftModeProviderForCacheScope(</span><span class="s3">\n        </span><span class="s1">workStore,</span><span class="s3">\n        </span><span class="s1">outerWorkUnitStore</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">rootParams: outerWorkUnitStore.rootParams,</span><span class="s3">\n      </span><span class="s1">cookies: outerWorkUnitStore.cookies,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">let useCacheOrRequestStore: RequestStore | UseCacheStore | undefined</span><span class="s3">\n    </span><span class="s1">const outerWorkUnitStore = cacheContext.outerWorkUnitStore</span><span class="s3">\n\n    </span><span class="s1">if (outerWorkUnitStore) {</span><span class="s3">\n      </span><span class="s1">switch (outerWorkUnitStore?.type) {</span><span class="s3">\n        </span><span class="s1">case 'cache':</span><span class="s3">\n        </span><span class="s1">case 'private-cache':</span><span class="s3">\n        </span><span class="s1">case 'request':</span><span class="s3">\n          </span><span class="s1">useCacheOrRequestStore = outerWorkUnitStore</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n        </span><span class="s1">case 'prerender':</span><span class="s3">\n        </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n        </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n        </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n          </span><span class="s1">outerWorkUnitStore satisfies never</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">type: 'cache',</span><span class="s3">\n      </span><span class="s1">phase: 'render',</span><span class="s3">\n      </span><span class="s1">implicitTags: outerWorkUnitStore?.implicitTags,</span><span class="s3">\n      </span><span class="s1">revalidate: defaultCacheLife.revalidate,</span><span class="s3">\n      </span><span class="s1">expire: defaultCacheLife.expire,</span><span class="s3">\n      </span><span class="s1">stale: defaultCacheLife.stale,</span><span class="s3">\n      </span><span class="s1">explicitRevalidate: undefined,</span><span class="s3">\n      </span><span class="s1">explicitExpire: undefined,</span><span class="s3">\n      </span><span class="s1">explicitStale: undefined,</span><span class="s3">\n      </span><span class="s1">tags: null,</span><span class="s3">\n      </span><span class="s1">hmrRefreshHash:</span><span class="s3">\n        </span><span class="s1">outerWorkUnitStore &amp;&amp; getHmrRefreshHash(workStore, outerWorkUnitStore),</span><span class="s3">\n      </span><span class="s1">isHmrRefresh: useCacheOrRequestStore?.isHmrRefresh ?? false,</span><span class="s3">\n      </span><span class="s1">serverComponentsHmrCache:</span><span class="s3">\n        </span><span class="s1">useCacheOrRequestStore?.serverComponentsHmrCache,</span><span class="s3">\n      </span><span class="s1">forceRevalidate: shouldForceRevalidate(workStore, outerWorkUnitStore),</span><span class="s3">\n      </span><span class="s1">draftMode:</span><span class="s3">\n        </span><span class="s1">outerWorkUnitStore &amp;&amp;</span><span class="s3">\n        </span><span class="s1">getDraftModeProviderForCacheScope(workStore, outerWorkUnitStore),</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function assertDefaultCacheLife(</span><span class="s3">\n  </span><span class="s1">defaultCacheLife: CacheLife | undefined</span><span class="s3">\n</span><span class="s1">): asserts defaultCacheLife is Required&lt;CacheLife&gt; {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">!defaultCacheLife ||</span><span class="s3">\n    </span><span class="s1">defaultCacheLife.revalidate == null ||</span><span class="s3">\n    </span><span class="s1">defaultCacheLife.expire == null ||</span><span class="s3">\n    </span><span class="s1">defaultCacheLife.stale == null</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new InvariantError(</span><span class="s3">\n      </span><span class="s1">'A default cacheLife profile must always be provided.'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function generateCacheEntryWithCacheContext(</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">cacheContext: CacheContext,</span><span class="s3">\n  </span><span class="s1">clientReferenceManifest: DeepReadonly&lt;ClientReferenceManifestForRsc&gt;,</span><span class="s3">\n  </span><span class="s1">encodedArguments: FormData | string,</span><span class="s3">\n  </span><span class="s1">fn: (...args: unknown[]) =&gt; Promise&lt;unknown&gt;,</span><span class="s3">\n  </span><span class="s1">sharedErrorStack: string | undefined</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!workStore.cacheLifeProfiles) {</span><span class="s3">\n    </span><span class="s1">throw new InvariantError('cacheLifeProfiles should always be provided.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const defaultCacheLife = workStore.cacheLifeProfiles['default']</span><span class="s3">\n  </span><span class="s1">assertDefaultCacheLife(defaultCacheLife)</span><span class="s3">\n\n  </span><span class="s1">// Initialize the Store for this Cache entry.</span><span class="s3">\n  </span><span class="s1">const cacheStore = createUseCacheStore(</span><span class="s3">\n    </span><span class="s1">workStore,</span><span class="s3">\n    </span><span class="s1">cacheContext,</span><span class="s3">\n    </span><span class="s1">defaultCacheLife</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">return workUnitAsyncStorage.run(cacheStore, () =&gt;</span><span class="s3">\n    </span><span class="s1">dynamicAccessAsyncStorage.run(</span><span class="s3">\n      </span><span class="s1">{ abortController: new AbortController() },</span><span class="s3">\n      </span><span class="s1">generateCacheEntryImpl,</span><span class="s3">\n      </span><span class="s1">workStore,</span><span class="s3">\n      </span><span class="s1">cacheContext,</span><span class="s3">\n      </span><span class="s1">cacheStore,</span><span class="s3">\n      </span><span class="s1">clientReferenceManifest,</span><span class="s3">\n      </span><span class="s1">encodedArguments,</span><span class="s3">\n      </span><span class="s1">fn,</span><span class="s3">\n      </span><span class="s1">sharedErrorStack</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function propagateCacheLifeAndTagsToRevalidateStore(</span><span class="s3">\n  </span><span class="s1">revalidateStore: RevalidateStore,</span><span class="s3">\n  </span><span class="s1">entry: CacheEntry</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const outerTags = (revalidateStore.tags ??= [])</span><span class="s3">\n\n  </span><span class="s1">for (const tag of entry.tags) {</span><span class="s3">\n    </span><span class="s1">if (!outerTags.includes(tag)) {</span><span class="s3">\n      </span><span class="s1">outerTags.push(tag)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (revalidateStore.stale &gt; entry.stale) {</span><span class="s3">\n    </span><span class="s1">revalidateStore.stale = entry.stale</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (revalidateStore.revalidate &gt; entry.revalidate) {</span><span class="s3">\n    </span><span class="s1">revalidateStore.revalidate = entry.revalidate</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (revalidateStore.expire &gt; entry.expire) {</span><span class="s3">\n    </span><span class="s1">revalidateStore.expire = entry.expire</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function propagateCacheLifeAndTags(</span><span class="s3">\n  </span><span class="s1">cacheContext: CacheContext,</span><span class="s3">\n  </span><span class="s1">entry: CacheEntry</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">if (cacheContext.kind === 'private') {</span><span class="s3">\n    </span><span class="s1">switch (cacheContext.outerWorkUnitStore.type) {</span><span class="s3">\n      </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n      </span><span class="s1">case 'private-cache':</span><span class="s3">\n        </span><span class="s1">propagateCacheLifeAndTagsToRevalidateStore(</span><span class="s3">\n          </span><span class="s1">cacheContext.outerWorkUnitStore,</span><span class="s3">\n          </span><span class="s1">entry</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">case 'request':</span><span class="s3">\n      </span><span class="s1">case undefined:</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">cacheContext.outerWorkUnitStore satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">switch (cacheContext.outerWorkUnitStore?.type) {</span><span class="s3">\n      </span><span class="s1">case 'cache':</span><span class="s3">\n      </span><span class="s1">case 'private-cache':</span><span class="s3">\n      </span><span class="s1">case 'prerender':</span><span class="s3">\n      </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n      </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n      </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n        </span><span class="s1">propagateCacheLifeAndTagsToRevalidateStore(</span><span class="s3">\n          </span><span class="s1">cacheContext.outerWorkUnitStore,</span><span class="s3">\n          </span><span class="s1">entry</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">case 'request':</span><span class="s3">\n      </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n      </span><span class="s1">case undefined:</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">cacheContext.outerWorkUnitStore satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function collectResult(</span><span class="s3">\n  </span><span class="s1">savedStream: ReadableStream,</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">cacheContext: CacheContext,</span><span class="s3">\n  </span><span class="s1">innerCacheStore: UseCacheStore,</span><span class="s3">\n  </span><span class="s1">startTime: number,</span><span class="s3">\n  </span><span class="s1">errors: Array&lt;unknown&gt; // This is a live array that gets pushed into.</span><span class="s3">\n</span><span class="s1">): Promise&lt;CacheEntry&gt; {</span><span class="s3">\n  </span><span class="s1">// We create a buffered stream that collects all chunks until the end to</span><span class="s3">\n  </span><span class="s1">// ensure that RSC has finished rendering and therefore we have collected</span><span class="s3">\n  </span><span class="s1">// all tags. In the future the RSC API might allow for the equivalent of</span><span class="s3">\n  </span><span class="s1">// the allReady Promise that exists on SSR streams.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// If something errored or rejected anywhere in the render, we close</span><span class="s3">\n  </span><span class="s1">// the stream as errored. This lets a CacheHandler choose to save the</span><span class="s3">\n  </span><span class="s1">// partial result up until that point for future hits for a while to avoid</span><span class="s3">\n  </span><span class="s1">// unnecessary retries or not to retry. We use the end of the stream for</span><span class="s3">\n  </span><span class="s1">// this to avoid another complicated side-channel. A receiver has to consider</span><span class="s3">\n  </span><span class="s1">// that the stream might also error for other reasons anyway such as losing</span><span class="s3">\n  </span><span class="s1">// connection.</span><span class="s3">\n\n  </span><span class="s1">const buffer: any[] = []</span><span class="s3">\n  </span><span class="s1">const reader = savedStream.getReader()</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">for (let entry; !(entry = await reader.read()).done; ) {</span><span class="s3">\n      </span><span class="s1">buffer.push(entry.value)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} catch (error) {</span><span class="s3">\n    </span><span class="s1">errors.push(error)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let idx = 0</span><span class="s3">\n  </span><span class="s1">const bufferStream = new ReadableStream({</span><span class="s3">\n    </span><span class="s1">pull(controller) {</span><span class="s3">\n      </span><span class="s1">if (workStore.invalidDynamicUsageError) {</span><span class="s3">\n        </span><span class="s1">controller.error(workStore.invalidDynamicUsageError)</span><span class="s3">\n      </span><span class="s1">} else if (idx &lt; buffer.length) {</span><span class="s3">\n        </span><span class="s1">controller.enqueue(buffer[idx++])</span><span class="s3">\n      </span><span class="s1">} else if (errors.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">// TODO: Should we use AggregateError here?</span><span class="s3">\n        </span><span class="s1">controller.error(errors[0])</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">controller.close()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const collectedTags = innerCacheStore.tags</span><span class="s3">\n  </span><span class="s1">// If cacheLife() was used to set an explicit revalidate time we use that.</span><span class="s3">\n  </span><span class="s1">// Otherwise, we use the lowest of all inner fetch()/unstable_cache() or nested </span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n  </span><span class="s1">// If they're lower than our default.</span><span class="s3">\n  </span><span class="s1">const collectedRevalidate =</span><span class="s3">\n    </span><span class="s1">innerCacheStore.explicitRevalidate !== undefined</span><span class="s3">\n      </span><span class="s1">? innerCacheStore.explicitRevalidate</span><span class="s3">\n      </span><span class="s1">: innerCacheStore.revalidate</span><span class="s3">\n  </span><span class="s1">const collectedExpire =</span><span class="s3">\n    </span><span class="s1">innerCacheStore.explicitExpire !== undefined</span><span class="s3">\n      </span><span class="s1">? innerCacheStore.explicitExpire</span><span class="s3">\n      </span><span class="s1">: innerCacheStore.expire</span><span class="s3">\n  </span><span class="s1">const collectedStale =</span><span class="s3">\n    </span><span class="s1">innerCacheStore.explicitStale !== undefined</span><span class="s3">\n      </span><span class="s1">? innerCacheStore.explicitStale</span><span class="s3">\n      </span><span class="s1">: innerCacheStore.stale</span><span class="s3">\n\n  </span><span class="s1">const entry: CacheEntry = {</span><span class="s3">\n    </span><span class="s1">value: bufferStream,</span><span class="s3">\n    </span><span class="s1">timestamp: startTime,</span><span class="s3">\n    </span><span class="s1">revalidate: collectedRevalidate,</span><span class="s3">\n    </span><span class="s1">expire: collectedExpire,</span><span class="s3">\n    </span><span class="s1">stale: collectedStale,</span><span class="s3">\n    </span><span class="s1">tags: collectedTags === null ? [] : collectedTags,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Propagate tags/revalidate to the parent context.</span><span class="s3">\n  </span><span class="s1">if (cacheContext) {</span><span class="s3">\n    </span><span class="s1">propagateCacheLifeAndTags(cacheContext, entry)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const cacheSignal = cacheContext.outerWorkUnitStore</span><span class="s3">\n    </span><span class="s1">? getCacheSignal(cacheContext.outerWorkUnitStore)</span><span class="s3">\n    </span><span class="s1">: null</span><span class="s3">\n\n  </span><span class="s1">if (cacheSignal) {</span><span class="s3">\n    </span><span class="s1">cacheSignal.endRead()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return entry</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type GenerateCacheEntryResult =</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">readonly type: 'cached'</span><span class="s3">\n      </span><span class="s1">readonly stream: ReadableStream</span><span class="s3">\n      </span><span class="s1">readonly pendingCacheEntry: Promise&lt;CacheEntry&gt;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">readonly type: 'prerender-dynamic'</span><span class="s3">\n      </span><span class="s1">readonly hangingPromise: Promise&lt;never&gt;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function generateCacheEntryImpl(</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">cacheContext: CacheContext,</span><span class="s3">\n  </span><span class="s1">innerCacheStore: UseCacheStore,</span><span class="s3">\n  </span><span class="s1">clientReferenceManifest: DeepReadonly&lt;ClientReferenceManifestForRsc&gt;,</span><span class="s3">\n  </span><span class="s1">encodedArguments: FormData | string,</span><span class="s3">\n  </span><span class="s1">fn: (...args: unknown[]) =&gt; Promise&lt;unknown&gt;,</span><span class="s3">\n  </span><span class="s1">sharedErrorStack: string | undefined</span><span class="s3">\n</span><span class="s1">): Promise&lt;GenerateCacheEntryResult&gt; {</span><span class="s3">\n  </span><span class="s1">const temporaryReferences = createServerTemporaryReferenceSet()</span><span class="s3">\n  </span><span class="s1">const outerWorkUnitStore = cacheContext.outerWorkUnitStore</span><span class="s3">\n\n  </span><span class="s1">const [, , args] =</span><span class="s3">\n    </span><span class="s1">typeof encodedArguments === 'string'</span><span class="s3">\n      </span><span class="s1">? await decodeReply&lt;CacheKeyParts&gt;(</span><span class="s3">\n          </span><span class="s1">encodedArguments,</span><span class="s3">\n          </span><span class="s1">getServerModuleMap(),</span><span class="s3">\n          </span><span class="s1">{ temporaryReferences }</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">: await decodeReplyFromAsyncIterable&lt;CacheKeyParts&gt;(</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">async *[Symbol.asyncIterator]() {</span><span class="s3">\n              </span><span class="s1">for (const entry of encodedArguments) {</span><span class="s3">\n                </span><span class="s1">yield entry</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">if (outerWorkUnitStore) {</span><span class="s3">\n                </span><span class="s1">switch (outerWorkUnitStore.type) {</span><span class="s3">\n                  </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n                  </span><span class="s1">case 'prerender':</span><span class="s3">\n                    </span><span class="s1">// The encoded arguments might contain hanging promises. In</span><span class="s3">\n                    </span><span class="s1">// this case we don't want to reject with </span><span class="s3">\&quot;</span><span class="s1">Error: Connection</span><span class="s3">\n                    </span><span class="s1">// closed.</span><span class="s3">\&quot;</span><span class="s1">, so we intentionally keep the iterable alive.</span><span class="s3">\n                    </span><span class="s1">// This is similar to the halting trick that we do while</span><span class="s3">\n                    </span><span class="s1">// rendering.</span><span class="s3">\n                    </span><span class="s1">await new Promise&lt;void&gt;((resolve) =&gt; {</span><span class="s3">\n                      </span><span class="s1">if (outerWorkUnitStore.renderSignal.aborted) {</span><span class="s3">\n                        </span><span class="s1">resolve()</span><span class="s3">\n                      </span><span class="s1">} else {</span><span class="s3">\n                        </span><span class="s1">outerWorkUnitStore.renderSignal.addEventListener(</span><span class="s3">\n                          </span><span class="s1">'abort',</span><span class="s3">\n                          </span><span class="s1">() =&gt; resolve(),</span><span class="s3">\n                          </span><span class="s1">{ once: true }</span><span class="s3">\n                        </span><span class="s1">)</span><span class="s3">\n                      </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">})</span><span class="s3">\n                    </span><span class="s1">break</span><span class="s3">\n                  </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n                  </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n                  </span><span class="s1">case 'request':</span><span class="s3">\n                  </span><span class="s1">case 'cache':</span><span class="s3">\n                  </span><span class="s1">case 'private-cache':</span><span class="s3">\n                  </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n                    </span><span class="s1">break</span><span class="s3">\n                  </span><span class="s1">default:</span><span class="s3">\n                    </span><span class="s1">outerWorkUnitStore satisfies never</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">getServerModuleMap(),</span><span class="s3">\n          </span><span class="s1">{ temporaryReferences }</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// Track the timestamp when we started computing the result.</span><span class="s3">\n  </span><span class="s1">const startTime = performance.timeOrigin + performance.now()</span><span class="s3">\n\n  </span><span class="s1">// Invoke the inner function to load a new result. We delay the invocation</span><span class="s3">\n  </span><span class="s1">// though, until React awaits the promise so that React's request store (ALS)</span><span class="s3">\n  </span><span class="s1">// is available when the function is invoked. This allows us, for example, to</span><span class="s3">\n  </span><span class="s1">// capture logs so that we can later replay them.</span><span class="s3">\n  </span><span class="s1">const resultPromise = createLazyResult(() =&gt; fn.apply(null, args))</span><span class="s3">\n\n  </span><span class="s1">let errors: Array&lt;unknown&gt; = []</span><span class="s3">\n\n  </span><span class="s1">// In the </span><span class="s3">\&quot;</span><span class="s1">Cache</span><span class="s3">\&quot; </span><span class="s1">environment, we only need to make sure that the error</span><span class="s3">\n  </span><span class="s1">// digests are handled correctly. Error formatting and reporting is not</span><span class="s3">\n  </span><span class="s1">// necessary here; the errors are encoded in the stream, and will be reported</span><span class="s3">\n  </span><span class="s1">// in the </span><span class="s3">\&quot;</span><span class="s1">Server</span><span class="s3">\&quot; </span><span class="s1">environment.</span><span class="s3">\n  </span><span class="s1">const handleError = (error: unknown): string | undefined =&gt; {</span><span class="s3">\n    </span><span class="s1">const digest = getDigestForWellKnownError(error)</span><span class="s3">\n\n    </span><span class="s1">if (digest) {</span><span class="s3">\n      </span><span class="s1">return digest</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isReactLargeShellError(error)) {</span><span class="s3">\n      </span><span class="s1">// TODO: Aggregate</span><span class="s3">\n      </span><span class="s1">console.error(error)</span><span class="s3">\n      </span><span class="s1">return undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (process.env.NODE_ENV !== 'development') {</span><span class="s3">\n      </span><span class="s1">// TODO: For now we're also reporting the error here, because in</span><span class="s3">\n      </span><span class="s1">// production, the </span><span class="s3">\&quot;</span><span class="s1">Server</span><span class="s3">\&quot; </span><span class="s1">environment will only get the obfuscated</span><span class="s3">\n      </span><span class="s1">// error (created by the Flight Client in the cache wrapper).</span><span class="s3">\n      </span><span class="s1">console.error(error)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">errors.push(error)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let stream: ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n\n  </span><span class="s1">switch (outerWorkUnitStore?.type) {</span><span class="s3">\n    </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n    </span><span class="s1">case 'prerender':</span><span class="s3">\n      </span><span class="s1">const timeoutAbortController = new AbortController()</span><span class="s3">\n\n      </span><span class="s1">// If we're prerendering, we give you 50 seconds to fill a cache entry.</span><span class="s3">\n      </span><span class="s1">// Otherwise we assume you stalled on hanging input and de-opt. This needs</span><span class="s3">\n      </span><span class="s1">// to be lower than just the general timeout of 60 seconds.</span><span class="s3">\n      </span><span class="s1">const timer = setTimeout(() =&gt; {</span><span class="s3">\n        </span><span class="s1">const error = new UseCacheTimeoutError()</span><span class="s3">\n        </span><span class="s1">if (sharedErrorStack) {</span><span class="s3">\n          </span><span class="s1">error.stack = error.name + ': ' + error.message + sharedErrorStack</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">workStore.invalidDynamicUsageError = error</span><span class="s3">\n        </span><span class="s1">timeoutAbortController.abort(error)</span><span class="s3">\n      </span><span class="s1">}, 50000)</span><span class="s3">\n\n      </span><span class="s1">const dynamicAccessAbortSignal =</span><span class="s3">\n        </span><span class="s1">dynamicAccessAsyncStorage.getStore()?.abortController.signal</span><span class="s3">\n\n      </span><span class="s1">const abortSignal = dynamicAccessAbortSignal</span><span class="s3">\n        </span><span class="s1">? AbortSignal.any([</span><span class="s3">\n            </span><span class="s1">dynamicAccessAbortSignal,</span><span class="s3">\n            </span><span class="s1">outerWorkUnitStore.renderSignal,</span><span class="s3">\n            </span><span class="s1">timeoutAbortController.signal,</span><span class="s3">\n          </span><span class="s1">])</span><span class="s3">\n        </span><span class="s1">: timeoutAbortController.signal</span><span class="s3">\n\n      </span><span class="s1">const { prelude } = await prerender(</span><span class="s3">\n        </span><span class="s1">resultPromise,</span><span class="s3">\n        </span><span class="s1">clientReferenceManifest.clientModules,</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">environmentName: 'Cache',</span><span class="s3">\n          </span><span class="s1">filterStackFrame,</span><span class="s3">\n          </span><span class="s1">signal: abortSignal,</span><span class="s3">\n          </span><span class="s1">temporaryReferences,</span><span class="s3">\n          </span><span class="s1">onError(error) {</span><span class="s3">\n            </span><span class="s1">if (abortSignal.aborted &amp;&amp; abortSignal.reason === error) {</span><span class="s3">\n              </span><span class="s1">return undefined</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">return handleError(error)</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">clearTimeout(timer)</span><span class="s3">\n\n      </span><span class="s1">if (timeoutAbortController.signal.aborted) {</span><span class="s3">\n        </span><span class="s1">// When the timeout is reached we always error the stream. Even for</span><span class="s3">\n        </span><span class="s1">// fallback shell prerenders we don't want to return a hanging promise,</span><span class="s3">\n        </span><span class="s1">// which would allow the function to become a dynamic hole. Because that</span><span class="s3">\n        </span><span class="s1">// would mean that a non-empty shell could be generated which would be</span><span class="s3">\n        </span><span class="s1">// subject to revalidation, and we don't want to create long</span><span class="s3">\n        </span><span class="s1">// revalidation times.</span><span class="s3">\n        </span><span class="s1">stream = new ReadableStream({</span><span class="s3">\n          </span><span class="s1">start(controller) {</span><span class="s3">\n            </span><span class="s1">controller.error(timeoutAbortController.signal.reason)</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">} else if (dynamicAccessAbortSignal?.aborted) {</span><span class="s3">\n        </span><span class="s1">// If the prerender is aborted because of dynamic access (e.g. reading</span><span class="s3">\n        </span><span class="s1">// fallback params), we return a hanging promise. This essentially makes</span><span class="s3">\n        </span><span class="s1">// the </span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot; </span><span class="s1">function dynamic.</span><span class="s3">\n        </span><span class="s1">const hangingPromise = makeHangingPromise&lt;never&gt;(</span><span class="s3">\n          </span><span class="s1">outerWorkUnitStore.renderSignal,</span><span class="s3">\n          </span><span class="s1">workStore.route,</span><span class="s3">\n          </span><span class="s1">abortSignal.reason</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">if (outerWorkUnitStore.cacheSignal) {</span><span class="s3">\n          </span><span class="s1">outerWorkUnitStore.cacheSignal.endRead()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return { type: 'prerender-dynamic', hangingPromise }</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">stream = prelude</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n    </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n    </span><span class="s1">case 'request':</span><span class="s3">\n    </span><span class="s1">case 'cache':</span><span class="s3">\n    </span><span class="s1">case 'private-cache':</span><span class="s3">\n    </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n    </span><span class="s1">case undefined:</span><span class="s3">\n      </span><span class="s1">stream = renderToReadableStream(</span><span class="s3">\n        </span><span class="s1">resultPromise,</span><span class="s3">\n        </span><span class="s1">clientReferenceManifest.clientModules,</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">environmentName: 'Cache',</span><span class="s3">\n          </span><span class="s1">filterStackFrame,</span><span class="s3">\n          </span><span class="s1">temporaryReferences,</span><span class="s3">\n          </span><span class="s1">onError: handleError,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">return outerWorkUnitStore satisfies never</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const [returnStream, savedStream] = stream.tee()</span><span class="s3">\n\n  </span><span class="s1">const pendingCacheEntry = collectResult(</span><span class="s3">\n    </span><span class="s1">savedStream,</span><span class="s3">\n    </span><span class="s1">workStore,</span><span class="s3">\n    </span><span class="s1">cacheContext,</span><span class="s3">\n    </span><span class="s1">innerCacheStore,</span><span class="s3">\n    </span><span class="s1">startTime,</span><span class="s3">\n    </span><span class="s1">errors</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: 'cached',</span><span class="s3">\n    </span><span class="s1">// Return the stream as we're creating it. This means that if it ends up</span><span class="s3">\n    </span><span class="s1">// erroring we cannot return a stale-if-error version but it allows</span><span class="s3">\n    </span><span class="s1">// streaming back the result earlier.</span><span class="s3">\n    </span><span class="s1">stream: returnStream,</span><span class="s3">\n    </span><span class="s1">pendingCacheEntry,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function cloneCacheEntry(entry: CacheEntry): [CacheEntry, CacheEntry] {</span><span class="s3">\n  </span><span class="s1">const [streamA, streamB] = entry.value.tee()</span><span class="s3">\n  </span><span class="s1">entry.value = streamA</span><span class="s3">\n  </span><span class="s1">const clonedEntry: CacheEntry = {</span><span class="s3">\n    </span><span class="s1">value: streamB,</span><span class="s3">\n    </span><span class="s1">timestamp: entry.timestamp,</span><span class="s3">\n    </span><span class="s1">revalidate: entry.revalidate,</span><span class="s3">\n    </span><span class="s1">expire: entry.expire,</span><span class="s3">\n    </span><span class="s1">stale: entry.stale,</span><span class="s3">\n    </span><span class="s1">tags: entry.tags,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return [entry, clonedEntry]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function clonePendingCacheEntry(</span><span class="s3">\n  </span><span class="s1">pendingCacheEntry: Promise&lt;CacheEntry&gt;</span><span class="s3">\n</span><span class="s1">): Promise&lt;[CacheEntry, CacheEntry]&gt; {</span><span class="s3">\n  </span><span class="s1">const entry = await pendingCacheEntry</span><span class="s3">\n  </span><span class="s1">return cloneCacheEntry(entry)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function getNthCacheEntry(</span><span class="s3">\n  </span><span class="s1">split: Promise&lt;[CacheEntry, CacheEntry]&gt;,</span><span class="s3">\n  </span><span class="s1">i: number</span><span class="s3">\n</span><span class="s1">): Promise&lt;CacheEntry&gt; {</span><span class="s3">\n  </span><span class="s1">return (await split)[i]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function encodeFormData(formData: FormData): Promise&lt;string&gt; {</span><span class="s3">\n  </span><span class="s1">let result = ''</span><span class="s3">\n  </span><span class="s1">for (let [key, value] of formData) {</span><span class="s3">\n    </span><span class="s1">// We don't need this key to be serializable but from a security perspective it should not be</span><span class="s3">\n    </span><span class="s1">// possible to generate a string that looks the same from a different structure. To ensure this</span><span class="s3">\n    </span><span class="s1">// we need a delimeter between fields but just using a delimeter is not enough since a string</span><span class="s3">\n    </span><span class="s1">// might contain that delimeter. We use the length of each field as the delimeter to avoid</span><span class="s3">\n    </span><span class="s1">// escaping the values.</span><span class="s3">\n    </span><span class="s1">result += key.length.toString(16) + ':' + key</span><span class="s3">\n    </span><span class="s1">let stringValue</span><span class="s3">\n    </span><span class="s1">if (typeof value === 'string') {</span><span class="s3">\n      </span><span class="s1">stringValue = value</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// The FormData might contain binary data that is not valid UTF-8 so this cache</span><span class="s3">\n      </span><span class="s1">// key may generate a UCS-2 string. Passing this to another service needs to be</span><span class="s3">\n      </span><span class="s1">// aware that the key might not be compatible.</span><span class="s3">\n      </span><span class="s1">const arrayBuffer = await value.arrayBuffer()</span><span class="s3">\n      </span><span class="s1">if (arrayBuffer.byteLength % 2 === 0) {</span><span class="s3">\n        </span><span class="s1">stringValue = String.fromCodePoint(...new Uint16Array(arrayBuffer))</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">stringValue =</span><span class="s3">\n          </span><span class="s1">String.fromCodePoint(</span><span class="s3">\n            </span><span class="s1">...new Uint16Array(arrayBuffer, 0, (arrayBuffer.byteLength - 1) / 2)</span><span class="s3">\n          </span><span class="s1">) +</span><span class="s3">\n          </span><span class="s1">String.fromCodePoint(</span><span class="s3">\n            </span><span class="s1">new Uint8Array(arrayBuffer, arrayBuffer.byteLength - 1, 1)[0]</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">result += stringValue.length.toString(16) + ':' + stringValue</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createTrackedReadableStream(</span><span class="s3">\n  </span><span class="s1">stream: ReadableStream,</span><span class="s3">\n  </span><span class="s1">cacheSignal: CacheSignal</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const reader = stream.getReader()</span><span class="s3">\n  </span><span class="s1">return new ReadableStream({</span><span class="s3">\n    </span><span class="s1">async pull(controller) {</span><span class="s3">\n      </span><span class="s1">const { done, value } = await reader.read()</span><span class="s3">\n      </span><span class="s1">if (done) {</span><span class="s3">\n        </span><span class="s1">controller.close()</span><span class="s3">\n        </span><span class="s1">cacheSignal.endRead()</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">controller.enqueue(value)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function wrapAsInvalidDynamicUsageError(</span><span class="s3">\n  </span><span class="s1">error: Error,</span><span class="s3">\n  </span><span class="s1">sharedErrorStack: string | undefined,</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (sharedErrorStack) {</span><span class="s3">\n    </span><span class="s1">error.stack = error.name + ': ' + error.message + sharedErrorStack</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">workStore.invalidDynamicUsageError ??= error</span><span class="s3">\n\n  </span><span class="s1">return error</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function cache(</span><span class="s3">\n  </span><span class="s1">kind: string,</span><span class="s3">\n  </span><span class="s1">id: string,</span><span class="s3">\n  </span><span class="s1">boundArgsLength: number,</span><span class="s3">\n  </span><span class="s1">originalFn: (...args: unknown[]) =&gt; Promise&lt;unknown&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const isPrivate = kind === 'private'</span><span class="s3">\n\n  </span><span class="s1">// Private caches are currently only stored in the Resume Data Cache (RDC),</span><span class="s3">\n  </span><span class="s1">// and not in cache handlers.</span><span class="s3">\n  </span><span class="s1">const cacheHandler = isPrivate ? undefined : getCacheHandler(kind)</span><span class="s3">\n\n  </span><span class="s1">if (!isPrivate &amp;&amp; !cacheHandler) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Unknown cache handler: ' + kind)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Capture a better error stack in this scope.</span><span class="s3">\n  </span><span class="s1">const sharedError = new Error()</span><span class="s3">\n  </span><span class="s1">Error.captureStackTrace(sharedError, cache)</span><span class="s3">\n  </span><span class="s1">const sharedErrorStack = sharedError.stack?.slice(</span><span class="s3">\n    </span><span class="s1">sharedError.stack.indexOf('</span><span class="s3">\\</span><span class="s1">n')</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const name = originalFn.name</span><span class="s3">\n  </span><span class="s1">const cachedFn = {</span><span class="s3">\n    </span><span class="s1">[name]: async function (...args: any[]) {</span><span class="s3">\n      </span><span class="s1">const workStore = workAsyncStorage.getStore()</span><span class="s3">\n      </span><span class="s1">if (workStore === undefined) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot; </span><span class="s1">cannot be used outside of App Router. Expected a WorkStore.'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let fn = originalFn</span><span class="s3">\n\n      </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n\n      </span><span class="s1">let cacheContext: CacheContext</span><span class="s3">\n\n      </span><span class="s1">if (isPrivate) {</span><span class="s3">\n        </span><span class="s1">const expression = '</span><span class="s3">\&quot;</span><span class="s1">use cache: private</span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\n\n        </span><span class="s1">switch (workUnitStore?.type) {</span><span class="s3">\n          </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">use cache: private</span><span class="s3">\&quot; </span><span class="s1">is dynamic in prerendering contexts.</span><span class="s3">\n          </span><span class="s1">case 'prerender':</span><span class="s3">\n            </span><span class="s1">return makeHangingPromise(</span><span class="s3">\n              </span><span class="s1">workUnitStore.renderSignal,</span><span class="s3">\n              </span><span class="s1">workStore.route,</span><span class="s3">\n              </span><span class="s1">expression</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n            </span><span class="s1">return postponeWithTracking(</span><span class="s3">\n              </span><span class="s1">workStore.route,</span><span class="s3">\n              </span><span class="s1">expression,</span><span class="s3">\n              </span><span class="s1">workUnitStore.dynamicTracking</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n            </span><span class="s1">return throwToInterruptStaticGeneration(</span><span class="s3">\n              </span><span class="s1">expression,</span><span class="s3">\n              </span><span class="s1">workStore,</span><span class="s3">\n              </span><span class="s1">workUnitStore</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">case 'prerender-client':</span><span class="s3">\n            </span><span class="s1">throw new InvariantError(</span><span class="s3">\n              </span><span class="s1">`${expression} must not be used within a client component. Next.js should be preventing ${expression} from being allowed in client components statically, but did not in this case.`</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">case 'unstable-cache': {</span><span class="s3">\n            </span><span class="s1">throw wrapAsInvalidDynamicUsageError(</span><span class="s3">\n              </span><span class="s1">new Error(</span><span class="s3">\n                </span><span class="s1">// TODO: Add a link to an error documentation page when we have one.</span><span class="s3">\n                </span><span class="s1">`${expression} must not be used within </span><span class="s3">\\</span><span class="s1">`unstable_cache()</span><span class="s3">\\</span><span class="s1">`.`</span><span class="s3">\n              </span><span class="s1">),</span><span class="s3">\n              </span><span class="s1">sharedErrorStack,</span><span class="s3">\n              </span><span class="s1">workStore</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">case 'cache': {</span><span class="s3">\n            </span><span class="s1">throw wrapAsInvalidDynamicUsageError(</span><span class="s3">\n              </span><span class="s1">new Error(</span><span class="s3">\n                </span><span class="s1">// TODO: Add a link to an error documentation page when we have one.</span><span class="s3">\n                </span><span class="s1">`${expression} must not be used within </span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot;</span><span class="s1">. It can only be nested inside of another ${expression}.`</span><span class="s3">\n              </span><span class="s1">),</span><span class="s3">\n              </span><span class="s1">sharedErrorStack,</span><span class="s3">\n              </span><span class="s1">workStore</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">case 'request':</span><span class="s3">\n          </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n          </span><span class="s1">case 'private-cache':</span><span class="s3">\n            </span><span class="s1">cacheContext = {</span><span class="s3">\n              </span><span class="s1">kind: 'private',</span><span class="s3">\n              </span><span class="s1">outerWorkUnitStore: workUnitStore,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">case undefined:</span><span class="s3">\n            </span><span class="s1">throw wrapAsInvalidDynamicUsageError(</span><span class="s3">\n              </span><span class="s1">new Error(</span><span class="s3">\n                </span><span class="s1">// TODO: Add a link to an error documentation page when we have one.</span><span class="s3">\n                </span><span class="s1">`${expression} cannot be used outside of a request context.`</span><span class="s3">\n              </span><span class="s1">),</span><span class="s3">\n              </span><span class="s1">sharedErrorStack,</span><span class="s3">\n              </span><span class="s1">workStore</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n            </span><span class="s1">// This is dead code, but without throwing an error here, TypeScript</span><span class="s3">\n            </span><span class="s1">// will assume that cacheContext is used before being assigned.</span><span class="s3">\n            </span><span class="s1">throw new InvariantError(`Unexpected work unit store.`)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">switch (workUnitStore?.type) {</span><span class="s3">\n          </span><span class="s1">case 'prerender-client':</span><span class="s3">\n            </span><span class="s1">const expression = '</span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\n            </span><span class="s1">throw new InvariantError(</span><span class="s3">\n              </span><span class="s1">`${expression} must not be used within a client component. Next.js should be preventing ${expression} from being allowed in client components statically, but did not in this case.`</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">case 'prerender':</span><span class="s3">\n          </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n          </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n          </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n          </span><span class="s1">case 'request':</span><span class="s3">\n          </span><span class="s1">case 'cache':</span><span class="s3">\n          </span><span class="s1">case 'private-cache':</span><span class="s3">\n          </span><span class="s1">// TODO: We should probably forbid nesting </span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot; </span><span class="s1">inside</span><span class="s3">\n          </span><span class="s1">// unstable_cache. (fallthrough)</span><span class="s3">\n          </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n          </span><span class="s1">case undefined:</span><span class="s3">\n            </span><span class="s1">cacheContext = {</span><span class="s3">\n              </span><span class="s1">kind: 'public',</span><span class="s3">\n              </span><span class="s1">outerWorkUnitStore: workUnitStore,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n            </span><span class="s1">// This is dead code, but without throwing an error here, TypeScript</span><span class="s3">\n            </span><span class="s1">// will assume that cacheContext is used before being assigned.</span><span class="s3">\n            </span><span class="s1">throw new InvariantError(`Unexpected work unit store.`)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Get the clientReferenceManifest while we're still in the outer Context.</span><span class="s3">\n      </span><span class="s1">// In case getClientReferenceManifestSingleton is implemented using AsyncLocalStorage.</span><span class="s3">\n      </span><span class="s1">const clientReferenceManifest = getClientReferenceManifestForRsc()</span><span class="s3">\n\n      </span><span class="s1">// Because the Action ID is not yet unique per implementation of that Action we can't</span><span class="s3">\n      </span><span class="s1">// safely reuse the results across builds yet. In the meantime we add the buildId to the</span><span class="s3">\n      </span><span class="s1">// arguments as a seed to ensure they're not reused. Remove this once Action IDs hash</span><span class="s3">\n      </span><span class="s1">// the implementation.</span><span class="s3">\n      </span><span class="s1">const buildId = workStore.buildId</span><span class="s3">\n\n      </span><span class="s1">// In dev mode, when the HMR refresh hash is set, we include it in the</span><span class="s3">\n      </span><span class="s1">// cache key. This ensures that cache entries are not reused when server</span><span class="s3">\n      </span><span class="s1">// components have been edited. This is a very coarse approach. But it's</span><span class="s3">\n      </span><span class="s1">// also only a temporary solution until Action IDs are unique per</span><span class="s3">\n      </span><span class="s1">// implementation. Remove this once Action IDs hash the implementation.</span><span class="s3">\n      </span><span class="s1">const hmrRefreshHash =</span><span class="s3">\n        </span><span class="s1">workUnitStore &amp;&amp; getHmrRefreshHash(workStore, workUnitStore)</span><span class="s3">\n\n      </span><span class="s1">const hangingInputAbortSignal = workUnitStore</span><span class="s3">\n        </span><span class="s1">? createHangingInputAbortSignal(workUnitStore)</span><span class="s3">\n        </span><span class="s1">: undefined</span><span class="s3">\n\n      </span><span class="s1">// In a runtime prerender, we have to make sure that APIs that would hang during a static prerender</span><span class="s3">\n      </span><span class="s1">// are resolved with a delay, in the runtime stage. Private caches are one of these.</span><span class="s3">\n      </span><span class="s1">if (cacheContext.kind === 'private') {</span><span class="s3">\n        </span><span class="s1">const runtimeStagePromise = getRuntimeStagePromise(</span><span class="s3">\n          </span><span class="s1">cacheContext.outerWorkUnitStore</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">if (runtimeStagePromise) {</span><span class="s3">\n          </span><span class="s1">await runtimeStagePromise</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let isPageOrLayout = false</span><span class="s3">\n\n      </span><span class="s1">// For page and layout components, the cache function is overwritten,</span><span class="s3">\n      </span><span class="s1">// which allows us to apply special handling for params and searchParams.</span><span class="s3">\n      </span><span class="s1">// For pages and layouts we're using the outer params prop, and not the</span><span class="s3">\n      </span><span class="s1">// inner one that was serialized/deserialized. While it's not generally</span><span class="s3">\n      </span><span class="s1">// true for </span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot; </span><span class="s1">args, in the case of `params` the inner and outer</span><span class="s3">\n      </span><span class="s1">// object are essentially equivalent, so this is safe to do (including</span><span class="s3">\n      </span><span class="s1">// fallback params that are hanging promises). It allows us to avoid</span><span class="s3">\n      </span><span class="s1">// waiting for the timeout, when prerendering a fallback shell of a cached</span><span class="s3">\n      </span><span class="s1">// page or layout that awaits params.</span><span class="s3">\n      </span><span class="s1">if (isPageComponent(args)) {</span><span class="s3">\n        </span><span class="s1">isPageOrLayout = true</span><span class="s3">\n\n        </span><span class="s1">const [{ params: outerParams, searchParams: outerSearchParams }] = args</span><span class="s3">\n\n        </span><span class="s1">const props: UseCacheInnerPageComponentProps = {</span><span class="s3">\n          </span><span class="s1">params: outerParams,</span><span class="s3">\n          </span><span class="s1">// Omit searchParams and $$isPageComponent.</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (isPrivate) {</span><span class="s3">\n          </span><span class="s1">// Private caches allow accessing search params. We need to include</span><span class="s3">\n          </span><span class="s1">// them in the serialized args and when generating the cache key.</span><span class="s3">\n          </span><span class="s1">props.searchParams = outerSearchParams</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">args = [props]</span><span class="s3">\n\n        </span><span class="s1">fn = {</span><span class="s3">\n          </span><span class="s1">[name]: async ({</span><span class="s3">\n            </span><span class="s1">params: _innerParams,</span><span class="s3">\n            </span><span class="s1">searchParams: innerSearchParams,</span><span class="s3">\n          </span><span class="s1">}: UseCacheInnerPageComponentProps) =&gt;</span><span class="s3">\n            </span><span class="s1">originalFn.apply(null, [</span><span class="s3">\n              </span><span class="s1">{</span><span class="s3">\n                </span><span class="s1">params: outerParams,</span><span class="s3">\n                </span><span class="s1">searchParams:</span><span class="s3">\n                  </span><span class="s1">innerSearchParams ??</span><span class="s3">\n                  </span><span class="s1">// For public caches, search params are omitted from the cache</span><span class="s3">\n                  </span><span class="s1">// key (and the serialized args) to avoid mismatches between</span><span class="s3">\n                  </span><span class="s1">// prerendering and resuming a cached page that does not</span><span class="s3">\n                  </span><span class="s1">// access search params. This is also the reason why we're not</span><span class="s3">\n                  </span><span class="s1">// using a hanging promise for search params. For cached pages</span><span class="s3">\n                  </span><span class="s1">// that do access them, which is an invalid dynamic usage, we</span><span class="s3">\n                  </span><span class="s1">// need to ensure that an error is shown.</span><span class="s3">\n                  </span><span class="s1">makeErroringSearchParamsForUseCache(workStore),</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">]),</span><span class="s3">\n        </span><span class="s1">}[name] as (...args: unknown[]) =&gt; Promise&lt;unknown&gt;</span><span class="s3">\n      </span><span class="s1">} else if (isLayoutComponent(args)) {</span><span class="s3">\n        </span><span class="s1">isPageOrLayout = true</span><span class="s3">\n\n        </span><span class="s1">const [{ params: outerParams, $$isLayoutComponent, ...outerSlots }] =</span><span class="s3">\n          </span><span class="s1">args</span><span class="s3">\n        </span><span class="s1">// Overwrite the props to omit $$isLayoutComponent.</span><span class="s3">\n        </span><span class="s1">args = [{ params: outerParams, ...outerSlots }]</span><span class="s3">\n\n        </span><span class="s1">fn = {</span><span class="s3">\n          </span><span class="s1">[name]: async ({</span><span class="s3">\n            </span><span class="s1">params: _innerParams,</span><span class="s3">\n            </span><span class="s1">...innerSlots</span><span class="s3">\n          </span><span class="s1">}: Omit&lt;UseCacheLayoutComponentProps, '$$isLayoutComponent'&gt;) =&gt;</span><span class="s3">\n            </span><span class="s1">originalFn.apply(null, [{ params: outerParams, ...innerSlots }]),</span><span class="s3">\n        </span><span class="s1">}[name] as (...args: unknown[]) =&gt; Promise&lt;unknown&gt;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (boundArgsLength &gt; 0) {</span><span class="s3">\n        </span><span class="s1">if (args.length === 0) {</span><span class="s3">\n          </span><span class="s1">throw new InvariantError(</span><span class="s3">\n            </span><span class="s1">`Expected the </span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot; </span><span class="s1">function ${JSON.stringify(fn.name)} to receive its encrypted bound arguments as the first argument.`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const encryptedBoundArgs = args.shift()</span><span class="s3">\n        </span><span class="s1">const boundArgs = await decryptActionBoundArgs(id, encryptedBoundArgs)</span><span class="s3">\n\n        </span><span class="s1">if (!Array.isArray(boundArgs)) {</span><span class="s3">\n          </span><span class="s1">throw new InvariantError(</span><span class="s3">\n            </span><span class="s1">`Expected the bound arguments of </span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot; </span><span class="s1">function ${JSON.stringify(fn.name)} to deserialize into an array, got ${typeof boundArgs} instead.`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (boundArgsLength !== boundArgs.length) {</span><span class="s3">\n          </span><span class="s1">throw new InvariantError(</span><span class="s3">\n            </span><span class="s1">`Expected the </span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot; </span><span class="s1">function ${JSON.stringify(fn.name)} to receive ${boundArgsLength} bound arguments, got ${boundArgs.length} instead.`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">args.unshift(boundArgs)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const temporaryReferences = createClientTemporaryReferenceSet()</span><span class="s3">\n\n      </span><span class="s1">// For private caches, which are allowed to read cookies, we still don't</span><span class="s3">\n      </span><span class="s1">// need to include the cookies in the cache key. This is because we don't</span><span class="s3">\n      </span><span class="s1">// store the cache entries in a cache handler, but only in the Resume Data</span><span class="s3">\n      </span><span class="s1">// Cache (RDC). Private caches are only used during dynamic requests and</span><span class="s3">\n      </span><span class="s1">// runtime prefetches. For dynamic requests, the RDC is immutable, so it</span><span class="s3">\n      </span><span class="s1">// does not include any private caches. For runtime prefetches, the RDC is</span><span class="s3">\n      </span><span class="s1">// mutable, but only lives as long as the request, so the key does not</span><span class="s3">\n      </span><span class="s1">// need to include cookies.</span><span class="s3">\n      </span><span class="s1">const cacheKeyParts: CacheKeyParts = hmrRefreshHash</span><span class="s3">\n        </span><span class="s1">? [buildId, id, args, hmrRefreshHash]</span><span class="s3">\n        </span><span class="s1">: [buildId, id, args]</span><span class="s3">\n\n      </span><span class="s1">const encodeCacheKeyParts = () =&gt;</span><span class="s3">\n        </span><span class="s1">encodeReply(cacheKeyParts, {</span><span class="s3">\n          </span><span class="s1">temporaryReferences,</span><span class="s3">\n          </span><span class="s1">signal: hangingInputAbortSignal,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">let encodedCacheKeyParts: FormData | string</span><span class="s3">\n\n      </span><span class="s1">switch (workUnitStore?.type) {</span><span class="s3">\n        </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n        </span><span class="s1">// We're currently only using `dynamicAccessAsyncStorage` for params,</span><span class="s3">\n        </span><span class="s1">// which are always available in a runtime prerender, so they will never hang,</span><span class="s3">\n        </span><span class="s1">// effectively making the tracking below a no-op.</span><span class="s3">\n        </span><span class="s1">// However, a runtime prerender shares a lot of the semantics with a static prerender,</span><span class="s3">\n        </span><span class="s1">// and might need to follow this codepath in the future</span><span class="s3">\n        </span><span class="s1">// if we start using `dynamicAccessAsyncStorage` for other APIs.</span><span class="s3">\n        </span><span class="s1">//</span><span class="s3">\n        </span><span class="s1">// fallthrough</span><span class="s3">\n        </span><span class="s1">case 'prerender':</span><span class="s3">\n          </span><span class="s1">if (!isPageOrLayout) {</span><span class="s3">\n            </span><span class="s1">// If the </span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot; </span><span class="s1">function is not a page or a layout, we need to</span><span class="s3">\n            </span><span class="s1">// track dynamic access already when encoding the arguments. If</span><span class="s3">\n            </span><span class="s1">// params are passed explicitly into a </span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot; </span><span class="s1">function (as</span><span class="s3">\n            </span><span class="s1">// opposed to receiving them automatically in a page or layout), we</span><span class="s3">\n            </span><span class="s1">// assume that the params are also accessed. This allows us to abort</span><span class="s3">\n            </span><span class="s1">// early, and treat the function as dynamic, instead of waiting for</span><span class="s3">\n            </span><span class="s1">// the timeout to be reached.</span><span class="s3">\n            </span><span class="s1">const dynamicAccessAbortController = new AbortController()</span><span class="s3">\n\n            </span><span class="s1">encodedCacheKeyParts = await dynamicAccessAsyncStorage.run(</span><span class="s3">\n              </span><span class="s1">{ abortController: dynamicAccessAbortController },</span><span class="s3">\n              </span><span class="s1">encodeCacheKeyParts</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n\n            </span><span class="s1">if (dynamicAccessAbortController.signal.aborted) {</span><span class="s3">\n              </span><span class="s1">return makeHangingPromise(</span><span class="s3">\n                </span><span class="s1">workUnitStore.renderSignal,</span><span class="s3">\n                </span><span class="s1">workStore.route,</span><span class="s3">\n                </span><span class="s1">dynamicAccessAbortController.signal.reason.message</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// fallthrough</span><span class="s3">\n        </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n        </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n        </span><span class="s1">case 'request':</span><span class="s3">\n        </span><span class="s1">case 'cache':</span><span class="s3">\n        </span><span class="s1">case 'private-cache':</span><span class="s3">\n        </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n        </span><span class="s1">case undefined:</span><span class="s3">\n          </span><span class="s1">encodedCacheKeyParts = await encodeCacheKeyParts()</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n          </span><span class="s1">return workUnitStore satisfies never</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const serializedCacheKey =</span><span class="s3">\n        </span><span class="s1">typeof encodedCacheKeyParts === 'string'</span><span class="s3">\n          </span><span class="s1">? // Fast path for the simple case for simple inputs. We let the CacheHandler</span><span class="s3">\n            </span><span class="s1">// Convert it to an ArrayBuffer if it wants to.</span><span class="s3">\n            </span><span class="s1">encodedCacheKeyParts</span><span class="s3">\n          </span><span class="s1">: await encodeFormData(encodedCacheKeyParts)</span><span class="s3">\n\n      </span><span class="s1">let stream: undefined | ReadableStream = undefined</span><span class="s3">\n\n      </span><span class="s1">// Get an immutable and mutable versions of the resume data cache.</span><span class="s3">\n      </span><span class="s1">const prerenderResumeDataCache = workUnitStore</span><span class="s3">\n        </span><span class="s1">? getPrerenderResumeDataCache(workUnitStore)</span><span class="s3">\n        </span><span class="s1">: null</span><span class="s3">\n      </span><span class="s1">const renderResumeDataCache = workUnitStore</span><span class="s3">\n        </span><span class="s1">? getRenderResumeDataCache(workUnitStore)</span><span class="s3">\n        </span><span class="s1">: null</span><span class="s3">\n\n      </span><span class="s1">if (renderResumeDataCache) {</span><span class="s3">\n        </span><span class="s1">const cacheSignal = workUnitStore ? getCacheSignal(workUnitStore) : null</span><span class="s3">\n\n        </span><span class="s1">if (cacheSignal) {</span><span class="s3">\n          </span><span class="s1">cacheSignal.beginRead()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const cachedEntry = renderResumeDataCache.cache.get(serializedCacheKey)</span><span class="s3">\n        </span><span class="s1">if (cachedEntry !== undefined) {</span><span class="s3">\n          </span><span class="s1">const existingEntry = await cachedEntry</span><span class="s3">\n          </span><span class="s1">propagateCacheLifeAndTags(cacheContext, existingEntry)</span><span class="s3">\n\n          </span><span class="s1">if (workUnitStore !== undefined &amp;&amp; existingEntry !== undefined) {</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">existingEntry.revalidate === 0 ||</span><span class="s3">\n              </span><span class="s1">existingEntry.expire &lt; DYNAMIC_EXPIRE</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n                </span><span class="s1">case 'prerender':</span><span class="s3">\n                  </span><span class="s1">// In a Dynamic I/O prerender, if the cache entry has</span><span class="s3">\n                  </span><span class="s1">// revalidate: 0 or if the expire time is under 5 minutes, then</span><span class="s3">\n                  </span><span class="s1">// we consider this cache entry dynamic as it's not worth</span><span class="s3">\n                  </span><span class="s1">// generating static pages for such data. It's better to leave a</span><span class="s3">\n                  </span><span class="s1">// PPR hole that can be filled in dynamically with a potentially</span><span class="s3">\n                  </span><span class="s1">// cached entry.</span><span class="s3">\n                  </span><span class="s1">if (cacheSignal) {</span><span class="s3">\n                    </span><span class="s1">cacheSignal.endRead()</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">return makeHangingPromise(</span><span class="s3">\n                    </span><span class="s1">workUnitStore.renderSignal,</span><span class="s3">\n                    </span><span class="s1">workStore.route,</span><span class="s3">\n                    </span><span class="s1">'dynamic </span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\n                  </span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">case 'prerender-runtime': {</span><span class="s3">\n                  </span><span class="s1">// In a runtime prerender, we have to make sure that APIs that would hang during a static prerender</span><span class="s3">\n                  </span><span class="s1">// are resolved with a delay, in the runtime stage.</span><span class="s3">\n                  </span><span class="s1">if (workUnitStore.runtimeStagePromise) {</span><span class="s3">\n                    </span><span class="s1">await workUnitStore.runtimeStagePromise</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">break</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n                </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n                </span><span class="s1">case 'request':</span><span class="s3">\n                </span><span class="s1">case 'cache':</span><span class="s3">\n                </span><span class="s1">case 'private-cache':</span><span class="s3">\n                </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n                  </span><span class="s1">break</span><span class="s3">\n                </span><span class="s1">default:</span><span class="s3">\n                  </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (existingEntry.stale &lt; RUNTIME_PREFETCH_DYNAMIC_STALE) {</span><span class="s3">\n              </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n                </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n                  </span><span class="s1">// In a runtime prerender, if the cache entry will become stale in less then 30 seconds,</span><span class="s3">\n                  </span><span class="s1">// we consider this cache entry dynamic as it's not worth prefetching.</span><span class="s3">\n                  </span><span class="s1">// It's better to leave a PPR hole that can be filled in dynamically</span><span class="s3">\n                  </span><span class="s1">// with a potentially cached entry.</span><span class="s3">\n                  </span><span class="s1">if (cacheSignal) {</span><span class="s3">\n                    </span><span class="s1">cacheSignal.endRead()</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">return makeHangingPromise(</span><span class="s3">\n                    </span><span class="s1">workUnitStore.renderSignal,</span><span class="s3">\n                    </span><span class="s1">workStore.route,</span><span class="s3">\n                    </span><span class="s1">'dynamic </span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\n                  </span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">case 'prerender':</span><span class="s3">\n                </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n                </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n                </span><span class="s1">case 'request':</span><span class="s3">\n                </span><span class="s1">case 'cache':</span><span class="s3">\n                </span><span class="s1">case 'private-cache':</span><span class="s3">\n                </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n                  </span><span class="s1">break</span><span class="s3">\n                </span><span class="s1">default:</span><span class="s3">\n                  </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">const [streamA, streamB] = existingEntry.value.tee()</span><span class="s3">\n          </span><span class="s1">existingEntry.value = streamB</span><span class="s3">\n\n          </span><span class="s1">if (cacheSignal) {</span><span class="s3">\n            </span><span class="s1">// When we have a cacheSignal we need to block on reading the cache</span><span class="s3">\n            </span><span class="s1">// entry before ending the read.</span><span class="s3">\n            </span><span class="s1">stream = createTrackedReadableStream(streamA, cacheSignal)</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">stream = streamA</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">if (cacheSignal) {</span><span class="s3">\n            </span><span class="s1">cacheSignal.endRead()</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n            </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n              </span><span class="s1">case 'prerender':</span><span class="s3">\n                </span><span class="s1">// If `allowEmptyStaticShell` is true, and thus a prefilled</span><span class="s3">\n                </span><span class="s1">// resume data cache was provided, then a cache miss means that</span><span class="s3">\n                </span><span class="s1">// params were part of the cache key. In this case, we can make</span><span class="s3">\n                </span><span class="s1">// this cache function a dynamic hole in the shell (or produce</span><span class="s3">\n                </span><span class="s1">// an empty shell if there's no parent suspense boundary).</span><span class="s3">\n                </span><span class="s1">// Currently, this also includes layouts and pages that don't</span><span class="s3">\n                </span><span class="s1">// read params, which will be improved when we implement</span><span class="s3">\n                </span><span class="s1">// NAR-136. Otherwise, we assume that if params are passed</span><span class="s3">\n                </span><span class="s1">// explicitly into a </span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot; </span><span class="s1">function, that the params are</span><span class="s3">\n                </span><span class="s1">// also accessed. This allows us to abort early, and treat the</span><span class="s3">\n                </span><span class="s1">// function as dynamic, instead of waiting for the timeout to be</span><span class="s3">\n                </span><span class="s1">// reached. Compared to the instrumentation-based params bailout</span><span class="s3">\n                </span><span class="s1">// we do here, this also covers the case where params are</span><span class="s3">\n                </span><span class="s1">// transformed with an async function, before being passed into</span><span class="s3">\n                </span><span class="s1">// the </span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot; </span><span class="s1">function, which escapes the instrumentation.</span><span class="s3">\n                </span><span class="s1">if (workUnitStore.allowEmptyStaticShell) {</span><span class="s3">\n                  </span><span class="s1">return makeHangingPromise(</span><span class="s3">\n                    </span><span class="s1">workUnitStore.renderSignal,</span><span class="s3">\n                    </span><span class="s1">workStore.route,</span><span class="s3">\n                    </span><span class="s1">'dynamic </span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\n                  </span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">break</span><span class="s3">\n              </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n              </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n              </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n              </span><span class="s1">case 'request':</span><span class="s3">\n              </span><span class="s1">case 'cache':</span><span class="s3">\n              </span><span class="s1">case 'private-cache':</span><span class="s3">\n              </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n                </span><span class="s1">break</span><span class="s3">\n              </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (stream === undefined) {</span><span class="s3">\n        </span><span class="s1">const cacheSignal = workUnitStore ? getCacheSignal(workUnitStore) : null</span><span class="s3">\n        </span><span class="s1">if (cacheSignal) {</span><span class="s3">\n          </span><span class="s1">// Either the cache handler or the generation can be using I/O at this point.</span><span class="s3">\n          </span><span class="s1">// We need to track when they start and when they complete.</span><span class="s3">\n          </span><span class="s1">cacheSignal.beginRead()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const lazyRefreshTags = workStore.refreshTagsByCacheKind.get(kind)</span><span class="s3">\n\n        </span><span class="s1">if (lazyRefreshTags &amp;&amp; !isResolvedLazyResult(lazyRefreshTags)) {</span><span class="s3">\n          </span><span class="s1">await lazyRefreshTags</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">let entry: CacheEntry | undefined</span><span class="s3">\n\n        </span><span class="s1">// We ignore existing cache entries when force revalidating.</span><span class="s3">\n        </span><span class="s1">if (cacheHandler &amp;&amp; !shouldForceRevalidate(workStore, workUnitStore)) {</span><span class="s3">\n          </span><span class="s1">entry = await cacheHandler.get(</span><span class="s3">\n            </span><span class="s1">serializedCacheKey,</span><span class="s3">\n            </span><span class="s1">workUnitStore?.implicitTags?.tags ?? []</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (entry) {</span><span class="s3">\n          </span><span class="s1">const implicitTags = workUnitStore?.implicitTags?.tags ?? []</span><span class="s3">\n          </span><span class="s1">let implicitTagsExpiration = 0</span><span class="s3">\n\n          </span><span class="s1">if (workUnitStore?.implicitTags) {</span><span class="s3">\n            </span><span class="s1">const lazyExpiration =</span><span class="s3">\n              </span><span class="s1">workUnitStore.implicitTags.expirationsByCacheKind.get(kind)</span><span class="s3">\n\n            </span><span class="s1">if (lazyExpiration) {</span><span class="s3">\n              </span><span class="s1">const expiration = isResolvedLazyResult(lazyExpiration)</span><span class="s3">\n                </span><span class="s1">? lazyExpiration.value</span><span class="s3">\n                </span><span class="s1">: await lazyExpiration</span><span class="s3">\n\n              </span><span class="s1">// If a cache handler returns an expiration time of Infinity, it</span><span class="s3">\n              </span><span class="s1">// signals to Next.js that it handles checking cache entries for</span><span class="s3">\n              </span><span class="s1">// staleness based on the expiration of the implicit tags passed</span><span class="s3">\n              </span><span class="s1">// into the `get` method. In this case, we keep the default of 0,</span><span class="s3">\n              </span><span class="s1">// which means that the implicit tags are not considered expired.</span><span class="s3">\n              </span><span class="s1">if (expiration &lt; Infinity) {</span><span class="s3">\n                </span><span class="s1">implicitTagsExpiration = expiration</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">shouldDiscardCacheEntry(</span><span class="s3">\n              </span><span class="s1">entry,</span><span class="s3">\n              </span><span class="s1">workStore,</span><span class="s3">\n              </span><span class="s1">workUnitStore,</span><span class="s3">\n              </span><span class="s1">implicitTags,</span><span class="s3">\n              </span><span class="s1">implicitTagsExpiration</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">debug?.('discarding stale entry', serializedCacheKey)</span><span class="s3">\n            </span><span class="s1">entry = undefined</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const currentTime = performance.timeOrigin + performance.now()</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">workUnitStore !== undefined &amp;&amp;</span><span class="s3">\n          </span><span class="s1">entry !== undefined &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(entry.revalidate === 0 || entry.expire &lt; DYNAMIC_EXPIRE)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n            </span><span class="s1">case 'prerender':</span><span class="s3">\n              </span><span class="s1">// In a Dynamic I/O prerender, if the cache entry has revalidate:</span><span class="s3">\n              </span><span class="s1">// 0 or if the expire time is under 5 minutes, then we consider</span><span class="s3">\n              </span><span class="s1">// this cache entry dynamic as it's not worth generating static</span><span class="s3">\n              </span><span class="s1">// pages for such data. It's better to leave a PPR hole that can</span><span class="s3">\n              </span><span class="s1">// be filled in dynamically with a potentially cached entry.</span><span class="s3">\n              </span><span class="s1">if (cacheSignal) {</span><span class="s3">\n                </span><span class="s1">cacheSignal.endRead()</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">return makeHangingPromise(</span><span class="s3">\n                </span><span class="s1">workUnitStore.renderSignal,</span><span class="s3">\n                </span><span class="s1">workStore.route,</span><span class="s3">\n                </span><span class="s1">'dynamic </span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n              </span><span class="s1">// In a runtime prerender, we have to make sure that APIs that would hang during a static prerender</span><span class="s3">\n              </span><span class="s1">// are resolved with a delay, in the runtime stage.</span><span class="s3">\n              </span><span class="s1">if (workUnitStore.runtimeStagePromise) {</span><span class="s3">\n                </span><span class="s1">await workUnitStore.runtimeStagePromise</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n            </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n            </span><span class="s1">case 'request':</span><span class="s3">\n            </span><span class="s1">case 'cache':</span><span class="s3">\n            </span><span class="s1">case 'private-cache':</span><span class="s3">\n            </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n              </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n              </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">entry === undefined ||</span><span class="s3">\n          </span><span class="s1">currentTime &gt; entry.timestamp + entry.expire * 1000 ||</span><span class="s3">\n          </span><span class="s1">(workStore.isStaticGeneration &amp;&amp;</span><span class="s3">\n            </span><span class="s1">currentTime &gt; entry.timestamp + entry.revalidate * 1000)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">// Miss. Generate a new result.</span><span class="s3">\n\n          </span><span class="s1">// If the cache entry is stale and we're prerendering, we don't want to use the</span><span class="s3">\n          </span><span class="s1">// stale entry since it would unnecessarily need to shorten the lifetime of the</span><span class="s3">\n          </span><span class="s1">// prerender. We're not time constrained here so we can re-generated it now.</span><span class="s3">\n\n          </span><span class="s1">// We need to run this inside a clean AsyncLocalStorage snapshot so that the cache</span><span class="s3">\n          </span><span class="s1">// generation cannot read anything from the context we're currently executing which</span><span class="s3">\n          </span><span class="s1">// might include request specific things like cookies() inside a React.cache().</span><span class="s3">\n          </span><span class="s1">// Note: It is important that we await at least once before this because it lets us</span><span class="s3">\n          </span><span class="s1">// pop out of any stack specific contexts as well - aka </span><span class="s3">\&quot;</span><span class="s1">Sync</span><span class="s3">\&quot; </span><span class="s1">Local Storage.</span><span class="s3">\n\n          </span><span class="s1">if (entry) {</span><span class="s3">\n            </span><span class="s1">if (currentTime &gt; entry.timestamp + entry.expire * 1000) {</span><span class="s3">\n              </span><span class="s1">debug?.('entry is expired', serializedCacheKey)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">workStore.isStaticGeneration &amp;&amp;</span><span class="s3">\n              </span><span class="s1">currentTime &gt; entry.timestamp + entry.revalidate * 1000</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">debug?.('static generation, entry is stale', serializedCacheKey)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">const result = await generateCacheEntry(</span><span class="s3">\n            </span><span class="s1">workStore,</span><span class="s3">\n            </span><span class="s1">cacheContext,</span><span class="s3">\n            </span><span class="s1">clientReferenceManifest,</span><span class="s3">\n            </span><span class="s1">encodedCacheKeyParts,</span><span class="s3">\n            </span><span class="s1">fn,</span><span class="s3">\n            </span><span class="s1">sharedErrorStack</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">if (result.type === 'prerender-dynamic') {</span><span class="s3">\n            </span><span class="s1">return result.hangingPromise</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">const { stream: newStream, pendingCacheEntry } = result</span><span class="s3">\n\n          </span><span class="s1">// When draft mode is enabled, we must not save the cache entry.</span><span class="s3">\n          </span><span class="s1">if (!workStore.isDraftMode) {</span><span class="s3">\n            </span><span class="s1">let savedCacheEntry</span><span class="s3">\n\n            </span><span class="s1">if (prerenderResumeDataCache) {</span><span class="s3">\n              </span><span class="s1">// Create a clone that goes into the cache scope memory cache.</span><span class="s3">\n              </span><span class="s1">const split = clonePendingCacheEntry(pendingCacheEntry)</span><span class="s3">\n              </span><span class="s1">savedCacheEntry = getNthCacheEntry(split, 0)</span><span class="s3">\n              </span><span class="s1">prerenderResumeDataCache.cache.set(</span><span class="s3">\n                </span><span class="s1">serializedCacheKey,</span><span class="s3">\n                </span><span class="s1">getNthCacheEntry(split, 1)</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">savedCacheEntry = pendingCacheEntry</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (cacheHandler) {</span><span class="s3">\n              </span><span class="s1">const promise = cacheHandler.set(</span><span class="s3">\n                </span><span class="s1">serializedCacheKey,</span><span class="s3">\n                </span><span class="s1">savedCacheEntry</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n\n              </span><span class="s1">workStore.pendingRevalidateWrites ??= []</span><span class="s3">\n              </span><span class="s1">workStore.pendingRevalidateWrites.push(promise)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">stream = newStream</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// If we have an entry at this point, this can't be a private cache</span><span class="s3">\n          </span><span class="s1">// entry.</span><span class="s3">\n          </span><span class="s1">if (cacheContext.kind === 'private') {</span><span class="s3">\n            </span><span class="s1">throw new InvariantError(</span><span class="s3">\n              </span><span class="s1">`A private cache entry must not be retrieved from the cache handler.`</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">propagateCacheLifeAndTags(cacheContext, entry)</span><span class="s3">\n\n          </span><span class="s1">// We want to return this stream, even if it's stale.</span><span class="s3">\n          </span><span class="s1">stream = entry.value</span><span class="s3">\n\n          </span><span class="s1">// If we have a cache scope, we need to clone the entry and set it on</span><span class="s3">\n          </span><span class="s1">// the inner cache scope.</span><span class="s3">\n          </span><span class="s1">if (prerenderResumeDataCache) {</span><span class="s3">\n            </span><span class="s1">const [entryLeft, entryRight] = cloneCacheEntry(entry)</span><span class="s3">\n            </span><span class="s1">if (cacheSignal) {</span><span class="s3">\n              </span><span class="s1">stream = createTrackedReadableStream(entryLeft.value, cacheSignal)</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">stream = entryLeft.value</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">prerenderResumeDataCache.cache.set(</span><span class="s3">\n              </span><span class="s1">serializedCacheKey,</span><span class="s3">\n              </span><span class="s1">Promise.resolve(entryRight)</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">// If we're not regenerating we need to signal that we've finished</span><span class="s3">\n            </span><span class="s1">// putting the entry into the cache scope at this point. Otherwise we do</span><span class="s3">\n            </span><span class="s1">// that inside generateCacheEntry.</span><span class="s3">\n            </span><span class="s1">cacheSignal?.endRead()</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (currentTime &gt; entry.timestamp + entry.revalidate * 1000) {</span><span class="s3">\n            </span><span class="s1">// If this is stale, and we're not in a prerender (i.e. this is</span><span class="s3">\n            </span><span class="s1">// dynamic render), then we should warm up the cache with a fresh</span><span class="s3">\n            </span><span class="s1">// revalidated entry.</span><span class="s3">\n            </span><span class="s1">const result = await generateCacheEntry(</span><span class="s3">\n              </span><span class="s1">workStore,</span><span class="s3">\n              </span><span class="s1">// This is not running within the context of this unit.</span><span class="s3">\n              </span><span class="s1">{ kind: cacheContext.kind, outerWorkUnitStore: undefined },</span><span class="s3">\n              </span><span class="s1">clientReferenceManifest,</span><span class="s3">\n              </span><span class="s1">encodedCacheKeyParts,</span><span class="s3">\n              </span><span class="s1">fn,</span><span class="s3">\n              </span><span class="s1">sharedErrorStack</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n\n            </span><span class="s1">if (result.type === 'cached') {</span><span class="s3">\n              </span><span class="s1">const { stream: ignoredStream, pendingCacheEntry } = result</span><span class="s3">\n              </span><span class="s1">let savedCacheEntry: Promise&lt;CacheEntry&gt;</span><span class="s3">\n\n              </span><span class="s1">if (prerenderResumeDataCache) {</span><span class="s3">\n                </span><span class="s1">const split = clonePendingCacheEntry(pendingCacheEntry)</span><span class="s3">\n                </span><span class="s1">savedCacheEntry = getNthCacheEntry(split, 0)</span><span class="s3">\n                </span><span class="s1">prerenderResumeDataCache.cache.set(</span><span class="s3">\n                  </span><span class="s1">serializedCacheKey,</span><span class="s3">\n                  </span><span class="s1">getNthCacheEntry(split, 1)</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">savedCacheEntry = pendingCacheEntry</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">if (cacheHandler) {</span><span class="s3">\n                </span><span class="s1">const promise = cacheHandler.set(</span><span class="s3">\n                  </span><span class="s1">serializedCacheKey,</span><span class="s3">\n                  </span><span class="s1">savedCacheEntry</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n\n                </span><span class="s1">workStore.pendingRevalidateWrites ??= []</span><span class="s3">\n                </span><span class="s1">workStore.pendingRevalidateWrites.push(promise)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">await ignoredStream.cancel()</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Logs are replayed even if it's a hit - to ensure we see them on the client eventually.</span><span class="s3">\n      </span><span class="s1">// If we didn't then the client wouldn't see the logs if it was seeded from a prewarm that</span><span class="s3">\n      </span><span class="s1">// never made it to the client. However, this also means that you see logs even when the</span><span class="s3">\n      </span><span class="s1">// cached function isn't actually re-executed. We should instead ensure prewarms always</span><span class="s3">\n      </span><span class="s1">// make it to the client. Another issue is that this will cause double logging in the</span><span class="s3">\n      </span><span class="s1">// server terminal. Once while generating the cache entry and once when replaying it on</span><span class="s3">\n      </span><span class="s1">// the server, which is required to pick it up for replaying again on the client.</span><span class="s3">\n      </span><span class="s1">const replayConsoleLogs = true</span><span class="s3">\n\n      </span><span class="s1">const serverConsumerManifest = {</span><span class="s3">\n        </span><span class="s1">// moduleLoading must be null because we don't want to trigger preloads of ClientReferences</span><span class="s3">\n        </span><span class="s1">// to be added to the consumer. Instead, we'll wait for any ClientReference to be emitted</span><span class="s3">\n        </span><span class="s1">// which themselves will handle the preloading.</span><span class="s3">\n        </span><span class="s1">moduleLoading: null,</span><span class="s3">\n        </span><span class="s1">moduleMap: isEdgeRuntime</span><span class="s3">\n          </span><span class="s1">? clientReferenceManifest.edgeRscModuleMapping</span><span class="s3">\n          </span><span class="s1">: clientReferenceManifest.rscModuleMapping,</span><span class="s3">\n        </span><span class="s1">serverModuleMap: getServerModuleMap(),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return createFromReadableStream(stream, {</span><span class="s3">\n        </span><span class="s1">findSourceMapURL,</span><span class="s3">\n        </span><span class="s1">serverConsumerManifest,</span><span class="s3">\n        </span><span class="s1">temporaryReferences,</span><span class="s3">\n        </span><span class="s1">replayConsoleLogs,</span><span class="s3">\n        </span><span class="s1">environmentName: 'Cache',</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">}[name]</span><span class="s3">\n\n  </span><span class="s1">return React.cache(cachedFn)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isPageComponent(</span><span class="s3">\n  </span><span class="s1">args: any[]</span><span class="s3">\n</span><span class="s1">): args is [UseCachePageComponentProps, undefined] {</span><span class="s3">\n  </span><span class="s1">if (args.length !== 2) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const [props, ref] = args</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">ref === undefined &amp;&amp; // server components receive an undefined ref arg</span><span class="s3">\n    </span><span class="s1">props !== null &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof props === 'object' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">(props as UseCachePageComponentProps).$$isPageComponent</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isLayoutComponent(</span><span class="s3">\n  </span><span class="s1">args: any[]</span><span class="s3">\n</span><span class="s1">): args is [UseCacheLayoutComponentProps, undefined] {</span><span class="s3">\n  </span><span class="s1">if (args.length !== 2) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const [props, ref] = args</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">ref === undefined &amp;&amp; // server components receive an undefined ref arg</span><span class="s3">\n    </span><span class="s1">props !== null &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof props === 'object' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">(props as UseCacheLayoutComponentProps).$$isLayoutComponent</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function shouldForceRevalidate(</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">workUnitStore: WorkUnitStore | undefined</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">if (workStore.isOnDemandRevalidate || workStore.isDraftMode) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (workStore.dev &amp;&amp; workUnitStore) {</span><span class="s3">\n    </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n      </span><span class="s1">case 'request':</span><span class="s3">\n        </span><span class="s1">return workUnitStore.headers.get('cache-control') === 'no-cache'</span><span class="s3">\n      </span><span class="s1">case 'cache':</span><span class="s3">\n      </span><span class="s1">case 'private-cache':</span><span class="s3">\n        </span><span class="s1">return workUnitStore.forceRevalidate</span><span class="s3">\n      </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n      </span><span class="s1">case 'prerender':</span><span class="s3">\n      </span><span class="s1">case 'prerender-client':</span><span class="s3">\n      </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n      </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n      </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function shouldDiscardCacheEntry(</span><span class="s3">\n  </span><span class="s1">entry: CacheEntry,</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">workUnitStore: WorkUnitStore | undefined,</span><span class="s3">\n  </span><span class="s1">implicitTags: string[],</span><span class="s3">\n  </span><span class="s1">implicitTagsExpiration: number</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">// If the cache entry was created before any of the implicit tags were</span><span class="s3">\n  </span><span class="s1">// revalidated last, we need to discard it.</span><span class="s3">\n  </span><span class="s1">if (entry.timestamp &lt;= implicitTagsExpiration) {</span><span class="s3">\n    </span><span class="s1">debug?.(</span><span class="s3">\n      </span><span class="s1">'entry was created at',</span><span class="s3">\n      </span><span class="s1">entry.timestamp,</span><span class="s3">\n      </span><span class="s1">'before implicit tags were revalidated at',</span><span class="s3">\n      </span><span class="s1">implicitTagsExpiration</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// During prerendering, we ignore recently revalidated tags. In dev mode, we</span><span class="s3">\n  </span><span class="s1">// can assume that the dynamic dev rendering will have discarded and recreated</span><span class="s3">\n  </span><span class="s1">// the affected cache entries, and we don't want to discard those again during</span><span class="s3">\n  </span><span class="s1">// the prerender validation. During build-time prerendering, there will never</span><span class="s3">\n  </span><span class="s1">// be any pending revalidated tags.</span><span class="s3">\n  </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n    </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n      </span><span class="s1">case 'prerender':</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n      </span><span class="s1">case 'prerender-client':</span><span class="s3">\n      </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n      </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n      </span><span class="s1">case 'request':</span><span class="s3">\n      </span><span class="s1">case 'cache':</span><span class="s3">\n      </span><span class="s1">case 'private-cache':</span><span class="s3">\n      </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If the cache entry contains revalidated tags that the cache handler might</span><span class="s3">\n  </span><span class="s1">// not know about yet, we need to discard it.</span><span class="s3">\n  </span><span class="s1">if (entry.tags.some((tag) =&gt; isRecentlyRevalidatedTag(tag, workStore))) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Finally, if any of the implicit tags have been revalidated recently, we</span><span class="s3">\n  </span><span class="s1">// also need to discard the cache entry.</span><span class="s3">\n  </span><span class="s1">if (implicitTags.some((tag) =&gt; isRecentlyRevalidatedTag(tag, workStore))) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isRecentlyRevalidatedTag(tag: string, workStore: WorkStore): boolean {</span><span class="s3">\n  </span><span class="s1">const { previouslyRevalidatedTags, pendingRevalidatedTags } = workStore</span><span class="s3">\n\n  </span><span class="s1">// Was the tag previously revalidated (e.g. by a redirecting server action)?</span><span class="s3">\n  </span><span class="s1">if (previouslyRevalidatedTags.includes(tag)) {</span><span class="s3">\n    </span><span class="s1">debug?.('tag', tag, 'was previously revalidated')</span><span class="s3">\n\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// It could also have been revalidated by the currently running server action.</span><span class="s3">\n  </span><span class="s1">// In this case the revalidation might not have been fully propagated by a</span><span class="s3">\n  </span><span class="s1">// remote cache handler yet, so we read it from the pending tags in the work</span><span class="s3">\n  </span><span class="s1">// store.</span><span class="s3">\n  </span><span class="s1">if (pendingRevalidatedTags?.includes(tag)) {</span><span class="s3">\n    </span><span class="s1">debug?.('tag', tag, 'was just revalidated')</span><span class="s3">\n\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;isEdgeRuntime&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_RUNTIME&quot;</span><span class="s0">,</span><span class="s1">&quot;debug&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_PRIVATE_DEBUG_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;filterStackFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;filterStackFrameDEV&quot;</span><span class="s0">,</span><span class="s1">&quot;findSourceMapURL&quot;</span><span class="s0">,</span><span class="s1">&quot;findSourceMapURLDEV&quot;</span><span class="s0">,</span><span class="s1">&quot;generateCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;workStore&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheContext&quot;</span><span class="s0">,</span><span class="s1">&quot;clientReferenceManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;encodedArguments&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;sharedErrorStack&quot;</span><span class="s0">,</span><span class="s1">&quot;runInCleanSnapshot&quot;</span><span class="s0">,</span><span class="s1">&quot;generateCacheEntryWithRestoredWorkStore&quot;</span><span class="s0">,</span><span class="s1">&quot;workAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;run&quot;</span><span class="s0">,</span><span class="s1">&quot;generateCacheEntryWithCacheContext&quot;</span><span class="s0">,</span><span class="s1">&quot;createUseCacheStore&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultCacheLife&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;outerWorkUnitStore&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;phase&quot;</span><span class="s0">,</span><span class="s1">&quot;implicitTags&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;expire&quot;</span><span class="s0">,</span><span class="s1">&quot;stale&quot;</span><span class="s0">,</span><span class="s1">&quot;explicitRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;explicitExpire&quot;</span><span class="s0">,</span><span class="s1">&quot;explicitStale&quot;</span><span class="s0">,</span><span class="s1">&quot;tags&quot;</span><span class="s0">,</span><span class="s1">&quot;hmrRefreshHash&quot;</span><span class="s0">,</span><span class="s1">&quot;getHmrRefreshHash&quot;</span><span class="s0">,</span><span class="s1">&quot;isHmrRefresh&quot;</span><span class="s0">,</span><span class="s1">&quot;serverComponentsHmrCache&quot;</span><span class="s0">,</span><span class="s1">&quot;getServerComponentsHmrCache&quot;</span><span class="s0">,</span><span class="s1">&quot;forceRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldForceRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;runtimeStagePromise&quot;</span><span class="s0">,</span><span class="s1">&quot;getRuntimeStagePromise&quot;</span><span class="s0">,</span><span class="s1">&quot;draftMode&quot;</span><span class="s0">,</span><span class="s1">&quot;getDraftModeProviderForCacheScope&quot;</span><span class="s0">,</span><span class="s1">&quot;rootParams&quot;</span><span class="s0">,</span><span class="s1">&quot;cookies&quot;</span><span class="s0">,</span><span class="s1">&quot;useCacheOrRequestStore&quot;</span><span class="s0">,</span><span class="s1">&quot;assertDefaultCacheLife&quot;</span><span class="s0">,</span><span class="s1">&quot;InvariantError&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheLifeProfiles&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheStore&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicAccessAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;abortController&quot;</span><span class="s0">,</span><span class="s1">&quot;AbortController&quot;</span><span class="s0">,</span><span class="s1">&quot;generateCacheEntryImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;propagateCacheLifeAndTagsToRevalidateStore&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateStore&quot;</span><span class="s0">,</span><span class="s1">&quot;entry&quot;</span><span class="s0">,</span><span class="s1">&quot;outerTags&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;propagateCacheLifeAndTags&quot;</span><span class="s0">,</span><span class="s1">&quot;collectResult&quot;</span><span class="s0">,</span><span class="s1">&quot;savedStream&quot;</span><span class="s0">,</span><span class="s1">&quot;innerCacheStore&quot;</span><span class="s0">,</span><span class="s1">&quot;startTime&quot;</span><span class="s0">,</span><span class="s1">&quot;errors&quot;</span><span class="s0">,</span><span class="s1">&quot;buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;reader&quot;</span><span class="s0">,</span><span class="s1">&quot;getReader&quot;</span><span class="s0">,</span><span class="s1">&quot;read&quot;</span><span class="s0">,</span><span class="s1">&quot;done&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;idx&quot;</span><span class="s0">,</span><span class="s1">&quot;bufferStream&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;pull&quot;</span><span class="s0">,</span><span class="s1">&quot;controller&quot;</span><span class="s0">,</span><span class="s1">&quot;invalidDynamicUsageError&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;enqueue&quot;</span><span class="s0">,</span><span class="s1">&quot;close&quot;</span><span class="s0">,</span><span class="s1">&quot;collectedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;collectedRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;collectedExpire&quot;</span><span class="s0">,</span><span class="s1">&quot;collectedStale&quot;</span><span class="s0">,</span><span class="s1">&quot;timestamp&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;getCacheSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;endRead&quot;</span><span class="s0">,</span><span class="s1">&quot;temporaryReferences&quot;</span><span class="s0">,</span><span class="s1">&quot;createServerTemporaryReferenceSet&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeReply&quot;</span><span class="s0">,</span><span class="s1">&quot;getServerModuleMap&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeReplyFromAsyncIterable&quot;</span><span class="s0">,</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;asyncIterator&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;renderSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;aborted&quot;</span><span class="s0">,</span><span class="s1">&quot;addEventListener&quot;</span><span class="s0">,</span><span class="s1">&quot;once&quot;</span><span class="s0">,</span><span class="s1">&quot;performance&quot;</span><span class="s0">,</span><span class="s1">&quot;timeOrigin&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;resultPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;createLazyResult&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;handleError&quot;</span><span class="s0">,</span><span class="s1">&quot;digest&quot;</span><span class="s0">,</span><span class="s1">&quot;getDigestForWellKnownError&quot;</span><span class="s0">,</span><span class="s1">&quot;isReactLargeShellError&quot;</span><span class="s0">,</span><span class="s1">&quot;stream&quot;</span><span class="s0">,</span><span class="s1">&quot;timeoutAbortController&quot;</span><span class="s0">,</span><span class="s1">&quot;timer&quot;</span><span class="s0">,</span><span class="s1">&quot;setTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;UseCacheTimeoutError&quot;</span><span class="s0">,</span><span class="s1">&quot;stack&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;abort&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicAccessAbortSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;getStore&quot;</span><span class="s0">,</span><span class="s1">&quot;signal&quot;</span><span class="s0">,</span><span class="s1">&quot;abortSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;AbortSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;any&quot;</span><span class="s0">,</span><span class="s1">&quot;prelude&quot;</span><span class="s0">,</span><span class="s1">&quot;prerender&quot;</span><span class="s0">,</span><span class="s1">&quot;clientModules&quot;</span><span class="s0">,</span><span class="s1">&quot;environmentName&quot;</span><span class="s0">,</span><span class="s1">&quot;onError&quot;</span><span class="s0">,</span><span class="s1">&quot;reason&quot;</span><span class="s0">,</span><span class="s1">&quot;clearTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;hangingPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;makeHangingPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;returnStream&quot;</span><span class="s0">,</span><span class="s1">&quot;tee&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;streamA&quot;</span><span class="s0">,</span><span class="s1">&quot;streamB&quot;</span><span class="s0">,</span><span class="s1">&quot;clonedEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;clonePendingCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;getNthCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeFormData&quot;</span><span class="s0">,</span><span class="s1">&quot;formData&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;stringValue&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;byteLength&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;fromCodePoint&quot;</span><span class="s0">,</span><span class="s1">&quot;Uint16Array&quot;</span><span class="s0">,</span><span class="s1">&quot;Uint8Array&quot;</span><span class="s0">,</span><span class="s1">&quot;createTrackedReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapAsInvalidDynamicUsageError&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;boundArgsLength&quot;</span><span class="s0">,</span><span class="s1">&quot;originalFn&quot;</span><span class="s0">,</span><span class="s1">&quot;sharedError&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrivate&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;getCacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;captureStackTrace&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedFn&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitStore&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;postponeWithTracking&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicTracking&quot;</span><span class="s0">,</span><span class="s1">&quot;throwToInterruptStaticGeneration&quot;</span><span class="s0">,</span><span class="s1">&quot;getClientReferenceManifestForRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;buildId&quot;</span><span class="s0">,</span><span class="s1">&quot;hangingInputAbortSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;createHangingInputAbortSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;isPageOrLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;isPageComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;outerParams&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;outerSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;_innerParams&quot;</span><span class="s0">,</span><span class="s1">&quot;innerSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;makeErroringSearchParamsForUseCache&quot;</span><span class="s0">,</span><span class="s1">&quot;isLayoutComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;$$isLayoutComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;outerSlots&quot;</span><span class="s0">,</span><span class="s1">&quot;innerSlots&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;encryptedBoundArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;shift&quot;</span><span class="s0">,</span><span class="s1">&quot;boundArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;decryptActionBoundArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;createClientTemporaryReferenceSet&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKeyParts&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeCacheKeyParts&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeReply&quot;</span><span class="s0">,</span><span class="s1">&quot;encodedCacheKeyParts&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicAccessAbortController&quot;</span><span class="s0">,</span><span class="s1">&quot;serializedCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;getPrerenderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;renderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;getRenderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;beginRead&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;existingEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;DYNAMIC_EXPIRE&quot;</span><span class="s0">,</span><span class="s1">&quot;RUNTIME_PREFETCH_DYNAMIC_STALE&quot;</span><span class="s0">,</span><span class="s1">&quot;allowEmptyStaticShell&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyRefreshTags&quot;</span><span class="s0">,</span><span class="s1">&quot;refreshTagsByCacheKind&quot;</span><span class="s0">,</span><span class="s1">&quot;isResolvedLazyResult&quot;</span><span class="s0">,</span><span class="s1">&quot;implicitTagsExpiration&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyExpiration&quot;</span><span class="s0">,</span><span class="s1">&quot;expirationsByCacheKind&quot;</span><span class="s0">,</span><span class="s1">&quot;expiration&quot;</span><span class="s0">,</span><span class="s1">&quot;Infinity&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldDiscardCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;currentTime&quot;</span><span class="s0">,</span><span class="s1">&quot;isStaticGeneration&quot;</span><span class="s0">,</span><span class="s1">&quot;newStream&quot;</span><span class="s0">,</span><span class="s1">&quot;isDraftMode&quot;</span><span class="s0">,</span><span class="s1">&quot;savedCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;promise&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingRevalidateWrites&quot;</span><span class="s0">,</span><span class="s1">&quot;entryLeft&quot;</span><span class="s0">,</span><span class="s1">&quot;entryRight&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoredStream&quot;</span><span class="s0">,</span><span class="s1">&quot;cancel&quot;</span><span class="s0">,</span><span class="s1">&quot;replayConsoleLogs&quot;</span><span class="s0">,</span><span class="s1">&quot;serverConsumerManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;moduleLoading&quot;</span><span class="s0">,</span><span class="s1">&quot;moduleMap&quot;</span><span class="s0">,</span><span class="s1">&quot;edgeRscModuleMapping&quot;</span><span class="s0">,</span><span class="s1">&quot;rscModuleMapping&quot;</span><span class="s0">,</span><span class="s1">&quot;serverModuleMap&quot;</span><span class="s0">,</span><span class="s1">&quot;createFromReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;React&quot;</span><span class="s0">,</span><span class="s1">&quot;ref&quot;</span><span class="s0">,</span><span class="s1">&quot;$$isPageComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;isOnDemandRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;dev&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;isRecentlyRevalidatedTag&quot;</span><span class="s0">,</span><span class="s1">&quot;previouslyRevalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingRevalidatedTags&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>