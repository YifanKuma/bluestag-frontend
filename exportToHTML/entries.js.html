<html>
<head>
<title>entries.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #264eff;}
.s6 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
entries.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">collectAppFiles: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">collectPagesFiles: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">combineSlots: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">createEntrypoints: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">createPagesMapping: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">createRelativeFilePath: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">extractSlotsFromAppRoutes: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">extractSlotsFromDefaultFiles: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">finalizeEntrypoint: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getAppEntry: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getAppLoader: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getClientEntry: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getEdgeServerEntry: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getInstrumentationEntry: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getPageFilePath: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getPageFromPath: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getStaticInfoIncludingLayouts: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">processAppRoutes: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">processLayoutRoutes: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">processPageRoutes: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">runDependingOnPageType: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">sortByPageExts: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">collectAppFiles: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">collectAppFiles;</span>
    <span class="s1">},</span>
    <span class="s1">collectPagesFiles: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">collectPagesFiles;</span>
    <span class="s1">},</span>
    <span class="s1">combineSlots: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">combineSlots;</span>
    <span class="s1">},</span>
    <span class="s1">createEntrypoints: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createEntrypoints;</span>
    <span class="s1">},</span>
    <span class="s1">createPagesMapping: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createPagesMapping;</span>
    <span class="s1">},</span>
    <span class="s1">createRelativeFilePath: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createRelativeFilePath;</span>
    <span class="s1">},</span>
    <span class="s1">extractSlotsFromAppRoutes: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">extractSlotsFromAppRoutes;</span>
    <span class="s1">},</span>
    <span class="s1">extractSlotsFromDefaultFiles: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">extractSlotsFromDefaultFiles;</span>
    <span class="s1">},</span>
    <span class="s1">finalizeEntrypoint: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">finalizeEntrypoint;</span>
    <span class="s1">},</span>
    <span class="s1">getAppEntry: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getAppEntry;</span>
    <span class="s1">},</span>
    <span class="s1">getAppLoader: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getAppLoader;</span>
    <span class="s1">},</span>
    <span class="s1">getClientEntry: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getClientEntry;</span>
    <span class="s1">},</span>
    <span class="s1">getEdgeServerEntry: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getEdgeServerEntry;</span>
    <span class="s1">},</span>
    <span class="s1">getInstrumentationEntry: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getInstrumentationEntry;</span>
    <span class="s1">},</span>
    <span class="s1">getPageFilePath: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getPageFilePath;</span>
    <span class="s1">},</span>
    <span class="s1">getPageFromPath: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getPageFromPath;</span>
    <span class="s1">},</span>
    <span class="s1">getStaticInfoIncludingLayouts: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getStaticInfoIncludingLayouts;</span>
    <span class="s1">},</span>
    <span class="s1">processAppRoutes: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">processAppRoutes;</span>
    <span class="s1">},</span>
    <span class="s1">processLayoutRoutes: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">processLayoutRoutes;</span>
    <span class="s1">},</span>
    <span class="s1">processPageRoutes: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">processPageRoutes;</span>
    <span class="s1">},</span>
    <span class="s1">runDependingOnPageType: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">runDependingOnPageType;</span>
    <span class="s1">},</span>
    <span class="s1">sortByPageExts: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">sortByPageExts;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_path = require(</span><span class="s0">&quot;path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_querystring = require(</span><span class="s0">&quot;querystring&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_fs = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;fs&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_constants = require(</span><span class="s0">&quot;../lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_isapiroute = require(</span><span class="s0">&quot;../lib/is-api-route&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_isedgeruntime = require(</span><span class="s0">&quot;../lib/is-edge-runtime&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants1 = require(</span><span class="s0">&quot;../shared/lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils = require(</span><span class="s0">&quot;./utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_getpagestaticinfo = require(</span><span class="s0">&quot;./analysis/get-page-static-info&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_normalizepathsep = require(</span><span class="s0">&quot;../shared/lib/page-path/normalize-path-sep&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_normalizepagepath = require(</span><span class="s0">&quot;../shared/lib/page-path/normalize-page-path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_apppaths = require(</span><span class="s0">&quot;../shared/lib/router/utils/app-paths&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_nextmiddlewareloader = require(</span><span class="s0">&quot;./webpack/loaders/next-middleware-loader&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_isapprouteroute = require(</span><span class="s0">&quot;../lib/is-app-route-route&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_getmetadataroute = require(</span><span class="s0">&quot;../lib/metadata/get-metadata-route&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_nextrouteloader = require(</span><span class="s0">&quot;./webpack/loaders/next-route-loader&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_isinternalcomponent = require(</span><span class="s0">&quot;../lib/is-internal-component&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_ismetadataroute = require(</span><span class="s0">&quot;../lib/metadata/is-metadata-route&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_routekind = require(</span><span class="s0">&quot;../server/route-kind&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils1 = require(</span><span class="s0">&quot;./webpack/loaders/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_normalizecatchallroutes = require(</span><span class="s0">&quot;./normalize-catchall-routes&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_pagetypes = require(</span><span class="s0">&quot;../lib/page-types&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_isapppageroute = require(</span><span class="s0">&quot;../lib/is-app-page-route&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_recursivereaddir = require(</span><span class="s0">&quot;../lib/recursive-readdir&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_segment = require(</span><span class="s0">&quot;../shared/lib/segment&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_ensureleadingslash = require(</span><span class="s0">&quot;../shared/lib/page-path/ensure-leading-slash&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">collectAppFiles(appDir, validFileMatcher) {</span>
    <span class="s4">// Collect app pages, layouts, and default files in a single directory traversal</span>
    <span class="s2">const </span><span class="s1">allAppFiles = </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _recursivereaddir.recursiveReadDir)(appDir, {</span>
        <span class="s1">pathnameFilter: (absolutePath)=&gt;validFileMatcher.isAppRouterPage(absolutePath) || validFileMatcher.isRootNotFound(absolutePath) || validFileMatcher.isAppLayoutPage(absolutePath) || validFileMatcher.isAppDefaultPage(absolutePath),</span>
        <span class="s1">ignorePartFilter: (part)=&gt;part.startsWith(</span><span class="s0">'_'</span><span class="s1">)</span>
    <span class="s1">});</span>
    <span class="s4">// Separate app pages, layouts, and defaults</span>
    <span class="s2">const </span><span class="s1">appPaths = allAppFiles.filter((absolutePath)=&gt;validFileMatcher.isAppRouterPage(absolutePath) || validFileMatcher.isRootNotFound(absolutePath));</span>
    <span class="s2">const </span><span class="s1">layoutPaths = allAppFiles.filter((absolutePath)=&gt;validFileMatcher.isAppLayoutPage(absolutePath));</span>
    <span class="s2">const </span><span class="s1">defaultPaths = allAppFiles.filter((absolutePath)=&gt;validFileMatcher.isAppDefaultPage(absolutePath));</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">appPaths,</span>
        <span class="s1">layoutPaths,</span>
        <span class="s1">defaultPaths</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">collectPagesFiles(pagesDir, validFileMatcher) {</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _recursivereaddir.recursiveReadDir)(pagesDir, {</span>
        <span class="s1">pathnameFilter: validFileMatcher.isPageFile</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createRelativeFilePath(baseDir, filePath, prefix, isSrcDir) {</span>
    <span class="s2">const </span><span class="s1">privatePrefix = prefix === </span><span class="s0">'pages' </span><span class="s1">? </span><span class="s0">'private-next-pages' </span><span class="s1">: </span><span class="s0">'private-next-app-dir'</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">srcPrefix = isSrcDir ? </span><span class="s0">'src/' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _path.join)(baseDir, filePath.replace(</span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s0">`^</span><span class="s1">${privatePrefix}</span><span class="s0">/`</span><span class="s1">), </span><span class="s0">`</span><span class="s1">${srcPrefix}${prefix}</span><span class="s0">/`</span><span class="s1">));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">processPageRoutes(mappedPages, baseDir, isSrcDir) {</span>
    <span class="s2">const </span><span class="s1">pageRoutes = [];</span>
    <span class="s2">const </span><span class="s1">pageApiRoutes = [];</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[route, filePath] of Object.entries(mappedPages)){</span>
        <span class="s2">const </span><span class="s1">relativeFilePath = createRelativeFilePath(baseDir, filePath, </span><span class="s0">'pages'</span><span class="s1">, isSrcDir);</span>
        <span class="s2">if </span><span class="s1">(route.startsWith(</span><span class="s0">'/api/'</span><span class="s1">)) {</span>
            <span class="s1">pageApiRoutes.push({</span>
                <span class="s1">route: (</span><span class="s3">0</span><span class="s1">, _normalizepathsep.normalizePathSep)(route),</span>
                <span class="s1">filePath: relativeFilePath</span>
            <span class="s1">});</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s4">// Filter out _app, _error, _document</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _utils.isReservedPage)(route)) </span><span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">pageRoutes.push({</span>
                <span class="s1">route: (</span><span class="s3">0</span><span class="s1">, _normalizepathsep.normalizePathSep)(route),</span>
                <span class="s1">filePath: relativeFilePath</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">pageRoutes,</span>
        <span class="s1">pageApiRoutes</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">extractSlotsFromAppRoutes(mappedAppPages) {</span>
    <span class="s2">const </span><span class="s1">slots = [];</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[route] of Object.entries(mappedAppPages)){</span>
        <span class="s2">if </span><span class="s1">(route === </span><span class="s0">'/_not-found/page'</span><span class="s1">) </span><span class="s2">continue</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">segments = route.split(</span><span class="s0">'/'</span><span class="s1">);</span>
        <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = segments.length - </span><span class="s3">1</span><span class="s1">; i &gt;= </span><span class="s3">0</span><span class="s1">; i--){</span>
            <span class="s2">const </span><span class="s1">segment = segments[i];</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _segment.isParallelRouteSegment)(segment)) {</span>
                <span class="s2">const </span><span class="s1">parentPath = (</span><span class="s3">0</span><span class="s1">, _apppaths.normalizeAppPath)(segments.slice(</span><span class="s3">0</span><span class="s1">, i).join(</span><span class="s0">'/'</span><span class="s1">));</span>
                <span class="s2">const </span><span class="s1">slotName = segment.slice(</span><span class="s3">1</span><span class="s1">);</span>
                <span class="s4">// Check if the slot already exists</span>
                <span class="s2">if </span><span class="s1">(slots.some((s)=&gt;s.name === slotName &amp;&amp; s.parent === parentPath)) </span><span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">slots.push({</span>
                    <span class="s1">name: slotName,</span>
                    <span class="s1">parent: parentPath</span>
                <span class="s1">});</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">slots;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">extractSlotsFromDefaultFiles(mappedDefaultFiles) {</span>
    <span class="s2">const </span><span class="s1">slots = [];</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[route] of Object.entries(mappedDefaultFiles)){</span>
        <span class="s2">const </span><span class="s1">segments = route.split(</span><span class="s0">'/'</span><span class="s1">);</span>
        <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = segments.length - </span><span class="s3">1</span><span class="s1">; i &gt;= </span><span class="s3">0</span><span class="s1">; i--){</span>
            <span class="s2">const </span><span class="s1">segment = segments[i];</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _segment.isParallelRouteSegment)(segment)) {</span>
                <span class="s2">const </span><span class="s1">parentPath = (</span><span class="s3">0</span><span class="s1">, _apppaths.normalizeAppPath)(segments.slice(</span><span class="s3">0</span><span class="s1">, i).join(</span><span class="s0">'/'</span><span class="s1">));</span>
                <span class="s2">const </span><span class="s1">slotName = segment.slice(</span><span class="s3">1</span><span class="s1">);</span>
                <span class="s4">// Check if the slot already exists</span>
                <span class="s2">if </span><span class="s1">(slots.some((s)=&gt;s.name === slotName &amp;&amp; s.parent === parentPath)) </span><span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">slots.push({</span>
                    <span class="s1">name: slotName,</span>
                    <span class="s1">parent: parentPath</span>
                <span class="s1">});</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">slots;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">combineSlots(...slotArrays) {</span>
    <span class="s2">const </span><span class="s1">slotSet = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s2">const </span><span class="s1">result = [];</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">slots of slotArrays){</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">slot of slots){</span>
            <span class="s2">const </span><span class="s1">key = </span><span class="s0">`</span><span class="s1">${slot.name}</span><span class="s0">:</span><span class="s1">${slot.parent}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(!slotSet.has(key)) {</span>
                <span class="s1">slotSet.add(key);</span>
                <span class="s1">result.push(slot);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">processAppRoutes(mappedAppPages, validFileMatcher, baseDir, isSrcDir) {</span>
    <span class="s2">const </span><span class="s1">appRoutes = [];</span>
    <span class="s2">const </span><span class="s1">appRouteHandlers = [];</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[route, filePath] of Object.entries(mappedAppPages)){</span>
        <span class="s2">if </span><span class="s1">(route === </span><span class="s0">'/_not-found/page'</span><span class="s1">) </span><span class="s2">continue</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">relativeFilePath = createRelativeFilePath(baseDir, filePath, </span><span class="s0">'app'</span><span class="s1">, isSrcDir);</span>
        <span class="s2">if </span><span class="s1">(validFileMatcher.isAppRouterRoute(filePath)) {</span>
            <span class="s1">appRouteHandlers.push({</span>
                <span class="s1">route: (</span><span class="s3">0</span><span class="s1">, _apppaths.normalizeAppPath)((</span><span class="s3">0</span><span class="s1">, _normalizepathsep.normalizePathSep)(route)),</span>
                <span class="s1">filePath: relativeFilePath</span>
            <span class="s1">});</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">appRoutes.push({</span>
                <span class="s1">route: (</span><span class="s3">0</span><span class="s1">, _apppaths.normalizeAppPath)((</span><span class="s3">0</span><span class="s1">, _normalizepathsep.normalizePathSep)(route)),</span>
                <span class="s1">filePath: relativeFilePath</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">appRoutes,</span>
        <span class="s1">appRouteHandlers</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">processLayoutRoutes(mappedAppLayouts, baseDir, isSrcDir) {</span>
    <span class="s2">const </span><span class="s1">layoutRoutes = [];</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[route, filePath] of Object.entries(mappedAppLayouts)){</span>
        <span class="s2">const </span><span class="s1">relativeFilePath = createRelativeFilePath(baseDir, filePath, </span><span class="s0">'app'</span><span class="s1">, isSrcDir);</span>
        <span class="s1">layoutRoutes.push({</span>
            <span class="s1">route: (</span><span class="s3">0</span><span class="s1">, _ensureleadingslash.ensureLeadingSlash)((</span><span class="s3">0</span><span class="s1">, _apppaths.normalizeAppPath)((</span><span class="s3">0</span><span class="s1">, _normalizepathsep.normalizePathSep)(route)).replace(</span><span class="s5">/\/layout$/</span><span class="s1">, </span><span class="s0">''</span><span class="s1">)),</span>
            <span class="s1">filePath: relativeFilePath</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">layoutRoutes;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">sortByPageExts(pageExtensions) {</span>
    <span class="s2">return </span><span class="s1">(a, b)=&gt;{</span>
        <span class="s4">// prioritize entries according to pageExtensions order</span>
        <span class="s4">// for consistency as fs order can differ across systems</span>
        <span class="s4">// NOTE: this is reversed so preferred comes last and</span>
        <span class="s4">// overrides prior</span>
        <span class="s2">const </span><span class="s1">aExt = (</span><span class="s3">0</span><span class="s1">, _path.extname)(a);</span>
        <span class="s2">const </span><span class="s1">bExt = (</span><span class="s3">0</span><span class="s1">, _path.extname)(b);</span>
        <span class="s2">const </span><span class="s1">aNoExt = a.substring(</span><span class="s3">0</span><span class="s1">, a.length - aExt.length);</span>
        <span class="s2">const </span><span class="s1">bNoExt = a.substring(</span><span class="s3">0</span><span class="s1">, b.length - bExt.length);</span>
        <span class="s2">if </span><span class="s1">(aNoExt !== bNoExt) </span><span class="s2">return </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s4">// find extension index (skip '.' as pageExtensions doesn't have it)</span>
        <span class="s2">const </span><span class="s1">aExtIndex = pageExtensions.indexOf(aExt.substring(</span><span class="s3">1</span><span class="s1">));</span>
        <span class="s2">const </span><span class="s1">bExtIndex = pageExtensions.indexOf(bExt.substring(</span><span class="s3">1</span><span class="s1">));</span>
        <span class="s2">return </span><span class="s1">bExtIndex - aExtIndex;</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">getStaticInfoIncludingLayouts({ isInsideAppDir, pageExtensions, pageFilePath, appDir, config: nextConfig, isDev, page }) {</span>
    <span class="s4">// TODO: sync types for pages: PAGE_TYPES, ROUTER_TYPE, 'app' | 'pages', etc.</span>
    <span class="s2">const </span><span class="s1">pageType = isInsideAppDir ? _pagetypes.PAGE_TYPES.APP : _pagetypes.PAGE_TYPES.PAGES;</span>
    <span class="s2">const </span><span class="s1">pageStaticInfo = </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _getpagestaticinfo.getPageStaticInfo)({</span>
        <span class="s1">nextConfig,</span>
        <span class="s1">pageFilePath,</span>
        <span class="s1">isDev,</span>
        <span class="s1">page,</span>
        <span class="s1">pageType</span>
    <span class="s1">});</span>
    <span class="s2">if </span><span class="s1">(pageStaticInfo.type === _pagetypes.PAGE_TYPES.PAGES || !appDir) {</span>
        <span class="s2">return </span><span class="s1">pageStaticInfo;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">segments = [</span>
        <span class="s1">pageStaticInfo</span>
    <span class="s1">];</span>
    <span class="s4">// inherit from layout files only if it's a page route</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _isapppageroute.isAppPageRoute)(page)) {</span>
        <span class="s2">const </span><span class="s1">layoutFiles = [];</span>
        <span class="s2">const </span><span class="s1">potentialLayoutFiles = pageExtensions.map((ext)=&gt;</span><span class="s0">'layout.' </span><span class="s1">+ ext);</span>
        <span class="s2">let </span><span class="s1">dir = (</span><span class="s3">0</span><span class="s1">, _path.dirname)(pageFilePath);</span>
        <span class="s4">// Uses startsWith to not include directories further up.</span>
        <span class="s2">while</span><span class="s1">(dir.startsWith(appDir)){</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">potentialLayoutFile of potentialLayoutFiles){</span>
                <span class="s2">const </span><span class="s1">layoutFile = (</span><span class="s3">0</span><span class="s1">, _path.join)(dir, potentialLayoutFile);</span>
                <span class="s2">if </span><span class="s1">(!_fs.default.existsSync(layoutFile)) {</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">layoutFiles.push(layoutFile);</span>
            <span class="s1">}</span>
            <span class="s4">// Walk up the directory tree</span>
            <span class="s1">dir = (</span><span class="s3">0</span><span class="s1">, _path.join)(dir, </span><span class="s0">'..'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">layoutFile of layoutFiles){</span>
            <span class="s2">const </span><span class="s1">layoutStaticInfo = </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _getpagestaticinfo.getAppPageStaticInfo)({</span>
                <span class="s1">nextConfig,</span>
                <span class="s1">pageFilePath: layoutFile,</span>
                <span class="s1">isDev,</span>
                <span class="s1">page,</span>
                <span class="s1">pageType: isInsideAppDir ? _pagetypes.PAGE_TYPES.APP : _pagetypes.PAGE_TYPES.PAGES</span>
            <span class="s1">});</span>
            <span class="s1">segments.unshift(layoutStaticInfo);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">config = (</span><span class="s3">0</span><span class="s1">, _utils.reduceAppConfig)(segments);</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">...pageStaticInfo,</span>
        <span class="s1">config,</span>
        <span class="s1">runtime: config.runtime,</span>
        <span class="s1">preferredRegion: config.preferredRegion,</span>
        <span class="s1">maxDuration: config.maxDuration</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getPageFromPath(pagePath, pageExtensions) {</span>
    <span class="s2">let </span><span class="s1">page = (</span><span class="s3">0</span><span class="s1">, _normalizepathsep.normalizePathSep)(pagePath.replace(</span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s0">`</span><span class="s6">\\</span><span class="s0">.+(</span><span class="s1">${pageExtensions.join(</span><span class="s0">'|'</span><span class="s1">)}</span><span class="s0">)$`</span><span class="s1">), </span><span class="s0">''</span><span class="s1">));</span>
    <span class="s1">page = page.replace(</span><span class="s5">/\/index$/</span><span class="s1">, </span><span class="s0">''</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">page === </span><span class="s0">'' </span><span class="s1">? </span><span class="s0">'/' </span><span class="s1">: page;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getPageFilePath({ absolutePagePath, pagesDir, appDir, rootDir }) {</span>
    <span class="s2">if </span><span class="s1">(absolutePagePath.startsWith(_constants.PAGES_DIR_ALIAS) &amp;&amp; pagesDir) {</span>
        <span class="s2">return </span><span class="s1">absolutePagePath.replace(_constants.PAGES_DIR_ALIAS, pagesDir);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(absolutePagePath.startsWith(_constants.APP_DIR_ALIAS) &amp;&amp; appDir) {</span>
        <span class="s2">return </span><span class="s1">absolutePagePath.replace(_constants.APP_DIR_ALIAS, appDir);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(absolutePagePath.startsWith(_constants.ROOT_DIR_ALIAS)) {</span>
        <span class="s2">return </span><span class="s1">absolutePagePath.replace(_constants.ROOT_DIR_ALIAS, rootDir);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">require.resolve(absolutePagePath);</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">createPagesMapping({ isDev, pageExtensions, pagePaths, pagesType, pagesDir, appDir }) {</span>
    <span class="s2">const </span><span class="s1">isAppRoute = pagesType === </span><span class="s0">'app'</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">pages = {};</span>
    <span class="s2">const </span><span class="s1">promises = pagePaths.map(async (pagePath)=&gt;{</span>
        <span class="s4">// Do not process .d.ts files as routes</span>
        <span class="s2">if </span><span class="s1">(pagePath.endsWith(</span><span class="s0">'.d.ts'</span><span class="s1">) &amp;&amp; pageExtensions.includes(</span><span class="s0">'ts'</span><span class="s1">)) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">pageKey = getPageFromPath(pagePath, pageExtensions);</span>
        <span class="s2">if </span><span class="s1">(isAppRoute) {</span>
            <span class="s1">pageKey = pageKey.replace(</span><span class="s5">/%5F/g</span><span class="s1">, </span><span class="s0">'_'</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(pageKey === </span><span class="s0">'/not-found'</span><span class="s1">) {</span>
                <span class="s1">pageKey = _constants1.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">normalizedPath = (</span><span class="s3">0</span><span class="s1">, _normalizepathsep.normalizePathSep)((</span><span class="s3">0</span><span class="s1">, _path.join)(pagesType === </span><span class="s0">'pages' </span><span class="s1">? _constants.PAGES_DIR_ALIAS : pagesType === </span><span class="s0">'app' </span><span class="s1">? _constants.APP_DIR_ALIAS : _constants.ROOT_DIR_ALIAS, pagePath));</span>
        <span class="s2">let </span><span class="s1">route = pagesType === </span><span class="s0">'app' </span><span class="s1">? (</span><span class="s3">0</span><span class="s1">, _getmetadataroute.normalizeMetadataRoute)(pageKey) : pageKey;</span>
        <span class="s2">if </span><span class="s1">(pagesType === </span><span class="s0">'app' </span><span class="s1">&amp;&amp; (</span><span class="s3">0</span><span class="s1">, _ismetadataroute.isMetadataRouteFile)(pagePath, pageExtensions, </span><span class="s2">true</span><span class="s1">)) {</span>
            <span class="s2">const </span><span class="s1">filePath = (</span><span class="s3">0</span><span class="s1">, _path.join)(appDir, pagePath);</span>
            <span class="s2">const </span><span class="s1">staticInfo = </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _getpagestaticinfo.getPageStaticInfo)({</span>
                <span class="s1">nextConfig: {},</span>
                <span class="s1">pageFilePath: filePath,</span>
                <span class="s1">isDev,</span>
                <span class="s1">page: pageKey,</span>
                <span class="s1">pageType: pagesType</span>
            <span class="s1">});</span>
            <span class="s1">route = (</span><span class="s3">0</span><span class="s1">, _getmetadataroute.normalizeMetadataPageToRoute)(route, !!(staticInfo.generateImageMetadata || staticInfo.generateSitemaps));</span>
        <span class="s1">}</span>
        <span class="s1">pages[route] = normalizedPath;</span>
    <span class="s1">});</span>
    <span class="s2">await </span><span class="s1">Promise.all(promises);</span>
    <span class="s2">switch</span><span class="s1">(pagesType){</span>
        <span class="s2">case </span><span class="s1">_pagetypes.PAGE_TYPES.ROOT:</span>
            <span class="s1">{</span>
                <span class="s2">return </span><span class="s1">pages;</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s1">_pagetypes.PAGE_TYPES.APP:</span>
            <span class="s1">{</span>
                <span class="s2">const </span><span class="s1">hasAppPages = Object.keys(pages).some((page)=&gt;page.endsWith(</span><span class="s0">'/page'</span><span class="s1">));</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s4">// If there's any app pages existed, add a default /_not-found route as 404.</span>
                    <span class="s4">// If there's any custom /_not-found page, it will override the default one.</span>
                    <span class="s1">...hasAppPages &amp;&amp; {</span>
                        <span class="s1">[_constants1.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY]: require.resolve(</span><span class="s0">'next/dist/client/components/builtin/global-not-found'</span><span class="s1">)</span>
                    <span class="s1">},</span>
                    <span class="s1">...pages</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s1">_pagetypes.PAGE_TYPES.PAGES:</span>
            <span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(isDev) {</span>
                    <span class="s2">delete </span><span class="s1">pages[</span><span class="s0">'/_app'</span><span class="s1">];</span>
                    <span class="s2">delete </span><span class="s1">pages[</span><span class="s0">'/_error'</span><span class="s1">];</span>
                    <span class="s2">delete </span><span class="s1">pages[</span><span class="s0">'/_document'</span><span class="s1">];</span>
                <span class="s1">}</span>
                <span class="s4">// In development we always alias these to allow Webpack to fallback to</span>
                <span class="s4">// the correct source file so that HMR can work properly when a file is</span>
                <span class="s4">// added or removed.</span>
                <span class="s2">const </span><span class="s1">root = isDev &amp;&amp; pagesDir ? _constants.PAGES_DIR_ALIAS : </span><span class="s0">'next/dist/pages'</span><span class="s1">;</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s0">'/_app'</span><span class="s1">: </span><span class="s0">`</span><span class="s1">${root}</span><span class="s0">/_app`</span><span class="s1">,</span>
                    <span class="s0">'/_error'</span><span class="s1">: </span><span class="s0">`</span><span class="s1">${root}</span><span class="s0">/_error`</span><span class="s1">,</span>
                    <span class="s0">'/_document'</span><span class="s1">: </span><span class="s0">`</span><span class="s1">${root}</span><span class="s0">/_document`</span><span class="s1">,</span>
                    <span class="s1">...pages</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s2">return </span><span class="s1">{};</span>
            <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getEdgeServerEntry(opts) {</span>
    <span class="s2">var </span><span class="s1">_opts_config_experimental_sri;</span>
    <span class="s2">if </span><span class="s1">(opts.pagesType === </span><span class="s0">'app' </span><span class="s1">&amp;&amp; (</span><span class="s3">0</span><span class="s1">, _isapprouteroute.isAppRouteRoute)(opts.page) &amp;&amp; opts.appDirLoader) {</span>
        <span class="s2">const </span><span class="s1">loaderParams = {</span>
            <span class="s1">absolutePagePath: opts.absolutePagePath,</span>
            <span class="s1">page: opts.page,</span>
            <span class="s1">appDirLoader: Buffer.from(opts.appDirLoader || </span><span class="s0">''</span><span class="s1">).toString(</span><span class="s0">'base64'</span><span class="s1">),</span>
            <span class="s1">nextConfig: Buffer.from(JSON.stringify(opts.config)).toString(</span><span class="s0">'base64'</span><span class="s1">),</span>
            <span class="s1">preferredRegion: opts.preferredRegion,</span>
            <span class="s1">middlewareConfig: Buffer.from(JSON.stringify(opts.middlewareConfig || {})).toString(</span><span class="s0">'base64'</span><span class="s1">),</span>
            <span class="s1">cacheHandlers: JSON.stringify(opts.config.experimental.cacheHandlers || {})</span>
        <span class="s1">};</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s2">import</span><span class="s1">: </span><span class="s0">`next-edge-app-route-loader?</span><span class="s1">${(</span><span class="s3">0</span><span class="s1">, _querystring.stringify)(loaderParams)}</span><span class="s0">!`</span><span class="s1">,</span>
            <span class="s1">layer: _constants.WEBPACK_LAYERS.reactServerComponents</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _utils.isMiddlewareFile)(opts.page)) {</span>
        <span class="s2">var </span><span class="s1">_opts_middleware;</span>
        <span class="s2">const </span><span class="s1">loaderParams = {</span>
            <span class="s1">absolutePagePath: opts.absolutePagePath,</span>
            <span class="s1">page: opts.page,</span>
            <span class="s1">rootDir: opts.rootDir,</span>
            <span class="s1">matchers: ((_opts_middleware = opts.middleware) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _opts_middleware.matchers) ? (</span><span class="s3">0</span><span class="s1">, _nextmiddlewareloader.encodeMatchers)(opts.middleware.matchers) : </span><span class="s0">''</span><span class="s1">,</span>
            <span class="s1">preferredRegion: opts.preferredRegion,</span>
            <span class="s1">middlewareConfig: Buffer.from(JSON.stringify(opts.middlewareConfig || {})).toString(</span><span class="s0">'base64'</span><span class="s1">)</span>
        <span class="s1">};</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s2">import</span><span class="s1">: </span><span class="s0">`next-middleware-loader?</span><span class="s1">${(</span><span class="s3">0</span><span class="s1">, _querystring.stringify)(loaderParams)}</span><span class="s0">!`</span><span class="s1">,</span>
            <span class="s1">layer: _constants.WEBPACK_LAYERS.middleware</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _isapiroute.isAPIRoute)(opts.page)) {</span>
        <span class="s2">const </span><span class="s1">loaderParams = {</span>
            <span class="s1">absolutePagePath: opts.absolutePagePath,</span>
            <span class="s1">page: opts.page,</span>
            <span class="s1">rootDir: opts.rootDir,</span>
            <span class="s1">preferredRegion: opts.preferredRegion,</span>
            <span class="s1">middlewareConfig: Buffer.from(JSON.stringify(opts.middlewareConfig || {})).toString(</span><span class="s0">'base64'</span><span class="s1">)</span>
        <span class="s1">};</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s2">import</span><span class="s1">: </span><span class="s0">`next-edge-function-loader?</span><span class="s1">${(</span><span class="s3">0</span><span class="s1">, _querystring.stringify)(loaderParams)}</span><span class="s0">!`</span><span class="s1">,</span>
            <span class="s1">layer: _constants.WEBPACK_LAYERS.apiEdge</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">loaderParams = {</span>
        <span class="s1">absolute500Path: opts.pages[</span><span class="s0">'/500'</span><span class="s1">] || </span><span class="s0">''</span><span class="s1">,</span>
        <span class="s1">absoluteAppPath: opts.pages[</span><span class="s0">'/_app'</span><span class="s1">],</span>
        <span class="s1">absoluteDocumentPath: opts.pages[</span><span class="s0">'/_document'</span><span class="s1">],</span>
        <span class="s1">absoluteErrorPath: opts.pages[</span><span class="s0">'/_error'</span><span class="s1">],</span>
        <span class="s1">absolutePagePath: opts.absolutePagePath,</span>
        <span class="s1">dev: opts.isDev,</span>
        <span class="s1">isServerComponent: opts.isServerComponent,</span>
        <span class="s1">page: opts.page,</span>
        <span class="s1">stringifiedConfig: Buffer.from(JSON.stringify(opts.config)).toString(</span><span class="s0">'base64'</span><span class="s1">),</span>
        <span class="s1">pagesType: opts.pagesType,</span>
        <span class="s1">appDirLoader: Buffer.from(opts.appDirLoader || </span><span class="s0">''</span><span class="s1">).toString(</span><span class="s0">'base64'</span><span class="s1">),</span>
        <span class="s1">sriEnabled: !opts.isDev &amp;&amp; !!((_opts_config_experimental_sri = opts.config.experimental.sri) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _opts_config_experimental_sri.algorithm),</span>
        <span class="s1">cacheHandler: opts.config.cacheHandler,</span>
        <span class="s1">preferredRegion: opts.preferredRegion,</span>
        <span class="s1">middlewareConfig: Buffer.from(JSON.stringify(opts.middlewareConfig || {})).toString(</span><span class="s0">'base64'</span><span class="s1">),</span>
        <span class="s1">serverActions: opts.config.experimental.serverActions,</span>
        <span class="s1">cacheHandlers: JSON.stringify(opts.config.experimental.cacheHandlers || {})</span>
    <span class="s1">};</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s2">import</span><span class="s1">: </span><span class="s0">`next-edge-ssr-loader?</span><span class="s1">${JSON.stringify(loaderParams)}</span><span class="s0">!`</span><span class="s1">,</span>
        <span class="s4">// The Edge bundle includes the server in its entrypoint, so it has to</span>
        <span class="s4">// be in the SSR layer  we later convert the page request to the RSC layer</span>
        <span class="s4">// via a webpack rule.</span>
        <span class="s1">layer: opts.appDirLoader ? _constants.WEBPACK_LAYERS.serverSideRendering : undefined</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getInstrumentationEntry(opts) {</span>
    <span class="s4">// the '../' is needed to make sure the file is not chunked</span>
    <span class="s2">const </span><span class="s1">filename = </span><span class="s0">`</span><span class="s1">${opts.isEdgeServer ? </span><span class="s0">'edge-' </span><span class="s1">: opts.isDev ? </span><span class="s0">'' </span><span class="s1">: </span><span class="s0">'../'</span><span class="s1">}${_constants.INSTRUMENTATION_HOOK_FILENAME}</span><span class="s0">.js`</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s2">import</span><span class="s1">: opts.absolutePagePath,</span>
        <span class="s1">filename,</span>
        <span class="s1">layer: _constants.WEBPACK_LAYERS.instrument</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getAppLoader() {</span>
    <span class="s2">return </span><span class="s1">process.env.BUILTIN_APP_LOADER ? </span><span class="s0">`builtin:next-app-loader` </span><span class="s1">: </span><span class="s0">'next-app-loader'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getAppEntry(opts) {</span>
    <span class="s2">if </span><span class="s1">(process.env.NEXT_RSPACK &amp;&amp; process.env.BUILTIN_APP_LOADER) {</span>
        <span class="s1">;</span>
        <span class="s1">opts.projectRoot = (</span><span class="s3">0</span><span class="s1">, _path.normalize)((</span><span class="s3">0</span><span class="s1">, _path.join)(__dirname, </span><span class="s0">'../../..'</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s2">import</span><span class="s1">: </span><span class="s0">`</span><span class="s1">${getAppLoader()}</span><span class="s0">?</span><span class="s1">${(</span><span class="s3">0</span><span class="s1">, _querystring.stringify)(opts)}</span><span class="s0">!`</span><span class="s1">,</span>
        <span class="s1">layer: _constants.WEBPACK_LAYERS.reactServerComponents</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getClientEntry(opts) {</span>
    <span class="s2">const </span><span class="s1">loaderOptions = {</span>
        <span class="s1">absolutePagePath: opts.absolutePagePath,</span>
        <span class="s1">page: opts.page</span>
    <span class="s1">};</span>
    <span class="s2">const </span><span class="s1">pageLoader = </span><span class="s0">`next-client-pages-loader?</span><span class="s1">${(</span><span class="s3">0</span><span class="s1">, _querystring.stringify)(loaderOptions)}</span><span class="s0">!`</span><span class="s1">;</span>
    <span class="s4">// Make sure next/router is a dependency of _app or else chunk splitting</span>
    <span class="s4">// might cause the router to not be able to load causing hydration</span>
    <span class="s4">// to fail</span>
    <span class="s2">return </span><span class="s1">opts.page === </span><span class="s0">'/_app' </span><span class="s1">? [</span>
        <span class="s1">pageLoader,</span>
        <span class="s1">require.resolve(</span><span class="s0">'../client/router'</span><span class="s1">)</span>
    <span class="s1">] : pageLoader;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">runDependingOnPageType(params) {</span>
    <span class="s2">if </span><span class="s1">(params.pageType === _pagetypes.PAGE_TYPES.ROOT &amp;&amp; (</span><span class="s3">0</span><span class="s1">, _utils.isInstrumentationHookFile)(params.page)) {</span>
        <span class="s1">params.onServer();</span>
        <span class="s1">params.onEdgeServer();</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _utils.isMiddlewareFile)(params.page)) {</span>
        <span class="s2">if </span><span class="s1">(params.pageRuntime === </span><span class="s0">'nodejs'</span><span class="s1">) {</span>
            <span class="s1">params.onServer();</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">params.onEdgeServer();</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _isapiroute.isAPIRoute)(params.page)) {</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _isedgeruntime.isEdgeRuntime)(params.pageRuntime)) {</span>
            <span class="s1">params.onEdgeServer();</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">params.onServer();</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(params.page === </span><span class="s0">'/_document'</span><span class="s1">) {</span>
        <span class="s1">params.onServer();</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(params.page === </span><span class="s0">'/_app' </span><span class="s1">|| params.page === </span><span class="s0">'/_error' </span><span class="s1">|| params.page === </span><span class="s0">'/404' </span><span class="s1">|| params.page === </span><span class="s0">'/500'</span><span class="s1">) {</span>
        <span class="s1">params.onClient();</span>
        <span class="s1">params.onServer();</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _isedgeruntime.isEdgeRuntime)(params.pageRuntime)) {</span>
        <span class="s1">params.onClient();</span>
        <span class="s1">params.onEdgeServer();</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">params.onClient();</span>
    <span class="s1">params.onServer();</span>
    <span class="s2">return</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">createEntrypoints(params) {</span>
    <span class="s2">const </span><span class="s1">{ config, pages, pagesDir, isDev, rootDir, rootPaths, appDir, appPaths, pageExtensions } = params;</span>
    <span class="s2">const </span><span class="s1">edgeServer = {};</span>
    <span class="s2">const </span><span class="s1">server = {};</span>
    <span class="s2">const </span><span class="s1">client = {};</span>
    <span class="s2">let </span><span class="s1">middlewareMatchers = undefined;</span>
    <span class="s2">let </span><span class="s1">appPathsPerRoute = {};</span>
    <span class="s2">if </span><span class="s1">(appDir &amp;&amp; appPaths) {</span>
        <span class="s2">for</span><span class="s1">(</span><span class="s2">const </span><span class="s1">pathname </span><span class="s2">in </span><span class="s1">appPaths){</span>
            <span class="s2">const </span><span class="s1">normalizedPath = (</span><span class="s3">0</span><span class="s1">, _apppaths.normalizeAppPath)(pathname);</span>
            <span class="s2">const </span><span class="s1">actualPath = appPaths[pathname];</span>
            <span class="s2">if </span><span class="s1">(!appPathsPerRoute[normalizedPath]) {</span>
                <span class="s1">appPathsPerRoute[normalizedPath] = [];</span>
            <span class="s1">}</span>
            <span class="s1">appPathsPerRoute[normalizedPath].push(</span><span class="s4">// TODO-APP: refactor to pass the page path from createPagesMapping instead.</span>
            <span class="s1">getPageFromPath(actualPath, pageExtensions).replace(_constants.APP_DIR_ALIAS, </span><span class="s0">''</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s4">// TODO: find a better place to do this</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _normalizecatchallroutes.normalizeCatchAllRoutes)(appPathsPerRoute);</span>
        <span class="s4">// Make sure to sort parallel routes to make the result deterministic.</span>
        <span class="s1">appPathsPerRoute = Object.fromEntries(Object.entries(appPathsPerRoute).map(([k, v])=&gt;[</span>
                <span class="s1">k,</span>
                <span class="s1">v.sort()</span>
            <span class="s1">]));</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">getEntryHandler = (mappings, pagesType)=&gt;async (page)=&gt;{</span>
            <span class="s2">const </span><span class="s1">bundleFile = (</span><span class="s3">0</span><span class="s1">, _normalizepagepath.normalizePagePath)(page);</span>
            <span class="s2">const </span><span class="s1">clientBundlePath = _path.posix.join(pagesType, bundleFile);</span>
            <span class="s2">const </span><span class="s1">serverBundlePath = pagesType === _pagetypes.PAGE_TYPES.PAGES ? _path.posix.join(</span><span class="s0">'pages'</span><span class="s1">, bundleFile) : pagesType === _pagetypes.PAGE_TYPES.APP ? _path.posix.join(</span><span class="s0">'app'</span><span class="s1">, bundleFile) : bundleFile.slice(</span><span class="s3">1</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">absolutePagePath = mappings[page];</span>
            <span class="s4">// Handle paths that have aliases</span>
            <span class="s2">const </span><span class="s1">pageFilePath = getPageFilePath({</span>
                <span class="s1">absolutePagePath,</span>
                <span class="s1">pagesDir,</span>
                <span class="s1">appDir,</span>
                <span class="s1">rootDir</span>
            <span class="s1">});</span>
            <span class="s2">const </span><span class="s1">isInsideAppDir = !!appDir &amp;&amp; (absolutePagePath.startsWith(_constants.APP_DIR_ALIAS) || absolutePagePath.startsWith(appDir));</span>
            <span class="s2">const </span><span class="s1">staticInfo = </span><span class="s2">await </span><span class="s1">getStaticInfoIncludingLayouts({</span>
                <span class="s1">isInsideAppDir,</span>
                <span class="s1">pageExtensions,</span>
                <span class="s1">pageFilePath,</span>
                <span class="s1">appDir,</span>
                <span class="s1">config,</span>
                <span class="s1">isDev,</span>
                <span class="s1">page</span>
            <span class="s1">});</span>
            <span class="s4">// TODO(timneutkens): remove this</span>
            <span class="s2">const </span><span class="s1">isServerComponent = isInsideAppDir &amp;&amp; staticInfo.rsc !== _constants1.RSC_MODULE_TYPES.client;</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _utils.isMiddlewareFile)(page)) {</span>
                <span class="s2">var </span><span class="s1">_staticInfo_middleware;</span>
                <span class="s1">middlewareMatchers = ((_staticInfo_middleware = staticInfo.middleware) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _staticInfo_middleware.matchers) ?? [</span>
                    <span class="s1">{</span>
                        <span class="s1">regexp: </span><span class="s0">'.*'</span><span class="s1">,</span>
                        <span class="s1">originalSource: </span><span class="s0">'/:path*'</span>
                    <span class="s1">}</span>
                <span class="s1">];</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">isInstrumentation = (</span><span class="s3">0</span><span class="s1">, _utils.isInstrumentationHookFile)(page) &amp;&amp; pagesType === _pagetypes.PAGE_TYPES.ROOT;</span>
            <span class="s1">runDependingOnPageType({</span>
                <span class="s1">page,</span>
                <span class="s1">pageRuntime: staticInfo.runtime,</span>
                <span class="s1">pageType: pagesType,</span>
                <span class="s1">onClient: ()=&gt;{</span>
                    <span class="s2">if </span><span class="s1">(isServerComponent || isInsideAppDir) {</span>
                    <span class="s4">// We skip the initial entries for server component pages and let the</span>
                    <span class="s4">// server compiler inject them instead.</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">client[clientBundlePath] = getClientEntry({</span>
                            <span class="s1">absolutePagePath,</span>
                            <span class="s1">page</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">},</span>
                <span class="s1">onServer: ()=&gt;{</span>
                    <span class="s2">if </span><span class="s1">(pagesType === </span><span class="s0">'app' </span><span class="s1">&amp;&amp; appDir) {</span>
                        <span class="s2">const </span><span class="s1">matchedAppPaths = appPathsPerRoute[(</span><span class="s3">0</span><span class="s1">, _apppaths.normalizeAppPath)(page)];</span>
                        <span class="s1">server[serverBundlePath] = getAppEntry({</span>
                            <span class="s1">page,</span>
                            <span class="s1">name: serverBundlePath,</span>
                            <span class="s1">pagePath: absolutePagePath,</span>
                            <span class="s1">appDir,</span>
                            <span class="s1">appPaths: matchedAppPaths,</span>
                            <span class="s1">pageExtensions,</span>
                            <span class="s1">basePath: config.basePath,</span>
                            <span class="s1">assetPrefix: config.assetPrefix,</span>
                            <span class="s1">nextConfigOutput: config.output,</span>
                            <span class="s1">preferredRegion: staticInfo.preferredRegion,</span>
                            <span class="s1">middlewareConfig: (</span><span class="s3">0</span><span class="s1">, _utils1.encodeToBase64)(staticInfo.middleware || {}),</span>
                            <span class="s1">isGlobalNotFoundEnabled: config.experimental.globalNotFound ? </span><span class="s2">true </span><span class="s1">: undefined</span>
                        <span class="s1">});</span>
                    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isInstrumentation) {</span>
                        <span class="s1">server[serverBundlePath.replace(</span><span class="s0">'src/'</span><span class="s1">, </span><span class="s0">''</span><span class="s1">)] = getInstrumentationEntry({</span>
                            <span class="s1">absolutePagePath,</span>
                            <span class="s1">isEdgeServer: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">isDev: </span><span class="s2">false</span>
                        <span class="s1">});</span>
                    <span class="s1">} </span><span class="s2">else if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _utils.isMiddlewareFile)(page)) {</span>
                        <span class="s1">server[serverBundlePath.replace(</span><span class="s0">'src/'</span><span class="s1">, </span><span class="s0">''</span><span class="s1">)] = getEdgeServerEntry({</span>
                            <span class="s1">...params,</span>
                            <span class="s1">rootDir,</span>
                            <span class="s1">absolutePagePath: absolutePagePath,</span>
                            <span class="s1">bundlePath: clientBundlePath,</span>
                            <span class="s1">isDev: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">isServerComponent,</span>
                            <span class="s1">page,</span>
                            <span class="s1">middleware: staticInfo == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: staticInfo.middleware,</span>
                            <span class="s1">pagesType,</span>
                            <span class="s1">preferredRegion: staticInfo.preferredRegion,</span>
                            <span class="s1">middlewareConfig: staticInfo.middleware</span>
                        <span class="s1">});</span>
                    <span class="s1">} </span><span class="s2">else if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _isapiroute.isAPIRoute)(page)) {</span>
                        <span class="s1">server[serverBundlePath] = [</span>
                            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _nextrouteloader.getRouteLoaderEntry)({</span>
                                <span class="s1">kind: _routekind.RouteKind.PAGES_API,</span>
                                <span class="s1">page,</span>
                                <span class="s1">absolutePagePath,</span>
                                <span class="s1">preferredRegion: staticInfo.preferredRegion,</span>
                                <span class="s1">middlewareConfig: staticInfo.middleware || {}</span>
                            <span class="s1">})</span>
                        <span class="s1">];</span>
                    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!(</span><span class="s3">0</span><span class="s1">, _utils.isMiddlewareFile)(page) &amp;&amp; !(</span><span class="s3">0</span><span class="s1">, _isinternalcomponent.isInternalComponent)(absolutePagePath) &amp;&amp; !(</span><span class="s3">0</span><span class="s1">, _isinternalcomponent.isNonRoutePagesPage)(page)) {</span>
                        <span class="s1">server[serverBundlePath] = [</span>
                            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _nextrouteloader.getRouteLoaderEntry)({</span>
                                <span class="s1">kind: _routekind.RouteKind.PAGES,</span>
                                <span class="s1">page,</span>
                                <span class="s1">pages,</span>
                                <span class="s1">absolutePagePath,</span>
                                <span class="s1">preferredRegion: staticInfo.preferredRegion,</span>
                                <span class="s1">middlewareConfig: staticInfo.middleware ?? {}</span>
                            <span class="s1">})</span>
                        <span class="s1">];</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">server[serverBundlePath] = [</span>
                            <span class="s1">absolutePagePath</span>
                        <span class="s1">];</span>
                    <span class="s1">}</span>
                <span class="s1">},</span>
                <span class="s1">onEdgeServer: ()=&gt;{</span>
                    <span class="s2">let </span><span class="s1">appDirLoader = </span><span class="s0">''</span><span class="s1">;</span>
                    <span class="s2">if </span><span class="s1">(isInstrumentation) {</span>
                        <span class="s1">edgeServer[serverBundlePath.replace(</span><span class="s0">'src/'</span><span class="s1">, </span><span class="s0">''</span><span class="s1">)] = getInstrumentationEntry({</span>
                            <span class="s1">absolutePagePath,</span>
                            <span class="s1">isEdgeServer: </span><span class="s2">true</span><span class="s1">,</span>
                            <span class="s1">isDev: </span><span class="s2">false</span>
                        <span class="s1">});</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s2">if </span><span class="s1">(pagesType === </span><span class="s0">'app'</span><span class="s1">) {</span>
                            <span class="s2">const </span><span class="s1">matchedAppPaths = appPathsPerRoute[(</span><span class="s3">0</span><span class="s1">, _apppaths.normalizeAppPath)(page)];</span>
                            <span class="s1">appDirLoader = getAppEntry({</span>
                                <span class="s1">name: serverBundlePath,</span>
                                <span class="s1">page,</span>
                                <span class="s1">pagePath: absolutePagePath,</span>
                                <span class="s1">appDir: appDir,</span>
                                <span class="s1">appPaths: matchedAppPaths,</span>
                                <span class="s1">pageExtensions,</span>
                                <span class="s1">basePath: config.basePath,</span>
                                <span class="s1">assetPrefix: config.assetPrefix,</span>
                                <span class="s1">nextConfigOutput: config.output,</span>
                                <span class="s4">// This isn't used with edge as it needs to be set on the entry module, which will be the `edgeServerEntry` instead.</span>
                                <span class="s4">// Still passing it here for consistency.</span>
                                <span class="s1">preferredRegion: staticInfo.preferredRegion,</span>
                                <span class="s1">middlewareConfig: Buffer.from(JSON.stringify(staticInfo.middleware || {})).toString(</span><span class="s0">'base64'</span><span class="s1">),</span>
                                <span class="s1">isGlobalNotFoundEnabled: config.experimental.globalNotFound ? </span><span class="s2">true </span><span class="s1">: undefined</span>
                            <span class="s1">}).import;</span>
                        <span class="s1">}</span>
                        <span class="s1">edgeServer[serverBundlePath] = getEdgeServerEntry({</span>
                            <span class="s1">...params,</span>
                            <span class="s1">rootDir,</span>
                            <span class="s1">absolutePagePath: absolutePagePath,</span>
                            <span class="s1">bundlePath: clientBundlePath,</span>
                            <span class="s1">isDev: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">isServerComponent,</span>
                            <span class="s1">page,</span>
                            <span class="s1">middleware: staticInfo == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: staticInfo.middleware,</span>
                            <span class="s1">pagesType,</span>
                            <span class="s1">appDirLoader,</span>
                            <span class="s1">preferredRegion: staticInfo.preferredRegion,</span>
                            <span class="s1">middlewareConfig: staticInfo.middleware</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">};</span>
    <span class="s2">const </span><span class="s1">promises = [];</span>
    <span class="s2">if </span><span class="s1">(appPaths) {</span>
        <span class="s2">const </span><span class="s1">entryHandler = getEntryHandler(appPaths, _pagetypes.PAGE_TYPES.APP);</span>
        <span class="s1">promises.push(Promise.all(Object.keys(appPaths).map(entryHandler)));</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(rootPaths) {</span>
        <span class="s1">promises.push(Promise.all(Object.keys(rootPaths).map(getEntryHandler(rootPaths, _pagetypes.PAGE_TYPES.ROOT))));</span>
    <span class="s1">}</span>
    <span class="s1">promises.push(Promise.all(Object.keys(pages).map(getEntryHandler(pages, _pagetypes.PAGE_TYPES.PAGES))));</span>
    <span class="s2">await </span><span class="s1">Promise.all(promises);</span>
    <span class="s4">// Optimization: If there's only one instrumentation hook in edge compiler, which means there's no edge server entry.</span>
    <span class="s4">// We remove the edge instrumentation entry from edge compiler as it can be pure server side.</span>
    <span class="s2">if </span><span class="s1">(edgeServer.instrumentation &amp;&amp; Object.keys(edgeServer).length === </span><span class="s3">1</span><span class="s1">) {</span>
        <span class="s2">delete </span><span class="s1">edgeServer.instrumentation;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">client,</span>
        <span class="s1">server,</span>
        <span class="s1">edgeServer,</span>
        <span class="s1">middlewareMatchers</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">finalizeEntrypoint({ name, compilerType, value, isServerComponent, hasAppDir }) {</span>
    <span class="s2">const </span><span class="s1">entry = </span><span class="s2">typeof </span><span class="s1">value !== </span><span class="s0">'object' </span><span class="s1">|| Array.isArray(value) ? {</span>
        <span class="s2">import</span><span class="s1">: value</span>
    <span class="s1">} : value;</span>
    <span class="s2">const </span><span class="s1">isApi = name.startsWith(</span><span class="s0">'pages/api/'</span><span class="s1">);</span>
    <span class="s2">const </span><span class="s1">isInstrumentation = (</span><span class="s3">0</span><span class="s1">, _utils.isInstrumentationHookFilename)(name);</span>
    <span class="s2">switch</span><span class="s1">(compilerType){</span>
        <span class="s2">case </span><span class="s1">_constants1.COMPILER_NAMES.server:</span>
            <span class="s1">{</span>
                <span class="s2">const </span><span class="s1">layer = isApi ? _constants.WEBPACK_LAYERS.apiNode : isInstrumentation ? _constants.WEBPACK_LAYERS.instrument : isServerComponent ? _constants.WEBPACK_LAYERS.reactServerComponents : name.startsWith(</span><span class="s0">'pages/'</span><span class="s1">) ? _constants.WEBPACK_LAYERS.pagesDirNode : undefined;</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">publicPath: isApi ? </span><span class="s0">'' </span><span class="s1">: undefined,</span>
                    <span class="s1">runtime: isApi ? </span><span class="s0">'webpack-api-runtime' </span><span class="s1">: </span><span class="s0">'webpack-runtime'</span><span class="s1">,</span>
                    <span class="s1">layer,</span>
                    <span class="s1">...entry</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s1">_constants1.COMPILER_NAMES.edgeServer:</span>
            <span class="s1">{</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">layer: isApi ? _constants.WEBPACK_LAYERS.apiEdge : (</span><span class="s3">0</span><span class="s1">, _utils.isMiddlewareFilename)(name) || isInstrumentation ? _constants.WEBPACK_LAYERS.middleware : name.startsWith(</span><span class="s0">'pages/'</span><span class="s1">) ? _constants.WEBPACK_LAYERS.pagesDirEdge : undefined,</span>
                    <span class="s1">library: {</span>
                        <span class="s1">name: [</span>
                            <span class="s0">'_ENTRIES'</span><span class="s1">,</span>
                            <span class="s0">`middleware_[name]`</span>
                        <span class="s1">],</span>
                        <span class="s1">type: </span><span class="s0">'assign'</span>
                    <span class="s1">},</span>
                    <span class="s1">runtime: _constants1.EDGE_RUNTIME_WEBPACK,</span>
                    <span class="s1">asyncChunks: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">...entry</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s1">_constants1.COMPILER_NAMES.client:</span>
            <span class="s1">{</span>
                <span class="s2">const </span><span class="s1">isAppLayer = hasAppDir &amp;&amp; (name === _constants1.CLIENT_STATIC_FILES_RUNTIME_MAIN_APP || name === _constants1.APP_CLIENT_INTERNALS || name.startsWith(</span><span class="s0">'app/'</span><span class="s1">));</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s4">// Client special cases</span>
                <span class="s1">name !== _constants1.CLIENT_STATIC_FILES_RUNTIME_POLYFILLS &amp;&amp; name !== _constants1.CLIENT_STATIC_FILES_RUNTIME_MAIN &amp;&amp; name !== _constants1.CLIENT_STATIC_FILES_RUNTIME_MAIN_APP &amp;&amp; name !== _constants1.CLIENT_STATIC_FILES_RUNTIME_AMP &amp;&amp; name !== _constants1.CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH) {</span>
                    <span class="s2">if </span><span class="s1">(isAppLayer) {</span>
                        <span class="s2">return </span><span class="s1">{</span>
                            <span class="s1">dependOn: _constants1.CLIENT_STATIC_FILES_RUNTIME_MAIN_APP,</span>
                            <span class="s1">layer: _constants.WEBPACK_LAYERS.appPagesBrowser,</span>
                            <span class="s1">...entry</span>
                        <span class="s1">};</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">{</span>
                        <span class="s1">dependOn: name.startsWith(</span><span class="s0">'pages/'</span><span class="s1">) &amp;&amp; name !== </span><span class="s0">'pages/_app' </span><span class="s1">? </span><span class="s0">'pages/_app' </span><span class="s1">: _constants1.CLIENT_STATIC_FILES_RUNTIME_MAIN,</span>
                        <span class="s1">layer: _constants.WEBPACK_LAYERS.pagesDirBrowser,</span>
                        <span class="s1">...entry</span>
                    <span class="s1">};</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(isAppLayer) {</span>
                    <span class="s2">return </span><span class="s1">{</span>
                        <span class="s1">layer: _constants.WEBPACK_LAYERS.appPagesBrowser,</span>
                        <span class="s1">...entry</span>
                    <span class="s1">};</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">layer: _constants.WEBPACK_LAYERS.pagesDirBrowser,</span>
                    <span class="s1">...entry</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">compilerType;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=entries.js.map</span></pre>
</body>
</html>