<html>
<head>
<title>checkNumberLength.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
checkNumberLength.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;checkNumberLength.js&quot;</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_metadata&quot;</span><span class="s0">,</span><span class="s1">&quot;_interopRequireDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_mergeArrays&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;__esModule&quot;</span><span class="s0">,</span><span class="s1">&quot;checkNumberLength&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;country&quot;</span><span class="s0">,</span><span class="s1">&quot;metadata&quot;</span><span class="s0">,</span><span class="s1">&quot;checkNumberLengthForType&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;Metadata&quot;</span><span class="s0">,</span><span class="s1">&quot;selectNumberingPlan&quot;</span><span class="s0">,</span><span class="s1">&quot;type_info&quot;</span><span class="s0">,</span><span class="s1">&quot;possible_lengths&quot;</span><span class="s0">,</span><span class="s1">&quot;possibleLengths&quot;</span><span class="s0">,</span><span class="s1">&quot;mobile_type&quot;</span><span class="s0">,</span><span class="s1">&quot;mergeArrays&quot;</span><span class="s0">,</span><span class="s1">&quot;actual_length&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;minimum_length&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../source/helpers/checkNumberLength.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import Metadata from '../metadata.js'</span><span class="s3">\r\n</span><span class="s1">import mergeArrays from './mergeArrays.js'</span><span class="s3">\r\n\r\n</span><span class="s1">export default function checkNumberLength(nationalNumber, country, metadata) {</span><span class="s3">\r\n\t</span><span class="s1">return checkNumberLengthForType(nationalNumber, country, undefined, metadata)</span><span class="s3">\r\n</span><span class="s1">}</span><span class="s3">\r\n\r\n</span><span class="s1">// Checks whether a number is possible for a certain `country` based on the number length.</span><span class="s3">\r\n</span><span class="s1">//</span><span class="s3">\r\n</span><span class="s1">// This function is not supported by metadata generated with ancient versions of</span><span class="s3">\r\n</span><span class="s1">// `libphonenumber-js` (before version `1.0.18`) which didn't include </span><span class="s3">\&quot;</span><span class="s1">possible lengths</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\r\n</span><span class="s1">//</span><span class="s3">\r\n</span><span class="s1">// There was also a known issue with `checkNumberLength()` function:</span><span class="s3">\r\n</span><span class="s1">// if a number is possible only in a certain `country` among several `countries`</span><span class="s3">\r\n</span><span class="s1">// that share the same </span><span class="s3">\&quot;</span><span class="s1">country calling code</span><span class="s3">\&quot;</span><span class="s1">, that function would check</span><span class="s3">\r\n</span><span class="s1">// the possibility of the phone number only in the </span><span class="s3">\&quot;</span><span class="s1">main</span><span class="s3">\&quot; </span><span class="s1">`country` for the </span><span class="s3">\&quot;</span><span class="s1">country calling code</span><span class="s3">\&quot;\r\n</span><span class="s1">// and would not check if it's actually be possible in the speciifc `country`.</span><span class="s3">\r\n</span><span class="s1">//</span><span class="s3">\r\n</span><span class="s1">// For example, </span><span class="s3">\&quot;</span><span class="s1">+1310xxxx</span><span class="s3">\&quot; </span><span class="s1">numbers are valid in Canada.</span><span class="s3">\r\n</span><span class="s1">// However, they are not possible in the US due to being too short.</span><span class="s3">\r\n</span><span class="s1">// Since Canada and the US share the same country calling code — </span><span class="s3">\&quot;</span><span class="s1">+1</span><span class="s3">\&quot; </span><span class="s1">—</span><span class="s3">\r\n</span><span class="s1">// `checkNumberLength()` function used to return not </span><span class="s3">\&quot;</span><span class="s1">IS_POSSIBLE</span><span class="s3">\&quot; </span><span class="s1">for </span><span class="s3">\&quot;</span><span class="s1">+1310xxxx</span><span class="s3">\&quot; </span><span class="s1">numbers.</span><span class="s3">\r\n</span><span class="s1">//</span><span class="s3">\r\n</span><span class="s1">// In such cases, when using </span><span class="s3">\&quot;</span><span class="s1">/max</span><span class="s3">\&quot; </span><span class="s1">metadata, `isValid()` could output `true`</span><span class="s3">\r\n</span><span class="s1">// but at the same time `isPossible()` could output `false`, which was contradictory.</span><span class="s3">\r\n</span><span class="s1">//</span><span class="s3">\r\n</span><span class="s1">// See https://issuetracker.google.com/issues/335892662 for the discusson in Google's issues.</span><span class="s3">\r\n</span><span class="s1">//</span><span class="s3">\r\n</span><span class="s1">// The solution suggested by Google was implemented: an optional `country` argument</span><span class="s3">\r\n</span><span class="s1">// was added to `checkNumberLength()` function. If present, that `country` will be used</span><span class="s3">\r\n</span><span class="s1">// to check phone number length for that specific `country` rather than the </span><span class="s3">\&quot;</span><span class="s1">main</span><span class="s3">\&quot; </span><span class="s1">country</span><span class="s3">\r\n</span><span class="s1">// for the shared </span><span class="s3">\&quot;</span><span class="s1">country calling code</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\r\n</span><span class="s1">//</span><span class="s3">\r\n</span><span class="s1">export function checkNumberLengthForType(nationalNumber, country, type, metadata) {</span><span class="s3">\r\n\t</span><span class="s1">// If the exact `country` is specified, it's no necessarily already selected in `metadata`.</span><span class="s3">\r\n\t</span><span class="s1">// Most likely, in cases when there're multiple countries corresponding to the same</span><span class="s3">\r\n\t</span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">country calling code</span><span class="s3">\&quot;</span><span class="s1">, the </span><span class="s3">\&quot;</span><span class="s1">main</span><span class="s3">\&quot; </span><span class="s1">country for that </span><span class="s3">\&quot;</span><span class="s1">country calling code</span><span class="s3">\&quot; </span><span class="s1">will be selected.</span><span class="s3">\r\n\t</span><span class="s1">if (country) {</span><span class="s3">\r\n\t\t</span><span class="s1">metadata = new Metadata(metadata.metadata)</span><span class="s3">\r\n\t\t</span><span class="s1">metadata.selectNumberingPlan(country)</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">const type_info = metadata.type(type)</span><span class="s3">\r\n\r\n\t</span><span class="s1">// There should always be </span><span class="s3">\&quot;</span><span class="s1">&lt;possiblePengths/&gt;</span><span class="s3">\&quot; </span><span class="s1">set for every type element.</span><span class="s3">\r\n\t</span><span class="s1">// This is declared in the XML schema.</span><span class="s3">\r\n\t</span><span class="s1">// For size efficiency, where a sub-description (e.g. fixed-line)</span><span class="s3">\r\n\t</span><span class="s1">// has the same </span><span class="s3">\&quot;</span><span class="s1">&lt;possiblePengths/&gt;</span><span class="s3">\&quot; </span><span class="s1">as the </span><span class="s3">\&quot;</span><span class="s1">general description</span><span class="s3">\&quot;</span><span class="s1">, this is missing,</span><span class="s3">\r\n\t</span><span class="s1">// so we fall back to the </span><span class="s3">\&quot;</span><span class="s1">general description</span><span class="s3">\&quot;</span><span class="s1">. Where no numbers of the type</span><span class="s3">\r\n\t</span><span class="s1">// exist at all, there is one possible length (-1) which is guaranteed</span><span class="s3">\r\n\t</span><span class="s1">// not to match the length of any real phone number.</span><span class="s3">\r\n\t</span><span class="s1">let possible_lengths = type_info &amp;&amp; type_info.possibleLengths() || metadata.possibleLengths()</span><span class="s3">\r\n\t</span><span class="s1">// let local_lengths = type_info &amp;&amp; type.possibleLengthsLocal() || metadata.possibleLengthsLocal()</span><span class="s3">\r\n\r\n\t</span><span class="s1">// Metadata before version `1.0.18` didn't contain `possible_lengths`.</span><span class="s3">\r\n\t</span><span class="s1">if (!possible_lengths) {</span><span class="s3">\r\n\t\t</span><span class="s1">return 'IS_POSSIBLE'</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">if (type === 'FIXED_LINE_OR_MOBILE') {</span><span class="s3">\r\n\t\t</span><span class="s1">// No such country in metadata.</span><span class="s3">\r\n\t\t</span><span class="s1">/* istanbul ignore next */</span><span class="s3">\r\n\t\t</span><span class="s1">if (!metadata.type('FIXED_LINE')) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">// The rare case has been encountered where no fixedLine data is available</span><span class="s3">\r\n\t\t\t</span><span class="s1">// (true for some non-geographic entities), so we just check mobile.</span><span class="s3">\r\n\t\t\t</span><span class="s1">return checkNumberLengthForType(nationalNumber, country, 'MOBILE', metadata)</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">const mobile_type = metadata.type('MOBILE')</span><span class="s3">\r\n\t\t</span><span class="s1">if (mobile_type) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">// Merge the mobile data in if there was any. </span><span class="s3">\&quot;</span><span class="s1">Concat</span><span class="s3">\&quot; </span><span class="s1">creates a new</span><span class="s3">\r\n\t\t\t</span><span class="s1">// array, it doesn't edit possible_lengths in place, so we don't need a copy.</span><span class="s3">\r\n\t\t\t</span><span class="s1">// Note that when adding the possible lengths from mobile, we have</span><span class="s3">\r\n\t\t\t</span><span class="s1">// to again check they aren't empty since if they are this indicates</span><span class="s3">\r\n\t\t\t</span><span class="s1">// they are the same as the general desc and should be obtained from there.</span><span class="s3">\r\n\t\t\t</span><span class="s1">possible_lengths = mergeArrays(possible_lengths, mobile_type.possibleLengths())</span><span class="s3">\r\n\t\t\t</span><span class="s1">// The current list is sorted; we need to merge in the new list and</span><span class="s3">\r\n\t\t\t</span><span class="s1">// re-sort (duplicates are okay). Sorting isn't so expensive because</span><span class="s3">\r\n\t\t\t</span><span class="s1">// the lists are very small.</span><span class="s3">\r\n\r\n\t\t\t</span><span class="s1">// if (local_lengths) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">// </span><span class="s3">\t</span><span class="s1">local_lengths = mergeArrays(local_lengths, mobile_type.possibleLengthsLocal())</span><span class="s3">\r\n\t\t\t</span><span class="s1">// } else {</span><span class="s3">\r\n\t\t\t</span><span class="s1">// </span><span class="s3">\t</span><span class="s1">local_lengths = mobile_type.possibleLengthsLocal()</span><span class="s3">\r\n\t\t\t</span><span class="s1">// }</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">// If the type doesn't exist then return 'INVALID_LENGTH'.</span><span class="s3">\r\n\t</span><span class="s1">else if (type &amp;&amp; !type_info) {</span><span class="s3">\r\n\t\t</span><span class="s1">return 'INVALID_LENGTH'</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">const actual_length = nationalNumber.length</span><span class="s3">\r\n\r\n\t</span><span class="s1">// In `libphonenumber-js` all </span><span class="s3">\&quot;</span><span class="s1">local-only</span><span class="s3">\&quot; </span><span class="s1">formats are dropped for simplicity.</span><span class="s3">\r\n\t</span><span class="s1">// // This is safe because there is never an overlap beween the possible lengths</span><span class="s3">\r\n\t</span><span class="s1">// // and the local-only lengths; this is checked at build time.</span><span class="s3">\r\n\t</span><span class="s1">// if (local_lengths &amp;&amp; local_lengths.indexOf(nationalNumber.length) &gt;= 0)</span><span class="s3">\r\n\t</span><span class="s1">// {</span><span class="s3">\r\n\t</span><span class="s1">// </span><span class="s3">\t</span><span class="s1">return 'IS_POSSIBLE_LOCAL_ONLY'</span><span class="s3">\r\n\t</span><span class="s1">// }</span><span class="s3">\r\n\r\n\t</span><span class="s1">const minimum_length = possible_lengths[0]</span><span class="s3">\r\n\r\n\t</span><span class="s1">if (minimum_length === actual_length) {</span><span class="s3">\r\n\t\t</span><span class="s1">return 'IS_POSSIBLE'</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">if (minimum_length &gt; actual_length) {</span><span class="s3">\r\n\t\t</span><span class="s1">return 'TOO_SHORT'</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">if (possible_lengths[possible_lengths.length - 1] &lt; actual_length) {</span><span class="s3">\r\n\t\t</span><span class="s1">return 'TOO_LONG'</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">// We skip the first element since we've already checked it.</span><span class="s3">\r\n\t</span><span class="s1">return possible_lengths.indexOf(actual_length, 1) &gt;= 0 ? 'IS_POSSIBLE' : 'INVALID_LENGTH'</span><span class="s3">\r\n</span><span class="s1">}&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;AAAA,IAAAA,SAAA,GAAAC,sBAAA,CAAAC,OAAA;AACA,IAAAC,YAAA,GAAAF,sBAAA,CAAAC,OAAA;AAA0C,SAAAD,uBAAAG,CAAA,WAAAA,CAAA,IAAAA,CAAA,CAAAC,UAAA,GAAAD,CAAA,gBAAAA,CAAA;AAE3B,SAASE,iBAAiBA,CAACC,cAAc,EAAEC,OAAO,EAAEC,QAAQ,EAAE;EAC5E,OAAOC,wBAAwB,CAACH,cAAc,EAAEC,OAAO,EAAEG,SAAS,EAAEF,QAAQ,CAAC;AAC9E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,wBAAwBA,CAACH,cAAc,EAAEC,OAAO,EAAEI,IAAI,EAAEH,QAAQ,EAAE;EACjF;EACA;EACA;EACA,IAAID,OAAO,EAAE;IACZC,QAAQ,GAAG,IAAII,oBAAQ,CAACJ,QAAQ,CAACA,QAAQ,CAAC;IAC1CA,QAAQ,CAACK,mBAAmB,CAACN,OAAO,CAAC;EACtC;EAEA,IAAMO,SAAS,GAAGN,QAAQ,CAACG,IAAI,CAACA,IAAI,CAAC;;EAErC;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAII,gBAAgB,GAAGD,SAAS,IAAIA,SAAS,CAACE,eAAe,CAAC,CAAC,IAAIR,QAAQ,CAACQ,eAAe,CAAC,CAAC;EAC7F;;EAEA;EACA,IAAI,CAACD,gBAAgB,EAAE;IACtB,OAAO,aAAa;EACrB;EAEA,IAAIJ,IAAI,KAAK,sBAAsB,EAAE;IACpC;IACA;IACA,IAAI,CAACH,QAAQ,CAACG,IAAI,CAAC,YAAY,CAAC,EAAE;MACjC;MACA;MACA,OAAOF,wBAAwB,CAACH,cAAc,EAAEC,OAAO,EAAE,QAAQ,EAAEC,QAAQ,CAAC;IAC7E;IAEA,IAAMS,WAAW,GAAGT,QAAQ,CAACG,IAAI,CAAC,QAAQ,CAAC;IAC3C,IAAIM,WAAW,EAAE;MAChB;MACA;MACA;MACA;MACA;MACAF,gBAAgB,GAAG,IAAAG,uBAAW,EAACH,gBAAgB,EAAEE,WAAW,CAACD,eAAe,CAAC,CAAC,CAAC;MAC/E;MACA;MACA;;MAEA;MACA;MACA;MACA;MACA;IACD;EACD;EACA;EAAA,KACK,IAAIL,IAAI,IAAI,CAACG,SAAS,EAAE;IAC5B,OAAO,gBAAgB;EACxB;EAEA,IAAMK,aAAa,GAAGb,cAAc,CAACc,MAAM;;EAE3C;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA,IAAMC,cAAc,GAAGN,gBAAgB,CAAC,CAAC,CAAC;EAE1C,IAAIM,cAAc,KAAKF,aAAa,EAAE;IACrC,OAAO,aAAa;EACrB;EAEA,IAAIE,cAAc,GAAGF,aAAa,EAAE;IACnC,OAAO,WAAW;EACnB;EAEA,IAAIJ,gBAAgB,CAACA,gBAAgB,CAACK,MAAM,GAAG,CAAC,CAAC,GAAGD,aAAa,EAAE;IAClE,OAAO,UAAU;EAClB;;EAEA;EACA,OAAOJ,gBAAgB,CAACO,OAAO,CAACH,aAAa,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,aAAa,GAAG,gBAAgB;AAC1F&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>