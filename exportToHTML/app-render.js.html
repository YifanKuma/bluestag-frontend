<html>
<head>
<title>app-render.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
app-render.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;renderToHTMLOrFlight&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">renderToHTMLOrFlight;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_jsxruntime = require(</span><span class="s0">&quot;react/jsx-runtime&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_workasyncstorageexternal = require(</span><span class="s0">&quot;../app-render/work-async-storage.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_react = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;react&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_renderresult = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;../render-result&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_nodewebstreamshelper = require(</span><span class="s0">&quot;../stream-utils/node-web-streams-helper&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_internalutils = require(</span><span class="s0">&quot;../internal-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_approuterheaders = require(</span><span class="s0">&quot;../../client/components/app-router-headers&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_metadatacontext = require(</span><span class="s0">&quot;../../lib/metadata/metadata-context&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_requeststore = require(</span><span class="s0">&quot;../async-storage/request-store&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_workstore = require(</span><span class="s0">&quot;../async-storage/work-store&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_httpaccessfallback = require(</span><span class="s0">&quot;../../client/components/http-access-fallback/http-access-fallback&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_redirect = require(</span><span class="s0">&quot;../../client/components/redirect&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_redirecterror = require(</span><span class="s0">&quot;../../client/components/redirect-error&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_implicittags = require(</span><span class="s0">&quot;../lib/implicit-tags&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants = require(</span><span class="s0">&quot;../lib/trace/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_tracer = require(</span><span class="s0">&quot;../lib/trace/tracer&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_flightrenderresult = require(</span><span class="s0">&quot;./flight-render-result&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_createerrorhandler = require(</span><span class="s0">&quot;./create-error-handler&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_getshortdynamicparamtype = require(</span><span class="s0">&quot;./get-short-dynamic-param-type&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_getsegmentparam = require(</span><span class="s0">&quot;./get-segment-param&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_getscriptnoncefromheader = require(</span><span class="s0">&quot;./get-script-nonce-from-header&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_parseandvalidateflightrouterstate = require(</span><span class="s0">&quot;./parse-and-validate-flight-router-state&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_createflightrouterstatefromloadertree = require(</span><span class="s0">&quot;./create-flight-router-state-from-loader-tree&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_actionhandler = require(</span><span class="s0">&quot;./action-handler&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_bailouttocsr = require(</span><span class="s0">&quot;../../shared/lib/lazy-dynamic/bailout-to-csr&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_log = require(</span><span class="s0">&quot;../../build/output/log&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_requestcookies = require(</span><span class="s0">&quot;../web/spec-extension/adapters/request-cookies&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_serverinsertedhtml = require(</span><span class="s0">&quot;./server-inserted-html&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_requiredscripts = require(</span><span class="s0">&quot;./required-scripts&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_addpathprefix = require(</span><span class="s0">&quot;../../shared/lib/router/utils/add-path-prefix&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_makegetserverinsertedhtml = require(</span><span class="s0">&quot;./make-get-server-inserted-html&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_walktreewithflightrouterstate = require(</span><span class="s0">&quot;./walk-tree-with-flight-router-state&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_createcomponenttree = require(</span><span class="s0">&quot;./create-component-tree&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_getassetquerystring = require(</span><span class="s0">&quot;./get-asset-query-string&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_encryptionutils = require(</span><span class="s0">&quot;./encryption-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_postponedstate = require(</span><span class="s0">&quot;./postponed-state&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_hooksservercontext = require(</span><span class="s0">&quot;../../client/components/hooks-server-context&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_useflightresponse = require(</span><span class="s0">&quot;./use-flight-response&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_staticgenerationbailout = require(</span><span class="s0">&quot;../../client/components/static-generation-bailout&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_formatservererror = require(</span><span class="s0">&quot;../../lib/format-server-error&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_dynamicrendering = require(</span><span class="s0">&quot;./dynamic-rendering&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_clientcomponentrendererlogger = require(</span><span class="s0">&quot;../client-component-renderer-logger&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_actionutils = require(</span><span class="s0">&quot;./action-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_helpers = require(</span><span class="s0">&quot;../base-http/helpers&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_parserelativeurl = require(</span><span class="s0">&quot;../../shared/lib/router/utils/parse-relative-url&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_approuter = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;../../client/components/app-router&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_serveractionrequestmeta = require(</span><span class="s0">&quot;../lib/server-action-request-meta&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_createinitialrouterstate = require(</span><span class="s0">&quot;../../client/components/router-reducer/create-initial-router-state&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_approuterinstance = require(</span><span class="s0">&quot;../../client/components/app-router-instance&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils = require(</span><span class="s0">&quot;../instrumentation/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_segment = require(</span><span class="s0">&quot;../../shared/lib/segment&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_apprenderprerenderutils = require(</span><span class="s0">&quot;./app-render-prerender-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_prospectiverenderutils = require(</span><span class="s0">&quot;./prospective-render-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_apprenderrenderutils = require(</span><span class="s0">&quot;./app-render-render-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_scheduler = require(</span><span class="s0">&quot;../../lib/scheduler&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_workunitasyncstorageexternal = require(</span><span class="s0">&quot;./work-unit-async-storage.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_cachesignal = require(</span><span class="s0">&quot;./cache-signal&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils1 = require(</span><span class="s0">&quot;../lib/trace/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_invarianterror = require(</span><span class="s0">&quot;../../shared/lib/invariant-error&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants1 = require(</span><span class="s0">&quot;../../lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_createcomponentstylesandscripts = require(</span><span class="s0">&quot;./create-component-styles-and-scripts&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_parseloadertree = require(</span><span class="s0">&quot;./parse-loader-tree&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_resumedatacache = require(</span><span class="s0">&quot;../resume-data-cache/resume-data-cache&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_iserror = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;../../lib/is-error&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_createserverinsertedmetadata = require(</span><span class="s0">&quot;./metadata-insertion/create-server-inserted-metadata&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_serverutils = require(</span><span class="s0">&quot;../server-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_revalidationutils = require(</span><span class="s0">&quot;../revalidation-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_trackmoduleloadingexternal = require(</span><span class="s0">&quot;./module-loading/track-module-loading.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_reactlargeshellerror = require(</span><span class="s0">&quot;./react-large-shell-error&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_segmentexplorerpath = require(</span><span class="s0">&quot;./segment-explorer-path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_requestmeta = require(</span><span class="s0">&quot;../request-meta&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_getdynamicparam = require(</span><span class="s0">&quot;../../shared/lib/router/utils/get-dynamic-param&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_promisewithresolvers = require(</span><span class="s0">&quot;../../shared/lib/promise-with-resolvers&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">flightDataPathHeadKey = </span><span class="s0">'h'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">getFlightViewportKey = (requestId)=&gt;requestId + </span><span class="s0">'v'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">getFlightMetadataKey = (requestId)=&gt;requestId + </span><span class="s0">'m'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">filterStackFrame = process.env.NODE_ENV !== </span><span class="s0">'production' </span><span class="s1">? require(</span><span class="s0">'../lib/source-maps'</span><span class="s1">).filterStackFrameDEV : undefined;</span>
<span class="s2">function </span><span class="s1">parseRequestHeaders(headers, options) {</span>
    <span class="s2">const </span><span class="s1">isDevWarmupRequest = options.isDevWarmup === </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s3">// dev warmup requests are treated as prefetch RSC requests</span>
    <span class="s3">// runtime prefetch requests are *not* treated as prefetch requests</span>
    <span class="s3">// (TODO: this is confusing, we should refactor this to express this better)</span>
    <span class="s2">const </span><span class="s1">isPrefetchRequest = isDevWarmupRequest || headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] === </span><span class="s0">'1'</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">isRuntimePrefetchRequest = headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] === </span><span class="s0">'2'</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">isHmrRefresh = headers[_approuterheaders.NEXT_HMR_REFRESH_HEADER] !== undefined;</span>
    <span class="s3">// dev warmup requests are treated as prefetch RSC requests</span>
    <span class="s2">const </span><span class="s1">isRSCRequest = isDevWarmupRequest || headers[_approuterheaders.RSC_HEADER] !== undefined;</span>
    <span class="s2">const </span><span class="s1">shouldProvideFlightRouterState = isRSCRequest &amp;&amp; (!isPrefetchRequest || !options.isRoutePPREnabled);</span>
    <span class="s2">const </span><span class="s1">flightRouterState = shouldProvideFlightRouterState ? (</span><span class="s4">0</span><span class="s1">, _parseandvalidateflightrouterstate.parseAndValidateFlightRouterState)(headers[_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]) : undefined;</span>
    <span class="s3">// Checks if this is a prefetch of the Route Tree by the Segment Cache</span>
    <span class="s2">const </span><span class="s1">isRouteTreePrefetchRequest = headers[_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] === </span><span class="s0">'/_tree'</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">csp = headers[</span><span class="s0">'content-security-policy'</span><span class="s1">] || headers[</span><span class="s0">'content-security-policy-report-only'</span><span class="s1">];</span>
    <span class="s2">const </span><span class="s1">nonce = </span><span class="s2">typeof </span><span class="s1">csp === </span><span class="s0">'string' </span><span class="s1">? (</span><span class="s4">0</span><span class="s1">, _getscriptnoncefromheader.getScriptNonceFromHeader)(csp) : undefined;</span>
    <span class="s2">const </span><span class="s1">previouslyRevalidatedTags = (</span><span class="s4">0</span><span class="s1">, _serverutils.getPreviouslyRevalidatedTags)(headers, options.previewModeId);</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">flightRouterState,</span>
        <span class="s1">isPrefetchRequest,</span>
        <span class="s1">isRuntimePrefetchRequest,</span>
        <span class="s1">isRouteTreePrefetchRequest,</span>
        <span class="s1">isHmrRefresh,</span>
        <span class="s1">isRSCRequest,</span>
        <span class="s1">isDevWarmupRequest,</span>
        <span class="s1">nonce,</span>
        <span class="s1">previouslyRevalidatedTags</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createNotFoundLoaderTree(loaderTree) {</span>
    <span class="s2">const </span><span class="s1">components = loaderTree[</span><span class="s4">2</span><span class="s1">];</span>
    <span class="s2">const </span><span class="s1">hasGlobalNotFound = !!components[</span><span class="s0">'global-not-found'</span><span class="s1">];</span>
    <span class="s2">return </span><span class="s1">[</span>
        <span class="s0">''</span><span class="s1">,</span>
        <span class="s1">{</span>
            <span class="s1">children: [</span>
                <span class="s1">_segment.PAGE_SEGMENT_KEY,</span>
                <span class="s1">{},</span>
                <span class="s1">{</span>
                    <span class="s1">page: components[</span><span class="s0">'global-not-found'</span><span class="s1">] ?? components[</span><span class="s0">'not-found'</span><span class="s1">]</span>
                <span class="s1">}</span>
            <span class="s1">]</span>
        <span class="s1">},</span>
        <span class="s3">// When global-not-found is present, skip layout from components</span>
        <span class="s1">hasGlobalNotFound ? components : {}</span>
    <span class="s1">];</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Returns a function that parses the dynamic segment and return the associated value.</span>
 <span class="s3">*/ </span><span class="s2">function </span><span class="s1">makeGetDynamicParamFromSegment(params, pagePath, fallbackRouteParams) {</span>
    <span class="s2">return function </span><span class="s1">getDynamicParamFromSegment(</span><span class="s3">// [slug] / [[slug]] / [...slug]</span>
    <span class="s1">segment) {</span>
        <span class="s2">const </span><span class="s1">segmentParam = (</span><span class="s4">0</span><span class="s1">, _getsegmentparam.getSegmentParam)(segment);</span>
        <span class="s2">if </span><span class="s1">(!segmentParam) {</span>
            <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">segmentKey = segmentParam.param;</span>
        <span class="s2">const </span><span class="s1">dynamicParamType = _getshortdynamicparamtype.dynamicParamTypes[segmentParam.type];</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _getdynamicparam.getDynamicParam)(params, segmentKey, dynamicParamType, pagePath, fallbackRouteParams);</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">NonIndex({ pagePath, statusCode, isPossibleServerAction }) {</span>
    <span class="s2">const </span><span class="s1">is404Page = pagePath === </span><span class="s0">'/404'</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">isInvalidStatusCode = </span><span class="s2">typeof </span><span class="s1">statusCode === </span><span class="s0">'number' </span><span class="s1">&amp;&amp; statusCode &gt; </span><span class="s4">400</span><span class="s1">;</span>
    <span class="s3">// Only render noindex for page request, skip for server actions</span>
    <span class="s3">// TODO: is this correct if `isPossibleServerAction` is a false positive?</span>
    <span class="s2">if </span><span class="s1">(!isPossibleServerAction &amp;&amp; (is404Page || isInvalidStatusCode)) {</span>
        <span class="s2">return </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(</span><span class="s0">&quot;meta&quot;</span><span class="s1">, {</span>
            <span class="s1">name: </span><span class="s0">&quot;robots&quot;</span><span class="s1">,</span>
            <span class="s1">content: </span><span class="s0">&quot;noindex&quot;</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* This is used by server actions &amp; client-side navigations to generate RSC data from a client-side request.</span>
 <span class="s3">* This function is only called on &quot;dynamic&quot; requests (ie, there wasn't already a static response).</span>
 <span class="s3">* It uses request headers (namely `next-router-state-tree`) to determine where to start rendering.</span>
 <span class="s3">*/ </span><span class="s1">async </span><span class="s2">function </span><span class="s1">generateDynamicRSCPayload(ctx, options) {</span>
    <span class="s3">// Flight data that is going to be passed to the browser.</span>
    <span class="s3">// Currently a single item array but in the future multiple patches might be combined in a single request.</span>
    <span class="s3">// We initialize `flightData` to an empty string because the client router knows how to tolerate</span>
    <span class="s3">// it (treating it as an MPA navigation). The only time this function wouldn't generate flight data</span>
    <span class="s3">// is for server actions, if the server action handler instructs this function to skip it. When the server</span>
    <span class="s3">// action reducer sees a falsy value, it'll simply resolve the action with no data.</span>
    <span class="s2">let </span><span class="s1">flightData = </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">{ componentMod: { tree: loaderTree, createMetadataComponents, MetadataBoundary, ViewportBoundary }, getDynamicParamFromSegment, appUsingSizeAdjustment, query, requestId, flightRouterState, workStore, url } = ctx;</span>
    <span class="s2">const </span><span class="s1">serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata;</span>
    <span class="s2">if </span><span class="s1">(!(options == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: options.skipFlight)) {</span>
        <span class="s2">const </span><span class="s1">preloadCallbacks = [];</span>
        <span class="s2">const </span><span class="s1">{ ViewportTree, MetadataTree, getViewportReady, getMetadataReady, StreamingMetadataOutlet } = createMetadataComponents({</span>
            <span class="s1">tree: loaderTree,</span>
            <span class="s1">parsedQuery: query,</span>
            <span class="s1">pathname: url.pathname,</span>
            <span class="s1">metadataContext: (</span><span class="s4">0</span><span class="s1">, _metadatacontext.createMetadataContext)(ctx.renderOpts),</span>
            <span class="s1">getDynamicParamFromSegment,</span>
            <span class="s1">appUsingSizeAdjustment,</span>
            <span class="s1">workStore,</span>
            <span class="s1">MetadataBoundary,</span>
            <span class="s1">ViewportBoundary,</span>
            <span class="s1">serveStreamingMetadata</span>
        <span class="s1">});</span>
        <span class="s1">flightData = (</span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _walktreewithflightrouterstate.walkTreeWithFlightRouterState)({</span>
            <span class="s1">ctx,</span>
            <span class="s1">loaderTreeToFilter: loaderTree,</span>
            <span class="s1">parentParams: {},</span>
            <span class="s1">flightRouterState,</span>
            <span class="s3">// For flight, render metadata inside leaf page</span>
            <span class="s1">rscHead: </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsxs)(_react.default.Fragment, {</span>
                <span class="s1">children: [</span>
                    <span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(NonIndex, {</span>
                        <span class="s1">pagePath: ctx.pagePath,</span>
                        <span class="s1">statusCode: ctx.res.statusCode,</span>
                        <span class="s1">isPossibleServerAction: ctx.isPossibleServerAction</span>
                    <span class="s1">}),</span>
                    <span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(ViewportTree, {}, getFlightViewportKey(requestId)),</span>
                    <span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(MetadataTree, {}, getFlightMetadataKey(requestId))</span>
                <span class="s1">]</span>
            <span class="s1">}, flightDataPathHeadKey),</span>
            <span class="s1">injectedCSS: </span><span class="s2">new </span><span class="s1">Set(),</span>
            <span class="s1">injectedJS: </span><span class="s2">new </span><span class="s1">Set(),</span>
            <span class="s1">injectedFontPreloadTags: </span><span class="s2">new </span><span class="s1">Set(),</span>
            <span class="s1">rootLayoutIncluded: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">getViewportReady,</span>
            <span class="s1">getMetadataReady,</span>
            <span class="s1">preloadCallbacks,</span>
            <span class="s1">StreamingMetadataOutlet</span>
        <span class="s1">})).map((path)=&gt;path.slice(</span><span class="s4">1</span><span class="s1">)) </span><span class="s3">// remove the '' (root) segment</span>
        <span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">// If we have an action result, then this is a server action response.</span>
    <span class="s3">// We can rely on this because `ActionResult` will always be a promise, even if</span>
    <span class="s3">// the result is falsey.</span>
    <span class="s2">if </span><span class="s1">(options == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: options.actionResult) {</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">a: options.actionResult,</span>
            <span class="s1">f: flightData,</span>
            <span class="s1">b: ctx.sharedContext.buildId</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s3">// Otherwise, it's a regular RSC response.</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">b: ctx.sharedContext.buildId,</span>
        <span class="s1">f: flightData,</span>
        <span class="s1">S: workStore.isStaticGeneration</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createErrorContext(ctx, renderSource) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">routerKind: </span><span class="s0">'App Router'</span><span class="s1">,</span>
        <span class="s1">routePath: ctx.pagePath,</span>
        <span class="s3">// TODO: is this correct if `isPossibleServerAction` is a false positive?</span>
        <span class="s1">routeType: ctx.isPossibleServerAction ? </span><span class="s0">'action' </span><span class="s1">: </span><span class="s0">'render'</span><span class="s1">,</span>
        <span class="s1">renderSource,</span>
        <span class="s1">revalidateReason: (</span><span class="s4">0</span><span class="s1">, _utils.getRevalidateReason)(ctx.workStore)</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Produces a RenderResult containing the Flight data for the given request. See</span>
 <span class="s3">* `generateDynamicRSCPayload` for information on the contents of the render result.</span>
 <span class="s3">*/ </span><span class="s1">async </span><span class="s2">function </span><span class="s1">generateDynamicFlightRenderResult(req, ctx, requestStore, options) {</span>
    <span class="s2">const </span><span class="s1">renderOpts = ctx.renderOpts;</span>
    <span class="s2">function </span><span class="s1">onFlightDataRenderError(err) {</span>
        <span class="s2">return </span><span class="s1">renderOpts.onInstrumentationRequestError == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: renderOpts.onInstrumentationRequestError.call(renderOpts, err, req, createErrorContext(ctx, </span><span class="s0">'react-server-components-payload'</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">onError = (</span><span class="s4">0</span><span class="s1">, _createerrorhandler.createFlightReactServerErrorHandler)(!!renderOpts.dev, onFlightDataRenderError);</span>
    <span class="s2">const </span><span class="s1">RSCPayload = </span><span class="s2">await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(requestStore, generateDynamicRSCPayload, ctx, options);</span>
    <span class="s3">// For app dir, use the bundled version of Flight server renderer (renderToReadableStream)</span>
    <span class="s3">// which contains the subset React.</span>
    <span class="s2">const </span><span class="s1">flightReadableStream = _workunitasyncstorageexternal.workUnitAsyncStorage.run(requestStore, ctx.componentMod.renderToReadableStream, RSCPayload, ctx.clientReferenceManifest.clientModules, {</span>
        <span class="s1">onError,</span>
        <span class="s1">temporaryReferences: options == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: options.temporaryReferences,</span>
        <span class="s1">filterStackFrame</span>
    <span class="s1">});</span>
    <span class="s2">return new </span><span class="s1">_flightrenderresult.FlightRenderResult(flightReadableStream, {</span>
        <span class="s1">fetchMetrics: ctx.workStore.fetchMetrics</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">generateRuntimePrefetchResult(req, res, ctx, requestStore) {</span>
    <span class="s2">const </span><span class="s1">{ workStore } = ctx;</span>
    <span class="s2">const </span><span class="s1">renderOpts = ctx.renderOpts;</span>
    <span class="s2">function </span><span class="s1">onFlightDataRenderError(err) {</span>
        <span class="s2">return </span><span class="s1">renderOpts.onInstrumentationRequestError == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: renderOpts.onInstrumentationRequestError.call(renderOpts, err, req, </span><span class="s3">// TODO(runtime-ppr): should we use a different value?</span>
        <span class="s1">createErrorContext(ctx, </span><span class="s0">'react-server-components-payload'</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">onError = (</span><span class="s4">0</span><span class="s1">, _createerrorhandler.createFlightReactServerErrorHandler)(</span><span class="s2">false</span><span class="s1">, onFlightDataRenderError);</span>
    <span class="s2">const </span><span class="s1">metadata = {};</span>
    <span class="s2">const </span><span class="s1">generatePayload = ()=&gt;generateDynamicRSCPayload(ctx, undefined);</span>
    <span class="s2">const </span><span class="s1">{ componentMod: { tree }, getDynamicParamFromSegment } = ctx;</span>
    <span class="s2">const </span><span class="s1">rootParams = (</span><span class="s4">0</span><span class="s1">, _createcomponenttree.getRootParams)(tree, getDynamicParamFromSegment);</span>
    <span class="s3">// We need to share caches between the prospective prerender and the final prerender,</span>
    <span class="s3">// but we're not going to persist this anywhere.</span>
    <span class="s2">const </span><span class="s1">prerenderResumeDataCache = (</span><span class="s4">0</span><span class="s1">, _resumedatacache.createPrerenderResumeDataCache)();</span>
    <span class="s3">// We're not resuming an existing render.</span>
    <span class="s2">const </span><span class="s1">renderResumeDataCache = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">await </span><span class="s1">prospectiveRuntimeServerPrerender(ctx, generatePayload, prerenderResumeDataCache, renderResumeDataCache, rootParams, requestStore.cookies, requestStore.draftMode);</span>
    <span class="s2">const </span><span class="s1">response = </span><span class="s2">await </span><span class="s1">finalRuntimeServerPrerender(ctx, generatePayload, prerenderResumeDataCache, renderResumeDataCache, rootParams, requestStore.cookies, requestStore.draftMode, onError);</span>
    <span class="s1">applyMetadataFromPrerenderResult(response, metadata, workStore);</span>
    <span class="s1">metadata.fetchMetrics = ctx.workStore.fetchMetrics;</span>
    <span class="s2">if </span><span class="s1">(response.isPartial) {</span>
        <span class="s1">res.setHeader(_approuterheaders.NEXT_DID_POSTPONE_HEADER, </span><span class="s0">'1'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">return new </span><span class="s1">_flightrenderresult.FlightRenderResult(response.result.prelude, metadata);</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">prospectiveRuntimeServerPrerender(ctx, getPayload, prerenderResumeDataCache, renderResumeDataCache, rootParams, cookies, draftMode) {</span>
    <span class="s2">const </span><span class="s1">{ implicitTags, renderOpts, workStore } = ctx;</span>
    <span class="s2">const </span><span class="s1">{ clientReferenceManifest, ComponentMod } = renderOpts;</span>
    <span class="s1">assertClientReferenceManifest(clientReferenceManifest);</span>
    <span class="s3">// Prerender controller represents the lifetime of the prerender.</span>
    <span class="s3">// It will be aborted when a Task is complete or a synchronously aborting</span>
    <span class="s3">// API is called. Notably during cache-filling renders this does not actually</span>
    <span class="s3">// terminate the render itself which will continue until all caches are filled</span>
    <span class="s2">const </span><span class="s1">initialServerPrerenderController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
    <span class="s3">// This controller represents the lifetime of the React render call. Notably</span>
    <span class="s3">// during the cache-filling render it is different from the prerender controller</span>
    <span class="s3">// because we don't want to end the react render until all caches are filled.</span>
    <span class="s2">const </span><span class="s1">initialServerRenderController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
    <span class="s3">// The cacheSignal helps us track whether caches are still filling or we are ready</span>
    <span class="s3">// to cut the render off.</span>
    <span class="s2">const </span><span class="s1">cacheSignal = </span><span class="s2">new </span><span class="s1">_cachesignal.CacheSignal();</span>
    <span class="s2">const </span><span class="s1">initialServerPrerenderStore = {</span>
        <span class="s1">type: </span><span class="s0">'prerender-runtime'</span><span class="s1">,</span>
        <span class="s1">phase: </span><span class="s0">'render'</span><span class="s1">,</span>
        <span class="s1">rootParams,</span>
        <span class="s1">implicitTags,</span>
        <span class="s1">renderSignal: initialServerRenderController.signal,</span>
        <span class="s1">controller: initialServerPrerenderController,</span>
        <span class="s3">// During the initial prerender we need to track all cache reads to ensure</span>
        <span class="s3">// we render long enough to fill every cache it is possible to visit during</span>
        <span class="s3">// the final prerender.</span>
        <span class="s1">cacheSignal,</span>
        <span class="s3">// We only need to track dynamic accesses during the final prerender.</span>
        <span class="s1">dynamicTracking: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s3">// Runtime prefetches are never cached server-side, only client-side,</span>
        <span class="s3">// so we set `expire` and `revalidate` to their minimum values just in case.</span>
        <span class="s1">revalidate: </span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">expire: </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s1">stale: _constants1.INFINITE_CACHE,</span>
        <span class="s1">tags: [</span>
            <span class="s1">...implicitTags.tags</span>
        <span class="s1">],</span>
        <span class="s1">renderResumeDataCache,</span>
        <span class="s1">prerenderResumeDataCache,</span>
        <span class="s1">hmrRefreshHash: undefined,</span>
        <span class="s1">captureOwnerStack: undefined,</span>
        <span class="s3">// We only need task sequencing in the final prerender.</span>
        <span class="s1">runtimeStagePromise: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s3">// These are not present in regular prerenders, but allowed in a runtime prerender.</span>
        <span class="s1">cookies,</span>
        <span class="s1">draftMode</span>
    <span class="s1">};</span>
    <span class="s3">// We're not going to use the result of this render because the only time it could be used</span>
    <span class="s3">// is if it completes in a microtask and that's likely very rare for any non-trivial app</span>
    <span class="s2">const </span><span class="s1">initialServerPayload = </span><span class="s2">await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(initialServerPrerenderStore, getPayload);</span>
    <span class="s2">const </span><span class="s1">pendingInitialServerResult = _workunitasyncstorageexternal.workUnitAsyncStorage.run(initialServerPrerenderStore, ComponentMod.prerender, initialServerPayload, clientReferenceManifest.clientModules, {</span>
        <span class="s1">filterStackFrame,</span>
        <span class="s1">onError: (err)=&gt;{</span>
            <span class="s2">const </span><span class="s1">digest = (</span><span class="s4">0</span><span class="s1">, _createerrorhandler.getDigestForWellKnownError)(err);</span>
            <span class="s2">if </span><span class="s1">(digest) {</span>
                <span class="s2">return </span><span class="s1">digest;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(initialServerPrerenderController.signal.aborted) {</span>
                <span class="s3">// The render aborted before this error was handled which indicates</span>
                <span class="s3">// the error is caused by unfinished components within the render</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s1">, _prospectiverenderutils.printDebugThrownValueForProspectiveRender)(err, workStore.route);</span>
            <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s3">// we don't care to track postpones during the prospective render because we need</span>
        <span class="s3">// to always do a final render anyway</span>
        <span class="s1">onPostpone: undefined,</span>
        <span class="s3">// We don't want to stop rendering until the cacheSignal is complete so we pass</span>
        <span class="s3">// a different signal to this render call than is used by dynamic APIs to signify</span>
        <span class="s3">// transitioning out of the prerender environment</span>
        <span class="s1">signal: initialServerRenderController.signal</span>
    <span class="s1">});</span>
    <span class="s3">// Wait for all caches to be finished filling and for async imports to resolve</span>
    <span class="s1">(</span><span class="s4">0</span><span class="s1">, _trackmoduleloadingexternal.trackPendingModules)(cacheSignal);</span>
    <span class="s2">await </span><span class="s1">cacheSignal.cacheReady();</span>
    <span class="s1">initialServerRenderController.abort();</span>
    <span class="s1">initialServerPrerenderController.abort();</span>
    <span class="s3">// We don't need to continue the prerender process if we already</span>
    <span class="s3">// detected invalid dynamic usage in the initial prerender phase.</span>
    <span class="s2">if </span><span class="s1">(workStore.invalidDynamicUsageError) {</span>
        <span class="s2">throw </span><span class="s1">workStore.invalidDynamicUsageError;</span>
    <span class="s1">}</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">return await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _apprenderprerenderutils.createReactServerPrerenderResult)(pendingInitialServerResult);</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
        <span class="s2">if </span><span class="s1">(initialServerRenderController.signal.aborted || initialServerPrerenderController.signal.aborted) {</span>
        <span class="s3">// These are expected errors that might error the prerender. we ignore them.</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {</span>
            <span class="s3">// We don't normally log these errors because we are going to retry anyway but</span>
            <span class="s3">// it can be useful for debugging Next.js itself to get visibility here when needed</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _prospectiverenderutils.printDebugThrownValueForProspectiveRender)(err, workStore.route);</span>
        <span class="s1">}</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">finalRuntimeServerPrerender(ctx, getPayload, prerenderResumeDataCache, renderResumeDataCache, rootParams, cookies, draftMode, onError) {</span>
    <span class="s2">const </span><span class="s1">{ implicitTags, renderOpts } = ctx;</span>
    <span class="s2">const </span><span class="s1">{ clientReferenceManifest, ComponentMod, experimental, isDebugDynamicAccesses } = renderOpts;</span>
    <span class="s1">assertClientReferenceManifest(clientReferenceManifest);</span>
    <span class="s2">const </span><span class="s1">selectStaleTime = createSelectStaleTime(experimental);</span>
    <span class="s2">let </span><span class="s1">serverIsDynamic = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">finalServerController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
    <span class="s2">const </span><span class="s1">serverDynamicTracking = (</span><span class="s4">0</span><span class="s1">, _dynamicrendering.createDynamicTrackingState)(isDebugDynamicAccesses);</span>
    <span class="s2">const </span><span class="s1">{ promise: runtimeStagePromise, resolve: resolveBlockedRuntimeAPIs } = (</span><span class="s4">0</span><span class="s1">, _promisewithresolvers.createPromiseWithResolvers)();</span>
    <span class="s2">const </span><span class="s1">finalServerPrerenderStore = {</span>
        <span class="s1">type: </span><span class="s0">'prerender-runtime'</span><span class="s1">,</span>
        <span class="s1">phase: </span><span class="s0">'render'</span><span class="s1">,</span>
        <span class="s1">rootParams,</span>
        <span class="s1">implicitTags,</span>
        <span class="s1">renderSignal: finalServerController.signal,</span>
        <span class="s1">controller: finalServerController,</span>
        <span class="s3">// All caches we could read must already be filled so no tracking is necessary</span>
        <span class="s1">cacheSignal: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">dynamicTracking: serverDynamicTracking,</span>
        <span class="s3">// Runtime prefetches are never cached server-side, only client-side,</span>
        <span class="s3">// so we set `expire` and `revalidate` to their minimum values just in case.</span>
        <span class="s1">revalidate: </span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">expire: </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s1">stale: _constants1.INFINITE_CACHE,</span>
        <span class="s1">tags: [</span>
            <span class="s1">...implicitTags.tags</span>
        <span class="s1">],</span>
        <span class="s1">prerenderResumeDataCache,</span>
        <span class="s1">renderResumeDataCache,</span>
        <span class="s1">hmrRefreshHash: undefined,</span>
        <span class="s1">captureOwnerStack: undefined,</span>
        <span class="s3">// Used to separate the &quot;Static&quot; stage from the &quot;Runtime&quot; stage.</span>
        <span class="s1">runtimeStagePromise,</span>
        <span class="s3">// These are not present in regular prerenders, but allowed in a runtime prerender.</span>
        <span class="s1">cookies,</span>
        <span class="s1">draftMode</span>
    <span class="s1">};</span>
    <span class="s2">const </span><span class="s1">finalRSCPayload = </span><span class="s2">await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(finalServerPrerenderStore, getPayload);</span>
    <span class="s2">let </span><span class="s1">prerenderIsPending = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">result = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _apprenderprerenderutils.prerenderAndAbortInSequentialTasksWithStages)(async ()=&gt;{</span>
        <span class="s3">// Static stage</span>
        <span class="s2">const </span><span class="s1">prerenderResult = </span><span class="s2">await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(finalServerPrerenderStore, ComponentMod.prerender, finalRSCPayload, clientReferenceManifest.clientModules, {</span>
            <span class="s1">filterStackFrame,</span>
            <span class="s1">onError,</span>
            <span class="s1">signal: finalServerController.signal</span>
        <span class="s1">});</span>
        <span class="s1">prerenderIsPending = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s1">prerenderResult;</span>
    <span class="s1">}, ()=&gt;{</span>
        <span class="s3">// Advance to the runtime stage.</span>
        <span class="s3">//</span>
        <span class="s3">// We make runtime APIs hang during the first task (above), and unblock them in the following task (here).</span>
        <span class="s3">// This makes sure that, at this point, we'll have finished all the static parts (what we'd prerender statically).</span>
        <span class="s3">// We know that they don't contain any incorrect sync IO, because that'd have caused a build error.</span>
        <span class="s3">// After we unblock Runtime APIs, if we encounter sync IO (e.g. `await cookies(); Date.now()`),</span>
        <span class="s3">// we'll abort, but we'll produce at least as much output as a static prerender would.</span>
        <span class="s1">resolveBlockedRuntimeAPIs();</span>
    <span class="s1">}, ()=&gt;{</span>
        <span class="s3">// Abort.</span>
        <span class="s2">if </span><span class="s1">(finalServerController.signal.aborted) {</span>
            <span class="s3">// If the server controller is already aborted we must have called something</span>
            <span class="s3">// that required aborting the prerender synchronously such as with new Date()</span>
            <span class="s1">serverIsDynamic = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(prerenderIsPending) {</span>
            <span class="s3">// If prerenderIsPending then we have blocked for longer than a Task and we assume</span>
            <span class="s3">// there is something unfinished.</span>
            <span class="s1">serverIsDynamic = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">finalServerController.abort();</span>
    <span class="s1">});</span>
    <span class="s1">(</span><span class="s4">0</span><span class="s1">, _dynamicrendering.warnOnSyncDynamicError)(serverDynamicTracking);</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">result,</span>
        <span class="s3">// TODO(runtime-ppr): do we need to produce a digest map here?</span>
        <span class="s3">// digestErrorsMap: ...,</span>
        <span class="s1">dynamicAccess: serverDynamicTracking,</span>
        <span class="s1">isPartial: serverIsDynamic,</span>
        <span class="s1">collectedRevalidate: finalServerPrerenderStore.revalidate,</span>
        <span class="s1">collectedExpire: finalServerPrerenderStore.expire,</span>
        <span class="s1">collectedStale: selectStaleTime(finalServerPrerenderStore.stale),</span>
        <span class="s1">collectedTags: finalServerPrerenderStore.tags</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Performs a &quot;warmup&quot; render of the RSC payload for a given route. This function is called by the server</span>
 <span class="s3">* prior to an actual render request in Dev mode only. It's purpose is to fill caches so the actual render</span>
 <span class="s3">* can accurately log activity in the right render context (Prerender vs Render).</span>
 <span class="s3">*</span>
 <span class="s3">* At the moment this implementation is mostly a fork of generateDynamicFlightRenderResult</span>
 <span class="s3">*/ </span><span class="s1">async </span><span class="s2">function </span><span class="s1">warmupDevRender(req, ctx) {</span>
    <span class="s2">const </span><span class="s1">{ clientReferenceManifest, componentMod: ComponentMod, getDynamicParamFromSegment, implicitTags, renderOpts, workStore } = ctx;</span>
    <span class="s2">const </span><span class="s1">{ allowEmptyStaticShell = </span><span class="s2">false</span><span class="s1">, dev, onInstrumentationRequestError } = renderOpts;</span>
    <span class="s2">if </span><span class="s1">(!dev) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">'generateDynamicFlightRenderResult should never be called in `next start` mode.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E523&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">rootParams = (</span><span class="s4">0</span><span class="s1">, _createcomponenttree.getRootParams)(ComponentMod.tree, getDynamicParamFromSegment);</span>
    <span class="s2">function </span><span class="s1">onFlightDataRenderError(err) {</span>
        <span class="s2">return </span><span class="s1">onInstrumentationRequestError == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: onInstrumentationRequestError(err, req, createErrorContext(ctx, </span><span class="s0">'react-server-components-payload'</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">onError = (</span><span class="s4">0</span><span class="s1">, _createerrorhandler.createFlightReactServerErrorHandler)(</span><span class="s2">true</span><span class="s1">, onFlightDataRenderError);</span>
    <span class="s3">// We're doing a dev warmup, so we should create a new resume data cache so</span>
    <span class="s3">// we can fill it.</span>
    <span class="s2">const </span><span class="s1">prerenderResumeDataCache = (</span><span class="s4">0</span><span class="s1">, _resumedatacache.createPrerenderResumeDataCache)();</span>
    <span class="s2">const </span><span class="s1">renderController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
    <span class="s2">const </span><span class="s1">prerenderController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
    <span class="s2">const </span><span class="s1">reactController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
    <span class="s2">const </span><span class="s1">cacheSignal = </span><span class="s2">new </span><span class="s1">_cachesignal.CacheSignal();</span>
    <span class="s2">const </span><span class="s1">prerenderStore = {</span>
        <span class="s1">type: </span><span class="s0">'prerender'</span><span class="s1">,</span>
        <span class="s1">phase: </span><span class="s0">'render'</span><span class="s1">,</span>
        <span class="s1">rootParams,</span>
        <span class="s1">implicitTags,</span>
        <span class="s1">renderSignal: renderController.signal,</span>
        <span class="s1">controller: prerenderController,</span>
        <span class="s1">cacheSignal,</span>
        <span class="s1">dynamicTracking: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">allowEmptyStaticShell,</span>
        <span class="s1">revalidate: _constants1.INFINITE_CACHE,</span>
        <span class="s1">expire: _constants1.INFINITE_CACHE,</span>
        <span class="s1">stale: _constants1.INFINITE_CACHE,</span>
        <span class="s1">tags: [],</span>
        <span class="s1">prerenderResumeDataCache,</span>
        <span class="s1">renderResumeDataCache: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">hmrRefreshHash: req.cookies[_approuterheaders.NEXT_HMR_REFRESH_HASH_COOKIE],</span>
        <span class="s1">captureOwnerStack: ComponentMod.captureOwnerStack,</span>
        <span class="s3">// warmup is a dev only feature and no fallback params are used in the</span>
        <span class="s3">// primary render which is static. We only use a prerender store here to</span>
        <span class="s3">// allow the warmup to halt on Request data APIs and fetches.</span>
        <span class="s1">fallbackRouteParams: </span><span class="s2">null</span>
    <span class="s1">};</span>
    <span class="s2">const </span><span class="s1">rscPayload = </span><span class="s2">await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(prerenderStore, generateDynamicRSCPayload, ctx);</span>
    <span class="s3">// For app dir, use the bundled version of Flight server renderer (renderToReadableStream)</span>
    <span class="s3">// which contains the subset React.</span>
    <span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(prerenderStore, ComponentMod.renderToReadableStream, rscPayload, clientReferenceManifest.clientModules, {</span>
        <span class="s1">filterStackFrame,</span>
        <span class="s1">onError,</span>
        <span class="s1">signal: renderController.signal</span>
    <span class="s1">});</span>
    <span class="s3">// Wait for all caches to be finished filling and for async imports to resolve</span>
    <span class="s1">(</span><span class="s4">0</span><span class="s1">, _trackmoduleloadingexternal.trackPendingModules)(cacheSignal);</span>
    <span class="s2">await </span><span class="s1">cacheSignal.cacheReady();</span>
    <span class="s3">// We unset the cache so any late over-run renders aren't able to write into this cache</span>
    <span class="s1">prerenderStore.prerenderResumeDataCache = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s3">// Abort the render</span>
    <span class="s1">reactController.abort();</span>
    <span class="s1">renderController.abort();</span>
    <span class="s3">// We don't really want to return a result here but the stack of functions</span>
    <span class="s3">// that calls into renderToHTML... expects a result. We should refactor this to</span>
    <span class="s3">// lift the warmup pathway outside of renderToHTML... but for now this suffices</span>
    <span class="s2">return new </span><span class="s1">_flightrenderresult.FlightRenderResult(</span><span class="s0">''</span><span class="s1">, {</span>
        <span class="s1">fetchMetrics: workStore.fetchMetrics,</span>
        <span class="s1">renderResumeDataCache: (</span><span class="s4">0</span><span class="s1">, _resumedatacache.createRenderResumeDataCache)(prerenderResumeDataCache)</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Crawlers will inadvertently think the canonicalUrl in the RSC payload should be crawled</span>
 <span class="s3">* when our intention is to just seed the router state with the current URL.</span>
 <span class="s3">* This function splits up the pathname so that we can later join it on</span>
 <span class="s3">* when we're ready to consume the path.</span>
 <span class="s3">*/ </span><span class="s2">function </span><span class="s1">prepareInitialCanonicalUrl(url) {</span>
    <span class="s2">return </span><span class="s1">(url.pathname + url.search).split(</span><span class="s0">'/'</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">// This is the data necessary to render &lt;AppRouter /&gt; when no SSR errors are encountered</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">getRSCPayload(tree, ctx, is404) {</span>
    <span class="s2">const </span><span class="s1">injectedCSS = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s2">const </span><span class="s1">injectedJS = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s2">const </span><span class="s1">injectedFontPreloadTags = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s2">let </span><span class="s1">missingSlots;</span>
    <span class="s3">// We only track missing parallel slots in development</span>
    <span class="s2">if </span><span class="s1">(process.env.NODE_ENV === </span><span class="s0">'development'</span><span class="s1">) {</span>
        <span class="s1">missingSlots = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">{ getDynamicParamFromSegment, query, appUsingSizeAdjustment, componentMod: { createMetadataComponents, MetadataBoundary, ViewportBoundary }, url, workStore } = ctx;</span>
    <span class="s2">const </span><span class="s1">initialTree = (</span><span class="s4">0</span><span class="s1">, _createflightrouterstatefromloadertree.createFlightRouterStateFromLoaderTree)(tree, getDynamicParamFromSegment, query);</span>
    <span class="s2">const </span><span class="s1">serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata;</span>
    <span class="s2">const </span><span class="s1">hasGlobalNotFound = !!tree[</span><span class="s4">2</span><span class="s1">][</span><span class="s0">'global-not-found'</span><span class="s1">];</span>
    <span class="s2">const </span><span class="s1">{ ViewportTree, MetadataTree, getViewportReady, getMetadataReady, StreamingMetadataOutlet } = createMetadataComponents({</span>
        <span class="s1">tree,</span>
        <span class="s3">// When it's using global-not-found, metadata errorType is undefined, which will retrieve the</span>
        <span class="s3">// metadata from the page.</span>
        <span class="s3">// When it's using not-found, metadata errorType is 'not-found', which will retrieve the</span>
        <span class="s3">// metadata from the not-found.js boundary.</span>
        <span class="s3">// TODO: remove this condition and keep it undefined when global-not-found is stabilized.</span>
        <span class="s1">errorType: is404 &amp;&amp; !hasGlobalNotFound ? </span><span class="s0">'not-found' </span><span class="s1">: undefined,</span>
        <span class="s1">parsedQuery: query,</span>
        <span class="s1">pathname: url.pathname,</span>
        <span class="s1">metadataContext: (</span><span class="s4">0</span><span class="s1">, _metadatacontext.createMetadataContext)(ctx.renderOpts),</span>
        <span class="s1">getDynamicParamFromSegment,</span>
        <span class="s1">appUsingSizeAdjustment,</span>
        <span class="s1">workStore,</span>
        <span class="s1">MetadataBoundary,</span>
        <span class="s1">ViewportBoundary,</span>
        <span class="s1">serveStreamingMetadata</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">preloadCallbacks = [];</span>
    <span class="s2">const </span><span class="s1">seedData = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _createcomponenttree.createComponentTree)({</span>
        <span class="s1">ctx,</span>
        <span class="s1">loaderTree: tree,</span>
        <span class="s1">parentParams: {},</span>
        <span class="s1">injectedCSS,</span>
        <span class="s1">injectedJS,</span>
        <span class="s1">injectedFontPreloadTags,</span>
        <span class="s1">rootLayoutIncluded: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">getViewportReady,</span>
        <span class="s1">getMetadataReady,</span>
        <span class="s1">missingSlots,</span>
        <span class="s1">preloadCallbacks,</span>
        <span class="s1">authInterrupts: ctx.renderOpts.experimental.authInterrupts,</span>
        <span class="s1">StreamingMetadataOutlet</span>
    <span class="s1">});</span>
    <span class="s3">// When the `vary` response header is present with `Next-URL`, that means there's a chance</span>
    <span class="s3">// it could respond differently if there's an interception route. We provide this information</span>
    <span class="s3">// to `AppRouter` so that it can properly seed the prefetch cache with a prefix, if needed.</span>
    <span class="s2">const </span><span class="s1">varyHeader = ctx.res.getHeader(</span><span class="s0">'vary'</span><span class="s1">);</span>
    <span class="s2">const </span><span class="s1">couldBeIntercepted = </span><span class="s2">typeof </span><span class="s1">varyHeader === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; varyHeader.includes(_approuterheaders.NEXT_URL);</span>
    <span class="s2">const </span><span class="s1">initialHead = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsxs)(_react.default.Fragment, {</span>
        <span class="s1">children: [</span>
            <span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(NonIndex, {</span>
                <span class="s1">pagePath: ctx.pagePath,</span>
                <span class="s1">statusCode: ctx.res.statusCode,</span>
                <span class="s1">isPossibleServerAction: ctx.isPossibleServerAction</span>
            <span class="s1">}),</span>
            <span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(ViewportTree, {}),</span>
            <span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(MetadataTree, {})</span>
        <span class="s1">]</span>
    <span class="s1">}, flightDataPathHeadKey);</span>
    <span class="s2">const </span><span class="s1">{ GlobalError, styles: globalErrorStyles } = </span><span class="s2">await </span><span class="s1">getGlobalErrorStyles(tree, ctx);</span>
    <span class="s3">// Assume the head we're rendering contains only partial data if PPR is</span>
    <span class="s3">// enabled and this is a statically generated response. This is used by the</span>
    <span class="s3">// client Segment Cache after a prefetch to determine if it can skip the</span>
    <span class="s3">// second request to fill in the dynamic data.</span>
    <span class="s3">//</span>
    <span class="s3">// See similar comment in create-component-tree.tsx for more context.</span>
    <span class="s2">const </span><span class="s1">isPossiblyPartialHead = workStore.isStaticGeneration &amp;&amp; ctx.renderOpts.experimental.isRoutePPREnabled === </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s3">// See the comment above the `Preloads` component (below) for why this is part of the payload</span>
        <span class="s1">P: </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(Preloads, {</span>
            <span class="s1">preloadCallbacks: preloadCallbacks</span>
        <span class="s1">}),</span>
        <span class="s1">b: ctx.sharedContext.buildId,</span>
        <span class="s1">p: ctx.assetPrefix,</span>
        <span class="s1">c: prepareInitialCanonicalUrl(url),</span>
        <span class="s1">i: !!couldBeIntercepted,</span>
        <span class="s1">f: [</span>
            <span class="s1">[</span>
                <span class="s1">initialTree,</span>
                <span class="s1">seedData,</span>
                <span class="s1">initialHead,</span>
                <span class="s1">isPossiblyPartialHead</span>
            <span class="s1">]</span>
        <span class="s1">],</span>
        <span class="s1">m: missingSlots,</span>
        <span class="s1">G: [</span>
            <span class="s1">GlobalError,</span>
            <span class="s1">globalErrorStyles</span>
        <span class="s1">],</span>
        <span class="s1">s: </span><span class="s2">typeof </span><span class="s1">ctx.renderOpts.postponed === </span><span class="s0">'string'</span><span class="s1">,</span>
        <span class="s1">S: workStore.isStaticGeneration</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Preload calls (such as `ReactDOM.preloadStyle` and `ReactDOM.preloadFont`) need to be called during rendering</span>
 <span class="s3">* in order to create the appropriate preload tags in the DOM, otherwise they're a no-op. Since we invoke</span>
 <span class="s3">* renderToReadableStream with a function that returns component props rather than a component itself, we use</span>
 <span class="s3">* this component to &quot;render  &quot; the preload calls.</span>
 <span class="s3">*/ </span><span class="s2">function </span><span class="s1">Preloads({ preloadCallbacks }) {</span>
    <span class="s1">preloadCallbacks.forEach((preloadFn)=&gt;preloadFn());</span>
    <span class="s2">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">// This is the data necessary to render &lt;AppRouter /&gt; when an error state is triggered</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">getErrorRSCPayload(tree, ctx, ssrError, errorType) {</span>
    <span class="s2">const </span><span class="s1">{ getDynamicParamFromSegment, query, appUsingSizeAdjustment, componentMod: { createMetadataComponents, MetadataBoundary, ViewportBoundary }, url, workStore } = ctx;</span>
    <span class="s2">const </span><span class="s1">serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata;</span>
    <span class="s2">const </span><span class="s1">{ MetadataTree, ViewportTree } = createMetadataComponents({</span>
        <span class="s1">tree,</span>
        <span class="s1">parsedQuery: query,</span>
        <span class="s1">pathname: url.pathname,</span>
        <span class="s1">metadataContext: (</span><span class="s4">0</span><span class="s1">, _metadatacontext.createMetadataContext)(ctx.renderOpts),</span>
        <span class="s1">errorType,</span>
        <span class="s1">getDynamicParamFromSegment,</span>
        <span class="s1">appUsingSizeAdjustment,</span>
        <span class="s1">workStore,</span>
        <span class="s1">MetadataBoundary,</span>
        <span class="s1">ViewportBoundary,</span>
        <span class="s1">serveStreamingMetadata: serveStreamingMetadata</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">initialHead = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsxs)(_react.default.Fragment, {</span>
        <span class="s1">children: [</span>
            <span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(NonIndex, {</span>
                <span class="s1">pagePath: ctx.pagePath,</span>
                <span class="s1">statusCode: ctx.res.statusCode,</span>
                <span class="s1">isPossibleServerAction: ctx.isPossibleServerAction</span>
            <span class="s1">}),</span>
            <span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(ViewportTree, {}),</span>
            <span class="s1">process.env.NODE_ENV === </span><span class="s0">'development' </span><span class="s1">&amp;&amp; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(</span><span class="s0">&quot;meta&quot;</span><span class="s1">, {</span>
                <span class="s1">name: </span><span class="s0">&quot;next-error&quot;</span><span class="s1">,</span>
                <span class="s1">content: </span><span class="s0">&quot;not-found&quot;</span>
            <span class="s1">}),</span>
            <span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(MetadataTree, {})</span>
        <span class="s1">]</span>
    <span class="s1">}, flightDataPathHeadKey);</span>
    <span class="s2">const </span><span class="s1">initialTree = (</span><span class="s4">0</span><span class="s1">, _createflightrouterstatefromloadertree.createFlightRouterStateFromLoaderTree)(tree, getDynamicParamFromSegment, query);</span>
    <span class="s2">let </span><span class="s1">err = undefined;</span>
    <span class="s2">if </span><span class="s1">(ssrError) {</span>
        <span class="s1">err = (</span><span class="s4">0</span><span class="s1">, _iserror.default)(ssrError) ? ssrError : Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(ssrError + </span><span class="s0">''</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E394&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s3">// For metadata notFound error there's no global not found boundary on top</span>
    <span class="s3">// so we create a not found page with AppRouter</span>
    <span class="s2">const </span><span class="s1">seedData = [</span>
        <span class="s1">initialTree[</span><span class="s4">0</span><span class="s1">],</span>
        <span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsxs)(</span><span class="s0">&quot;html&quot;</span><span class="s1">, {</span>
            <span class="s1">id: </span><span class="s0">&quot;__next_error__&quot;</span><span class="s1">,</span>
            <span class="s1">children: [</span>
                <span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(</span><span class="s0">&quot;head&quot;</span><span class="s1">, {}),</span>
                <span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(</span><span class="s0">&quot;body&quot;</span><span class="s1">, {</span>
                    <span class="s1">children: process.env.NODE_ENV !== </span><span class="s0">'production' </span><span class="s1">&amp;&amp; err ? </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(</span><span class="s0">&quot;template&quot;</span><span class="s1">, {</span>
                        <span class="s0">&quot;data-next-error-message&quot;</span><span class="s1">: err.message,</span>
                        <span class="s0">&quot;data-next-error-digest&quot;</span><span class="s1">: </span><span class="s0">'digest' </span><span class="s2">in </span><span class="s1">err ? err.digest : </span><span class="s0">''</span><span class="s1">,</span>
                        <span class="s0">&quot;data-next-error-stack&quot;</span><span class="s1">: err.stack</span>
                    <span class="s1">}) : </span><span class="s2">null</span>
                <span class="s1">})</span>
            <span class="s1">]</span>
        <span class="s1">}),</span>
        <span class="s1">{},</span>
        <span class="s2">null</span><span class="s1">,</span>
        <span class="s2">false</span>
    <span class="s1">];</span>
    <span class="s2">const </span><span class="s1">{ GlobalError, styles: globalErrorStyles } = </span><span class="s2">await </span><span class="s1">getGlobalErrorStyles(tree, ctx);</span>
    <span class="s2">const </span><span class="s1">isPossiblyPartialHead = workStore.isStaticGeneration &amp;&amp; ctx.renderOpts.experimental.isRoutePPREnabled === </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">b: ctx.sharedContext.buildId,</span>
        <span class="s1">p: ctx.assetPrefix,</span>
        <span class="s1">c: prepareInitialCanonicalUrl(url),</span>
        <span class="s1">m: undefined,</span>
        <span class="s1">i: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">f: [</span>
            <span class="s1">[</span>
                <span class="s1">initialTree,</span>
                <span class="s1">seedData,</span>
                <span class="s1">initialHead,</span>
                <span class="s1">isPossiblyPartialHead</span>
            <span class="s1">]</span>
        <span class="s1">],</span>
        <span class="s1">G: [</span>
            <span class="s1">GlobalError,</span>
            <span class="s1">globalErrorStyles</span>
        <span class="s1">],</span>
        <span class="s1">s: </span><span class="s2">typeof </span><span class="s1">ctx.renderOpts.postponed === </span><span class="s0">'string'</span><span class="s1">,</span>
        <span class="s1">S: workStore.isStaticGeneration</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">assertClientReferenceManifest(clientReferenceManifest) {</span>
    <span class="s2">if </span><span class="s1">(!clientReferenceManifest) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">'Expected clientReferenceManifest to be defined.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E692&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">// This component must run in an SSR context. It will render the RSC root component</span>
<span class="s2">function </span><span class="s1">App({ reactServerStream, preinitScripts, clientReferenceManifest, ServerInsertedHTMLProvider, nonce }) {</span>
    <span class="s1">preinitScripts();</span>
    <span class="s2">const </span><span class="s1">response = _react.default.use((</span><span class="s4">0</span><span class="s1">, _useflightresponse.useFlightStream)(reactServerStream, clientReferenceManifest, nonce));</span>
    <span class="s2">const </span><span class="s1">initialState = (</span><span class="s4">0</span><span class="s1">, _createinitialrouterstate.createInitialRouterState)({</span>
        <span class="s3">// This is not used during hydration, so we don't have to pass a</span>
        <span class="s3">// real timestamp.</span>
        <span class="s1">navigatedAt: -</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">initialFlightData: response.f,</span>
        <span class="s1">initialCanonicalUrlParts: response.c,</span>
        <span class="s1">initialParallelRoutes: </span><span class="s2">new </span><span class="s1">Map(),</span>
        <span class="s3">// location is not initialized in the SSR render</span>
        <span class="s3">// it's set to window.location during hydration</span>
        <span class="s1">location: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">couldBeIntercepted: response.i,</span>
        <span class="s1">postponed: response.s,</span>
        <span class="s1">prerendered: response.S</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">actionQueue = (</span><span class="s4">0</span><span class="s1">, _approuterinstance.createMutableActionQueue)(initialState, </span><span class="s2">null</span><span class="s1">);</span>
    <span class="s2">const </span><span class="s1">{ HeadManagerContext } = require(</span><span class="s0">'../../shared/lib/head-manager-context.shared-runtime'</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(HeadManagerContext.Provider, {</span>
        <span class="s1">value: {</span>
            <span class="s1">appDir: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">nonce</span>
        <span class="s1">},</span>
        <span class="s1">children: </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(ServerInsertedHTMLProvider, {</span>
            <span class="s1">children: </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(_approuter.default, {</span>
                <span class="s1">actionQueue: actionQueue,</span>
                <span class="s1">globalErrorState: response.G,</span>
                <span class="s1">assetPrefix: response.p</span>
            <span class="s1">})</span>
        <span class="s1">})</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s3">// @TODO our error stream should be probably just use the same root component. But it was previously</span>
<span class="s3">// different I don't want to figure out if that is meaningful at this time so just keeping the behavior</span>
<span class="s3">// consistent for now.</span>
<span class="s2">function </span><span class="s1">ErrorApp({ reactServerStream, preinitScripts, clientReferenceManifest, ServerInsertedHTMLProvider, nonce }) {</span>
    <span class="s1">preinitScripts();</span>
    <span class="s2">const </span><span class="s1">response = _react.default.use((</span><span class="s4">0</span><span class="s1">, _useflightresponse.useFlightStream)(reactServerStream, clientReferenceManifest, nonce));</span>
    <span class="s2">const </span><span class="s1">initialState = (</span><span class="s4">0</span><span class="s1">, _createinitialrouterstate.createInitialRouterState)({</span>
        <span class="s3">// This is not used during hydration, so we don't have to pass a</span>
        <span class="s3">// real timestamp.</span>
        <span class="s1">navigatedAt: -</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">initialFlightData: response.f,</span>
        <span class="s1">initialCanonicalUrlParts: response.c,</span>
        <span class="s1">initialParallelRoutes: </span><span class="s2">new </span><span class="s1">Map(),</span>
        <span class="s3">// location is not initialized in the SSR render</span>
        <span class="s3">// it's set to window.location during hydration</span>
        <span class="s1">location: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">couldBeIntercepted: response.i,</span>
        <span class="s1">postponed: response.s,</span>
        <span class="s1">prerendered: response.S</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">actionQueue = (</span><span class="s4">0</span><span class="s1">, _approuterinstance.createMutableActionQueue)(initialState, </span><span class="s2">null</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(ServerInsertedHTMLProvider, {</span>
        <span class="s1">children: </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(_approuter.default, {</span>
            <span class="s1">actionQueue: actionQueue,</span>
            <span class="s1">globalErrorState: response.G,</span>
            <span class="s1">assetPrefix: response.p</span>
        <span class="s1">})</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">renderToHTMLOrFlightImpl(req, res, url, pagePath, query, renderOpts, workStore, parsedRequestHeaders, postponedState, serverComponentsHmrCache, sharedContext, fallbackRouteParams) {</span>
    <span class="s2">const </span><span class="s1">isNotFoundPath = pagePath === </span><span class="s0">'/404'</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(isNotFoundPath) {</span>
        <span class="s1">res.statusCode = </span><span class="s4">404</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">// A unique request timestamp used by development to ensure that it's</span>
    <span class="s3">// consistent and won't change during this request. This is important to</span>
    <span class="s3">// avoid that resources can be deduped by React Float if the same resource is</span>
    <span class="s3">// rendered or preloaded multiple times: `&lt;link href=&quot;a.css?v={Date.now()}&quot;/&gt;`.</span>
    <span class="s2">const </span><span class="s1">requestTimestamp = Date.now();</span>
    <span class="s2">const </span><span class="s1">{ clientReferenceManifest, serverActionsManifest, ComponentMod, nextFontManifest, serverActions, assetPrefix = </span><span class="s0">''</span><span class="s1">, enableTainting } = renderOpts;</span>
    <span class="s3">// We need to expose the bundled `require` API globally for</span>
    <span class="s3">// react-server-dom-webpack. This is a hack until we find a better way.</span>
    <span class="s2">if </span><span class="s1">(ComponentMod.__next_app__) {</span>
        <span class="s2">const </span><span class="s1">instrumented = (</span><span class="s4">0</span><span class="s1">, _clientcomponentrendererlogger.wrapClientComponentLoader)(ComponentMod);</span>
        <span class="s3">// When we are prerendering if there is a cacheSignal for tracking</span>
        <span class="s3">// cache reads we track calls to `loadChunk` and `require`. This allows us</span>
        <span class="s3">// to treat chunk/module loading with similar semantics as cache reads to avoid</span>
        <span class="s3">// module loading from causing a prerender to abort too early.</span>
        <span class="s2">const </span><span class="s1">shouldTrackModuleLoading = ()=&gt;{</span>
            <span class="s2">if </span><span class="s1">(!renderOpts.experimental.cacheComponents) {</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(renderOpts.dev) {</span>
                <span class="s2">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
            <span class="s2">if </span><span class="s1">(!workUnitStore) {</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
                <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
                    <span class="s2">return true</span><span class="s1">;</span>
                <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                    <span class="s2">return false</span><span class="s1">;</span>
                <span class="s2">default</span><span class="s1">:</span>
                    <span class="s1">workUnitStore;</span>
            <span class="s1">}</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">__next_require__ = (...args)=&gt;{</span>
            <span class="s2">const </span><span class="s1">exportsOrPromise = instrumented.require(...args);</span>
            <span class="s2">if </span><span class="s1">(shouldTrackModuleLoading()) {</span>
                <span class="s3">// requiring an async module returns a promise.</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s1">, _trackmoduleloadingexternal.trackPendingImport)(exportsOrPromise);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">exportsOrPromise;</span>
        <span class="s1">};</span>
        <span class="s3">// @ts-expect-error</span>
        <span class="s1">globalThis.__next_require__ = __next_require__;</span>
        <span class="s2">const </span><span class="s1">__next_chunk_load__ = (...args)=&gt;{</span>
            <span class="s2">const </span><span class="s1">loadingChunk = instrumented.loadChunk(...args);</span>
            <span class="s2">if </span><span class="s1">(shouldTrackModuleLoading()) {</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s1">, _trackmoduleloadingexternal.trackPendingChunkLoad)(loadingChunk);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">loadingChunk;</span>
        <span class="s1">};</span>
        <span class="s3">// @ts-expect-error</span>
        <span class="s1">globalThis.__next_chunk_load__ = __next_chunk_load__;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(process.env.NODE_ENV === </span><span class="s0">'development'</span><span class="s1">) {</span>
        <span class="s3">// reset isr status at start of request</span>
        <span class="s2">const </span><span class="s1">{ pathname } = </span><span class="s2">new </span><span class="s1">URL(req.url || </span><span class="s0">'/'</span><span class="s1">, </span><span class="s0">'http://n'</span><span class="s1">);</span>
        <span class="s1">renderOpts.setIsrStatus == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: renderOpts.setIsrStatus.call(renderOpts, pathname, </span><span class="s2">null</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s3">// The type check here ensures that `req` is correctly typed, and the</span>
    <span class="s3">// environment variable check provides dead code elimination.</span>
    <span class="s1">process.env.NEXT_RUNTIME !== </span><span class="s0">'edge' </span><span class="s1">&amp;&amp; (</span><span class="s4">0</span><span class="s1">, _helpers.isNodeNextRequest)(req)) {</span>
        <span class="s1">res.onClose(()=&gt;{</span>
            <span class="s3">// We stop tracking fetch metrics when the response closes, since we</span>
            <span class="s3">// report them at that time.</span>
            <span class="s1">workStore.shouldTrackFetchMetrics = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s1">req.originalRequest.on(</span><span class="s0">'end'</span><span class="s1">, ()=&gt;{</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s0">'performance' </span><span class="s2">in </span><span class="s1">globalThis) {</span>
                <span class="s2">const </span><span class="s1">metrics = (</span><span class="s4">0</span><span class="s1">, _clientcomponentrendererlogger.getClientComponentLoaderMetrics)({</span>
                    <span class="s1">reset: </span><span class="s2">true</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(metrics) {</span>
                    <span class="s1">(</span><span class="s4">0</span><span class="s1">, _tracer.getTracer)().startSpan(_constants.NextNodeServerSpan.clientComponentLoading, {</span>
                        <span class="s1">startTime: metrics.clientComponentLoadStart,</span>
                        <span class="s1">attributes: {</span>
                            <span class="s0">'next.clientComponentLoadCount'</span><span class="s1">: metrics.clientComponentLoadCount,</span>
                            <span class="s0">'next.span_type'</span><span class="s1">: _constants.NextNodeServerSpan.clientComponentLoading</span>
                        <span class="s1">}</span>
                    <span class="s1">}).end(metrics.clientComponentLoadStart + metrics.clientComponentLoadTimes);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">metadata = {</span>
        <span class="s1">statusCode: isNotFoundPath ? </span><span class="s4">404 </span><span class="s1">: undefined</span>
    <span class="s1">};</span>
    <span class="s2">const </span><span class="s1">appUsingSizeAdjustment = !!(nextFontManifest == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: nextFontManifest.appUsingSizeAdjust);</span>
    <span class="s1">assertClientReferenceManifest(clientReferenceManifest);</span>
    <span class="s2">const </span><span class="s1">serverModuleMap = (</span><span class="s4">0</span><span class="s1">, _actionutils.createServerModuleMap)({</span>
        <span class="s1">serverActionsManifest</span>
    <span class="s1">});</span>
    <span class="s1">(</span><span class="s4">0</span><span class="s1">, _encryptionutils.setReferenceManifestsSingleton)({</span>
        <span class="s1">page: workStore.page,</span>
        <span class="s1">clientReferenceManifest,</span>
        <span class="s1">serverActionsManifest,</span>
        <span class="s1">serverModuleMap</span>
    <span class="s1">});</span>
    <span class="s1">ComponentMod.patchFetch();</span>
    <span class="s3">// Pull out the hooks/references from the component.</span>
    <span class="s2">const </span><span class="s1">{ tree: loaderTree, taintObjectReference } = ComponentMod;</span>
    <span class="s2">if </span><span class="s1">(enableTainting) {</span>
        <span class="s1">taintObjectReference(</span><span class="s0">'Do not pass process.env to Client Components since it will leak sensitive data'</span><span class="s1">, process.env);</span>
    <span class="s1">}</span>
    <span class="s1">workStore.fetchMetrics = [];</span>
    <span class="s1">metadata.fetchMetrics = workStore.fetchMetrics;</span>
    <span class="s3">// don't modify original query object</span>
    <span class="s1">query = {</span>
        <span class="s1">...query</span>
    <span class="s1">};</span>
    <span class="s1">(</span><span class="s4">0</span><span class="s1">, _internalutils.stripInternalQueries)(query);</span>
    <span class="s2">const </span><span class="s1">{ flightRouterState, isPrefetchRequest, isRuntimePrefetchRequest, isRSCRequest, isDevWarmupRequest, isHmrRefresh, nonce } = parsedRequestHeaders;</span>
    <span class="s2">const </span><span class="s1">{ isStaticGeneration } = workStore;</span>
    <span class="s3">/**</span>
   <span class="s3">* The metadata items array created in next-app-loader with all relevant information</span>
   <span class="s3">* that we need to resolve the final metadata.</span>
   <span class="s3">*/ </span><span class="s2">let </span><span class="s1">requestId;</span>
    <span class="s2">if </span><span class="s1">(isStaticGeneration) {</span>
        <span class="s1">requestId = Buffer.from(</span><span class="s2">await </span><span class="s1">crypto.subtle.digest(</span><span class="s0">'SHA-1'</span><span class="s1">, Buffer.from(req.url))).toString(</span><span class="s0">'hex'</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(process.env.NEXT_RUNTIME === </span><span class="s0">'edge'</span><span class="s1">) {</span>
        <span class="s1">requestId = crypto.randomUUID();</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">requestId = require(</span><span class="s0">'next/dist/compiled/nanoid'</span><span class="s1">).nanoid();</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
   <span class="s3">* Dynamic parameters. E.g. when you visit `/dashboard/vercel` which is rendered by `/dashboard/[slug]` the value will be {&quot;slug&quot;: &quot;vercel&quot;}.</span>
   <span class="s3">*/ </span><span class="s2">const </span><span class="s1">params = renderOpts.params ?? {};</span>
    <span class="s2">const </span><span class="s1">getDynamicParamFromSegment = makeGetDynamicParamFromSegment(params, pagePath, fallbackRouteParams);</span>
    <span class="s2">const </span><span class="s1">isPossibleActionRequest = (</span><span class="s4">0</span><span class="s1">, _serveractionrequestmeta.getIsPossibleServerAction)(req);</span>
    <span class="s2">const </span><span class="s1">implicitTags = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _implicittags.getImplicitTags)(workStore.page, url, fallbackRouteParams);</span>
    <span class="s2">const </span><span class="s1">ctx = {</span>
        <span class="s1">componentMod: ComponentMod,</span>
        <span class="s1">url,</span>
        <span class="s1">renderOpts,</span>
        <span class="s1">workStore,</span>
        <span class="s1">parsedRequestHeaders,</span>
        <span class="s1">getDynamicParamFromSegment,</span>
        <span class="s1">query,</span>
        <span class="s1">isPrefetch: isPrefetchRequest,</span>
        <span class="s1">isPossibleServerAction: isPossibleActionRequest,</span>
        <span class="s1">requestTimestamp,</span>
        <span class="s1">appUsingSizeAdjustment,</span>
        <span class="s1">flightRouterState,</span>
        <span class="s1">requestId,</span>
        <span class="s1">pagePath,</span>
        <span class="s1">clientReferenceManifest,</span>
        <span class="s1">assetPrefix,</span>
        <span class="s1">isNotFoundPath,</span>
        <span class="s1">nonce,</span>
        <span class="s1">res,</span>
        <span class="s1">sharedContext,</span>
        <span class="s1">implicitTags</span>
    <span class="s1">};</span>
    <span class="s1">(</span><span class="s4">0</span><span class="s1">, _tracer.getTracer)().setRootSpanAttribute(</span><span class="s0">'next.route'</span><span class="s1">, pagePath);</span>
    <span class="s2">if </span><span class="s1">(isStaticGeneration) {</span>
        <span class="s3">// We're either building or revalidating. In either case we need to</span>
        <span class="s3">// prerender our page rather than render it.</span>
        <span class="s2">const </span><span class="s1">prerenderToStreamWithTracing = (</span><span class="s4">0</span><span class="s1">, _tracer.getTracer)().wrap(_constants.AppRenderSpan.getBodyResult, {</span>
            <span class="s1">spanName: </span><span class="s0">`prerender route (app) </span><span class="s1">${pagePath}</span><span class="s0">`</span><span class="s1">,</span>
            <span class="s1">attributes: {</span>
                <span class="s0">'next.route'</span><span class="s1">: pagePath</span>
            <span class="s1">}</span>
        <span class="s1">}, prerenderToStream);</span>
        <span class="s2">const </span><span class="s1">response = </span><span class="s2">await </span><span class="s1">prerenderToStreamWithTracing(req, res, ctx, metadata, loaderTree, fallbackRouteParams);</span>
        <span class="s3">// If we're debugging partial prerendering, print all the dynamic API accesses</span>
        <span class="s3">// that occurred during the render.</span>
        <span class="s3">// @TODO move into renderToStream function</span>
        <span class="s2">if </span><span class="s1">(response.dynamicAccess &amp;&amp; (</span><span class="s4">0</span><span class="s1">, _dynamicrendering.accessedDynamicData)(response.dynamicAccess) &amp;&amp; renderOpts.isDebugDynamicAccesses) {</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _log.warn)(</span><span class="s0">'The following dynamic usage was detected:'</span><span class="s1">);</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">access of (</span><span class="s4">0</span><span class="s1">, _dynamicrendering.formatDynamicAPIAccesses)(response.dynamicAccess)){</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s1">, _log.warn)(access);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">// If we encountered any unexpected errors during build we fail the</span>
        <span class="s3">// prerendering phase and the build.</span>
        <span class="s2">if </span><span class="s1">(workStore.invalidDynamicUsageError) {</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _dynamicrendering.logDisallowedDynamicError)(workStore, workStore.invalidDynamicUsageError);</span>
            <span class="s2">throw new </span><span class="s1">_staticgenerationbailout.StaticGenBailoutError();</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(response.digestErrorsMap.size) {</span>
            <span class="s2">const </span><span class="s1">buildFailingError = response.digestErrorsMap.values().next().value;</span>
            <span class="s2">if </span><span class="s1">(buildFailingError) </span><span class="s2">throw </span><span class="s1">buildFailingError;</span>
        <span class="s1">}</span>
        <span class="s3">// Pick first userland SSR error, which is also not a RSC error.</span>
        <span class="s2">if </span><span class="s1">(response.ssrErrors.length) {</span>
            <span class="s2">const </span><span class="s1">buildFailingError = response.ssrErrors.find((err)=&gt;(</span><span class="s4">0</span><span class="s1">, _createerrorhandler.isUserLandError)(err));</span>
            <span class="s2">if </span><span class="s1">(buildFailingError) </span><span class="s2">throw </span><span class="s1">buildFailingError;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">options = {</span>
            <span class="s1">metadata,</span>
            <span class="s1">contentType: _constants1.HTML_CONTENT_TYPE_HEADER</span>
        <span class="s1">};</span>
        <span class="s3">// If we have pending revalidates, wait until they are all resolved.</span>
        <span class="s2">if </span><span class="s1">(workStore.pendingRevalidates || workStore.pendingRevalidateWrites || workStore.pendingRevalidatedTags) {</span>
            <span class="s2">const </span><span class="s1">pendingPromise = (</span><span class="s4">0</span><span class="s1">, _revalidationutils.executeRevalidates)(workStore).finally(()=&gt;{</span>
                <span class="s2">if </span><span class="s1">(process.env.NEXT_PRIVATE_DEBUG_CACHE) {</span>
                    <span class="s1">console.log(</span><span class="s0">'pending revalidates promise finished for:'</span><span class="s1">, url);</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s2">if </span><span class="s1">(renderOpts.waitUntil) {</span>
                <span class="s1">renderOpts.waitUntil(pendingPromise);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">options.waitUntil = pendingPromise;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">applyMetadataFromPrerenderResult(response, metadata, workStore);</span>
        <span class="s2">if </span><span class="s1">(response.renderResumeDataCache) {</span>
            <span class="s1">metadata.renderResumeDataCache = response.renderResumeDataCache;</span>
        <span class="s1">}</span>
        <span class="s2">return new </span><span class="s1">_renderresult.default(</span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _nodewebstreamshelper.streamToString)(response.stream), options);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s3">// We're rendering dynamically</span>
        <span class="s2">const </span><span class="s1">renderResumeDataCache = renderOpts.renderResumeDataCache ?? (postponedState == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: postponedState.renderResumeDataCache);</span>
        <span class="s2">const </span><span class="s1">rootParams = (</span><span class="s4">0</span><span class="s1">, _createcomponenttree.getRootParams)(loaderTree, ctx.getDynamicParamFromSegment);</span>
        <span class="s2">const </span><span class="s1">devValidatingFallbackParams = (</span><span class="s4">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'devValidatingFallbackParams'</span><span class="s1">) || </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">requestStore = (</span><span class="s4">0</span><span class="s1">, _requeststore.createRequestStoreForRender)(req, res, url, rootParams, implicitTags, renderOpts.onUpdateCookies, renderOpts.previewProps, isHmrRefresh, serverComponentsHmrCache, renderResumeDataCache, devValidatingFallbackParams);</span>
        <span class="s2">if </span><span class="s1">(process.env.NODE_ENV === </span><span class="s0">'development' </span><span class="s1">&amp;&amp; renderOpts.setIsrStatus &amp;&amp; </span><span class="s3">// The type check here ensures that `req` is correctly typed, and the</span>
        <span class="s3">// environment variable check provides dead code elimination.</span>
        <span class="s1">process.env.NEXT_RUNTIME !== </span><span class="s0">'edge' </span><span class="s1">&amp;&amp; (</span><span class="s4">0</span><span class="s1">, _helpers.isNodeNextRequest)(req) &amp;&amp; !isDevWarmupRequest) {</span>
            <span class="s2">const </span><span class="s1">setIsrStatus = renderOpts.setIsrStatus;</span>
            <span class="s1">req.originalRequest.on(</span><span class="s0">'end'</span><span class="s1">, ()=&gt;{</span>
                <span class="s2">if </span><span class="s1">(!requestStore.usedDynamic &amp;&amp; !workStore.forceDynamic) {</span>
                    <span class="s3">// only node can be ISR so we only need to update the status here</span>
                    <span class="s2">const </span><span class="s1">{ pathname } = </span><span class="s2">new </span><span class="s1">URL(req.url || </span><span class="s0">'/'</span><span class="s1">, </span><span class="s0">'http://n'</span><span class="s1">);</span>
                    <span class="s1">setIsrStatus(pathname, </span><span class="s2">true</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isDevWarmupRequest) {</span>
            <span class="s2">return </span><span class="s1">warmupDevRender(req, ctx);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isRSCRequest) {</span>
            <span class="s2">if </span><span class="s1">(isRuntimePrefetchRequest) {</span>
                <span class="s2">return </span><span class="s1">generateRuntimePrefetchResult(req, res, ctx, requestStore);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">return </span><span class="s1">generateDynamicFlightRenderResult(req, ctx, requestStore);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">renderToStreamWithTracing = (</span><span class="s4">0</span><span class="s1">, _tracer.getTracer)().wrap(_constants.AppRenderSpan.getBodyResult, {</span>
            <span class="s1">spanName: </span><span class="s0">`render route (app) </span><span class="s1">${pagePath}</span><span class="s0">`</span><span class="s1">,</span>
            <span class="s1">attributes: {</span>
                <span class="s0">'next.route'</span><span class="s1">: pagePath</span>
            <span class="s1">}</span>
        <span class="s1">}, renderToStream);</span>
        <span class="s2">let </span><span class="s1">formState = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(isPossibleActionRequest) {</span>
            <span class="s3">// For action requests, we handle them differently with a special render result.</span>
            <span class="s2">const </span><span class="s1">actionRequestResult = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _actionhandler.handleAction)({</span>
                <span class="s1">req,</span>
                <span class="s1">res,</span>
                <span class="s1">ComponentMod,</span>
                <span class="s1">serverModuleMap,</span>
                <span class="s1">generateFlight: generateDynamicFlightRenderResult,</span>
                <span class="s1">workStore,</span>
                <span class="s1">requestStore,</span>
                <span class="s1">serverActions,</span>
                <span class="s1">ctx,</span>
                <span class="s1">metadata</span>
            <span class="s1">});</span>
            <span class="s2">if </span><span class="s1">(actionRequestResult) {</span>
                <span class="s2">if </span><span class="s1">(actionRequestResult.type === </span><span class="s0">'not-found'</span><span class="s1">) {</span>
                    <span class="s2">const </span><span class="s1">notFoundLoaderTree = createNotFoundLoaderTree(loaderTree);</span>
                    <span class="s1">res.statusCode = </span><span class="s4">404</span><span class="s1">;</span>
                    <span class="s1">metadata.statusCode = </span><span class="s4">404</span><span class="s1">;</span>
                    <span class="s2">const </span><span class="s1">stream = </span><span class="s2">await </span><span class="s1">renderToStreamWithTracing(requestStore, req, res, ctx, notFoundLoaderTree, formState, postponedState, metadata, devValidatingFallbackParams);</span>
                    <span class="s2">return new </span><span class="s1">_renderresult.default(stream, {</span>
                        <span class="s1">metadata,</span>
                        <span class="s1">contentType: _constants1.HTML_CONTENT_TYPE_HEADER</span>
                    <span class="s1">});</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(actionRequestResult.type === </span><span class="s0">'done'</span><span class="s1">) {</span>
                    <span class="s2">if </span><span class="s1">(actionRequestResult.result) {</span>
                        <span class="s1">actionRequestResult.result.assignMetadata(metadata);</span>
                        <span class="s2">return </span><span class="s1">actionRequestResult.result;</span>
                    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(actionRequestResult.formState) {</span>
                        <span class="s1">formState = actionRequestResult.formState;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">options = {</span>
            <span class="s1">metadata,</span>
            <span class="s1">contentType: _constants1.HTML_CONTENT_TYPE_HEADER</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">stream = </span><span class="s2">await </span><span class="s1">renderToStreamWithTracing(requestStore, req, res, ctx, loaderTree, formState, postponedState, metadata, devValidatingFallbackParams);</span>
        <span class="s3">// Invalid dynamic usages should only error the request in development.</span>
        <span class="s3">// In production, it's better to produce a result.</span>
        <span class="s3">// (the dynamic error will still be thrown inside the component tree, but it's catchable by error boundaries)</span>
        <span class="s2">if </span><span class="s1">(workStore.invalidDynamicUsageError &amp;&amp; workStore.dev) {</span>
            <span class="s2">throw </span><span class="s1">workStore.invalidDynamicUsageError;</span>
        <span class="s1">}</span>
        <span class="s3">// If we have pending revalidates, wait until they are all resolved.</span>
        <span class="s2">if </span><span class="s1">(workStore.pendingRevalidates || workStore.pendingRevalidateWrites || workStore.pendingRevalidatedTags) {</span>
            <span class="s2">const </span><span class="s1">pendingPromise = (</span><span class="s4">0</span><span class="s1">, _revalidationutils.executeRevalidates)(workStore).finally(()=&gt;{</span>
                <span class="s2">if </span><span class="s1">(process.env.NEXT_PRIVATE_DEBUG_CACHE) {</span>
                    <span class="s1">console.log(</span><span class="s0">'pending revalidates promise finished for:'</span><span class="s1">, url);</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s2">if </span><span class="s1">(renderOpts.waitUntil) {</span>
                <span class="s1">renderOpts.waitUntil(pendingPromise);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">options.waitUntil = pendingPromise;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">// Create the new render result for the response.</span>
        <span class="s2">return new </span><span class="s1">_renderresult.default(stream, options);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">renderToHTMLOrFlight = (req, res, pagePath, query, fallbackRouteParams, renderOpts, serverComponentsHmrCache, isDevWarmup, sharedContext)=&gt;{</span>
    <span class="s2">var </span><span class="s1">_renderOpts_previewProps;</span>
    <span class="s2">if </span><span class="s1">(!req.url) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Invalid URL'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E182&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">url = (</span><span class="s4">0</span><span class="s1">, _parserelativeurl.parseRelativeUrl)(req.url, undefined, </span><span class="s2">false</span><span class="s1">);</span>
    <span class="s3">// We read these values from the request object as, in certain cases,</span>
    <span class="s3">// base-server will strip them to opt into different rendering behavior.</span>
    <span class="s2">const </span><span class="s1">parsedRequestHeaders = parseRequestHeaders(req.headers, {</span>
        <span class="s1">isDevWarmup,</span>
        <span class="s1">isRoutePPREnabled: renderOpts.experimental.isRoutePPREnabled === </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">previewModeId: (_renderOpts_previewProps = renderOpts.previewProps) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _renderOpts_previewProps.previewModeId</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">{ isPrefetchRequest, previouslyRevalidatedTags } = parsedRequestHeaders;</span>
    <span class="s2">let </span><span class="s1">postponedState = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s3">// If provided, the postpone state should be parsed so it can be provided to</span>
    <span class="s3">// React.</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">renderOpts.postponed === </span><span class="s0">'string'</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(fallbackRouteParams) {</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">'postponed state should not be provided when fallback params are provided'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E592&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s1">postponedState = (</span><span class="s4">0</span><span class="s1">, _postponedstate.parsePostponedState)(renderOpts.postponed, renderOpts.params);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">((postponedState == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: postponedState.renderResumeDataCache) &amp;&amp; renderOpts.renderResumeDataCache) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">'postponed state and dev warmup immutable resume data cache should not be provided together'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E589&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">workStore = (</span><span class="s4">0</span><span class="s1">, _workstore.createWorkStore)({</span>
        <span class="s1">page: renderOpts.routeModule.definition.page,</span>
        <span class="s1">renderOpts,</span>
        <span class="s3">// @TODO move to workUnitStore of type Request</span>
        <span class="s1">isPrefetchRequest,</span>
        <span class="s1">buildId: sharedContext.buildId,</span>
        <span class="s1">previouslyRevalidatedTags</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">_workasyncstorageexternal.workAsyncStorage.run(workStore, </span><span class="s3">// The function to run</span>
    <span class="s1">renderToHTMLOrFlightImpl, </span><span class="s3">// all of it's args</span>
    <span class="s1">req, res, url, pagePath, query, renderOpts, workStore, parsedRequestHeaders, postponedState, serverComponentsHmrCache, sharedContext, fallbackRouteParams);</span>
<span class="s1">};</span>
<span class="s2">function </span><span class="s1">applyMetadataFromPrerenderResult(response, metadata, workStore) {</span>
    <span class="s2">var </span><span class="s1">_metadata_cacheControl;</span>
    <span class="s2">if </span><span class="s1">(response.collectedTags) {</span>
        <span class="s1">metadata.fetchTags = response.collectedTags.join(</span><span class="s0">','</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">// Let the client router know how long to keep the cached entry around.</span>
    <span class="s2">const </span><span class="s1">staleHeader = String(response.collectedStale);</span>
    <span class="s1">metadata.headers ??= {};</span>
    <span class="s1">metadata.headers[_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER] = staleHeader;</span>
    <span class="s3">// If force static is specifically set to false, we should not revalidate</span>
    <span class="s3">// the page.</span>
    <span class="s2">if </span><span class="s1">(workStore.forceStatic === </span><span class="s2">false </span><span class="s1">|| response.collectedRevalidate === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">metadata.cacheControl = {</span>
            <span class="s1">revalidate: </span><span class="s4">0</span><span class="s1">,</span>
            <span class="s1">expire: undefined</span>
        <span class="s1">};</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s3">// Copy the cache control value onto the render result metadata.</span>
        <span class="s1">metadata.cacheControl = {</span>
            <span class="s1">revalidate: response.collectedRevalidate &gt;= _constants1.INFINITE_CACHE ? </span><span class="s2">false </span><span class="s1">: response.collectedRevalidate,</span>
            <span class="s1">expire: response.collectedExpire &gt;= _constants1.INFINITE_CACHE ? undefined : response.collectedExpire</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s3">// provide bailout info for debugging</span>
    <span class="s2">if </span><span class="s1">(((_metadata_cacheControl = metadata.cacheControl) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _metadata_cacheControl.revalidate) === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">metadata.staticBailoutInfo = {</span>
            <span class="s1">description: workStore.dynamicUsageDescription,</span>
            <span class="s1">stack: workStore.dynamicUsageStack</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">renderToStream(requestStore, req, res, ctx, tree, formState, postponedState, metadata, devValidatingFallbackParams) {</span>
    <span class="s2">const </span><span class="s1">{ assetPrefix, nonce, pagePath, renderOpts } = ctx;</span>
    <span class="s2">const </span><span class="s1">{ basePath, buildManifest, clientReferenceManifest, ComponentMod, crossOrigin, dev = </span><span class="s2">false</span><span class="s1">, experimental, nextExport = </span><span class="s2">false</span><span class="s1">, onInstrumentationRequestError, page, reactMaxHeadersLength, shouldWaitOnAllReady, subresourceIntegrityManifest, supportsDynamicResponse } = renderOpts;</span>
    <span class="s1">assertClientReferenceManifest(clientReferenceManifest);</span>
    <span class="s2">const </span><span class="s1">{ ServerInsertedHTMLProvider, renderServerInsertedHTML } = (</span><span class="s4">0</span><span class="s1">, _serverinsertedhtml.createServerInsertedHTML)();</span>
    <span class="s2">const </span><span class="s1">getServerInsertedMetadata = (</span><span class="s4">0</span><span class="s1">, _createserverinsertedmetadata.createServerInsertedMetadata)(nonce);</span>
    <span class="s2">const </span><span class="s1">tracingMetadata = (</span><span class="s4">0</span><span class="s1">, _utils1.getTracedMetadata)((</span><span class="s4">0</span><span class="s1">, _tracer.getTracer)().getTracePropagationData(), experimental.clientTraceMetadata);</span>
    <span class="s2">const </span><span class="s1">polyfills = buildManifest.polyfillFiles.filter((polyfill)=&gt;polyfill.endsWith(</span><span class="s0">'.js'</span><span class="s1">) &amp;&amp; !polyfill.endsWith(</span><span class="s0">'.module.js'</span><span class="s1">)).map((polyfill)=&gt;({</span>
            <span class="s1">src: </span><span class="s0">`</span><span class="s1">${assetPrefix}</span><span class="s0">/_next/</span><span class="s1">${polyfill}${(</span><span class="s4">0</span><span class="s1">, _getassetquerystring.getAssetQueryString)(ctx, </span><span class="s2">false</span><span class="s1">)}</span><span class="s0">`</span><span class="s1">,</span>
            <span class="s1">integrity: subresourceIntegrityManifest == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: subresourceIntegrityManifest[polyfill],</span>
            <span class="s1">crossOrigin,</span>
            <span class="s1">noModule: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">nonce</span>
        <span class="s1">}));</span>
    <span class="s2">const </span><span class="s1">[preinitScripts, bootstrapScript] = (</span><span class="s4">0</span><span class="s1">, _requiredscripts.getRequiredScripts)(buildManifest, </span><span class="s3">// Why is assetPrefix optional on renderOpts?</span>
    <span class="s3">// @TODO make it default empty string on renderOpts and get rid of it from ctx</span>
    <span class="s1">assetPrefix, crossOrigin, subresourceIntegrityManifest, (</span><span class="s4">0</span><span class="s1">, _getassetquerystring.getAssetQueryString)(ctx, </span><span class="s2">true</span><span class="s1">), nonce, page);</span>
    <span class="s2">const </span><span class="s1">reactServerErrorsByDigest = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s2">const </span><span class="s1">silenceLogger = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">onHTMLRenderRSCError(err) {</span>
        <span class="s2">return </span><span class="s1">onInstrumentationRequestError == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: onInstrumentationRequestError(err, req, createErrorContext(ctx, </span><span class="s0">'react-server-components'</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">serverComponentsErrorHandler = (</span><span class="s4">0</span><span class="s1">, _createerrorhandler.createHTMLReactServerErrorHandler)(dev, nextExport, reactServerErrorsByDigest, silenceLogger, onHTMLRenderRSCError);</span>
    <span class="s2">function </span><span class="s1">onHTMLRenderSSRError(err) {</span>
        <span class="s2">return </span><span class="s1">onInstrumentationRequestError == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: onInstrumentationRequestError(err, req, createErrorContext(ctx, </span><span class="s0">'server-rendering'</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">allCapturedErrors = [];</span>
    <span class="s2">const </span><span class="s1">htmlRendererErrorHandler = (</span><span class="s4">0</span><span class="s1">, _createerrorhandler.createHTMLErrorHandler)(dev, nextExport, reactServerErrorsByDigest, allCapturedErrors, silenceLogger, onHTMLRenderSSRError);</span>
    <span class="s2">let </span><span class="s1">reactServerResult = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">setHeader = res.setHeader.bind(res);</span>
    <span class="s2">const </span><span class="s1">appendHeader = res.appendHeader.bind(res);</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s3">// We only want this behavior when running `next dev`</span>
        <span class="s1">dev &amp;&amp; </span><span class="s3">// We only want this behavior when we have React's dev builds available</span>
        <span class="s1">process.env.NODE_ENV === </span><span class="s0">'development' </span><span class="s1">&amp;&amp; </span><span class="s3">// Edge routes never prerender so we don't have a Prerender environment for anything in edge runtime</span>
        <span class="s1">process.env.NEXT_RUNTIME !== </span><span class="s0">'edge' </span><span class="s1">&amp;&amp; </span><span class="s3">// We only have a Prerender environment for projects opted into cacheComponents</span>
        <span class="s1">experimental.cacheComponents) {</span>
            <span class="s3">// This is a dynamic render. We don't do dynamic tracking because we're not prerendering</span>
            <span class="s2">const </span><span class="s1">RSCPayload = </span><span class="s2">await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(requestStore, getRSCPayload, tree, ctx, res.statusCode === </span><span class="s4">404</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">[resolveValidation, validationOutlet] = createValidationOutlet();</span>
            <span class="s1">RSCPayload._validation = validationOutlet;</span>
            <span class="s2">const </span><span class="s1">reactServerStream = </span><span class="s2">await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(requestStore, _apprenderrenderutils.scheduleInSequentialTasks, ()=&gt;{</span>
                <span class="s1">requestStore.prerenderPhase = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s2">return </span><span class="s1">ComponentMod.renderToReadableStream(RSCPayload, clientReferenceManifest.clientModules, {</span>
                    <span class="s1">onError: serverComponentsErrorHandler,</span>
                    <span class="s1">environmentName: ()=&gt;requestStore.prerenderPhase === </span><span class="s2">true </span><span class="s1">? </span><span class="s0">'Prerender' </span><span class="s1">: </span><span class="s0">'Server'</span><span class="s1">,</span>
                    <span class="s1">filterStackFrame</span>
                <span class="s1">});</span>
            <span class="s1">}, ()=&gt;{</span>
                <span class="s1">requestStore.prerenderPhase = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s1">});</span>
            <span class="s1">spawnDynamicValidationInDev(resolveValidation, tree, ctx, res.statusCode === </span><span class="s4">404</span><span class="s1">, clientReferenceManifest, requestStore, devValidatingFallbackParams);</span>
            <span class="s1">reactServerResult = </span><span class="s2">new </span><span class="s1">_apprenderprerenderutils.ReactServerResult(reactServerStream);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s3">// This is a dynamic render. We don't do dynamic tracking because we're not prerendering</span>
            <span class="s2">const </span><span class="s1">RSCPayload = </span><span class="s2">await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(requestStore, getRSCPayload, tree, ctx, res.statusCode === </span><span class="s4">404</span><span class="s1">);</span>
            <span class="s1">reactServerResult = </span><span class="s2">new </span><span class="s1">_apprenderprerenderutils.ReactServerResult(_workunitasyncstorageexternal.workUnitAsyncStorage.run(requestStore, ComponentMod.renderToReadableStream, RSCPayload, clientReferenceManifest.clientModules, {</span>
                <span class="s1">filterStackFrame,</span>
                <span class="s1">onError: serverComponentsErrorHandler</span>
            <span class="s1">}));</span>
        <span class="s1">}</span>
        <span class="s3">// React doesn't start rendering synchronously but we want the RSC render to have a chance to start</span>
        <span class="s3">// before we begin SSR rendering because we want to capture any available preload headers so we tick</span>
        <span class="s3">// one task before continuing</span>
        <span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _scheduler.waitAtLeastOneReactRenderTask)();</span>
        <span class="s3">// If provided, the postpone state should be parsed as JSON so it can be</span>
        <span class="s3">// provided to React.</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">renderOpts.postponed === </span><span class="s0">'string'</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">((postponedState == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: postponedState.type) === _postponedstate.DynamicState.DATA) {</span>
                <span class="s3">// We have a complete HTML Document in the prerender but we need to</span>
                <span class="s3">// still include the new server component render because it was not included</span>
                <span class="s3">// in the static prelude.</span>
                <span class="s2">const </span><span class="s1">inlinedReactServerDataStream = (</span><span class="s4">0</span><span class="s1">, _useflightresponse.createInlinedDataReadableStream)(reactServerResult.tee(), nonce, formState);</span>
                <span class="s2">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _nodewebstreamshelper.chainStreams)(inlinedReactServerDataStream, (</span><span class="s4">0</span><span class="s1">, _nodewebstreamshelper.createDocumentClosingStream)());</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(postponedState) {</span>
                <span class="s3">// We assume we have dynamic HTML requiring a resume render to complete</span>
                <span class="s2">const </span><span class="s1">{ postponed, preludeState } = (</span><span class="s4">0</span><span class="s1">, _postponedstate.getPostponedFromState)(postponedState);</span>
                <span class="s2">const </span><span class="s1">resume = require(</span><span class="s0">'react-dom/server'</span><span class="s1">).resume;</span>
                <span class="s2">const </span><span class="s1">htmlStream = </span><span class="s2">await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(requestStore, resume, </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(App, {</span>
                    <span class="s1">reactServerStream: reactServerResult.tee(),</span>
                    <span class="s1">preinitScripts: preinitScripts,</span>
                    <span class="s1">clientReferenceManifest: clientReferenceManifest,</span>
                    <span class="s1">ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,</span>
                    <span class="s1">nonce: nonce</span>
                <span class="s1">}), postponed, {</span>
                    <span class="s1">onError: htmlRendererErrorHandler,</span>
                    <span class="s1">nonce</span>
                <span class="s1">});</span>
                <span class="s2">const </span><span class="s1">getServerInsertedHTML = (</span><span class="s4">0</span><span class="s1">, _makegetserverinsertedhtml.makeGetServerInsertedHTML)({</span>
                    <span class="s1">polyfills,</span>
                    <span class="s1">renderServerInsertedHTML,</span>
                    <span class="s1">serverCapturedErrors: allCapturedErrors,</span>
                    <span class="s1">basePath,</span>
                    <span class="s1">tracingMetadata: tracingMetadata</span>
                <span class="s1">});</span>
                <span class="s2">return await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _nodewebstreamshelper.continueDynamicHTMLResume)(htmlStream, {</span>
                    <span class="s3">// If the prelude is empty (i.e. is no static shell), we should wait for initial HTML to be rendered</span>
                    <span class="s3">// to avoid injecting RSC data too early.</span>
                    <span class="s3">// If we have a non-empty-prelude (i.e. a static HTML shell), then it's already been sent separately,</span>
                    <span class="s3">// so we shouldn't wait for any HTML to be emitted from the resume before sending RSC data.</span>
                    <span class="s1">delayDataUntilFirstHtmlChunk: preludeState === _postponedstate.DynamicHTMLPreludeState.Empty,</span>
                    <span class="s1">inlinedDataStream: (</span><span class="s4">0</span><span class="s1">, _useflightresponse.createInlinedDataReadableStream)(reactServerResult.consume(), nonce, formState),</span>
                    <span class="s1">getServerInsertedHTML,</span>
                    <span class="s1">getServerInsertedMetadata</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">// This is a regular dynamic render</span>
        <span class="s2">const </span><span class="s1">renderToReadableStream = require(</span><span class="s0">'react-dom/server'</span><span class="s1">).renderToReadableStream;</span>
        <span class="s2">const </span><span class="s1">htmlStream = </span><span class="s2">await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(requestStore, renderToReadableStream, </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(App, {</span>
            <span class="s1">reactServerStream: reactServerResult.tee(),</span>
            <span class="s1">preinitScripts: preinitScripts,</span>
            <span class="s1">clientReferenceManifest: clientReferenceManifest,</span>
            <span class="s1">ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,</span>
            <span class="s1">nonce: nonce</span>
        <span class="s1">}), {</span>
            <span class="s1">onError: htmlRendererErrorHandler,</span>
            <span class="s1">nonce,</span>
            <span class="s1">onHeaders: (headers)=&gt;{</span>
                <span class="s1">headers.forEach((value, key)=&gt;{</span>
                    <span class="s1">appendHeader(key, value);</span>
                <span class="s1">});</span>
            <span class="s1">},</span>
            <span class="s1">maxHeadersLength: reactMaxHeadersLength,</span>
            <span class="s1">bootstrapScripts: [</span>
                <span class="s1">bootstrapScript</span>
            <span class="s1">],</span>
            <span class="s1">formState</span>
        <span class="s1">});</span>
        <span class="s2">const </span><span class="s1">getServerInsertedHTML = (</span><span class="s4">0</span><span class="s1">, _makegetserverinsertedhtml.makeGetServerInsertedHTML)({</span>
            <span class="s1">polyfills,</span>
            <span class="s1">renderServerInsertedHTML,</span>
            <span class="s1">serverCapturedErrors: allCapturedErrors,</span>
            <span class="s1">basePath,</span>
            <span class="s1">tracingMetadata: tracingMetadata</span>
        <span class="s1">});</span>
        <span class="s3">/**</span>
     <span class="s3">* Rules of Static &amp; Dynamic HTML:</span>
     <span class="s3">*</span>
     <span class="s3">*    1.) We must generate static HTML unless the caller explicitly opts</span>
     <span class="s3">*        in to dynamic HTML support.</span>
     <span class="s3">*</span>
     <span class="s3">*    2.) If dynamic HTML support is requested, we must honor that request</span>
     <span class="s3">*        or throw an error. It is the sole responsibility of the caller to</span>
     <span class="s3">*        ensure they aren't e.g. requesting dynamic HTML for an AMP page.</span>
     <span class="s3">*</span>
     <span class="s3">*   3.) If `shouldWaitOnAllReady` is true, which indicates we need to</span>
     <span class="s3">*       resolve all suspenses and generate a full HTML. e.g. when it's a</span>
     <span class="s3">*       html limited bot requests, we produce the full HTML content.</span>
     <span class="s3">*</span>
     <span class="s3">* These rules help ensure that other existing features like request caching,</span>
     <span class="s3">* coalescing, and ISR continue working as intended.</span>
     <span class="s3">*/ </span><span class="s2">const </span><span class="s1">generateStaticHTML = supportsDynamicResponse !== </span><span class="s2">true </span><span class="s1">|| !!shouldWaitOnAllReady;</span>
        <span class="s2">return await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _nodewebstreamshelper.continueFizzStream)(htmlStream, {</span>
            <span class="s1">inlinedDataStream: (</span><span class="s4">0</span><span class="s1">, _useflightresponse.createInlinedDataReadableStream)(reactServerResult.consume(), nonce, formState),</span>
            <span class="s1">isStaticGeneration: generateStaticHTML,</span>
            <span class="s1">isBuildTimePrerendering: ctx.workStore.isBuildTimePrerendering === </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">buildId: ctx.workStore.buildId,</span>
            <span class="s1">getServerInsertedHTML,</span>
            <span class="s1">getServerInsertedMetadata,</span>
            <span class="s1">validateRootLayout: dev</span>
        <span class="s1">});</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _staticgenerationbailout.isStaticGenBailoutError)(err) || </span><span class="s2">typeof </span><span class="s1">err === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; err !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s0">'message' </span><span class="s2">in </span><span class="s1">err &amp;&amp; </span><span class="s2">typeof </span><span class="s1">err.message === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; err.message.includes(</span><span class="s0">'https://nextjs.org/docs/advanced-features/static-html-export'</span><span class="s1">)) {</span>
            <span class="s3">// Ensure that &quot;next dev&quot; prints the red error overlay</span>
            <span class="s2">throw </span><span class="s1">err;</span>
        <span class="s1">}</span>
        <span class="s3">// If a bailout made it to this point, it means it wasn't wrapped inside</span>
        <span class="s3">// a suspense boundary.</span>
        <span class="s2">const </span><span class="s1">shouldBailoutToCSR = (</span><span class="s4">0</span><span class="s1">, _bailouttocsr.isBailoutToCSRError)(err);</span>
        <span class="s2">if </span><span class="s1">(shouldBailoutToCSR) {</span>
            <span class="s2">const </span><span class="s1">stack = (</span><span class="s4">0</span><span class="s1">, _formatservererror.getStackWithoutErrorMessage)(err);</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _log.error)(</span><span class="s0">`</span><span class="s1">${err.reason} </span><span class="s0">should be wrapped in a suspense boundary at page &quot;</span><span class="s1">${pagePath}</span><span class="s0">&quot;. Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout</span><span class="s5">\n</span><span class="s1">${stack}</span><span class="s0">`</span><span class="s1">);</span>
            <span class="s2">throw </span><span class="s1">err;</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">errorType;</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _httpaccessfallback.isHTTPAccessFallbackError)(err)) {</span>
            <span class="s1">res.statusCode = (</span><span class="s4">0</span><span class="s1">, _httpaccessfallback.getAccessFallbackHTTPStatus)(err);</span>
            <span class="s1">metadata.statusCode = res.statusCode;</span>
            <span class="s1">errorType = (</span><span class="s4">0</span><span class="s1">, _httpaccessfallback.getAccessFallbackErrorTypeByStatus)(res.statusCode);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _redirecterror.isRedirectError)(err)) {</span>
            <span class="s1">errorType = </span><span class="s0">'redirect'</span><span class="s1">;</span>
            <span class="s1">res.statusCode = (</span><span class="s4">0</span><span class="s1">, _redirect.getRedirectStatusCodeFromError)(err);</span>
            <span class="s1">metadata.statusCode = res.statusCode;</span>
            <span class="s2">const </span><span class="s1">redirectUrl = (</span><span class="s4">0</span><span class="s1">, _addpathprefix.addPathPrefix)((</span><span class="s4">0</span><span class="s1">, _redirect.getURLFromRedirectError)(err), basePath);</span>
            <span class="s3">// If there were mutable cookies set, we need to set them on the</span>
            <span class="s3">// response.</span>
            <span class="s2">const </span><span class="s1">headers = </span><span class="s2">new </span><span class="s1">Headers();</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _requestcookies.appendMutableCookies)(headers, requestStore.mutableCookies)) {</span>
                <span class="s1">setHeader(</span><span class="s0">'set-cookie'</span><span class="s1">, Array.from(headers.values()));</span>
            <span class="s1">}</span>
            <span class="s1">setHeader(</span><span class="s0">'location'</span><span class="s1">, redirectUrl);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!shouldBailoutToCSR) {</span>
            <span class="s1">res.statusCode = </span><span class="s4">500</span><span class="s1">;</span>
            <span class="s1">metadata.statusCode = res.statusCode;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">[errorPreinitScripts, errorBootstrapScript] = (</span><span class="s4">0</span><span class="s1">, _requiredscripts.getRequiredScripts)(buildManifest, assetPrefix, crossOrigin, subresourceIntegrityManifest, (</span><span class="s4">0</span><span class="s1">, _getassetquerystring.getAssetQueryString)(ctx, </span><span class="s2">false</span><span class="s1">), nonce, </span><span class="s0">'/_not-found/page'</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">errorRSCPayload = </span><span class="s2">await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(requestStore, getErrorRSCPayload, tree, ctx, reactServerErrorsByDigest.has(err.digest) ? </span><span class="s2">null </span><span class="s1">: err, errorType);</span>
        <span class="s2">const </span><span class="s1">errorServerStream = _workunitasyncstorageexternal.workUnitAsyncStorage.run(requestStore, ComponentMod.renderToReadableStream, errorRSCPayload, clientReferenceManifest.clientModules, {</span>
            <span class="s1">filterStackFrame,</span>
            <span class="s1">onError: serverComponentsErrorHandler</span>
        <span class="s1">});</span>
        <span class="s2">if </span><span class="s1">(reactServerResult === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s3">// We errored when we did not have an RSC stream to read from. This is not just a render</span>
            <span class="s3">// error, we need to throw early</span>
            <span class="s2">throw </span><span class="s1">err;</span>
        <span class="s1">}</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">fizzStream = </span><span class="s2">await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(requestStore, _nodewebstreamshelper.renderToInitialFizzStream, {</span>
                <span class="s1">ReactDOMServer: require(</span><span class="s0">'react-dom/server'</span><span class="s1">),</span>
                <span class="s1">element: </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(ErrorApp, {</span>
                    <span class="s1">reactServerStream: errorServerStream,</span>
                    <span class="s1">ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,</span>
                    <span class="s1">preinitScripts: errorPreinitScripts,</span>
                    <span class="s1">clientReferenceManifest: clientReferenceManifest,</span>
                    <span class="s1">nonce: nonce</span>
                <span class="s1">}),</span>
                <span class="s1">streamOptions: {</span>
                    <span class="s1">nonce,</span>
                    <span class="s3">// Include hydration scripts in the HTML</span>
                    <span class="s1">bootstrapScripts: [</span>
                        <span class="s1">errorBootstrapScript</span>
                    <span class="s1">],</span>
                    <span class="s1">formState</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s3">/**</span>
       <span class="s3">* Rules of Static &amp; Dynamic HTML:</span>
       <span class="s3">*</span>
       <span class="s3">*    1.) We must generate static HTML unless the caller explicitly opts</span>
       <span class="s3">*        in to dynamic HTML support.</span>
       <span class="s3">*</span>
       <span class="s3">*    2.) If dynamic HTML support is requested, we must honor that request</span>
       <span class="s3">*        or throw an error. It is the sole responsibility of the caller to</span>
       <span class="s3">*        ensure they aren't e.g. requesting dynamic HTML for an AMP page.</span>
       <span class="s3">*    3.) If `shouldWaitOnAllReady` is true, which indicates we need to</span>
       <span class="s3">*        resolve all suspenses and generate a full HTML. e.g. when it's a</span>
       <span class="s3">*        html limited bot requests, we produce the full HTML content.</span>
       <span class="s3">*</span>
       <span class="s3">* These rules help ensure that other existing features like request caching,</span>
       <span class="s3">* coalescing, and ISR continue working as intended.</span>
       <span class="s3">*/ </span><span class="s2">const </span><span class="s1">generateStaticHTML = supportsDynamicResponse !== </span><span class="s2">true </span><span class="s1">|| !!shouldWaitOnAllReady;</span>
            <span class="s2">return await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _nodewebstreamshelper.continueFizzStream)(fizzStream, {</span>
                <span class="s1">inlinedDataStream: (</span><span class="s4">0</span><span class="s1">, _useflightresponse.createInlinedDataReadableStream)(</span><span class="s3">// This is intentionally using the readable datastream from the</span>
                <span class="s3">// main render rather than the flight data from the error page</span>
                <span class="s3">// render</span>
                <span class="s1">reactServerResult.consume(), nonce, formState),</span>
                <span class="s1">isStaticGeneration: generateStaticHTML,</span>
                <span class="s1">isBuildTimePrerendering: ctx.workStore.isBuildTimePrerendering === </span><span class="s2">true</span><span class="s1">,</span>
                <span class="s1">buildId: ctx.workStore.buildId,</span>
                <span class="s1">getServerInsertedHTML: (</span><span class="s4">0</span><span class="s1">, _makegetserverinsertedhtml.makeGetServerInsertedHTML)({</span>
                    <span class="s1">polyfills,</span>
                    <span class="s1">renderServerInsertedHTML,</span>
                    <span class="s1">serverCapturedErrors: [],</span>
                    <span class="s1">basePath,</span>
                    <span class="s1">tracingMetadata: tracingMetadata</span>
                <span class="s1">}),</span>
                <span class="s1">getServerInsertedMetadata,</span>
                <span class="s1">validateRootLayout: dev</span>
            <span class="s1">});</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(finalErr) {</span>
            <span class="s2">if </span><span class="s1">(process.env.NODE_ENV === </span><span class="s0">'development' </span><span class="s1">&amp;&amp; (</span><span class="s4">0</span><span class="s1">, _httpaccessfallback.isHTTPAccessFallbackError)(finalErr)) {</span>
                <span class="s2">const </span><span class="s1">{ bailOnRootNotFound } = require(</span><span class="s0">'../../client/components/dev-root-http-access-fallback-boundary'</span><span class="s1">);</span>
                <span class="s1">bailOnRootNotFound();</span>
            <span class="s1">}</span>
            <span class="s2">throw </span><span class="s1">finalErr;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createValidationOutlet() {</span>
    <span class="s2">let </span><span class="s1">resolveValidation;</span>
    <span class="s2">let </span><span class="s1">outlet = </span><span class="s2">new </span><span class="s1">Promise((resolve)=&gt;{</span>
        <span class="s1">resolveValidation = resolve;</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">[</span>
        <span class="s1">resolveValidation,</span>
        <span class="s1">outlet</span>
    <span class="s1">];</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* This function is a fork of prerenderToStream cacheComponents branch.</span>
 <span class="s3">* While it doesn't return a stream we want it to have identical</span>
 <span class="s3">* prerender semantics to prerenderToStream and should update it</span>
 <span class="s3">* in conjunction with any changes to that function.</span>
 <span class="s3">*/ </span><span class="s1">async </span><span class="s2">function </span><span class="s1">spawnDynamicValidationInDev(resolveValidation, tree, ctx, isNotFound, clientReferenceManifest, requestStore, fallbackRouteParams) {</span>
    <span class="s2">var </span><span class="s1">_requestStore_cookies_get;</span>
    <span class="s2">const </span><span class="s1">{ componentMod: ComponentMod, getDynamicParamFromSegment, implicitTags, nonce, renderOpts, workStore } = ctx;</span>
    <span class="s2">const </span><span class="s1">{ allowEmptyStaticShell = </span><span class="s2">false </span><span class="s1">} = renderOpts;</span>
    <span class="s3">// These values are placeholder values for this validating render</span>
    <span class="s3">// that are provided during the actual prerenderToStream.</span>
    <span class="s2">const </span><span class="s1">preinitScripts = ()=&gt;{};</span>
    <span class="s2">const </span><span class="s1">{ ServerInsertedHTMLProvider } = (</span><span class="s4">0</span><span class="s1">, _serverinsertedhtml.createServerInsertedHTML)();</span>
    <span class="s2">const </span><span class="s1">rootParams = (</span><span class="s4">0</span><span class="s1">, _createcomponenttree.getRootParams)(ComponentMod.tree, getDynamicParamFromSegment);</span>
    <span class="s2">const </span><span class="s1">hmrRefreshHash = (_requestStore_cookies_get = requestStore.cookies.get(_approuterheaders.NEXT_HMR_REFRESH_HASH_COOKIE)) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _requestStore_cookies_get.value;</span>
    <span class="s3">// The prerender controller represents the lifetime of the prerender. It will</span>
    <span class="s3">// be aborted when a task is complete or a synchronously aborting API is</span>
    <span class="s3">// called. Notably, during prospective prerenders, this does not actually</span>
    <span class="s3">// terminate the prerender itself, which will continue until all caches are</span>
    <span class="s3">// filled.</span>
    <span class="s2">const </span><span class="s1">initialServerPrerenderController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
    <span class="s3">// This controller is used to abort the React prerender.</span>
    <span class="s2">const </span><span class="s1">initialServerReactController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
    <span class="s3">// This controller represents the lifetime of the React prerender. Its signal</span>
    <span class="s3">// can be used for any I/O operation to abort the I/O and/or to reject, when</span>
    <span class="s3">// prerendering aborts. This includes our own hanging promises for accessing</span>
    <span class="s3">// request data, and for fetch calls. It might be replaced in the future by</span>
    <span class="s3">// React.cacheSignal(). It's aborted after the React controller, so that no</span>
    <span class="s3">// pending I/O can register abort listeners that are called before React's</span>
    <span class="s3">// abort listener is called. This ensures that pending I/O is not rejected too</span>
    <span class="s3">// early when aborting the prerender. Notably, during the prospective</span>
    <span class="s3">// prerender, it is different from the prerender controller because we don't</span>
    <span class="s3">// want to end the React prerender until all caches are filled.</span>
    <span class="s2">const </span><span class="s1">initialServerRenderController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
    <span class="s3">// The cacheSignal helps us track whether caches are still filling or we are</span>
    <span class="s3">// ready to cut the render off.</span>
    <span class="s2">const </span><span class="s1">cacheSignal = </span><span class="s2">new </span><span class="s1">_cachesignal.CacheSignal();</span>
    <span class="s2">const </span><span class="s1">captureOwnerStackClient = _react.default.captureOwnerStack;</span>
    <span class="s2">const </span><span class="s1">captureOwnerStackServer = ComponentMod.captureOwnerStack;</span>
    <span class="s3">// The resume data cache here should use a fresh instance as it's</span>
    <span class="s3">// performing a fresh prerender. If we get to implementing the</span>
    <span class="s3">// prerendering of an already prerendered page, we should use the passed</span>
    <span class="s3">// resume data cache instead.</span>
    <span class="s2">const </span><span class="s1">prerenderResumeDataCache = (</span><span class="s4">0</span><span class="s1">, _resumedatacache.createPrerenderResumeDataCache)();</span>
    <span class="s2">const </span><span class="s1">initialServerPayloadPrerenderStore = {</span>
        <span class="s1">type: </span><span class="s0">'prerender'</span><span class="s1">,</span>
        <span class="s1">phase: </span><span class="s0">'render'</span><span class="s1">,</span>
        <span class="s1">rootParams,</span>
        <span class="s1">fallbackRouteParams,</span>
        <span class="s1">implicitTags,</span>
        <span class="s3">// While this render signal isn't going to be used to abort a React render while getting the RSC payload</span>
        <span class="s3">// various request data APIs bind to this controller to reject after completion.</span>
        <span class="s1">renderSignal: initialServerRenderController.signal,</span>
        <span class="s3">// When we generate the RSC payload we might abort this controller due to sync IO</span>
        <span class="s3">// but we don't actually care about sync IO in this phase so we use a throw away controller</span>
        <span class="s3">// that isn't connected to anything</span>
        <span class="s1">controller: </span><span class="s2">new </span><span class="s1">AbortController(),</span>
        <span class="s3">// During the initial prerender we need to track all cache reads to ensure</span>
        <span class="s3">// we render long enough to fill every cache it is possible to visit during</span>
        <span class="s3">// the final prerender.</span>
        <span class="s1">cacheSignal,</span>
        <span class="s1">dynamicTracking: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">allowEmptyStaticShell,</span>
        <span class="s1">revalidate: _constants1.INFINITE_CACHE,</span>
        <span class="s1">expire: _constants1.INFINITE_CACHE,</span>
        <span class="s1">stale: _constants1.INFINITE_CACHE,</span>
        <span class="s1">tags: [</span>
            <span class="s1">...implicitTags.tags</span>
        <span class="s1">],</span>
        <span class="s1">prerenderResumeDataCache,</span>
        <span class="s1">renderResumeDataCache: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">hmrRefreshHash,</span>
        <span class="s1">captureOwnerStack: captureOwnerStackServer</span>
    <span class="s1">};</span>
    <span class="s3">// We're not going to use the result of this render because the only time it could be used</span>
    <span class="s3">// is if it completes in a microtask and that's likely very rare for any non-trivial app</span>
    <span class="s2">const </span><span class="s1">initialServerPayload = </span><span class="s2">await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(initialServerPayloadPrerenderStore, getRSCPayload, tree, ctx, isNotFound);</span>
    <span class="s2">const </span><span class="s1">initialServerPrerenderStore = {</span>
        <span class="s1">type: </span><span class="s0">'prerender'</span><span class="s1">,</span>
        <span class="s1">phase: </span><span class="s0">'render'</span><span class="s1">,</span>
        <span class="s1">rootParams,</span>
        <span class="s1">fallbackRouteParams,</span>
        <span class="s1">implicitTags,</span>
        <span class="s1">renderSignal: initialServerRenderController.signal,</span>
        <span class="s1">controller: initialServerPrerenderController,</span>
        <span class="s3">// During the initial prerender we need to track all cache reads to ensure</span>
        <span class="s3">// we render long enough to fill every cache it is possible to visit during</span>
        <span class="s3">// the final prerender.</span>
        <span class="s1">cacheSignal,</span>
        <span class="s1">dynamicTracking: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">allowEmptyStaticShell,</span>
        <span class="s1">revalidate: _constants1.INFINITE_CACHE,</span>
        <span class="s1">expire: _constants1.INFINITE_CACHE,</span>
        <span class="s1">stale: _constants1.INFINITE_CACHE,</span>
        <span class="s1">tags: [</span>
            <span class="s1">...implicitTags.tags</span>
        <span class="s1">],</span>
        <span class="s1">prerenderResumeDataCache,</span>
        <span class="s1">renderResumeDataCache: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">hmrRefreshHash,</span>
        <span class="s1">captureOwnerStack: captureOwnerStackServer</span>
    <span class="s1">};</span>
    <span class="s2">const </span><span class="s1">pendingInitialServerResult = _workunitasyncstorageexternal.workUnitAsyncStorage.run(initialServerPrerenderStore, ComponentMod.prerender, initialServerPayload, clientReferenceManifest.clientModules, {</span>
        <span class="s1">filterStackFrame,</span>
        <span class="s1">onError: (err)=&gt;{</span>
            <span class="s2">const </span><span class="s1">digest = (</span><span class="s4">0</span><span class="s1">, _createerrorhandler.getDigestForWellKnownError)(err);</span>
            <span class="s2">if </span><span class="s1">(digest) {</span>
                <span class="s2">return </span><span class="s1">digest;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _reactlargeshellerror.isReactLargeShellError)(err)) {</span>
                <span class="s3">// TODO: Aggregate</span>
                <span class="s1">console.error(err);</span>
                <span class="s2">return </span><span class="s1">undefined;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(initialServerPrerenderController.signal.aborted) {</span>
                <span class="s3">// The render aborted before this error was handled which indicates</span>
                <span class="s3">// the error is caused by unfinished components within the render</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s1">, _prospectiverenderutils.printDebugThrownValueForProspectiveRender)(err, workStore.route);</span>
            <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s3">// we don't care to track postpones during the prospective render because we need</span>
        <span class="s3">// to always do a final render anyway</span>
        <span class="s1">onPostpone: undefined,</span>
        <span class="s3">// We don't want to stop rendering until the cacheSignal is complete so we pass</span>
        <span class="s3">// a different signal to this render call than is used by dynamic APIs to signify</span>
        <span class="s3">// transitioning out of the prerender environment</span>
        <span class="s1">signal: initialServerReactController.signal</span>
    <span class="s1">});</span>
    <span class="s3">// The listener to abort our own render controller must be added after React</span>
    <span class="s3">// has added its listener, to ensure that pending I/O is not aborted/rejected</span>
    <span class="s3">// too early.</span>
    <span class="s1">initialServerReactController.signal.addEventListener(</span><span class="s0">'abort'</span><span class="s1">, ()=&gt;{</span>
        <span class="s1">initialServerRenderController.abort();</span>
    <span class="s1">}, {</span>
        <span class="s1">once: </span><span class="s2">true</span>
    <span class="s1">});</span>
    <span class="s3">// Wait for all caches to be finished filling and for async imports to resolve</span>
    <span class="s1">(</span><span class="s4">0</span><span class="s1">, _trackmoduleloadingexternal.trackPendingModules)(cacheSignal);</span>
    <span class="s2">await </span><span class="s1">cacheSignal.cacheReady();</span>
    <span class="s1">initialServerReactController.abort();</span>
    <span class="s3">// We don't need to continue the prerender process if we already</span>
    <span class="s3">// detected invalid dynamic usage in the initial prerender phase.</span>
    <span class="s2">const </span><span class="s1">{ invalidDynamicUsageError } = workStore;</span>
    <span class="s2">if </span><span class="s1">(invalidDynamicUsageError) {</span>
        <span class="s1">resolveValidation(</span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(LogSafely, {</span>
            <span class="s1">fn: ()=&gt;{</span>
                <span class="s1">console.error(invalidDynamicUsageError);</span>
            <span class="s1">}</span>
        <span class="s1">}));</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">initialServerResult;</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">initialServerResult = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _apprenderprerenderutils.createReactServerPrerenderResult)(pendingInitialServerResult);</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
        <span class="s2">if </span><span class="s1">(initialServerReactController.signal.aborted || initialServerPrerenderController.signal.aborted) {</span>
        <span class="s3">// These are expected errors that might error the prerender. we ignore them.</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {</span>
            <span class="s3">// We don't normally log these errors because we are going to retry anyway but</span>
            <span class="s3">// it can be useful for debugging Next.js itself to get visibility here when needed</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _prospectiverenderutils.printDebugThrownValueForProspectiveRender)(err, workStore.route);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(initialServerResult) {</span>
        <span class="s2">const </span><span class="s1">initialClientPrerenderController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
        <span class="s2">const </span><span class="s1">initialClientReactController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
        <span class="s2">const </span><span class="s1">initialClientRenderController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
        <span class="s2">const </span><span class="s1">initialClientPrerenderStore = {</span>
            <span class="s1">type: </span><span class="s0">'prerender-client'</span><span class="s1">,</span>
            <span class="s1">phase: </span><span class="s0">'render'</span><span class="s1">,</span>
            <span class="s1">rootParams,</span>
            <span class="s1">fallbackRouteParams,</span>
            <span class="s1">implicitTags,</span>
            <span class="s1">renderSignal: initialClientRenderController.signal,</span>
            <span class="s1">controller: initialClientPrerenderController,</span>
            <span class="s3">// For HTML Generation the only cache tracked activity</span>
            <span class="s3">// is module loading, which has it's own cache signal</span>
            <span class="s1">cacheSignal: </span><span class="s2">null</span><span class="s1">,</span>
            <span class="s1">dynamicTracking: </span><span class="s2">null</span><span class="s1">,</span>
            <span class="s1">allowEmptyStaticShell,</span>
            <span class="s1">revalidate: _constants1.INFINITE_CACHE,</span>
            <span class="s1">expire: _constants1.INFINITE_CACHE,</span>
            <span class="s1">stale: _constants1.INFINITE_CACHE,</span>
            <span class="s1">tags: [</span>
                <span class="s1">...implicitTags.tags</span>
            <span class="s1">],</span>
            <span class="s1">prerenderResumeDataCache,</span>
            <span class="s1">renderResumeDataCache: </span><span class="s2">null</span><span class="s1">,</span>
            <span class="s1">hmrRefreshHash: undefined,</span>
            <span class="s1">captureOwnerStack: captureOwnerStackClient</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">prerender = require(</span><span class="s0">'react-dom/static'</span><span class="s1">).prerender;</span>
        <span class="s2">const </span><span class="s1">pendingInitialClientResult = _workunitasyncstorageexternal.workUnitAsyncStorage.run(initialClientPrerenderStore, prerender, </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(App, {</span>
            <span class="s1">reactServerStream: initialServerResult.asUnclosingStream(),</span>
            <span class="s1">preinitScripts: preinitScripts,</span>
            <span class="s1">clientReferenceManifest: clientReferenceManifest,</span>
            <span class="s1">ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,</span>
            <span class="s1">nonce: nonce</span>
        <span class="s1">}), {</span>
            <span class="s1">signal: initialClientReactController.signal,</span>
            <span class="s1">onError: (err)=&gt;{</span>
                <span class="s2">const </span><span class="s1">digest = (</span><span class="s4">0</span><span class="s1">, _createerrorhandler.getDigestForWellKnownError)(err);</span>
                <span class="s2">if </span><span class="s1">(digest) {</span>
                    <span class="s2">return </span><span class="s1">digest;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _reactlargeshellerror.isReactLargeShellError)(err)) {</span>
                    <span class="s3">// TODO: Aggregate</span>
                    <span class="s1">console.error(err);</span>
                    <span class="s2">return </span><span class="s1">undefined;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(initialClientReactController.signal.aborted) {</span>
                <span class="s3">// These are expected errors that might error the prerender. we ignore them.</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {</span>
                    <span class="s3">// We don't normally log these errors because we are going to retry anyway but</span>
                    <span class="s3">// it can be useful for debugging Next.js itself to get visibility here when needed</span>
                    <span class="s1">(</span><span class="s4">0</span><span class="s1">, _prospectiverenderutils.printDebugThrownValueForProspectiveRender)(err, workStore.route);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s3">// The listener to abort our own render controller must be added after React</span>
        <span class="s3">// has added its listener, to ensure that pending I/O is not</span>
        <span class="s3">// aborted/rejected too early.</span>
        <span class="s1">initialClientReactController.signal.addEventListener(</span><span class="s0">'abort'</span><span class="s1">, ()=&gt;{</span>
            <span class="s1">initialClientRenderController.abort();</span>
        <span class="s1">}, {</span>
            <span class="s1">once: </span><span class="s2">true</span>
        <span class="s1">});</span>
        <span class="s1">pendingInitialClientResult.catch((err)=&gt;{</span>
            <span class="s2">if </span><span class="s1">(initialClientReactController.signal.aborted || (</span><span class="s4">0</span><span class="s1">, _dynamicrendering.isPrerenderInterruptedError)(err)) {</span>
            <span class="s3">// These are expected errors that might error the prerender. we ignore them.</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {</span>
                <span class="s3">// We don't normally log these errors because we are going to retry anyway but</span>
                <span class="s3">// it can be useful for debugging Next.js itself to get visibility here when needed</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s1">, _prospectiverenderutils.printDebugThrownValueForProspectiveRender)(err, workStore.route);</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s3">// This is mostly needed for dynamic `import()`s in client components.</span>
        <span class="s3">// Promises passed to client were already awaited above (assuming that they came from cached functions)</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _trackmoduleloadingexternal.trackPendingModules)(cacheSignal);</span>
        <span class="s2">await </span><span class="s1">cacheSignal.cacheReady();</span>
        <span class="s1">initialClientReactController.abort();</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">finalServerReactController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
    <span class="s2">const </span><span class="s1">finalServerRenderController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
    <span class="s2">const </span><span class="s1">finalServerPayloadPrerenderStore = {</span>
        <span class="s1">type: </span><span class="s0">'prerender'</span><span class="s1">,</span>
        <span class="s1">phase: </span><span class="s0">'render'</span><span class="s1">,</span>
        <span class="s1">rootParams,</span>
        <span class="s1">fallbackRouteParams,</span>
        <span class="s1">implicitTags,</span>
        <span class="s3">// While this render signal isn't going to be used to abort a React render while getting the RSC payload</span>
        <span class="s3">// various request data APIs bind to this controller to reject after completion.</span>
        <span class="s1">renderSignal: finalServerRenderController.signal,</span>
        <span class="s3">// When we generate the RSC payload we might abort this controller due to sync IO</span>
        <span class="s3">// but we don't actually care about sync IO in this phase so we use a throw away controller</span>
        <span class="s3">// that isn't connected to anything</span>
        <span class="s1">controller: </span><span class="s2">new </span><span class="s1">AbortController(),</span>
        <span class="s3">// All caches we could read must already be filled so no tracking is necessary</span>
        <span class="s1">cacheSignal: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">dynamicTracking: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">allowEmptyStaticShell,</span>
        <span class="s1">revalidate: _constants1.INFINITE_CACHE,</span>
        <span class="s1">expire: _constants1.INFINITE_CACHE,</span>
        <span class="s1">stale: _constants1.INFINITE_CACHE,</span>
        <span class="s1">tags: [</span>
            <span class="s1">...implicitTags.tags</span>
        <span class="s1">],</span>
        <span class="s1">prerenderResumeDataCache,</span>
        <span class="s1">renderResumeDataCache: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">hmrRefreshHash,</span>
        <span class="s1">captureOwnerStack: captureOwnerStackServer</span>
    <span class="s1">};</span>
    <span class="s2">const </span><span class="s1">finalAttemptRSCPayload = </span><span class="s2">await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(finalServerPayloadPrerenderStore, getRSCPayload, tree, ctx, isNotFound);</span>
    <span class="s2">const </span><span class="s1">serverDynamicTracking = (</span><span class="s4">0</span><span class="s1">, _dynamicrendering.createDynamicTrackingState)(</span><span class="s2">false </span><span class="s3">// isDebugDynamicAccesses</span>
    <span class="s1">);</span>
    <span class="s2">const </span><span class="s1">finalServerPrerenderStore = {</span>
        <span class="s1">type: </span><span class="s0">'prerender'</span><span class="s1">,</span>
        <span class="s1">phase: </span><span class="s0">'render'</span><span class="s1">,</span>
        <span class="s1">rootParams,</span>
        <span class="s1">fallbackRouteParams,</span>
        <span class="s1">implicitTags,</span>
        <span class="s1">renderSignal: finalServerRenderController.signal,</span>
        <span class="s1">controller: finalServerReactController,</span>
        <span class="s3">// All caches we could read must already be filled so no tracking is necessary</span>
        <span class="s1">cacheSignal: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">dynamicTracking: serverDynamicTracking,</span>
        <span class="s1">allowEmptyStaticShell,</span>
        <span class="s1">revalidate: _constants1.INFINITE_CACHE,</span>
        <span class="s1">expire: _constants1.INFINITE_CACHE,</span>
        <span class="s1">stale: _constants1.INFINITE_CACHE,</span>
        <span class="s1">tags: [</span>
            <span class="s1">...implicitTags.tags</span>
        <span class="s1">],</span>
        <span class="s1">prerenderResumeDataCache,</span>
        <span class="s1">renderResumeDataCache: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">hmrRefreshHash,</span>
        <span class="s1">captureOwnerStack: captureOwnerStackServer</span>
    <span class="s1">};</span>
    <span class="s2">const </span><span class="s1">reactServerResult = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _apprenderprerenderutils.createReactServerPrerenderResult)((</span><span class="s4">0</span><span class="s1">, _apprenderprerenderutils.prerenderAndAbortInSequentialTasks)(async ()=&gt;{</span>
        <span class="s2">const </span><span class="s1">pendingPrerenderResult = _workunitasyncstorageexternal.workUnitAsyncStorage.run(</span><span class="s3">// The store to scope</span>
        <span class="s1">finalServerPrerenderStore, </span><span class="s3">// The function to run</span>
        <span class="s1">ComponentMod.prerender, </span><span class="s3">// ... the arguments for the function to run</span>
        <span class="s1">finalAttemptRSCPayload, clientReferenceManifest.clientModules, {</span>
            <span class="s1">filterStackFrame,</span>
            <span class="s1">onError: (err)=&gt;{</span>
                <span class="s2">if </span><span class="s1">(finalServerReactController.signal.aborted &amp;&amp; (</span><span class="s4">0</span><span class="s1">, _dynamicrendering.isPrerenderInterruptedError)(err)) {</span>
                    <span class="s2">return </span><span class="s1">err.digest;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _reactlargeshellerror.isReactLargeShellError)(err)) {</span>
                    <span class="s3">// TODO: Aggregate</span>
                    <span class="s1">console.error(err);</span>
                    <span class="s2">return </span><span class="s1">undefined;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _createerrorhandler.getDigestForWellKnownError)(err);</span>
            <span class="s1">},</span>
            <span class="s1">signal: finalServerReactController.signal</span>
        <span class="s1">});</span>
        <span class="s3">// The listener to abort our own render controller must be added after</span>
        <span class="s3">// React has added its listener, to ensure that pending I/O is not</span>
        <span class="s3">// aborted/rejected too early.</span>
        <span class="s1">finalServerReactController.signal.addEventListener(</span><span class="s0">'abort'</span><span class="s1">, ()=&gt;{</span>
            <span class="s1">finalServerRenderController.abort();</span>
        <span class="s1">}, {</span>
            <span class="s1">once: </span><span class="s2">true</span>
        <span class="s1">});</span>
        <span class="s2">return </span><span class="s1">pendingPrerenderResult;</span>
    <span class="s1">}, ()=&gt;{</span>
        <span class="s1">finalServerReactController.abort();</span>
    <span class="s1">}));</span>
    <span class="s2">const </span><span class="s1">clientDynamicTracking = (</span><span class="s4">0</span><span class="s1">, _dynamicrendering.createDynamicTrackingState)(</span><span class="s2">false </span><span class="s3">//isDebugDynamicAccesses</span>
    <span class="s1">);</span>
    <span class="s2">const </span><span class="s1">finalClientReactController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
    <span class="s2">const </span><span class="s1">finalClientRenderController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
    <span class="s2">const </span><span class="s1">finalClientPrerenderStore = {</span>
        <span class="s1">type: </span><span class="s0">'prerender-client'</span><span class="s1">,</span>
        <span class="s1">phase: </span><span class="s0">'render'</span><span class="s1">,</span>
        <span class="s1">rootParams,</span>
        <span class="s1">fallbackRouteParams,</span>
        <span class="s1">implicitTags,</span>
        <span class="s1">renderSignal: finalClientRenderController.signal,</span>
        <span class="s1">controller: finalClientReactController,</span>
        <span class="s3">// No APIs require a cacheSignal through the workUnitStore during the HTML prerender</span>
        <span class="s1">cacheSignal: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">dynamicTracking: clientDynamicTracking,</span>
        <span class="s1">allowEmptyStaticShell,</span>
        <span class="s1">revalidate: _constants1.INFINITE_CACHE,</span>
        <span class="s1">expire: _constants1.INFINITE_CACHE,</span>
        <span class="s1">stale: _constants1.INFINITE_CACHE,</span>
        <span class="s1">tags: [</span>
            <span class="s1">...implicitTags.tags</span>
        <span class="s1">],</span>
        <span class="s1">prerenderResumeDataCache,</span>
        <span class="s1">renderResumeDataCache: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">hmrRefreshHash,</span>
        <span class="s1">captureOwnerStack: captureOwnerStackClient</span>
    <span class="s1">};</span>
    <span class="s2">let </span><span class="s1">dynamicValidation = (</span><span class="s4">0</span><span class="s1">, _dynamicrendering.createDynamicValidationState)();</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">prerender = require(</span><span class="s0">'react-dom/static'</span><span class="s1">).prerender;</span>
        <span class="s2">let </span><span class="s1">{ prelude: unprocessedPrelude } = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _apprenderprerenderutils.prerenderAndAbortInSequentialTasks)(()=&gt;{</span>
            <span class="s2">const </span><span class="s1">pendingFinalClientResult = _workunitasyncstorageexternal.workUnitAsyncStorage.run(finalClientPrerenderStore, prerender, </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(App, {</span>
                <span class="s1">reactServerStream: reactServerResult.asUnclosingStream(),</span>
                <span class="s1">preinitScripts: preinitScripts,</span>
                <span class="s1">clientReferenceManifest: clientReferenceManifest,</span>
                <span class="s1">ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,</span>
                <span class="s1">nonce: nonce</span>
            <span class="s1">}), {</span>
                <span class="s1">signal: finalClientReactController.signal,</span>
                <span class="s1">onError: (err, errorInfo)=&gt;{</span>
                    <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _dynamicrendering.isPrerenderInterruptedError)(err) || finalClientReactController.signal.aborted) {</span>
                        <span class="s2">const </span><span class="s1">componentStack = errorInfo.componentStack;</span>
                        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">componentStack === </span><span class="s0">'string'</span><span class="s1">) {</span>
                            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _dynamicrendering.trackAllowedDynamicAccess)(workStore, componentStack, dynamicValidation, clientDynamicTracking);</span>
                        <span class="s1">}</span>
                        <span class="s2">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _reactlargeshellerror.isReactLargeShellError)(err)) {</span>
                        <span class="s3">// TODO: Aggregate</span>
                        <span class="s1">console.error(err);</span>
                        <span class="s2">return </span><span class="s1">undefined;</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _createerrorhandler.getDigestForWellKnownError)(err);</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s3">// The listener to abort our own render controller must be added after</span>
            <span class="s3">// React has added its listener, to ensure that pending I/O is not</span>
            <span class="s3">// aborted/rejected too early.</span>
            <span class="s1">finalClientReactController.signal.addEventListener(</span><span class="s0">'abort'</span><span class="s1">, ()=&gt;{</span>
                <span class="s1">finalClientRenderController.abort();</span>
            <span class="s1">}, {</span>
                <span class="s1">once: </span><span class="s2">true</span>
            <span class="s1">});</span>
            <span class="s2">return </span><span class="s1">pendingFinalClientResult;</span>
        <span class="s1">}, ()=&gt;{</span>
            <span class="s1">finalClientReactController.abort();</span>
        <span class="s1">});</span>
        <span class="s2">const </span><span class="s1">{ preludeIsEmpty } = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _apprenderprerenderutils.processPrelude)(unprocessedPrelude);</span>
        <span class="s1">resolveValidation(</span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(LogSafely, {</span>
            <span class="s1">fn: _dynamicrendering.throwIfDisallowedDynamic.bind(</span><span class="s2">null</span><span class="s1">, workStore, preludeIsEmpty ? _dynamicrendering.PreludeState.Empty : _dynamicrendering.PreludeState.Full, dynamicValidation, serverDynamicTracking)</span>
        <span class="s1">}));</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(thrownValue) {</span>
        <span class="s3">// Even if the root errors we still want to report any cache components errors</span>
        <span class="s3">// that were discovered before the root errored.</span>
        <span class="s2">let </span><span class="s1">loggingFunction = _dynamicrendering.throwIfDisallowedDynamic.bind(</span><span class="s2">null</span><span class="s1">, workStore, _dynamicrendering.PreludeState.Errored, dynamicValidation, serverDynamicTracking);</span>
        <span class="s2">if </span><span class="s1">(process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {</span>
            <span class="s3">// We don't normally log these errors because we are going to retry anyway but</span>
            <span class="s3">// it can be useful for debugging Next.js itself to get visibility here when needed</span>
            <span class="s2">const </span><span class="s1">originalLoggingFunction = loggingFunction;</span>
            <span class="s1">loggingFunction = ()=&gt;{</span>
                <span class="s1">console.error(</span><span class="s0">'During dynamic validation the root of the page errored. The next logged error is the thrown value. It may be a duplicate of errors reported during the normal development mode render.'</span><span class="s1">);</span>
                <span class="s1">console.error(thrownValue);</span>
                <span class="s1">originalLoggingFunction();</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s1">resolveValidation(</span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(LogSafely, {</span>
            <span class="s1">fn: loggingFunction</span>
        <span class="s1">}));</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">LogSafely({ fn }) {</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">await </span><span class="s1">fn();</span>
    <span class="s1">} </span><span class="s2">catch  </span><span class="s1">{}</span>
    <span class="s2">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Determines whether we should generate static flight data.</span>
 <span class="s3">*/ </span><span class="s2">function </span><span class="s1">shouldGenerateStaticFlightData(workStore) {</span>
    <span class="s2">const </span><span class="s1">{ isStaticGeneration } = workStore;</span>
    <span class="s2">if </span><span class="s1">(!isStaticGeneration) </span><span class="s2">return false</span><span class="s1">;</span>
    <span class="s2">return true</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">prerenderToStream(req, res, ctx, metadata, tree, fallbackRouteParams) {</span>
    <span class="s3">// When prerendering formState is always null. We still include it</span>
    <span class="s3">// because some shared APIs expect a formState value and this is slightly</span>
    <span class="s3">// more explicit than making it an optional function argument</span>
    <span class="s2">const </span><span class="s1">formState = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">{ assetPrefix, getDynamicParamFromSegment, implicitTags, nonce, pagePath, renderOpts, workStore } = ctx;</span>
    <span class="s2">const </span><span class="s1">{ allowEmptyStaticShell = </span><span class="s2">false</span><span class="s1">, basePath, buildManifest, clientReferenceManifest, ComponentMod, crossOrigin, dev = </span><span class="s2">false</span><span class="s1">, experimental, isDebugDynamicAccesses, nextExport = </span><span class="s2">false</span><span class="s1">, onInstrumentationRequestError, page, reactMaxHeadersLength, subresourceIntegrityManifest } = renderOpts;</span>
    <span class="s1">assertClientReferenceManifest(clientReferenceManifest);</span>
    <span class="s2">const </span><span class="s1">rootParams = (</span><span class="s4">0</span><span class="s1">, _createcomponenttree.getRootParams)(tree, getDynamicParamFromSegment);</span>
    <span class="s2">const </span><span class="s1">{ ServerInsertedHTMLProvider, renderServerInsertedHTML } = (</span><span class="s4">0</span><span class="s1">, _serverinsertedhtml.createServerInsertedHTML)();</span>
    <span class="s2">const </span><span class="s1">getServerInsertedMetadata = (</span><span class="s4">0</span><span class="s1">, _createserverinsertedmetadata.createServerInsertedMetadata)(nonce);</span>
    <span class="s2">const </span><span class="s1">tracingMetadata = (</span><span class="s4">0</span><span class="s1">, _utils1.getTracedMetadata)((</span><span class="s4">0</span><span class="s1">, _tracer.getTracer)().getTracePropagationData(), experimental.clientTraceMetadata);</span>
    <span class="s2">const </span><span class="s1">polyfills = buildManifest.polyfillFiles.filter((polyfill)=&gt;polyfill.endsWith(</span><span class="s0">'.js'</span><span class="s1">) &amp;&amp; !polyfill.endsWith(</span><span class="s0">'.module.js'</span><span class="s1">)).map((polyfill)=&gt;({</span>
            <span class="s1">src: </span><span class="s0">`</span><span class="s1">${assetPrefix}</span><span class="s0">/_next/</span><span class="s1">${polyfill}${(</span><span class="s4">0</span><span class="s1">, _getassetquerystring.getAssetQueryString)(ctx, </span><span class="s2">false</span><span class="s1">)}</span><span class="s0">`</span><span class="s1">,</span>
            <span class="s1">integrity: subresourceIntegrityManifest == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: subresourceIntegrityManifest[polyfill],</span>
            <span class="s1">crossOrigin,</span>
            <span class="s1">noModule: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">nonce</span>
        <span class="s1">}));</span>
    <span class="s2">const </span><span class="s1">[preinitScripts, bootstrapScript] = (</span><span class="s4">0</span><span class="s1">, _requiredscripts.getRequiredScripts)(buildManifest, </span><span class="s3">// Why is assetPrefix optional on renderOpts?</span>
    <span class="s3">// @TODO make it default empty string on renderOpts and get rid of it from ctx</span>
    <span class="s1">assetPrefix, crossOrigin, subresourceIntegrityManifest, (</span><span class="s4">0</span><span class="s1">, _getassetquerystring.getAssetQueryString)(ctx, </span><span class="s2">true</span><span class="s1">), nonce, page);</span>
    <span class="s2">const </span><span class="s1">reactServerErrorsByDigest = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s3">// We don't report errors during prerendering through our instrumentation hooks</span>
    <span class="s2">const </span><span class="s1">silenceLogger = !!experimental.isRoutePPREnabled;</span>
    <span class="s2">function </span><span class="s1">onHTMLRenderRSCError(err) {</span>
        <span class="s2">return </span><span class="s1">onInstrumentationRequestError == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: onInstrumentationRequestError(err, req, createErrorContext(ctx, </span><span class="s0">'react-server-components'</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">serverComponentsErrorHandler = (</span><span class="s4">0</span><span class="s1">, _createerrorhandler.createHTMLReactServerErrorHandler)(dev, nextExport, reactServerErrorsByDigest, silenceLogger, onHTMLRenderRSCError);</span>
    <span class="s2">function </span><span class="s1">onHTMLRenderSSRError(err) {</span>
        <span class="s2">return </span><span class="s1">onInstrumentationRequestError == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: onInstrumentationRequestError(err, req, createErrorContext(ctx, </span><span class="s0">'server-rendering'</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">allCapturedErrors = [];</span>
    <span class="s2">const </span><span class="s1">htmlRendererErrorHandler = (</span><span class="s4">0</span><span class="s1">, _createerrorhandler.createHTMLErrorHandler)(dev, nextExport, reactServerErrorsByDigest, allCapturedErrors, silenceLogger, onHTMLRenderSSRError);</span>
    <span class="s2">let </span><span class="s1">reactServerPrerenderResult = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">setMetadataHeader = (name)=&gt;{</span>
        <span class="s1">metadata.headers ??= {};</span>
        <span class="s1">metadata.headers[name] = res.getHeader(name);</span>
    <span class="s1">};</span>
    <span class="s2">const </span><span class="s1">setHeader = (name, value)=&gt;{</span>
        <span class="s1">res.setHeader(name, value);</span>
        <span class="s1">setMetadataHeader(name);</span>
        <span class="s2">return </span><span class="s1">res;</span>
    <span class="s1">};</span>
    <span class="s2">const </span><span class="s1">appendHeader = (name, value)=&gt;{</span>
        <span class="s2">if </span><span class="s1">(Array.isArray(value)) {</span>
            <span class="s1">value.forEach((item)=&gt;{</span>
                <span class="s1">res.appendHeader(name, item);</span>
            <span class="s1">});</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">res.appendHeader(name, value);</span>
        <span class="s1">}</span>
        <span class="s1">setMetadataHeader(name);</span>
    <span class="s1">};</span>
    <span class="s2">const </span><span class="s1">selectStaleTime = createSelectStaleTime(experimental);</span>
    <span class="s2">let </span><span class="s1">prerenderStore = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(experimental.cacheComponents) {</span>
            <span class="s3">/**</span>
       <span class="s3">* cacheComponents with PPR</span>
       <span class="s3">*</span>
       <span class="s3">* The general approach is to render the RSC stream first allowing any cache reads to resolve.</span>
       <span class="s3">* Once we have settled all cache reads we restart the render and abort after a single Task.</span>
       <span class="s3">*</span>
       <span class="s3">* Unlike with the non PPR case we can't synchronously abort the render when a dynamic API is used</span>
       <span class="s3">* during the initial render because we need to ensure all caches can be filled as part of the initial Task</span>
       <span class="s3">* and a synchronous abort might prevent us from filling all caches.</span>
       <span class="s3">*</span>
       <span class="s3">* Once the render is complete we allow the SSR render to finish and use a combination of the postponed state</span>
       <span class="s3">* and the reactServerIsDynamic value to determine how to treat the resulting render</span>
       <span class="s3">*/ // The prerender controller represents the lifetime of the prerender. It</span>
            <span class="s3">// will be aborted when a task is complete or a synchronously aborting API</span>
            <span class="s3">// is called. Notably, during prospective prerenders, this does not</span>
            <span class="s3">// actually terminate the prerender itself, which will continue until all</span>
            <span class="s3">// caches are filled.</span>
            <span class="s2">const </span><span class="s1">initialServerPrerenderController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
            <span class="s3">// This controller is used to abort the React prerender.</span>
            <span class="s2">const </span><span class="s1">initialServerReactController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
            <span class="s3">// This controller represents the lifetime of the React prerender. Its</span>
            <span class="s3">// signal can be used for any I/O operation to abort the I/O and/or to</span>
            <span class="s3">// reject, when prerendering aborts. This includes our own hanging</span>
            <span class="s3">// promises for accessing request data, and for fetch calls. It might be</span>
            <span class="s3">// replaced in the future by React.cacheSignal(). It's aborted after the</span>
            <span class="s3">// React controller, so that no pending I/O can register abort listeners</span>
            <span class="s3">// that are called before React's abort listener is called. This ensures</span>
            <span class="s3">// that pending I/O is not rejected too early when aborting the prerender.</span>
            <span class="s3">// Notably, during the prospective prerender, it is different from the</span>
            <span class="s3">// prerender controller because we don't want to end the React prerender</span>
            <span class="s3">// until all caches are filled.</span>
            <span class="s2">const </span><span class="s1">initialServerRenderController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
            <span class="s3">// The cacheSignal helps us track whether caches are still filling or we are ready</span>
            <span class="s3">// to cut the render off.</span>
            <span class="s2">const </span><span class="s1">cacheSignal = </span><span class="s2">new </span><span class="s1">_cachesignal.CacheSignal();</span>
            <span class="s2">let </span><span class="s1">resumeDataCache;</span>
            <span class="s2">let </span><span class="s1">renderResumeDataCache = </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">let </span><span class="s1">prerenderResumeDataCache = </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(renderOpts.renderResumeDataCache) {</span>
                <span class="s3">// If a prefilled immutable render resume data cache is provided, e.g.</span>
                <span class="s3">// when prerendering an optional fallback shell after having prerendered</span>
                <span class="s3">// pages with defined params, we use this instead of a prerender resume</span>
                <span class="s3">// data cache.</span>
                <span class="s1">resumeDataCache = renderResumeDataCache = renderOpts.renderResumeDataCache;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s3">// Otherwise we create a new mutable prerender resume data cache.</span>
                <span class="s1">resumeDataCache = prerenderResumeDataCache = (</span><span class="s4">0</span><span class="s1">, _resumedatacache.createPrerenderResumeDataCache)();</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">initialServerPayloadPrerenderStore = {</span>
                <span class="s1">type: </span><span class="s0">'prerender'</span><span class="s1">,</span>
                <span class="s1">phase: </span><span class="s0">'render'</span><span class="s1">,</span>
                <span class="s1">rootParams,</span>
                <span class="s1">fallbackRouteParams,</span>
                <span class="s1">implicitTags,</span>
                <span class="s3">// While this render signal isn't going to be used to abort a React render while getting the RSC payload</span>
                <span class="s3">// various request data APIs bind to this controller to reject after completion.</span>
                <span class="s1">renderSignal: initialServerRenderController.signal,</span>
                <span class="s3">// When we generate the RSC payload we might abort this controller due to sync IO</span>
                <span class="s3">// but we don't actually care about sync IO in this phase so we use a throw away controller</span>
                <span class="s3">// that isn't connected to anything</span>
                <span class="s1">controller: </span><span class="s2">new </span><span class="s1">AbortController(),</span>
                <span class="s3">// During the initial prerender we need to track all cache reads to ensure</span>
                <span class="s3">// we render long enough to fill every cache it is possible to visit during</span>
                <span class="s3">// the final prerender.</span>
                <span class="s1">cacheSignal,</span>
                <span class="s1">dynamicTracking: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">allowEmptyStaticShell,</span>
                <span class="s1">revalidate: _constants1.INFINITE_CACHE,</span>
                <span class="s1">expire: _constants1.INFINITE_CACHE,</span>
                <span class="s1">stale: _constants1.INFINITE_CACHE,</span>
                <span class="s1">tags: [</span>
                    <span class="s1">...implicitTags.tags</span>
                <span class="s1">],</span>
                <span class="s1">prerenderResumeDataCache,</span>
                <span class="s1">renderResumeDataCache,</span>
                <span class="s1">hmrRefreshHash: undefined,</span>
                <span class="s1">captureOwnerStack: undefined</span>
            <span class="s1">};</span>
            <span class="s3">// We're not going to use the result of this render because the only time it could be used</span>
            <span class="s3">// is if it completes in a microtask and that's likely very rare for any non-trivial app</span>
            <span class="s2">const </span><span class="s1">initialServerPayload = </span><span class="s2">await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(initialServerPayloadPrerenderStore, getRSCPayload, tree, ctx, res.statusCode === </span><span class="s4">404</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">initialServerPrerenderStore = prerenderStore = {</span>
                <span class="s1">type: </span><span class="s0">'prerender'</span><span class="s1">,</span>
                <span class="s1">phase: </span><span class="s0">'render'</span><span class="s1">,</span>
                <span class="s1">rootParams,</span>
                <span class="s1">fallbackRouteParams,</span>
                <span class="s1">implicitTags,</span>
                <span class="s1">renderSignal: initialServerRenderController.signal,</span>
                <span class="s1">controller: initialServerPrerenderController,</span>
                <span class="s3">// During the initial prerender we need to track all cache reads to ensure</span>
                <span class="s3">// we render long enough to fill every cache it is possible to visit during</span>
                <span class="s3">// the final prerender.</span>
                <span class="s1">cacheSignal,</span>
                <span class="s1">dynamicTracking: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">allowEmptyStaticShell,</span>
                <span class="s1">revalidate: _constants1.INFINITE_CACHE,</span>
                <span class="s1">expire: _constants1.INFINITE_CACHE,</span>
                <span class="s1">stale: _constants1.INFINITE_CACHE,</span>
                <span class="s1">tags: [</span>
                    <span class="s1">...implicitTags.tags</span>
                <span class="s1">],</span>
                <span class="s1">prerenderResumeDataCache,</span>
                <span class="s1">renderResumeDataCache,</span>
                <span class="s1">hmrRefreshHash: undefined,</span>
                <span class="s1">captureOwnerStack: undefined</span>
            <span class="s1">};</span>
            <span class="s2">const </span><span class="s1">pendingInitialServerResult = _workunitasyncstorageexternal.workUnitAsyncStorage.run(initialServerPrerenderStore, ComponentMod.prerender, initialServerPayload, clientReferenceManifest.clientModules, {</span>
                <span class="s1">filterStackFrame,</span>
                <span class="s1">onError: (err)=&gt;{</span>
                    <span class="s2">const </span><span class="s1">digest = (</span><span class="s4">0</span><span class="s1">, _createerrorhandler.getDigestForWellKnownError)(err);</span>
                    <span class="s2">if </span><span class="s1">(digest) {</span>
                        <span class="s2">return </span><span class="s1">digest;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _reactlargeshellerror.isReactLargeShellError)(err)) {</span>
                        <span class="s3">// TODO: Aggregate</span>
                        <span class="s1">console.error(err);</span>
                        <span class="s2">return </span><span class="s1">undefined;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(initialServerPrerenderController.signal.aborted) {</span>
                        <span class="s3">// The render aborted before this error was handled which indicates</span>
                        <span class="s3">// the error is caused by unfinished components within the render</span>
                        <span class="s2">return</span><span class="s1">;</span>
                    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {</span>
                        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _prospectiverenderutils.printDebugThrownValueForProspectiveRender)(err, workStore.route);</span>
                    <span class="s1">}</span>
                <span class="s1">},</span>
                <span class="s3">// we don't care to track postpones during the prospective render because we need</span>
                <span class="s3">// to always do a final render anyway</span>
                <span class="s1">onPostpone: undefined,</span>
                <span class="s3">// We don't want to stop rendering until the cacheSignal is complete so we pass</span>
                <span class="s3">// a different signal to this render call than is used by dynamic APIs to signify</span>
                <span class="s3">// transitioning out of the prerender environment</span>
                <span class="s1">signal: initialServerReactController.signal</span>
            <span class="s1">});</span>
            <span class="s3">// The listener to abort our own render controller must be added after</span>
            <span class="s3">// React has added its listener, to ensure that pending I/O is not</span>
            <span class="s3">// aborted/rejected too early.</span>
            <span class="s1">initialServerReactController.signal.addEventListener(</span><span class="s0">'abort'</span><span class="s1">, ()=&gt;{</span>
                <span class="s1">initialServerRenderController.abort();</span>
            <span class="s1">}, {</span>
                <span class="s1">once: </span><span class="s2">true</span>
            <span class="s1">});</span>
            <span class="s3">// Wait for all caches to be finished filling and for async imports to resolve</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _trackmoduleloadingexternal.trackPendingModules)(cacheSignal);</span>
            <span class="s2">await </span><span class="s1">cacheSignal.cacheReady();</span>
            <span class="s1">initialServerReactController.abort();</span>
            <span class="s3">// We don't need to continue the prerender process if we already</span>
            <span class="s3">// detected invalid dynamic usage in the initial prerender phase.</span>
            <span class="s2">if </span><span class="s1">(workStore.invalidDynamicUsageError) {</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s1">, _dynamicrendering.logDisallowedDynamicError)(workStore, workStore.invalidDynamicUsageError);</span>
                <span class="s2">throw new </span><span class="s1">_staticgenerationbailout.StaticGenBailoutError();</span>
            <span class="s1">}</span>
            <span class="s2">let </span><span class="s1">initialServerResult;</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s1">initialServerResult = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _apprenderprerenderutils.createReactServerPrerenderResult)(pendingInitialServerResult);</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
                <span class="s2">if </span><span class="s1">(initialServerReactController.signal.aborted || initialServerPrerenderController.signal.aborted) {</span>
                <span class="s3">// These are expected errors that might error the prerender. we ignore them.</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {</span>
                    <span class="s3">// We don't normally log these errors because we are going to retry anyway but</span>
                    <span class="s3">// it can be useful for debugging Next.js itself to get visibility here when needed</span>
                    <span class="s1">(</span><span class="s4">0</span><span class="s1">, _prospectiverenderutils.printDebugThrownValueForProspectiveRender)(err, workStore.route);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(initialServerResult) {</span>
                <span class="s2">const </span><span class="s1">initialClientPrerenderController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
                <span class="s2">const </span><span class="s1">initialClientReactController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
                <span class="s2">const </span><span class="s1">initialClientRenderController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
                <span class="s2">const </span><span class="s1">initialClientPrerenderStore = {</span>
                    <span class="s1">type: </span><span class="s0">'prerender-client'</span><span class="s1">,</span>
                    <span class="s1">phase: </span><span class="s0">'render'</span><span class="s1">,</span>
                    <span class="s1">rootParams,</span>
                    <span class="s1">fallbackRouteParams,</span>
                    <span class="s1">implicitTags,</span>
                    <span class="s1">renderSignal: initialClientRenderController.signal,</span>
                    <span class="s1">controller: initialClientPrerenderController,</span>
                    <span class="s3">// For HTML Generation the only cache tracked activity</span>
                    <span class="s3">// is module loading, which has it's own cache signal</span>
                    <span class="s1">cacheSignal: </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">dynamicTracking: </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">allowEmptyStaticShell,</span>
                    <span class="s1">revalidate: _constants1.INFINITE_CACHE,</span>
                    <span class="s1">expire: _constants1.INFINITE_CACHE,</span>
                    <span class="s1">stale: _constants1.INFINITE_CACHE,</span>
                    <span class="s1">tags: [</span>
                        <span class="s1">...implicitTags.tags</span>
                    <span class="s1">],</span>
                    <span class="s1">prerenderResumeDataCache,</span>
                    <span class="s1">renderResumeDataCache,</span>
                    <span class="s1">hmrRefreshHash: undefined,</span>
                    <span class="s1">captureOwnerStack: undefined</span>
                <span class="s1">};</span>
                <span class="s2">const </span><span class="s1">prerender = require(</span><span class="s0">'react-dom/static'</span><span class="s1">).prerender;</span>
                <span class="s2">const </span><span class="s1">pendingInitialClientResult = _workunitasyncstorageexternal.workUnitAsyncStorage.run(initialClientPrerenderStore, prerender, </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(App, {</span>
                    <span class="s1">reactServerStream: initialServerResult.asUnclosingStream(),</span>
                    <span class="s1">preinitScripts: preinitScripts,</span>
                    <span class="s1">clientReferenceManifest: clientReferenceManifest,</span>
                    <span class="s1">ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,</span>
                    <span class="s1">nonce: nonce</span>
                <span class="s1">}), {</span>
                    <span class="s1">signal: initialClientReactController.signal,</span>
                    <span class="s1">onError: (err)=&gt;{</span>
                        <span class="s2">const </span><span class="s1">digest = (</span><span class="s4">0</span><span class="s1">, _createerrorhandler.getDigestForWellKnownError)(err);</span>
                        <span class="s2">if </span><span class="s1">(digest) {</span>
                            <span class="s2">return </span><span class="s1">digest;</span>
                        <span class="s1">}</span>
                        <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _reactlargeshellerror.isReactLargeShellError)(err)) {</span>
                            <span class="s3">// TODO: Aggregate</span>
                            <span class="s1">console.error(err);</span>
                            <span class="s2">return </span><span class="s1">undefined;</span>
                        <span class="s1">}</span>
                        <span class="s2">if </span><span class="s1">(initialClientReactController.signal.aborted) {</span>
                        <span class="s3">// These are expected errors that might error the prerender. we ignore them.</span>
                        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {</span>
                            <span class="s3">// We don't normally log these errors because we are going to retry anyway but</span>
                            <span class="s3">// it can be useful for debugging Next.js itself to get visibility here when needed</span>
                            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _prospectiverenderutils.printDebugThrownValueForProspectiveRender)(err, workStore.route);</span>
                        <span class="s1">}</span>
                    <span class="s1">},</span>
                    <span class="s1">bootstrapScripts: [</span>
                        <span class="s1">bootstrapScript</span>
                    <span class="s1">]</span>
                <span class="s1">});</span>
                <span class="s3">// The listener to abort our own render controller must be added after</span>
                <span class="s3">// React has added its listener, to ensure that pending I/O is not</span>
                <span class="s3">// aborted/rejected too early.</span>
                <span class="s1">initialClientReactController.signal.addEventListener(</span><span class="s0">'abort'</span><span class="s1">, ()=&gt;{</span>
                    <span class="s1">initialClientRenderController.abort();</span>
                <span class="s1">}, {</span>
                    <span class="s1">once: </span><span class="s2">true</span>
                <span class="s1">});</span>
                <span class="s1">pendingInitialClientResult.catch((err)=&gt;{</span>
                    <span class="s2">if </span><span class="s1">(initialClientReactController.signal.aborted || (</span><span class="s4">0</span><span class="s1">, _dynamicrendering.isPrerenderInterruptedError)(err)) {</span>
                    <span class="s3">// These are expected errors that might error the prerender. we ignore them.</span>
                    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {</span>
                        <span class="s3">// We don't normally log these errors because we are going to retry anyway but</span>
                        <span class="s3">// it can be useful for debugging Next.js itself to get visibility here when needed</span>
                        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _prospectiverenderutils.printDebugThrownValueForProspectiveRender)(err, workStore.route);</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
                <span class="s3">// This is mostly needed for dynamic `import()`s in client components.</span>
                <span class="s3">// Promises passed to client were already awaited above (assuming that they came from cached functions)</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s1">, _trackmoduleloadingexternal.trackPendingModules)(cacheSignal);</span>
                <span class="s2">await </span><span class="s1">cacheSignal.cacheReady();</span>
                <span class="s1">initialClientReactController.abort();</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">finalServerReactController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
            <span class="s2">const </span><span class="s1">finalServerRenderController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
            <span class="s2">const </span><span class="s1">finalServerPayloadPrerenderStore = {</span>
                <span class="s1">type: </span><span class="s0">'prerender'</span><span class="s1">,</span>
                <span class="s1">phase: </span><span class="s0">'render'</span><span class="s1">,</span>
                <span class="s1">rootParams,</span>
                <span class="s1">fallbackRouteParams,</span>
                <span class="s1">implicitTags,</span>
                <span class="s3">// While this render signal isn't going to be used to abort a React render while getting the RSC payload</span>
                <span class="s3">// various request data APIs bind to this controller to reject after completion.</span>
                <span class="s1">renderSignal: finalServerRenderController.signal,</span>
                <span class="s3">// When we generate the RSC payload we might abort this controller due to sync IO</span>
                <span class="s3">// but we don't actually care about sync IO in this phase so we use a throw away controller</span>
                <span class="s3">// that isn't connected to anything</span>
                <span class="s1">controller: </span><span class="s2">new </span><span class="s1">AbortController(),</span>
                <span class="s3">// All caches we could read must already be filled so no tracking is necessary</span>
                <span class="s1">cacheSignal: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">dynamicTracking: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">allowEmptyStaticShell,</span>
                <span class="s1">revalidate: _constants1.INFINITE_CACHE,</span>
                <span class="s1">expire: _constants1.INFINITE_CACHE,</span>
                <span class="s1">stale: _constants1.INFINITE_CACHE,</span>
                <span class="s1">tags: [</span>
                    <span class="s1">...implicitTags.tags</span>
                <span class="s1">],</span>
                <span class="s1">prerenderResumeDataCache,</span>
                <span class="s1">renderResumeDataCache,</span>
                <span class="s1">hmrRefreshHash: undefined,</span>
                <span class="s1">captureOwnerStack: undefined</span>
            <span class="s1">};</span>
            <span class="s2">const </span><span class="s1">finalAttemptRSCPayload = </span><span class="s2">await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(finalServerPayloadPrerenderStore, getRSCPayload, tree, ctx, res.statusCode === </span><span class="s4">404</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">serverDynamicTracking = (</span><span class="s4">0</span><span class="s1">, _dynamicrendering.createDynamicTrackingState)(isDebugDynamicAccesses);</span>
            <span class="s2">let </span><span class="s1">serverIsDynamic = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">finalServerPrerenderStore = prerenderStore = {</span>
                <span class="s1">type: </span><span class="s0">'prerender'</span><span class="s1">,</span>
                <span class="s1">phase: </span><span class="s0">'render'</span><span class="s1">,</span>
                <span class="s1">rootParams,</span>
                <span class="s1">fallbackRouteParams,</span>
                <span class="s1">implicitTags,</span>
                <span class="s1">renderSignal: finalServerRenderController.signal,</span>
                <span class="s1">controller: finalServerReactController,</span>
                <span class="s3">// All caches we could read must already be filled so no tracking is necessary</span>
                <span class="s1">cacheSignal: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">dynamicTracking: serverDynamicTracking,</span>
                <span class="s1">allowEmptyStaticShell,</span>
                <span class="s1">revalidate: _constants1.INFINITE_CACHE,</span>
                <span class="s1">expire: _constants1.INFINITE_CACHE,</span>
                <span class="s1">stale: _constants1.INFINITE_CACHE,</span>
                <span class="s1">tags: [</span>
                    <span class="s1">...implicitTags.tags</span>
                <span class="s1">],</span>
                <span class="s1">prerenderResumeDataCache,</span>
                <span class="s1">renderResumeDataCache,</span>
                <span class="s1">hmrRefreshHash: undefined,</span>
                <span class="s1">captureOwnerStack: undefined</span>
            <span class="s1">};</span>
            <span class="s2">let </span><span class="s1">prerenderIsPending = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">reactServerResult = reactServerPrerenderResult = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _apprenderprerenderutils.createReactServerPrerenderResult)((</span><span class="s4">0</span><span class="s1">, _apprenderprerenderutils.prerenderAndAbortInSequentialTasks)(async ()=&gt;{</span>
                <span class="s2">const </span><span class="s1">pendingPrerenderResult = _workunitasyncstorageexternal.workUnitAsyncStorage.run(</span><span class="s3">// The store to scope</span>
                <span class="s1">finalServerPrerenderStore, </span><span class="s3">// The function to run</span>
                <span class="s1">ComponentMod.prerender, </span><span class="s3">// ... the arguments for the function to run</span>
                <span class="s1">finalAttemptRSCPayload, clientReferenceManifest.clientModules, {</span>
                    <span class="s1">filterStackFrame,</span>
                    <span class="s1">onError: (err)=&gt;{</span>
                        <span class="s2">return </span><span class="s1">serverComponentsErrorHandler(err);</span>
                    <span class="s1">},</span>
                    <span class="s1">signal: finalServerReactController.signal</span>
                <span class="s1">});</span>
                <span class="s3">// The listener to abort our own render controller must be added</span>
                <span class="s3">// after React has added its listener, to ensure that pending I/O</span>
                <span class="s3">// is not aborted/rejected too early.</span>
                <span class="s1">finalServerReactController.signal.addEventListener(</span><span class="s0">'abort'</span><span class="s1">, ()=&gt;{</span>
                    <span class="s1">finalServerRenderController.abort();</span>
                <span class="s1">}, {</span>
                    <span class="s1">once: </span><span class="s2">true</span>
                <span class="s1">});</span>
                <span class="s2">const </span><span class="s1">prerenderResult = </span><span class="s2">await </span><span class="s1">pendingPrerenderResult;</span>
                <span class="s1">prerenderIsPending = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s2">return </span><span class="s1">prerenderResult;</span>
            <span class="s1">}, ()=&gt;{</span>
                <span class="s2">if </span><span class="s1">(finalServerReactController.signal.aborted) {</span>
                    <span class="s3">// If the server controller is already aborted we must have called something</span>
                    <span class="s3">// that required aborting the prerender synchronously such as with new Date()</span>
                    <span class="s1">serverIsDynamic = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(prerenderIsPending) {</span>
                    <span class="s3">// If prerenderIsPending then we have blocked for longer than a Task and we assume</span>
                    <span class="s3">// there is something unfinished.</span>
                    <span class="s1">serverIsDynamic = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">finalServerReactController.abort();</span>
            <span class="s1">}));</span>
            <span class="s2">const </span><span class="s1">clientDynamicTracking = (</span><span class="s4">0</span><span class="s1">, _dynamicrendering.createDynamicTrackingState)(isDebugDynamicAccesses);</span>
            <span class="s2">const </span><span class="s1">finalClientReactController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
            <span class="s2">const </span><span class="s1">finalClientRenderController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
            <span class="s2">const </span><span class="s1">finalClientPrerenderStore = {</span>
                <span class="s1">type: </span><span class="s0">'prerender-client'</span><span class="s1">,</span>
                <span class="s1">phase: </span><span class="s0">'render'</span><span class="s1">,</span>
                <span class="s1">rootParams,</span>
                <span class="s1">fallbackRouteParams,</span>
                <span class="s1">implicitTags,</span>
                <span class="s1">renderSignal: finalClientRenderController.signal,</span>
                <span class="s1">controller: finalClientReactController,</span>
                <span class="s3">// No APIs require a cacheSignal through the workUnitStore during the HTML prerender</span>
                <span class="s1">cacheSignal: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">dynamicTracking: clientDynamicTracking,</span>
                <span class="s1">allowEmptyStaticShell,</span>
                <span class="s1">revalidate: _constants1.INFINITE_CACHE,</span>
                <span class="s1">expire: _constants1.INFINITE_CACHE,</span>
                <span class="s1">stale: _constants1.INFINITE_CACHE,</span>
                <span class="s1">tags: [</span>
                    <span class="s1">...implicitTags.tags</span>
                <span class="s1">],</span>
                <span class="s1">prerenderResumeDataCache,</span>
                <span class="s1">renderResumeDataCache,</span>
                <span class="s1">hmrRefreshHash: undefined,</span>
                <span class="s1">captureOwnerStack: undefined</span>
            <span class="s1">};</span>
            <span class="s2">let </span><span class="s1">dynamicValidation = (</span><span class="s4">0</span><span class="s1">, _dynamicrendering.createDynamicValidationState)();</span>
            <span class="s2">const </span><span class="s1">prerender = require(</span><span class="s0">'react-dom/static'</span><span class="s1">).prerender;</span>
            <span class="s2">let </span><span class="s1">{ prelude: unprocessedPrelude, postponed } = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _apprenderprerenderutils.prerenderAndAbortInSequentialTasks)(()=&gt;{</span>
                <span class="s2">const </span><span class="s1">pendingFinalClientResult = _workunitasyncstorageexternal.workUnitAsyncStorage.run(finalClientPrerenderStore, prerender, </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(App, {</span>
                    <span class="s1">reactServerStream: reactServerResult.asUnclosingStream(),</span>
                    <span class="s1">preinitScripts: preinitScripts,</span>
                    <span class="s1">clientReferenceManifest: clientReferenceManifest,</span>
                    <span class="s1">ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,</span>
                    <span class="s1">nonce: nonce</span>
                <span class="s1">}), {</span>
                    <span class="s1">signal: finalClientReactController.signal,</span>
                    <span class="s1">onError: (err, errorInfo)=&gt;{</span>
                        <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _dynamicrendering.isPrerenderInterruptedError)(err) || finalClientReactController.signal.aborted) {</span>
                            <span class="s2">const </span><span class="s1">componentStack = errorInfo.componentStack;</span>
                            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">componentStack === </span><span class="s0">'string'</span><span class="s1">) {</span>
                                <span class="s1">(</span><span class="s4">0</span><span class="s1">, _dynamicrendering.trackAllowedDynamicAccess)(workStore, componentStack, dynamicValidation, clientDynamicTracking);</span>
                            <span class="s1">}</span>
                            <span class="s2">return</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s2">return </span><span class="s1">htmlRendererErrorHandler(err, errorInfo);</span>
                    <span class="s1">},</span>
                    <span class="s1">onHeaders: (headers)=&gt;{</span>
                        <span class="s1">headers.forEach((value, key)=&gt;{</span>
                            <span class="s1">appendHeader(key, value);</span>
                        <span class="s1">});</span>
                    <span class="s1">},</span>
                    <span class="s1">maxHeadersLength: reactMaxHeadersLength,</span>
                    <span class="s1">bootstrapScripts: [</span>
                        <span class="s1">bootstrapScript</span>
                    <span class="s1">]</span>
                <span class="s1">});</span>
                <span class="s3">// The listener to abort our own render controller must be added</span>
                <span class="s3">// after React has added its listener, to ensure that pending I/O is</span>
                <span class="s3">// not aborted/rejected too early.</span>
                <span class="s1">finalClientReactController.signal.addEventListener(</span><span class="s0">'abort'</span><span class="s1">, ()=&gt;{</span>
                    <span class="s1">finalClientRenderController.abort();</span>
                <span class="s1">}, {</span>
                    <span class="s1">once: </span><span class="s2">true</span>
                <span class="s1">});</span>
                <span class="s2">return </span><span class="s1">pendingFinalClientResult;</span>
            <span class="s1">}, ()=&gt;{</span>
                <span class="s1">finalClientReactController.abort();</span>
            <span class="s1">});</span>
            <span class="s2">const </span><span class="s1">{ prelude, preludeIsEmpty } = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _apprenderprerenderutils.processPrelude)(unprocessedPrelude);</span>
            <span class="s3">// If we've disabled throwing on empty static shell, then we don't need to</span>
            <span class="s3">// track any dynamic access that occurs above the suspense boundary because</span>
            <span class="s3">// we'll do so in the route shell.</span>
            <span class="s2">if </span><span class="s1">(!allowEmptyStaticShell) {</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s1">, _dynamicrendering.throwIfDisallowedDynamic)(workStore, preludeIsEmpty ? _dynamicrendering.PreludeState.Empty : _dynamicrendering.PreludeState.Full, dynamicValidation, serverDynamicTracking);</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">getServerInsertedHTML = (</span><span class="s4">0</span><span class="s1">, _makegetserverinsertedhtml.makeGetServerInsertedHTML)({</span>
                <span class="s1">polyfills,</span>
                <span class="s1">renderServerInsertedHTML,</span>
                <span class="s1">serverCapturedErrors: allCapturedErrors,</span>
                <span class="s1">basePath,</span>
                <span class="s1">tracingMetadata: tracingMetadata</span>
            <span class="s1">});</span>
            <span class="s2">const </span><span class="s1">flightData = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _nodewebstreamshelper.streamToBuffer)(reactServerResult.asStream());</span>
            <span class="s1">metadata.flightData = flightData;</span>
            <span class="s1">metadata.segmentData = </span><span class="s2">await </span><span class="s1">collectSegmentData(flightData, finalServerPrerenderStore, ComponentMod, renderOpts);</span>
            <span class="s3">// If there are fallback route params, the RSC data is inherently dynamic</span>
            <span class="s3">// today because it's encoded into the flight router state. Until we can</span>
            <span class="s3">// move the fallback route params out of the flight router state, we need</span>
            <span class="s3">// to always perform a dynamic resume after the static prerender.</span>
            <span class="s2">const </span><span class="s1">hasFallbackRouteParams = fallbackRouteParams &amp;&amp; fallbackRouteParams.size &gt; </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(serverIsDynamic || hasFallbackRouteParams) {</span>
                <span class="s3">// Dynamic case</span>
                <span class="s3">// We will always need to perform a &quot;resume&quot; render of some kind when this route is accessed</span>
                <span class="s3">// because the RSC data itself is dynamic. We determine if there are any HTML holes or not</span>
                <span class="s3">// but generally this is a &quot;partial&quot; prerender in that there will be a per-request compute</span>
                <span class="s3">// concatenated to the static shell.</span>
                <span class="s2">if </span><span class="s1">(postponed != </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s3">// Dynamic HTML case</span>
                    <span class="s1">metadata.postponed = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _postponedstate.getDynamicHTMLPostponedState)(postponed, preludeIsEmpty ? _postponedstate.DynamicHTMLPreludeState.Empty : _postponedstate.DynamicHTMLPreludeState.Full, fallbackRouteParams, resumeDataCache);</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s3">// Dynamic Data case</span>
                    <span class="s1">metadata.postponed = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _postponedstate.getDynamicDataPostponedState)(resumeDataCache);</span>
                <span class="s1">}</span>
                <span class="s1">reactServerResult.consume();</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">digestErrorsMap: reactServerErrorsByDigest,</span>
                    <span class="s1">ssrErrors: allCapturedErrors,</span>
                    <span class="s1">stream: </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _nodewebstreamshelper.continueDynamicPrerender)(prelude, {</span>
                        <span class="s1">getServerInsertedHTML,</span>
                        <span class="s1">getServerInsertedMetadata</span>
                    <span class="s1">}),</span>
                    <span class="s1">dynamicAccess: (</span><span class="s4">0</span><span class="s1">, _dynamicrendering.consumeDynamicAccess)(serverDynamicTracking, clientDynamicTracking),</span>
                    <span class="s3">// TODO: Should this include the SSR pass?</span>
                    <span class="s1">collectedRevalidate: finalServerPrerenderStore.revalidate,</span>
                    <span class="s1">collectedExpire: finalServerPrerenderStore.expire,</span>
                    <span class="s1">collectedStale: selectStaleTime(finalServerPrerenderStore.stale),</span>
                    <span class="s1">collectedTags: finalServerPrerenderStore.tags,</span>
                    <span class="s1">renderResumeDataCache: (</span><span class="s4">0</span><span class="s1">, _resumedatacache.createRenderResumeDataCache)(resumeDataCache)</span>
                <span class="s1">};</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s3">// Static case</span>
                <span class="s3">// We will not perform resumption per request. The result can be served statically to the requestor</span>
                <span class="s3">// and if there was anything dynamic it will only be rendered in the browser.</span>
                <span class="s2">if </span><span class="s1">(workStore.forceDynamic) {</span>
                    <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_staticgenerationbailout.StaticGenBailoutError(</span><span class="s0">'Invariant: a Page with `dynamic = &quot;force-dynamic&quot;` did not trigger the dynamic pathway. This is a bug in Next.js'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E598&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">let </span><span class="s1">htmlStream = prelude;</span>
                <span class="s2">if </span><span class="s1">(postponed != </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s3">// We postponed but nothing dynamic was used. We resume the render now and immediately abort it</span>
                    <span class="s3">// so we can set all the postponed boundaries to client render mode before we store the HTML response</span>
                    <span class="s2">const </span><span class="s1">resume = require(</span><span class="s0">'react-dom/server'</span><span class="s1">).resume;</span>
                    <span class="s3">// We don't actually want to render anything so we just pass a stream</span>
                    <span class="s3">// that never resolves. The resume call is going to abort immediately anyway</span>
                    <span class="s2">const </span><span class="s1">foreverStream = </span><span class="s2">new </span><span class="s1">ReadableStream();</span>
                    <span class="s2">const </span><span class="s1">resumeStream = </span><span class="s2">await </span><span class="s1">resume(</span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(App, {</span>
                        <span class="s1">reactServerStream: foreverStream,</span>
                        <span class="s1">preinitScripts: ()=&gt;{},</span>
                        <span class="s1">clientReferenceManifest: clientReferenceManifest,</span>
                        <span class="s1">ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,</span>
                        <span class="s1">nonce: nonce</span>
                    <span class="s1">}), JSON.parse(JSON.stringify(postponed)), {</span>
                        <span class="s1">signal: (</span><span class="s4">0</span><span class="s1">, _dynamicrendering.createRenderInBrowserAbortSignal)(),</span>
                        <span class="s1">onError: htmlRendererErrorHandler,</span>
                        <span class="s1">nonce</span>
                    <span class="s1">});</span>
                    <span class="s3">// First we write everything from the prerender, then we write everything from the aborted resume render</span>
                    <span class="s1">htmlStream = (</span><span class="s4">0</span><span class="s1">, _nodewebstreamshelper.chainStreams)(prelude, resumeStream);</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">digestErrorsMap: reactServerErrorsByDigest,</span>
                    <span class="s1">ssrErrors: allCapturedErrors,</span>
                    <span class="s1">stream: </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _nodewebstreamshelper.continueStaticPrerender)(htmlStream, {</span>
                        <span class="s1">inlinedDataStream: (</span><span class="s4">0</span><span class="s1">, _useflightresponse.createInlinedDataReadableStream)(reactServerResult.consumeAsStream(), nonce, formState),</span>
                        <span class="s1">getServerInsertedHTML,</span>
                        <span class="s1">getServerInsertedMetadata,</span>
                        <span class="s1">isBuildTimePrerendering: ctx.workStore.isBuildTimePrerendering === </span><span class="s2">true</span><span class="s1">,</span>
                        <span class="s1">buildId: ctx.workStore.buildId</span>
                    <span class="s1">}),</span>
                    <span class="s1">dynamicAccess: (</span><span class="s4">0</span><span class="s1">, _dynamicrendering.consumeDynamicAccess)(serverDynamicTracking, clientDynamicTracking),</span>
                    <span class="s3">// TODO: Should this include the SSR pass?</span>
                    <span class="s1">collectedRevalidate: finalServerPrerenderStore.revalidate,</span>
                    <span class="s1">collectedExpire: finalServerPrerenderStore.expire,</span>
                    <span class="s1">collectedStale: selectStaleTime(finalServerPrerenderStore.stale),</span>
                    <span class="s1">collectedTags: finalServerPrerenderStore.tags,</span>
                    <span class="s1">renderResumeDataCache: (</span><span class="s4">0</span><span class="s1">, _resumedatacache.createRenderResumeDataCache)(resumeDataCache)</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(experimental.isRoutePPREnabled) {</span>
            <span class="s3">// We're statically generating with PPR and need to do dynamic tracking</span>
            <span class="s2">let </span><span class="s1">dynamicTracking = (</span><span class="s4">0</span><span class="s1">, _dynamicrendering.createDynamicTrackingState)(isDebugDynamicAccesses);</span>
            <span class="s2">const </span><span class="s1">prerenderResumeDataCache = (</span><span class="s4">0</span><span class="s1">, _resumedatacache.createPrerenderResumeDataCache)();</span>
            <span class="s2">const </span><span class="s1">reactServerPrerenderStore = prerenderStore = {</span>
                <span class="s1">type: </span><span class="s0">'prerender-ppr'</span><span class="s1">,</span>
                <span class="s1">phase: </span><span class="s0">'render'</span><span class="s1">,</span>
                <span class="s1">rootParams,</span>
                <span class="s1">fallbackRouteParams,</span>
                <span class="s1">implicitTags,</span>
                <span class="s1">dynamicTracking,</span>
                <span class="s1">revalidate: _constants1.INFINITE_CACHE,</span>
                <span class="s1">expire: _constants1.INFINITE_CACHE,</span>
                <span class="s1">stale: _constants1.INFINITE_CACHE,</span>
                <span class="s1">tags: [</span>
                    <span class="s1">...implicitTags.tags</span>
                <span class="s1">],</span>
                <span class="s1">prerenderResumeDataCache</span>
            <span class="s1">};</span>
            <span class="s2">const </span><span class="s1">RSCPayload = </span><span class="s2">await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(reactServerPrerenderStore, getRSCPayload, tree, ctx, res.statusCode === </span><span class="s4">404</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">reactServerResult = reactServerPrerenderResult = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _apprenderprerenderutils.createReactServerPrerenderResultFromRender)(_workunitasyncstorageexternal.workUnitAsyncStorage.run(reactServerPrerenderStore, ComponentMod.renderToReadableStream, </span><span class="s3">// ... the arguments for the function to run</span>
            <span class="s1">RSCPayload, clientReferenceManifest.clientModules, {</span>
                <span class="s1">filterStackFrame,</span>
                <span class="s1">onError: serverComponentsErrorHandler</span>
            <span class="s1">}));</span>
            <span class="s2">const </span><span class="s1">ssrPrerenderStore = {</span>
                <span class="s1">type: </span><span class="s0">'prerender-ppr'</span><span class="s1">,</span>
                <span class="s1">phase: </span><span class="s0">'render'</span><span class="s1">,</span>
                <span class="s1">rootParams,</span>
                <span class="s1">fallbackRouteParams,</span>
                <span class="s1">implicitTags,</span>
                <span class="s1">dynamicTracking,</span>
                <span class="s1">revalidate: _constants1.INFINITE_CACHE,</span>
                <span class="s1">expire: _constants1.INFINITE_CACHE,</span>
                <span class="s1">stale: _constants1.INFINITE_CACHE,</span>
                <span class="s1">tags: [</span>
                    <span class="s1">...implicitTags.tags</span>
                <span class="s1">],</span>
                <span class="s1">prerenderResumeDataCache</span>
            <span class="s1">};</span>
            <span class="s2">const </span><span class="s1">prerender = require(</span><span class="s0">'react-dom/static'</span><span class="s1">).prerender;</span>
            <span class="s2">const </span><span class="s1">{ prelude: unprocessedPrelude, postponed } = </span><span class="s2">await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(ssrPrerenderStore, prerender, </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(App, {</span>
                <span class="s1">reactServerStream: reactServerResult.asUnclosingStream(),</span>
                <span class="s1">preinitScripts: preinitScripts,</span>
                <span class="s1">clientReferenceManifest: clientReferenceManifest,</span>
                <span class="s1">ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,</span>
                <span class="s1">nonce: nonce</span>
            <span class="s1">}), {</span>
                <span class="s1">onError: htmlRendererErrorHandler,</span>
                <span class="s1">onHeaders: (headers)=&gt;{</span>
                    <span class="s1">headers.forEach((value, key)=&gt;{</span>
                        <span class="s1">appendHeader(key, value);</span>
                    <span class="s1">});</span>
                <span class="s1">},</span>
                <span class="s1">maxHeadersLength: reactMaxHeadersLength,</span>
                <span class="s1">bootstrapScripts: [</span>
                    <span class="s1">bootstrapScript</span>
                <span class="s1">]</span>
            <span class="s1">});</span>
            <span class="s2">const </span><span class="s1">getServerInsertedHTML = (</span><span class="s4">0</span><span class="s1">, _makegetserverinsertedhtml.makeGetServerInsertedHTML)({</span>
                <span class="s1">polyfills,</span>
                <span class="s1">renderServerInsertedHTML,</span>
                <span class="s1">serverCapturedErrors: allCapturedErrors,</span>
                <span class="s1">basePath,</span>
                <span class="s1">tracingMetadata: tracingMetadata</span>
            <span class="s1">});</span>
            <span class="s3">// After awaiting here we've waited for the entire RSC render to complete. Crucially this means</span>
            <span class="s3">// that when we detect whether we've used dynamic APIs below we know we'll have picked up even</span>
            <span class="s3">// parts of the React Server render that might not be used in the SSR render.</span>
            <span class="s2">const </span><span class="s1">flightData = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _nodewebstreamshelper.streamToBuffer)(reactServerResult.asStream());</span>
            <span class="s2">if </span><span class="s1">(shouldGenerateStaticFlightData(workStore)) {</span>
                <span class="s1">metadata.flightData = flightData;</span>
                <span class="s1">metadata.segmentData = </span><span class="s2">await </span><span class="s1">collectSegmentData(flightData, ssrPrerenderStore, ComponentMod, renderOpts);</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">{ prelude, preludeIsEmpty } = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _apprenderprerenderutils.processPrelude)(unprocessedPrelude);</span>
            <span class="s3">/**</span>
       <span class="s3">* When prerendering there are three outcomes to consider</span>
       <span class="s3">*</span>
       <span class="s3">*   Dynamic HTML:      The prerender has dynamic holes (caused by using Next.js Dynamic Rendering APIs)</span>
       <span class="s3">*                      We will need to resume this result when requests are handled and we don't include</span>
       <span class="s3">*                      any server inserted HTML or inlined flight data in the static HTML</span>
       <span class="s3">*</span>
       <span class="s3">*   Dynamic Data:      The prerender has no dynamic holes but dynamic APIs were used. We will not</span>
       <span class="s3">*                      resume this render when requests are handled but we will generate new inlined</span>
       <span class="s3">*                      flight data since it is dynamic and differences may end up reconciling on the client</span>
       <span class="s3">*</span>
       <span class="s3">*   Static:            The prerender has no dynamic holes and no dynamic APIs were used. We statically encode</span>
       <span class="s3">*                      all server inserted HTML and flight data</span>
       <span class="s3">*/ // First we check if we have any dynamic holes in our HTML prerender</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _dynamicrendering.accessedDynamicData)(dynamicTracking.dynamicAccesses)) {</span>
                <span class="s2">if </span><span class="s1">(postponed != </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s3">// Dynamic HTML case.</span>
                    <span class="s1">metadata.postponed = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _postponedstate.getDynamicHTMLPostponedState)(postponed, preludeIsEmpty ? _postponedstate.DynamicHTMLPreludeState.Empty : _postponedstate.DynamicHTMLPreludeState.Full, fallbackRouteParams, prerenderResumeDataCache);</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s3">// Dynamic Data case.</span>
                    <span class="s1">metadata.postponed = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _postponedstate.getDynamicDataPostponedState)(prerenderResumeDataCache);</span>
                <span class="s1">}</span>
                <span class="s3">// Regardless of whether this is the Dynamic HTML or Dynamic Data case we need to ensure we include</span>
                <span class="s3">// server inserted html in the static response because the html that is part of the prerender may depend on it</span>
                <span class="s3">// It is possible in the set of stream transforms for Dynamic HTML vs Dynamic Data may differ but currently both states</span>
                <span class="s3">// require the same set so we unify the code path here</span>
                <span class="s1">reactServerResult.consume();</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">digestErrorsMap: reactServerErrorsByDigest,</span>
                    <span class="s1">ssrErrors: allCapturedErrors,</span>
                    <span class="s1">stream: </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _nodewebstreamshelper.continueDynamicPrerender)(prelude, {</span>
                        <span class="s1">getServerInsertedHTML,</span>
                        <span class="s1">getServerInsertedMetadata</span>
                    <span class="s1">}),</span>
                    <span class="s1">dynamicAccess: dynamicTracking.dynamicAccesses,</span>
                    <span class="s3">// TODO: Should this include the SSR pass?</span>
                    <span class="s1">collectedRevalidate: reactServerPrerenderStore.revalidate,</span>
                    <span class="s1">collectedExpire: reactServerPrerenderStore.expire,</span>
                    <span class="s1">collectedStale: selectStaleTime(reactServerPrerenderStore.stale),</span>
                    <span class="s1">collectedTags: reactServerPrerenderStore.tags</span>
                <span class="s1">};</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(fallbackRouteParams &amp;&amp; fallbackRouteParams.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s3">// Rendering the fallback case.</span>
                <span class="s1">metadata.postponed = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _postponedstate.getDynamicDataPostponedState)(prerenderResumeDataCache);</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">digestErrorsMap: reactServerErrorsByDigest,</span>
                    <span class="s1">ssrErrors: allCapturedErrors,</span>
                    <span class="s1">stream: </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _nodewebstreamshelper.continueDynamicPrerender)(prelude, {</span>
                        <span class="s1">getServerInsertedHTML,</span>
                        <span class="s1">getServerInsertedMetadata</span>
                    <span class="s1">}),</span>
                    <span class="s1">dynamicAccess: dynamicTracking.dynamicAccesses,</span>
                    <span class="s3">// TODO: Should this include the SSR pass?</span>
                    <span class="s1">collectedRevalidate: reactServerPrerenderStore.revalidate,</span>
                    <span class="s1">collectedExpire: reactServerPrerenderStore.expire,</span>
                    <span class="s1">collectedStale: selectStaleTime(reactServerPrerenderStore.stale),</span>
                    <span class="s1">collectedTags: reactServerPrerenderStore.tags</span>
                <span class="s1">};</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s3">// Static case</span>
                <span class="s3">// We still have not used any dynamic APIs. At this point we can produce an entirely static prerender response</span>
                <span class="s2">if </span><span class="s1">(workStore.forceDynamic) {</span>
                    <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_staticgenerationbailout.StaticGenBailoutError(</span><span class="s0">'Invariant: a Page with `dynamic = &quot;force-dynamic&quot;` did not trigger the dynamic pathway. This is a bug in Next.js'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E598&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">let </span><span class="s1">htmlStream = prelude;</span>
                <span class="s2">if </span><span class="s1">(postponed != </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s3">// We postponed but nothing dynamic was used. We resume the render now and immediately abort it</span>
                    <span class="s3">// so we can set all the postponed boundaries to client render mode before we store the HTML response</span>
                    <span class="s2">const </span><span class="s1">resume = require(</span><span class="s0">'react-dom/server'</span><span class="s1">).resume;</span>
                    <span class="s3">// We don't actually want to render anything so we just pass a stream</span>
                    <span class="s3">// that never resolves. The resume call is going to abort immediately anyway</span>
                    <span class="s2">const </span><span class="s1">foreverStream = </span><span class="s2">new </span><span class="s1">ReadableStream();</span>
                    <span class="s2">const </span><span class="s1">resumeStream = </span><span class="s2">await </span><span class="s1">resume(</span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(App, {</span>
                        <span class="s1">reactServerStream: foreverStream,</span>
                        <span class="s1">preinitScripts: ()=&gt;{},</span>
                        <span class="s1">clientReferenceManifest: clientReferenceManifest,</span>
                        <span class="s1">ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,</span>
                        <span class="s1">nonce: nonce</span>
                    <span class="s1">}), JSON.parse(JSON.stringify(postponed)), {</span>
                        <span class="s1">signal: (</span><span class="s4">0</span><span class="s1">, _dynamicrendering.createRenderInBrowserAbortSignal)(),</span>
                        <span class="s1">onError: htmlRendererErrorHandler,</span>
                        <span class="s1">nonce</span>
                    <span class="s1">});</span>
                    <span class="s3">// First we write everything from the prerender, then we write everything from the aborted resume render</span>
                    <span class="s1">htmlStream = (</span><span class="s4">0</span><span class="s1">, _nodewebstreamshelper.chainStreams)(prelude, resumeStream);</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">digestErrorsMap: reactServerErrorsByDigest,</span>
                    <span class="s1">ssrErrors: allCapturedErrors,</span>
                    <span class="s1">stream: </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _nodewebstreamshelper.continueStaticPrerender)(htmlStream, {</span>
                        <span class="s1">inlinedDataStream: (</span><span class="s4">0</span><span class="s1">, _useflightresponse.createInlinedDataReadableStream)(reactServerResult.consumeAsStream(), nonce, formState),</span>
                        <span class="s1">getServerInsertedHTML,</span>
                        <span class="s1">getServerInsertedMetadata,</span>
                        <span class="s1">isBuildTimePrerendering: ctx.workStore.isBuildTimePrerendering === </span><span class="s2">true</span><span class="s1">,</span>
                        <span class="s1">buildId: ctx.workStore.buildId</span>
                    <span class="s1">}),</span>
                    <span class="s1">dynamicAccess: dynamicTracking.dynamicAccesses,</span>
                    <span class="s3">// TODO: Should this include the SSR pass?</span>
                    <span class="s1">collectedRevalidate: reactServerPrerenderStore.revalidate,</span>
                    <span class="s1">collectedExpire: reactServerPrerenderStore.expire,</span>
                    <span class="s1">collectedStale: selectStaleTime(reactServerPrerenderStore.stale),</span>
                    <span class="s1">collectedTags: reactServerPrerenderStore.tags</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">prerenderLegacyStore = prerenderStore = {</span>
                <span class="s1">type: </span><span class="s0">'prerender-legacy'</span><span class="s1">,</span>
                <span class="s1">phase: </span><span class="s0">'render'</span><span class="s1">,</span>
                <span class="s1">rootParams,</span>
                <span class="s1">implicitTags,</span>
                <span class="s1">revalidate: _constants1.INFINITE_CACHE,</span>
                <span class="s1">expire: _constants1.INFINITE_CACHE,</span>
                <span class="s1">stale: _constants1.INFINITE_CACHE,</span>
                <span class="s1">tags: [</span>
                    <span class="s1">...implicitTags.tags</span>
                <span class="s1">]</span>
            <span class="s1">};</span>
            <span class="s3">// This is a regular static generation. We don't do dynamic tracking because we rely on</span>
            <span class="s3">// the old-school dynamic error handling to bail out of static generation</span>
            <span class="s2">const </span><span class="s1">RSCPayload = </span><span class="s2">await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(prerenderLegacyStore, getRSCPayload, tree, ctx, res.statusCode === </span><span class="s4">404</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">reactServerResult = reactServerPrerenderResult = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _apprenderprerenderutils.createReactServerPrerenderResultFromRender)(_workunitasyncstorageexternal.workUnitAsyncStorage.run(prerenderLegacyStore, ComponentMod.renderToReadableStream, RSCPayload, clientReferenceManifest.clientModules, {</span>
                <span class="s1">filterStackFrame,</span>
                <span class="s1">onError: serverComponentsErrorHandler</span>
            <span class="s1">}));</span>
            <span class="s2">const </span><span class="s1">renderToReadableStream = require(</span><span class="s0">'react-dom/server'</span><span class="s1">).renderToReadableStream;</span>
            <span class="s2">const </span><span class="s1">htmlStream = </span><span class="s2">await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(prerenderLegacyStore, renderToReadableStream, </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(App, {</span>
                <span class="s1">reactServerStream: reactServerResult.asUnclosingStream(),</span>
                <span class="s1">preinitScripts: preinitScripts,</span>
                <span class="s1">clientReferenceManifest: clientReferenceManifest,</span>
                <span class="s1">ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,</span>
                <span class="s1">nonce: nonce</span>
            <span class="s1">}), {</span>
                <span class="s1">onError: htmlRendererErrorHandler,</span>
                <span class="s1">nonce,</span>
                <span class="s1">bootstrapScripts: [</span>
                    <span class="s1">bootstrapScript</span>
                <span class="s1">]</span>
            <span class="s1">});</span>
            <span class="s2">if </span><span class="s1">(shouldGenerateStaticFlightData(workStore)) {</span>
                <span class="s2">const </span><span class="s1">flightData = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _nodewebstreamshelper.streamToBuffer)(reactServerResult.asStream());</span>
                <span class="s1">metadata.flightData = flightData;</span>
                <span class="s1">metadata.segmentData = </span><span class="s2">await </span><span class="s1">collectSegmentData(flightData, prerenderLegacyStore, ComponentMod, renderOpts);</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">getServerInsertedHTML = (</span><span class="s4">0</span><span class="s1">, _makegetserverinsertedhtml.makeGetServerInsertedHTML)({</span>
                <span class="s1">polyfills,</span>
                <span class="s1">renderServerInsertedHTML,</span>
                <span class="s1">serverCapturedErrors: allCapturedErrors,</span>
                <span class="s1">basePath,</span>
                <span class="s1">tracingMetadata: tracingMetadata</span>
            <span class="s1">});</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">digestErrorsMap: reactServerErrorsByDigest,</span>
                <span class="s1">ssrErrors: allCapturedErrors,</span>
                <span class="s1">stream: </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _nodewebstreamshelper.continueFizzStream)(htmlStream, {</span>
                    <span class="s1">inlinedDataStream: (</span><span class="s4">0</span><span class="s1">, _useflightresponse.createInlinedDataReadableStream)(reactServerResult.consumeAsStream(), nonce, formState),</span>
                    <span class="s1">isStaticGeneration: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">isBuildTimePrerendering: ctx.workStore.isBuildTimePrerendering === </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">buildId: ctx.workStore.buildId,</span>
                    <span class="s1">getServerInsertedHTML,</span>
                    <span class="s1">getServerInsertedMetadata</span>
                <span class="s1">}),</span>
                <span class="s3">// TODO: Should this include the SSR pass?</span>
                <span class="s1">collectedRevalidate: prerenderLegacyStore.revalidate,</span>
                <span class="s1">collectedExpire: prerenderLegacyStore.expire,</span>
                <span class="s1">collectedStale: selectStaleTime(prerenderLegacyStore.stale),</span>
                <span class="s1">collectedTags: prerenderLegacyStore.tags</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _staticgenerationbailout.isStaticGenBailoutError)(err) || </span><span class="s2">typeof </span><span class="s1">err === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; err !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s0">'message' </span><span class="s2">in </span><span class="s1">err &amp;&amp; </span><span class="s2">typeof </span><span class="s1">err.message === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; err.message.includes(</span><span class="s0">'https://nextjs.org/docs/advanced-features/static-html-export'</span><span class="s1">)) {</span>
            <span class="s3">// Ensure that &quot;next dev&quot; prints the red error overlay</span>
            <span class="s2">throw </span><span class="s1">err;</span>
        <span class="s1">}</span>
        <span class="s3">// If this is a static generation error, we need to throw it so that it</span>
        <span class="s3">// can be handled by the caller if we're in static generation mode.</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _hooksservercontext.isDynamicServerError)(err)) {</span>
            <span class="s2">throw </span><span class="s1">err;</span>
        <span class="s1">}</span>
        <span class="s3">// If a bailout made it to this point, it means it wasn't wrapped inside</span>
        <span class="s3">// a suspense boundary.</span>
        <span class="s2">const </span><span class="s1">shouldBailoutToCSR = (</span><span class="s4">0</span><span class="s1">, _bailouttocsr.isBailoutToCSRError)(err);</span>
        <span class="s2">if </span><span class="s1">(shouldBailoutToCSR) {</span>
            <span class="s2">const </span><span class="s1">stack = (</span><span class="s4">0</span><span class="s1">, _formatservererror.getStackWithoutErrorMessage)(err);</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _log.error)(</span><span class="s0">`</span><span class="s1">${err.reason} </span><span class="s0">should be wrapped in a suspense boundary at page &quot;</span><span class="s1">${pagePath}</span><span class="s0">&quot;. Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout</span><span class="s5">\n</span><span class="s1">${stack}</span><span class="s0">`</span><span class="s1">);</span>
            <span class="s2">throw </span><span class="s1">err;</span>
        <span class="s1">}</span>
        <span class="s3">// If we errored when we did not have an RSC stream to read from. This is</span>
        <span class="s3">// not just a render error, we need to throw early.</span>
        <span class="s2">if </span><span class="s1">(reactServerPrerenderResult === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">throw </span><span class="s1">err;</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">errorType;</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _httpaccessfallback.isHTTPAccessFallbackError)(err)) {</span>
            <span class="s1">res.statusCode = (</span><span class="s4">0</span><span class="s1">, _httpaccessfallback.getAccessFallbackHTTPStatus)(err);</span>
            <span class="s1">metadata.statusCode = res.statusCode;</span>
            <span class="s1">errorType = (</span><span class="s4">0</span><span class="s1">, _httpaccessfallback.getAccessFallbackErrorTypeByStatus)(res.statusCode);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _redirecterror.isRedirectError)(err)) {</span>
            <span class="s1">errorType = </span><span class="s0">'redirect'</span><span class="s1">;</span>
            <span class="s1">res.statusCode = (</span><span class="s4">0</span><span class="s1">, _redirect.getRedirectStatusCodeFromError)(err);</span>
            <span class="s1">metadata.statusCode = res.statusCode;</span>
            <span class="s2">const </span><span class="s1">redirectUrl = (</span><span class="s4">0</span><span class="s1">, _addpathprefix.addPathPrefix)((</span><span class="s4">0</span><span class="s1">, _redirect.getURLFromRedirectError)(err), basePath);</span>
            <span class="s1">setHeader(</span><span class="s0">'location'</span><span class="s1">, redirectUrl);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!shouldBailoutToCSR) {</span>
            <span class="s1">res.statusCode = </span><span class="s4">500</span><span class="s1">;</span>
            <span class="s1">metadata.statusCode = res.statusCode;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">[errorPreinitScripts, errorBootstrapScript] = (</span><span class="s4">0</span><span class="s1">, _requiredscripts.getRequiredScripts)(buildManifest, assetPrefix, crossOrigin, subresourceIntegrityManifest, (</span><span class="s4">0</span><span class="s1">, _getassetquerystring.getAssetQueryString)(ctx, </span><span class="s2">false</span><span class="s1">), nonce, </span><span class="s0">'/_not-found/page'</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">prerenderLegacyStore = prerenderStore = {</span>
            <span class="s1">type: </span><span class="s0">'prerender-legacy'</span><span class="s1">,</span>
            <span class="s1">phase: </span><span class="s0">'render'</span><span class="s1">,</span>
            <span class="s1">rootParams,</span>
            <span class="s1">implicitTags: implicitTags,</span>
            <span class="s1">revalidate: </span><span class="s2">typeof </span><span class="s1">(prerenderStore == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: prerenderStore.revalidate) !== </span><span class="s0">'undefined' </span><span class="s1">? prerenderStore.revalidate : _constants1.INFINITE_CACHE,</span>
            <span class="s1">expire: </span><span class="s2">typeof </span><span class="s1">(prerenderStore == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: prerenderStore.expire) !== </span><span class="s0">'undefined' </span><span class="s1">? prerenderStore.expire : _constants1.INFINITE_CACHE,</span>
            <span class="s1">stale: </span><span class="s2">typeof </span><span class="s1">(prerenderStore == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: prerenderStore.stale) !== </span><span class="s0">'undefined' </span><span class="s1">? prerenderStore.stale : _constants1.INFINITE_CACHE,</span>
            <span class="s1">tags: [</span>
                <span class="s1">...(prerenderStore == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: prerenderStore.tags) || implicitTags.tags</span>
            <span class="s1">]</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">errorRSCPayload = </span><span class="s2">await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(prerenderLegacyStore, getErrorRSCPayload, tree, ctx, reactServerErrorsByDigest.has(err.digest) ? undefined : err, errorType);</span>
        <span class="s2">const </span><span class="s1">errorServerStream = _workunitasyncstorageexternal.workUnitAsyncStorage.run(prerenderLegacyStore, ComponentMod.renderToReadableStream, errorRSCPayload, clientReferenceManifest.clientModules, {</span>
            <span class="s1">filterStackFrame,</span>
            <span class="s1">onError: serverComponentsErrorHandler</span>
        <span class="s1">});</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s3">// TODO we should use the same prerender semantics that we initially rendered</span>
            <span class="s3">// with in this case too. The only reason why this is ok atm is because it's essentially</span>
            <span class="s3">// an empty page and no user code runs.</span>
            <span class="s2">const </span><span class="s1">fizzStream = </span><span class="s2">await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(prerenderLegacyStore, _nodewebstreamshelper.renderToInitialFizzStream, {</span>
                <span class="s1">ReactDOMServer: require(</span><span class="s0">'react-dom/server'</span><span class="s1">),</span>
                <span class="s1">element: </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(ErrorApp, {</span>
                    <span class="s1">reactServerStream: errorServerStream,</span>
                    <span class="s1">ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,</span>
                    <span class="s1">preinitScripts: errorPreinitScripts,</span>
                    <span class="s1">clientReferenceManifest: clientReferenceManifest,</span>
                    <span class="s1">nonce: nonce</span>
                <span class="s1">}),</span>
                <span class="s1">streamOptions: {</span>
                    <span class="s1">nonce,</span>
                    <span class="s3">// Include hydration scripts in the HTML</span>
                    <span class="s1">bootstrapScripts: [</span>
                        <span class="s1">errorBootstrapScript</span>
                    <span class="s1">],</span>
                    <span class="s1">formState</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s2">if </span><span class="s1">(shouldGenerateStaticFlightData(workStore)) {</span>
                <span class="s2">const </span><span class="s1">flightData = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _nodewebstreamshelper.streamToBuffer)(reactServerPrerenderResult.asStream());</span>
                <span class="s1">metadata.flightData = flightData;</span>
                <span class="s1">metadata.segmentData = </span><span class="s2">await </span><span class="s1">collectSegmentData(flightData, prerenderLegacyStore, ComponentMod, renderOpts);</span>
            <span class="s1">}</span>
            <span class="s3">// This is intentionally using the readable datastream from the main</span>
            <span class="s3">// render rather than the flight data from the error page render</span>
            <span class="s2">const </span><span class="s1">flightStream = reactServerPrerenderResult.consumeAsStream();</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s3">// Returning the error that was thrown so it can be used to handle</span>
                <span class="s3">// the response in the caller.</span>
                <span class="s1">digestErrorsMap: reactServerErrorsByDigest,</span>
                <span class="s1">ssrErrors: allCapturedErrors,</span>
                <span class="s1">stream: </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _nodewebstreamshelper.continueFizzStream)(fizzStream, {</span>
                    <span class="s1">inlinedDataStream: (</span><span class="s4">0</span><span class="s1">, _useflightresponse.createInlinedDataReadableStream)(flightStream, nonce, formState),</span>
                    <span class="s1">isStaticGeneration: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">isBuildTimePrerendering: ctx.workStore.isBuildTimePrerendering === </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">buildId: ctx.workStore.buildId,</span>
                    <span class="s1">getServerInsertedHTML: (</span><span class="s4">0</span><span class="s1">, _makegetserverinsertedhtml.makeGetServerInsertedHTML)({</span>
                        <span class="s1">polyfills,</span>
                        <span class="s1">renderServerInsertedHTML,</span>
                        <span class="s1">serverCapturedErrors: [],</span>
                        <span class="s1">basePath,</span>
                        <span class="s1">tracingMetadata: tracingMetadata</span>
                    <span class="s1">}),</span>
                    <span class="s1">getServerInsertedMetadata,</span>
                    <span class="s1">validateRootLayout: dev</span>
                <span class="s1">}),</span>
                <span class="s1">dynamicAccess: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">collectedRevalidate: prerenderStore !== </span><span class="s2">null </span><span class="s1">? prerenderStore.revalidate : _constants1.INFINITE_CACHE,</span>
                <span class="s1">collectedExpire: prerenderStore !== </span><span class="s2">null </span><span class="s1">? prerenderStore.expire : _constants1.INFINITE_CACHE,</span>
                <span class="s1">collectedStale: selectStaleTime(prerenderStore !== </span><span class="s2">null </span><span class="s1">? prerenderStore.stale : _constants1.INFINITE_CACHE),</span>
                <span class="s1">collectedTags: prerenderStore !== </span><span class="s2">null </span><span class="s1">? prerenderStore.tags : </span><span class="s2">null</span>
            <span class="s1">};</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(finalErr) {</span>
            <span class="s2">if </span><span class="s1">(process.env.NODE_ENV === </span><span class="s0">'development' </span><span class="s1">&amp;&amp; (</span><span class="s4">0</span><span class="s1">, _httpaccessfallback.isHTTPAccessFallbackError)(finalErr)) {</span>
                <span class="s2">const </span><span class="s1">{ bailOnRootNotFound } = require(</span><span class="s0">'../../client/components/dev-root-http-access-fallback-boundary'</span><span class="s1">);</span>
                <span class="s1">bailOnRootNotFound();</span>
            <span class="s1">}</span>
            <span class="s2">throw </span><span class="s1">finalErr;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">getGlobalErrorStyles = async (tree, ctx)=&gt;{</span>
    <span class="s2">const </span><span class="s1">{ modules: { </span><span class="s0">'global-error'</span><span class="s1">: globalErrorModule } } = (</span><span class="s4">0</span><span class="s1">, _parseloadertree.parseLoaderTree)(tree);</span>
    <span class="s2">const </span><span class="s1">GlobalErrorComponent = ctx.componentMod.GlobalError;</span>
    <span class="s2">let </span><span class="s1">globalErrorStyles;</span>
    <span class="s2">if </span><span class="s1">(globalErrorModule) {</span>
        <span class="s2">const </span><span class="s1">[, styles] = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _createcomponentstylesandscripts.createComponentStylesAndScripts)({</span>
            <span class="s1">ctx,</span>
            <span class="s1">filePath: globalErrorModule[</span><span class="s4">1</span><span class="s1">],</span>
            <span class="s1">getComponent: globalErrorModule[</span><span class="s4">0</span><span class="s1">],</span>
            <span class="s1">injectedCSS: </span><span class="s2">new </span><span class="s1">Set(),</span>
            <span class="s1">injectedJS: </span><span class="s2">new </span><span class="s1">Set()</span>
        <span class="s1">});</span>
        <span class="s1">globalErrorStyles = styles;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(ctx.renderOpts.dev) {</span>
        <span class="s2">const </span><span class="s1">dir = (process.env.NEXT_RUNTIME === </span><span class="s0">'edge' </span><span class="s1">? process.env.__NEXT_EDGE_PROJECT_DIR : ctx.renderOpts.dir) || </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">globalErrorModulePath = (</span><span class="s4">0</span><span class="s1">, _segmentexplorerpath.normalizeConventionFilePath)(dir, globalErrorModule == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: globalErrorModule[</span><span class="s4">1</span><span class="s1">]);</span>
        <span class="s2">if </span><span class="s1">(ctx.renderOpts.devtoolSegmentExplorer &amp;&amp; globalErrorModulePath) {</span>
            <span class="s2">const </span><span class="s1">SegmentViewNode = ctx.componentMod.SegmentViewNode;</span>
            <span class="s1">globalErrorStyles = </span><span class="s3">// This will be rendered next to GlobalError component under ErrorBoundary,</span>
            <span class="s3">// it requires a key to avoid React warning about duplicate keys.</span>
            <span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(SegmentViewNode, {</span>
                <span class="s1">type: </span><span class="s0">&quot;global-error&quot;</span><span class="s1">,</span>
                <span class="s1">pagePath: globalErrorModulePath,</span>
                <span class="s1">children: globalErrorStyles</span>
            <span class="s1">}, </span><span class="s0">&quot;ge-svn&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">GlobalError: GlobalErrorComponent,</span>
        <span class="s1">styles: globalErrorStyles</span>
    <span class="s1">};</span>
<span class="s1">};</span>
<span class="s2">function </span><span class="s1">createSelectStaleTime(experimental) {</span>
    <span class="s2">return </span><span class="s1">(stale)=&gt;{</span>
        <span class="s2">var </span><span class="s1">_experimental_staleTimes;</span>
        <span class="s2">return </span><span class="s1">stale === _constants1.INFINITE_CACHE &amp;&amp; </span><span class="s2">typeof </span><span class="s1">((_experimental_staleTimes = experimental.staleTimes) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _experimental_staleTimes.static) === </span><span class="s0">'number' </span><span class="s1">? experimental.staleTimes.static : stale;</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">collectSegmentData(fullPageDataBuffer, prerenderStore, ComponentMod, renderOpts) {</span>
    <span class="s3">// Per-segment prefetch data</span>
    <span class="s3">//</span>
    <span class="s3">// All of the segments for a page are generated simultaneously, including</span>
    <span class="s3">// during revalidations. This is to ensure consistency, because it's</span>
    <span class="s3">// possible for a mismatch between a layout and page segment can cause the</span>
    <span class="s3">// client to error during rendering. We want to preserve the ability of the</span>
    <span class="s3">// client to recover from such a mismatch by re-requesting all the segments</span>
    <span class="s3">// to get a consistent view of the page.</span>
    <span class="s3">//</span>
    <span class="s3">// For performance, we reuse the Flight output that was created when</span>
    <span class="s3">// generating the initial page HTML. The Flight stream for the whole page is</span>
    <span class="s3">// decomposed into a separate stream per segment.</span>
    <span class="s2">const </span><span class="s1">clientReferenceManifest = renderOpts.clientReferenceManifest;</span>
    <span class="s2">if </span><span class="s1">(!clientReferenceManifest || </span><span class="s3">// Do not generate per-segment data unless the experimental Segment Cache</span>
    <span class="s3">// flag is enabled.</span>
    <span class="s3">//</span>
    <span class="s3">// We also skip generating segment data if flag is set to &quot;client-only&quot;,</span>
    <span class="s3">// rather than true. (The &quot;client-only&quot; option only affects the behavior of</span>
    <span class="s3">// the client-side implementation; per-segment prefetches are intentionally</span>
    <span class="s3">// disabled in that configuration).</span>
    <span class="s1">renderOpts.experimental.clientSegmentCache !== </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">// Manifest passed to the Flight client for reading the full-page Flight</span>
    <span class="s3">// stream. Based off similar code in use-cache-wrapper.ts.</span>
    <span class="s2">const </span><span class="s1">isEdgeRuntime = process.env.NEXT_RUNTIME === </span><span class="s0">'edge'</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">serverConsumerManifest = {</span>
        <span class="s3">// moduleLoading must be null because we don't want to trigger preloads of ClientReferences</span>
        <span class="s3">// to be added to the consumer. Instead, we'll wait for any ClientReference to be emitted</span>
        <span class="s3">// which themselves will handle the preloading.</span>
        <span class="s1">moduleLoading: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">moduleMap: isEdgeRuntime ? clientReferenceManifest.edgeRscModuleMapping : clientReferenceManifest.rscModuleMapping,</span>
        <span class="s1">serverModuleMap: (</span><span class="s4">0</span><span class="s1">, _encryptionutils.getServerModuleMap)()</span>
    <span class="s1">};</span>
    <span class="s2">const </span><span class="s1">staleTime = prerenderStore.stale;</span>
    <span class="s2">return await </span><span class="s1">ComponentMod.collectSegmentData(renderOpts.experimental.clientParamParsing, fullPageDataBuffer, staleTime, clientReferenceManifest.clientModules, serverConsumerManifest);</span>
<span class="s1">}</span>

<span class="s3">//# sourceMappingURL=app-render.js.map</span></pre>
</body>
</html>