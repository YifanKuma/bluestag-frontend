<html>
<head>
<title>misc.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #0033b3;}
.s4 { color: #067d17;}
.s5 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
misc.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">Really small utility functions that didn't deserve their own files</span>
 <span class="s0">*/</span>
<span class="s3">import </span><span class="s2">type { TSESLint, TSESTree } from </span><span class="s4">'@typescript-eslint/utils'</span><span class="s2">;</span>
<span class="s3">import </span><span class="s2">type { RuleContext } from </span><span class="s4">'@typescript-eslint/utils/ts-eslint'</span><span class="s2">;</span>
<span class="s3">import </span><span class="s2">* as ts from </span><span class="s4">'typescript'</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* Check if the context file name is *.d.ts or *.d.tsx</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">isDefinitionFile(fileName: string): boolean;</span>
<span class="s0">/**</span>
 <span class="s0">* Upper cases the first character or the string</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">upperCaseFirst(str: string): string;</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">arrayGroupByToMap&lt;T, Key </span><span class="s3">extends </span><span class="s2">number | string&gt;(array: T[], getKey: (item: T) =&gt; Key): Map&lt;Key, T[]&gt;;</span>
<span class="s0">/** Return true if both parameters are equal. */</span>
<span class="s3">export </span><span class="s2">type Equal&lt;T&gt; = (a: T, b: T) =&gt; boolean;</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">arraysAreEqual&lt;T&gt;(a: T[] | undefined, b: T[] | undefined, eq: (a: T, b: T) =&gt; boolean): boolean;</span>
<span class="s0">/** Returns the first non-`undefined` result. */</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">findFirstResult&lt;T, U&gt;(inputs: T[], getResult: (t: T) =&gt; U | undefined): U | undefined;</span>
<span class="s0">/**</span>
 <span class="s0">* Gets a string representation of the name of the index signature.</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">getNameFromIndexSignature(node: TSESTree.TSIndexSignature): string;</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">enum </span><span class="s2">MemberNameType {</span>
    <span class="s2">Private = </span><span class="s5">1</span><span class="s2">,</span>
    <span class="s2">Quoted = </span><span class="s5">2</span><span class="s2">,</span>
    <span class="s2">Normal = </span><span class="s5">3</span><span class="s2">,</span>
    <span class="s2">Expression = </span><span class="s5">4</span>
<span class="s2">}</span>
<span class="s0">/**</span>
 <span class="s0">* Gets a string name representation of the name of the given MethodDefinition</span>
 <span class="s0">* or PropertyDefinition node, with handling for computed property names.</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">getNameFromMember(member: TSESTree.AccessorProperty | TSESTree.MethodDefinition | TSESTree.Property | TSESTree.PropertyDefinition | TSESTree.TSAbstractAccessorProperty | TSESTree.TSAbstractMethodDefinition | TSESTree.TSAbstractPropertyDefinition | TSESTree.TSMethodSignature | TSESTree.TSPropertySignature, sourceCode: TSESLint.SourceCode): {</span>
    <span class="s2">name: string;</span>
    <span class="s2">type: MemberNameType;</span>
<span class="s2">};</span>
<span class="s3">export </span><span class="s2">type ExcludeKeys&lt;Obj </span><span class="s3">extends </span><span class="s2">Record&lt;string, unknown&gt;, Keys </span><span class="s3">extends </span><span class="s2">keyof Obj&gt; = {</span>
    <span class="s2">[k </span><span class="s3">in </span><span class="s2">Exclude&lt;keyof Obj, Keys&gt;]: Obj[k];</span>
<span class="s2">};</span>
<span class="s3">export </span><span class="s2">type RequireKeys&lt;Obj </span><span class="s3">extends </span><span class="s2">Record&lt;string, unknown&gt;, Keys </span><span class="s3">extends </span><span class="s2">keyof Obj&gt; = {</span>
    <span class="s2">[k </span><span class="s3">in </span><span class="s2">Keys]-?: Exclude&lt;Obj[k], undefined&gt;;</span>
<span class="s2">} &amp; ExcludeKeys&lt;Obj, Keys&gt;;</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">getEnumNames&lt;T </span><span class="s3">extends </span><span class="s2">string&gt;(myEnum: Record&lt;T, unknown&gt;): T[];</span>
<span class="s0">/**</span>
 <span class="s0">* Given an array of words, returns an English-friendly concatenation, separated with commas, with</span>
 <span class="s0">* the `and` clause inserted before the last item.</span>
 <span class="s0">*</span>
 <span class="s0">* Example: ['foo', 'bar', 'baz' ] returns the string &quot;foo, bar, and baz&quot;.</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">formatWordList(words: string[]): string;</span>
<span class="s0">/**</span>
 <span class="s0">* Iterates the array in reverse and returns the index of the first element it</span>
 <span class="s0">* finds which passes the predicate function.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">Returns the index of the element if it finds it or -1 otherwise.</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">findLastIndex&lt;T&gt;(members: T[], predicate: (member: T) =&gt; boolean | </span><span class="s3">null </span><span class="s2">| undefined): number;</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">typeNodeRequiresParentheses(node: TSESTree.TypeNode, text: string): boolean;</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">isRestParameterDeclaration(decl: ts.Declaration): boolean;</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">isParenlessArrowFunction(node: TSESTree.ArrowFunctionExpression, sourceCode: TSESLint.SourceCode): boolean;</span>
<span class="s3">export </span><span class="s2">type NodeWithKey = TSESTree.AccessorProperty | TSESTree.MemberExpression | TSESTree.MethodDefinition | TSESTree.Property | TSESTree.PropertyDefinition | TSESTree.TSAbstractMethodDefinition | TSESTree.TSAbstractPropertyDefinition;</span>
<span class="s0">/**</span>
 <span class="s0">* Gets a member being accessed or declared if its value can be determined statically, and</span>
 <span class="s0">* resolves it to the string or symbol value that will be used as the actual member</span>
 <span class="s0">* access key at runtime. Otherwise, returns `undefined`.</span>
 <span class="s0">*</span>
 <span class="s0">* ```ts</span>
 <span class="s0">* x.member // returns 'member'</span>
 <span class="s0">* ^^^^^^^^</span>
 <span class="s0">*</span>
 <span class="s0">* x?.member // returns 'member' (optional chaining is treated the same)</span>
 <span class="s0">* ^^^^^^^^^</span>
 <span class="s0">*</span>
 <span class="s0">* x['value'] // returns 'value'</span>
 <span class="s0">* ^^^^^^^^^^</span>
 <span class="s0">*</span>
 <span class="s0">* x[Math.random()] // returns undefined (not a static value)</span>
 <span class="s0">* ^^^^^^^^^^^^^^^^</span>
 <span class="s0">*</span>
 <span class="s0">* arr[0] // returns '0' (NOT 0)</span>
 <span class="s0">* ^^^^^^</span>
 <span class="s0">*</span>
 <span class="s0">* arr[0n] // returns '0' (NOT 0n)</span>
 <span class="s0">* ^^^^^^^</span>
 <span class="s0">*</span>
 <span class="s0">* const s = Symbol.for('symbolName')</span>
 <span class="s0">* x[s] // returns `Symbol.for('symbolName')` (since it's a static/global symbol)</span>
 <span class="s0">* ^^^^</span>
 <span class="s0">*</span>
 <span class="s0">* const us = Symbol('symbolName')</span>
 <span class="s0">* x[us] // returns undefined (since it's a unique symbol, so not statically analyzable)</span>
 <span class="s0">* ^^^^^</span>
 <span class="s0">*</span>
 <span class="s0">* var object = {</span>
 <span class="s0">*     1234: '4567', // returns '1234' (NOT 1234)</span>
 <span class="s0">*     ^^^^^^^^^^^^</span>
 <span class="s0">*     method() { } // returns 'method'</span>
 <span class="s0">*     ^^^^^^^^^^^^</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* class WithMembers {</span>
 <span class="s0">*     foo: string // returns 'foo'</span>
 <span class="s0">*     ^^^^^^^^^^^</span>
 <span class="s0">* }</span>
 <span class="s0">* ```</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">getStaticMemberAccessValue(node: NodeWithKey, { sourceCode }: RuleContext&lt;string, unknown[]&gt;): string | symbol | undefined;</span>
<span class="s0">/**</span>
 <span class="s0">* Answers whether the member expression looks like</span>
 <span class="s0">* `x.value`, `x['value']`,</span>
 <span class="s0">* or even `const v = 'value'; x[v]` (or optional variants thereof).</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isStaticMemberAccessOfValue: (memberExpression: NodeWithKey, context: RuleContext&lt;string, unknown[]&gt;, ...values: (string | symbol)[]) =&gt; boolean;</span>
</pre>
</body>
</html>