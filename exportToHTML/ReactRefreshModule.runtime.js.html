<html>
<head>
<title>ReactRefreshModule.runtime.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ReactRefreshModule.runtime.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">exports.default = default_1;</span>
<span class="s3">// This function gets unwrapped into global scope, which is why we don't invert</span>
<span class="s3">// if-blocks. Also, you cannot use `return`.</span>
<span class="s2">function </span><span class="s1">default_1() {</span>
    <span class="s3">// Wrapped in an IIFE to avoid polluting the global scope</span>
    <span class="s1">;</span>
    <span class="s1">(</span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s2">var </span><span class="s1">_a, _b;</span>
        <span class="s3">// Legacy CSS implementations will `eval` browser code in a Node.js context</span>
        <span class="s3">// to extract CSS. For backwards compatibility, we need to check we're in a</span>
        <span class="s3">// browser context before continuing.</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">self !== </span><span class="s0">'undefined' </span><span class="s1">&amp;&amp;</span>
            <span class="s3">// AMP / No-JS mode does not inject these helpers:</span>
            <span class="s0">'$RefreshHelpers$' </span><span class="s2">in </span><span class="s1">self) {</span>
            <span class="s3">// @ts-ignore __webpack_module__ is global</span>
            <span class="s2">var </span><span class="s1">currentExports = __webpack_module__.exports;</span>
            <span class="s3">// @ts-ignore __webpack_module__ is global</span>
            <span class="s2">var </span><span class="s1">prevSignature = (_b = (_a = __webpack_module__.hot.data) === </span><span class="s2">null </span><span class="s1">|| _a === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _a.prevSignature) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _b !== </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? _b : </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s3">// This cannot happen in MainTemplate because the exports mismatch between</span>
            <span class="s3">// templating and execution.</span>
            <span class="s1">self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);</span>
            <span class="s3">// A module can be accepted automatically based on its exports, e.g. when</span>
            <span class="s3">// it is a Refresh Boundary.</span>
            <span class="s2">if </span><span class="s1">(self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {</span>
                <span class="s3">// Save the previous exports signature on update so we can compare the boundary</span>
                <span class="s3">// signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)</span>
                <span class="s1">__webpack_module__.hot.dispose(</span><span class="s2">function </span><span class="s1">(data) {</span>
                    <span class="s1">data.prevSignature =</span>
                        <span class="s1">self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);</span>
                <span class="s1">});</span>
                <span class="s3">// Unconditionally accept an update to this module, we'll check if it's</span>
                <span class="s3">// still a Refresh Boundary later.</span>
                <span class="s3">// @ts-ignore importMeta is replaced in the loader</span>
                <span class="s1">global.importMeta.webpackHot.accept();</span>
                <span class="s3">// This field is set when the previous version of this module was a</span>
                <span class="s3">// Refresh Boundary, letting us know we need to check for invalidation or</span>
                <span class="s3">// enqueue an update.</span>
                <span class="s2">if </span><span class="s1">(prevSignature !== </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s3">// A boundary can become ineligible if its exports are incompatible</span>
                    <span class="s3">// with the previous exports.</span>
                    <span class="s3">//</span>
                    <span class="s3">// For example, if you add/remove/change exports, we'll want to</span>
                    <span class="s3">// re-execute the importing modules, and force those components to</span>
                    <span class="s3">// re-render. Similarly, if you convert a class component to a</span>
                    <span class="s3">// function, we want to invalidate the boundary.</span>
                    <span class="s2">if </span><span class="s1">(self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {</span>
                        <span class="s1">__webpack_module__.hot.invalidate();</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">self.$RefreshHelpers$.scheduleUpdate();</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s3">// Since we just executed the code for the module, it's possible that the</span>
                <span class="s3">// new exports made it ineligible for being a boundary.</span>
                <span class="s3">// We only care about the case when we were _previously_ a boundary,</span>
                <span class="s3">// because we already accepted this update (accidental side effect).</span>
                <span class="s2">var </span><span class="s1">isNoLongerABoundary = prevSignature !== </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(isNoLongerABoundary) {</span>
                    <span class="s1">__webpack_module__.hot.invalidate();</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">})();</span>
<span class="s1">}</span>
<span class="s3">//# sourceMappingURL=ReactRefreshModule.runtime.js.map</span></pre>
</body>
</html>