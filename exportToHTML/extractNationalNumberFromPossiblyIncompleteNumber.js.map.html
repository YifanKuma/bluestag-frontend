<html>
<head>
<title>extractNationalNumberFromPossiblyIncompleteNumber.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
extractNationalNumberFromPossiblyIncompleteNumber.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;extractNationalNumberFromPossiblyIncompleteNumber.js&quot;</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;extractNationalNumberFromPossiblyIncompleteNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;number&quot;</span><span class="s0">,</span><span class="s1">&quot;metadata&quot;</span><span class="s0">,</span><span class="s1">&quot;numberingPlan&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalPrefixForParsing&quot;</span><span class="s0">,</span><span class="s1">&quot;prefixPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;prefixMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;exec&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;carrierCode&quot;</span><span class="s0">,</span><span class="s1">&quot;capturedGroupsCount&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;hasCapturedGroups&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalPrefixTransformRule&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;prefixBeforeNationalNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;possiblePositionOfTheFirstCapturedGroup&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;possibleNationalPrefix&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../source/helpers/extractNationalNumberFromPossiblyIncompleteNumber.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\r\n </span><span class="s1">* Strips any national prefix (such as 0, 1) present in a</span><span class="s3">\r\n </span><span class="s1">* (possibly incomplete) number provided.</span><span class="s3">\r\n </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">Carrier codes</span><span class="s3">\&quot; </span><span class="s1">are only used  in Colombia and Brazil,</span><span class="s3">\r\n </span><span class="s1">* and only when dialing within those countries from a mobile phone to a fixed line number.</span><span class="s3">\r\n </span><span class="s1">* Sometimes it won't actually strip national prefix</span><span class="s3">\r\n </span><span class="s1">* and will instead prepend some digits to the `number`:</span><span class="s3">\r\n </span><span class="s1">* for example, when number `2345678` is passed with `VI` country selected,</span><span class="s3">\r\n </span><span class="s1">* it will return `{ number: </span><span class="s3">\&quot;</span><span class="s1">3402345678</span><span class="s3">\&quot; </span><span class="s1">}`, because `340` area code is prepended.</span><span class="s3">\r\n </span><span class="s1">* @param {string} number — National number digits.</span><span class="s3">\r\n </span><span class="s1">* @param {object} metadata — Metadata with country selected.</span><span class="s3">\r\n </span><span class="s1">* @return {object} `{ nationalNumber: string, nationalPrefix: string? carrierCode: string? }`. Even if a national prefix was extracted, it's not necessarily present in the returned object, so don't rely on its presence in the returned object in order to find out whether a national prefix has been extracted or not.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\r\n</span><span class="s1">export default function extractNationalNumberFromPossiblyIncompleteNumber(number, metadata) {</span><span class="s3">\r\n\t</span><span class="s1">if (number &amp;&amp; metadata.numberingPlan.nationalPrefixForParsing()) {</span><span class="s3">\r\n\t\t</span><span class="s1">// See METADATA.md for the description of</span><span class="s3">\r\n\t\t</span><span class="s1">// `national_prefix_for_parsing` and `national_prefix_transform_rule`.</span><span class="s3">\r\n\t\t</span><span class="s1">// Attempt to parse the first digits as a national prefix.</span><span class="s3">\r\n\t\t</span><span class="s1">const prefixPattern = new RegExp('^(?:' + metadata.numberingPlan.nationalPrefixForParsing() + ')')</span><span class="s3">\r\n\t\t</span><span class="s1">const prefixMatch = prefixPattern.exec(number)</span><span class="s3">\r\n\t\t</span><span class="s1">if (prefixMatch) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">let nationalNumber</span><span class="s3">\r\n\t\t\t</span><span class="s1">let carrierCode</span><span class="s3">\r\n\t\t\t</span><span class="s1">// https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule</span><span class="s3">\r\n\t\t\t</span><span class="s1">// If a `national_prefix_for_parsing` has any </span><span class="s3">\&quot;</span><span class="s1">capturing groups</span><span class="s3">\&quot;\r\n\t\t\t</span><span class="s1">// then it means that the national (significant) number is equal to</span><span class="s3">\r\n\t\t\t</span><span class="s1">// those </span><span class="s3">\&quot;</span><span class="s1">capturing groups</span><span class="s3">\&quot; </span><span class="s1">transformed via `national_prefix_transform_rule`,</span><span class="s3">\r\n\t\t\t</span><span class="s1">// and nothing could be said about the actual national prefix:</span><span class="s3">\r\n\t\t\t</span><span class="s1">// what is it and was it even there.</span><span class="s3">\r\n\t\t\t</span><span class="s1">// If a `national_prefix_for_parsing` doesn't have any </span><span class="s3">\&quot;</span><span class="s1">capturing groups</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\r\n\t\t\t</span><span class="s1">// then everything it matches is a national prefix.</span><span class="s3">\r\n\t\t\t</span><span class="s1">// To determine whether `national_prefix_for_parsing` matched any</span><span class="s3">\r\n\t\t\t</span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">capturing groups</span><span class="s3">\&quot;</span><span class="s1">, the value of the result of calling `.exec()`</span><span class="s3">\r\n\t\t\t</span><span class="s1">// is looked at, and if it has non-undefined values where there're</span><span class="s3">\r\n\t\t\t</span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">capturing groups</span><span class="s3">\&quot; </span><span class="s1">in the regular expression, then it means</span><span class="s3">\r\n\t\t\t</span><span class="s1">// that </span><span class="s3">\&quot;</span><span class="s1">capturing groups</span><span class="s3">\&quot; </span><span class="s1">have been matched.</span><span class="s3">\r\n\t\t\t</span><span class="s1">// It's not possible to tell whether there'll be any </span><span class="s3">\&quot;</span><span class="s1">capturing gropus</span><span class="s3">\&quot;\r\n\t\t\t</span><span class="s1">// before the matching process, because a `national_prefix_for_parsing`</span><span class="s3">\r\n\t\t\t</span><span class="s1">// could exhibit both behaviors.</span><span class="s3">\r\n\t\t\t</span><span class="s1">const capturedGroupsCount = prefixMatch.length - 1</span><span class="s3">\r\n\t\t\t</span><span class="s1">const hasCapturedGroups = capturedGroupsCount &gt; 0 &amp;&amp; prefixMatch[capturedGroupsCount]</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (metadata.nationalPrefixTransformRule() &amp;&amp; hasCapturedGroups) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">nationalNumber = number.replace(</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">prefixPattern,</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">metadata.nationalPrefixTransformRule()</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">)</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// If there's more than one captured group,</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// then carrier code is the second one.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">if (capturedGroupsCount &gt; 1) {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">carrierCode = prefixMatch[1]</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">// If there're no </span><span class="s3">\&quot;</span><span class="s1">capturing groups</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\r\n\t\t\t</span><span class="s1">// or if there're </span><span class="s3">\&quot;</span><span class="s1">capturing groups</span><span class="s3">\&quot; </span><span class="s1">but no</span><span class="s3">\r\n\t\t\t</span><span class="s1">// `national_prefix_transform_rule`,</span><span class="s3">\r\n\t\t\t</span><span class="s1">// then just strip the national prefix from the number,</span><span class="s3">\r\n\t\t\t</span><span class="s1">// and possibly a carrier code.</span><span class="s3">\r\n\t\t\t</span><span class="s1">// Seems like there could be more.</span><span class="s3">\r\n\t\t\t</span><span class="s1">else {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// `prefixBeforeNationalNumber` is the whole substring matched by</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// the `national_prefix_for_parsing` regular expression.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// There seem to be no guarantees that it's just a national prefix.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// For example, if there's a carrier code, it's gonna be a</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// part of `prefixBeforeNationalNumber` too.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">const prefixBeforeNationalNumber = prefixMatch[0]</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">nationalNumber = number.slice(prefixBeforeNationalNumber.length)</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// If there's at least one captured group,</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// then carrier code is the first one.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">if (hasCapturedGroups) {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">carrierCode = prefixMatch[1]</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">// Tries to guess whether a national prefix was present in the input.</span><span class="s3">\r\n\t\t\t</span><span class="s1">// This is not something copy-pasted from Google's library:</span><span class="s3">\r\n\t\t\t</span><span class="s1">// they don't seem to have an equivalent for that.</span><span class="s3">\r\n\t\t\t</span><span class="s1">// So this isn't an </span><span class="s3">\&quot;</span><span class="s1">officially approved</span><span class="s3">\&quot; </span><span class="s1">way of doing something like that.</span><span class="s3">\r\n\t\t\t</span><span class="s1">// But since there seems no other existing method, this library uses it.</span><span class="s3">\r\n\t\t\t</span><span class="s1">let nationalPrefix</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (hasCapturedGroups) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">const possiblePositionOfTheFirstCapturedGroup = number.indexOf(prefixMatch[1])</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">const possibleNationalPrefix = number.slice(0, possiblePositionOfTheFirstCapturedGroup)</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// Example: an Argentinian (AR) phone number `0111523456789`.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// `prefixMatch[0]` is `01115`, and `$1` is `11`,</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// and the rest of the phone number is `23456789`.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// The national number is transformed via `9$1` to `91123456789`.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// National prefix `0` is detected being present at the start.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// if (possibleNationalPrefix.indexOf(metadata.numberingPlan.nationalPrefix()) === 0) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">if (possibleNationalPrefix === metadata.numberingPlan.nationalPrefix()) {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">nationalPrefix = metadata.numberingPlan.nationalPrefix()</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">nationalPrefix = prefixMatch[0]</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">return {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">nationalNumber,</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">nationalPrefix,</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">carrierCode</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n   </span><span class="s1">return {</span><span class="s3">\r\n   \t</span><span class="s1">nationalNumber: number</span><span class="s3">\r\n   </span><span class="s1">}</span><span class="s3">\r\n</span><span class="s1">}&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,SAASA,iDAAiDA,CAACC,MAAM,EAAEC,QAAQ,EAAE;EAC3F,IAAID,MAAM,IAAIC,QAAQ,CAACC,aAAa,CAACC,wBAAwB,CAAC,CAAC,EAAE;IAChE;IACA;IACA;IACA,IAAMC,aAAa,GAAG,IAAIC,MAAM,CAAC,MAAM,GAAGJ,QAAQ,CAACC,aAAa,CAACC,wBAAwB,CAAC,CAAC,GAAG,GAAG,CAAC;IAClG,IAAMG,WAAW,GAAGF,aAAa,CAACG,IAAI,CAACP,MAAM,CAAC;IAC9C,IAAIM,WAAW,EAAE;MAChB,IAAIE,cAAc;MAClB,IAAIC,WAAW;MACf;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAMC,mBAAmB,GAAGJ,WAAW,CAACK,MAAM,GAAG,CAAC;MAClD,IAAMC,iBAAiB,GAAGF,mBAAmB,GAAG,CAAC,IAAIJ,WAAW,CAACI,mBAAmB,CAAC;MACrF,IAAIT,QAAQ,CAACY,2BAA2B,CAAC,CAAC,IAAID,iBAAiB,EAAE;QAChEJ,cAAc,GAAGR,MAAM,CAACc,OAAO,CAC9BV,aAAa,EACbH,QAAQ,CAACY,2BAA2B,CAAC,CACtC,CAAC;QACD;QACA;QACA,IAAIH,mBAAmB,GAAG,CAAC,EAAE;UAC5BD,WAAW,GAAGH,WAAW,CAAC,CAAC,CAAC;QAC7B;MACD;MACA;MACA;MACA;MACA;MACA;MACA;MAAA,KACK;QACJ;QACA;QACA;QACA;QACA;QACA,IAAMS,0BAA0B,GAAGT,WAAW,CAAC,CAAC,CAAC;QACjDE,cAAc,GAAGR,MAAM,CAACgB,KAAK,CAACD,0BAA0B,CAACJ,MAAM,CAAC;QAChE;QACA;QACA,IAAIC,iBAAiB,EAAE;UACtBH,WAAW,GAAGH,WAAW,CAAC,CAAC,CAAC;QAC7B;MACD;MACA;MACA;MACA;MACA;MACA;MACA,IAAIW,cAAc;MAClB,IAAIL,iBAAiB,EAAE;QACtB,IAAMM,uCAAuC,GAAGlB,MAAM,CAACmB,OAAO,CAACb,WAAW,CAAC,CAAC,CAAC,CAAC;QAC9E,IAAMc,sBAAsB,GAAGpB,MAAM,CAACgB,KAAK,CAAC,CAAC,EAAEE,uCAAuC,CAAC;QACvF;QACA;QACA;QACA;QACA;QACA;QACA,IAAIE,sBAAsB,KAAKnB,QAAQ,CAACC,aAAa,CAACe,cAAc,CAAC,CAAC,EAAE;UACvEA,cAAc,GAAGhB,QAAQ,CAACC,aAAa,CAACe,cAAc,CAAC,CAAC;QACzD;MACD,CAAC,MAAM;QACNA,cAAc,GAAGX,WAAW,CAAC,CAAC,CAAC;MAChC;MACA,OAAO;QACNE,cAAc,EAAdA,cAAc;QACdS,cAAc,EAAdA,cAAc;QACdR,WAAW,EAAXA;MACD,CAAC;IACF;EACD;EACE,OAAO;IACND,cAAc,EAAER;EACjB,CAAC;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>