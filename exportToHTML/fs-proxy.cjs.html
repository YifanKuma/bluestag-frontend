<html>
<head>
<title>fs-proxy.cjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #8c8c8c; font-style: italic;}
.s3 { color: #0033b3;}
.s4 { color: #1750eb;}
.s5 { color: #067d17;}
.s6 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
fs-proxy.cjs</font>
</center></td></tr></table>
<pre><span class="s0">// @ts-check</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s2">@param </span><span class="s0">{unknown} value</span>
 <span class="s0">*/</span>
<span class="s3">const </span><span class="s1">getType = (value) =&gt; {</span>
  <span class="s3">if </span><span class="s1">(value === undefined) </span><span class="s3">return </span><span class="s4">0</span>
  <span class="s3">if </span><span class="s1">(value === </span><span class="s3">null</span><span class="s1">) </span><span class="s3">return </span><span class="s4">1</span>
  <span class="s3">const </span><span class="s1">t = </span><span class="s3">typeof </span><span class="s1">value</span>
  <span class="s3">if </span><span class="s1">(t === </span><span class="s5">'boolean'</span><span class="s1">) </span><span class="s3">return </span><span class="s4">2</span>
  <span class="s3">if </span><span class="s1">(t === </span><span class="s5">'number'</span><span class="s1">) </span><span class="s3">return </span><span class="s4">3</span>
  <span class="s3">if </span><span class="s1">(t === </span><span class="s5">'string'</span><span class="s1">) </span><span class="s3">return </span><span class="s4">4</span>
  <span class="s3">if </span><span class="s1">(t === </span><span class="s5">'object'</span><span class="s1">) </span><span class="s3">return </span><span class="s4">6</span>
  <span class="s3">if </span><span class="s1">(t === </span><span class="s5">'bigint'</span><span class="s1">) </span><span class="s3">return </span><span class="s4">9</span>
  <span class="s3">return </span><span class="s1">-</span><span class="s4">1</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s2">@param </span><span class="s0">{import('memfs').IFs} memfs</span>
 <span class="s0">* </span><span class="s2">@param </span><span class="s0">{any} value</span>
 <span class="s0">* </span><span class="s2">@param </span><span class="s0">{ReturnType&lt;typeof getType&gt;} type</span>
 <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Uint8Array}</span>
 <span class="s0">*/</span>
<span class="s3">const </span><span class="s1">encodeValue = (memfs, value, type) =&gt; {</span>
  <span class="s3">switch </span><span class="s1">(type) {</span>
    <span class="s3">case </span><span class="s4">0</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
      <span class="s3">return new </span><span class="s1">Uint8Array(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s3">case </span><span class="s4">2</span><span class="s1">: {</span>
      <span class="s3">const </span><span class="s1">view = </span><span class="s3">new </span><span class="s1">Int32Array(</span><span class="s4">1</span><span class="s1">)</span>
      <span class="s1">view[</span><span class="s4">0</span><span class="s1">] = value ? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span>
      <span class="s3">return new </span><span class="s1">Uint8Array(view.buffer)</span>
    <span class="s1">}</span>
    <span class="s3">case </span><span class="s4">3</span><span class="s1">: {</span>
      <span class="s3">const </span><span class="s1">view = </span><span class="s3">new </span><span class="s1">Float64Array(</span><span class="s4">1</span><span class="s1">)</span>
      <span class="s1">view[</span><span class="s4">0</span><span class="s1">] = value</span>
      <span class="s3">return new </span><span class="s1">Uint8Array(view.buffer)</span>
    <span class="s1">}</span>
    <span class="s3">case </span><span class="s4">4</span><span class="s1">: {</span>
      <span class="s3">const </span><span class="s1">view = </span><span class="s3">new </span><span class="s1">TextEncoder().encode(value)</span>
      <span class="s3">return </span><span class="s1">view</span>
    <span class="s1">}</span>
    <span class="s3">case </span><span class="s4">6</span><span class="s1">: {</span>
      <span class="s3">const </span><span class="s1">[entry] = Object.entries(memfs).filter(([_, v]) =&gt; v === value.constructor)[</span><span class="s4">0</span><span class="s1">] ?? []</span>
      <span class="s3">if </span><span class="s1">(entry) {</span>
        <span class="s1">Object.defineProperty(value, </span><span class="s5">'__constructor__'</span><span class="s1">, {</span>
          <span class="s1">configurable: </span><span class="s3">true</span><span class="s1">,</span>
          <span class="s1">writable: </span><span class="s3">true</span><span class="s1">,</span>
          <span class="s1">enumerable: </span><span class="s3">true</span><span class="s1">,</span>
          <span class="s1">value: entry</span>
        <span class="s1">})</span>
      <span class="s1">}</span>

      <span class="s3">const </span><span class="s1">json = JSON.stringify(value, (_, value) =&gt; {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">value === </span><span class="s5">'bigint'</span><span class="s1">) {</span>
          <span class="s3">return </span><span class="s5">`BigInt(</span><span class="s1">${String(value)}</span><span class="s5">)`</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(value </span><span class="s3">instanceof </span><span class="s1">Error) {</span>
          <span class="s3">return </span><span class="s1">{</span>
            <span class="s1">...value,</span>
            <span class="s1">message: value.message,</span>
            <span class="s1">stack: value.stack,</span>
            <span class="s1">__error__: value.constructor.name,</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">value</span>
      <span class="s1">})</span>
      <span class="s3">const </span><span class="s1">view = </span><span class="s3">new </span><span class="s1">TextEncoder().encode(json)</span>
      <span class="s3">return </span><span class="s1">view</span>
    <span class="s1">}</span>
    <span class="s3">case </span><span class="s4">9</span><span class="s1">: {</span>
      <span class="s3">const </span><span class="s1">view = </span><span class="s3">new </span><span class="s1">BigInt64Array(</span><span class="s4">1</span><span class="s1">)</span>
      <span class="s1">view[</span><span class="s4">0</span><span class="s1">] = value</span>
      <span class="s3">return new </span><span class="s1">Uint8Array(view.buffer)</span>
    <span class="s1">}</span>
    <span class="s3">case </span><span class="s1">-</span><span class="s4">1</span><span class="s1">:</span>
    <span class="s3">default</span><span class="s1">:</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s5">'unsupported data'</span><span class="s1">)</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s2">@param </span><span class="s0">{typeof import('memfs')} memfs</span>
 <span class="s0">* </span><span class="s2">@param </span><span class="s0">{Uint8Array} payload</span>
 <span class="s0">* </span><span class="s2">@param </span><span class="s0">{number} type</span>
 <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{any}</span>
 <span class="s0">*/</span>
<span class="s3">const </span><span class="s1">decodeValue = (memfs, payload, type) =&gt; {</span>
  <span class="s3">if </span><span class="s1">(type === </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return </span><span class="s1">undefined</span>
  <span class="s3">if </span><span class="s1">(type === </span><span class="s4">1</span><span class="s1">) </span><span class="s3">return null</span>
  <span class="s3">if </span><span class="s1">(type === </span><span class="s4">2</span><span class="s1">) </span><span class="s3">return </span><span class="s1">Boolean(</span><span class="s3">new </span><span class="s1">Int32Array(payload.buffer, payload.byteOffset, </span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">])</span>
  <span class="s3">if </span><span class="s1">(type === </span><span class="s4">3</span><span class="s1">) </span><span class="s3">return new </span><span class="s1">Float64Array(payload.buffer, payload.byteOffset, </span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
  <span class="s3">if </span><span class="s1">(type === </span><span class="s4">4</span><span class="s1">) </span><span class="s3">return new </span><span class="s1">TextDecoder().decode(payload.slice())</span>
  <span class="s3">if </span><span class="s1">(type === </span><span class="s4">6</span><span class="s1">) {</span>
    <span class="s3">const </span><span class="s1">obj = JSON.parse(</span><span class="s3">new </span><span class="s1">TextDecoder().decode(payload.slice()), (_key, value) =&gt; {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">value === </span><span class="s5">'string'</span><span class="s1">) {</span>
        <span class="s3">const </span><span class="s1">matched = value.match(</span><span class="s6">/^BigInt\((-?\d+)\)$/</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">(matched &amp;&amp; matched[</span><span class="s4">1</span><span class="s1">]) {</span>
          <span class="s3">return </span><span class="s1">BigInt(matched[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s3">return </span><span class="s1">value</span>
    <span class="s1">})</span>
    <span class="s3">if </span><span class="s1">(obj.__constructor__) {</span>
      <span class="s3">const </span><span class="s1">ctor = obj.__constructor__</span>
      <span class="s3">delete </span><span class="s1">obj.__constructor__</span>
      <span class="s1">Object.setPrototypeOf(obj, memfs[ctor].prototype)</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(obj.__error__) {</span>
      <span class="s3">const </span><span class="s1">name = obj.__error__</span>
      <span class="s3">const </span><span class="s1">ErrorConstructor = globalThis[name] || Error</span>
      <span class="s3">delete </span><span class="s1">obj.__error__</span>
      <span class="s3">const </span><span class="s1">err = </span><span class="s3">new </span><span class="s1">ErrorConstructor(obj.message)</span>
      <span class="s1">Object.defineProperty(err, </span><span class="s5">'stack'</span><span class="s1">, {</span>
        <span class="s1">configurable: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">writable: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">value: err.stack</span>
      <span class="s1">})</span>
      <span class="s1">Object.defineProperty(err, Symbol.toStringTag, {</span>
        <span class="s1">configurable: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">writable: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">value: name</span>
      <span class="s1">})</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">[k, v] of Object.entries(obj)) {</span>
        <span class="s3">if </span><span class="s1">(k === </span><span class="s5">'message' </span><span class="s1">|| k === </span><span class="s5">'stack'</span><span class="s1">) </span><span class="s3">continue</span>
        <span class="s1">err[k] = v</span>
      <span class="s1">}</span>
      <span class="s3">return </span><span class="s1">err</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">obj</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(type === </span><span class="s4">9</span><span class="s1">) </span><span class="s3">return new </span><span class="s1">BigInt64Array(payload.buffer, payload.byteOffset, </span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
  <span class="s3">throw new </span><span class="s1">Error(</span><span class="s5">'unsupported data'</span><span class="s1">)</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s2">@param </span><span class="s0">{import('memfs').IFs} fs</span>
 <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{(e: { data: { __fs__: { sab: Int32Array, type: keyof import('memfs').IFs, payload: any[] } } }) =&gt; void}</span>
 <span class="s0">*/</span>
<span class="s0">// oxlint-disable-next-line no-unused-vars -- fixed in an upcoming release</span>
<span class="s1">module.exports.createOnMessage = (fs) =&gt; </span><span class="s3">function </span><span class="s1">onMessage(e) {</span>
  <span class="s3">if </span><span class="s1">(e.data.__fs__) {</span>
    <span class="s0">/**</span>
     <span class="s0">* 0..4                    status(int32_t):        21(waiting) 0(success) 1(error)</span>
     <span class="s0">* 5..8                    type(napi_valuetype):   0(undefined) 1(null) 2(boolean) 3(number) 4(string) 6(jsonstring) 9(bigint) -1(unsupported)</span>
     <span class="s0">* 9..16                   payload_size(uint32_t)  &lt;= 1024</span>
     <span class="s0">* 16..16 + payload_size   payload_content</span>
     <span class="s0">*/</span>
    <span class="s3">const </span><span class="s1">{ sab, type, payload } = e.data.__fs__</span>
    <span class="s3">const </span><span class="s1">fn = fs[type]</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">const </span><span class="s1">ret = fn.apply(fs, payload)</span>
      <span class="s3">const </span><span class="s1">t = getType(ret)</span>
      <span class="s1">Atomics.store(sab, </span><span class="s4">1</span><span class="s1">, t)</span>
      <span class="s3">const </span><span class="s1">v = encodeValue(fs, ret, t)</span>
      <span class="s1">Atomics.store(sab, </span><span class="s4">2</span><span class="s1">, v.length)</span>
      <span class="s3">new </span><span class="s1">Uint8Array(sab.buffer).set(v, </span><span class="s4">16</span><span class="s1">)</span>
      <span class="s1">Atomics.store(sab, </span><span class="s4">0</span><span class="s1">, </span><span class="s4">0</span><span class="s1">) </span><span class="s0">// success</span>

    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(</span><span class="s0">/** </span><span class="s2">@type </span><span class="s0">{any} */ </span><span class="s1">err) {</span>
      <span class="s3">const </span><span class="s1">t = getType(err)</span>
      <span class="s1">Atomics.store(sab, </span><span class="s4">1</span><span class="s1">, t)</span>
      <span class="s3">const </span><span class="s1">v = encodeValue(fs, err, t)</span>
      <span class="s1">Atomics.store(sab, </span><span class="s4">2</span><span class="s1">, v.length)</span>
      <span class="s3">new </span><span class="s1">Uint8Array(sab.buffer).set(v, </span><span class="s4">16</span><span class="s1">)</span>
      <span class="s1">Atomics.store(sab, </span><span class="s4">0</span><span class="s1">, </span><span class="s4">1</span><span class="s1">) </span><span class="s0">// error</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s1">Atomics.notify(sab, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s2">@param </span><span class="s0">{typeof import('memfs')} memfs</span>
 <span class="s0">*/</span>
<span class="s1">module.exports.createFsProxy = (memfs) =&gt; </span><span class="s3">new </span><span class="s1">Proxy({}, {</span>
  <span class="s1">get (_target, p, _receiver) {</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{any[]} args</span>
     <span class="s0">*/</span>
    <span class="s3">return function </span><span class="s1">(...args) {</span>
      <span class="s3">const </span><span class="s1">sab = </span><span class="s3">new </span><span class="s1">SharedArrayBuffer(</span><span class="s4">16 </span><span class="s1">+ </span><span class="s4">10240</span><span class="s1">)</span>
      <span class="s3">const </span><span class="s1">i32arr = </span><span class="s3">new </span><span class="s1">Int32Array(sab)</span>
      <span class="s1">Atomics.store(i32arr, </span><span class="s4">0</span><span class="s1">, </span><span class="s4">21</span><span class="s1">)</span>

      <span class="s1">postMessage({</span>
        <span class="s1">__fs__: {</span>
          <span class="s1">sab: i32arr,</span>
          <span class="s1">type: p,</span>
          <span class="s1">payload: args</span>
        <span class="s1">}</span>
      <span class="s1">})</span>

      <span class="s1">Atomics.wait(i32arr, </span><span class="s4">0</span><span class="s1">, </span><span class="s4">21</span><span class="s1">)</span>

      <span class="s3">const </span><span class="s1">status = Atomics.load(i32arr, </span><span class="s4">0</span><span class="s1">)</span>
      <span class="s3">const </span><span class="s1">type = Atomics.load(i32arr, </span><span class="s4">1</span><span class="s1">)</span>
      <span class="s3">const </span><span class="s1">size = Atomics.load(i32arr, </span><span class="s4">2</span><span class="s1">)</span>
      <span class="s3">const </span><span class="s1">content = </span><span class="s3">new </span><span class="s1">Uint8Array(sab, </span><span class="s4">16</span><span class="s1">, size)</span>
      <span class="s3">const </span><span class="s1">value = decodeValue(memfs, content, type)</span>
      <span class="s3">if </span><span class="s1">(status === </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s3">throw </span><span class="s1">value</span>
      <span class="s1">}</span>
      <span class="s3">return </span><span class="s1">value</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">})</span>
</pre>
</body>
</html>