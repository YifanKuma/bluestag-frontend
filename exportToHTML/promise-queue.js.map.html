<html>
<head>
<title>promise-queue.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
promise-queue.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/client/components/promise-queue.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/*</span><span class="s3">\n    </span><span class="s1">This is a simple promise queue that allows you to limit the number of concurrent promises</span><span class="s3">\n    </span><span class="s1">that are running at any given time. It's used to limit the number of concurrent</span><span class="s3">\n    </span><span class="s1">prefetch requests that are being made to the server but could be used for other</span><span class="s3">\n    </span><span class="s1">things as well.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class PromiseQueue {</span><span class="s3">\n  </span><span class="s1">#maxConcurrency: number</span><span class="s3">\n  </span><span class="s1">#runningCount: number</span><span class="s3">\n  </span><span class="s1">#queue: Array&lt;{</span><span class="s3">\n    </span><span class="s1">promiseFn: Promise&lt;any&gt;</span><span class="s3">\n    </span><span class="s1">task: () =&gt; void</span><span class="s3">\n  </span><span class="s1">}&gt;</span><span class="s3">\n\n  </span><span class="s1">constructor(maxConcurrency = 5) {</span><span class="s3">\n    </span><span class="s1">this.#maxConcurrency = maxConcurrency</span><span class="s3">\n    </span><span class="s1">this.#runningCount = 0</span><span class="s3">\n    </span><span class="s1">this.#queue = []</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">enqueue&lt;T&gt;(promiseFn: () =&gt; Promise&lt;T&gt;): Promise&lt;T&gt; {</span><span class="s3">\n    </span><span class="s1">let taskResolve: (value: T | PromiseLike&lt;T&gt;) =&gt; void</span><span class="s3">\n    </span><span class="s1">let taskReject: (reason?: any) =&gt; void</span><span class="s3">\n\n    </span><span class="s1">const taskPromise = new Promise((resolve, reject) =&gt; {</span><span class="s3">\n      </span><span class="s1">taskResolve = resolve</span><span class="s3">\n      </span><span class="s1">taskReject = reject</span><span class="s3">\n    </span><span class="s1">}) as Promise&lt;T&gt;</span><span class="s3">\n\n    </span><span class="s1">const task = async () =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">this.#runningCount++</span><span class="s3">\n        </span><span class="s1">const result = await promiseFn()</span><span class="s3">\n        </span><span class="s1">taskResolve(result)</span><span class="s3">\n      </span><span class="s1">} catch (error) {</span><span class="s3">\n        </span><span class="s1">taskReject(error)</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">this.#runningCount--</span><span class="s3">\n        </span><span class="s1">this.#processNext()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const enqueueResult = { promiseFn: taskPromise, task }</span><span class="s3">\n    </span><span class="s1">// wonder if we should take a LIFO approach here</span><span class="s3">\n    </span><span class="s1">this.#queue.push(enqueueResult)</span><span class="s3">\n    </span><span class="s1">this.#processNext()</span><span class="s3">\n\n    </span><span class="s1">return taskPromise</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">bump(promiseFn: Promise&lt;any&gt;) {</span><span class="s3">\n    </span><span class="s1">const index = this.#queue.findIndex((item) =&gt; item.promiseFn === promiseFn)</span><span class="s3">\n\n    </span><span class="s1">if (index &gt; -1) {</span><span class="s3">\n      </span><span class="s1">const bumpedItem = this.#queue.splice(index, 1)[0]</span><span class="s3">\n      </span><span class="s1">this.#queue.unshift(bumpedItem)</span><span class="s3">\n      </span><span class="s1">this.#processNext(true)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">#processNext(forced = false) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(this.#runningCount &lt; this.#maxConcurrency || forced) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.#queue.length &gt; 0</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this.#queue.shift()?.task()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;PromiseQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;enqueue&quot;</span><span class="s0">,</span><span class="s1">&quot;promiseFn&quot;</span><span class="s0">,</span><span class="s1">&quot;taskResolve&quot;</span><span class="s0">,</span><span class="s1">&quot;taskReject&quot;</span><span class="s0">,</span><span class="s1">&quot;taskPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;task&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;enqueueResult&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;bump&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;findIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;item&quot;</span><span class="s0">,</span><span class="s1">&quot;bumpedItem&quot;</span><span class="s0">,</span><span class="s1">&quot;splice&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;maxConcurrency&quot;</span><span class="s0">,</span><span class="s1">&quot;forced&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;shift&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;;;;AAKA;;;;+BACaA;;;eAAAA;;;;;IACX,qFACA,iFACA,mEAmDA;AAtDK,MAAMA;IAcXC,QAAWC,SAA2B,EAAc;QAClD,IAAIC;QACJ,IAAIC;QAEJ,MAAMC,cAAc,IAAIC,QAAQ,CAACC,SAASC;YACxCL,cAAcI;YACdH,aAAaI;QACf;QAEA,MAAMC,OAAO;YACX,IAAI;gBACF,kCAAA,IAAI,EAAC,eAAA;gBACL,MAAMC,SAAS,MAAMR;gBACrBC,YAAYO;YACd,EAAE,OAAOC,OAAO;gBACdP,WAAWO;YACb,SAAU;gBACR,kCAAA,IAAI,EAAC,eAAA;gBACL,kCAAA,IAAI,EAAC,cAAA;YACP;QACF;QAEA,MAAMC,gBAAgB;YAAEV,WAAWG;YAAaI;QAAK;QACrD,gDAAgD;QAChD,kCAAA,IAAI,EAAC,QAAA,QAAOI,IAAI,CAACD;QACjB,kCAAA,IAAI,EAAC,cAAA;QAEL,OAAOP;IACT;IAEAS,KAAKZ,SAAuB,EAAE;QAC5B,MAAMa,QAAQ,kCAAA,IAAI,EAAC,QAAA,QAAOC,SAAS,CAAC,CAACC,OAASA,KAAKf,SAAS,KAAKA;QAEjE,IAAIa,QAAQ,CAAC,GAAG;YACd,MAAMG,aAAa,kCAAA,IAAI,EAAC,QAAA,QAAOC,MAAM,CAACJ,OAAO,EAAE,CAAC,EAAE;YAClD,kCAAA,IAAI,EAAC,QAAA,QAAOK,OAAO,CAACF;YACpB,kCAAA,IAAI,EAAC,cAAA,cAAa;QACpB;IACF;IA5CAG,YAAYC,iBAAiB,CAAC,CAAE;QA8ChC,4BAAA;mBAAA;;QArDA,4BAAA;;mBAAA,KAAA;;QACA,4BAAA;;mBAAA,KAAA;;QACA,4BAAA;;mBAAA,KAAA;;QAME,kCAAA,IAAI,EAAC,iBAAA,mBAAkBA;QACvB,kCAAA,IAAI,EAAC,eAAA,iBAAgB;QACrB,kCAAA,IAAI,EAAC,QAAA,UAAS,EAAE;IAClB;AAkDF;AARE,SAAA,YAAaC,MAAc;IAAdA,IAAAA,mBAAAA,SAAS;IACpB,IACE,AAAC,CAAA,kCAAA,IAAI,EAAC,eAAA,iBAAgB,kCAAA,IAAI,EAAC,iBAAA,oBAAmBA,MAAK,KACnD,kCAAA,IAAI,EAAC,QAAA,QAAOC,MAAM,GAAG,GACrB;YACA;SAAA,+CAAA,kCAAA,IAAI,EAAC,QAAA,QAAOC,KAAK,uBAAjB,6CAAqBhB,IAAI;IAC3B;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>