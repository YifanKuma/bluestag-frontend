<html>
<head>
<title>next-barrel-loader.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #0033b3;}
.s4 { color: #1750eb;}
.s5 { color: #264eff;}
.s6 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
next-barrel-loader.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* ## Barrel Optimizations</span>
 <span class="s0">*</span>
 <span class="s0">* This loader is used to optimize the imports of &quot;barrel&quot; files that have many</span>
 <span class="s0">* re-exports. Currently, both Node.js and Webpack have to enter all of these</span>
 <span class="s0">* submodules even if we only need a few of them.</span>
 <span class="s0">*</span>
 <span class="s0">* For example, say a file `foo.js` with the following contents:</span>
 <span class="s0">*</span>
 <span class="s0">*   export { a } from './a'</span>
 <span class="s0">*   export { b } from './b'</span>
 <span class="s0">*   export { c } from './c'</span>
 <span class="s0">*   ...</span>
 <span class="s0">*</span>
 <span class="s0">* If the user imports `a` only, this loader will accept the `names` option to</span>
 <span class="s0">* be `['a']`. Then, it request the &quot;__barrel_transform__&quot; SWC transform to load</span>
 <span class="s0">* `foo.js` and receive the following output:</span>
 <span class="s0">*</span>
 <span class="s0">*   export const __next_private_export_map__ = '[[&quot;a&quot;,&quot;./a&quot;,&quot;a&quot;],[&quot;b&quot;,&quot;./b&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;./c&quot;,&quot;c&quot;],...]'</span>
 <span class="s0">*</span>
 <span class="s0">*   format: '[&quot;&lt;imported identifier&gt;&quot;, &quot;&lt;import path&gt;&quot;, &quot;&lt;exported name&gt;&quot;]'</span>
 <span class="s0">*   e.g.: import { a as b } from './module-a' =&gt; '[&quot;b&quot;, &quot;./module-a&quot;, &quot;a&quot;]'</span>
 <span class="s0">*</span>
 <span class="s0">* The export map, generated by SWC, is a JSON that represents the exports of</span>
 <span class="s0">* that module, their original file, and their original name (since you can do</span>
 <span class="s0">* `export { a as b }`).</span>
 <span class="s0">*</span>
 <span class="s0">* Then, this loader can safely remove all the exports that are not needed and</span>
 <span class="s0">* re-export the ones from `names`:</span>
 <span class="s0">*</span>
 <span class="s0">*   export { a } from './a'</span>
 <span class="s0">*</span>
 <span class="s0">* That's the basic situation and also the happy path.</span>
 <span class="s0">*</span>
 <span class="s0">*</span>
 <span class="s0">*</span>
 <span class="s0">* ## Wildcard Exports</span>
 <span class="s0">*</span>
 <span class="s0">* For wildcard exports (e.g. `export * from './a'`), it becomes a bit more complicated.</span>
 <span class="s0">* Say `foo.js` with the following contents:</span>
 <span class="s0">*</span>
 <span class="s0">*   export * from './a'</span>
 <span class="s0">*   export * from './b'</span>
 <span class="s0">*   export * from './c'</span>
 <span class="s0">*   ...</span>
 <span class="s0">*</span>
 <span class="s0">* If the user imports `bar` from it, SWC can never know which files are going to be</span>
 <span class="s0">* exporting `bar`. So, we have to keep all the wildcard exports and do the same</span>
 <span class="s0">* process recursively. This loader will return the following output:</span>
 <span class="s0">*</span>
 <span class="s0">*   export * from '__barrel_optimize__?names=bar&amp;wildcard!=!./a'</span>
 <span class="s0">*   export * from '__barrel_optimize__?names=bar&amp;wildcard!=!./b'</span>
 <span class="s0">*   export * from '__barrel_optimize__?names=bar&amp;wildcard!=!./c'</span>
 <span class="s0">*   ...</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;!=!&quot; tells Webpack to use the same loader to process './a', './b', and './c'.</span>
 <span class="s0">* After the recursive process, the &quot;inner loaders&quot; will either return an empty string</span>
 <span class="s0">* or:</span>
 <span class="s0">*</span>
 <span class="s0">*   export * from './target'</span>
 <span class="s0">*</span>
 <span class="s0">* Where `target` is the file that exports `bar`.</span>
 <span class="s0">*</span>
 <span class="s0">*</span>
 <span class="s0">*</span>
 <span class="s0">* ## Non-Barrel Files</span>
 <span class="s0">*</span>
 <span class="s0">* If the file is not a barrel, we can't apply any optimizations. That's because</span>
 <span class="s0">* we can't easily remove things from the file. For example, say `foo.js` with:</span>
 <span class="s0">*</span>
 <span class="s0">*   const v = 1</span>
 <span class="s0">*   export function b () {</span>
 <span class="s0">*     return v</span>
 <span class="s0">*   }</span>
 <span class="s0">*</span>
 <span class="s0">* If the user imports `b` only, we can't remove the `const v = 1` even though</span>
 <span class="s0">* the file is side-effect free. In these caes, this loader will simply re-export</span>
 <span class="s0">* `foo.js`:</span>
 <span class="s0">*</span>
 <span class="s0">*   export * from './foo'</span>
 <span class="s0">*</span>
 <span class="s0">* Besides these cases, this loader also carefully handles the module cache so</span>
 <span class="s0">* SWC won't analyze the same file twice, and no instance of the same file will</span>
 <span class="s0">* be accidentally created as different instances.</span>
 <span class="s0">*/ </span><span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s3">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s2">&quot;default&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">_default;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s3">const </span><span class="s1">_path = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s2">&quot;path&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">_swc = require(</span><span class="s2">&quot;../../swc&quot;</span><span class="s1">);</span>
<span class="s3">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s3">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s3">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s0">// This is a in-memory cache for the mapping of barrel exports. This only applies</span>
<span class="s0">// to the packages that we optimize. It will never change (e.g. upgrading packages)</span>
<span class="s0">// during the lifetime of the server so we can safely cache it.</span>
<span class="s0">// There is also no need to collect the cache for the same reason.</span>
<span class="s3">const </span><span class="s1">barrelTransformMappingCache = </span><span class="s3">new </span><span class="s1">Map();</span>
<span class="s1">async </span><span class="s3">function </span><span class="s1">getBarrelMapping(resourcePath, swcCacheDir, resolve, fs) {</span>
    <span class="s3">if </span><span class="s1">(barrelTransformMappingCache.has(resourcePath)) {</span>
        <span class="s3">return </span><span class="s1">barrelTransformMappingCache.get(resourcePath);</span>
    <span class="s1">}</span>
    <span class="s0">// This is a SWC transform specifically for `optimizeBarrelExports`. We don't</span>
    <span class="s0">// care about other things but the export map only.</span>
    <span class="s1">async </span><span class="s3">function </span><span class="s1">transpileSource(filename, source, isWildcard) {</span>
        <span class="s3">const </span><span class="s1">isTypeScript = filename.endsWith(</span><span class="s2">'.ts'</span><span class="s1">) || filename.endsWith(</span><span class="s2">'.tsx'</span><span class="s1">);</span>
        <span class="s3">return new </span><span class="s1">Promise((res)=&gt;(</span><span class="s4">0</span><span class="s1">, _swc.transform)(source, {</span>
                <span class="s1">filename,</span>
                <span class="s1">inputSourceMap: undefined,</span>
                <span class="s1">sourceFileName: filename,</span>
                <span class="s1">optimizeBarrelExports: {</span>
                    <span class="s1">wildcard: isWildcard</span>
                <span class="s1">},</span>
                <span class="s1">jsc: {</span>
                    <span class="s1">parser: {</span>
                        <span class="s1">syntax: isTypeScript ? </span><span class="s2">'typescript' </span><span class="s1">: </span><span class="s2">'ecmascript'</span><span class="s1">,</span>
                        <span class="s1">[isTypeScript ? </span><span class="s2">'tsx' </span><span class="s1">: </span><span class="s2">'jsx'</span><span class="s1">]: </span><span class="s3">true</span>
                    <span class="s1">},</span>
                    <span class="s1">experimental: {</span>
                        <span class="s1">cacheRoot: swcCacheDir</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}).then((output)=&gt;{</span>
                <span class="s1">res(output.code);</span>
            <span class="s1">}));</span>
    <span class="s1">}</span>
    <span class="s0">// Avoid circular `export *` dependencies</span>
    <span class="s3">const </span><span class="s1">visited = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s1">async </span><span class="s3">function </span><span class="s1">getMatches(file, isWildcard, isClientEntry) {</span>
        <span class="s3">if </span><span class="s1">(visited.has(file)) {</span>
            <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">visited.add(file);</span>
        <span class="s3">const </span><span class="s1">source = </span><span class="s3">await new </span><span class="s1">Promise((res, rej)=&gt;{</span>
            <span class="s1">fs.readFile(file, (err, data)=&gt;{</span>
                <span class="s3">if </span><span class="s1">(err || data === undefined) {</span>
                    <span class="s1">rej(err);</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">res(data.toString());</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">});</span>
        <span class="s3">const </span><span class="s1">output = </span><span class="s3">await </span><span class="s1">transpileSource(file, source, isWildcard);</span>
        <span class="s3">const </span><span class="s1">matches = output.match(</span><span class="s5">/^([^]*)export (const|var) __next_private_export_map__ = ('[^']+'|&quot;[^&quot;]+&quot;)/</span><span class="s1">);</span>
        <span class="s3">if </span><span class="s1">(!matches) {</span>
            <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">const </span><span class="s1">matchedDirectives = output.match(</span><span class="s5">/^([^]*)export (const|var) __next_private_directive_list__ = '([^']+)'/</span><span class="s1">);</span>
        <span class="s3">const </span><span class="s1">directiveList = matchedDirectives ? JSON.parse(matchedDirectives[</span><span class="s4">3</span><span class="s1">]) : [];</span>
        <span class="s0">// &quot;use client&quot; in barrel files has to be transferred to the target file.</span>
        <span class="s1">isClientEntry = directiveList.includes(</span><span class="s2">'use client'</span><span class="s1">);</span>
        <span class="s3">let </span><span class="s1">exportList = JSON.parse(matches[</span><span class="s4">3</span><span class="s1">].slice(</span><span class="s4">1</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">));</span>
        <span class="s3">const </span><span class="s1">wildcardExports = [</span>
            <span class="s1">...output.matchAll(</span><span class="s5">/export \* from &quot;([^&quot;]+)&quot;/g</span><span class="s1">)</span>
        <span class="s1">].map((match)=&gt;match[</span><span class="s4">1</span><span class="s1">]);</span>
        <span class="s0">// In the wildcard case, if the value is exported from another file, we</span>
        <span class="s0">// redirect to that file (decl[0]). Otherwise, export from the current</span>
        <span class="s0">// file itself.</span>
        <span class="s3">if </span><span class="s1">(isWildcard) {</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">decl of exportList){</span>
                <span class="s1">decl[</span><span class="s4">1</span><span class="s1">] = file;</span>
                <span class="s1">decl[</span><span class="s4">2</span><span class="s1">] = decl[</span><span class="s4">0</span><span class="s1">];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">// This recursively handles the wildcard exports (e.g. `export * from './a'`)</span>
        <span class="s3">if </span><span class="s1">(wildcardExports.length) {</span>
            <span class="s3">await </span><span class="s1">Promise.all(wildcardExports.map(async (req)=&gt;{</span>
                <span class="s3">const </span><span class="s1">targetPath = </span><span class="s3">await </span><span class="s1">resolve(_path.default.dirname(file), req.replace(</span><span class="s2">'__barrel_optimize__?names=__PLACEHOLDER__!=!'</span><span class="s1">, </span><span class="s2">''</span><span class="s1">));</span>
                <span class="s3">const </span><span class="s1">targetMatches = </span><span class="s3">await </span><span class="s1">getMatches(targetPath, </span><span class="s3">true</span><span class="s1">, isClientEntry);</span>
                <span class="s3">if </span><span class="s1">(targetMatches) {</span>
                    <span class="s0">// Merge the export list</span>
                    <span class="s1">exportList = exportList.concat(targetMatches.exportList);</span>
                <span class="s1">}</span>
            <span class="s1">}));</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">{</span>
            <span class="s1">exportList,</span>
            <span class="s1">wildcardExports,</span>
            <span class="s1">isClientEntry</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s3">const </span><span class="s1">res = </span><span class="s3">await </span><span class="s1">getMatches(resourcePath, </span><span class="s3">false</span><span class="s1">, </span><span class="s3">false</span><span class="s1">);</span>
    <span class="s1">barrelTransformMappingCache.set(resourcePath, res);</span>
    <span class="s3">return </span><span class="s1">res;</span>
<span class="s1">}</span>
<span class="s3">const </span><span class="s1">NextBarrelLoader = async </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s3">this</span><span class="s1">.async();</span>
    <span class="s3">this</span><span class="s1">.cacheable(</span><span class="s3">true</span><span class="s1">);</span>
    <span class="s3">const </span><span class="s1">{ names, swcCacheDir } = </span><span class="s3">this</span><span class="s1">.getOptions();</span>
    <span class="s0">// For barrel optimizations, we always prefer the &quot;module&quot; field over the</span>
    <span class="s0">// &quot;main&quot; field because ESM handling is more robust with better tree-shaking.</span>
    <span class="s3">const </span><span class="s1">resolve = </span><span class="s3">this</span><span class="s1">.getResolve({</span>
        <span class="s1">mainFields: [</span>
            <span class="s2">'module'</span><span class="s1">,</span>
            <span class="s2">'main'</span>
        <span class="s1">]</span>
    <span class="s1">});</span>
    <span class="s3">const </span><span class="s1">mapping = </span><span class="s3">await </span><span class="s1">getBarrelMapping(</span><span class="s3">this</span><span class="s1">.resourcePath, swcCacheDir, resolve, </span><span class="s3">this</span><span class="s1">.fs);</span>
    <span class="s0">// `resolve` adds all sub-paths to the dependency graph. However, we already</span>
    <span class="s0">// cached the mapping and we assume them to not change. So, we can safely</span>
    <span class="s0">// clear the dependencies here to avoid unnecessary watchers which turned out</span>
    <span class="s0">// to be very expensive.</span>
    <span class="s3">this</span><span class="s1">.clearDependencies();</span>
    <span class="s3">if </span><span class="s1">(!mapping) {</span>
        <span class="s0">// This file isn't a barrel and we can't apply any optimizations. Let's re-export everything.</span>
        <span class="s0">// Since this loader accepts `names` and the request is keyed with `names`, we can't simply</span>
        <span class="s0">// return the original source here. That will create these imports with different names as</span>
        <span class="s0">// different modules instances.</span>
        <span class="s3">this</span><span class="s1">.callback(</span><span class="s3">null</span><span class="s1">, </span><span class="s2">`export * from </span><span class="s1">${JSON.stringify(</span><span class="s3">this</span><span class="s1">.resourcePath)}</span><span class="s2">`</span><span class="s1">);</span>
        <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">const </span><span class="s1">exportList = mapping.exportList;</span>
    <span class="s3">const </span><span class="s1">isClientEntry = mapping.isClientEntry;</span>
    <span class="s3">const </span><span class="s1">exportMap = </span><span class="s3">new </span><span class="s1">Map();</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">[name, filePath, orig] of exportList){</span>
        <span class="s1">exportMap.set(name, [</span>
            <span class="s1">filePath,</span>
            <span class="s1">orig</span>
        <span class="s1">]);</span>
    <span class="s1">}</span>
    <span class="s3">let </span><span class="s1">output = </span><span class="s2">''</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s1">missedNames = [];</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">name of names){</span>
        <span class="s0">// If the name matches</span>
        <span class="s3">if </span><span class="s1">(exportMap.has(name)) {</span>
            <span class="s3">const </span><span class="s1">decl = exportMap.get(name);</span>
            <span class="s3">if </span><span class="s1">(decl[</span><span class="s4">1</span><span class="s1">] === </span><span class="s2">'*'</span><span class="s1">) {</span>
                <span class="s1">output += </span><span class="s2">`</span><span class="s6">\n</span><span class="s2">export * as </span><span class="s1">${name} </span><span class="s2">from </span><span class="s1">${JSON.stringify(decl[</span><span class="s4">0</span><span class="s1">])}</span><span class="s2">`</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(decl[</span><span class="s4">1</span><span class="s1">] === </span><span class="s2">'default'</span><span class="s1">) {</span>
                <span class="s1">output += </span><span class="s2">`</span><span class="s6">\n</span><span class="s2">export { default as </span><span class="s1">${name} </span><span class="s2">} from </span><span class="s1">${JSON.stringify(decl[</span><span class="s4">0</span><span class="s1">])}</span><span class="s2">`</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(decl[</span><span class="s4">1</span><span class="s1">] === name) {</span>
                <span class="s1">output += </span><span class="s2">`</span><span class="s6">\n</span><span class="s2">export { </span><span class="s1">${name} </span><span class="s2">} from </span><span class="s1">${JSON.stringify(decl[</span><span class="s4">0</span><span class="s1">])}</span><span class="s2">`</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">output += </span><span class="s2">`</span><span class="s6">\n</span><span class="s2">export { </span><span class="s1">${decl[</span><span class="s4">1</span><span class="s1">]} </span><span class="s2">as </span><span class="s1">${name} </span><span class="s2">} from </span><span class="s1">${JSON.stringify(decl[</span><span class="s4">0</span><span class="s1">])}</span><span class="s2">`</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">missedNames.push(name);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">// These are from wildcard exports.</span>
    <span class="s3">if </span><span class="s1">(missedNames.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">req of mapping.wildcardExports){</span>
            <span class="s1">output += </span><span class="s2">`</span><span class="s6">\n</span><span class="s2">export * from </span><span class="s1">${JSON.stringify(req.replace(</span><span class="s2">'__PLACEHOLDER__'</span><span class="s1">, missedNames.join(</span><span class="s2">','</span><span class="s1">) + </span><span class="s2">'&amp;wildcard'</span><span class="s1">))}</span><span class="s2">`</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">// When it has `&quot;use client&quot;` inherited from its barrel files, we need to</span>
    <span class="s0">// prefix it to this target file as well.</span>
    <span class="s3">if </span><span class="s1">(isClientEntry) {</span>
        <span class="s1">output = </span><span class="s2">`&quot;use client&quot;;</span><span class="s6">\n</span><span class="s1">${output}</span><span class="s2">`</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">this</span><span class="s1">.callback(</span><span class="s3">null</span><span class="s1">, output);</span>
<span class="s1">};</span>
<span class="s3">const </span><span class="s1">_default = NextBarrelLoader;</span>

<span class="s0">//# sourceMappingURL=next-barrel-loader.js.map</span></pre>
</body>
</html>