<html>
<head>
<title>typescript.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #067d17;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
typescript.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/*! ***************************************************************************** 
Copyright (c) Microsoft Corporation. All rights reserved. 
Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use 
this file except in compliance with the License. You may obtain a copy of the 
License at http://www.apache.org/licenses/LICENSE-2.0 
 
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY 
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED 
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, 
MERCHANTABLITY OR NON-INFRINGEMENT. 
 
See the Apache Version 2.0 License for specific language governing permissions 
and limitations under the License. 
***************************************************************************** */</span>

<span class="s1">declare namespace ts {</span>
    <span class="s1">namespace server {</span>
        <span class="s1">namespace protocol {</span>
            <span class="s2">export import </span><span class="s1">ApplicableRefactorInfo = ts.ApplicableRefactorInfo;</span>
            <span class="s2">export import </span><span class="s1">ClassificationType = ts.ClassificationType;</span>
            <span class="s2">export import </span><span class="s1">CompletionsTriggerCharacter = ts.CompletionsTriggerCharacter;</span>
            <span class="s2">export import </span><span class="s1">CompletionTriggerKind = ts.CompletionTriggerKind;</span>
            <span class="s2">export import </span><span class="s1">InlayHintKind = ts.InlayHintKind;</span>
            <span class="s2">export import </span><span class="s1">OrganizeImportsMode = ts.OrganizeImportsMode;</span>
            <span class="s2">export import </span><span class="s1">RefactorActionInfo = ts.RefactorActionInfo;</span>
            <span class="s2">export import </span><span class="s1">RefactorTriggerReason = ts.RefactorTriggerReason;</span>
            <span class="s2">export import </span><span class="s1">RenameInfoFailure = ts.RenameInfoFailure;</span>
            <span class="s2">export import </span><span class="s1">SemicolonPreference = ts.SemicolonPreference;</span>
            <span class="s2">export import </span><span class="s1">SignatureHelpCharacterTypedReason = ts.SignatureHelpCharacterTypedReason;</span>
            <span class="s2">export import </span><span class="s1">SignatureHelpInvokedReason = ts.SignatureHelpInvokedReason;</span>
            <span class="s2">export import </span><span class="s1">SignatureHelpParameter = ts.SignatureHelpParameter;</span>
            <span class="s2">export import </span><span class="s1">SignatureHelpRetriggerCharacter = ts.SignatureHelpRetriggerCharacter;</span>
            <span class="s2">export import </span><span class="s1">SignatureHelpRetriggeredReason = ts.SignatureHelpRetriggeredReason;</span>
            <span class="s2">export import </span><span class="s1">SignatureHelpTriggerCharacter = ts.SignatureHelpTriggerCharacter;</span>
            <span class="s2">export import </span><span class="s1">SignatureHelpTriggerReason = ts.SignatureHelpTriggerReason;</span>
            <span class="s2">export import </span><span class="s1">SymbolDisplayPart = ts.SymbolDisplayPart;</span>
            <span class="s2">export import </span><span class="s1">UserPreferences = ts.UserPreferences;</span>
            <span class="s1">type ChangePropertyTypes&lt;</span>
                <span class="s1">T,</span>
                <span class="s1">Substitutions </span><span class="s2">extends </span><span class="s1">{</span>
                    <span class="s1">[K </span><span class="s2">in </span><span class="s1">keyof T]?: any;</span>
                <span class="s1">},</span>
            <span class="s1">&gt; = {</span>
                <span class="s1">[K </span><span class="s2">in </span><span class="s1">keyof T]: K </span><span class="s2">extends </span><span class="s1">keyof Substitutions ? Substitutions[K] : T[K];</span>
            <span class="s1">};</span>
            <span class="s1">type ChangeStringIndexSignature&lt;T, NewStringIndexSignatureType&gt; = {</span>
                <span class="s1">[K </span><span class="s2">in </span><span class="s1">keyof T]: string </span><span class="s2">extends </span><span class="s1">K ? NewStringIndexSignatureType : T[K];</span>
            <span class="s1">};</span>
            <span class="s2">export enum </span><span class="s1">CommandTypes {</span>
                <span class="s1">JsxClosingTag = </span><span class="s3">&quot;jsxClosingTag&quot;</span><span class="s1">,</span>
                <span class="s1">LinkedEditingRange = </span><span class="s3">&quot;linkedEditingRange&quot;</span><span class="s1">,</span>
                <span class="s1">Brace = </span><span class="s3">&quot;brace&quot;</span><span class="s1">,</span>
                <span class="s1">BraceCompletion = </span><span class="s3">&quot;braceCompletion&quot;</span><span class="s1">,</span>
                <span class="s1">GetSpanOfEnclosingComment = </span><span class="s3">&quot;getSpanOfEnclosingComment&quot;</span><span class="s1">,</span>
                <span class="s1">Change = </span><span class="s3">&quot;change&quot;</span><span class="s1">,</span>
                <span class="s1">Close = </span><span class="s3">&quot;close&quot;</span><span class="s1">,</span>
                <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">Prefer CompletionInfo -- see comment on CompletionsResponse */</span>
                <span class="s1">Completions = </span><span class="s3">&quot;completions&quot;</span><span class="s1">,</span>
                <span class="s1">CompletionInfo = </span><span class="s3">&quot;completionInfo&quot;</span><span class="s1">,</span>
                <span class="s1">CompletionDetails = </span><span class="s3">&quot;completionEntryDetails&quot;</span><span class="s1">,</span>
                <span class="s1">CompileOnSaveAffectedFileList = </span><span class="s3">&quot;compileOnSaveAffectedFileList&quot;</span><span class="s1">,</span>
                <span class="s1">CompileOnSaveEmitFile = </span><span class="s3">&quot;compileOnSaveEmitFile&quot;</span><span class="s1">,</span>
                <span class="s1">Configure = </span><span class="s3">&quot;configure&quot;</span><span class="s1">,</span>
                <span class="s1">Definition = </span><span class="s3">&quot;definition&quot;</span><span class="s1">,</span>
                <span class="s1">DefinitionAndBoundSpan = </span><span class="s3">&quot;definitionAndBoundSpan&quot;</span><span class="s1">,</span>
                <span class="s1">Implementation = </span><span class="s3">&quot;implementation&quot;</span><span class="s1">,</span>
                <span class="s1">Exit = </span><span class="s3">&quot;exit&quot;</span><span class="s1">,</span>
                <span class="s1">FileReferences = </span><span class="s3">&quot;fileReferences&quot;</span><span class="s1">,</span>
                <span class="s1">Format = </span><span class="s3">&quot;format&quot;</span><span class="s1">,</span>
                <span class="s1">Formatonkey = </span><span class="s3">&quot;formatonkey&quot;</span><span class="s1">,</span>
                <span class="s1">Geterr = </span><span class="s3">&quot;geterr&quot;</span><span class="s1">,</span>
                <span class="s1">GeterrForProject = </span><span class="s3">&quot;geterrForProject&quot;</span><span class="s1">,</span>
                <span class="s1">SemanticDiagnosticsSync = </span><span class="s3">&quot;semanticDiagnosticsSync&quot;</span><span class="s1">,</span>
                <span class="s1">SyntacticDiagnosticsSync = </span><span class="s3">&quot;syntacticDiagnosticsSync&quot;</span><span class="s1">,</span>
                <span class="s1">SuggestionDiagnosticsSync = </span><span class="s3">&quot;suggestionDiagnosticsSync&quot;</span><span class="s1">,</span>
                <span class="s1">NavBar = </span><span class="s3">&quot;navbar&quot;</span><span class="s1">,</span>
                <span class="s1">Navto = </span><span class="s3">&quot;navto&quot;</span><span class="s1">,</span>
                <span class="s1">NavTree = </span><span class="s3">&quot;navtree&quot;</span><span class="s1">,</span>
                <span class="s1">NavTreeFull = </span><span class="s3">&quot;navtree-full&quot;</span><span class="s1">,</span>
                <span class="s1">DocumentHighlights = </span><span class="s3">&quot;documentHighlights&quot;</span><span class="s1">,</span>
                <span class="s1">Open = </span><span class="s3">&quot;open&quot;</span><span class="s1">,</span>
                <span class="s1">Quickinfo = </span><span class="s3">&quot;quickinfo&quot;</span><span class="s1">,</span>
                <span class="s1">References = </span><span class="s3">&quot;references&quot;</span><span class="s1">,</span>
                <span class="s1">Reload = </span><span class="s3">&quot;reload&quot;</span><span class="s1">,</span>
                <span class="s1">Rename = </span><span class="s3">&quot;rename&quot;</span><span class="s1">,</span>
                <span class="s1">Saveto = </span><span class="s3">&quot;saveto&quot;</span><span class="s1">,</span>
                <span class="s1">SignatureHelp = </span><span class="s3">&quot;signatureHelp&quot;</span><span class="s1">,</span>
                <span class="s1">FindSourceDefinition = </span><span class="s3">&quot;findSourceDefinition&quot;</span><span class="s1">,</span>
                <span class="s1">Status = </span><span class="s3">&quot;status&quot;</span><span class="s1">,</span>
                <span class="s1">TypeDefinition = </span><span class="s3">&quot;typeDefinition&quot;</span><span class="s1">,</span>
                <span class="s1">ProjectInfo = </span><span class="s3">&quot;projectInfo&quot;</span><span class="s1">,</span>
                <span class="s1">ReloadProjects = </span><span class="s3">&quot;reloadProjects&quot;</span><span class="s1">,</span>
                <span class="s1">Unknown = </span><span class="s3">&quot;unknown&quot;</span><span class="s1">,</span>
                <span class="s1">OpenExternalProject = </span><span class="s3">&quot;openExternalProject&quot;</span><span class="s1">,</span>
                <span class="s1">OpenExternalProjects = </span><span class="s3">&quot;openExternalProjects&quot;</span><span class="s1">,</span>
                <span class="s1">CloseExternalProject = </span><span class="s3">&quot;closeExternalProject&quot;</span><span class="s1">,</span>
                <span class="s1">UpdateOpen = </span><span class="s3">&quot;updateOpen&quot;</span><span class="s1">,</span>
                <span class="s1">GetOutliningSpans = </span><span class="s3">&quot;getOutliningSpans&quot;</span><span class="s1">,</span>
                <span class="s1">TodoComments = </span><span class="s3">&quot;todoComments&quot;</span><span class="s1">,</span>
                <span class="s1">Indentation = </span><span class="s3">&quot;indentation&quot;</span><span class="s1">,</span>
                <span class="s1">DocCommentTemplate = </span><span class="s3">&quot;docCommentTemplate&quot;</span><span class="s1">,</span>
                <span class="s1">CompilerOptionsForInferredProjects = </span><span class="s3">&quot;compilerOptionsForInferredProjects&quot;</span><span class="s1">,</span>
                <span class="s1">GetCodeFixes = </span><span class="s3">&quot;getCodeFixes&quot;</span><span class="s1">,</span>
                <span class="s1">GetCombinedCodeFix = </span><span class="s3">&quot;getCombinedCodeFix&quot;</span><span class="s1">,</span>
                <span class="s1">ApplyCodeActionCommand = </span><span class="s3">&quot;applyCodeActionCommand&quot;</span><span class="s1">,</span>
                <span class="s1">GetSupportedCodeFixes = </span><span class="s3">&quot;getSupportedCodeFixes&quot;</span><span class="s1">,</span>
                <span class="s1">GetApplicableRefactors = </span><span class="s3">&quot;getApplicableRefactors&quot;</span><span class="s1">,</span>
                <span class="s1">GetEditsForRefactor = </span><span class="s3">&quot;getEditsForRefactor&quot;</span><span class="s1">,</span>
                <span class="s1">GetMoveToRefactoringFileSuggestions = </span><span class="s3">&quot;getMoveToRefactoringFileSuggestions&quot;</span><span class="s1">,</span>
                <span class="s1">PreparePasteEdits = </span><span class="s3">&quot;preparePasteEdits&quot;</span><span class="s1">,</span>
                <span class="s1">GetPasteEdits = </span><span class="s3">&quot;getPasteEdits&quot;</span><span class="s1">,</span>
                <span class="s1">OrganizeImports = </span><span class="s3">&quot;organizeImports&quot;</span><span class="s1">,</span>
                <span class="s1">GetEditsForFileRename = </span><span class="s3">&quot;getEditsForFileRename&quot;</span><span class="s1">,</span>
                <span class="s1">ConfigurePlugin = </span><span class="s3">&quot;configurePlugin&quot;</span><span class="s1">,</span>
                <span class="s1">SelectionRange = </span><span class="s3">&quot;selectionRange&quot;</span><span class="s1">,</span>
                <span class="s1">ToggleLineComment = </span><span class="s3">&quot;toggleLineComment&quot;</span><span class="s1">,</span>
                <span class="s1">ToggleMultilineComment = </span><span class="s3">&quot;toggleMultilineComment&quot;</span><span class="s1">,</span>
                <span class="s1">CommentSelection = </span><span class="s3">&quot;commentSelection&quot;</span><span class="s1">,</span>
                <span class="s1">UncommentSelection = </span><span class="s3">&quot;uncommentSelection&quot;</span><span class="s1">,</span>
                <span class="s1">PrepareCallHierarchy = </span><span class="s3">&quot;prepareCallHierarchy&quot;</span><span class="s1">,</span>
                <span class="s1">ProvideCallHierarchyIncomingCalls = </span><span class="s3">&quot;provideCallHierarchyIncomingCalls&quot;</span><span class="s1">,</span>
                <span class="s1">ProvideCallHierarchyOutgoingCalls = </span><span class="s3">&quot;provideCallHierarchyOutgoingCalls&quot;</span><span class="s1">,</span>
                <span class="s1">ProvideInlayHints = </span><span class="s3">&quot;provideInlayHints&quot;</span><span class="s1">,</span>
                <span class="s1">WatchChange = </span><span class="s3">&quot;watchChange&quot;</span><span class="s1">,</span>
                <span class="s1">MapCode = </span><span class="s3">&quot;mapCode&quot;</span><span class="s1">,</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* A TypeScript Server message</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">Message {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Sequence number of the message</span>
                 <span class="s0">*/</span>
                <span class="s1">seq: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* One of &quot;request&quot;, &quot;response&quot;, or &quot;event&quot;</span>
                 <span class="s0">*/</span>
                <span class="s1">type: </span><span class="s3">&quot;request&quot; </span><span class="s1">| </span><span class="s3">&quot;response&quot; </span><span class="s1">| </span><span class="s3">&quot;event&quot;</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Client-initiated request message</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">Request </span><span class="s2">extends </span><span class="s1">Message {</span>
                <span class="s1">type: </span><span class="s3">&quot;request&quot;</span><span class="s1">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The command to execute</span>
                 <span class="s0">*/</span>
                <span class="s1">command: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Object containing arguments for the command</span>
                 <span class="s0">*/</span>
                <span class="s1">arguments?: any;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Request to reload the project structure for all the opened files</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">ReloadProjectsRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.ReloadProjects;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Server-initiated event message</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">Event </span><span class="s2">extends </span><span class="s1">Message {</span>
                <span class="s1">type: </span><span class="s3">&quot;event&quot;</span><span class="s1">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Name of event</span>
                 <span class="s0">*/</span>
                <span class="s1">event: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Event-specific information</span>
                 <span class="s0">*/</span>
                <span class="s1">body?: any;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Response by server to client request message.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">Response </span><span class="s2">extends </span><span class="s1">Message {</span>
                <span class="s1">type: </span><span class="s3">&quot;response&quot;</span><span class="s1">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Sequence number of the request message.</span>
                 <span class="s0">*/</span>
                <span class="s1">request_seq: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Outcome of the request.</span>
                 <span class="s0">*/</span>
                <span class="s1">success: boolean;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The command requested.</span>
                 <span class="s0">*/</span>
                <span class="s1">command: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* If success === false, this should always be provided.</span>
                 <span class="s0">* Otherwise, may (or may not) contain a success message.</span>
                 <span class="s0">*/</span>
                <span class="s1">message?: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Contains message body if success === true.</span>
                 <span class="s0">*/</span>
                <span class="s1">body?: any;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Contains extra information that plugin can include to be passed on</span>
                 <span class="s0">*/</span>
                <span class="s1">metadata?: unknown;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Exposes information about the performance of this request-response pair.</span>
                 <span class="s0">*/</span>
                <span class="s1">performanceData?: PerformanceData;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">PerformanceData {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Time spent updating the program graph, in milliseconds.</span>
                 <span class="s0">*/</span>
                <span class="s1">updateGraphDurationMs?: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The time spent creating or updating the auto-import program, in milliseconds.</span>
                 <span class="s0">*/</span>
                <span class="s1">createAutoImportProviderProgramDurationMs?: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The time spent computing diagnostics, in milliseconds.</span>
                 <span class="s0">*/</span>
                <span class="s1">diagnosticsDuration?: FileDiagnosticPerformanceData[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Time spent computing each kind of diagnostics, in milliseconds.</span>
             <span class="s0">*/</span>
            <span class="s2">export </span><span class="s1">type DiagnosticPerformanceData = {</span>
                <span class="s1">[Kind </span><span class="s2">in </span><span class="s1">DiagnosticEventKind]?: number;</span>
            <span class="s1">};</span>
            <span class="s2">export interface </span><span class="s1">FileDiagnosticPerformanceData </span><span class="s2">extends </span><span class="s1">DiagnosticPerformanceData {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The file for which the performance data is reported.</span>
                 <span class="s0">*/</span>
                <span class="s1">file: string;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Arguments for FileRequest messages.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">FileRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The file for the request (absolute pathname required).</span>
                 <span class="s0">*/</span>
                <span class="s1">file: string;</span>
                <span class="s1">projectFileName?: string;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">StatusRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.Status;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">StatusResponseBody {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The TypeScript version (`ts.version`).</span>
                 <span class="s0">*/</span>
                <span class="s1">version: string;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Response to StatusRequest</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">StatusResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body: StatusResponseBody;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Requests a JS Doc comment template for a given position</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">DocCommentTemplateRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">command: CommandTypes.DocCommentTemplate;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Response to DocCommentTemplateRequest</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">DocCommandTemplateResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: TextInsertion;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* A request to get TODO comments from the file</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">TodoCommentRequest </span><span class="s2">extends </span><span class="s1">FileRequest {</span>
                <span class="s1">command: CommandTypes.TodoComments;</span>
                <span class="s1">arguments: TodoCommentRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Arguments for TodoCommentRequest request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">TodoCommentRequestArgs </span><span class="s2">extends </span><span class="s1">FileRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Array of target TodoCommentDescriptors that describes TODO comments to be found</span>
                 <span class="s0">*/</span>
                <span class="s1">descriptors: TodoCommentDescriptor[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Response for TodoCommentRequest request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">TodoCommentsResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: TodoComment[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* A request to determine if the caret is inside a comment.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">SpanOfEnclosingCommentRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">command: CommandTypes.GetSpanOfEnclosingComment;</span>
                <span class="s1">arguments: SpanOfEnclosingCommentRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">SpanOfEnclosingCommentRequestArgs </span><span class="s2">extends </span><span class="s1">FileLocationRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Requires that the enclosing span be a multi-line comment, or else the request returns undefined.</span>
                 <span class="s0">*/</span>
                <span class="s1">onlyMultiLine: boolean;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Request to obtain outlining spans in file.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">OutliningSpansRequest </span><span class="s2">extends </span><span class="s1">FileRequest {</span>
                <span class="s1">command: CommandTypes.GetOutliningSpans;</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type OutliningSpan = ChangePropertyTypes&lt;ts.OutliningSpan, {</span>
                <span class="s1">textSpan: TextSpan;</span>
                <span class="s1">hintSpan: TextSpan;</span>
            <span class="s1">}&gt;;</span>
            <span class="s0">/**</span>
             <span class="s0">* Response to OutliningSpansRequest request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">OutliningSpansResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: OutliningSpan[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* A request to get indentation for a location in file</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">IndentationRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">command: CommandTypes.Indentation;</span>
                <span class="s1">arguments: IndentationRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Response for IndentationRequest request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">IndentationResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: IndentationResult;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Indentation result representing where indentation should be placed</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">IndentationResult {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The base position in the document that the indent should be relative to</span>
                 <span class="s0">*/</span>
                <span class="s1">position: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The number of columns the indent should be at relative to the position's column.</span>
                 <span class="s0">*/</span>
                <span class="s1">indentation: number;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Arguments for IndentationRequest request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">IndentationRequestArgs </span><span class="s2">extends </span><span class="s1">FileLocationRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* An optional set of settings to be used when computing indentation.</span>
                 <span class="s0">* If argument is omitted - then it will use settings for file that were previously set via 'configure' request or global settings.</span>
                 <span class="s0">*/</span>
                <span class="s1">options?: EditorSettings;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Arguments for ProjectInfoRequest request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">ProjectInfoRequestArgs </span><span class="s2">extends </span><span class="s1">FileRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Indicate if the file name list of the project is needed</span>
                 <span class="s0">*/</span>
                <span class="s1">needFileNameList: boolean;</span>
                <span class="s0">/**</span>
                 <span class="s0">* if true returns details about default configured project calculation</span>
                 <span class="s0">*/</span>
                <span class="s1">needDefaultConfiguredProjectInfo?: boolean;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* A request to get the project information of the current file.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">ProjectInfoRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.ProjectInfo;</span>
                <span class="s1">arguments: ProjectInfoRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* A request to retrieve compiler options diagnostics for a project</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">CompilerOptionsDiagnosticsRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">arguments: CompilerOptionsDiagnosticsRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Arguments for CompilerOptionsDiagnosticsRequest request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">CompilerOptionsDiagnosticsRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Name of the project to retrieve compiler options diagnostics.</span>
                 <span class="s0">*/</span>
                <span class="s1">projectFileName: string;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Details about the default project for the file if tsconfig file is found</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">DefaultConfiguredProjectInfo {</span>
                <span class="s0">/** List of config files looked and did not match because file was not part of root file names */</span>
                <span class="s1">notMatchedByConfig?: readonly string[];</span>
                <span class="s0">/** List of projects which were loaded but file was not part of the project or is file from referenced project */</span>
                <span class="s1">notInProject?: readonly string[];</span>
                <span class="s0">/** Configured project used as default */</span>
                <span class="s1">defaultProject?: string;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Response message body for &quot;projectInfo&quot; request</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">ProjectInfo {</span>
                <span class="s0">/**</span>
                 <span class="s0">* For configured project, this is the normalized path of the 'tsconfig.json' file</span>
                 <span class="s0">* For inferred project, this is undefined</span>
                 <span class="s0">*/</span>
                <span class="s1">configFileName: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The list of normalized file name in the project, including 'lib.d.ts'</span>
                 <span class="s0">*/</span>
                <span class="s1">fileNames?: string[];</span>
                <span class="s0">/**</span>
                 <span class="s0">* Indicates if the project has a active language service instance</span>
                 <span class="s0">*/</span>
                <span class="s1">languageServiceDisabled?: boolean;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Information about default project</span>
                 <span class="s0">*/</span>
                <span class="s1">configuredProjectInfo?: DefaultConfiguredProjectInfo;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Represents diagnostic info that includes location of diagnostic in two forms</span>
             <span class="s0">* - start position and length of the error span</span>
             <span class="s0">* - startLocation and endLocation - a pair of Location objects that store start/end line and offset of the error span.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">DiagnosticWithLinePosition {</span>
                <span class="s1">message: string;</span>
                <span class="s1">start: number;</span>
                <span class="s1">length: number;</span>
                <span class="s1">startLocation: Location;</span>
                <span class="s1">endLocation: Location;</span>
                <span class="s1">category: string;</span>
                <span class="s1">code: number;</span>
                <span class="s0">/** May store more in future. For now, this will simply be `true` to indicate when a diagnostic is an unused-identifier diagnostic. */</span>
                <span class="s1">reportsUnnecessary?: {};</span>
                <span class="s1">reportsDeprecated?: {};</span>
                <span class="s1">relatedInformation?: DiagnosticRelatedInformation[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Response message for &quot;projectInfo&quot; request</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">ProjectInfoResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: ProjectInfo;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Request whose sole parameter is a file name.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">FileRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">arguments: FileRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Instances of this interface specify a location in a source file:</span>
             <span class="s0">* (file, line, character offset), where line and character offset are 1-based.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">FileLocationRequestArgs </span><span class="s2">extends </span><span class="s1">FileRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The line number for the request (1-based).</span>
                 <span class="s0">*/</span>
                <span class="s1">line: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The character offset (on the line) for the request (1-based).</span>
                 <span class="s0">*/</span>
                <span class="s1">offset: number;</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type FileLocationOrRangeRequestArgs = FileLocationRequestArgs | FileRangeRequestArgs;</span>
            <span class="s0">/**</span>
             <span class="s0">* Request refactorings at a given position or selection area.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">GetApplicableRefactorsRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.GetApplicableRefactors;</span>
                <span class="s1">arguments: GetApplicableRefactorsRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type GetApplicableRefactorsRequestArgs = FileLocationOrRangeRequestArgs &amp; {</span>
                <span class="s1">triggerReason?: RefactorTriggerReason;</span>
                <span class="s1">kind?: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Include refactor actions that require additional arguments to be passed when</span>
                 <span class="s0">* calling 'GetEditsForRefactor'. When true, clients should inspect the</span>
                 <span class="s0">* `isInteractive` property of each returned `RefactorActionInfo`</span>
                 <span class="s0">* and ensure they are able to collect the appropriate arguments for any</span>
                 <span class="s0">* interactive refactor before offering it.</span>
                 <span class="s0">*/</span>
                <span class="s1">includeInteractiveActions?: boolean;</span>
            <span class="s1">};</span>
            <span class="s0">/**</span>
             <span class="s0">* Response is a list of available refactorings.</span>
             <span class="s0">* Each refactoring exposes one or more &quot;Actions&quot;; a user selects one action to invoke a refactoring</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">GetApplicableRefactorsResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: ApplicableRefactorInfo[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Request refactorings at a given position or selection area to move to an existing file.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">GetMoveToRefactoringFileSuggestionsRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.GetMoveToRefactoringFileSuggestions;</span>
                <span class="s1">arguments: GetMoveToRefactoringFileSuggestionsRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type GetMoveToRefactoringFileSuggestionsRequestArgs = FileLocationOrRangeRequestArgs &amp; {</span>
                <span class="s1">kind?: string;</span>
            <span class="s1">};</span>
            <span class="s0">/**</span>
             <span class="s0">* Response is a list of available files.</span>
             <span class="s0">* Each refactoring exposes one or more &quot;Actions&quot;; a user selects one action to invoke a refactoring</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">GetMoveToRefactoringFileSuggestions </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body: {</span>
                    <span class="s1">newFileName: string;</span>
                    <span class="s1">files: string[];</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Request to check if `pasteEdits` should be provided for a given location post copying text from that location.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">PreparePasteEditsRequest </span><span class="s2">extends </span><span class="s1">FileRequest {</span>
                <span class="s1">command: CommandTypes.PreparePasteEdits;</span>
                <span class="s1">arguments: PreparePasteEditsRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">PreparePasteEditsRequestArgs </span><span class="s2">extends </span><span class="s1">FileRequestArgs {</span>
                <span class="s1">copiedTextSpan: TextSpan[];</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">PreparePasteEditsResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body: boolean;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Request refactorings at a given position post pasting text from some other location.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">GetPasteEditsRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.GetPasteEdits;</span>
                <span class="s1">arguments: GetPasteEditsRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">GetPasteEditsRequestArgs </span><span class="s2">extends </span><span class="s1">FileRequestArgs {</span>
                <span class="s0">/** The text that gets pasted in a file.  */</span>
                <span class="s1">pastedText: string[];</span>
                <span class="s0">/** Locations of where the `pastedText` gets added in a file. If the length of the `pastedText` and `pastedLocations` are not the same,</span>
                 <span class="s0">*  then the `pastedText` is combined into one and added at all the `pastedLocations`.</span>
                 <span class="s0">*/</span>
                <span class="s1">pasteLocations: TextSpan[];</span>
                <span class="s0">/** The source location of each `pastedText`. If present, the length of `spans` must be equal to the length of `pastedText`. */</span>
                <span class="s1">copiedFrom?: {</span>
                    <span class="s1">file: string;</span>
                    <span class="s1">spans: TextSpan[];</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">GetPasteEditsResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body: PasteEditsAction;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">PasteEditsAction {</span>
                <span class="s1">edits: FileCodeEdits[];</span>
                <span class="s1">fixId?: {};</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">GetEditsForRefactorRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.GetEditsForRefactor;</span>
                <span class="s1">arguments: GetEditsForRefactorRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Request the edits that a particular refactoring action produces.</span>
             <span class="s0">* Callers must specify the name of the refactor and the name of the action.</span>
             <span class="s0">*/</span>
            <span class="s2">export </span><span class="s1">type GetEditsForRefactorRequestArgs = FileLocationOrRangeRequestArgs &amp; {</span>
                <span class="s1">refactor: string;</span>
                <span class="s1">action: string;</span>
                <span class="s1">interactiveRefactorArguments?: InteractiveRefactorArguments;</span>
            <span class="s1">};</span>
            <span class="s2">export interface </span><span class="s1">GetEditsForRefactorResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: RefactorEditInfo;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">RefactorEditInfo {</span>
                <span class="s1">edits: FileCodeEdits[];</span>
                <span class="s0">/**</span>
                 <span class="s0">* An optional location where the editor should start a rename operation once</span>
                 <span class="s0">* the refactoring edits have been applied</span>
                 <span class="s0">*/</span>
                <span class="s1">renameLocation?: Location;</span>
                <span class="s1">renameFilename?: string;</span>
                <span class="s1">notApplicableReason?: string;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Organize imports by:</span>
             <span class="s0">*   1) Removing unused imports</span>
             <span class="s0">*   2) Coalescing imports from the same module</span>
             <span class="s0">*   3) Sorting imports</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">OrganizeImportsRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.OrganizeImports;</span>
                <span class="s1">arguments: OrganizeImportsRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type OrganizeImportsScope = GetCombinedCodeFixScope;</span>
            <span class="s2">export interface </span><span class="s1">OrganizeImportsRequestArgs {</span>
                <span class="s1">scope: OrganizeImportsScope;</span>
                <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">Use `mode` instead */</span>
                <span class="s1">skipDestructiveCodeActions?: boolean;</span>
                <span class="s1">mode?: OrganizeImportsMode;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">OrganizeImportsResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body: readonly FileCodeEdits[];</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">GetEditsForFileRenameRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.GetEditsForFileRename;</span>
                <span class="s1">arguments: GetEditsForFileRenameRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/** Note: Paths may also be directories. */</span>
            <span class="s2">export interface </span><span class="s1">GetEditsForFileRenameRequestArgs {</span>
                <span class="s1">readonly oldFilePath: string;</span>
                <span class="s1">readonly newFilePath: string;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">GetEditsForFileRenameResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body: readonly FileCodeEdits[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Request for the available codefixes at a specific position.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">CodeFixRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.GetCodeFixes;</span>
                <span class="s1">arguments: CodeFixRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">GetCombinedCodeFixRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.GetCombinedCodeFix;</span>
                <span class="s1">arguments: GetCombinedCodeFixRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">GetCombinedCodeFixResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body: CombinedCodeActions;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">ApplyCodeActionCommandRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.ApplyCodeActionCommand;</span>
                <span class="s1">arguments: ApplyCodeActionCommandRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">ApplyCodeActionCommandResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">FileRangeRequestArgs </span><span class="s2">extends </span><span class="s1">FileRequestArgs, FileRange {</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Instances of this interface specify errorcodes on a specific location in a sourcefile.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">CodeFixRequestArgs </span><span class="s2">extends </span><span class="s1">FileRangeRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Errorcodes we want to get the fixes for.</span>
                 <span class="s0">*/</span>
                <span class="s1">errorCodes: readonly number[];</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">GetCombinedCodeFixRequestArgs {</span>
                <span class="s1">scope: GetCombinedCodeFixScope;</span>
                <span class="s1">fixId: {};</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">GetCombinedCodeFixScope {</span>
                <span class="s1">type: </span><span class="s3">&quot;file&quot;</span><span class="s1">;</span>
                <span class="s1">args: FileRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">ApplyCodeActionCommandRequestArgs {</span>
                <span class="s0">/** May also be an array of commands. */</span>
                <span class="s1">command: {};</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Response for GetCodeFixes request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">GetCodeFixesResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: CodeAction[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* A request whose arguments specify a file location (file, line, col).</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">FileLocationRequest </span><span class="s2">extends </span><span class="s1">FileRequest {</span>
                <span class="s1">arguments: FileLocationRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* A request to get codes of supported code fixes.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">GetSupportedCodeFixesRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.GetSupportedCodeFixes;</span>
                <span class="s1">arguments?: Partial&lt;FileRequestArgs&gt;;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* A response for GetSupportedCodeFixesRequest request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">GetSupportedCodeFixesResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s0">/**</span>
                 <span class="s0">* List of error codes supported by the server.</span>
                 <span class="s0">*/</span>
                <span class="s1">body?: string[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* A request to get encoded semantic classifications for a span in the file</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">EncodedSemanticClassificationsRequest </span><span class="s2">extends </span><span class="s1">FileRequest {</span>
                <span class="s1">arguments: EncodedSemanticClassificationsRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Arguments for EncodedSemanticClassificationsRequest request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">EncodedSemanticClassificationsRequestArgs </span><span class="s2">extends </span><span class="s1">FileRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Start position of the span.</span>
                 <span class="s0">*/</span>
                <span class="s1">start: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Length of the span.</span>
                 <span class="s0">*/</span>
                <span class="s1">length: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Optional parameter for the semantic highlighting response, if absent it</span>
                 <span class="s0">* defaults to &quot;original&quot;.</span>
                 <span class="s0">*/</span>
                <span class="s1">format?: </span><span class="s3">&quot;original&quot; </span><span class="s1">| </span><span class="s3">&quot;2020&quot;</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">/** The response for a EncodedSemanticClassificationsRequest */</span>
            <span class="s2">export interface </span><span class="s1">EncodedSemanticClassificationsResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: EncodedSemanticClassificationsResponseBody;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Implementation response message. Gives series of text spans depending on the format ar.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">EncodedSemanticClassificationsResponseBody {</span>
                <span class="s1">endOfLineState: EndOfLineState;</span>
                <span class="s1">spans: number[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Arguments in document highlight request; include: filesToSearch, file,</span>
             <span class="s0">* line, offset.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">DocumentHighlightsRequestArgs </span><span class="s2">extends </span><span class="s1">FileLocationRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* List of files to search for document highlights.</span>
                 <span class="s0">*/</span>
                <span class="s1">filesToSearch: string[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Go to definition request; value of command field is</span>
             <span class="s0">* &quot;definition&quot;. Return response giving the file locations that</span>
             <span class="s0">* define the symbol found in file at location line, col.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">DefinitionRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">command: CommandTypes.Definition;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">DefinitionAndBoundSpanRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">readonly command: CommandTypes.DefinitionAndBoundSpan;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">FindSourceDefinitionRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">readonly command: CommandTypes.FindSourceDefinition;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">DefinitionAndBoundSpanResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">readonly body: DefinitionInfoAndBoundSpan;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Go to type request; value of command field is</span>
             <span class="s0">* &quot;typeDefinition&quot;. Return response giving the file locations that</span>
             <span class="s0">* define the type for the symbol found in file at location line, col.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">TypeDefinitionRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">command: CommandTypes.TypeDefinition;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Go to implementation request; value of command field is</span>
             <span class="s0">* &quot;implementation&quot;. Return response giving the file locations that</span>
             <span class="s0">* implement the symbol found in file at location line, col.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">ImplementationRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">command: CommandTypes.Implementation;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Location in source code expressed as (one-based) line and (one-based) column offset.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">Location {</span>
                <span class="s1">line: number;</span>
                <span class="s1">offset: number;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Object found in response messages defining a span of text in source code.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">TextSpan {</span>
                <span class="s0">/**</span>
                 <span class="s0">* First character of the definition.</span>
                 <span class="s0">*/</span>
                <span class="s1">start: Location;</span>
                <span class="s0">/**</span>
                 <span class="s0">* One character past last character of the definition.</span>
                 <span class="s0">*/</span>
                <span class="s1">end: Location;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Object found in response messages defining a span of text in a specific source file.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">FileSpan </span><span class="s2">extends </span><span class="s1">TextSpan {</span>
                <span class="s0">/**</span>
                 <span class="s0">* File containing text span.</span>
                 <span class="s0">*/</span>
                <span class="s1">file: string;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">JSDocTagInfo {</span>
                <span class="s0">/** Name of the JSDoc tag */</span>
                <span class="s1">name: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Comment text after the JSDoc tag -- the text after the tag name until the next tag or end of comment</span>
                 <span class="s0">* Display parts when UserPreferences.displayPartsForJSDoc is true, flattened to string otherwise.</span>
                 <span class="s0">*/</span>
                <span class="s1">text?: string | SymbolDisplayPart[];</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">TextSpanWithContext </span><span class="s2">extends </span><span class="s1">TextSpan {</span>
                <span class="s1">contextStart?: Location;</span>
                <span class="s1">contextEnd?: Location;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">FileSpanWithContext </span><span class="s2">extends </span><span class="s1">FileSpan, TextSpanWithContext {</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">DefinitionInfo </span><span class="s2">extends </span><span class="s1">FileSpanWithContext {</span>
                <span class="s0">/**</span>
                 <span class="s0">* When true, the file may or may not exist.</span>
                 <span class="s0">*/</span>
                <span class="s1">unverified?: boolean;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">DefinitionInfoAndBoundSpan {</span>
                <span class="s1">definitions: readonly DefinitionInfo[];</span>
                <span class="s1">textSpan: TextSpan;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Definition response message.  Gives text range for definition.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">DefinitionResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: DefinitionInfo[];</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">DefinitionInfoAndBoundSpanResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: DefinitionInfoAndBoundSpan;</span>
            <span class="s1">}</span>
            <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">Use `DefinitionInfoAndBoundSpanResponse` instead. */</span>
            <span class="s2">export </span><span class="s1">type DefinitionInfoAndBoundSpanReponse = DefinitionInfoAndBoundSpanResponse;</span>
            <span class="s0">/**</span>
             <span class="s0">* Definition response message.  Gives text range for definition.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">TypeDefinitionResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: FileSpanWithContext[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Implementation response message.  Gives text range for implementations.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">ImplementationResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: FileSpanWithContext[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Request to get brace completion for a location in the file.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">BraceCompletionRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">command: CommandTypes.BraceCompletion;</span>
                <span class="s1">arguments: BraceCompletionRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Argument for BraceCompletionRequest request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">BraceCompletionRequestArgs </span><span class="s2">extends </span><span class="s1">FileLocationRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Kind of opening brace</span>
                 <span class="s0">*/</span>
                <span class="s1">openingBrace: string;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">JsxClosingTagRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">readonly command: CommandTypes.JsxClosingTag;</span>
                <span class="s1">readonly arguments: JsxClosingTagRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">JsxClosingTagRequestArgs </span><span class="s2">extends </span><span class="s1">FileLocationRequestArgs {</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">JsxClosingTagResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">readonly body: TextInsertion;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">LinkedEditingRangeRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">readonly command: CommandTypes.LinkedEditingRange;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">LinkedEditingRangesBody {</span>
                <span class="s1">ranges: TextSpan[];</span>
                <span class="s1">wordPattern?: string;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">LinkedEditingRangeResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">readonly body: LinkedEditingRangesBody;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Get document highlights request; value of command field is</span>
             <span class="s0">* &quot;documentHighlights&quot;. Return response giving spans that are relevant</span>
             <span class="s0">* in the file at a given line and column.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">DocumentHighlightsRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">command: CommandTypes.DocumentHighlights;</span>
                <span class="s1">arguments: DocumentHighlightsRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Span augmented with extra information that denotes the kind of the highlighting to be used for span.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">HighlightSpan </span><span class="s2">extends </span><span class="s1">TextSpanWithContext {</span>
                <span class="s1">kind: HighlightSpanKind;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Represents a set of highligh spans for a give name</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">DocumentHighlightsItem {</span>
                <span class="s0">/**</span>
                 <span class="s0">* File containing highlight spans.</span>
                 <span class="s0">*/</span>
                <span class="s1">file: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Spans to highlight in file.</span>
                 <span class="s0">*/</span>
                <span class="s1">highlightSpans: HighlightSpan[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Response for a DocumentHighlightsRequest request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">DocumentHighlightsResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: DocumentHighlightsItem[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Find references request; value of command field is</span>
             <span class="s0">* &quot;references&quot;. Return response giving the file locations that</span>
             <span class="s0">* reference the symbol found in file at location line, col.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">ReferencesRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">command: CommandTypes.References;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">ReferencesResponseItem </span><span class="s2">extends </span><span class="s1">FileSpanWithContext {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Text of line containing the reference. Including this</span>
                 <span class="s0">* with the response avoids latency of editor loading files</span>
                 <span class="s0">* to show text of reference line (the server already has loaded the referencing files).</span>
                 <span class="s0">*</span>
                 <span class="s0">* If {</span><span class="s4">@link </span><span class="s0">UserPreferences.disableLineTextInReferences} is enabled, the property won't be filled</span>
                 <span class="s0">*/</span>
                <span class="s1">lineText?: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* True if reference is a write location, false otherwise.</span>
                 <span class="s0">*/</span>
                <span class="s1">isWriteAccess: boolean;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Present only if the search was triggered from a declaration.</span>
                 <span class="s0">* True indicates that the references refers to the same symbol</span>
                 <span class="s0">* (i.e. has the same meaning) as the declaration that began the</span>
                 <span class="s0">* search.</span>
                 <span class="s0">*/</span>
                <span class="s1">isDefinition?: boolean;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* The body of a &quot;references&quot; response message.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">ReferencesResponseBody {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The file locations referencing the symbol.</span>
                 <span class="s0">*/</span>
                <span class="s1">refs: readonly ReferencesResponseItem[];</span>
                <span class="s0">/**</span>
                 <span class="s0">* The name of the symbol.</span>
                 <span class="s0">*/</span>
                <span class="s1">symbolName: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The start character offset of the symbol (on the line provided by the references request).</span>
                 <span class="s0">*/</span>
                <span class="s1">symbolStartOffset: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The full display name of the symbol.</span>
                 <span class="s0">*/</span>
                <span class="s1">symbolDisplayString: string;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Response to &quot;references&quot; request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">ReferencesResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: ReferencesResponseBody;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">FileReferencesRequest </span><span class="s2">extends </span><span class="s1">FileRequest {</span>
                <span class="s1">command: CommandTypes.FileReferences;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">FileReferencesResponseBody {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The file locations referencing the symbol.</span>
                 <span class="s0">*/</span>
                <span class="s1">refs: readonly ReferencesResponseItem[];</span>
                <span class="s0">/**</span>
                 <span class="s0">* The name of the symbol.</span>
                 <span class="s0">*/</span>
                <span class="s1">symbolName: string;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">FileReferencesResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: FileReferencesResponseBody;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Argument for RenameRequest request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">RenameRequestArgs </span><span class="s2">extends </span><span class="s1">FileLocationRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Should text at specified location be found/changed in comments?</span>
                 <span class="s0">*/</span>
                <span class="s1">findInComments?: boolean;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Should text at specified location be found/changed in strings?</span>
                 <span class="s0">*/</span>
                <span class="s1">findInStrings?: boolean;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Rename request; value of command field is &quot;rename&quot;. Return</span>
             <span class="s0">* response giving the file locations that reference the symbol</span>
             <span class="s0">* found in file at location line, col. Also return full display</span>
             <span class="s0">* name of the symbol so that client can print it unambiguously.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">RenameRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">command: CommandTypes.Rename;</span>
                <span class="s1">arguments: RenameRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Information about the item to be renamed.</span>
             <span class="s0">*/</span>
            <span class="s2">export </span><span class="s1">type RenameInfo = RenameInfoSuccess | RenameInfoFailure;</span>
            <span class="s2">export </span><span class="s1">type RenameInfoSuccess = ChangePropertyTypes&lt;ts.RenameInfoSuccess, {</span>
                <span class="s1">triggerSpan: TextSpan;</span>
            <span class="s1">}&gt;;</span>
            <span class="s0">/**</span>
             <span class="s0">*  A group of text spans, all in 'file'.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">SpanGroup {</span>
                <span class="s0">/** The file to which the spans apply */</span>
                <span class="s1">file: string;</span>
                <span class="s0">/** The text spans in this group */</span>
                <span class="s1">locs: RenameTextSpan[];</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">RenameTextSpan </span><span class="s2">extends </span><span class="s1">TextSpanWithContext {</span>
                <span class="s1">readonly prefixText?: string;</span>
                <span class="s1">readonly suffixText?: string;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">RenameResponseBody {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Information about the item to be renamed.</span>
                 <span class="s0">*/</span>
                <span class="s1">info: RenameInfo;</span>
                <span class="s0">/**</span>
                 <span class="s0">* An array of span groups (one per file) that refer to the item to be renamed.</span>
                 <span class="s0">*/</span>
                <span class="s1">locs: readonly SpanGroup[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Rename response message.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">RenameResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: RenameResponseBody;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Represents a file in external project.</span>
             <span class="s0">* External project is project whose set of files, compilation options and open\close state</span>
             <span class="s0">* is maintained by the client (i.e. if all this data come from .csproj file in Visual Studio).</span>
             <span class="s0">* External project will exist even if all files in it are closed and should be closed explicitly.</span>
             <span class="s0">* If external project includes one or more tsconfig.json/jsconfig.json files then tsserver will</span>
             <span class="s0">* create configured project for every config file but will maintain a link that these projects were created</span>
             <span class="s0">* as a result of opening external project so they should be removed once external project is closed.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">ExternalFile {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Name of file file</span>
                 <span class="s0">*/</span>
                <span class="s1">fileName: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Script kind of the file</span>
                 <span class="s0">*/</span>
                <span class="s1">scriptKind?: ScriptKindName | ScriptKind;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Whether file has mixed content (i.e. .cshtml file that combines html markup with C#/JavaScript)</span>
                 <span class="s0">*/</span>
                <span class="s1">hasMixedContent?: boolean;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Content of the file</span>
                 <span class="s0">*/</span>
                <span class="s1">content?: string;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Represent an external project</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">ExternalProject {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Project name</span>
                 <span class="s0">*/</span>
                <span class="s1">projectFileName: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* List of root files in project</span>
                 <span class="s0">*/</span>
                <span class="s1">rootFiles: ExternalFile[];</span>
                <span class="s0">/**</span>
                 <span class="s0">* Compiler options for the project</span>
                 <span class="s0">*/</span>
                <span class="s1">options: ExternalProjectCompilerOptions;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Explicitly specified type acquisition for the project</span>
                 <span class="s0">*/</span>
                <span class="s1">typeAcquisition?: TypeAcquisition;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">CompileOnSaveMixin {</span>
                <span class="s0">/**</span>
                 <span class="s0">* If compile on save is enabled for the project</span>
                 <span class="s0">*/</span>
                <span class="s1">compileOnSave?: boolean;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* For external projects, some of the project settings are sent together with</span>
             <span class="s0">* compiler settings.</span>
             <span class="s0">*/</span>
            <span class="s2">export </span><span class="s1">type ExternalProjectCompilerOptions = CompilerOptions &amp; CompileOnSaveMixin &amp; WatchOptions;</span>
            <span class="s2">export interface </span><span class="s1">FileWithProjectReferenceRedirectInfo {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Name of file</span>
                 <span class="s0">*/</span>
                <span class="s1">fileName: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* True if the file is primarily included in a referenced project</span>
                 <span class="s0">*/</span>
                <span class="s1">isSourceOfProjectReferenceRedirect: boolean;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Represents a set of changes that happen in project</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">ProjectChanges {</span>
                <span class="s0">/**</span>
                 <span class="s0">* List of added files</span>
                 <span class="s0">*/</span>
                <span class="s1">added: string[] | FileWithProjectReferenceRedirectInfo[];</span>
                <span class="s0">/**</span>
                 <span class="s0">* List of removed files</span>
                 <span class="s0">*/</span>
                <span class="s1">removed: string[] | FileWithProjectReferenceRedirectInfo[];</span>
                <span class="s0">/**</span>
                 <span class="s0">* List of updated files</span>
                 <span class="s0">*/</span>
                <span class="s1">updated: string[] | FileWithProjectReferenceRedirectInfo[];</span>
                <span class="s0">/**</span>
                 <span class="s0">* List of files that have had their project reference redirect status updated</span>
                 <span class="s0">* Only provided when the synchronizeProjectList request has includeProjectReferenceRedirectInfo set to true</span>
                 <span class="s0">*/</span>
                <span class="s1">updatedRedirects?: FileWithProjectReferenceRedirectInfo[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Information found in a configure request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">ConfigureRequestArguments {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Information about the host, for example 'Emacs 24.4' or</span>
                 <span class="s0">* 'Sublime Text version 3075'</span>
                 <span class="s0">*/</span>
                <span class="s1">hostInfo?: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* If present, tab settings apply only to this file.</span>
                 <span class="s0">*/</span>
                <span class="s1">file?: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The format options to use during formatting and other code editing features.</span>
                 <span class="s0">*/</span>
                <span class="s1">formatOptions?: FormatCodeSettings;</span>
                <span class="s1">preferences?: UserPreferences;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The host's additional supported .js file extensions</span>
                 <span class="s0">*/</span>
                <span class="s1">extraFileExtensions?: FileExtensionInfo[];</span>
                <span class="s1">watchOptions?: WatchOptions;</span>
            <span class="s1">}</span>
            <span class="s2">export enum </span><span class="s1">WatchFileKind {</span>
                <span class="s1">FixedPollingInterval = </span><span class="s3">&quot;FixedPollingInterval&quot;</span><span class="s1">,</span>
                <span class="s1">PriorityPollingInterval = </span><span class="s3">&quot;PriorityPollingInterval&quot;</span><span class="s1">,</span>
                <span class="s1">DynamicPriorityPolling = </span><span class="s3">&quot;DynamicPriorityPolling&quot;</span><span class="s1">,</span>
                <span class="s1">FixedChunkSizePolling = </span><span class="s3">&quot;FixedChunkSizePolling&quot;</span><span class="s1">,</span>
                <span class="s1">UseFsEvents = </span><span class="s3">&quot;UseFsEvents&quot;</span><span class="s1">,</span>
                <span class="s1">UseFsEventsOnParentDirectory = </span><span class="s3">&quot;UseFsEventsOnParentDirectory&quot;</span><span class="s1">,</span>
            <span class="s1">}</span>
            <span class="s2">export enum </span><span class="s1">WatchDirectoryKind {</span>
                <span class="s1">UseFsEvents = </span><span class="s3">&quot;UseFsEvents&quot;</span><span class="s1">,</span>
                <span class="s1">FixedPollingInterval = </span><span class="s3">&quot;FixedPollingInterval&quot;</span><span class="s1">,</span>
                <span class="s1">DynamicPriorityPolling = </span><span class="s3">&quot;DynamicPriorityPolling&quot;</span><span class="s1">,</span>
                <span class="s1">FixedChunkSizePolling = </span><span class="s3">&quot;FixedChunkSizePolling&quot;</span><span class="s1">,</span>
            <span class="s1">}</span>
            <span class="s2">export enum </span><span class="s1">PollingWatchKind {</span>
                <span class="s1">FixedInterval = </span><span class="s3">&quot;FixedInterval&quot;</span><span class="s1">,</span>
                <span class="s1">PriorityInterval = </span><span class="s3">&quot;PriorityInterval&quot;</span><span class="s1">,</span>
                <span class="s1">DynamicPriority = </span><span class="s3">&quot;DynamicPriority&quot;</span><span class="s1">,</span>
                <span class="s1">FixedChunkSize = </span><span class="s3">&quot;FixedChunkSize&quot;</span><span class="s1">,</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">WatchOptions {</span>
                <span class="s1">watchFile?: WatchFileKind | ts.WatchFileKind;</span>
                <span class="s1">watchDirectory?: WatchDirectoryKind | ts.WatchDirectoryKind;</span>
                <span class="s1">fallbackPolling?: PollingWatchKind | ts.PollingWatchKind;</span>
                <span class="s1">synchronousWatchDirectory?: boolean;</span>
                <span class="s1">excludeDirectories?: string[];</span>
                <span class="s1">excludeFiles?: string[];</span>
                <span class="s1">[option: string]: CompilerOptionsValue | undefined;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">*  Configure request; value of command field is &quot;configure&quot;.  Specifies</span>
             <span class="s0">*  host information, such as host type, tab size, and indent size.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">ConfigureRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.Configure;</span>
                <span class="s1">arguments: ConfigureRequestArguments;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Response to &quot;configure&quot; request.  This is just an acknowledgement, so</span>
             <span class="s0">* no body field is required.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">ConfigureResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">ConfigurePluginRequestArguments {</span>
                <span class="s1">pluginName: string;</span>
                <span class="s1">configuration: any;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">ConfigurePluginRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.ConfigurePlugin;</span>
                <span class="s1">arguments: ConfigurePluginRequestArguments;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">ConfigurePluginResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">SelectionRangeRequest </span><span class="s2">extends </span><span class="s1">FileRequest {</span>
                <span class="s1">command: CommandTypes.SelectionRange;</span>
                <span class="s1">arguments: SelectionRangeRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">SelectionRangeRequestArgs </span><span class="s2">extends </span><span class="s1">FileRequestArgs {</span>
                <span class="s1">locations: Location[];</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">SelectionRangeResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: SelectionRange[];</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">SelectionRange {</span>
                <span class="s1">textSpan: TextSpan;</span>
                <span class="s1">parent?: SelectionRange;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">ToggleLineCommentRequest </span><span class="s2">extends </span><span class="s1">FileRequest {</span>
                <span class="s1">command: CommandTypes.ToggleLineComment;</span>
                <span class="s1">arguments: FileRangeRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">ToggleMultilineCommentRequest </span><span class="s2">extends </span><span class="s1">FileRequest {</span>
                <span class="s1">command: CommandTypes.ToggleMultilineComment;</span>
                <span class="s1">arguments: FileRangeRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">CommentSelectionRequest </span><span class="s2">extends </span><span class="s1">FileRequest {</span>
                <span class="s1">command: CommandTypes.CommentSelection;</span>
                <span class="s1">arguments: FileRangeRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">UncommentSelectionRequest </span><span class="s2">extends </span><span class="s1">FileRequest {</span>
                <span class="s1">command: CommandTypes.UncommentSelection;</span>
                <span class="s1">arguments: FileRangeRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">*  Information found in an &quot;open&quot; request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">OpenRequestArgs </span><span class="s2">extends </span><span class="s1">FileRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Used when a version of the file content is known to be more up to date than the one on disk.</span>
                 <span class="s0">* Then the known content will be used upon opening instead of the disk copy</span>
                 <span class="s0">*/</span>
                <span class="s1">fileContent?: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Used to specify the script kind of the file explicitly. It could be one of the following:</span>
                 <span class="s0">*      &quot;TS&quot;, &quot;JS&quot;, &quot;TSX&quot;, &quot;JSX&quot;</span>
                 <span class="s0">*/</span>
                <span class="s1">scriptKindName?: ScriptKindName;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Used to limit the searching for project config file. If given the searching will stop at this</span>
                 <span class="s0">* root path; otherwise it will go all the way up to the dist root path.</span>
                 <span class="s0">*/</span>
                <span class="s1">projectRootPath?: string;</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type ScriptKindName = </span><span class="s3">&quot;TS&quot; </span><span class="s1">| </span><span class="s3">&quot;JS&quot; </span><span class="s1">| </span><span class="s3">&quot;TSX&quot; </span><span class="s1">| </span><span class="s3">&quot;JSX&quot;</span><span class="s1">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Open request; value of command field is &quot;open&quot;. Notify the</span>
             <span class="s0">* server that the client has file open.  The server will not</span>
             <span class="s0">* monitor the filesystem for changes in this file and will assume</span>
             <span class="s0">* that the client is updating the server (using the change and/or</span>
             <span class="s0">* reload messages) when the file changes. Server does not currently</span>
             <span class="s0">* send a response to an open request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">OpenRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.Open;</span>
                <span class="s1">arguments: OpenRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Request to open or update external project</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">OpenExternalProjectRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.OpenExternalProject;</span>
                <span class="s1">arguments: OpenExternalProjectArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Arguments to OpenExternalProjectRequest request</span>
             <span class="s0">*/</span>
            <span class="s2">export </span><span class="s1">type OpenExternalProjectArgs = ExternalProject;</span>
            <span class="s0">/**</span>
             <span class="s0">* Request to open multiple external projects</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">OpenExternalProjectsRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.OpenExternalProjects;</span>
                <span class="s1">arguments: OpenExternalProjectsArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Arguments to OpenExternalProjectsRequest</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">OpenExternalProjectsArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* List of external projects to open or update</span>
                 <span class="s0">*/</span>
                <span class="s1">projects: ExternalProject[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Response to OpenExternalProjectRequest request. This is just an acknowledgement, so</span>
             <span class="s0">* no body field is required.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">OpenExternalProjectResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Response to OpenExternalProjectsRequest request. This is just an acknowledgement, so</span>
             <span class="s0">* no body field is required.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">OpenExternalProjectsResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Request to close external project.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">CloseExternalProjectRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.CloseExternalProject;</span>
                <span class="s1">arguments: CloseExternalProjectRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Arguments to CloseExternalProjectRequest request</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">CloseExternalProjectRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Name of the project to close</span>
                 <span class="s0">*/</span>
                <span class="s1">projectFileName: string;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Response to CloseExternalProjectRequest request. This is just an acknowledgement, so</span>
             <span class="s0">* no body field is required.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">CloseExternalProjectResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Request to synchronize list of open files with the client</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">UpdateOpenRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.UpdateOpen;</span>
                <span class="s1">arguments: UpdateOpenRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Arguments to UpdateOpenRequest</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">UpdateOpenRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* List of newly open files</span>
                 <span class="s0">*/</span>
                <span class="s1">openFiles?: OpenRequestArgs[];</span>
                <span class="s0">/**</span>
                 <span class="s0">* List of open files files that were changes</span>
                 <span class="s0">*/</span>
                <span class="s1">changedFiles?: FileCodeEdits[];</span>
                <span class="s0">/**</span>
                 <span class="s0">* List of files that were closed</span>
                 <span class="s0">*/</span>
                <span class="s1">closedFiles?: string[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* External projects have a typeAcquisition option so they need to be added separately to compiler options for inferred projects.</span>
             <span class="s0">*/</span>
            <span class="s2">export </span><span class="s1">type InferredProjectCompilerOptions = ExternalProjectCompilerOptions &amp; TypeAcquisition;</span>
            <span class="s0">/**</span>
             <span class="s0">* Request to set compiler options for inferred projects.</span>
             <span class="s0">* External projects are opened / closed explicitly.</span>
             <span class="s0">* Configured projects are opened when user opens loose file that has 'tsconfig.json' or 'jsconfig.json' anywhere in one of containing folders.</span>
             <span class="s0">* This configuration file will be used to obtain a list of files and configuration settings for the project.</span>
             <span class="s0">* Inferred projects are created when user opens a loose file that is not the part of external project</span>
             <span class="s0">* or configured project and will contain only open file and transitive closure of referenced files if 'useOneInferredProject' is false,</span>
             <span class="s0">* or all open loose files and its transitive closure of referenced files if 'useOneInferredProject' is true.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">SetCompilerOptionsForInferredProjectsRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.CompilerOptionsForInferredProjects;</span>
                <span class="s1">arguments: SetCompilerOptionsForInferredProjectsArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Argument for SetCompilerOptionsForInferredProjectsRequest request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">SetCompilerOptionsForInferredProjectsArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Compiler options to be used with inferred projects.</span>
                 <span class="s0">*/</span>
                <span class="s1">options: InferredProjectCompilerOptions;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Specifies the project root path used to scope compiler options.</span>
                 <span class="s0">* It is an error to provide this property if the server has not been started with</span>
                 <span class="s0">* `useInferredProjectPerProjectRoot` enabled.</span>
                 <span class="s0">*/</span>
                <span class="s1">projectRootPath?: string;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Response to SetCompilerOptionsForInferredProjectsResponse request. This is just an acknowledgement, so</span>
             <span class="s0">* no body field is required.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">SetCompilerOptionsForInferredProjectsResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">*  Exit request; value of command field is &quot;exit&quot;.  Ask the server process</span>
             <span class="s0">*  to exit.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">ExitRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.Exit;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Close request; value of command field is &quot;close&quot;. Notify the</span>
             <span class="s0">* server that the client has closed a previously open file.  If</span>
             <span class="s0">* file is still referenced by open files, the server will resume</span>
             <span class="s0">* monitoring the filesystem for changes to file.  Server does not</span>
             <span class="s0">* currently send a response to a close request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">CloseRequest </span><span class="s2">extends </span><span class="s1">FileRequest {</span>
                <span class="s1">command: CommandTypes.Close;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">WatchChangeRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.WatchChange;</span>
                <span class="s1">arguments: WatchChangeRequestArgs | readonly WatchChangeRequestArgs[];</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">WatchChangeRequestArgs {</span>
                <span class="s1">id: number;</span>
                <span class="s1">created?: string[];</span>
                <span class="s1">deleted?: string[];</span>
                <span class="s1">updated?: string[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Request to obtain the list of files that should be regenerated if target file is recompiled.</span>
             <span class="s0">* NOTE: this us query-only operation and does not generate any output on disk.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">CompileOnSaveAffectedFileListRequest </span><span class="s2">extends </span><span class="s1">FileRequest {</span>
                <span class="s1">command: CommandTypes.CompileOnSaveAffectedFileList;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Contains a list of files that should be regenerated in a project</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">CompileOnSaveAffectedFileListSingleProject {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Project name</span>
                 <span class="s0">*/</span>
                <span class="s1">projectFileName: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* List of files names that should be recompiled</span>
                 <span class="s0">*/</span>
                <span class="s1">fileNames: string[];</span>
                <span class="s0">/**</span>
                 <span class="s0">* true if project uses outFile or out compiler option</span>
                 <span class="s0">*/</span>
                <span class="s1">projectUsesOutFile: boolean;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Response for CompileOnSaveAffectedFileListRequest request;</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">CompileOnSaveAffectedFileListResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body: CompileOnSaveAffectedFileListSingleProject[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Request to recompile the file. All generated outputs (.js, .d.ts or .js.map files) is written on disk.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">CompileOnSaveEmitFileRequest </span><span class="s2">extends </span><span class="s1">FileRequest {</span>
                <span class="s1">command: CommandTypes.CompileOnSaveEmitFile;</span>
                <span class="s1">arguments: CompileOnSaveEmitFileRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Arguments for CompileOnSaveEmitFileRequest</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">CompileOnSaveEmitFileRequestArgs </span><span class="s2">extends </span><span class="s1">FileRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* if true - then file should be recompiled even if it does not have any changes.</span>
                 <span class="s0">*/</span>
                <span class="s1">forced?: boolean;</span>
                <span class="s1">includeLinePosition?: boolean;</span>
                <span class="s0">/** if true - return response as object with emitSkipped and diagnostics */</span>
                <span class="s1">richResponse?: boolean;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">CompileOnSaveEmitFileResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body: boolean | EmitResult;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">EmitResult {</span>
                <span class="s1">emitSkipped: boolean;</span>
                <span class="s1">diagnostics: Diagnostic[] | DiagnosticWithLinePosition[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Quickinfo request; value of command field is</span>
             <span class="s0">* &quot;quickinfo&quot;. Return response giving a quick type and</span>
             <span class="s0">* documentation string for the symbol found in file at location</span>
             <span class="s0">* line, col.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">QuickInfoRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">command: CommandTypes.Quickinfo;</span>
                <span class="s1">arguments: FileLocationRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">QuickInfoRequestArgs </span><span class="s2">extends </span><span class="s1">FileLocationRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* This controls how many levels of definitions will be expanded in the quick info response.</span>
                 <span class="s0">* The default value is 0.</span>
                 <span class="s0">*/</span>
                <span class="s1">verbosityLevel?: number;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Body of QuickInfoResponse.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">QuickInfoResponseBody {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The symbol's kind (such as 'className' or 'parameterName' or plain 'text').</span>
                 <span class="s0">*/</span>
                <span class="s1">kind: ScriptElementKind;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Optional modifiers for the kind (such as 'public').</span>
                 <span class="s0">*/</span>
                <span class="s1">kindModifiers: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Starting file location of symbol.</span>
                 <span class="s0">*/</span>
                <span class="s1">start: Location;</span>
                <span class="s0">/**</span>
                 <span class="s0">* One past last character of symbol.</span>
                 <span class="s0">*/</span>
                <span class="s1">end: Location;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Type and kind of symbol.</span>
                 <span class="s0">*/</span>
                <span class="s1">displayString: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Documentation associated with symbol.</span>
                 <span class="s0">* Display parts when UserPreferences.displayPartsForJSDoc is true, flattened to string otherwise.</span>
                 <span class="s0">*/</span>
                <span class="s1">documentation: string | SymbolDisplayPart[];</span>
                <span class="s0">/**</span>
                 <span class="s0">* JSDoc tags associated with symbol.</span>
                 <span class="s0">*/</span>
                <span class="s1">tags: JSDocTagInfo[];</span>
                <span class="s0">/**</span>
                 <span class="s0">* Whether the verbosity level can be increased for this quick info response.</span>
                 <span class="s0">*/</span>
                <span class="s1">canIncreaseVerbosityLevel?: boolean;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Quickinfo response message.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">QuickInfoResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: QuickInfoResponseBody;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Arguments for format messages.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">FormatRequestArgs </span><span class="s2">extends </span><span class="s1">FileLocationRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Last line of range for which to format text in file.</span>
                 <span class="s0">*/</span>
                <span class="s1">endLine: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Character offset on last line of range for which to format text in file.</span>
                 <span class="s0">*/</span>
                <span class="s1">endOffset: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Format options to be used.</span>
                 <span class="s0">*/</span>
                <span class="s1">options?: FormatCodeSettings;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Format request; value of command field is &quot;format&quot;.  Return</span>
             <span class="s0">* response giving zero or more edit instructions.  The edit</span>
             <span class="s0">* instructions will be sorted in file order.  Applying the edit</span>
             <span class="s0">* instructions in reverse to file will result in correctly</span>
             <span class="s0">* reformatted text.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">FormatRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">command: CommandTypes.Format;</span>
                <span class="s1">arguments: FormatRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Object found in response messages defining an editing</span>
             <span class="s0">* instruction for a span of text in source code.  The effect of</span>
             <span class="s0">* this instruction is to replace the text starting at start and</span>
             <span class="s0">* ending one character before end with newText. For an insertion,</span>
             <span class="s0">* the text span is empty.  For a deletion, newText is empty.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">CodeEdit {</span>
                <span class="s0">/**</span>
                 <span class="s0">* First character of the text span to edit.</span>
                 <span class="s0">*/</span>
                <span class="s1">start: Location;</span>
                <span class="s0">/**</span>
                 <span class="s0">* One character past last character of the text span to edit.</span>
                 <span class="s0">*/</span>
                <span class="s1">end: Location;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Replace the span defined above with this string (may be</span>
                 <span class="s0">* the empty string).</span>
                 <span class="s0">*/</span>
                <span class="s1">newText: string;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">FileCodeEdits {</span>
                <span class="s1">fileName: string;</span>
                <span class="s1">textChanges: CodeEdit[];</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">CodeFixResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s0">/** The code actions that are available */</span>
                <span class="s1">body?: CodeFixAction[];</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">CodeAction {</span>
                <span class="s0">/** Description of the code action to display in the UI of the editor */</span>
                <span class="s1">description: string;</span>
                <span class="s0">/** Text changes to apply to each file as part of the code action */</span>
                <span class="s1">changes: FileCodeEdits[];</span>
                <span class="s0">/** A command is an opaque object that should be passed to `ApplyCodeActionCommandRequestArgs` without modification.  */</span>
                <span class="s1">commands?: {}[];</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">CombinedCodeActions {</span>
                <span class="s1">changes: readonly FileCodeEdits[];</span>
                <span class="s1">commands?: readonly {}[];</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">CodeFixAction </span><span class="s2">extends </span><span class="s1">CodeAction {</span>
                <span class="s0">/** Short name to identify the fix, for use by telemetry. */</span>
                <span class="s1">fixName: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* If present, one may call 'getCombinedCodeFix' with this fixId.</span>
                 <span class="s0">* This may be omitted to indicate that the code fix can't be applied in a group.</span>
                 <span class="s0">*/</span>
                <span class="s1">fixId?: {};</span>
                <span class="s0">/** Should be present if and only if 'fixId' is. */</span>
                <span class="s1">fixAllDescription?: string;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Format and format on key response message.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">FormatResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: CodeEdit[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Arguments for format on key messages.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">FormatOnKeyRequestArgs </span><span class="s2">extends </span><span class="s1">FileLocationRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Key pressed (';', '\n', or '}').</span>
                 <span class="s0">*/</span>
                <span class="s1">key: string;</span>
                <span class="s1">options?: FormatCodeSettings;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Format on key request; value of command field is</span>
             <span class="s0">* &quot;formatonkey&quot;. Given file location and key typed (as string),</span>
             <span class="s0">* return response giving zero or more edit instructions.  The</span>
             <span class="s0">* edit instructions will be sorted in file order.  Applying the</span>
             <span class="s0">* edit instructions in reverse to file will result in correctly</span>
             <span class="s0">* reformatted text.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">FormatOnKeyRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">command: CommandTypes.Formatonkey;</span>
                <span class="s1">arguments: FormatOnKeyRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Arguments for completions messages.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">CompletionsRequestArgs </span><span class="s2">extends </span><span class="s1">FileLocationRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Optional prefix to apply to possible completions.</span>
                 <span class="s0">*/</span>
                <span class="s1">prefix?: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Character that was responsible for triggering completion.</span>
                 <span class="s0">* Should be `undefined` if a user manually requested completion.</span>
                 <span class="s0">*/</span>
                <span class="s1">triggerCharacter?: CompletionsTriggerCharacter;</span>
                <span class="s1">triggerKind?: CompletionTriggerKind;</span>
                <span class="s0">/**</span>
                 <span class="s0">* </span><span class="s4">@deprecated </span><span class="s0">Use UserPreferences.includeCompletionsForModuleExports</span>
                 <span class="s0">*/</span>
                <span class="s1">includeExternalModuleExports?: boolean;</span>
                <span class="s0">/**</span>
                 <span class="s0">* </span><span class="s4">@deprecated </span><span class="s0">Use UserPreferences.includeCompletionsWithInsertText</span>
                 <span class="s0">*/</span>
                <span class="s1">includeInsertTextCompletions?: boolean;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Completions request; value of command field is &quot;completions&quot;.</span>
             <span class="s0">* Given a file location (file, line, col) and a prefix (which may</span>
             <span class="s0">* be the empty string), return the possible completions that</span>
             <span class="s0">* begin with prefix.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">CompletionsRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">command: CommandTypes.Completions | CommandTypes.CompletionInfo;</span>
                <span class="s1">arguments: CompletionsRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Arguments for completion details request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">CompletionDetailsRequestArgs </span><span class="s2">extends </span><span class="s1">FileLocationRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Names of one or more entries for which to obtain details.</span>
                 <span class="s0">*/</span>
                <span class="s1">entryNames: (string | CompletionEntryIdentifier)[];</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">CompletionEntryIdentifier {</span>
                <span class="s1">name: string;</span>
                <span class="s1">source?: string;</span>
                <span class="s1">data?: unknown;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Completion entry details request; value of command field is</span>
             <span class="s0">* &quot;completionEntryDetails&quot;.  Given a file location (file, line,</span>
             <span class="s0">* col) and an array of completion entry names return more</span>
             <span class="s0">* detailed information for each completion entry.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">CompletionDetailsRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">command: CommandTypes.CompletionDetails;</span>
                <span class="s1">arguments: CompletionDetailsRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/** A part of a symbol description that links from a jsdoc @link tag to a declaration */</span>
            <span class="s2">export interface </span><span class="s1">JSDocLinkDisplayPart </span><span class="s2">extends </span><span class="s1">SymbolDisplayPart {</span>
                <span class="s0">/** The location of the declaration that the @link tag links to. */</span>
                <span class="s1">target: FileSpan;</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type CompletionEntry = ChangePropertyTypes&lt;Omit&lt;ts.CompletionEntry, </span><span class="s3">&quot;symbol&quot;</span><span class="s1">&gt;, {</span>
                <span class="s1">replacementSpan: TextSpan;</span>
                <span class="s1">data: unknown;</span>
            <span class="s1">}&gt;;</span>
            <span class="s0">/**</span>
             <span class="s0">* Additional completion entry details, available on demand</span>
             <span class="s0">*/</span>
            <span class="s2">export </span><span class="s1">type CompletionEntryDetails = ChangePropertyTypes&lt;ts.CompletionEntryDetails, {</span>
                <span class="s1">tags: JSDocTagInfo[];</span>
                <span class="s1">codeActions: CodeAction[];</span>
            <span class="s1">}&gt;;</span>
            <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">Prefer CompletionInfoResponse, which supports several top-level fields in addition to the array of entries. */</span>
            <span class="s2">export interface </span><span class="s1">CompletionsResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: CompletionEntry[];</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">CompletionInfoResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: CompletionInfo;</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type CompletionInfo = ChangePropertyTypes&lt;ts.CompletionInfo, {</span>
                <span class="s1">entries: readonly CompletionEntry[];</span>
                <span class="s1">optionalReplacementSpan: TextSpan;</span>
            <span class="s1">}&gt;;</span>
            <span class="s2">export interface </span><span class="s1">CompletionDetailsResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: CompletionEntryDetails[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Represents a single signature to show in signature help.</span>
             <span class="s0">*/</span>
            <span class="s2">export </span><span class="s1">type SignatureHelpItem = ChangePropertyTypes&lt;ts.SignatureHelpItem, {</span>
                <span class="s1">tags: JSDocTagInfo[];</span>
            <span class="s1">}&gt;;</span>
            <span class="s0">/**</span>
             <span class="s0">* Signature help items found in the response of a signature help request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">SignatureHelpItems {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The signature help items.</span>
                 <span class="s0">*/</span>
                <span class="s1">items: SignatureHelpItem[];</span>
                <span class="s0">/**</span>
                 <span class="s0">* The span for which signature help should appear on a signature</span>
                 <span class="s0">*/</span>
                <span class="s1">applicableSpan: TextSpan;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The item selected in the set of available help items.</span>
                 <span class="s0">*/</span>
                <span class="s1">selectedItemIndex: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The argument selected in the set of parameters.</span>
                 <span class="s0">*/</span>
                <span class="s1">argumentIndex: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The argument count</span>
                 <span class="s0">*/</span>
                <span class="s1">argumentCount: number;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Arguments of a signature help request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">SignatureHelpRequestArgs </span><span class="s2">extends </span><span class="s1">FileLocationRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Reason why signature help was invoked.</span>
                 <span class="s0">* See each individual possible</span>
                 <span class="s0">*/</span>
                <span class="s1">triggerReason?: SignatureHelpTriggerReason;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Signature help request; value of command field is &quot;signatureHelp&quot;.</span>
             <span class="s0">* Given a file location (file, line, col), return the signature</span>
             <span class="s0">* help.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">SignatureHelpRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">command: CommandTypes.SignatureHelp;</span>
                <span class="s1">arguments: SignatureHelpRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Response object for a SignatureHelpRequest.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">SignatureHelpResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: SignatureHelpItems;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">InlayHintsRequestArgs </span><span class="s2">extends </span><span class="s1">FileRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Start position of the span.</span>
                 <span class="s0">*/</span>
                <span class="s1">start: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Length of the span.</span>
                 <span class="s0">*/</span>
                <span class="s1">length: number;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">InlayHintsRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.ProvideInlayHints;</span>
                <span class="s1">arguments: InlayHintsRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type InlayHintItem = ChangePropertyTypes&lt;ts.InlayHint, {</span>
                <span class="s1">position: Location;</span>
                <span class="s1">displayParts: InlayHintItemDisplayPart[];</span>
            <span class="s1">}&gt;;</span>
            <span class="s2">export interface </span><span class="s1">InlayHintItemDisplayPart {</span>
                <span class="s1">text: string;</span>
                <span class="s1">span?: FileSpan;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">InlayHintsResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: InlayHintItem[];</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">MapCodeRequestArgs </span><span class="s2">extends </span><span class="s1">FileRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The files and changes to try and apply/map.</span>
                 <span class="s0">*/</span>
                <span class="s1">mapping: MapCodeRequestDocumentMapping;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">MapCodeRequestDocumentMapping {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The specific code to map/insert/replace in the file.</span>
                 <span class="s0">*/</span>
                <span class="s1">contents: string[];</span>
                <span class="s0">/**</span>
                 <span class="s0">* Areas of &quot;focus&quot; to inform the code mapper with. For example, cursor</span>
                 <span class="s0">* location, current selection, viewport, etc. Nested arrays denote</span>
                 <span class="s0">* priority: toplevel arrays are more important than inner arrays, and</span>
                 <span class="s0">* inner array priorities are based on items within that array. Items</span>
                 <span class="s0">* earlier in the arrays have higher priority.</span>
                 <span class="s0">*/</span>
                <span class="s1">focusLocations?: TextSpan[][];</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">MapCodeRequest </span><span class="s2">extends </span><span class="s1">FileRequest {</span>
                <span class="s1">command: CommandTypes.MapCode;</span>
                <span class="s1">arguments: MapCodeRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">MapCodeResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body: readonly FileCodeEdits[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Synchronous request for semantic diagnostics of one file.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">SemanticDiagnosticsSyncRequest </span><span class="s2">extends </span><span class="s1">FileRequest {</span>
                <span class="s1">command: CommandTypes.SemanticDiagnosticsSync;</span>
                <span class="s1">arguments: SemanticDiagnosticsSyncRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">SemanticDiagnosticsSyncRequestArgs </span><span class="s2">extends </span><span class="s1">FileRequestArgs {</span>
                <span class="s1">includeLinePosition?: boolean;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Response object for synchronous sematic diagnostics request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">SemanticDiagnosticsSyncResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: Diagnostic[] | DiagnosticWithLinePosition[];</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">SuggestionDiagnosticsSyncRequest </span><span class="s2">extends </span><span class="s1">FileRequest {</span>
                <span class="s1">command: CommandTypes.SuggestionDiagnosticsSync;</span>
                <span class="s1">arguments: SuggestionDiagnosticsSyncRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type SuggestionDiagnosticsSyncRequestArgs = SemanticDiagnosticsSyncRequestArgs;</span>
            <span class="s2">export </span><span class="s1">type SuggestionDiagnosticsSyncResponse = SemanticDiagnosticsSyncResponse;</span>
            <span class="s0">/**</span>
             <span class="s0">* Synchronous request for syntactic diagnostics of one file.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">SyntacticDiagnosticsSyncRequest </span><span class="s2">extends </span><span class="s1">FileRequest {</span>
                <span class="s1">command: CommandTypes.SyntacticDiagnosticsSync;</span>
                <span class="s1">arguments: SyntacticDiagnosticsSyncRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">SyntacticDiagnosticsSyncRequestArgs </span><span class="s2">extends </span><span class="s1">FileRequestArgs {</span>
                <span class="s1">includeLinePosition?: boolean;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Response object for synchronous syntactic diagnostics request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">SyntacticDiagnosticsSyncResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: Diagnostic[] | DiagnosticWithLinePosition[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Arguments for GeterrForProject request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">GeterrForProjectRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* the file requesting project error list</span>
                 <span class="s0">*/</span>
                <span class="s1">file: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Delay in milliseconds to wait before starting to compute</span>
                 <span class="s0">* errors for the files in the file list</span>
                 <span class="s0">*/</span>
                <span class="s1">delay: number;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* GeterrForProjectRequest request; value of command field is</span>
             <span class="s0">* &quot;geterrForProject&quot;. It works similarly with 'Geterr', only</span>
             <span class="s0">* it request for every file in this project.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">GeterrForProjectRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.GeterrForProject;</span>
                <span class="s1">arguments: GeterrForProjectRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Arguments for geterr messages.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">GeterrRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* List of file names for which to compute compiler errors.</span>
                 <span class="s0">* The files will be checked in list order.</span>
                 <span class="s0">*/</span>
                <span class="s1">files: (string | FileRangesRequestArgs)[];</span>
                <span class="s0">/**</span>
                 <span class="s0">* Delay in milliseconds to wait before starting to compute</span>
                 <span class="s0">* errors for the files in the file list</span>
                 <span class="s0">*/</span>
                <span class="s1">delay: number;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Geterr request; value of command field is &quot;geterr&quot;. Wait for</span>
             <span class="s0">* delay milliseconds and then, if during the wait no change or</span>
             <span class="s0">* reload messages have arrived for the first file in the files</span>
             <span class="s0">* list, get the syntactic errors for the file, field requests,</span>
             <span class="s0">* and then get the semantic errors for the file.  Repeat with a</span>
             <span class="s0">* smaller delay for each subsequent file on the files list.  Best</span>
             <span class="s0">* practice for an editor is to send a file list containing each</span>
             <span class="s0">* file that is currently visible, in most-recently-used order.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">GeterrRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.Geterr;</span>
                <span class="s1">arguments: GeterrRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">FileRange {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The line number for the request (1-based).</span>
                 <span class="s0">*/</span>
                <span class="s1">startLine: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The character offset (on the line) for the request (1-based).</span>
                 <span class="s0">*/</span>
                <span class="s1">startOffset: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The line number for the request (1-based).</span>
                 <span class="s0">*/</span>
                <span class="s1">endLine: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The character offset (on the line) for the request (1-based).</span>
                 <span class="s0">*/</span>
                <span class="s1">endOffset: number;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">FileRangesRequestArgs </span><span class="s2">extends </span><span class="s1">Pick&lt;FileRequestArgs, </span><span class="s3">&quot;file&quot;</span><span class="s1">&gt; {</span>
                <span class="s1">ranges: FileRange[];</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type RequestCompletedEventName = </span><span class="s3">&quot;requestCompleted&quot;</span><span class="s1">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Event that is sent when server have finished processing request with specified id.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">RequestCompletedEvent </span><span class="s2">extends </span><span class="s1">Event {</span>
                <span class="s1">event: RequestCompletedEventName;</span>
                <span class="s1">body: RequestCompletedEventBody;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">RequestCompletedEventBody {</span>
                <span class="s1">request_seq: number;</span>
                <span class="s1">performanceData?: PerformanceData;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Item of diagnostic information found in a DiagnosticEvent message.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">Diagnostic {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Starting file location at which text applies.</span>
                 <span class="s0">*/</span>
                <span class="s1">start: Location;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The last file location at which the text applies.</span>
                 <span class="s0">*/</span>
                <span class="s1">end: Location;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Text of diagnostic message.</span>
                 <span class="s0">*/</span>
                <span class="s1">text: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The category of the diagnostic message, e.g. &quot;error&quot;, &quot;warning&quot;, or &quot;suggestion&quot;.</span>
                 <span class="s0">*/</span>
                <span class="s1">category: string;</span>
                <span class="s1">reportsUnnecessary?: {};</span>
                <span class="s1">reportsDeprecated?: {};</span>
                <span class="s0">/**</span>
                 <span class="s0">* Any related spans the diagnostic may have, such as other locations relevant to an error, such as declarartion sites</span>
                 <span class="s0">*/</span>
                <span class="s1">relatedInformation?: DiagnosticRelatedInformation[];</span>
                <span class="s0">/**</span>
                 <span class="s0">* The error code of the diagnostic message.</span>
                 <span class="s0">*/</span>
                <span class="s1">code?: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The name of the plugin reporting the message.</span>
                 <span class="s0">*/</span>
                <span class="s1">source?: string;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">DiagnosticWithFileName </span><span class="s2">extends </span><span class="s1">Diagnostic {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Name of the file the diagnostic is in</span>
                 <span class="s0">*/</span>
                <span class="s1">fileName: string;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Represents additional spans returned with a diagnostic which are relevant to it</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">DiagnosticRelatedInformation {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The category of the related information message, e.g. &quot;error&quot;, &quot;warning&quot;, or &quot;suggestion&quot;.</span>
                 <span class="s0">*/</span>
                <span class="s1">category: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The code used ot identify the related information</span>
                 <span class="s0">*/</span>
                <span class="s1">code: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Text of related or additional information.</span>
                 <span class="s0">*/</span>
                <span class="s1">message: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Associated location</span>
                 <span class="s0">*/</span>
                <span class="s1">span?: FileSpan;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">DiagnosticEventBody {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The file for which diagnostic information is reported.</span>
                 <span class="s0">*/</span>
                <span class="s1">file: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* An array of diagnostic information items.</span>
                 <span class="s0">*/</span>
                <span class="s1">diagnostics: Diagnostic[];</span>
                <span class="s0">/**</span>
                 <span class="s0">* Spans where the region diagnostic was requested, if this is a region semantic diagnostic event.</span>
                 <span class="s0">*/</span>
                <span class="s1">spans?: TextSpan[];</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type DiagnosticEventKind = </span><span class="s3">&quot;semanticDiag&quot; </span><span class="s1">| </span><span class="s3">&quot;syntaxDiag&quot; </span><span class="s1">| </span><span class="s3">&quot;suggestionDiag&quot; </span><span class="s1">| </span><span class="s3">&quot;regionSemanticDiag&quot;</span><span class="s1">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Event message for DiagnosticEventKind event types.</span>
             <span class="s0">* These events provide syntactic and semantic errors for a file.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">DiagnosticEvent </span><span class="s2">extends </span><span class="s1">Event {</span>
                <span class="s1">body?: DiagnosticEventBody;</span>
                <span class="s1">event: DiagnosticEventKind;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">ConfigFileDiagnosticEventBody {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The file which trigged the searching and error-checking of the config file</span>
                 <span class="s0">*/</span>
                <span class="s1">triggerFile: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The name of the found config file.</span>
                 <span class="s0">*/</span>
                <span class="s1">configFile: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* An arry of diagnostic information items for the found config file.</span>
                 <span class="s0">*/</span>
                <span class="s1">diagnostics: DiagnosticWithFileName[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Event message for &quot;configFileDiag&quot; event type.</span>
             <span class="s0">* This event provides errors for a found config file.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">ConfigFileDiagnosticEvent </span><span class="s2">extends </span><span class="s1">Event {</span>
                <span class="s1">body?: ConfigFileDiagnosticEventBody;</span>
                <span class="s1">event: </span><span class="s3">&quot;configFileDiag&quot;</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type ProjectLanguageServiceStateEventName = </span><span class="s3">&quot;projectLanguageServiceState&quot;</span><span class="s1">;</span>
            <span class="s2">export interface </span><span class="s1">ProjectLanguageServiceStateEvent </span><span class="s2">extends </span><span class="s1">Event {</span>
                <span class="s1">event: ProjectLanguageServiceStateEventName;</span>
                <span class="s1">body?: ProjectLanguageServiceStateEventBody;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">ProjectLanguageServiceStateEventBody {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Project name that has changes in the state of language service.</span>
                 <span class="s0">* For configured projects this will be the config file path.</span>
                 <span class="s0">* For external projects this will be the name of the projects specified when project was open.</span>
                 <span class="s0">* For inferred projects this event is not raised.</span>
                 <span class="s0">*/</span>
                <span class="s1">projectName: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* True if language service state switched from disabled to enabled</span>
                 <span class="s0">* and false otherwise.</span>
                 <span class="s0">*/</span>
                <span class="s1">languageServiceEnabled: boolean;</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type ProjectsUpdatedInBackgroundEventName = </span><span class="s3">&quot;projectsUpdatedInBackground&quot;</span><span class="s1">;</span>
            <span class="s2">export interface </span><span class="s1">ProjectsUpdatedInBackgroundEvent </span><span class="s2">extends </span><span class="s1">Event {</span>
                <span class="s1">event: ProjectsUpdatedInBackgroundEventName;</span>
                <span class="s1">body: ProjectsUpdatedInBackgroundEventBody;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">ProjectsUpdatedInBackgroundEventBody {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Current set of open files</span>
                 <span class="s0">*/</span>
                <span class="s1">openFiles: string[];</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type ProjectLoadingStartEventName = </span><span class="s3">&quot;projectLoadingStart&quot;</span><span class="s1">;</span>
            <span class="s2">export interface </span><span class="s1">ProjectLoadingStartEvent </span><span class="s2">extends </span><span class="s1">Event {</span>
                <span class="s1">event: ProjectLoadingStartEventName;</span>
                <span class="s1">body: ProjectLoadingStartEventBody;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">ProjectLoadingStartEventBody {</span>
                <span class="s0">/** name of the project */</span>
                <span class="s1">projectName: string;</span>
                <span class="s0">/** reason for loading */</span>
                <span class="s1">reason: string;</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type ProjectLoadingFinishEventName = </span><span class="s3">&quot;projectLoadingFinish&quot;</span><span class="s1">;</span>
            <span class="s2">export interface </span><span class="s1">ProjectLoadingFinishEvent </span><span class="s2">extends </span><span class="s1">Event {</span>
                <span class="s1">event: ProjectLoadingFinishEventName;</span>
                <span class="s1">body: ProjectLoadingFinishEventBody;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">ProjectLoadingFinishEventBody {</span>
                <span class="s0">/** name of the project */</span>
                <span class="s1">projectName: string;</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type SurveyReadyEventName = </span><span class="s3">&quot;surveyReady&quot;</span><span class="s1">;</span>
            <span class="s2">export interface </span><span class="s1">SurveyReadyEvent </span><span class="s2">extends </span><span class="s1">Event {</span>
                <span class="s1">event: SurveyReadyEventName;</span>
                <span class="s1">body: SurveyReadyEventBody;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">SurveyReadyEventBody {</span>
                <span class="s0">/** Name of the survey. This is an internal machine- and programmer-friendly name */</span>
                <span class="s1">surveyId: string;</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type LargeFileReferencedEventName = </span><span class="s3">&quot;largeFileReferenced&quot;</span><span class="s1">;</span>
            <span class="s2">export interface </span><span class="s1">LargeFileReferencedEvent </span><span class="s2">extends </span><span class="s1">Event {</span>
                <span class="s1">event: LargeFileReferencedEventName;</span>
                <span class="s1">body: LargeFileReferencedEventBody;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">LargeFileReferencedEventBody {</span>
                <span class="s0">/**</span>
                 <span class="s0">* name of the large file being loaded</span>
                 <span class="s0">*/</span>
                <span class="s1">file: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* size of the file</span>
                 <span class="s0">*/</span>
                <span class="s1">fileSize: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* max file size allowed on the server</span>
                 <span class="s0">*/</span>
                <span class="s1">maxFileSize: number;</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type CreateFileWatcherEventName = </span><span class="s3">&quot;createFileWatcher&quot;</span><span class="s1">;</span>
            <span class="s2">export interface </span><span class="s1">CreateFileWatcherEvent </span><span class="s2">extends </span><span class="s1">Event {</span>
                <span class="s1">readonly event: CreateFileWatcherEventName;</span>
                <span class="s1">readonly body: CreateFileWatcherEventBody;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">CreateFileWatcherEventBody {</span>
                <span class="s1">readonly id: number;</span>
                <span class="s1">readonly path: string;</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type CreateDirectoryWatcherEventName = </span><span class="s3">&quot;createDirectoryWatcher&quot;</span><span class="s1">;</span>
            <span class="s2">export interface </span><span class="s1">CreateDirectoryWatcherEvent </span><span class="s2">extends </span><span class="s1">Event {</span>
                <span class="s1">readonly event: CreateDirectoryWatcherEventName;</span>
                <span class="s1">readonly body: CreateDirectoryWatcherEventBody;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">CreateDirectoryWatcherEventBody {</span>
                <span class="s1">readonly id: number;</span>
                <span class="s1">readonly path: string;</span>
                <span class="s1">readonly recursive: boolean;</span>
                <span class="s1">readonly ignoreUpdate?: boolean;</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type CloseFileWatcherEventName = </span><span class="s3">&quot;closeFileWatcher&quot;</span><span class="s1">;</span>
            <span class="s2">export interface </span><span class="s1">CloseFileWatcherEvent </span><span class="s2">extends </span><span class="s1">Event {</span>
                <span class="s1">readonly event: CloseFileWatcherEventName;</span>
                <span class="s1">readonly body: CloseFileWatcherEventBody;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">CloseFileWatcherEventBody {</span>
                <span class="s1">readonly id: number;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Arguments for reload request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">ReloadRequestArgs </span><span class="s2">extends </span><span class="s1">FileRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Name of temporary file from which to reload file</span>
                 <span class="s0">* contents. May be same as file.</span>
                 <span class="s0">*/</span>
                <span class="s1">tmpfile: string;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Reload request message; value of command field is &quot;reload&quot;.</span>
             <span class="s0">* Reload contents of file with name given by the 'file' argument</span>
             <span class="s0">* from temporary file with name given by the 'tmpfile' argument.</span>
             <span class="s0">* The two names can be identical.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">ReloadRequest </span><span class="s2">extends </span><span class="s1">FileRequest {</span>
                <span class="s1">command: CommandTypes.Reload;</span>
                <span class="s1">arguments: ReloadRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Response to &quot;reload&quot; request. This is just an acknowledgement, so</span>
             <span class="s0">* no body field is required.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">ReloadResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Arguments for saveto request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">SavetoRequestArgs </span><span class="s2">extends </span><span class="s1">FileRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Name of temporary file into which to save server's view of</span>
                 <span class="s0">* file contents.</span>
                 <span class="s0">*/</span>
                <span class="s1">tmpfile: string;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Saveto request message; value of command field is &quot;saveto&quot;.</span>
             <span class="s0">* For debugging purposes, save to a temporaryfile (named by</span>
             <span class="s0">* argument 'tmpfile') the contents of file named by argument</span>
             <span class="s0">* 'file'.  The server does not currently send a response to a</span>
             <span class="s0">* &quot;saveto&quot; request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">SavetoRequest </span><span class="s2">extends </span><span class="s1">FileRequest {</span>
                <span class="s1">command: CommandTypes.Saveto;</span>
                <span class="s1">arguments: SavetoRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Arguments for navto request message.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">NavtoRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Search term to navigate to from current location; term can</span>
                 <span class="s0">* be '.*' or an identifier prefix.</span>
                 <span class="s0">*/</span>
                <span class="s1">searchValue: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">*  Optional limit on the number of items to return.</span>
                 <span class="s0">*/</span>
                <span class="s1">maxResultCount?: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The file for the request (absolute pathname required).</span>
                 <span class="s0">*/</span>
                <span class="s1">file?: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Optional flag to indicate we want results for just the current file</span>
                 <span class="s0">* or the entire project.</span>
                 <span class="s0">*/</span>
                <span class="s1">currentFileOnly?: boolean;</span>
                <span class="s1">projectFileName?: string;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Navto request message; value of command field is &quot;navto&quot;.</span>
             <span class="s0">* Return list of objects giving file locations and symbols that</span>
             <span class="s0">* match the search term given in argument 'searchTerm'.  The</span>
             <span class="s0">* context for the search is given by the named file.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">NavtoRequest </span><span class="s2">extends </span><span class="s1">Request {</span>
                <span class="s1">command: CommandTypes.Navto;</span>
                <span class="s1">arguments: NavtoRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* An item found in a navto response.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">NavtoItem </span><span class="s2">extends </span><span class="s1">FileSpan {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The symbol's name.</span>
                 <span class="s0">*/</span>
                <span class="s1">name: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The symbol's kind (such as 'className' or 'parameterName').</span>
                 <span class="s0">*/</span>
                <span class="s1">kind: ScriptElementKind;</span>
                <span class="s0">/**</span>
                 <span class="s0">* exact, substring, or prefix.</span>
                 <span class="s0">*/</span>
                <span class="s1">matchKind: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* If this was a case sensitive or insensitive match.</span>
                 <span class="s0">*/</span>
                <span class="s1">isCaseSensitive: boolean;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Optional modifiers for the kind (such as 'public').</span>
                 <span class="s0">*/</span>
                <span class="s1">kindModifiers?: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Name of symbol's container symbol (if any); for example,</span>
                 <span class="s0">* the class name if symbol is a class member.</span>
                 <span class="s0">*/</span>
                <span class="s1">containerName?: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Kind of symbol's container symbol (if any).</span>
                 <span class="s0">*/</span>
                <span class="s1">containerKind?: ScriptElementKind;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Navto response message. Body is an array of navto items.  Each</span>
             <span class="s0">* item gives a symbol that matched the search term.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">NavtoResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: NavtoItem[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Arguments for change request message.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">ChangeRequestArgs </span><span class="s2">extends </span><span class="s1">FormatRequestArgs {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Optional string to insert at location (file, line, offset).</span>
                 <span class="s0">*/</span>
                <span class="s1">insertString?: string;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Change request message; value of command field is &quot;change&quot;.</span>
             <span class="s0">* Update the server's view of the file named by argument 'file'.</span>
             <span class="s0">* Server does not currently send a response to a change request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">ChangeRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">command: CommandTypes.Change;</span>
                <span class="s1">arguments: ChangeRequestArgs;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Response to &quot;brace&quot; request.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">BraceResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: TextSpan[];</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Brace matching request; value of command field is &quot;brace&quot;.</span>
             <span class="s0">* Return response giving the file locations of matching braces</span>
             <span class="s0">* found in file at location line, offset.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">BraceRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">command: CommandTypes.Brace;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* NavBar items request; value of command field is &quot;navbar&quot;.</span>
             <span class="s0">* Return response giving the list of navigation bar entries</span>
             <span class="s0">* extracted from the requested file.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">NavBarRequest </span><span class="s2">extends </span><span class="s1">FileRequest {</span>
                <span class="s1">command: CommandTypes.NavBar;</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* NavTree request; value of command field is &quot;navtree&quot;.</span>
             <span class="s0">* Return response giving the navigation tree of the requested file.</span>
             <span class="s0">*/</span>
            <span class="s2">export interface </span><span class="s1">NavTreeRequest </span><span class="s2">extends </span><span class="s1">FileRequest {</span>
                <span class="s1">command: CommandTypes.NavTree;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">NavigationBarItem {</span>
                <span class="s0">/**</span>
                 <span class="s0">* The item's display text.</span>
                 <span class="s0">*/</span>
                <span class="s1">text: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The symbol's kind (such as 'className' or 'parameterName').</span>
                 <span class="s0">*/</span>
                <span class="s1">kind: ScriptElementKind;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Optional modifiers for the kind (such as 'public').</span>
                 <span class="s0">*/</span>
                <span class="s1">kindModifiers?: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The definition locations of the item.</span>
                 <span class="s0">*/</span>
                <span class="s1">spans: TextSpan[];</span>
                <span class="s0">/**</span>
                 <span class="s0">* Optional children.</span>
                 <span class="s0">*/</span>
                <span class="s1">childItems?: NavigationBarItem[];</span>
                <span class="s0">/**</span>
                 <span class="s0">* Number of levels deep this item should appear.</span>
                 <span class="s0">*/</span>
                <span class="s1">indent: number;</span>
            <span class="s1">}</span>
            <span class="s0">/** protocol.NavigationTree is identical to ts.NavigationTree, except using protocol.TextSpan instead of ts.TextSpan */</span>
            <span class="s2">export interface </span><span class="s1">NavigationTree {</span>
                <span class="s1">text: string;</span>
                <span class="s1">kind: ScriptElementKind;</span>
                <span class="s1">kindModifiers: string;</span>
                <span class="s1">spans: TextSpan[];</span>
                <span class="s1">nameSpan: TextSpan | undefined;</span>
                <span class="s1">childItems?: NavigationTree[];</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type TelemetryEventName = </span><span class="s3">&quot;telemetry&quot;</span><span class="s1">;</span>
            <span class="s2">export interface </span><span class="s1">TelemetryEvent </span><span class="s2">extends </span><span class="s1">Event {</span>
                <span class="s1">event: TelemetryEventName;</span>
                <span class="s1">body: TelemetryEventBody;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">TelemetryEventBody {</span>
                <span class="s1">telemetryEventName: string;</span>
                <span class="s1">payload: any;</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type TypesInstallerInitializationFailedEventName = </span><span class="s3">&quot;typesInstallerInitializationFailed&quot;</span><span class="s1">;</span>
            <span class="s2">export interface </span><span class="s1">TypesInstallerInitializationFailedEvent </span><span class="s2">extends </span><span class="s1">Event {</span>
                <span class="s1">event: TypesInstallerInitializationFailedEventName;</span>
                <span class="s1">body: TypesInstallerInitializationFailedEventBody;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">TypesInstallerInitializationFailedEventBody {</span>
                <span class="s1">message: string;</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type TypingsInstalledTelemetryEventName = </span><span class="s3">&quot;typingsInstalled&quot;</span><span class="s1">;</span>
            <span class="s2">export interface </span><span class="s1">TypingsInstalledTelemetryEventBody </span><span class="s2">extends </span><span class="s1">TelemetryEventBody {</span>
                <span class="s1">telemetryEventName: TypingsInstalledTelemetryEventName;</span>
                <span class="s1">payload: TypingsInstalledTelemetryEventPayload;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">TypingsInstalledTelemetryEventPayload {</span>
                <span class="s0">/**</span>
                 <span class="s0">* Comma separated list of installed typing packages</span>
                 <span class="s0">*/</span>
                <span class="s1">installedPackages: string;</span>
                <span class="s0">/**</span>
                 <span class="s0">* true if install request succeeded, otherwise - false</span>
                 <span class="s0">*/</span>
                <span class="s1">installSuccess: boolean;</span>
                <span class="s0">/**</span>
                 <span class="s0">* version of typings installer</span>
                 <span class="s0">*/</span>
                <span class="s1">typingsInstallerVersion: string;</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type BeginInstallTypesEventName = </span><span class="s3">&quot;beginInstallTypes&quot;</span><span class="s1">;</span>
            <span class="s2">export </span><span class="s1">type EndInstallTypesEventName = </span><span class="s3">&quot;endInstallTypes&quot;</span><span class="s1">;</span>
            <span class="s2">export interface </span><span class="s1">BeginInstallTypesEvent </span><span class="s2">extends </span><span class="s1">Event {</span>
                <span class="s1">event: BeginInstallTypesEventName;</span>
                <span class="s1">body: BeginInstallTypesEventBody;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">EndInstallTypesEvent </span><span class="s2">extends </span><span class="s1">Event {</span>
                <span class="s1">event: EndInstallTypesEventName;</span>
                <span class="s1">body: EndInstallTypesEventBody;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">InstallTypesEventBody {</span>
                <span class="s0">/**</span>
                 <span class="s0">* correlation id to match begin and end events</span>
                 <span class="s0">*/</span>
                <span class="s1">eventId: number;</span>
                <span class="s0">/**</span>
                 <span class="s0">* list of packages to install</span>
                 <span class="s0">*/</span>
                <span class="s1">packages: readonly string[];</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">BeginInstallTypesEventBody </span><span class="s2">extends </span><span class="s1">InstallTypesEventBody {</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">EndInstallTypesEventBody </span><span class="s2">extends </span><span class="s1">InstallTypesEventBody {</span>
                <span class="s0">/**</span>
                 <span class="s0">* true if installation succeeded, otherwise false</span>
                 <span class="s0">*/</span>
                <span class="s1">success: boolean;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">NavBarResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: NavigationBarItem[];</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">NavTreeResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">body?: NavigationTree;</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type CallHierarchyItem = ChangePropertyTypes&lt;ts.CallHierarchyItem, {</span>
                <span class="s1">span: TextSpan;</span>
                <span class="s1">selectionSpan: TextSpan;</span>
            <span class="s1">}&gt;;</span>
            <span class="s2">export interface </span><span class="s1">CallHierarchyIncomingCall {</span>
                <span class="s1">from: CallHierarchyItem;</span>
                <span class="s1">fromSpans: TextSpan[];</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">CallHierarchyOutgoingCall {</span>
                <span class="s1">to: CallHierarchyItem;</span>
                <span class="s1">fromSpans: TextSpan[];</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">PrepareCallHierarchyRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">command: CommandTypes.PrepareCallHierarchy;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">PrepareCallHierarchyResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">readonly body: CallHierarchyItem | CallHierarchyItem[];</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">ProvideCallHierarchyIncomingCallsRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">command: CommandTypes.ProvideCallHierarchyIncomingCalls;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">ProvideCallHierarchyIncomingCallsResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">readonly body: CallHierarchyIncomingCall[];</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">ProvideCallHierarchyOutgoingCallsRequest </span><span class="s2">extends </span><span class="s1">FileLocationRequest {</span>
                <span class="s1">command: CommandTypes.ProvideCallHierarchyOutgoingCalls;</span>
            <span class="s1">}</span>
            <span class="s2">export interface </span><span class="s1">ProvideCallHierarchyOutgoingCallsResponse </span><span class="s2">extends </span><span class="s1">Response {</span>
                <span class="s1">readonly body: CallHierarchyOutgoingCall[];</span>
            <span class="s1">}</span>
            <span class="s2">export enum </span><span class="s1">IndentStyle {</span>
                <span class="s1">None = </span><span class="s3">&quot;None&quot;</span><span class="s1">,</span>
                <span class="s1">Block = </span><span class="s3">&quot;Block&quot;</span><span class="s1">,</span>
                <span class="s1">Smart = </span><span class="s3">&quot;Smart&quot;</span><span class="s1">,</span>
            <span class="s1">}</span>
            <span class="s2">export </span><span class="s1">type EditorSettings = ChangePropertyTypes&lt;ts.EditorSettings, {</span>
                <span class="s1">indentStyle: IndentStyle | ts.IndentStyle;</span>
            <span class="s1">}&gt;;</span>
            <span class="s2">export </span><span class="s1">type FormatCodeSettings = ChangePropertyTypes&lt;ts.FormatCodeSettings, {</span>
                <span class="s1">indentStyle: IndentStyle | ts.IndentStyle;</span>
            <span class="s1">}&gt;;</span>
            <span class="s2">export </span><span class="s1">type CompilerOptions = ChangePropertyTypes&lt;ChangeStringIndexSignature&lt;ts.CompilerOptions, CompilerOptionsValue&gt;, {</span>
                <span class="s1">jsx: JsxEmit | ts.JsxEmit;</span>
                <span class="s1">module: ModuleKind | ts.ModuleKind;</span>
                <span class="s1">moduleResolution: ModuleResolutionKind | ts.ModuleResolutionKind;</span>
                <span class="s1">newLine: NewLineKind | ts.NewLineKind;</span>
                <span class="s1">target: ScriptTarget | ts.ScriptTarget;</span>
            <span class="s1">}&gt;;</span>
            <span class="s2">export enum </span><span class="s1">JsxEmit {</span>
                <span class="s1">None = </span><span class="s3">&quot;none&quot;</span><span class="s1">,</span>
                <span class="s1">Preserve = </span><span class="s3">&quot;preserve&quot;</span><span class="s1">,</span>
                <span class="s1">ReactNative = </span><span class="s3">&quot;react-native&quot;</span><span class="s1">,</span>
                <span class="s1">React = </span><span class="s3">&quot;react&quot;</span><span class="s1">,</span>
                <span class="s1">ReactJSX = </span><span class="s3">&quot;react-jsx&quot;</span><span class="s1">,</span>
                <span class="s1">ReactJSXDev = </span><span class="s3">&quot;react-jsxdev&quot;</span><span class="s1">,</span>
            <span class="s1">}</span>
            <span class="s2">export enum </span><span class="s1">ModuleKind {</span>
                <span class="s1">None = </span><span class="s3">&quot;none&quot;</span><span class="s1">,</span>
                <span class="s1">CommonJS = </span><span class="s3">&quot;commonjs&quot;</span><span class="s1">,</span>
                <span class="s1">AMD = </span><span class="s3">&quot;amd&quot;</span><span class="s1">,</span>
                <span class="s1">UMD = </span><span class="s3">&quot;umd&quot;</span><span class="s1">,</span>
                <span class="s1">System = </span><span class="s3">&quot;system&quot;</span><span class="s1">,</span>
                <span class="s1">ES6 = </span><span class="s3">&quot;es6&quot;</span><span class="s1">,</span>
                <span class="s1">ES2015 = </span><span class="s3">&quot;es2015&quot;</span><span class="s1">,</span>
                <span class="s1">ES2020 = </span><span class="s3">&quot;es2020&quot;</span><span class="s1">,</span>
                <span class="s1">ES2022 = </span><span class="s3">&quot;es2022&quot;</span><span class="s1">,</span>
                <span class="s1">ESNext = </span><span class="s3">&quot;esnext&quot;</span><span class="s1">,</span>
                <span class="s1">Node16 = </span><span class="s3">&quot;node16&quot;</span><span class="s1">,</span>
                <span class="s1">Node18 = </span><span class="s3">&quot;node18&quot;</span><span class="s1">,</span>
                <span class="s1">Node20 = </span><span class="s3">&quot;node20&quot;</span><span class="s1">,</span>
                <span class="s1">NodeNext = </span><span class="s3">&quot;nodenext&quot;</span><span class="s1">,</span>
                <span class="s1">Preserve = </span><span class="s3">&quot;preserve&quot;</span><span class="s1">,</span>
            <span class="s1">}</span>
            <span class="s2">export enum </span><span class="s1">ModuleResolutionKind {</span>
                <span class="s1">Classic = </span><span class="s3">&quot;classic&quot;</span><span class="s1">,</span>
                <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">Renamed to `Node10` */</span>
                <span class="s1">Node = </span><span class="s3">&quot;node&quot;</span><span class="s1">,</span>
                <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">Renamed to `Node10` */</span>
                <span class="s1">NodeJs = </span><span class="s3">&quot;node&quot;</span><span class="s1">,</span>
                <span class="s1">Node10 = </span><span class="s3">&quot;node10&quot;</span><span class="s1">,</span>
                <span class="s1">Node16 = </span><span class="s3">&quot;node16&quot;</span><span class="s1">,</span>
                <span class="s1">NodeNext = </span><span class="s3">&quot;nodenext&quot;</span><span class="s1">,</span>
                <span class="s1">Bundler = </span><span class="s3">&quot;bundler&quot;</span><span class="s1">,</span>
            <span class="s1">}</span>
            <span class="s2">export enum </span><span class="s1">NewLineKind {</span>
                <span class="s1">Crlf = </span><span class="s3">&quot;Crlf&quot;</span><span class="s1">,</span>
                <span class="s1">Lf = </span><span class="s3">&quot;Lf&quot;</span><span class="s1">,</span>
            <span class="s1">}</span>
            <span class="s2">export enum </span><span class="s1">ScriptTarget {</span>
                <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/</span>
                <span class="s1">ES3 = </span><span class="s3">&quot;es3&quot;</span><span class="s1">,</span>
                <span class="s1">ES5 = </span><span class="s3">&quot;es5&quot;</span><span class="s1">,</span>
                <span class="s1">ES6 = </span><span class="s3">&quot;es6&quot;</span><span class="s1">,</span>
                <span class="s1">ES2015 = </span><span class="s3">&quot;es2015&quot;</span><span class="s1">,</span>
                <span class="s1">ES2016 = </span><span class="s3">&quot;es2016&quot;</span><span class="s1">,</span>
                <span class="s1">ES2017 = </span><span class="s3">&quot;es2017&quot;</span><span class="s1">,</span>
                <span class="s1">ES2018 = </span><span class="s3">&quot;es2018&quot;</span><span class="s1">,</span>
                <span class="s1">ES2019 = </span><span class="s3">&quot;es2019&quot;</span><span class="s1">,</span>
                <span class="s1">ES2020 = </span><span class="s3">&quot;es2020&quot;</span><span class="s1">,</span>
                <span class="s1">ES2021 = </span><span class="s3">&quot;es2021&quot;</span><span class="s1">,</span>
                <span class="s1">ES2022 = </span><span class="s3">&quot;es2022&quot;</span><span class="s1">,</span>
                <span class="s1">ES2023 = </span><span class="s3">&quot;es2023&quot;</span><span class="s1">,</span>
                <span class="s1">ES2024 = </span><span class="s3">&quot;es2024&quot;</span><span class="s1">,</span>
                <span class="s1">ESNext = </span><span class="s3">&quot;esnext&quot;</span><span class="s1">,</span>
                <span class="s1">JSON = </span><span class="s3">&quot;json&quot;</span><span class="s1">,</span>
                <span class="s1">Latest = </span><span class="s3">&quot;esnext&quot;</span><span class="s1">,</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">namespace typingsInstaller {</span>
            <span class="s2">interface </span><span class="s1">Log {</span>
                <span class="s1">isEnabled(): boolean;</span>
                <span class="s1">writeLine(text: string): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">type RequestCompletedAction = (success: boolean) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s2">interface </span><span class="s1">PendingRequest {</span>
                <span class="s1">requestId: number;</span>
                <span class="s1">packageNames: string[];</span>
                <span class="s1">cwd: string;</span>
                <span class="s1">onRequestCompleted: RequestCompletedAction;</span>
            <span class="s1">}</span>
            <span class="s1">abstract </span><span class="s2">class </span><span class="s1">TypingsInstaller {</span>
                <span class="s2">protected </span><span class="s1">readonly installTypingHost: InstallTypingHost;</span>
                <span class="s2">private </span><span class="s1">readonly globalCachePath;</span>
                <span class="s2">private </span><span class="s1">readonly safeListPath;</span>
                <span class="s2">private </span><span class="s1">readonly typesMapLocation;</span>
                <span class="s2">private </span><span class="s1">readonly throttleLimit;</span>
                <span class="s2">protected </span><span class="s1">readonly log: Log;</span>
                <span class="s2">private </span><span class="s1">readonly packageNameToTypingLocation;</span>
                <span class="s2">private </span><span class="s1">readonly missingTypingsSet;</span>
                <span class="s2">private </span><span class="s1">readonly knownCachesSet;</span>
                <span class="s2">private </span><span class="s1">readonly projectWatchers;</span>
                <span class="s2">private </span><span class="s1">safeList;</span>
                <span class="s2">private </span><span class="s1">pendingRunRequests;</span>
                <span class="s2">private </span><span class="s1">installRunCount;</span>
                <span class="s2">private </span><span class="s1">inFlightRequestCount;</span>
                <span class="s1">abstract readonly typesRegistry: Map&lt;string, MapLike&lt;string&gt;&gt;;</span>
                <span class="s1">constructor(installTypingHost: InstallTypingHost, globalCachePath: string, safeListPath: Path, typesMapLocation: Path, throttleLimit: number, log?: Log);</span>
                <span class="s1">closeProject(req: CloseProject): </span><span class="s2">void</span><span class="s1">;</span>
                <span class="s2">private </span><span class="s1">closeWatchers;</span>
                <span class="s1">install(req: DiscoverTypings): </span><span class="s2">void</span><span class="s1">;</span>
                <span class="s2">private </span><span class="s1">initializeSafeList;</span>
                <span class="s2">private </span><span class="s1">processCacheLocation;</span>
                <span class="s2">private </span><span class="s1">filterTypings;</span>
                <span class="s2">protected </span><span class="s1">ensurePackageDirectoryExists(directory: string): </span><span class="s2">void</span><span class="s1">;</span>
                <span class="s2">private </span><span class="s1">installTypings;</span>
                <span class="s2">private </span><span class="s1">ensureDirectoryExists;</span>
                <span class="s2">private </span><span class="s1">watchFiles;</span>
                <span class="s2">private </span><span class="s1">createSetTypings;</span>
                <span class="s2">private </span><span class="s1">installTypingsAsync;</span>
                <span class="s2">private </span><span class="s1">executeWithThrottling;</span>
                <span class="s2">protected </span><span class="s1">abstract installWorker(requestId: number, packageNames: string[], cwd: string, onRequestCompleted: RequestCompletedAction): </span><span class="s2">void</span><span class="s1">;</span>
                <span class="s2">protected </span><span class="s1">abstract sendResponse(response: SetTypings | InvalidateCachedTypings | BeginInstallTypes | EndInstallTypes | WatchTypingLocations): </span><span class="s2">void</span><span class="s1">;</span>
                <span class="s2">protected </span><span class="s1">readonly latestDistTag = </span><span class="s3">&quot;latest&quot;</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">type ActionSet = </span><span class="s3">&quot;action::set&quot;</span><span class="s1">;</span>
        <span class="s1">type ActionInvalidate = </span><span class="s3">&quot;action::invalidate&quot;</span><span class="s1">;</span>
        <span class="s1">type ActionPackageInstalled = </span><span class="s3">&quot;action::packageInstalled&quot;</span><span class="s1">;</span>
        <span class="s1">type EventTypesRegistry = </span><span class="s3">&quot;event::typesRegistry&quot;</span><span class="s1">;</span>
        <span class="s1">type EventBeginInstallTypes = </span><span class="s3">&quot;event::beginInstallTypes&quot;</span><span class="s1">;</span>
        <span class="s1">type EventEndInstallTypes = </span><span class="s3">&quot;event::endInstallTypes&quot;</span><span class="s1">;</span>
        <span class="s1">type EventInitializationFailed = </span><span class="s3">&quot;event::initializationFailed&quot;</span><span class="s1">;</span>
        <span class="s1">type ActionWatchTypingLocations = </span><span class="s3">&quot;action::watchTypingLocations&quot;</span><span class="s1">;</span>
        <span class="s2">interface </span><span class="s1">TypingInstallerResponse {</span>
            <span class="s1">readonly kind: ActionSet | ActionInvalidate | EventTypesRegistry | ActionPackageInstalled | EventBeginInstallTypes | EventEndInstallTypes | EventInitializationFailed | ActionWatchTypingLocations;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">TypingInstallerRequestWithProjectName {</span>
            <span class="s1">readonly projectName: string;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">DiscoverTypings </span><span class="s2">extends </span><span class="s1">TypingInstallerRequestWithProjectName {</span>
            <span class="s1">readonly fileNames: string[];</span>
            <span class="s1">readonly projectRootPath: Path;</span>
            <span class="s1">readonly compilerOptions: CompilerOptions;</span>
            <span class="s1">readonly typeAcquisition: TypeAcquisition;</span>
            <span class="s1">readonly unresolvedImports: SortedReadonlyArray&lt;string&gt;;</span>
            <span class="s1">readonly cachePath?: string;</span>
            <span class="s1">readonly kind: </span><span class="s3">&quot;discover&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">CloseProject </span><span class="s2">extends </span><span class="s1">TypingInstallerRequestWithProjectName {</span>
            <span class="s1">readonly kind: </span><span class="s3">&quot;closeProject&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">TypesRegistryRequest {</span>
            <span class="s1">readonly kind: </span><span class="s3">&quot;typesRegistry&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">InstallPackageRequest </span><span class="s2">extends </span><span class="s1">TypingInstallerRequestWithProjectName {</span>
            <span class="s1">readonly kind: </span><span class="s3">&quot;installPackage&quot;</span><span class="s1">;</span>
            <span class="s1">readonly fileName: Path;</span>
            <span class="s1">readonly packageName: string;</span>
            <span class="s1">readonly projectRootPath: Path;</span>
            <span class="s1">readonly id: number;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">PackageInstalledResponse </span><span class="s2">extends </span><span class="s1">ProjectResponse {</span>
            <span class="s1">readonly kind: ActionPackageInstalled;</span>
            <span class="s1">readonly id: number;</span>
            <span class="s1">readonly success: boolean;</span>
            <span class="s1">readonly message: string;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">InitializationFailedResponse </span><span class="s2">extends </span><span class="s1">TypingInstallerResponse {</span>
            <span class="s1">readonly kind: EventInitializationFailed;</span>
            <span class="s1">readonly message: string;</span>
            <span class="s1">readonly stack?: string;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">ProjectResponse </span><span class="s2">extends </span><span class="s1">TypingInstallerResponse {</span>
            <span class="s1">readonly projectName: string;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">InvalidateCachedTypings </span><span class="s2">extends </span><span class="s1">ProjectResponse {</span>
            <span class="s1">readonly kind: ActionInvalidate;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">InstallTypes </span><span class="s2">extends </span><span class="s1">ProjectResponse {</span>
            <span class="s1">readonly kind: EventBeginInstallTypes | EventEndInstallTypes;</span>
            <span class="s1">readonly eventId: number;</span>
            <span class="s1">readonly typingsInstallerVersion: string;</span>
            <span class="s1">readonly packagesToInstall: readonly string[];</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">BeginInstallTypes </span><span class="s2">extends </span><span class="s1">InstallTypes {</span>
            <span class="s1">readonly kind: EventBeginInstallTypes;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">EndInstallTypes </span><span class="s2">extends </span><span class="s1">InstallTypes {</span>
            <span class="s1">readonly kind: EventEndInstallTypes;</span>
            <span class="s1">readonly installSuccess: boolean;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">InstallTypingHost </span><span class="s2">extends </span><span class="s1">JsTyping.TypingResolutionHost {</span>
            <span class="s1">useCaseSensitiveFileNames: boolean;</span>
            <span class="s1">writeFile(path: string, content: string): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">createDirectory(path: string): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">getCurrentDirectory?(): string;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">SetTypings </span><span class="s2">extends </span><span class="s1">ProjectResponse {</span>
            <span class="s1">readonly typeAcquisition: TypeAcquisition;</span>
            <span class="s1">readonly compilerOptions: CompilerOptions;</span>
            <span class="s1">readonly typings: string[];</span>
            <span class="s1">readonly unresolvedImports: SortedReadonlyArray&lt;string&gt;;</span>
            <span class="s1">readonly kind: ActionSet;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">WatchTypingLocations </span><span class="s2">extends </span><span class="s1">ProjectResponse {</span>
            <span class="s0">/** if files is undefined, retain same set of watchers */</span>
            <span class="s1">readonly files: readonly string[] | undefined;</span>
            <span class="s1">readonly kind: ActionWatchTypingLocations;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">CompressedData {</span>
            <span class="s1">length: number;</span>
            <span class="s1">compressionKind: string;</span>
            <span class="s1">data: any;</span>
        <span class="s1">}</span>
        <span class="s1">type ModuleImportResult = {</span>
            <span class="s1">module: {};</span>
            <span class="s1">error: undefined;</span>
        <span class="s1">} | {</span>
            <span class="s1">module: undefined;</span>
            <span class="s1">error: {</span>
                <span class="s1">stack?: string;</span>
                <span class="s1">message?: string;</span>
            <span class="s1">};</span>
        <span class="s1">};</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">Use {</span><span class="s4">@link </span><span class="s0">ModuleImportResult} instead. */</span>
        <span class="s1">type RequireResult = ModuleImportResult;</span>
        <span class="s2">interface </span><span class="s1">ServerHost </span><span class="s2">extends </span><span class="s1">System {</span>
            <span class="s1">watchFile(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: WatchOptions): FileWatcher;</span>
            <span class="s1">watchDirectory(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: WatchOptions): FileWatcher;</span>
            <span class="s1">preferNonRecursiveWatch?: boolean;</span>
            <span class="s1">setTimeout(callback: (...args: any[]) =&gt; </span><span class="s2">void</span><span class="s1">, ms: number, ...args: any[]): any;</span>
            <span class="s1">clearTimeout(timeoutId: any): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">setImmediate(callback: (...args: any[]) =&gt; </span><span class="s2">void</span><span class="s1">, ...args: any[]): any;</span>
            <span class="s1">clearImmediate(timeoutId: any): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">gc?(): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">trace?(s: string): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">require?(initialPath: string, moduleName: string): ModuleImportResult;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">InstallPackageOptionsWithProject </span><span class="s2">extends </span><span class="s1">InstallPackageOptions {</span>
            <span class="s1">projectName: string;</span>
            <span class="s1">projectRootPath: Path;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">ITypingsInstaller {</span>
            <span class="s1">isKnownTypesPackageName(name: string): boolean;</span>
            <span class="s1">installPackage(options: InstallPackageOptionsWithProject): Promise&lt;ApplyCodeActionCommandResult&gt;;</span>
            <span class="s1">enqueueInstallTypingsRequest(p: Project, typeAcquisition: TypeAcquisition, unresolvedImports: SortedReadonlyArray&lt;string&gt; | undefined): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">attach(projectService: ProjectService): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">onProjectClosed(p: Project): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">readonly globalTypingsCacheLocation: string | undefined;</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">createInstallTypingsRequest(project: Project, typeAcquisition: TypeAcquisition, unresolvedImports: SortedReadonlyArray&lt;string&gt;, cachePath?: string): DiscoverTypings;</span>
        <span class="s2">function </span><span class="s1">toNormalizedPath(fileName: string): NormalizedPath;</span>
        <span class="s2">function </span><span class="s1">normalizedPathToPath(normalizedPath: NormalizedPath, currentDirectory: string, getCanonicalFileName: (f: string) =&gt; string): Path;</span>
        <span class="s2">function </span><span class="s1">asNormalizedPath(fileName: string): NormalizedPath;</span>
        <span class="s2">function </span><span class="s1">createNormalizedPathMap&lt;T&gt;(): NormalizedPathMap&lt;T&gt;;</span>
        <span class="s2">function </span><span class="s1">isInferredProjectName(name: string): boolean;</span>
        <span class="s2">function </span><span class="s1">makeInferredProjectName(counter: number): string;</span>
        <span class="s2">function </span><span class="s1">createSortedArray&lt;T&gt;(): SortedArray&lt;T&gt;;</span>
        <span class="s2">enum </span><span class="s1">LogLevel {</span>
            <span class="s1">terse = </span><span class="s5">0</span><span class="s1">,</span>
            <span class="s1">normal = </span><span class="s5">1</span><span class="s1">,</span>
            <span class="s1">requestTime = </span><span class="s5">2</span><span class="s1">,</span>
            <span class="s1">verbose = </span><span class="s5">3</span><span class="s1">,</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">emptyArray: SortedReadonlyArray&lt;never&gt;;</span>
        <span class="s2">interface </span><span class="s1">Logger {</span>
            <span class="s1">close(): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">hasLevel(level: LogLevel): boolean;</span>
            <span class="s1">loggingEnabled(): boolean;</span>
            <span class="s1">perftrc(s: string): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">info(s: string): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">startGroup(): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">endGroup(): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">msg(s: string, type?: Msg): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">getLogFileName(): string | undefined;</span>
        <span class="s1">}</span>
        <span class="s2">enum </span><span class="s1">Msg {</span>
            <span class="s1">Err = </span><span class="s3">&quot;Err&quot;</span><span class="s1">,</span>
            <span class="s1">Info = </span><span class="s3">&quot;Info&quot;</span><span class="s1">,</span>
            <span class="s1">Perf = </span><span class="s3">&quot;Perf&quot;</span><span class="s1">,</span>
        <span class="s1">}</span>
        <span class="s1">namespace Errors {</span>
            <span class="s2">function </span><span class="s1">ThrowNoProject(): never;</span>
            <span class="s2">function </span><span class="s1">ThrowProjectLanguageServiceDisabled(): never;</span>
            <span class="s2">function </span><span class="s1">ThrowProjectDoesNotContainDocument(fileName: string, project: Project): never;</span>
        <span class="s1">}</span>
        <span class="s1">type NormalizedPath = string &amp; {</span>
            <span class="s1">__normalizedPathTag: any;</span>
        <span class="s1">};</span>
        <span class="s2">interface </span><span class="s1">NormalizedPathMap&lt;T&gt; {</span>
            <span class="s1">get(path: NormalizedPath): T | undefined;</span>
            <span class="s1">set(path: NormalizedPath, value: T): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">contains(path: NormalizedPath): boolean;</span>
            <span class="s1">remove(path: NormalizedPath): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">isDynamicFileName(fileName: NormalizedPath): boolean;</span>
        <span class="s2">class </span><span class="s1">ScriptInfo {</span>
            <span class="s2">private </span><span class="s1">readonly host;</span>
            <span class="s1">readonly fileName: NormalizedPath;</span>
            <span class="s1">readonly scriptKind: ScriptKind;</span>
            <span class="s1">readonly hasMixedContent: boolean;</span>
            <span class="s1">readonly path: Path;</span>
            <span class="s0">/**</span>
             <span class="s0">* All projects that include this file</span>
             <span class="s0">*/</span>
            <span class="s1">readonly containingProjects: Project[];</span>
            <span class="s2">private </span><span class="s1">formatSettings;</span>
            <span class="s2">private </span><span class="s1">preferences;</span>
            <span class="s2">private </span><span class="s1">realpath;</span>
            <span class="s1">constructor(host: ServerHost, fileName: NormalizedPath, scriptKind: ScriptKind, hasMixedContent: boolean, path: Path, initialVersion?: number);</span>
            <span class="s1">isScriptOpen(): boolean;</span>
            <span class="s1">open(newText: string | undefined): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">close(fileExists?: boolean): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">getSnapshot(): IScriptSnapshot;</span>
            <span class="s2">private </span><span class="s1">ensureRealPath;</span>
            <span class="s1">getFormatCodeSettings(): FormatCodeSettings | undefined;</span>
            <span class="s1">getPreferences(): protocol.UserPreferences | undefined;</span>
            <span class="s1">attachToProject(project: Project): boolean;</span>
            <span class="s1">isAttached(project: Project): boolean;</span>
            <span class="s1">detachFromProject(project: Project): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">detachAllProjects(): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">getDefaultProject(): Project;</span>
            <span class="s1">registerFileUpdate(): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">setOptions(formatSettings: FormatCodeSettings, preferences: protocol.UserPreferences | undefined): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">getLatestVersion(): string;</span>
            <span class="s1">saveTo(fileName: string): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">reloadFromFile(tempFileName?: NormalizedPath): boolean;</span>
            <span class="s1">editContent(start: number, end: number, newText: string): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">markContainingProjectsAsDirty(): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">isOrphan(): boolean;</span>
            <span class="s0">/**</span>
             <span class="s0">*  </span><span class="s4">@param </span><span class="s0">line 1 based index</span>
             <span class="s0">*/</span>
            <span class="s1">lineToTextSpan(line: number): TextSpan;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s4">@param </span><span class="s0">line 1 based index</span>
             <span class="s0">* </span><span class="s4">@param </span><span class="s0">offset 1 based index</span>
             <span class="s0">*/</span>
            <span class="s1">lineOffsetToPosition(line: number, offset: number): number;</span>
            <span class="s1">positionToLineOffset(position: number): protocol.Location;</span>
            <span class="s1">isJavaScript(): boolean;</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">allRootFilesAreJsOrDts(project: Project): boolean;</span>
        <span class="s2">function </span><span class="s1">allFilesAreJsOrDts(project: Project): boolean;</span>
        <span class="s2">enum </span><span class="s1">ProjectKind {</span>
            <span class="s1">Inferred = </span><span class="s5">0</span><span class="s1">,</span>
            <span class="s1">Configured = </span><span class="s5">1</span><span class="s1">,</span>
            <span class="s1">External = </span><span class="s5">2</span><span class="s1">,</span>
            <span class="s1">AutoImportProvider = </span><span class="s5">3</span><span class="s1">,</span>
            <span class="s1">Auxiliary = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">PluginCreateInfo {</span>
            <span class="s1">project: Project;</span>
            <span class="s1">languageService: LanguageService;</span>
            <span class="s1">languageServiceHost: LanguageServiceHost;</span>
            <span class="s1">serverHost: ServerHost;</span>
            <span class="s1">session?: Session&lt;unknown&gt;;</span>
            <span class="s1">config: any;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">PluginModule {</span>
            <span class="s1">create(createInfo: PluginCreateInfo): LanguageService;</span>
            <span class="s1">getExternalFiles?(proj: Project, updateLevel: ProgramUpdateLevel): string[];</span>
            <span class="s1">onConfigurationChanged?(config: any): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">PluginModuleWithName {</span>
            <span class="s1">name: string;</span>
            <span class="s1">module: PluginModule;</span>
        <span class="s1">}</span>
        <span class="s1">type PluginModuleFactory = (mod: {</span>
            <span class="s1">typescript: </span><span class="s2">typeof </span><span class="s1">ts;</span>
        <span class="s1">}) =&gt; PluginModule;</span>
        <span class="s1">abstract </span><span class="s2">class </span><span class="s1">Project </span><span class="s2">implements </span><span class="s1">LanguageServiceHost, ModuleResolutionHost {</span>
            <span class="s1">readonly projectKind: ProjectKind;</span>
            <span class="s1">readonly projectService: ProjectService;</span>
            <span class="s2">private </span><span class="s1">compilerOptions;</span>
            <span class="s1">compileOnSaveEnabled: boolean;</span>
            <span class="s2">protected </span><span class="s1">watchOptions: WatchOptions | undefined;</span>
            <span class="s2">private </span><span class="s1">rootFilesMap;</span>
            <span class="s2">private </span><span class="s1">program;</span>
            <span class="s2">private </span><span class="s1">externalFiles;</span>
            <span class="s2">private </span><span class="s1">missingFilesMap;</span>
            <span class="s2">private </span><span class="s1">generatedFilesMap;</span>
            <span class="s2">private </span><span class="s1">hasAddedorRemovedFiles;</span>
            <span class="s2">private </span><span class="s1">hasAddedOrRemovedSymlinks;</span>
            <span class="s2">protected </span><span class="s1">languageService: LanguageService;</span>
            <span class="s1">languageServiceEnabled: boolean;</span>
            <span class="s1">readonly trace?: (s: string) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">readonly realpath?: (path: string) =&gt; string;</span>
            <span class="s2">private </span><span class="s1">builderState;</span>
            <span class="s2">private </span><span class="s1">updatedFileNames;</span>
            <span class="s2">private </span><span class="s1">lastReportedFileNames;</span>
            <span class="s2">private </span><span class="s1">lastReportedVersion;</span>
            <span class="s2">protected </span><span class="s1">projectErrors: Diagnostic[] | undefined;</span>
            <span class="s2">private </span><span class="s1">typingsCache;</span>
            <span class="s2">private </span><span class="s1">typingWatchers;</span>
            <span class="s2">private </span><span class="s1">readonly cancellationToken;</span>
            <span class="s1">isNonTsProject(): boolean;</span>
            <span class="s1">isJsOnlyProject(): boolean;</span>
            <span class="s2">static </span><span class="s1">resolveModule(moduleName: string, initialDir: string, host: ServerHost, log: (message: string) =&gt; </span><span class="s2">void</span><span class="s1">): {} | undefined;</span>
            <span class="s2">private </span><span class="s1">exportMapCache;</span>
            <span class="s2">private </span><span class="s1">changedFilesForExportMapCache;</span>
            <span class="s2">private </span><span class="s1">moduleSpecifierCache;</span>
            <span class="s2">private </span><span class="s1">symlinks;</span>
            <span class="s1">readonly jsDocParsingMode: JSDocParsingMode | undefined;</span>
            <span class="s1">isKnownTypesPackageName(name: string): boolean;</span>
            <span class="s1">installPackage(options: InstallPackageOptions): Promise&lt;ApplyCodeActionCommandResult&gt;;</span>
            <span class="s1">getCompilationSettings(): CompilerOptions;</span>
            <span class="s1">getCompilerOptions(): CompilerOptions;</span>
            <span class="s1">getNewLine(): string;</span>
            <span class="s1">getProjectVersion(): string;</span>
            <span class="s1">getProjectReferences(): readonly ProjectReference[] | undefined;</span>
            <span class="s1">getScriptFileNames(): string[];</span>
            <span class="s2">private </span><span class="s1">getOrCreateScriptInfoAndAttachToProject;</span>
            <span class="s1">getScriptKind(fileName: string): ScriptKind;</span>
            <span class="s1">getScriptVersion(filename: string): string;</span>
            <span class="s1">getScriptSnapshot(filename: string): IScriptSnapshot | undefined;</span>
            <span class="s1">getCancellationToken(): HostCancellationToken;</span>
            <span class="s1">getCurrentDirectory(): string;</span>
            <span class="s1">getDefaultLibFileName(): string;</span>
            <span class="s1">useCaseSensitiveFileNames(): boolean;</span>
            <span class="s1">readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];</span>
            <span class="s1">readFile(fileName: string): string | undefined;</span>
            <span class="s1">writeFile(fileName: string, content: string): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">fileExists(file: string): boolean;</span>
            <span class="s1">directoryExists(path: string): boolean;</span>
            <span class="s1">getDirectories(path: string): string[];</span>
            <span class="s1">log(s: string): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">error(s: string): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s2">private </span><span class="s1">setInternalCompilerOptionsForEmittingJsFiles;</span>
            <span class="s0">/**</span>
             <span class="s0">* Get the errors that dont have any file name associated</span>
             <span class="s0">*/</span>
            <span class="s1">getGlobalProjectErrors(): readonly Diagnostic[];</span>
            <span class="s0">/**</span>
             <span class="s0">* Get all the project errors</span>
             <span class="s0">*/</span>
            <span class="s1">getAllProjectErrors(): readonly Diagnostic[];</span>
            <span class="s1">setProjectErrors(projectErrors: Diagnostic[] | undefined): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">getLanguageService(ensureSynchronized?: boolean): LanguageService;</span>
            <span class="s1">getCompileOnSaveAffectedFileList(scriptInfo: ScriptInfo): string[];</span>
            <span class="s0">/**</span>
             <span class="s0">* Returns true if emit was conducted</span>
             <span class="s0">*/</span>
            <span class="s1">emitFile(scriptInfo: ScriptInfo, writeFile: (path: string, data: string, writeByteOrderMark?: boolean) =&gt; </span><span class="s2">void</span><span class="s1">): EmitResult;</span>
            <span class="s1">enableLanguageService(): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">disableLanguageService(lastFileExceededProgramSize?: string): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">getProjectName(): string;</span>
            <span class="s2">protected </span><span class="s1">removeLocalTypingsFromTypeAcquisition(newTypeAcquisition: TypeAcquisition): TypeAcquisition;</span>
            <span class="s1">getExternalFiles(updateLevel?: ProgramUpdateLevel): SortedReadonlyArray&lt;string&gt;;</span>
            <span class="s1">getSourceFile(path: Path): SourceFile | undefined;</span>
            <span class="s1">close(): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s2">private </span><span class="s1">detachScriptInfoIfNotRoot;</span>
            <span class="s1">isClosed(): boolean;</span>
            <span class="s1">hasRoots(): boolean;</span>
            <span class="s1">getRootFiles(): NormalizedPath[];</span>
            <span class="s1">getRootScriptInfos(): ScriptInfo[];</span>
            <span class="s1">getScriptInfos(): ScriptInfo[];</span>
            <span class="s1">getExcludedFiles(): readonly NormalizedPath[];</span>
            <span class="s1">getFileNames(excludeFilesFromExternalLibraries?: boolean, excludeConfigFiles?: boolean): NormalizedPath[];</span>
            <span class="s1">hasConfigFile(configFilePath: NormalizedPath): boolean;</span>
            <span class="s1">containsScriptInfo(info: ScriptInfo): boolean;</span>
            <span class="s1">containsFile(filename: NormalizedPath, requireOpen?: boolean): boolean;</span>
            <span class="s1">isRoot(info: ScriptInfo): boolean;</span>
            <span class="s1">addRoot(info: ScriptInfo, fileName?: NormalizedPath): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">addMissingFileRoot(fileName: NormalizedPath): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">removeFile(info: ScriptInfo, fileExists: boolean, detachFromProject: boolean): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">registerFileUpdate(fileName: string): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Updates set of files that contribute to this project</span>
             <span class="s0">* </span><span class="s4">@returns</span><span class="s0">: true if set of files in the project stays the same and false - otherwise.</span>
             <span class="s0">*/</span>
            <span class="s1">updateGraph(): boolean;</span>
            <span class="s2">private </span><span class="s1">closeWatchingTypingLocations;</span>
            <span class="s2">private </span><span class="s1">onTypingInstallerWatchInvoke;</span>
            <span class="s2">protected </span><span class="s1">removeExistingTypings(include: string[]): string[];</span>
            <span class="s2">private </span><span class="s1">updateGraphWorker;</span>
            <span class="s2">private </span><span class="s1">detachScriptInfoFromProject;</span>
            <span class="s2">private </span><span class="s1">addMissingFileWatcher;</span>
            <span class="s2">private </span><span class="s1">isWatchedMissingFile;</span>
            <span class="s2">private </span><span class="s1">createGeneratedFileWatcher;</span>
            <span class="s2">private </span><span class="s1">isValidGeneratedFileWatcher;</span>
            <span class="s2">private </span><span class="s1">clearGeneratedFileWatch;</span>
            <span class="s1">getScriptInfoForNormalizedPath(fileName: NormalizedPath): ScriptInfo | undefined;</span>
            <span class="s1">getScriptInfo(uncheckedFileName: string): ScriptInfo | undefined;</span>
            <span class="s1">filesToString(writeProjectFileNames: boolean): string;</span>
            <span class="s2">private </span><span class="s1">filesToStringWorker;</span>
            <span class="s1">setCompilerOptions(compilerOptions: CompilerOptions): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">setTypeAcquisition(newTypeAcquisition: TypeAcquisition | undefined): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">getTypeAcquisition(): TypeAcquisition;</span>
            <span class="s2">protected </span><span class="s1">removeRoot(info: ScriptInfo): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s2">protected </span><span class="s1">enableGlobalPlugins(options: CompilerOptions): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s2">protected </span><span class="s1">enablePlugin(pluginConfigEntry: PluginImport, searchPaths: string[]): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s0">/** Starts a new check for diagnostics. Call this if some file has updated that would cause diagnostics to be changed. */</span>
            <span class="s1">refreshDiagnostics(): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s2">private </span><span class="s1">isDefaultProjectForOpenFiles;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* If a file is opened and no tsconfig (or jsconfig) is found,</span>
         <span class="s0">* the file and its imports/references are put into an InferredProject.</span>
         <span class="s0">*/</span>
        <span class="s2">class </span><span class="s1">InferredProject </span><span class="s2">extends </span><span class="s1">Project {</span>
            <span class="s2">private </span><span class="s1">_isJsInferredProject;</span>
            <span class="s1">toggleJsInferredProject(isJsInferredProject: boolean): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">setCompilerOptions(options?: CompilerOptions): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s0">/** this is canonical project root path */</span>
            <span class="s1">readonly projectRootPath: string | undefined;</span>
            <span class="s1">addRoot(info: ScriptInfo): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">removeRoot(info: ScriptInfo): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">isProjectWithSingleRoot(): boolean;</span>
            <span class="s1">close(): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">getTypeAcquisition(): TypeAcquisition;</span>
        <span class="s1">}</span>
        <span class="s2">class </span><span class="s1">AutoImportProviderProject </span><span class="s2">extends </span><span class="s1">Project {</span>
            <span class="s2">private </span><span class="s1">hostProject;</span>
            <span class="s2">private static </span><span class="s1">readonly maxDependencies;</span>
            <span class="s2">private </span><span class="s1">rootFileNames;</span>
            <span class="s1">updateGraph(): boolean;</span>
            <span class="s1">hasRoots(): boolean;</span>
            <span class="s1">getScriptFileNames(): string[];</span>
            <span class="s1">getLanguageService(): never;</span>
            <span class="s1">getHostForAutoImportProvider(): never;</span>
            <span class="s1">getProjectReferences(): readonly ProjectReference[] | undefined;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* If a file is opened, the server will look for a tsconfig (or jsconfig)</span>
         <span class="s0">* and if successful create a ConfiguredProject for it.</span>
         <span class="s0">* Otherwise it will create an InferredProject.</span>
         <span class="s0">*/</span>
        <span class="s2">class </span><span class="s1">ConfiguredProject </span><span class="s2">extends </span><span class="s1">Project {</span>
            <span class="s1">readonly canonicalConfigFilePath: NormalizedPath;</span>
            <span class="s2">private </span><span class="s1">projectReferences;</span>
            <span class="s2">private </span><span class="s1">compilerHost?;</span>
            <span class="s2">private </span><span class="s1">releaseParsedConfig;</span>
            <span class="s0">/**</span>
             <span class="s0">* If the project has reload from disk pending, it reloads (and then updates graph as part of that) instead of just updating the graph</span>
             <span class="s0">* </span><span class="s4">@returns</span><span class="s0">: true if set of files in the project stays the same and false - otherwise.</span>
             <span class="s0">*/</span>
            <span class="s1">updateGraph(): boolean;</span>
            <span class="s1">getConfigFilePath(): NormalizedPath;</span>
            <span class="s1">getProjectReferences(): readonly ProjectReference[] | undefined;</span>
            <span class="s1">updateReferences(refs: readonly ProjectReference[] | undefined): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Get the errors that dont have any file name associated</span>
             <span class="s0">*/</span>
            <span class="s1">getGlobalProjectErrors(): readonly Diagnostic[];</span>
            <span class="s0">/**</span>
             <span class="s0">* Get all the project errors</span>
             <span class="s0">*/</span>
            <span class="s1">getAllProjectErrors(): readonly Diagnostic[];</span>
            <span class="s1">setProjectErrors(projectErrors: Diagnostic[]): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">close(): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">getEffectiveTypeRoots(): string[];</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* Project whose configuration is handled externally, such as in a '.csproj'.</span>
         <span class="s0">* These are created only if a host explicitly calls `openExternalProject`.</span>
         <span class="s0">*/</span>
        <span class="s2">class </span><span class="s1">ExternalProject </span><span class="s2">extends </span><span class="s1">Project {</span>
            <span class="s1">externalProjectName: string;</span>
            <span class="s1">compileOnSaveEnabled: boolean;</span>
            <span class="s1">excludedFiles: readonly NormalizedPath[];</span>
            <span class="s1">updateGraph(): boolean;</span>
            <span class="s1">getExcludedFiles(): readonly NormalizedPath[];</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">convertFormatOptions(protocolOptions: protocol.FormatCodeSettings): FormatCodeSettings;</span>
        <span class="s2">function </span><span class="s1">convertCompilerOptions(protocolOptions: protocol.ExternalProjectCompilerOptions): CompilerOptions &amp; protocol.CompileOnSaveMixin;</span>
        <span class="s2">function </span><span class="s1">convertWatchOptions(protocolOptions: protocol.ExternalProjectCompilerOptions, currentDirectory?: string): WatchOptionsAndErrors | undefined;</span>
        <span class="s2">function </span><span class="s1">convertTypeAcquisition(protocolOptions: protocol.InferredProjectCompilerOptions): TypeAcquisition | undefined;</span>
        <span class="s2">function </span><span class="s1">tryConvertScriptKindName(scriptKindName: protocol.ScriptKindName | ScriptKind): ScriptKind;</span>
        <span class="s2">function </span><span class="s1">convertScriptKindName(scriptKindName: protocol.ScriptKindName): ScriptKind;</span>
        <span class="s2">const </span><span class="s1">maxProgramSizeForNonTsFiles: number;</span>
        <span class="s2">const </span><span class="s1">ProjectsUpdatedInBackgroundEvent = </span><span class="s3">&quot;projectsUpdatedInBackground&quot;</span><span class="s1">;</span>
        <span class="s2">interface </span><span class="s1">ProjectsUpdatedInBackgroundEvent {</span>
            <span class="s1">eventName: </span><span class="s2">typeof </span><span class="s1">ProjectsUpdatedInBackgroundEvent;</span>
            <span class="s1">data: {</span>
                <span class="s1">openFiles: string[];</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">ProjectLoadingStartEvent = </span><span class="s3">&quot;projectLoadingStart&quot;</span><span class="s1">;</span>
        <span class="s2">interface </span><span class="s1">ProjectLoadingStartEvent {</span>
            <span class="s1">eventName: </span><span class="s2">typeof </span><span class="s1">ProjectLoadingStartEvent;</span>
            <span class="s1">data: {</span>
                <span class="s1">project: Project;</span>
                <span class="s1">reason: string;</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">ProjectLoadingFinishEvent = </span><span class="s3">&quot;projectLoadingFinish&quot;</span><span class="s1">;</span>
        <span class="s2">interface </span><span class="s1">ProjectLoadingFinishEvent {</span>
            <span class="s1">eventName: </span><span class="s2">typeof </span><span class="s1">ProjectLoadingFinishEvent;</span>
            <span class="s1">data: {</span>
                <span class="s1">project: Project;</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">LargeFileReferencedEvent = </span><span class="s3">&quot;largeFileReferenced&quot;</span><span class="s1">;</span>
        <span class="s2">interface </span><span class="s1">LargeFileReferencedEvent {</span>
            <span class="s1">eventName: </span><span class="s2">typeof </span><span class="s1">LargeFileReferencedEvent;</span>
            <span class="s1">data: {</span>
                <span class="s1">file: string;</span>
                <span class="s1">fileSize: number;</span>
                <span class="s1">maxFileSize: number;</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">ConfigFileDiagEvent = </span><span class="s3">&quot;configFileDiag&quot;</span><span class="s1">;</span>
        <span class="s2">interface </span><span class="s1">ConfigFileDiagEvent {</span>
            <span class="s1">eventName: </span><span class="s2">typeof </span><span class="s1">ConfigFileDiagEvent;</span>
            <span class="s1">data: {</span>
                <span class="s1">triggerFile: string;</span>
                <span class="s1">configFileName: string;</span>
                <span class="s1">diagnostics: readonly Diagnostic[];</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">ProjectLanguageServiceStateEvent = </span><span class="s3">&quot;projectLanguageServiceState&quot;</span><span class="s1">;</span>
        <span class="s2">interface </span><span class="s1">ProjectLanguageServiceStateEvent {</span>
            <span class="s1">eventName: </span><span class="s2">typeof </span><span class="s1">ProjectLanguageServiceStateEvent;</span>
            <span class="s1">data: {</span>
                <span class="s1">project: Project;</span>
                <span class="s1">languageServiceEnabled: boolean;</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">ProjectInfoTelemetryEvent = </span><span class="s3">&quot;projectInfo&quot;</span><span class="s1">;</span>
        <span class="s0">/** This will be converted to the payload of a protocol.TelemetryEvent in session.defaultEventHandler. */</span>
        <span class="s2">interface </span><span class="s1">ProjectInfoTelemetryEvent {</span>
            <span class="s1">readonly eventName: </span><span class="s2">typeof </span><span class="s1">ProjectInfoTelemetryEvent;</span>
            <span class="s1">readonly data: ProjectInfoTelemetryEventData;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">OpenFileInfoTelemetryEvent = </span><span class="s3">&quot;openFileInfo&quot;</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Info that we may send about a file that was just opened.</span>
         <span class="s0">* Info about a file will only be sent once per session, even if the file changes in ways that might affect the info.</span>
         <span class="s0">* Currently this is only sent for '.js' files.</span>
         <span class="s0">*/</span>
        <span class="s2">interface </span><span class="s1">OpenFileInfoTelemetryEvent {</span>
            <span class="s1">readonly eventName: </span><span class="s2">typeof </span><span class="s1">OpenFileInfoTelemetryEvent;</span>
            <span class="s1">readonly data: OpenFileInfoTelemetryEventData;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">CreateFileWatcherEvent: protocol.CreateFileWatcherEventName;</span>
        <span class="s2">interface </span><span class="s1">CreateFileWatcherEvent {</span>
            <span class="s1">readonly eventName: protocol.CreateFileWatcherEventName;</span>
            <span class="s1">readonly data: protocol.CreateFileWatcherEventBody;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">CreateDirectoryWatcherEvent: protocol.CreateDirectoryWatcherEventName;</span>
        <span class="s2">interface </span><span class="s1">CreateDirectoryWatcherEvent {</span>
            <span class="s1">readonly eventName: protocol.CreateDirectoryWatcherEventName;</span>
            <span class="s1">readonly data: protocol.CreateDirectoryWatcherEventBody;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">CloseFileWatcherEvent: protocol.CloseFileWatcherEventName;</span>
        <span class="s2">interface </span><span class="s1">CloseFileWatcherEvent {</span>
            <span class="s1">readonly eventName: protocol.CloseFileWatcherEventName;</span>
            <span class="s1">readonly data: protocol.CloseFileWatcherEventBody;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">ProjectInfoTelemetryEventData {</span>
            <span class="s0">/** Cryptographically secure hash of project file location. */</span>
            <span class="s1">readonly projectId: string;</span>
            <span class="s0">/** Count of file extensions seen in the project. */</span>
            <span class="s1">readonly fileStats: FileStats;</span>
            <span class="s0">/**</span>
             <span class="s0">* Any compiler options that might contain paths will be taken out.</span>
             <span class="s0">* Enum compiler options will be converted to strings.</span>
             <span class="s0">*/</span>
            <span class="s1">readonly compilerOptions: CompilerOptions;</span>
            <span class="s1">readonly </span><span class="s2">extends</span><span class="s1">: boolean | undefined;</span>
            <span class="s1">readonly files: boolean | undefined;</span>
            <span class="s1">readonly include: boolean | undefined;</span>
            <span class="s1">readonly exclude: boolean | undefined;</span>
            <span class="s1">readonly compileOnSave: boolean;</span>
            <span class="s1">readonly typeAcquisition: ProjectInfoTypeAcquisitionData;</span>
            <span class="s1">readonly configFileName: </span><span class="s3">&quot;tsconfig.json&quot; </span><span class="s1">| </span><span class="s3">&quot;jsconfig.json&quot; </span><span class="s1">| </span><span class="s3">&quot;other&quot;</span><span class="s1">;</span>
            <span class="s1">readonly projectType: </span><span class="s3">&quot;external&quot; </span><span class="s1">| </span><span class="s3">&quot;configured&quot;</span><span class="s1">;</span>
            <span class="s1">readonly languageServiceEnabled: boolean;</span>
            <span class="s0">/** TypeScript version used by the server. */</span>
            <span class="s1">readonly version: string;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">OpenFileInfoTelemetryEventData {</span>
            <span class="s1">readonly info: OpenFileInfo;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">ProjectInfoTypeAcquisitionData {</span>
            <span class="s1">readonly enable: boolean | undefined;</span>
            <span class="s1">readonly include: boolean;</span>
            <span class="s1">readonly exclude: boolean;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">FileStats {</span>
            <span class="s1">readonly js: number;</span>
            <span class="s1">readonly jsSize?: number;</span>
            <span class="s1">readonly jsx: number;</span>
            <span class="s1">readonly jsxSize?: number;</span>
            <span class="s1">readonly ts: number;</span>
            <span class="s1">readonly tsSize?: number;</span>
            <span class="s1">readonly tsx: number;</span>
            <span class="s1">readonly tsxSize?: number;</span>
            <span class="s1">readonly dts: number;</span>
            <span class="s1">readonly dtsSize?: number;</span>
            <span class="s1">readonly deferred: number;</span>
            <span class="s1">readonly deferredSize?: number;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">OpenFileInfo {</span>
            <span class="s1">readonly checkJs: boolean;</span>
        <span class="s1">}</span>
        <span class="s1">type ProjectServiceEvent = LargeFileReferencedEvent | ProjectsUpdatedInBackgroundEvent | ProjectLoadingStartEvent | ProjectLoadingFinishEvent | ConfigFileDiagEvent | ProjectLanguageServiceStateEvent | ProjectInfoTelemetryEvent | OpenFileInfoTelemetryEvent | CreateFileWatcherEvent | CreateDirectoryWatcherEvent | CloseFileWatcherEvent;</span>
        <span class="s1">type ProjectServiceEventHandler = (event: ProjectServiceEvent) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s2">interface </span><span class="s1">SafeList {</span>
            <span class="s1">[name: string]: {</span>
                <span class="s1">match: RegExp;</span>
                <span class="s1">exclude?: (string | number)[][];</span>
                <span class="s1">types?: string[];</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">TypesMapFile {</span>
            <span class="s1">typesMap: SafeList;</span>
            <span class="s1">simpleMap: {</span>
                <span class="s1">[libName: string]: string;</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">HostConfiguration {</span>
            <span class="s1">formatCodeOptions: FormatCodeSettings;</span>
            <span class="s1">preferences: protocol.UserPreferences;</span>
            <span class="s1">hostInfo: string;</span>
            <span class="s1">extraFileExtensions?: FileExtensionInfo[];</span>
            <span class="s1">watchOptions?: WatchOptions;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">OpenConfiguredProjectResult {</span>
            <span class="s1">configFileName?: NormalizedPath;</span>
            <span class="s1">configFileErrors?: readonly Diagnostic[];</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">nullTypingsInstaller: ITypingsInstaller;</span>
        <span class="s2">interface </span><span class="s1">ProjectServiceOptions {</span>
            <span class="s1">host: ServerHost;</span>
            <span class="s1">logger: Logger;</span>
            <span class="s1">cancellationToken: HostCancellationToken;</span>
            <span class="s1">useSingleInferredProject: boolean;</span>
            <span class="s1">useInferredProjectPerProjectRoot: boolean;</span>
            <span class="s1">typingsInstaller?: ITypingsInstaller;</span>
            <span class="s1">eventHandler?: ProjectServiceEventHandler;</span>
            <span class="s1">canUseWatchEvents?: boolean;</span>
            <span class="s1">suppressDiagnosticEvents?: boolean;</span>
            <span class="s1">throttleWaitMilliseconds?: number;</span>
            <span class="s1">globalPlugins?: readonly string[];</span>
            <span class="s1">pluginProbeLocations?: readonly string[];</span>
            <span class="s1">allowLocalPluginLoads?: boolean;</span>
            <span class="s1">typesMapLocation?: string;</span>
            <span class="s1">serverMode?: LanguageServiceMode;</span>
            <span class="s1">session: Session&lt;unknown&gt; | undefined;</span>
            <span class="s1">jsDocParsingMode?: JSDocParsingMode;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">WatchOptionsAndErrors {</span>
            <span class="s1">watchOptions: WatchOptions;</span>
            <span class="s1">errors: Diagnostic[] | undefined;</span>
        <span class="s1">}</span>
        <span class="s2">class </span><span class="s1">ProjectService {</span>
            <span class="s2">private </span><span class="s1">readonly nodeModulesWatchers;</span>
            <span class="s2">private </span><span class="s1">readonly filenameToScriptInfoVersion;</span>
            <span class="s2">private </span><span class="s1">readonly allJsFilesForOpenFileTelemetry;</span>
            <span class="s2">private </span><span class="s1">readonly externalProjectToConfiguredProjectMap;</span>
            <span class="s0">/**</span>
             <span class="s0">* external projects (configuration and list of root files is not controlled by tsserver)</span>
             <span class="s0">*/</span>
            <span class="s1">readonly externalProjects: ExternalProject[];</span>
            <span class="s0">/**</span>
             <span class="s0">* projects built from openFileRoots</span>
             <span class="s0">*/</span>
            <span class="s1">readonly inferredProjects: InferredProject[];</span>
            <span class="s0">/**</span>
             <span class="s0">* projects specified by a tsconfig.json file</span>
             <span class="s0">*/</span>
            <span class="s1">readonly configuredProjects: Map&lt;string, ConfiguredProject&gt;;</span>
            <span class="s0">/**</span>
             <span class="s0">* Open files: with value being project root path, and key being Path of the file that is open</span>
             <span class="s0">*/</span>
            <span class="s1">readonly openFiles: Map&lt;Path, NormalizedPath | undefined&gt;;</span>
            <span class="s2">private </span><span class="s1">readonly configFileForOpenFiles;</span>
            <span class="s2">private </span><span class="s1">rootOfInferredProjects;</span>
            <span class="s2">private </span><span class="s1">readonly openFilesWithNonRootedDiskPath;</span>
            <span class="s2">private </span><span class="s1">compilerOptionsForInferredProjects;</span>
            <span class="s2">private </span><span class="s1">compilerOptionsForInferredProjectsPerProjectRoot;</span>
            <span class="s2">private </span><span class="s1">watchOptionsForInferredProjects;</span>
            <span class="s2">private </span><span class="s1">watchOptionsForInferredProjectsPerProjectRoot;</span>
            <span class="s2">private </span><span class="s1">typeAcquisitionForInferredProjects;</span>
            <span class="s2">private </span><span class="s1">typeAcquisitionForInferredProjectsPerProjectRoot;</span>
            <span class="s2">private </span><span class="s1">readonly projectToSizeMap;</span>
            <span class="s2">private </span><span class="s1">readonly hostConfiguration;</span>
            <span class="s2">private </span><span class="s1">safelist;</span>
            <span class="s2">private </span><span class="s1">readonly legacySafelist;</span>
            <span class="s2">private </span><span class="s1">pendingProjectUpdates;</span>
            <span class="s2">private </span><span class="s1">pendingOpenFileProjectUpdates?;</span>
            <span class="s1">readonly currentDirectory: NormalizedPath;</span>
            <span class="s1">readonly toCanonicalFileName: (f: string) =&gt; string;</span>
            <span class="s1">readonly host: ServerHost;</span>
            <span class="s1">readonly logger: Logger;</span>
            <span class="s1">readonly cancellationToken: HostCancellationToken;</span>
            <span class="s1">readonly useSingleInferredProject: boolean;</span>
            <span class="s1">readonly useInferredProjectPerProjectRoot: boolean;</span>
            <span class="s1">readonly typingsInstaller: ITypingsInstaller;</span>
            <span class="s2">private </span><span class="s1">readonly globalCacheLocationDirectoryPath;</span>
            <span class="s1">readonly throttleWaitMilliseconds?: number;</span>
            <span class="s2">private </span><span class="s1">readonly suppressDiagnosticEvents?;</span>
            <span class="s1">readonly globalPlugins: readonly string[];</span>
            <span class="s1">readonly pluginProbeLocations: readonly string[];</span>
            <span class="s1">readonly allowLocalPluginLoads: boolean;</span>
            <span class="s1">readonly typesMapLocation: string | undefined;</span>
            <span class="s1">readonly serverMode: LanguageServiceMode;</span>
            <span class="s2">private </span><span class="s1">readonly seenProjects;</span>
            <span class="s2">private </span><span class="s1">readonly sharedExtendedConfigFileWatchers;</span>
            <span class="s2">private </span><span class="s1">readonly extendedConfigCache;</span>
            <span class="s2">private </span><span class="s1">packageJsonFilesMap;</span>
            <span class="s2">private </span><span class="s1">incompleteCompletionsCache;</span>
            <span class="s2">private </span><span class="s1">performanceEventHandler?;</span>
            <span class="s2">private </span><span class="s1">pendingPluginEnablements?;</span>
            <span class="s2">private </span><span class="s1">currentPluginEnablementPromise?;</span>
            <span class="s1">readonly jsDocParsingMode: JSDocParsingMode | undefined;</span>
            <span class="s1">constructor(opts: ProjectServiceOptions);</span>
            <span class="s1">toPath(fileName: string): Path;</span>
            <span class="s2">private </span><span class="s1">loadTypesMap;</span>
            <span class="s1">updateTypingsForProject(response: SetTypings | InvalidateCachedTypings | PackageInstalledResponse): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s2">private </span><span class="s1">delayUpdateProjectGraph;</span>
            <span class="s2">private </span><span class="s1">delayUpdateProjectGraphs;</span>
            <span class="s1">setCompilerOptionsForInferredProjects(projectCompilerOptions: protocol.InferredProjectCompilerOptions, projectRootPath?: string): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">findProject(projectName: string): Project | undefined;</span>
            <span class="s1">getDefaultProjectForFile(fileName: NormalizedPath, ensureProject: boolean): Project | undefined;</span>
            <span class="s2">private </span><span class="s1">tryGetDefaultProjectForEnsuringConfiguredProjectForFile;</span>
            <span class="s2">private </span><span class="s1">doEnsureDefaultProjectForFile;</span>
            <span class="s1">getScriptInfoEnsuringProjectsUptoDate(uncheckedFileName: string): ScriptInfo | undefined;</span>
            <span class="s2">private </span><span class="s1">ensureProjectStructuresUptoDate;</span>
            <span class="s1">getFormatCodeOptions(file: NormalizedPath): FormatCodeSettings;</span>
            <span class="s1">getPreferences(file: NormalizedPath): protocol.UserPreferences;</span>
            <span class="s1">getHostFormatCodeOptions(): FormatCodeSettings;</span>
            <span class="s1">getHostPreferences(): protocol.UserPreferences;</span>
            <span class="s2">private </span><span class="s1">onSourceFileChanged;</span>
            <span class="s2">private </span><span class="s1">handleSourceMapProjects;</span>
            <span class="s2">private </span><span class="s1">delayUpdateSourceInfoProjects;</span>
            <span class="s2">private </span><span class="s1">delayUpdateProjectsOfScriptInfoPath;</span>
            <span class="s2">private </span><span class="s1">handleDeletedFile;</span>
            <span class="s2">private </span><span class="s1">watchWildcardDirectory;</span>
            <span class="s2">private </span><span class="s1">onWildCardDirectoryWatcherInvoke;</span>
            <span class="s2">private </span><span class="s1">delayUpdateProjectsFromParsedConfigOnConfigFileChange;</span>
            <span class="s2">private </span><span class="s1">onConfigFileChanged;</span>
            <span class="s2">private </span><span class="s1">removeProject;</span>
            <span class="s2">private </span><span class="s1">assignOrphanScriptInfosToInferredProject;</span>
            <span class="s2">private </span><span class="s1">closeOpenFile;</span>
            <span class="s2">private </span><span class="s1">deleteScriptInfo;</span>
            <span class="s2">private </span><span class="s1">configFileExists;</span>
            <span class="s2">private </span><span class="s1">createConfigFileWatcherForParsedConfig;</span>
            <span class="s2">private </span><span class="s1">ensureConfigFileWatcherForProject;</span>
            <span class="s2">private </span><span class="s1">forEachConfigFileLocation;</span>
            <span class="s2">private </span><span class="s1">getConfigFileNameForFileFromCache;</span>
            <span class="s2">private </span><span class="s1">setConfigFileNameForFileInCache;</span>
            <span class="s2">private </span><span class="s1">printProjects;</span>
            <span class="s2">private </span><span class="s1">getConfiguredProjectByCanonicalConfigFilePath;</span>
            <span class="s2">private </span><span class="s1">findExternalProjectByProjectName;</span>
            <span class="s2">private </span><span class="s1">getFilenameForExceededTotalSizeLimitForNonTsFiles;</span>
            <span class="s2">private </span><span class="s1">createExternalProject;</span>
            <span class="s2">private </span><span class="s1">addFilesToNonInferredProject;</span>
            <span class="s2">private </span><span class="s1">loadConfiguredProject;</span>
            <span class="s2">private </span><span class="s1">updateNonInferredProjectFiles;</span>
            <span class="s2">private </span><span class="s1">updateRootAndOptionsOfNonInferredProject;</span>
            <span class="s2">private </span><span class="s1">reloadFileNamesOfParsedConfig;</span>
            <span class="s2">private </span><span class="s1">setProjectForReload;</span>
            <span class="s2">private </span><span class="s1">clearSemanticCache;</span>
            <span class="s2">private </span><span class="s1">getOrCreateInferredProjectForProjectRootPathIfEnabled;</span>
            <span class="s2">private </span><span class="s1">getOrCreateSingleInferredProjectIfEnabled;</span>
            <span class="s2">private </span><span class="s1">getOrCreateSingleInferredWithoutProjectRoot;</span>
            <span class="s2">private </span><span class="s1">createInferredProject;</span>
            <span class="s1">getScriptInfo(uncheckedFileName: string): ScriptInfo | undefined;</span>
            <span class="s2">private </span><span class="s1">watchClosedScriptInfo;</span>
            <span class="s2">private </span><span class="s1">createNodeModulesWatcher;</span>
            <span class="s2">private </span><span class="s1">watchClosedScriptInfoInNodeModules;</span>
            <span class="s2">private </span><span class="s1">getModifiedTime;</span>
            <span class="s2">private </span><span class="s1">refreshScriptInfo;</span>
            <span class="s2">private </span><span class="s1">refreshScriptInfosInDirectory;</span>
            <span class="s2">private </span><span class="s1">stopWatchingScriptInfo;</span>
            <span class="s2">private </span><span class="s1">getOrCreateScriptInfoNotOpenedByClientForNormalizedPath;</span>
            <span class="s1">getOrCreateScriptInfoForNormalizedPath(fileName: NormalizedPath, openedByClient: boolean, fileContent?: string, scriptKind?: ScriptKind, hasMixedContent?: boolean, hostToQueryFileExistsOn?: {</span>
                <span class="s1">fileExists(path: string): boolean;</span>
            <span class="s1">}): ScriptInfo | undefined;</span>
            <span class="s2">private </span><span class="s1">getOrCreateScriptInfoWorker;</span>
            <span class="s0">/**</span>
             <span class="s0">* This gets the script info for the normalized path. If the path is not rooted disk path then the open script info with project root context is preferred</span>
             <span class="s0">*/</span>
            <span class="s1">getScriptInfoForNormalizedPath(fileName: NormalizedPath): ScriptInfo | undefined;</span>
            <span class="s1">getScriptInfoForPath(fileName: Path): ScriptInfo | undefined;</span>
            <span class="s2">private </span><span class="s1">addSourceInfoToSourceMap;</span>
            <span class="s2">private </span><span class="s1">addMissingSourceMapFile;</span>
            <span class="s1">setHostConfiguration(args: protocol.ConfigureRequestArguments): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s2">private </span><span class="s1">getWatchOptionsFromProjectWatchOptions;</span>
            <span class="s1">closeLog(): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s2">private </span><span class="s1">sendSourceFileChange;</span>
            <span class="s0">/**</span>
             <span class="s0">* This function rebuilds the project for every file opened by the client</span>
             <span class="s0">* This does not reload contents of open files from disk. But we could do that if needed</span>
             <span class="s0">*/</span>
            <span class="s1">reloadProjects(): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s2">private </span><span class="s1">removeRootOfInferredProjectIfNowPartOfOtherProject;</span>
            <span class="s2">private </span><span class="s1">ensureProjectForOpenFiles;</span>
            <span class="s0">/**</span>
             <span class="s0">* Open file whose contents is managed by the client</span>
             <span class="s0">* </span><span class="s4">@param </span><span class="s0">filename is absolute pathname</span>
             <span class="s0">* </span><span class="s4">@param </span><span class="s0">fileContent is a known version of the file content that is more up to date than the one on disk</span>
             <span class="s0">*/</span>
            <span class="s1">openClientFile(fileName: string, fileContent?: string, scriptKind?: ScriptKind, projectRootPath?: string): OpenConfiguredProjectResult;</span>
            <span class="s2">private </span><span class="s1">findExternalProjectContainingOpenScriptInfo;</span>
            <span class="s2">private </span><span class="s1">getOrCreateOpenScriptInfo;</span>
            <span class="s2">private </span><span class="s1">assignProjectToOpenedScriptInfo;</span>
            <span class="s2">private </span><span class="s1">tryFindDefaultConfiguredProjectForOpenScriptInfo;</span>
            <span class="s2">private </span><span class="s1">isMatchedByConfig;</span>
            <span class="s2">private </span><span class="s1">tryFindDefaultConfiguredProjectForOpenScriptInfoOrClosedFileInfo;</span>
            <span class="s2">private </span><span class="s1">tryFindDefaultConfiguredProjectAndLoadAncestorsForOpenScriptInfo;</span>
            <span class="s2">private </span><span class="s1">ensureProjectChildren;</span>
            <span class="s2">private </span><span class="s1">cleanupConfiguredProjects;</span>
            <span class="s2">private </span><span class="s1">cleanupProjectsAndScriptInfos;</span>
            <span class="s2">private </span><span class="s1">tryInvokeWildCardDirectories;</span>
            <span class="s1">openClientFileWithNormalizedPath(fileName: NormalizedPath, fileContent?: string, scriptKind?: ScriptKind, hasMixedContent?: boolean, projectRootPath?: NormalizedPath): OpenConfiguredProjectResult;</span>
            <span class="s2">private </span><span class="s1">removeOrphanScriptInfos;</span>
            <span class="s2">private </span><span class="s1">telemetryOnOpenFile;</span>
            <span class="s0">/**</span>
             <span class="s0">* Close file whose contents is managed by the client</span>
             <span class="s0">* </span><span class="s4">@param </span><span class="s0">filename is absolute pathname</span>
             <span class="s0">*/</span>
            <span class="s1">closeClientFile(uncheckedFileName: string): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s2">private </span><span class="s1">collectChanges;</span>
            <span class="s1">closeExternalProject(uncheckedFileName: string): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">openExternalProjects(projects: protocol.ExternalProject[]): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s2">private static </span><span class="s1">readonly filenameEscapeRegexp;</span>
            <span class="s2">private static </span><span class="s1">escapeFilenameForRegex;</span>
            <span class="s1">resetSafeList(): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">applySafeList(proj: protocol.ExternalProject): NormalizedPath[];</span>
            <span class="s2">private </span><span class="s1">applySafeListWorker;</span>
            <span class="s1">openExternalProject(proj: protocol.ExternalProject): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">hasDeferredExtension(): boolean;</span>
            <span class="s2">private </span><span class="s1">endEnablePlugin;</span>
            <span class="s2">private </span><span class="s1">enableRequestedPluginsAsync;</span>
            <span class="s2">private </span><span class="s1">enableRequestedPluginsWorker;</span>
            <span class="s1">configurePlugin(args: protocol.ConfigurePluginRequestArguments): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s2">private </span><span class="s1">watchPackageJsonFile;</span>
            <span class="s2">private </span><span class="s1">onPackageJsonChange;</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">formatMessage&lt;T </span><span class="s2">extends </span><span class="s1">protocol.Message&gt;(msg: T, logger: Logger, byteLength: (s: string, encoding: BufferEncoding) =&gt; number, newLine: string): string;</span>
        <span class="s2">interface </span><span class="s1">ServerCancellationToken </span><span class="s2">extends </span><span class="s1">HostCancellationToken {</span>
            <span class="s1">setRequest(requestId: number): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">resetRequest(requestId: number): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">nullCancellationToken: ServerCancellationToken;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">use ts.server.protocol.CommandTypes */</span>
        <span class="s1">type CommandNames = protocol.CommandTypes;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">use ts.server.protocol.CommandTypes */</span>
        <span class="s2">const </span><span class="s1">CommandNames: any;</span>
        <span class="s1">type Event = &lt;T </span><span class="s2">extends </span><span class="s1">object&gt;(body: T, eventName: string) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s2">interface </span><span class="s1">EventSender {</span>
            <span class="s1">event: Event;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">SessionOptions {</span>
            <span class="s1">host: ServerHost;</span>
            <span class="s1">cancellationToken: ServerCancellationToken;</span>
            <span class="s1">useSingleInferredProject: boolean;</span>
            <span class="s1">useInferredProjectPerProjectRoot: boolean;</span>
            <span class="s1">typingsInstaller?: ITypingsInstaller;</span>
            <span class="s1">byteLength: (buf: string, encoding?: BufferEncoding) =&gt; number;</span>
            <span class="s1">hrtime: (start?: [</span>
                <span class="s1">number,</span>
                <span class="s1">number,</span>
            <span class="s1">]) =&gt; [</span>
                <span class="s1">number,</span>
                <span class="s1">number,</span>
            <span class="s1">];</span>
            <span class="s1">logger: Logger;</span>
            <span class="s0">/**</span>
             <span class="s0">* If falsy, all events are suppressed.</span>
             <span class="s0">*/</span>
            <span class="s1">canUseEvents: boolean;</span>
            <span class="s1">canUseWatchEvents?: boolean;</span>
            <span class="s1">eventHandler?: ProjectServiceEventHandler;</span>
            <span class="s0">/** Has no effect if eventHandler is also specified. */</span>
            <span class="s1">suppressDiagnosticEvents?: boolean;</span>
            <span class="s1">serverMode?: LanguageServiceMode;</span>
            <span class="s1">throttleWaitMilliseconds?: number;</span>
            <span class="s1">noGetErrOnBackgroundUpdate?: boolean;</span>
            <span class="s1">globalPlugins?: readonly string[];</span>
            <span class="s1">pluginProbeLocations?: readonly string[];</span>
            <span class="s1">allowLocalPluginLoads?: boolean;</span>
            <span class="s1">typesMapLocation?: string;</span>
        <span class="s1">}</span>
        <span class="s2">class </span><span class="s1">Session&lt;TMessage = string&gt; </span><span class="s2">implements </span><span class="s1">EventSender {</span>
            <span class="s2">private </span><span class="s1">readonly gcTimer;</span>
            <span class="s2">protected </span><span class="s1">projectService: ProjectService;</span>
            <span class="s2">private </span><span class="s1">changeSeq;</span>
            <span class="s2">private </span><span class="s1">performanceData;</span>
            <span class="s2">private </span><span class="s1">currentRequestId;</span>
            <span class="s2">private </span><span class="s1">errorCheck;</span>
            <span class="s2">protected </span><span class="s1">host: ServerHost;</span>
            <span class="s2">private </span><span class="s1">readonly cancellationToken;</span>
            <span class="s2">protected </span><span class="s1">readonly typingsInstaller: ITypingsInstaller;</span>
            <span class="s2">protected </span><span class="s1">byteLength: (buf: string, encoding?: BufferEncoding) =&gt; number;</span>
            <span class="s2">private </span><span class="s1">hrtime;</span>
            <span class="s2">protected </span><span class="s1">logger: Logger;</span>
            <span class="s2">protected </span><span class="s1">canUseEvents: boolean;</span>
            <span class="s2">private </span><span class="s1">suppressDiagnosticEvents?;</span>
            <span class="s2">private </span><span class="s1">eventHandler;</span>
            <span class="s2">private </span><span class="s1">readonly noGetErrOnBackgroundUpdate?;</span>
            <span class="s1">constructor(opts: SessionOptions);</span>
            <span class="s2">private </span><span class="s1">sendRequestCompletedEvent;</span>
            <span class="s2">private </span><span class="s1">addPerformanceData;</span>
            <span class="s2">private </span><span class="s1">addDiagnosticsPerformanceData;</span>
            <span class="s2">private </span><span class="s1">performanceEventHandler;</span>
            <span class="s2">private </span><span class="s1">defaultEventHandler;</span>
            <span class="s2">private </span><span class="s1">projectsUpdatedInBackgroundEvent;</span>
            <span class="s1">logError(err: Error, cmd: string): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s2">private </span><span class="s1">logErrorWorker;</span>
            <span class="s1">send(msg: protocol.Message): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s2">protected </span><span class="s1">writeMessage(msg: protocol.Message): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s1">event&lt;T </span><span class="s2">extends </span><span class="s1">object&gt;(body: T, eventName: string): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s2">private </span><span class="s1">semanticCheck;</span>
            <span class="s2">private </span><span class="s1">syntacticCheck;</span>
            <span class="s2">private </span><span class="s1">suggestionCheck;</span>
            <span class="s2">private </span><span class="s1">regionSemanticCheck;</span>
            <span class="s2">private </span><span class="s1">sendDiagnosticsEvent;</span>
            <span class="s2">private </span><span class="s1">updateErrorCheck;</span>
            <span class="s2">private </span><span class="s1">cleanProjects;</span>
            <span class="s2">private </span><span class="s1">cleanup;</span>
            <span class="s2">private </span><span class="s1">getEncodedSyntacticClassifications;</span>
            <span class="s2">private </span><span class="s1">getEncodedSemanticClassifications;</span>
            <span class="s2">private </span><span class="s1">getProject;</span>
            <span class="s2">private </span><span class="s1">getConfigFileAndProject;</span>
            <span class="s2">private </span><span class="s1">getConfigFileDiagnostics;</span>
            <span class="s2">private </span><span class="s1">convertToDiagnosticsWithLinePositionFromDiagnosticFile;</span>
            <span class="s2">private </span><span class="s1">getCompilerOptionsDiagnostics;</span>
            <span class="s2">private </span><span class="s1">convertToDiagnosticsWithLinePosition;</span>
            <span class="s2">private </span><span class="s1">getDiagnosticsWorker;</span>
            <span class="s2">private </span><span class="s1">getDefinition;</span>
            <span class="s2">private </span><span class="s1">mapDefinitionInfoLocations;</span>
            <span class="s2">private </span><span class="s1">getDefinitionAndBoundSpan;</span>
            <span class="s2">private </span><span class="s1">findSourceDefinition;</span>
            <span class="s2">private </span><span class="s1">getEmitOutput;</span>
            <span class="s2">private </span><span class="s1">mapJSDocTagInfo;</span>
            <span class="s2">private </span><span class="s1">mapDisplayParts;</span>
            <span class="s2">private </span><span class="s1">mapSignatureHelpItems;</span>
            <span class="s2">private </span><span class="s1">mapDefinitionInfo;</span>
            <span class="s2">private static </span><span class="s1">mapToOriginalLocation;</span>
            <span class="s2">private </span><span class="s1">toFileSpan;</span>
            <span class="s2">private </span><span class="s1">toFileSpanWithContext;</span>
            <span class="s2">private </span><span class="s1">getTypeDefinition;</span>
            <span class="s2">private </span><span class="s1">mapImplementationLocations;</span>
            <span class="s2">private </span><span class="s1">getImplementation;</span>
            <span class="s2">private </span><span class="s1">getSyntacticDiagnosticsSync;</span>
            <span class="s2">private </span><span class="s1">getSemanticDiagnosticsSync;</span>
            <span class="s2">private </span><span class="s1">getSuggestionDiagnosticsSync;</span>
            <span class="s2">private </span><span class="s1">getJsxClosingTag;</span>
            <span class="s2">private </span><span class="s1">getLinkedEditingRange;</span>
            <span class="s2">private </span><span class="s1">getDocumentHighlights;</span>
            <span class="s2">private </span><span class="s1">provideInlayHints;</span>
            <span class="s2">private </span><span class="s1">mapCode;</span>
            <span class="s2">private </span><span class="s1">getCopilotRelatedInfo;</span>
            <span class="s2">private </span><span class="s1">setCompilerOptionsForInferredProjects;</span>
            <span class="s2">private </span><span class="s1">getProjectInfo;</span>
            <span class="s2">private </span><span class="s1">getProjectInfoWorker;</span>
            <span class="s2">private </span><span class="s1">getDefaultConfiguredProjectInfo;</span>
            <span class="s2">private </span><span class="s1">getRenameInfo;</span>
            <span class="s2">private </span><span class="s1">getProjects;</span>
            <span class="s2">private </span><span class="s1">getDefaultProject;</span>
            <span class="s2">private </span><span class="s1">getRenameLocations;</span>
            <span class="s2">private </span><span class="s1">mapRenameInfo;</span>
            <span class="s2">private </span><span class="s1">toSpanGroups;</span>
            <span class="s2">private </span><span class="s1">getReferences;</span>
            <span class="s2">private </span><span class="s1">getFileReferences;</span>
            <span class="s2">private </span><span class="s1">openClientFile;</span>
            <span class="s2">private </span><span class="s1">getPosition;</span>
            <span class="s2">private </span><span class="s1">getPositionInFile;</span>
            <span class="s2">private </span><span class="s1">getFileAndProject;</span>
            <span class="s2">private </span><span class="s1">getFileAndLanguageServiceForSyntacticOperation;</span>
            <span class="s2">private </span><span class="s1">getFileAndProjectWorker;</span>
            <span class="s2">private </span><span class="s1">getOutliningSpans;</span>
            <span class="s2">private </span><span class="s1">getTodoComments;</span>
            <span class="s2">private </span><span class="s1">getDocCommentTemplate;</span>
            <span class="s2">private </span><span class="s1">getSpanOfEnclosingComment;</span>
            <span class="s2">private </span><span class="s1">getIndentation;</span>
            <span class="s2">private </span><span class="s1">getBreakpointStatement;</span>
            <span class="s2">private </span><span class="s1">getNameOrDottedNameSpan;</span>
            <span class="s2">private </span><span class="s1">isValidBraceCompletion;</span>
            <span class="s2">private </span><span class="s1">getQuickInfoWorker;</span>
            <span class="s2">private </span><span class="s1">getFormattingEditsForRange;</span>
            <span class="s2">private </span><span class="s1">getFormattingEditsForRangeFull;</span>
            <span class="s2">private </span><span class="s1">getFormattingEditsForDocumentFull;</span>
            <span class="s2">private </span><span class="s1">getFormattingEditsAfterKeystrokeFull;</span>
            <span class="s2">private </span><span class="s1">getFormattingEditsAfterKeystroke;</span>
            <span class="s2">private </span><span class="s1">getCompletions;</span>
            <span class="s2">private </span><span class="s1">getCompletionEntryDetails;</span>
            <span class="s2">private </span><span class="s1">getCompileOnSaveAffectedFileList;</span>
            <span class="s2">private </span><span class="s1">emitFile;</span>
            <span class="s2">private </span><span class="s1">getSignatureHelpItems;</span>
            <span class="s2">private </span><span class="s1">toPendingErrorCheck;</span>
            <span class="s2">private </span><span class="s1">getDiagnostics;</span>
            <span class="s2">private </span><span class="s1">change;</span>
            <span class="s2">private </span><span class="s1">reload;</span>
            <span class="s2">private </span><span class="s1">saveToTmp;</span>
            <span class="s2">private </span><span class="s1">closeClientFile;</span>
            <span class="s2">private </span><span class="s1">mapLocationNavigationBarItems;</span>
            <span class="s2">private </span><span class="s1">getNavigationBarItems;</span>
            <span class="s2">private </span><span class="s1">toLocationNavigationTree;</span>
            <span class="s2">private </span><span class="s1">getNavigationTree;</span>
            <span class="s2">private </span><span class="s1">getNavigateToItems;</span>
            <span class="s2">private </span><span class="s1">getFullNavigateToItems;</span>
            <span class="s2">private </span><span class="s1">getSupportedCodeFixes;</span>
            <span class="s2">private </span><span class="s1">isLocation;</span>
            <span class="s2">private </span><span class="s1">extractPositionOrRange;</span>
            <span class="s2">private </span><span class="s1">getRange;</span>
            <span class="s2">private </span><span class="s1">getApplicableRefactors;</span>
            <span class="s2">private </span><span class="s1">getEditsForRefactor;</span>
            <span class="s2">private </span><span class="s1">getMoveToRefactoringFileSuggestions;</span>
            <span class="s2">private </span><span class="s1">preparePasteEdits;</span>
            <span class="s2">private </span><span class="s1">getPasteEdits;</span>
            <span class="s2">private </span><span class="s1">organizeImports;</span>
            <span class="s2">private </span><span class="s1">getEditsForFileRename;</span>
            <span class="s2">private </span><span class="s1">getCodeFixes;</span>
            <span class="s2">private </span><span class="s1">getCombinedCodeFix;</span>
            <span class="s2">private </span><span class="s1">applyCodeActionCommand;</span>
            <span class="s2">private </span><span class="s1">getStartAndEndPosition;</span>
            <span class="s2">private </span><span class="s1">mapCodeAction;</span>
            <span class="s2">private </span><span class="s1">mapCodeFixAction;</span>
            <span class="s2">private </span><span class="s1">mapPasteEditsAction;</span>
            <span class="s2">private </span><span class="s1">mapTextChangesToCodeEdits;</span>
            <span class="s2">private </span><span class="s1">mapTextChangeToCodeEdit;</span>
            <span class="s2">private </span><span class="s1">convertTextChangeToCodeEdit;</span>
            <span class="s2">private </span><span class="s1">getBraceMatching;</span>
            <span class="s2">private </span><span class="s1">getDiagnosticsForProject;</span>
            <span class="s2">private </span><span class="s1">configurePlugin;</span>
            <span class="s2">private </span><span class="s1">getSmartSelectionRange;</span>
            <span class="s2">private </span><span class="s1">toggleLineComment;</span>
            <span class="s2">private </span><span class="s1">toggleMultilineComment;</span>
            <span class="s2">private </span><span class="s1">commentSelection;</span>
            <span class="s2">private </span><span class="s1">uncommentSelection;</span>
            <span class="s2">private </span><span class="s1">mapSelectionRange;</span>
            <span class="s2">private </span><span class="s1">getScriptInfoFromProjectService;</span>
            <span class="s2">private </span><span class="s1">toProtocolCallHierarchyItem;</span>
            <span class="s2">private </span><span class="s1">toProtocolCallHierarchyIncomingCall;</span>
            <span class="s2">private </span><span class="s1">toProtocolCallHierarchyOutgoingCall;</span>
            <span class="s2">private </span><span class="s1">prepareCallHierarchy;</span>
            <span class="s2">private </span><span class="s1">provideCallHierarchyIncomingCalls;</span>
            <span class="s2">private </span><span class="s1">provideCallHierarchyOutgoingCalls;</span>
            <span class="s1">getCanonicalFileName(fileName: string): string;</span>
            <span class="s1">exit(): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s2">private </span><span class="s1">notRequired;</span>
            <span class="s2">private </span><span class="s1">requiredResponse;</span>
            <span class="s2">private </span><span class="s1">handlers;</span>
            <span class="s1">addProtocolHandler(command: string, handler: (request: protocol.Request) =&gt; HandlerResponse): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s2">private </span><span class="s1">setCurrentRequest;</span>
            <span class="s2">private </span><span class="s1">resetCurrentRequest;</span>
            <span class="s1">executeWithRequestId&lt;T&gt;(requestId: number, f: () =&gt; T): T;</span>
            <span class="s1">executeCommand(request: protocol.Request): HandlerResponse;</span>
            <span class="s1">onMessage(message: TMessage): </span><span class="s2">void</span><span class="s1">;</span>
            <span class="s2">protected </span><span class="s1">parseMessage(message: TMessage): protocol.Request;</span>
            <span class="s2">protected </span><span class="s1">toStringMessage(message: TMessage): string;</span>
            <span class="s2">private </span><span class="s1">getFormatOptions;</span>
            <span class="s2">private </span><span class="s1">getPreferences;</span>
            <span class="s2">private </span><span class="s1">getHostFormatOptions;</span>
            <span class="s2">private </span><span class="s1">getHostPreferences;</span>
        <span class="s1">}</span>
        <span class="s2">interface </span><span class="s1">HandlerResponse {</span>
            <span class="s1">response?: {};</span>
            <span class="s1">responseRequired?: boolean;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">namespace JsTyping {</span>
        <span class="s2">interface </span><span class="s1">TypingResolutionHost {</span>
            <span class="s1">directoryExists(path: string): boolean;</span>
            <span class="s1">fileExists(fileName: string): boolean;</span>
            <span class="s1">readFile(path: string, encoding?: string): string | undefined;</span>
            <span class="s1">readDirectory(rootDir: string, extensions: readonly string[], excludes: readonly string[] | undefined, includes: readonly string[] | undefined, depth?: number): string[];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">versionMajorMinor = </span><span class="s3">&quot;5.9&quot;</span><span class="s1">;</span>
    <span class="s0">/** The version of the TypeScript compiler release */</span>
    <span class="s2">const </span><span class="s1">version: string;</span>
    <span class="s0">/**</span>
     <span class="s0">* Type of objects whose values are all of the same type.</span>
     <span class="s0">* The `in` and `for-in` operators can *not* be safely used,</span>
     <span class="s0">* since `Object.prototype` may be modified by outside code.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">MapLike&lt;T&gt; {</span>
        <span class="s1">[index: string]: T;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SortedReadonlyArray&lt;T&gt; </span><span class="s2">extends </span><span class="s1">ReadonlyArray&lt;T&gt; {</span>
        <span class="s3">&quot; __sortedArrayBrand&quot;</span><span class="s1">: any;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SortedArray&lt;T&gt; </span><span class="s2">extends </span><span class="s1">Array&lt;T&gt; {</span>
        <span class="s3">&quot; __sortedArrayBrand&quot;</span><span class="s1">: any;</span>
    <span class="s1">}</span>
    <span class="s1">type Path = string &amp; {</span>
        <span class="s1">__pathBrand: any;</span>
    <span class="s1">};</span>
    <span class="s2">interface </span><span class="s1">TextRange {</span>
        <span class="s1">pos: number;</span>
        <span class="s1">end: number;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ReadonlyTextRange {</span>
        <span class="s1">readonly pos: number;</span>
        <span class="s1">readonly end: number;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">SyntaxKind {</span>
        <span class="s1">Unknown = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">EndOfFileToken = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">SingleLineCommentTrivia = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">MultiLineCommentTrivia = </span><span class="s5">3</span><span class="s1">,</span>
        <span class="s1">NewLineTrivia = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">WhitespaceTrivia = </span><span class="s5">5</span><span class="s1">,</span>
        <span class="s1">ShebangTrivia = </span><span class="s5">6</span><span class="s1">,</span>
        <span class="s1">ConflictMarkerTrivia = </span><span class="s5">7</span><span class="s1">,</span>
        <span class="s1">NonTextFileMarkerTrivia = </span><span class="s5">8</span><span class="s1">,</span>
        <span class="s1">NumericLiteral = </span><span class="s5">9</span><span class="s1">,</span>
        <span class="s1">BigIntLiteral = </span><span class="s5">10</span><span class="s1">,</span>
        <span class="s1">StringLiteral = </span><span class="s5">11</span><span class="s1">,</span>
        <span class="s1">JsxText = </span><span class="s5">12</span><span class="s1">,</span>
        <span class="s1">JsxTextAllWhiteSpaces = </span><span class="s5">13</span><span class="s1">,</span>
        <span class="s1">RegularExpressionLiteral = </span><span class="s5">14</span><span class="s1">,</span>
        <span class="s1">NoSubstitutionTemplateLiteral = </span><span class="s5">15</span><span class="s1">,</span>
        <span class="s1">TemplateHead = </span><span class="s5">16</span><span class="s1">,</span>
        <span class="s1">TemplateMiddle = </span><span class="s5">17</span><span class="s1">,</span>
        <span class="s1">TemplateTail = </span><span class="s5">18</span><span class="s1">,</span>
        <span class="s1">OpenBraceToken = </span><span class="s5">19</span><span class="s1">,</span>
        <span class="s1">CloseBraceToken = </span><span class="s5">20</span><span class="s1">,</span>
        <span class="s1">OpenParenToken = </span><span class="s5">21</span><span class="s1">,</span>
        <span class="s1">CloseParenToken = </span><span class="s5">22</span><span class="s1">,</span>
        <span class="s1">OpenBracketToken = </span><span class="s5">23</span><span class="s1">,</span>
        <span class="s1">CloseBracketToken = </span><span class="s5">24</span><span class="s1">,</span>
        <span class="s1">DotToken = </span><span class="s5">25</span><span class="s1">,</span>
        <span class="s1">DotDotDotToken = </span><span class="s5">26</span><span class="s1">,</span>
        <span class="s1">SemicolonToken = </span><span class="s5">27</span><span class="s1">,</span>
        <span class="s1">CommaToken = </span><span class="s5">28</span><span class="s1">,</span>
        <span class="s1">QuestionDotToken = </span><span class="s5">29</span><span class="s1">,</span>
        <span class="s1">LessThanToken = </span><span class="s5">30</span><span class="s1">,</span>
        <span class="s1">LessThanSlashToken = </span><span class="s5">31</span><span class="s1">,</span>
        <span class="s1">GreaterThanToken = </span><span class="s5">32</span><span class="s1">,</span>
        <span class="s1">LessThanEqualsToken = </span><span class="s5">33</span><span class="s1">,</span>
        <span class="s1">GreaterThanEqualsToken = </span><span class="s5">34</span><span class="s1">,</span>
        <span class="s1">EqualsEqualsToken = </span><span class="s5">35</span><span class="s1">,</span>
        <span class="s1">ExclamationEqualsToken = </span><span class="s5">36</span><span class="s1">,</span>
        <span class="s1">EqualsEqualsEqualsToken = </span><span class="s5">37</span><span class="s1">,</span>
        <span class="s1">ExclamationEqualsEqualsToken = </span><span class="s5">38</span><span class="s1">,</span>
        <span class="s1">EqualsGreaterThanToken = </span><span class="s5">39</span><span class="s1">,</span>
        <span class="s1">PlusToken = </span><span class="s5">40</span><span class="s1">,</span>
        <span class="s1">MinusToken = </span><span class="s5">41</span><span class="s1">,</span>
        <span class="s1">AsteriskToken = </span><span class="s5">42</span><span class="s1">,</span>
        <span class="s1">AsteriskAsteriskToken = </span><span class="s5">43</span><span class="s1">,</span>
        <span class="s1">SlashToken = </span><span class="s5">44</span><span class="s1">,</span>
        <span class="s1">PercentToken = </span><span class="s5">45</span><span class="s1">,</span>
        <span class="s1">PlusPlusToken = </span><span class="s5">46</span><span class="s1">,</span>
        <span class="s1">MinusMinusToken = </span><span class="s5">47</span><span class="s1">,</span>
        <span class="s1">LessThanLessThanToken = </span><span class="s5">48</span><span class="s1">,</span>
        <span class="s1">GreaterThanGreaterThanToken = </span><span class="s5">49</span><span class="s1">,</span>
        <span class="s1">GreaterThanGreaterThanGreaterThanToken = </span><span class="s5">50</span><span class="s1">,</span>
        <span class="s1">AmpersandToken = </span><span class="s5">51</span><span class="s1">,</span>
        <span class="s1">BarToken = </span><span class="s5">52</span><span class="s1">,</span>
        <span class="s1">CaretToken = </span><span class="s5">53</span><span class="s1">,</span>
        <span class="s1">ExclamationToken = </span><span class="s5">54</span><span class="s1">,</span>
        <span class="s1">TildeToken = </span><span class="s5">55</span><span class="s1">,</span>
        <span class="s1">AmpersandAmpersandToken = </span><span class="s5">56</span><span class="s1">,</span>
        <span class="s1">BarBarToken = </span><span class="s5">57</span><span class="s1">,</span>
        <span class="s1">QuestionToken = </span><span class="s5">58</span><span class="s1">,</span>
        <span class="s1">ColonToken = </span><span class="s5">59</span><span class="s1">,</span>
        <span class="s1">AtToken = </span><span class="s5">60</span><span class="s1">,</span>
        <span class="s1">QuestionQuestionToken = </span><span class="s5">61</span><span class="s1">,</span>
        <span class="s0">/** Only the JSDoc scanner produces BacktickToken. The normal scanner produces NoSubstitutionTemplateLiteral and related kinds. */</span>
        <span class="s1">BacktickToken = </span><span class="s5">62</span><span class="s1">,</span>
        <span class="s0">/** Only the JSDoc scanner produces HashToken. The normal scanner produces PrivateIdentifier. */</span>
        <span class="s1">HashToken = </span><span class="s5">63</span><span class="s1">,</span>
        <span class="s1">EqualsToken = </span><span class="s5">64</span><span class="s1">,</span>
        <span class="s1">PlusEqualsToken = </span><span class="s5">65</span><span class="s1">,</span>
        <span class="s1">MinusEqualsToken = </span><span class="s5">66</span><span class="s1">,</span>
        <span class="s1">AsteriskEqualsToken = </span><span class="s5">67</span><span class="s1">,</span>
        <span class="s1">AsteriskAsteriskEqualsToken = </span><span class="s5">68</span><span class="s1">,</span>
        <span class="s1">SlashEqualsToken = </span><span class="s5">69</span><span class="s1">,</span>
        <span class="s1">PercentEqualsToken = </span><span class="s5">70</span><span class="s1">,</span>
        <span class="s1">LessThanLessThanEqualsToken = </span><span class="s5">71</span><span class="s1">,</span>
        <span class="s1">GreaterThanGreaterThanEqualsToken = </span><span class="s5">72</span><span class="s1">,</span>
        <span class="s1">GreaterThanGreaterThanGreaterThanEqualsToken = </span><span class="s5">73</span><span class="s1">,</span>
        <span class="s1">AmpersandEqualsToken = </span><span class="s5">74</span><span class="s1">,</span>
        <span class="s1">BarEqualsToken = </span><span class="s5">75</span><span class="s1">,</span>
        <span class="s1">BarBarEqualsToken = </span><span class="s5">76</span><span class="s1">,</span>
        <span class="s1">AmpersandAmpersandEqualsToken = </span><span class="s5">77</span><span class="s1">,</span>
        <span class="s1">QuestionQuestionEqualsToken = </span><span class="s5">78</span><span class="s1">,</span>
        <span class="s1">CaretEqualsToken = </span><span class="s5">79</span><span class="s1">,</span>
        <span class="s1">Identifier = </span><span class="s5">80</span><span class="s1">,</span>
        <span class="s1">PrivateIdentifier = </span><span class="s5">81</span><span class="s1">,</span>
        <span class="s1">BreakKeyword = </span><span class="s5">83</span><span class="s1">,</span>
        <span class="s1">CaseKeyword = </span><span class="s5">84</span><span class="s1">,</span>
        <span class="s1">CatchKeyword = </span><span class="s5">85</span><span class="s1">,</span>
        <span class="s1">ClassKeyword = </span><span class="s5">86</span><span class="s1">,</span>
        <span class="s1">ConstKeyword = </span><span class="s5">87</span><span class="s1">,</span>
        <span class="s1">ContinueKeyword = </span><span class="s5">88</span><span class="s1">,</span>
        <span class="s1">DebuggerKeyword = </span><span class="s5">89</span><span class="s1">,</span>
        <span class="s1">DefaultKeyword = </span><span class="s5">90</span><span class="s1">,</span>
        <span class="s1">DeleteKeyword = </span><span class="s5">91</span><span class="s1">,</span>
        <span class="s1">DoKeyword = </span><span class="s5">92</span><span class="s1">,</span>
        <span class="s1">ElseKeyword = </span><span class="s5">93</span><span class="s1">,</span>
        <span class="s1">EnumKeyword = </span><span class="s5">94</span><span class="s1">,</span>
        <span class="s1">ExportKeyword = </span><span class="s5">95</span><span class="s1">,</span>
        <span class="s1">ExtendsKeyword = </span><span class="s5">96</span><span class="s1">,</span>
        <span class="s1">FalseKeyword = </span><span class="s5">97</span><span class="s1">,</span>
        <span class="s1">FinallyKeyword = </span><span class="s5">98</span><span class="s1">,</span>
        <span class="s1">ForKeyword = </span><span class="s5">99</span><span class="s1">,</span>
        <span class="s1">FunctionKeyword = </span><span class="s5">100</span><span class="s1">,</span>
        <span class="s1">IfKeyword = </span><span class="s5">101</span><span class="s1">,</span>
        <span class="s1">ImportKeyword = </span><span class="s5">102</span><span class="s1">,</span>
        <span class="s1">InKeyword = </span><span class="s5">103</span><span class="s1">,</span>
        <span class="s1">InstanceOfKeyword = </span><span class="s5">104</span><span class="s1">,</span>
        <span class="s1">NewKeyword = </span><span class="s5">105</span><span class="s1">,</span>
        <span class="s1">NullKeyword = </span><span class="s5">106</span><span class="s1">,</span>
        <span class="s1">ReturnKeyword = </span><span class="s5">107</span><span class="s1">,</span>
        <span class="s1">SuperKeyword = </span><span class="s5">108</span><span class="s1">,</span>
        <span class="s1">SwitchKeyword = </span><span class="s5">109</span><span class="s1">,</span>
        <span class="s1">ThisKeyword = </span><span class="s5">110</span><span class="s1">,</span>
        <span class="s1">ThrowKeyword = </span><span class="s5">111</span><span class="s1">,</span>
        <span class="s1">TrueKeyword = </span><span class="s5">112</span><span class="s1">,</span>
        <span class="s1">TryKeyword = </span><span class="s5">113</span><span class="s1">,</span>
        <span class="s1">TypeOfKeyword = </span><span class="s5">114</span><span class="s1">,</span>
        <span class="s1">VarKeyword = </span><span class="s5">115</span><span class="s1">,</span>
        <span class="s1">VoidKeyword = </span><span class="s5">116</span><span class="s1">,</span>
        <span class="s1">WhileKeyword = </span><span class="s5">117</span><span class="s1">,</span>
        <span class="s1">WithKeyword = </span><span class="s5">118</span><span class="s1">,</span>
        <span class="s1">ImplementsKeyword = </span><span class="s5">119</span><span class="s1">,</span>
        <span class="s1">InterfaceKeyword = </span><span class="s5">120</span><span class="s1">,</span>
        <span class="s1">LetKeyword = </span><span class="s5">121</span><span class="s1">,</span>
        <span class="s1">PackageKeyword = </span><span class="s5">122</span><span class="s1">,</span>
        <span class="s1">PrivateKeyword = </span><span class="s5">123</span><span class="s1">,</span>
        <span class="s1">ProtectedKeyword = </span><span class="s5">124</span><span class="s1">,</span>
        <span class="s1">PublicKeyword = </span><span class="s5">125</span><span class="s1">,</span>
        <span class="s1">StaticKeyword = </span><span class="s5">126</span><span class="s1">,</span>
        <span class="s1">YieldKeyword = </span><span class="s5">127</span><span class="s1">,</span>
        <span class="s1">AbstractKeyword = </span><span class="s5">128</span><span class="s1">,</span>
        <span class="s1">AccessorKeyword = </span><span class="s5">129</span><span class="s1">,</span>
        <span class="s1">AsKeyword = </span><span class="s5">130</span><span class="s1">,</span>
        <span class="s1">AssertsKeyword = </span><span class="s5">131</span><span class="s1">,</span>
        <span class="s1">AssertKeyword = </span><span class="s5">132</span><span class="s1">,</span>
        <span class="s1">AnyKeyword = </span><span class="s5">133</span><span class="s1">,</span>
        <span class="s1">AsyncKeyword = </span><span class="s5">134</span><span class="s1">,</span>
        <span class="s1">AwaitKeyword = </span><span class="s5">135</span><span class="s1">,</span>
        <span class="s1">BooleanKeyword = </span><span class="s5">136</span><span class="s1">,</span>
        <span class="s1">ConstructorKeyword = </span><span class="s5">137</span><span class="s1">,</span>
        <span class="s1">DeclareKeyword = </span><span class="s5">138</span><span class="s1">,</span>
        <span class="s1">GetKeyword = </span><span class="s5">139</span><span class="s1">,</span>
        <span class="s1">InferKeyword = </span><span class="s5">140</span><span class="s1">,</span>
        <span class="s1">IntrinsicKeyword = </span><span class="s5">141</span><span class="s1">,</span>
        <span class="s1">IsKeyword = </span><span class="s5">142</span><span class="s1">,</span>
        <span class="s1">KeyOfKeyword = </span><span class="s5">143</span><span class="s1">,</span>
        <span class="s1">ModuleKeyword = </span><span class="s5">144</span><span class="s1">,</span>
        <span class="s1">NamespaceKeyword = </span><span class="s5">145</span><span class="s1">,</span>
        <span class="s1">NeverKeyword = </span><span class="s5">146</span><span class="s1">,</span>
        <span class="s1">OutKeyword = </span><span class="s5">147</span><span class="s1">,</span>
        <span class="s1">ReadonlyKeyword = </span><span class="s5">148</span><span class="s1">,</span>
        <span class="s1">RequireKeyword = </span><span class="s5">149</span><span class="s1">,</span>
        <span class="s1">NumberKeyword = </span><span class="s5">150</span><span class="s1">,</span>
        <span class="s1">ObjectKeyword = </span><span class="s5">151</span><span class="s1">,</span>
        <span class="s1">SatisfiesKeyword = </span><span class="s5">152</span><span class="s1">,</span>
        <span class="s1">SetKeyword = </span><span class="s5">153</span><span class="s1">,</span>
        <span class="s1">StringKeyword = </span><span class="s5">154</span><span class="s1">,</span>
        <span class="s1">SymbolKeyword = </span><span class="s5">155</span><span class="s1">,</span>
        <span class="s1">TypeKeyword = </span><span class="s5">156</span><span class="s1">,</span>
        <span class="s1">UndefinedKeyword = </span><span class="s5">157</span><span class="s1">,</span>
        <span class="s1">UniqueKeyword = </span><span class="s5">158</span><span class="s1">,</span>
        <span class="s1">UnknownKeyword = </span><span class="s5">159</span><span class="s1">,</span>
        <span class="s1">UsingKeyword = </span><span class="s5">160</span><span class="s1">,</span>
        <span class="s1">FromKeyword = </span><span class="s5">161</span><span class="s1">,</span>
        <span class="s1">GlobalKeyword = </span><span class="s5">162</span><span class="s1">,</span>
        <span class="s1">BigIntKeyword = </span><span class="s5">163</span><span class="s1">,</span>
        <span class="s1">OverrideKeyword = </span><span class="s5">164</span><span class="s1">,</span>
        <span class="s1">OfKeyword = </span><span class="s5">165</span><span class="s1">,</span>
        <span class="s1">DeferKeyword = </span><span class="s5">166</span><span class="s1">,</span>
        <span class="s1">QualifiedName = </span><span class="s5">167</span><span class="s1">,</span>
        <span class="s1">ComputedPropertyName = </span><span class="s5">168</span><span class="s1">,</span>
        <span class="s1">TypeParameter = </span><span class="s5">169</span><span class="s1">,</span>
        <span class="s1">Parameter = </span><span class="s5">170</span><span class="s1">,</span>
        <span class="s1">Decorator = </span><span class="s5">171</span><span class="s1">,</span>
        <span class="s1">PropertySignature = </span><span class="s5">172</span><span class="s1">,</span>
        <span class="s1">PropertyDeclaration = </span><span class="s5">173</span><span class="s1">,</span>
        <span class="s1">MethodSignature = </span><span class="s5">174</span><span class="s1">,</span>
        <span class="s1">MethodDeclaration = </span><span class="s5">175</span><span class="s1">,</span>
        <span class="s1">ClassStaticBlockDeclaration = </span><span class="s5">176</span><span class="s1">,</span>
        <span class="s1">Constructor = </span><span class="s5">177</span><span class="s1">,</span>
        <span class="s1">GetAccessor = </span><span class="s5">178</span><span class="s1">,</span>
        <span class="s1">SetAccessor = </span><span class="s5">179</span><span class="s1">,</span>
        <span class="s1">CallSignature = </span><span class="s5">180</span><span class="s1">,</span>
        <span class="s1">ConstructSignature = </span><span class="s5">181</span><span class="s1">,</span>
        <span class="s1">IndexSignature = </span><span class="s5">182</span><span class="s1">,</span>
        <span class="s1">TypePredicate = </span><span class="s5">183</span><span class="s1">,</span>
        <span class="s1">TypeReference = </span><span class="s5">184</span><span class="s1">,</span>
        <span class="s1">FunctionType = </span><span class="s5">185</span><span class="s1">,</span>
        <span class="s1">ConstructorType = </span><span class="s5">186</span><span class="s1">,</span>
        <span class="s1">TypeQuery = </span><span class="s5">187</span><span class="s1">,</span>
        <span class="s1">TypeLiteral = </span><span class="s5">188</span><span class="s1">,</span>
        <span class="s1">ArrayType = </span><span class="s5">189</span><span class="s1">,</span>
        <span class="s1">TupleType = </span><span class="s5">190</span><span class="s1">,</span>
        <span class="s1">OptionalType = </span><span class="s5">191</span><span class="s1">,</span>
        <span class="s1">RestType = </span><span class="s5">192</span><span class="s1">,</span>
        <span class="s1">UnionType = </span><span class="s5">193</span><span class="s1">,</span>
        <span class="s1">IntersectionType = </span><span class="s5">194</span><span class="s1">,</span>
        <span class="s1">ConditionalType = </span><span class="s5">195</span><span class="s1">,</span>
        <span class="s1">InferType = </span><span class="s5">196</span><span class="s1">,</span>
        <span class="s1">ParenthesizedType = </span><span class="s5">197</span><span class="s1">,</span>
        <span class="s1">ThisType = </span><span class="s5">198</span><span class="s1">,</span>
        <span class="s1">TypeOperator = </span><span class="s5">199</span><span class="s1">,</span>
        <span class="s1">IndexedAccessType = </span><span class="s5">200</span><span class="s1">,</span>
        <span class="s1">MappedType = </span><span class="s5">201</span><span class="s1">,</span>
        <span class="s1">LiteralType = </span><span class="s5">202</span><span class="s1">,</span>
        <span class="s1">NamedTupleMember = </span><span class="s5">203</span><span class="s1">,</span>
        <span class="s1">TemplateLiteralType = </span><span class="s5">204</span><span class="s1">,</span>
        <span class="s1">TemplateLiteralTypeSpan = </span><span class="s5">205</span><span class="s1">,</span>
        <span class="s1">ImportType = </span><span class="s5">206</span><span class="s1">,</span>
        <span class="s1">ObjectBindingPattern = </span><span class="s5">207</span><span class="s1">,</span>
        <span class="s1">ArrayBindingPattern = </span><span class="s5">208</span><span class="s1">,</span>
        <span class="s1">BindingElement = </span><span class="s5">209</span><span class="s1">,</span>
        <span class="s1">ArrayLiteralExpression = </span><span class="s5">210</span><span class="s1">,</span>
        <span class="s1">ObjectLiteralExpression = </span><span class="s5">211</span><span class="s1">,</span>
        <span class="s1">PropertyAccessExpression = </span><span class="s5">212</span><span class="s1">,</span>
        <span class="s1">ElementAccessExpression = </span><span class="s5">213</span><span class="s1">,</span>
        <span class="s1">CallExpression = </span><span class="s5">214</span><span class="s1">,</span>
        <span class="s1">NewExpression = </span><span class="s5">215</span><span class="s1">,</span>
        <span class="s1">TaggedTemplateExpression = </span><span class="s5">216</span><span class="s1">,</span>
        <span class="s1">TypeAssertionExpression = </span><span class="s5">217</span><span class="s1">,</span>
        <span class="s1">ParenthesizedExpression = </span><span class="s5">218</span><span class="s1">,</span>
        <span class="s1">FunctionExpression = </span><span class="s5">219</span><span class="s1">,</span>
        <span class="s1">ArrowFunction = </span><span class="s5">220</span><span class="s1">,</span>
        <span class="s1">DeleteExpression = </span><span class="s5">221</span><span class="s1">,</span>
        <span class="s1">TypeOfExpression = </span><span class="s5">222</span><span class="s1">,</span>
        <span class="s1">VoidExpression = </span><span class="s5">223</span><span class="s1">,</span>
        <span class="s1">AwaitExpression = </span><span class="s5">224</span><span class="s1">,</span>
        <span class="s1">PrefixUnaryExpression = </span><span class="s5">225</span><span class="s1">,</span>
        <span class="s1">PostfixUnaryExpression = </span><span class="s5">226</span><span class="s1">,</span>
        <span class="s1">BinaryExpression = </span><span class="s5">227</span><span class="s1">,</span>
        <span class="s1">ConditionalExpression = </span><span class="s5">228</span><span class="s1">,</span>
        <span class="s1">TemplateExpression = </span><span class="s5">229</span><span class="s1">,</span>
        <span class="s1">YieldExpression = </span><span class="s5">230</span><span class="s1">,</span>
        <span class="s1">SpreadElement = </span><span class="s5">231</span><span class="s1">,</span>
        <span class="s1">ClassExpression = </span><span class="s5">232</span><span class="s1">,</span>
        <span class="s1">OmittedExpression = </span><span class="s5">233</span><span class="s1">,</span>
        <span class="s1">ExpressionWithTypeArguments = </span><span class="s5">234</span><span class="s1">,</span>
        <span class="s1">AsExpression = </span><span class="s5">235</span><span class="s1">,</span>
        <span class="s1">NonNullExpression = </span><span class="s5">236</span><span class="s1">,</span>
        <span class="s1">MetaProperty = </span><span class="s5">237</span><span class="s1">,</span>
        <span class="s1">SyntheticExpression = </span><span class="s5">238</span><span class="s1">,</span>
        <span class="s1">SatisfiesExpression = </span><span class="s5">239</span><span class="s1">,</span>
        <span class="s1">TemplateSpan = </span><span class="s5">240</span><span class="s1">,</span>
        <span class="s1">SemicolonClassElement = </span><span class="s5">241</span><span class="s1">,</span>
        <span class="s1">Block = </span><span class="s5">242</span><span class="s1">,</span>
        <span class="s1">EmptyStatement = </span><span class="s5">243</span><span class="s1">,</span>
        <span class="s1">VariableStatement = </span><span class="s5">244</span><span class="s1">,</span>
        <span class="s1">ExpressionStatement = </span><span class="s5">245</span><span class="s1">,</span>
        <span class="s1">IfStatement = </span><span class="s5">246</span><span class="s1">,</span>
        <span class="s1">DoStatement = </span><span class="s5">247</span><span class="s1">,</span>
        <span class="s1">WhileStatement = </span><span class="s5">248</span><span class="s1">,</span>
        <span class="s1">ForStatement = </span><span class="s5">249</span><span class="s1">,</span>
        <span class="s1">ForInStatement = </span><span class="s5">250</span><span class="s1">,</span>
        <span class="s1">ForOfStatement = </span><span class="s5">251</span><span class="s1">,</span>
        <span class="s1">ContinueStatement = </span><span class="s5">252</span><span class="s1">,</span>
        <span class="s1">BreakStatement = </span><span class="s5">253</span><span class="s1">,</span>
        <span class="s1">ReturnStatement = </span><span class="s5">254</span><span class="s1">,</span>
        <span class="s1">WithStatement = </span><span class="s5">255</span><span class="s1">,</span>
        <span class="s1">SwitchStatement = </span><span class="s5">256</span><span class="s1">,</span>
        <span class="s1">LabeledStatement = </span><span class="s5">257</span><span class="s1">,</span>
        <span class="s1">ThrowStatement = </span><span class="s5">258</span><span class="s1">,</span>
        <span class="s1">TryStatement = </span><span class="s5">259</span><span class="s1">,</span>
        <span class="s1">DebuggerStatement = </span><span class="s5">260</span><span class="s1">,</span>
        <span class="s1">VariableDeclaration = </span><span class="s5">261</span><span class="s1">,</span>
        <span class="s1">VariableDeclarationList = </span><span class="s5">262</span><span class="s1">,</span>
        <span class="s1">FunctionDeclaration = </span><span class="s5">263</span><span class="s1">,</span>
        <span class="s1">ClassDeclaration = </span><span class="s5">264</span><span class="s1">,</span>
        <span class="s1">InterfaceDeclaration = </span><span class="s5">265</span><span class="s1">,</span>
        <span class="s1">TypeAliasDeclaration = </span><span class="s5">266</span><span class="s1">,</span>
        <span class="s1">EnumDeclaration = </span><span class="s5">267</span><span class="s1">,</span>
        <span class="s1">ModuleDeclaration = </span><span class="s5">268</span><span class="s1">,</span>
        <span class="s1">ModuleBlock = </span><span class="s5">269</span><span class="s1">,</span>
        <span class="s1">CaseBlock = </span><span class="s5">270</span><span class="s1">,</span>
        <span class="s1">NamespaceExportDeclaration = </span><span class="s5">271</span><span class="s1">,</span>
        <span class="s1">ImportEqualsDeclaration = </span><span class="s5">272</span><span class="s1">,</span>
        <span class="s1">ImportDeclaration = </span><span class="s5">273</span><span class="s1">,</span>
        <span class="s1">ImportClause = </span><span class="s5">274</span><span class="s1">,</span>
        <span class="s1">NamespaceImport = </span><span class="s5">275</span><span class="s1">,</span>
        <span class="s1">NamedImports = </span><span class="s5">276</span><span class="s1">,</span>
        <span class="s1">ImportSpecifier = </span><span class="s5">277</span><span class="s1">,</span>
        <span class="s1">ExportAssignment = </span><span class="s5">278</span><span class="s1">,</span>
        <span class="s1">ExportDeclaration = </span><span class="s5">279</span><span class="s1">,</span>
        <span class="s1">NamedExports = </span><span class="s5">280</span><span class="s1">,</span>
        <span class="s1">NamespaceExport = </span><span class="s5">281</span><span class="s1">,</span>
        <span class="s1">ExportSpecifier = </span><span class="s5">282</span><span class="s1">,</span>
        <span class="s1">MissingDeclaration = </span><span class="s5">283</span><span class="s1">,</span>
        <span class="s1">ExternalModuleReference = </span><span class="s5">284</span><span class="s1">,</span>
        <span class="s1">JsxElement = </span><span class="s5">285</span><span class="s1">,</span>
        <span class="s1">JsxSelfClosingElement = </span><span class="s5">286</span><span class="s1">,</span>
        <span class="s1">JsxOpeningElement = </span><span class="s5">287</span><span class="s1">,</span>
        <span class="s1">JsxClosingElement = </span><span class="s5">288</span><span class="s1">,</span>
        <span class="s1">JsxFragment = </span><span class="s5">289</span><span class="s1">,</span>
        <span class="s1">JsxOpeningFragment = </span><span class="s5">290</span><span class="s1">,</span>
        <span class="s1">JsxClosingFragment = </span><span class="s5">291</span><span class="s1">,</span>
        <span class="s1">JsxAttribute = </span><span class="s5">292</span><span class="s1">,</span>
        <span class="s1">JsxAttributes = </span><span class="s5">293</span><span class="s1">,</span>
        <span class="s1">JsxSpreadAttribute = </span><span class="s5">294</span><span class="s1">,</span>
        <span class="s1">JsxExpression = </span><span class="s5">295</span><span class="s1">,</span>
        <span class="s1">JsxNamespacedName = </span><span class="s5">296</span><span class="s1">,</span>
        <span class="s1">CaseClause = </span><span class="s5">297</span><span class="s1">,</span>
        <span class="s1">DefaultClause = </span><span class="s5">298</span><span class="s1">,</span>
        <span class="s1">HeritageClause = </span><span class="s5">299</span><span class="s1">,</span>
        <span class="s1">CatchClause = </span><span class="s5">300</span><span class="s1">,</span>
        <span class="s1">ImportAttributes = </span><span class="s5">301</span><span class="s1">,</span>
        <span class="s1">ImportAttribute = </span><span class="s5">302</span><span class="s1">,</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/ </span><span class="s1">AssertClause = </span><span class="s5">301</span><span class="s1">,</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/ </span><span class="s1">AssertEntry = </span><span class="s5">302</span><span class="s1">,</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/ </span><span class="s1">ImportTypeAssertionContainer = </span><span class="s5">303</span><span class="s1">,</span>
        <span class="s1">PropertyAssignment = </span><span class="s5">304</span><span class="s1">,</span>
        <span class="s1">ShorthandPropertyAssignment = </span><span class="s5">305</span><span class="s1">,</span>
        <span class="s1">SpreadAssignment = </span><span class="s5">306</span><span class="s1">,</span>
        <span class="s1">EnumMember = </span><span class="s5">307</span><span class="s1">,</span>
        <span class="s1">SourceFile = </span><span class="s5">308</span><span class="s1">,</span>
        <span class="s1">Bundle = </span><span class="s5">309</span><span class="s1">,</span>
        <span class="s1">JSDocTypeExpression = </span><span class="s5">310</span><span class="s1">,</span>
        <span class="s1">JSDocNameReference = </span><span class="s5">311</span><span class="s1">,</span>
        <span class="s1">JSDocMemberName = </span><span class="s5">312</span><span class="s1">,</span>
        <span class="s1">JSDocAllType = </span><span class="s5">313</span><span class="s1">,</span>
        <span class="s1">JSDocUnknownType = </span><span class="s5">314</span><span class="s1">,</span>
        <span class="s1">JSDocNullableType = </span><span class="s5">315</span><span class="s1">,</span>
        <span class="s1">JSDocNonNullableType = </span><span class="s5">316</span><span class="s1">,</span>
        <span class="s1">JSDocOptionalType = </span><span class="s5">317</span><span class="s1">,</span>
        <span class="s1">JSDocFunctionType = </span><span class="s5">318</span><span class="s1">,</span>
        <span class="s1">JSDocVariadicType = </span><span class="s5">319</span><span class="s1">,</span>
        <span class="s1">JSDocNamepathType = </span><span class="s5">320</span><span class="s1">,</span>
        <span class="s1">JSDoc = </span><span class="s5">321</span><span class="s1">,</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">Use SyntaxKind.JSDoc */</span>
        <span class="s1">JSDocComment = </span><span class="s5">321</span><span class="s1">,</span>
        <span class="s1">JSDocText = </span><span class="s5">322</span><span class="s1">,</span>
        <span class="s1">JSDocTypeLiteral = </span><span class="s5">323</span><span class="s1">,</span>
        <span class="s1">JSDocSignature = </span><span class="s5">324</span><span class="s1">,</span>
        <span class="s1">JSDocLink = </span><span class="s5">325</span><span class="s1">,</span>
        <span class="s1">JSDocLinkCode = </span><span class="s5">326</span><span class="s1">,</span>
        <span class="s1">JSDocLinkPlain = </span><span class="s5">327</span><span class="s1">,</span>
        <span class="s1">JSDocTag = </span><span class="s5">328</span><span class="s1">,</span>
        <span class="s1">JSDocAugmentsTag = </span><span class="s5">329</span><span class="s1">,</span>
        <span class="s1">JSDocImplementsTag = </span><span class="s5">330</span><span class="s1">,</span>
        <span class="s1">JSDocAuthorTag = </span><span class="s5">331</span><span class="s1">,</span>
        <span class="s1">JSDocDeprecatedTag = </span><span class="s5">332</span><span class="s1">,</span>
        <span class="s1">JSDocClassTag = </span><span class="s5">333</span><span class="s1">,</span>
        <span class="s1">JSDocPublicTag = </span><span class="s5">334</span><span class="s1">,</span>
        <span class="s1">JSDocPrivateTag = </span><span class="s5">335</span><span class="s1">,</span>
        <span class="s1">JSDocProtectedTag = </span><span class="s5">336</span><span class="s1">,</span>
        <span class="s1">JSDocReadonlyTag = </span><span class="s5">337</span><span class="s1">,</span>
        <span class="s1">JSDocOverrideTag = </span><span class="s5">338</span><span class="s1">,</span>
        <span class="s1">JSDocCallbackTag = </span><span class="s5">339</span><span class="s1">,</span>
        <span class="s1">JSDocOverloadTag = </span><span class="s5">340</span><span class="s1">,</span>
        <span class="s1">JSDocEnumTag = </span><span class="s5">341</span><span class="s1">,</span>
        <span class="s1">JSDocParameterTag = </span><span class="s5">342</span><span class="s1">,</span>
        <span class="s1">JSDocReturnTag = </span><span class="s5">343</span><span class="s1">,</span>
        <span class="s1">JSDocThisTag = </span><span class="s5">344</span><span class="s1">,</span>
        <span class="s1">JSDocTypeTag = </span><span class="s5">345</span><span class="s1">,</span>
        <span class="s1">JSDocTemplateTag = </span><span class="s5">346</span><span class="s1">,</span>
        <span class="s1">JSDocTypedefTag = </span><span class="s5">347</span><span class="s1">,</span>
        <span class="s1">JSDocSeeTag = </span><span class="s5">348</span><span class="s1">,</span>
        <span class="s1">JSDocPropertyTag = </span><span class="s5">349</span><span class="s1">,</span>
        <span class="s1">JSDocThrowsTag = </span><span class="s5">350</span><span class="s1">,</span>
        <span class="s1">JSDocSatisfiesTag = </span><span class="s5">351</span><span class="s1">,</span>
        <span class="s1">JSDocImportTag = </span><span class="s5">352</span><span class="s1">,</span>
        <span class="s1">SyntaxList = </span><span class="s5">353</span><span class="s1">,</span>
        <span class="s1">NotEmittedStatement = </span><span class="s5">354</span><span class="s1">,</span>
        <span class="s1">NotEmittedTypeElement = </span><span class="s5">355</span><span class="s1">,</span>
        <span class="s1">PartiallyEmittedExpression = </span><span class="s5">356</span><span class="s1">,</span>
        <span class="s1">CommaListExpression = </span><span class="s5">357</span><span class="s1">,</span>
        <span class="s1">SyntheticReferenceExpression = </span><span class="s5">358</span><span class="s1">,</span>
        <span class="s1">Count = </span><span class="s5">359</span><span class="s1">,</span>
        <span class="s1">FirstAssignment = </span><span class="s5">64</span><span class="s1">,</span>
        <span class="s1">LastAssignment = </span><span class="s5">79</span><span class="s1">,</span>
        <span class="s1">FirstCompoundAssignment = </span><span class="s5">65</span><span class="s1">,</span>
        <span class="s1">LastCompoundAssignment = </span><span class="s5">79</span><span class="s1">,</span>
        <span class="s1">FirstReservedWord = </span><span class="s5">83</span><span class="s1">,</span>
        <span class="s1">LastReservedWord = </span><span class="s5">118</span><span class="s1">,</span>
        <span class="s1">FirstKeyword = </span><span class="s5">83</span><span class="s1">,</span>
        <span class="s1">LastKeyword = </span><span class="s5">166</span><span class="s1">,</span>
        <span class="s1">FirstFutureReservedWord = </span><span class="s5">119</span><span class="s1">,</span>
        <span class="s1">LastFutureReservedWord = </span><span class="s5">127</span><span class="s1">,</span>
        <span class="s1">FirstTypeNode = </span><span class="s5">183</span><span class="s1">,</span>
        <span class="s1">LastTypeNode = </span><span class="s5">206</span><span class="s1">,</span>
        <span class="s1">FirstPunctuation = </span><span class="s5">19</span><span class="s1">,</span>
        <span class="s1">LastPunctuation = </span><span class="s5">79</span><span class="s1">,</span>
        <span class="s1">FirstToken = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">LastToken = </span><span class="s5">166</span><span class="s1">,</span>
        <span class="s1">FirstTriviaToken = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">LastTriviaToken = </span><span class="s5">7</span><span class="s1">,</span>
        <span class="s1">FirstLiteralToken = </span><span class="s5">9</span><span class="s1">,</span>
        <span class="s1">LastLiteralToken = </span><span class="s5">15</span><span class="s1">,</span>
        <span class="s1">FirstTemplateToken = </span><span class="s5">15</span><span class="s1">,</span>
        <span class="s1">LastTemplateToken = </span><span class="s5">18</span><span class="s1">,</span>
        <span class="s1">FirstBinaryOperator = </span><span class="s5">30</span><span class="s1">,</span>
        <span class="s1">LastBinaryOperator = </span><span class="s5">79</span><span class="s1">,</span>
        <span class="s1">FirstStatement = </span><span class="s5">244</span><span class="s1">,</span>
        <span class="s1">LastStatement = </span><span class="s5">260</span><span class="s1">,</span>
        <span class="s1">FirstNode = </span><span class="s5">167</span><span class="s1">,</span>
        <span class="s1">FirstJSDocNode = </span><span class="s5">310</span><span class="s1">,</span>
        <span class="s1">LastJSDocNode = </span><span class="s5">352</span><span class="s1">,</span>
        <span class="s1">FirstJSDocTagNode = </span><span class="s5">328</span><span class="s1">,</span>
        <span class="s1">LastJSDocTagNode = </span><span class="s5">352</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s1">type TriviaSyntaxKind = SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia | SyntaxKind.NewLineTrivia | SyntaxKind.WhitespaceTrivia | SyntaxKind.ShebangTrivia | SyntaxKind.ConflictMarkerTrivia;</span>
    <span class="s1">type LiteralSyntaxKind = SyntaxKind.NumericLiteral | SyntaxKind.BigIntLiteral | SyntaxKind.StringLiteral | SyntaxKind.JsxText | SyntaxKind.JsxTextAllWhiteSpaces | SyntaxKind.RegularExpressionLiteral | SyntaxKind.NoSubstitutionTemplateLiteral;</span>
    <span class="s1">type PseudoLiteralSyntaxKind = SyntaxKind.TemplateHead | SyntaxKind.TemplateMiddle | SyntaxKind.TemplateTail;</span>
    <span class="s1">type PunctuationSyntaxKind =</span>
        <span class="s1">| SyntaxKind.OpenBraceToken</span>
        <span class="s1">| SyntaxKind.CloseBraceToken</span>
        <span class="s1">| SyntaxKind.OpenParenToken</span>
        <span class="s1">| SyntaxKind.CloseParenToken</span>
        <span class="s1">| SyntaxKind.OpenBracketToken</span>
        <span class="s1">| SyntaxKind.CloseBracketToken</span>
        <span class="s1">| SyntaxKind.DotToken</span>
        <span class="s1">| SyntaxKind.DotDotDotToken</span>
        <span class="s1">| SyntaxKind.SemicolonToken</span>
        <span class="s1">| SyntaxKind.CommaToken</span>
        <span class="s1">| SyntaxKind.QuestionDotToken</span>
        <span class="s1">| SyntaxKind.LessThanToken</span>
        <span class="s1">| SyntaxKind.LessThanSlashToken</span>
        <span class="s1">| SyntaxKind.GreaterThanToken</span>
        <span class="s1">| SyntaxKind.LessThanEqualsToken</span>
        <span class="s1">| SyntaxKind.GreaterThanEqualsToken</span>
        <span class="s1">| SyntaxKind.EqualsEqualsToken</span>
        <span class="s1">| SyntaxKind.ExclamationEqualsToken</span>
        <span class="s1">| SyntaxKind.EqualsEqualsEqualsToken</span>
        <span class="s1">| SyntaxKind.ExclamationEqualsEqualsToken</span>
        <span class="s1">| SyntaxKind.EqualsGreaterThanToken</span>
        <span class="s1">| SyntaxKind.PlusToken</span>
        <span class="s1">| SyntaxKind.MinusToken</span>
        <span class="s1">| SyntaxKind.AsteriskToken</span>
        <span class="s1">| SyntaxKind.AsteriskAsteriskToken</span>
        <span class="s1">| SyntaxKind.SlashToken</span>
        <span class="s1">| SyntaxKind.PercentToken</span>
        <span class="s1">| SyntaxKind.PlusPlusToken</span>
        <span class="s1">| SyntaxKind.MinusMinusToken</span>
        <span class="s1">| SyntaxKind.LessThanLessThanToken</span>
        <span class="s1">| SyntaxKind.GreaterThanGreaterThanToken</span>
        <span class="s1">| SyntaxKind.GreaterThanGreaterThanGreaterThanToken</span>
        <span class="s1">| SyntaxKind.AmpersandToken</span>
        <span class="s1">| SyntaxKind.BarToken</span>
        <span class="s1">| SyntaxKind.CaretToken</span>
        <span class="s1">| SyntaxKind.ExclamationToken</span>
        <span class="s1">| SyntaxKind.TildeToken</span>
        <span class="s1">| SyntaxKind.AmpersandAmpersandToken</span>
        <span class="s1">| SyntaxKind.AmpersandAmpersandEqualsToken</span>
        <span class="s1">| SyntaxKind.BarBarToken</span>
        <span class="s1">| SyntaxKind.BarBarEqualsToken</span>
        <span class="s1">| SyntaxKind.QuestionQuestionToken</span>
        <span class="s1">| SyntaxKind.QuestionQuestionEqualsToken</span>
        <span class="s1">| SyntaxKind.QuestionToken</span>
        <span class="s1">| SyntaxKind.ColonToken</span>
        <span class="s1">| SyntaxKind.AtToken</span>
        <span class="s1">| SyntaxKind.BacktickToken</span>
        <span class="s1">| SyntaxKind.HashToken</span>
        <span class="s1">| SyntaxKind.EqualsToken</span>
        <span class="s1">| SyntaxKind.PlusEqualsToken</span>
        <span class="s1">| SyntaxKind.MinusEqualsToken</span>
        <span class="s1">| SyntaxKind.AsteriskEqualsToken</span>
        <span class="s1">| SyntaxKind.AsteriskAsteriskEqualsToken</span>
        <span class="s1">| SyntaxKind.SlashEqualsToken</span>
        <span class="s1">| SyntaxKind.PercentEqualsToken</span>
        <span class="s1">| SyntaxKind.LessThanLessThanEqualsToken</span>
        <span class="s1">| SyntaxKind.GreaterThanGreaterThanEqualsToken</span>
        <span class="s1">| SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken</span>
        <span class="s1">| SyntaxKind.AmpersandEqualsToken</span>
        <span class="s1">| SyntaxKind.BarEqualsToken</span>
        <span class="s1">| SyntaxKind.CaretEqualsToken;</span>
    <span class="s1">type KeywordSyntaxKind =</span>
        <span class="s1">| SyntaxKind.AbstractKeyword</span>
        <span class="s1">| SyntaxKind.AccessorKeyword</span>
        <span class="s1">| SyntaxKind.AnyKeyword</span>
        <span class="s1">| SyntaxKind.AsKeyword</span>
        <span class="s1">| SyntaxKind.AssertsKeyword</span>
        <span class="s1">| SyntaxKind.AssertKeyword</span>
        <span class="s1">| SyntaxKind.AsyncKeyword</span>
        <span class="s1">| SyntaxKind.AwaitKeyword</span>
        <span class="s1">| SyntaxKind.BigIntKeyword</span>
        <span class="s1">| SyntaxKind.BooleanKeyword</span>
        <span class="s1">| SyntaxKind.BreakKeyword</span>
        <span class="s1">| SyntaxKind.CaseKeyword</span>
        <span class="s1">| SyntaxKind.CatchKeyword</span>
        <span class="s1">| SyntaxKind.ClassKeyword</span>
        <span class="s1">| SyntaxKind.ConstKeyword</span>
        <span class="s1">| SyntaxKind.ConstructorKeyword</span>
        <span class="s1">| SyntaxKind.ContinueKeyword</span>
        <span class="s1">| SyntaxKind.DebuggerKeyword</span>
        <span class="s1">| SyntaxKind.DeclareKeyword</span>
        <span class="s1">| SyntaxKind.DefaultKeyword</span>
        <span class="s1">| SyntaxKind.DeferKeyword</span>
        <span class="s1">| SyntaxKind.DeleteKeyword</span>
        <span class="s1">| SyntaxKind.DoKeyword</span>
        <span class="s1">| SyntaxKind.ElseKeyword</span>
        <span class="s1">| SyntaxKind.EnumKeyword</span>
        <span class="s1">| SyntaxKind.ExportKeyword</span>
        <span class="s1">| SyntaxKind.ExtendsKeyword</span>
        <span class="s1">| SyntaxKind.FalseKeyword</span>
        <span class="s1">| SyntaxKind.FinallyKeyword</span>
        <span class="s1">| SyntaxKind.ForKeyword</span>
        <span class="s1">| SyntaxKind.FromKeyword</span>
        <span class="s1">| SyntaxKind.FunctionKeyword</span>
        <span class="s1">| SyntaxKind.GetKeyword</span>
        <span class="s1">| SyntaxKind.GlobalKeyword</span>
        <span class="s1">| SyntaxKind.IfKeyword</span>
        <span class="s1">| SyntaxKind.ImplementsKeyword</span>
        <span class="s1">| SyntaxKind.ImportKeyword</span>
        <span class="s1">| SyntaxKind.InferKeyword</span>
        <span class="s1">| SyntaxKind.InKeyword</span>
        <span class="s1">| SyntaxKind.InstanceOfKeyword</span>
        <span class="s1">| SyntaxKind.InterfaceKeyword</span>
        <span class="s1">| SyntaxKind.IntrinsicKeyword</span>
        <span class="s1">| SyntaxKind.IsKeyword</span>
        <span class="s1">| SyntaxKind.KeyOfKeyword</span>
        <span class="s1">| SyntaxKind.LetKeyword</span>
        <span class="s1">| SyntaxKind.ModuleKeyword</span>
        <span class="s1">| SyntaxKind.NamespaceKeyword</span>
        <span class="s1">| SyntaxKind.NeverKeyword</span>
        <span class="s1">| SyntaxKind.NewKeyword</span>
        <span class="s1">| SyntaxKind.NullKeyword</span>
        <span class="s1">| SyntaxKind.NumberKeyword</span>
        <span class="s1">| SyntaxKind.ObjectKeyword</span>
        <span class="s1">| SyntaxKind.OfKeyword</span>
        <span class="s1">| SyntaxKind.PackageKeyword</span>
        <span class="s1">| SyntaxKind.PrivateKeyword</span>
        <span class="s1">| SyntaxKind.ProtectedKeyword</span>
        <span class="s1">| SyntaxKind.PublicKeyword</span>
        <span class="s1">| SyntaxKind.ReadonlyKeyword</span>
        <span class="s1">| SyntaxKind.OutKeyword</span>
        <span class="s1">| SyntaxKind.OverrideKeyword</span>
        <span class="s1">| SyntaxKind.RequireKeyword</span>
        <span class="s1">| SyntaxKind.ReturnKeyword</span>
        <span class="s1">| SyntaxKind.SatisfiesKeyword</span>
        <span class="s1">| SyntaxKind.SetKeyword</span>
        <span class="s1">| SyntaxKind.StaticKeyword</span>
        <span class="s1">| SyntaxKind.StringKeyword</span>
        <span class="s1">| SyntaxKind.SuperKeyword</span>
        <span class="s1">| SyntaxKind.SwitchKeyword</span>
        <span class="s1">| SyntaxKind.SymbolKeyword</span>
        <span class="s1">| SyntaxKind.ThisKeyword</span>
        <span class="s1">| SyntaxKind.ThrowKeyword</span>
        <span class="s1">| SyntaxKind.TrueKeyword</span>
        <span class="s1">| SyntaxKind.TryKeyword</span>
        <span class="s1">| SyntaxKind.TypeKeyword</span>
        <span class="s1">| SyntaxKind.TypeOfKeyword</span>
        <span class="s1">| SyntaxKind.UndefinedKeyword</span>
        <span class="s1">| SyntaxKind.UniqueKeyword</span>
        <span class="s1">| SyntaxKind.UnknownKeyword</span>
        <span class="s1">| SyntaxKind.UsingKeyword</span>
        <span class="s1">| SyntaxKind.VarKeyword</span>
        <span class="s1">| SyntaxKind.VoidKeyword</span>
        <span class="s1">| SyntaxKind.WhileKeyword</span>
        <span class="s1">| SyntaxKind.WithKeyword</span>
        <span class="s1">| SyntaxKind.YieldKeyword;</span>
    <span class="s1">type ModifierSyntaxKind = SyntaxKind.AbstractKeyword | SyntaxKind.AccessorKeyword | SyntaxKind.AsyncKeyword | SyntaxKind.ConstKeyword | SyntaxKind.DeclareKeyword | SyntaxKind.DefaultKeyword | SyntaxKind.ExportKeyword | SyntaxKind.InKeyword | SyntaxKind.PrivateKeyword | SyntaxKind.ProtectedKeyword | SyntaxKind.PublicKeyword | SyntaxKind.ReadonlyKeyword | SyntaxKind.OutKeyword | SyntaxKind.OverrideKeyword | SyntaxKind.StaticKeyword;</span>
    <span class="s1">type KeywordTypeSyntaxKind = SyntaxKind.AnyKeyword | SyntaxKind.BigIntKeyword | SyntaxKind.BooleanKeyword | SyntaxKind.IntrinsicKeyword | SyntaxKind.NeverKeyword | SyntaxKind.NumberKeyword | SyntaxKind.ObjectKeyword | SyntaxKind.StringKeyword | SyntaxKind.SymbolKeyword | SyntaxKind.UndefinedKeyword | SyntaxKind.UnknownKeyword | SyntaxKind.VoidKeyword;</span>
    <span class="s1">type TokenSyntaxKind = SyntaxKind.Unknown | SyntaxKind.EndOfFileToken | TriviaSyntaxKind | LiteralSyntaxKind | PseudoLiteralSyntaxKind | PunctuationSyntaxKind | SyntaxKind.Identifier | KeywordSyntaxKind;</span>
    <span class="s1">type JsxTokenSyntaxKind = SyntaxKind.LessThanSlashToken | SyntaxKind.EndOfFileToken | SyntaxKind.ConflictMarkerTrivia | SyntaxKind.JsxText | SyntaxKind.JsxTextAllWhiteSpaces | SyntaxKind.OpenBraceToken | SyntaxKind.LessThanToken;</span>
    <span class="s1">type JSDocSyntaxKind = SyntaxKind.EndOfFileToken | SyntaxKind.WhitespaceTrivia | SyntaxKind.AtToken | SyntaxKind.NewLineTrivia | SyntaxKind.AsteriskToken | SyntaxKind.OpenBraceToken | SyntaxKind.CloseBraceToken | SyntaxKind.LessThanToken | SyntaxKind.GreaterThanToken | SyntaxKind.OpenBracketToken | SyntaxKind.CloseBracketToken | SyntaxKind.OpenParenToken | SyntaxKind.CloseParenToken | SyntaxKind.EqualsToken | SyntaxKind.CommaToken | SyntaxKind.DotToken | SyntaxKind.Identifier | SyntaxKind.BacktickToken | SyntaxKind.HashToken | SyntaxKind.Unknown | KeywordSyntaxKind;</span>
    <span class="s2">enum </span><span class="s1">NodeFlags {</span>
        <span class="s1">None = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">Let = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">Const = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">Using = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">AwaitUsing = </span><span class="s5">6</span><span class="s1">,</span>
        <span class="s1">NestedNamespace = </span><span class="s5">8</span><span class="s1">,</span>
        <span class="s1">Synthesized = </span><span class="s5">16</span><span class="s1">,</span>
        <span class="s1">Namespace = </span><span class="s5">32</span><span class="s1">,</span>
        <span class="s1">OptionalChain = </span><span class="s5">64</span><span class="s1">,</span>
        <span class="s1">ExportContext = </span><span class="s5">128</span><span class="s1">,</span>
        <span class="s1">ContainsThis = </span><span class="s5">256</span><span class="s1">,</span>
        <span class="s1">HasImplicitReturn = </span><span class="s5">512</span><span class="s1">,</span>
        <span class="s1">HasExplicitReturn = </span><span class="s5">1024</span><span class="s1">,</span>
        <span class="s1">GlobalAugmentation = </span><span class="s5">2048</span><span class="s1">,</span>
        <span class="s1">HasAsyncFunctions = </span><span class="s5">4096</span><span class="s1">,</span>
        <span class="s1">DisallowInContext = </span><span class="s5">8192</span><span class="s1">,</span>
        <span class="s1">YieldContext = </span><span class="s5">16384</span><span class="s1">,</span>
        <span class="s1">DecoratorContext = </span><span class="s5">32768</span><span class="s1">,</span>
        <span class="s1">AwaitContext = </span><span class="s5">65536</span><span class="s1">,</span>
        <span class="s1">DisallowConditionalTypesContext = </span><span class="s5">131072</span><span class="s1">,</span>
        <span class="s1">ThisNodeHasError = </span><span class="s5">262144</span><span class="s1">,</span>
        <span class="s1">JavaScriptFile = </span><span class="s5">524288</span><span class="s1">,</span>
        <span class="s1">ThisNodeOrAnySubNodesHasError = </span><span class="s5">1048576</span><span class="s1">,</span>
        <span class="s1">HasAggregatedChildData = </span><span class="s5">2097152</span><span class="s1">,</span>
        <span class="s1">JSDoc = </span><span class="s5">16777216</span><span class="s1">,</span>
        <span class="s1">JsonFile = </span><span class="s5">134217728</span><span class="s1">,</span>
        <span class="s1">BlockScoped = </span><span class="s5">7</span><span class="s1">,</span>
        <span class="s1">Constant = </span><span class="s5">6</span><span class="s1">,</span>
        <span class="s1">ReachabilityCheckFlags = </span><span class="s5">1536</span><span class="s1">,</span>
        <span class="s1">ReachabilityAndEmitFlags = </span><span class="s5">5632</span><span class="s1">,</span>
        <span class="s1">ContextFlags = </span><span class="s5">101441536</span><span class="s1">,</span>
        <span class="s1">TypeExcludesFlags = </span><span class="s5">81920</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">ModifierFlags {</span>
        <span class="s1">None = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">Public = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">Private = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">Protected = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">Readonly = </span><span class="s5">8</span><span class="s1">,</span>
        <span class="s1">Override = </span><span class="s5">16</span><span class="s1">,</span>
        <span class="s1">Export = </span><span class="s5">32</span><span class="s1">,</span>
        <span class="s1">Abstract = </span><span class="s5">64</span><span class="s1">,</span>
        <span class="s1">Ambient = </span><span class="s5">128</span><span class="s1">,</span>
        <span class="s1">Static = </span><span class="s5">256</span><span class="s1">,</span>
        <span class="s1">Accessor = </span><span class="s5">512</span><span class="s1">,</span>
        <span class="s1">Async = </span><span class="s5">1024</span><span class="s1">,</span>
        <span class="s1">Default = </span><span class="s5">2048</span><span class="s1">,</span>
        <span class="s1">Const = </span><span class="s5">4096</span><span class="s1">,</span>
        <span class="s1">In = </span><span class="s5">8192</span><span class="s1">,</span>
        <span class="s1">Out = </span><span class="s5">16384</span><span class="s1">,</span>
        <span class="s1">Decorator = </span><span class="s5">32768</span><span class="s1">,</span>
        <span class="s1">Deprecated = </span><span class="s5">65536</span><span class="s1">,</span>
        <span class="s1">HasComputedJSDocModifiers = </span><span class="s5">268435456</span><span class="s1">,</span>
        <span class="s1">HasComputedFlags = </span><span class="s5">536870912</span><span class="s1">,</span>
        <span class="s1">AccessibilityModifier = </span><span class="s5">7</span><span class="s1">,</span>
        <span class="s1">ParameterPropertyModifier = </span><span class="s5">31</span><span class="s1">,</span>
        <span class="s1">NonPublicAccessibilityModifier = </span><span class="s5">6</span><span class="s1">,</span>
        <span class="s1">TypeScriptModifier = </span><span class="s5">28895</span><span class="s1">,</span>
        <span class="s1">ExportDefault = </span><span class="s5">2080</span><span class="s1">,</span>
        <span class="s1">All = </span><span class="s5">131071</span><span class="s1">,</span>
        <span class="s1">Modifier = </span><span class="s5">98303</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">JsxFlags {</span>
        <span class="s1">None = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/** An element from a named property of the JSX.IntrinsicElements interface */</span>
        <span class="s1">IntrinsicNamedElement = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s0">/** An element inferred from the string index signature of the JSX.IntrinsicElements interface */</span>
        <span class="s1">IntrinsicIndexedElement = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">IntrinsicElement = </span><span class="s5">3</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">Node </span><span class="s2">extends </span><span class="s1">ReadonlyTextRange {</span>
        <span class="s1">readonly kind: SyntaxKind;</span>
        <span class="s1">readonly flags: NodeFlags;</span>
        <span class="s1">readonly parent: Node;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">Node {</span>
        <span class="s1">getSourceFile(): SourceFile;</span>
        <span class="s1">getChildCount(sourceFile?: SourceFile): number;</span>
        <span class="s1">getChildAt(index: number, sourceFile?: SourceFile): Node;</span>
        <span class="s1">getChildren(sourceFile?: SourceFile): readonly Node[];</span>
        <span class="s1">getStart(sourceFile?: SourceFile, includeJsDocComment?: boolean): number;</span>
        <span class="s1">getFullStart(): number;</span>
        <span class="s1">getEnd(): number;</span>
        <span class="s1">getWidth(sourceFile?: SourceFileLike): number;</span>
        <span class="s1">getFullWidth(): number;</span>
        <span class="s1">getLeadingTriviaWidth(sourceFile?: SourceFile): number;</span>
        <span class="s1">getFullText(sourceFile?: SourceFile): string;</span>
        <span class="s1">getText(sourceFile?: SourceFile): string;</span>
        <span class="s1">getFirstToken(sourceFile?: SourceFile): Node | undefined;</span>
        <span class="s1">getLastToken(sourceFile?: SourceFile): Node | undefined;</span>
        <span class="s1">forEachChild&lt;T&gt;(cbNode: (node: Node) =&gt; T | undefined, cbNodeArray?: (nodes: NodeArray&lt;Node&gt;) =&gt; T | undefined): T | undefined;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocContainer </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">_jsdocContainerBrand: any;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">LocalsContainer </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">_localsContainerBrand: any;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">FlowContainer </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">_flowContainerBrand: any;</span>
    <span class="s1">}</span>
    <span class="s1">type HasJSDoc =</span>
        <span class="s1">| AccessorDeclaration</span>
        <span class="s1">| ArrowFunction</span>
        <span class="s1">| BinaryExpression</span>
        <span class="s1">| Block</span>
        <span class="s1">| BreakStatement</span>
        <span class="s1">| CallSignatureDeclaration</span>
        <span class="s1">| CaseClause</span>
        <span class="s1">| ClassLikeDeclaration</span>
        <span class="s1">| ClassStaticBlockDeclaration</span>
        <span class="s1">| ConstructorDeclaration</span>
        <span class="s1">| ConstructorTypeNode</span>
        <span class="s1">| ConstructSignatureDeclaration</span>
        <span class="s1">| ContinueStatement</span>
        <span class="s1">| DebuggerStatement</span>
        <span class="s1">| DoStatement</span>
        <span class="s1">| ElementAccessExpression</span>
        <span class="s1">| EmptyStatement</span>
        <span class="s1">| EndOfFileToken</span>
        <span class="s1">| EnumDeclaration</span>
        <span class="s1">| EnumMember</span>
        <span class="s1">| ExportAssignment</span>
        <span class="s1">| ExportDeclaration</span>
        <span class="s1">| ExportSpecifier</span>
        <span class="s1">| ExpressionStatement</span>
        <span class="s1">| ForInStatement</span>
        <span class="s1">| ForOfStatement</span>
        <span class="s1">| ForStatement</span>
        <span class="s1">| FunctionDeclaration</span>
        <span class="s1">| FunctionExpression</span>
        <span class="s1">| FunctionTypeNode</span>
        <span class="s1">| Identifier</span>
        <span class="s1">| IfStatement</span>
        <span class="s1">| ImportDeclaration</span>
        <span class="s1">| ImportEqualsDeclaration</span>
        <span class="s1">| IndexSignatureDeclaration</span>
        <span class="s1">| InterfaceDeclaration</span>
        <span class="s1">| JSDocFunctionType</span>
        <span class="s1">| JSDocSignature</span>
        <span class="s1">| LabeledStatement</span>
        <span class="s1">| MethodDeclaration</span>
        <span class="s1">| MethodSignature</span>
        <span class="s1">| ModuleDeclaration</span>
        <span class="s1">| NamedTupleMember</span>
        <span class="s1">| NamespaceExportDeclaration</span>
        <span class="s1">| ObjectLiteralExpression</span>
        <span class="s1">| ParameterDeclaration</span>
        <span class="s1">| ParenthesizedExpression</span>
        <span class="s1">| PropertyAccessExpression</span>
        <span class="s1">| PropertyAssignment</span>
        <span class="s1">| PropertyDeclaration</span>
        <span class="s1">| PropertySignature</span>
        <span class="s1">| ReturnStatement</span>
        <span class="s1">| SemicolonClassElement</span>
        <span class="s1">| ShorthandPropertyAssignment</span>
        <span class="s1">| SpreadAssignment</span>
        <span class="s1">| SwitchStatement</span>
        <span class="s1">| ThrowStatement</span>
        <span class="s1">| TryStatement</span>
        <span class="s1">| TypeAliasDeclaration</span>
        <span class="s1">| TypeParameterDeclaration</span>
        <span class="s1">| VariableDeclaration</span>
        <span class="s1">| VariableStatement</span>
        <span class="s1">| WhileStatement</span>
        <span class="s1">| WithStatement;</span>
    <span class="s1">type HasType = SignatureDeclaration | VariableDeclaration | ParameterDeclaration | PropertySignature | PropertyDeclaration | TypePredicateNode | ParenthesizedTypeNode | TypeOperatorNode | MappedTypeNode | AssertionExpression | TypeAliasDeclaration | JSDocTypeExpression | JSDocNonNullableType | JSDocNullableType | JSDocOptionalType | JSDocVariadicType;</span>
    <span class="s1">type HasTypeArguments = CallExpression | NewExpression | TaggedTemplateExpression | JsxOpeningElement | JsxSelfClosingElement;</span>
    <span class="s1">type HasInitializer = HasExpressionInitializer | ForStatement | ForInStatement | ForOfStatement | JsxAttribute;</span>
    <span class="s1">type HasExpressionInitializer = VariableDeclaration | ParameterDeclaration | BindingElement | PropertyDeclaration | PropertyAssignment | EnumMember;</span>
    <span class="s1">type HasDecorators = ParameterDeclaration | PropertyDeclaration | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | ClassExpression | ClassDeclaration;</span>
    <span class="s1">type HasModifiers = TypeParameterDeclaration | ParameterDeclaration | ConstructorTypeNode | PropertySignature | PropertyDeclaration | MethodSignature | MethodDeclaration | ConstructorDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | IndexSignatureDeclaration | FunctionExpression | ArrowFunction | ClassExpression | VariableStatement | FunctionDeclaration | ClassDeclaration | InterfaceDeclaration | TypeAliasDeclaration | EnumDeclaration | ModuleDeclaration | ImportEqualsDeclaration | ImportDeclaration | ExportAssignment | ExportDeclaration;</span>
    <span class="s2">interface </span><span class="s1">NodeArray&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt; </span><span class="s2">extends </span><span class="s1">ReadonlyArray&lt;T&gt;, ReadonlyTextRange {</span>
        <span class="s1">readonly hasTrailingComma: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">Token&lt;TKind </span><span class="s2">extends </span><span class="s1">SyntaxKind&gt; </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly kind: TKind;</span>
    <span class="s1">}</span>
    <span class="s1">type EndOfFileToken = Token&lt;SyntaxKind.EndOfFileToken&gt; &amp; JSDocContainer;</span>
    <span class="s2">interface </span><span class="s1">PunctuationToken&lt;TKind </span><span class="s2">extends </span><span class="s1">PunctuationSyntaxKind&gt; </span><span class="s2">extends </span><span class="s1">Token&lt;TKind&gt; {</span>
    <span class="s1">}</span>
    <span class="s1">type DotToken = PunctuationToken&lt;SyntaxKind.DotToken&gt;;</span>
    <span class="s1">type DotDotDotToken = PunctuationToken&lt;SyntaxKind.DotDotDotToken&gt;;</span>
    <span class="s1">type QuestionToken = PunctuationToken&lt;SyntaxKind.QuestionToken&gt;;</span>
    <span class="s1">type ExclamationToken = PunctuationToken&lt;SyntaxKind.ExclamationToken&gt;;</span>
    <span class="s1">type ColonToken = PunctuationToken&lt;SyntaxKind.ColonToken&gt;;</span>
    <span class="s1">type EqualsToken = PunctuationToken&lt;SyntaxKind.EqualsToken&gt;;</span>
    <span class="s1">type AmpersandAmpersandEqualsToken = PunctuationToken&lt;SyntaxKind.AmpersandAmpersandEqualsToken&gt;;</span>
    <span class="s1">type BarBarEqualsToken = PunctuationToken&lt;SyntaxKind.BarBarEqualsToken&gt;;</span>
    <span class="s1">type QuestionQuestionEqualsToken = PunctuationToken&lt;SyntaxKind.QuestionQuestionEqualsToken&gt;;</span>
    <span class="s1">type AsteriskToken = PunctuationToken&lt;SyntaxKind.AsteriskToken&gt;;</span>
    <span class="s1">type EqualsGreaterThanToken = PunctuationToken&lt;SyntaxKind.EqualsGreaterThanToken&gt;;</span>
    <span class="s1">type PlusToken = PunctuationToken&lt;SyntaxKind.PlusToken&gt;;</span>
    <span class="s1">type MinusToken = PunctuationToken&lt;SyntaxKind.MinusToken&gt;;</span>
    <span class="s1">type QuestionDotToken = PunctuationToken&lt;SyntaxKind.QuestionDotToken&gt;;</span>
    <span class="s2">interface </span><span class="s1">KeywordToken&lt;TKind </span><span class="s2">extends </span><span class="s1">KeywordSyntaxKind&gt; </span><span class="s2">extends </span><span class="s1">Token&lt;TKind&gt; {</span>
    <span class="s1">}</span>
    <span class="s1">type AssertsKeyword = KeywordToken&lt;SyntaxKind.AssertsKeyword&gt;;</span>
    <span class="s1">type AssertKeyword = KeywordToken&lt;SyntaxKind.AssertKeyword&gt;;</span>
    <span class="s1">type AwaitKeyword = KeywordToken&lt;SyntaxKind.AwaitKeyword&gt;;</span>
    <span class="s1">type CaseKeyword = KeywordToken&lt;SyntaxKind.CaseKeyword&gt;;</span>
    <span class="s2">interface </span><span class="s1">ModifierToken&lt;TKind </span><span class="s2">extends </span><span class="s1">ModifierSyntaxKind&gt; </span><span class="s2">extends </span><span class="s1">KeywordToken&lt;TKind&gt; {</span>
    <span class="s1">}</span>
    <span class="s1">type AbstractKeyword = ModifierToken&lt;SyntaxKind.AbstractKeyword&gt;;</span>
    <span class="s1">type AccessorKeyword = ModifierToken&lt;SyntaxKind.AccessorKeyword&gt;;</span>
    <span class="s1">type AsyncKeyword = ModifierToken&lt;SyntaxKind.AsyncKeyword&gt;;</span>
    <span class="s1">type ConstKeyword = ModifierToken&lt;SyntaxKind.ConstKeyword&gt;;</span>
    <span class="s1">type DeclareKeyword = ModifierToken&lt;SyntaxKind.DeclareKeyword&gt;;</span>
    <span class="s1">type DefaultKeyword = ModifierToken&lt;SyntaxKind.DefaultKeyword&gt;;</span>
    <span class="s1">type ExportKeyword = ModifierToken&lt;SyntaxKind.ExportKeyword&gt;;</span>
    <span class="s1">type InKeyword = ModifierToken&lt;SyntaxKind.InKeyword&gt;;</span>
    <span class="s1">type PrivateKeyword = ModifierToken&lt;SyntaxKind.PrivateKeyword&gt;;</span>
    <span class="s1">type ProtectedKeyword = ModifierToken&lt;SyntaxKind.ProtectedKeyword&gt;;</span>
    <span class="s1">type PublicKeyword = ModifierToken&lt;SyntaxKind.PublicKeyword&gt;;</span>
    <span class="s1">type ReadonlyKeyword = ModifierToken&lt;SyntaxKind.ReadonlyKeyword&gt;;</span>
    <span class="s1">type OutKeyword = ModifierToken&lt;SyntaxKind.OutKeyword&gt;;</span>
    <span class="s1">type OverrideKeyword = ModifierToken&lt;SyntaxKind.OverrideKeyword&gt;;</span>
    <span class="s1">type StaticKeyword = ModifierToken&lt;SyntaxKind.StaticKeyword&gt;;</span>
    <span class="s1">type Modifier = AbstractKeyword | AccessorKeyword | AsyncKeyword | ConstKeyword | DeclareKeyword | DefaultKeyword | ExportKeyword | InKeyword | PrivateKeyword | ProtectedKeyword | PublicKeyword | OutKeyword | OverrideKeyword | ReadonlyKeyword | StaticKeyword;</span>
    <span class="s1">type ModifierLike = Modifier | Decorator;</span>
    <span class="s1">type AccessibilityModifier = PublicKeyword | PrivateKeyword | ProtectedKeyword;</span>
    <span class="s1">type ParameterPropertyModifier = AccessibilityModifier | ReadonlyKeyword;</span>
    <span class="s1">type ClassMemberModifier = AccessibilityModifier | ReadonlyKeyword | StaticKeyword | AccessorKeyword;</span>
    <span class="s1">type ModifiersArray = NodeArray&lt;Modifier&gt;;</span>
    <span class="s2">enum </span><span class="s1">GeneratedIdentifierFlags {</span>
        <span class="s1">None = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">ReservedInNestedScopes = </span><span class="s5">8</span><span class="s1">,</span>
        <span class="s1">Optimistic = </span><span class="s5">16</span><span class="s1">,</span>
        <span class="s1">FileLevel = </span><span class="s5">32</span><span class="s1">,</span>
        <span class="s1">AllowNameSubstitution = </span><span class="s5">64</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">Identifier </span><span class="s2">extends </span><span class="s1">PrimaryExpression, Declaration, JSDocContainer, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.Identifier;</span>
        <span class="s0">/**</span>
         <span class="s0">* Prefer to use `id.unescapedText`. (Note: This is available only in services, not internally to the TypeScript compiler.)</span>
         <span class="s0">* Text of identifier, but if the identifier begins with two underscores, this will begin with three.</span>
         <span class="s0">*/</span>
        <span class="s1">readonly escapedText: __String;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">Identifier {</span>
        <span class="s1">readonly text: string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TransientIdentifier </span><span class="s2">extends </span><span class="s1">Identifier {</span>
        <span class="s1">resolvedSymbol: Symbol;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">QualifiedName </span><span class="s2">extends </span><span class="s1">Node, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.QualifiedName;</span>
        <span class="s1">readonly left: EntityName;</span>
        <span class="s1">readonly right: Identifier;</span>
    <span class="s1">}</span>
    <span class="s1">type EntityName = Identifier | QualifiedName;</span>
    <span class="s1">type PropertyName = Identifier | StringLiteral | NoSubstitutionTemplateLiteral | NumericLiteral | ComputedPropertyName | PrivateIdentifier | BigIntLiteral;</span>
    <span class="s1">type MemberName = Identifier | PrivateIdentifier;</span>
    <span class="s1">type DeclarationName = PropertyName | JsxAttributeName | StringLiteralLike | ElementAccessExpression | BindingPattern | EntityNameExpression;</span>
    <span class="s2">interface </span><span class="s1">Declaration </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">_declarationBrand: any;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">NamedDeclaration </span><span class="s2">extends </span><span class="s1">Declaration {</span>
        <span class="s1">readonly name?: DeclarationName;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">DeclarationStatement </span><span class="s2">extends </span><span class="s1">NamedDeclaration, Statement {</span>
        <span class="s1">readonly name?: Identifier | StringLiteral | NumericLiteral;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ComputedPropertyName </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly kind: SyntaxKind.ComputedPropertyName;</span>
        <span class="s1">readonly parent: Declaration;</span>
        <span class="s1">readonly expression: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">PrivateIdentifier </span><span class="s2">extends </span><span class="s1">PrimaryExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.PrivateIdentifier;</span>
        <span class="s1">readonly escapedText: __String;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">PrivateIdentifier {</span>
        <span class="s1">readonly text: string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">Decorator </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly kind: SyntaxKind.Decorator;</span>
        <span class="s1">readonly parent: NamedDeclaration;</span>
        <span class="s1">readonly expression: LeftHandSideExpression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TypeParameterDeclaration </span><span class="s2">extends </span><span class="s1">NamedDeclaration, JSDocContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.TypeParameter;</span>
        <span class="s1">readonly parent: DeclarationWithTypeParameterChildren | InferTypeNode;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;Modifier&gt;;</span>
        <span class="s1">readonly name: Identifier;</span>
        <span class="s0">/** Note: Consider calling `getEffectiveConstraintOfTypeParameter` */</span>
        <span class="s1">readonly constraint?: TypeNode;</span>
        <span class="s1">readonly </span><span class="s2">default</span><span class="s1">?: TypeNode;</span>
        <span class="s1">expression?: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SignatureDeclarationBase </span><span class="s2">extends </span><span class="s1">NamedDeclaration, JSDocContainer {</span>
        <span class="s1">readonly kind: SignatureDeclaration[</span><span class="s3">&quot;kind&quot;</span><span class="s1">];</span>
        <span class="s1">readonly name?: PropertyName;</span>
        <span class="s1">readonly typeParameters?: NodeArray&lt;TypeParameterDeclaration&gt; | undefined;</span>
        <span class="s1">readonly parameters: NodeArray&lt;ParameterDeclaration&gt;;</span>
        <span class="s1">readonly type?: TypeNode | undefined;</span>
    <span class="s1">}</span>
    <span class="s1">type SignatureDeclaration = CallSignatureDeclaration | ConstructSignatureDeclaration | MethodSignature | IndexSignatureDeclaration | FunctionTypeNode | ConstructorTypeNode | JSDocFunctionType | FunctionDeclaration | MethodDeclaration | ConstructorDeclaration | AccessorDeclaration | FunctionExpression | ArrowFunction;</span>
    <span class="s2">interface </span><span class="s1">CallSignatureDeclaration </span><span class="s2">extends </span><span class="s1">SignatureDeclarationBase, TypeElement, LocalsContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.CallSignature;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ConstructSignatureDeclaration </span><span class="s2">extends </span><span class="s1">SignatureDeclarationBase, TypeElement, LocalsContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.ConstructSignature;</span>
    <span class="s1">}</span>
    <span class="s1">type BindingName = Identifier | BindingPattern;</span>
    <span class="s2">interface </span><span class="s1">VariableDeclaration </span><span class="s2">extends </span><span class="s1">NamedDeclaration, JSDocContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.VariableDeclaration;</span>
        <span class="s1">readonly parent: VariableDeclarationList | CatchClause;</span>
        <span class="s1">readonly name: BindingName;</span>
        <span class="s1">readonly exclamationToken?: ExclamationToken;</span>
        <span class="s1">readonly type?: TypeNode;</span>
        <span class="s1">readonly initializer?: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">VariableDeclarationList </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly kind: SyntaxKind.VariableDeclarationList;</span>
        <span class="s1">readonly parent: VariableStatement | ForStatement | ForOfStatement | ForInStatement;</span>
        <span class="s1">readonly declarations: NodeArray&lt;VariableDeclaration&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ParameterDeclaration </span><span class="s2">extends </span><span class="s1">NamedDeclaration, JSDocContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.Parameter;</span>
        <span class="s1">readonly parent: SignatureDeclaration;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;ModifierLike&gt;;</span>
        <span class="s1">readonly dotDotDotToken?: DotDotDotToken;</span>
        <span class="s1">readonly name: BindingName;</span>
        <span class="s1">readonly questionToken?: QuestionToken;</span>
        <span class="s1">readonly type?: TypeNode;</span>
        <span class="s1">readonly initializer?: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">BindingElement </span><span class="s2">extends </span><span class="s1">NamedDeclaration, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.BindingElement;</span>
        <span class="s1">readonly parent: BindingPattern;</span>
        <span class="s1">readonly propertyName?: PropertyName;</span>
        <span class="s1">readonly dotDotDotToken?: DotDotDotToken;</span>
        <span class="s1">readonly name: BindingName;</span>
        <span class="s1">readonly initializer?: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">PropertySignature </span><span class="s2">extends </span><span class="s1">TypeElement, JSDocContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.PropertySignature;</span>
        <span class="s1">readonly parent: TypeLiteralNode | InterfaceDeclaration;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;Modifier&gt;;</span>
        <span class="s1">readonly name: PropertyName;</span>
        <span class="s1">readonly questionToken?: QuestionToken;</span>
        <span class="s1">readonly type?: TypeNode;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">PropertyDeclaration </span><span class="s2">extends </span><span class="s1">ClassElement, JSDocContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.PropertyDeclaration;</span>
        <span class="s1">readonly parent: ClassLikeDeclaration;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;ModifierLike&gt;;</span>
        <span class="s1">readonly name: PropertyName;</span>
        <span class="s1">readonly questionToken?: QuestionToken;</span>
        <span class="s1">readonly exclamationToken?: ExclamationToken;</span>
        <span class="s1">readonly type?: TypeNode;</span>
        <span class="s1">readonly initializer?: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">AutoAccessorPropertyDeclaration </span><span class="s2">extends </span><span class="s1">PropertyDeclaration {</span>
        <span class="s1">_autoAccessorBrand: any;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ObjectLiteralElement </span><span class="s2">extends </span><span class="s1">NamedDeclaration {</span>
        <span class="s1">_objectLiteralBrand: any;</span>
        <span class="s1">readonly name?: PropertyName;</span>
    <span class="s1">}</span>
    <span class="s0">/** Unlike ObjectLiteralElement, excludes JSXAttribute and JSXSpreadAttribute. */</span>
    <span class="s1">type ObjectLiteralElementLike = PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment | MethodDeclaration | AccessorDeclaration;</span>
    <span class="s2">interface </span><span class="s1">PropertyAssignment </span><span class="s2">extends </span><span class="s1">ObjectLiteralElement, JSDocContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.PropertyAssignment;</span>
        <span class="s1">readonly parent: ObjectLiteralExpression;</span>
        <span class="s1">readonly name: PropertyName;</span>
        <span class="s1">readonly initializer: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ShorthandPropertyAssignment </span><span class="s2">extends </span><span class="s1">ObjectLiteralElement, JSDocContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.ShorthandPropertyAssignment;</span>
        <span class="s1">readonly parent: ObjectLiteralExpression;</span>
        <span class="s1">readonly name: Identifier;</span>
        <span class="s1">readonly equalsToken?: EqualsToken;</span>
        <span class="s1">readonly objectAssignmentInitializer?: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SpreadAssignment </span><span class="s2">extends </span><span class="s1">ObjectLiteralElement, JSDocContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.SpreadAssignment;</span>
        <span class="s1">readonly parent: ObjectLiteralExpression;</span>
        <span class="s1">readonly expression: Expression;</span>
    <span class="s1">}</span>
    <span class="s1">type VariableLikeDeclaration = VariableDeclaration | ParameterDeclaration | BindingElement | PropertyDeclaration | PropertyAssignment | PropertySignature | JsxAttribute | ShorthandPropertyAssignment | EnumMember | JSDocPropertyTag | JSDocParameterTag;</span>
    <span class="s2">interface </span><span class="s1">ObjectBindingPattern </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly kind: SyntaxKind.ObjectBindingPattern;</span>
        <span class="s1">readonly parent: VariableDeclaration | ParameterDeclaration | BindingElement;</span>
        <span class="s1">readonly elements: NodeArray&lt;BindingElement&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ArrayBindingPattern </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly kind: SyntaxKind.ArrayBindingPattern;</span>
        <span class="s1">readonly parent: VariableDeclaration | ParameterDeclaration | BindingElement;</span>
        <span class="s1">readonly elements: NodeArray&lt;ArrayBindingElement&gt;;</span>
    <span class="s1">}</span>
    <span class="s1">type BindingPattern = ObjectBindingPattern | ArrayBindingPattern;</span>
    <span class="s1">type ArrayBindingElement = BindingElement | OmittedExpression;</span>
    <span class="s0">/**</span>
     <span class="s0">* Several node kinds share function-like features such as a signature,</span>
     <span class="s0">* a name, and a body. These nodes should extend FunctionLikeDeclarationBase.</span>
     <span class="s0">* Examples:</span>
     <span class="s0">* - FunctionDeclaration</span>
     <span class="s0">* - MethodDeclaration</span>
     <span class="s0">* - AccessorDeclaration</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">FunctionLikeDeclarationBase </span><span class="s2">extends </span><span class="s1">SignatureDeclarationBase {</span>
        <span class="s1">_functionLikeDeclarationBrand: any;</span>
        <span class="s1">readonly asteriskToken?: AsteriskToken | undefined;</span>
        <span class="s1">readonly questionToken?: QuestionToken | undefined;</span>
        <span class="s1">readonly exclamationToken?: ExclamationToken | undefined;</span>
        <span class="s1">readonly body?: Block | Expression | undefined;</span>
    <span class="s1">}</span>
    <span class="s1">type FunctionLikeDeclaration = FunctionDeclaration | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | ConstructorDeclaration | FunctionExpression | ArrowFunction;</span>
    <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">Use SignatureDeclaration */</span>
    <span class="s1">type FunctionLike = SignatureDeclaration;</span>
    <span class="s2">interface </span><span class="s1">FunctionDeclaration </span><span class="s2">extends </span><span class="s1">FunctionLikeDeclarationBase, DeclarationStatement, LocalsContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.FunctionDeclaration;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;ModifierLike&gt;;</span>
        <span class="s1">readonly name?: Identifier;</span>
        <span class="s1">readonly body?: FunctionBody;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">MethodSignature </span><span class="s2">extends </span><span class="s1">SignatureDeclarationBase, TypeElement, LocalsContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.MethodSignature;</span>
        <span class="s1">readonly parent: TypeLiteralNode | InterfaceDeclaration;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;Modifier&gt;;</span>
        <span class="s1">readonly name: PropertyName;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">MethodDeclaration </span><span class="s2">extends </span><span class="s1">FunctionLikeDeclarationBase, ClassElement, ObjectLiteralElement, JSDocContainer, LocalsContainer, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.MethodDeclaration;</span>
        <span class="s1">readonly parent: ClassLikeDeclaration | ObjectLiteralExpression;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;ModifierLike&gt; | undefined;</span>
        <span class="s1">readonly name: PropertyName;</span>
        <span class="s1">readonly body?: FunctionBody | undefined;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ConstructorDeclaration </span><span class="s2">extends </span><span class="s1">FunctionLikeDeclarationBase, ClassElement, JSDocContainer, LocalsContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.Constructor;</span>
        <span class="s1">readonly parent: ClassLikeDeclaration;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;ModifierLike&gt; | undefined;</span>
        <span class="s1">readonly body?: FunctionBody | undefined;</span>
    <span class="s1">}</span>
    <span class="s0">/** For when we encounter a semicolon in a class declaration. ES6 allows these as class elements. */</span>
    <span class="s2">interface </span><span class="s1">SemicolonClassElement </span><span class="s2">extends </span><span class="s1">ClassElement, JSDocContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.SemicolonClassElement;</span>
        <span class="s1">readonly parent: ClassLikeDeclaration;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">GetAccessorDeclaration </span><span class="s2">extends </span><span class="s1">FunctionLikeDeclarationBase, ClassElement, TypeElement, ObjectLiteralElement, JSDocContainer, LocalsContainer, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.GetAccessor;</span>
        <span class="s1">readonly parent: ClassLikeDeclaration | ObjectLiteralExpression | TypeLiteralNode | InterfaceDeclaration;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;ModifierLike&gt;;</span>
        <span class="s1">readonly name: PropertyName;</span>
        <span class="s1">readonly body?: FunctionBody;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SetAccessorDeclaration </span><span class="s2">extends </span><span class="s1">FunctionLikeDeclarationBase, ClassElement, TypeElement, ObjectLiteralElement, JSDocContainer, LocalsContainer, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.SetAccessor;</span>
        <span class="s1">readonly parent: ClassLikeDeclaration | ObjectLiteralExpression | TypeLiteralNode | InterfaceDeclaration;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;ModifierLike&gt;;</span>
        <span class="s1">readonly name: PropertyName;</span>
        <span class="s1">readonly body?: FunctionBody;</span>
    <span class="s1">}</span>
    <span class="s1">type AccessorDeclaration = GetAccessorDeclaration | SetAccessorDeclaration;</span>
    <span class="s2">interface </span><span class="s1">IndexSignatureDeclaration </span><span class="s2">extends </span><span class="s1">SignatureDeclarationBase, ClassElement, TypeElement, LocalsContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.IndexSignature;</span>
        <span class="s1">readonly parent: ObjectTypeDeclaration;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;ModifierLike&gt;;</span>
        <span class="s1">readonly type: TypeNode;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ClassStaticBlockDeclaration </span><span class="s2">extends </span><span class="s1">ClassElement, JSDocContainer, LocalsContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.ClassStaticBlockDeclaration;</span>
        <span class="s1">readonly parent: ClassDeclaration | ClassExpression;</span>
        <span class="s1">readonly body: Block;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TypeNode </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">_typeNodeBrand: any;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">KeywordTypeNode&lt;TKind </span><span class="s2">extends </span><span class="s1">KeywordTypeSyntaxKind = KeywordTypeSyntaxKind&gt; </span><span class="s2">extends </span><span class="s1">KeywordToken&lt;TKind&gt;, TypeNode {</span>
        <span class="s1">readonly kind: TKind;</span>
    <span class="s1">}</span>
    <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">ImportTypeAssertionContainer </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly kind: SyntaxKind.ImportTypeAssertionContainer;</span>
        <span class="s1">readonly parent: ImportTypeNode;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/ </span><span class="s1">readonly assertClause: AssertClause;</span>
        <span class="s1">readonly multiLine?: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ImportTypeNode </span><span class="s2">extends </span><span class="s1">NodeWithTypeArguments {</span>
        <span class="s1">readonly kind: SyntaxKind.ImportType;</span>
        <span class="s1">readonly isTypeOf: boolean;</span>
        <span class="s1">readonly argument: TypeNode;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/ </span><span class="s1">readonly assertions?: ImportTypeAssertionContainer;</span>
        <span class="s1">readonly attributes?: ImportAttributes;</span>
        <span class="s1">readonly qualifier?: EntityName;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ThisTypeNode </span><span class="s2">extends </span><span class="s1">TypeNode {</span>
        <span class="s1">readonly kind: SyntaxKind.ThisType;</span>
    <span class="s1">}</span>
    <span class="s1">type FunctionOrConstructorTypeNode = FunctionTypeNode | ConstructorTypeNode;</span>
    <span class="s2">interface </span><span class="s1">FunctionOrConstructorTypeNodeBase </span><span class="s2">extends </span><span class="s1">TypeNode, SignatureDeclarationBase {</span>
        <span class="s1">readonly kind: SyntaxKind.FunctionType | SyntaxKind.ConstructorType;</span>
        <span class="s1">readonly type: TypeNode;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">FunctionTypeNode </span><span class="s2">extends </span><span class="s1">FunctionOrConstructorTypeNodeBase, LocalsContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.FunctionType;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ConstructorTypeNode </span><span class="s2">extends </span><span class="s1">FunctionOrConstructorTypeNodeBase, LocalsContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.ConstructorType;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;Modifier&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">NodeWithTypeArguments </span><span class="s2">extends </span><span class="s1">TypeNode {</span>
        <span class="s1">readonly typeArguments?: NodeArray&lt;TypeNode&gt;;</span>
    <span class="s1">}</span>
    <span class="s1">type TypeReferenceType = TypeReferenceNode | ExpressionWithTypeArguments;</span>
    <span class="s2">interface </span><span class="s1">TypeReferenceNode </span><span class="s2">extends </span><span class="s1">NodeWithTypeArguments {</span>
        <span class="s1">readonly kind: SyntaxKind.TypeReference;</span>
        <span class="s1">readonly typeName: EntityName;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TypePredicateNode </span><span class="s2">extends </span><span class="s1">TypeNode {</span>
        <span class="s1">readonly kind: SyntaxKind.TypePredicate;</span>
        <span class="s1">readonly parent: SignatureDeclaration | JSDocTypeExpression;</span>
        <span class="s1">readonly assertsModifier?: AssertsKeyword;</span>
        <span class="s1">readonly parameterName: Identifier | ThisTypeNode;</span>
        <span class="s1">readonly type?: TypeNode;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TypeQueryNode </span><span class="s2">extends </span><span class="s1">NodeWithTypeArguments {</span>
        <span class="s1">readonly kind: SyntaxKind.TypeQuery;</span>
        <span class="s1">readonly exprName: EntityName;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TypeLiteralNode </span><span class="s2">extends </span><span class="s1">TypeNode, Declaration {</span>
        <span class="s1">readonly kind: SyntaxKind.TypeLiteral;</span>
        <span class="s1">readonly members: NodeArray&lt;TypeElement&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ArrayTypeNode </span><span class="s2">extends </span><span class="s1">TypeNode {</span>
        <span class="s1">readonly kind: SyntaxKind.ArrayType;</span>
        <span class="s1">readonly elementType: TypeNode;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TupleTypeNode </span><span class="s2">extends </span><span class="s1">TypeNode {</span>
        <span class="s1">readonly kind: SyntaxKind.TupleType;</span>
        <span class="s1">readonly elements: NodeArray&lt;TypeNode | NamedTupleMember&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">NamedTupleMember </span><span class="s2">extends </span><span class="s1">TypeNode, Declaration, JSDocContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.NamedTupleMember;</span>
        <span class="s1">readonly dotDotDotToken?: Token&lt;SyntaxKind.DotDotDotToken&gt;;</span>
        <span class="s1">readonly name: Identifier;</span>
        <span class="s1">readonly questionToken?: Token&lt;SyntaxKind.QuestionToken&gt;;</span>
        <span class="s1">readonly type: TypeNode;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">OptionalTypeNode </span><span class="s2">extends </span><span class="s1">TypeNode {</span>
        <span class="s1">readonly kind: SyntaxKind.OptionalType;</span>
        <span class="s1">readonly type: TypeNode;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">RestTypeNode </span><span class="s2">extends </span><span class="s1">TypeNode {</span>
        <span class="s1">readonly kind: SyntaxKind.RestType;</span>
        <span class="s1">readonly type: TypeNode;</span>
    <span class="s1">}</span>
    <span class="s1">type UnionOrIntersectionTypeNode = UnionTypeNode | IntersectionTypeNode;</span>
    <span class="s2">interface </span><span class="s1">UnionTypeNode </span><span class="s2">extends </span><span class="s1">TypeNode {</span>
        <span class="s1">readonly kind: SyntaxKind.UnionType;</span>
        <span class="s1">readonly types: NodeArray&lt;TypeNode&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">IntersectionTypeNode </span><span class="s2">extends </span><span class="s1">TypeNode {</span>
        <span class="s1">readonly kind: SyntaxKind.IntersectionType;</span>
        <span class="s1">readonly types: NodeArray&lt;TypeNode&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ConditionalTypeNode </span><span class="s2">extends </span><span class="s1">TypeNode, LocalsContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.ConditionalType;</span>
        <span class="s1">readonly checkType: TypeNode;</span>
        <span class="s1">readonly extendsType: TypeNode;</span>
        <span class="s1">readonly trueType: TypeNode;</span>
        <span class="s1">readonly falseType: TypeNode;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">InferTypeNode </span><span class="s2">extends </span><span class="s1">TypeNode {</span>
        <span class="s1">readonly kind: SyntaxKind.InferType;</span>
        <span class="s1">readonly typeParameter: TypeParameterDeclaration;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ParenthesizedTypeNode </span><span class="s2">extends </span><span class="s1">TypeNode {</span>
        <span class="s1">readonly kind: SyntaxKind.ParenthesizedType;</span>
        <span class="s1">readonly type: TypeNode;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TypeOperatorNode </span><span class="s2">extends </span><span class="s1">TypeNode {</span>
        <span class="s1">readonly kind: SyntaxKind.TypeOperator;</span>
        <span class="s1">readonly operator: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.ReadonlyKeyword;</span>
        <span class="s1">readonly type: TypeNode;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">IndexedAccessTypeNode </span><span class="s2">extends </span><span class="s1">TypeNode {</span>
        <span class="s1">readonly kind: SyntaxKind.IndexedAccessType;</span>
        <span class="s1">readonly objectType: TypeNode;</span>
        <span class="s1">readonly indexType: TypeNode;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">MappedTypeNode </span><span class="s2">extends </span><span class="s1">TypeNode, Declaration, LocalsContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.MappedType;</span>
        <span class="s1">readonly readonlyToken?: ReadonlyKeyword | PlusToken | MinusToken;</span>
        <span class="s1">readonly typeParameter: TypeParameterDeclaration;</span>
        <span class="s1">readonly nameType?: TypeNode;</span>
        <span class="s1">readonly questionToken?: QuestionToken | PlusToken | MinusToken;</span>
        <span class="s1">readonly type?: TypeNode;</span>
        <span class="s0">/** Used only to produce grammar errors */</span>
        <span class="s1">readonly members?: NodeArray&lt;TypeElement&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">LiteralTypeNode </span><span class="s2">extends </span><span class="s1">TypeNode {</span>
        <span class="s1">readonly kind: SyntaxKind.LiteralType;</span>
        <span class="s1">readonly literal: NullLiteral | BooleanLiteral | LiteralExpression | PrefixUnaryExpression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">StringLiteral </span><span class="s2">extends </span><span class="s1">LiteralExpression, Declaration {</span>
        <span class="s1">readonly kind: SyntaxKind.StringLiteral;</span>
    <span class="s1">}</span>
    <span class="s1">type StringLiteralLike = StringLiteral | NoSubstitutionTemplateLiteral;</span>
    <span class="s1">type PropertyNameLiteral = Identifier | StringLiteralLike | NumericLiteral | JsxNamespacedName | BigIntLiteral;</span>
    <span class="s2">interface </span><span class="s1">TemplateLiteralTypeNode </span><span class="s2">extends </span><span class="s1">TypeNode {</span>
        <span class="s1">kind: SyntaxKind.TemplateLiteralType;</span>
        <span class="s1">readonly head: TemplateHead;</span>
        <span class="s1">readonly templateSpans: NodeArray&lt;TemplateLiteralTypeSpan&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TemplateLiteralTypeSpan </span><span class="s2">extends </span><span class="s1">TypeNode {</span>
        <span class="s1">readonly kind: SyntaxKind.TemplateLiteralTypeSpan;</span>
        <span class="s1">readonly parent: TemplateLiteralTypeNode;</span>
        <span class="s1">readonly type: TypeNode;</span>
        <span class="s1">readonly literal: TemplateMiddle | TemplateTail;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">Expression </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">_expressionBrand: any;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">OmittedExpression </span><span class="s2">extends </span><span class="s1">Expression {</span>
        <span class="s1">readonly kind: SyntaxKind.OmittedExpression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">PartiallyEmittedExpression </span><span class="s2">extends </span><span class="s1">LeftHandSideExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.PartiallyEmittedExpression;</span>
        <span class="s1">readonly expression: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">UnaryExpression </span><span class="s2">extends </span><span class="s1">Expression {</span>
        <span class="s1">_unaryExpressionBrand: any;</span>
    <span class="s1">}</span>
    <span class="s0">/** Deprecated, please use UpdateExpression */</span>
    <span class="s1">type IncrementExpression = UpdateExpression;</span>
    <span class="s2">interface </span><span class="s1">UpdateExpression </span><span class="s2">extends </span><span class="s1">UnaryExpression {</span>
        <span class="s1">_updateExpressionBrand: any;</span>
    <span class="s1">}</span>
    <span class="s1">type PrefixUnaryOperator = SyntaxKind.PlusPlusToken | SyntaxKind.MinusMinusToken | SyntaxKind.PlusToken | SyntaxKind.MinusToken | SyntaxKind.TildeToken | SyntaxKind.ExclamationToken;</span>
    <span class="s2">interface </span><span class="s1">PrefixUnaryExpression </span><span class="s2">extends </span><span class="s1">UpdateExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.PrefixUnaryExpression;</span>
        <span class="s1">readonly operator: PrefixUnaryOperator;</span>
        <span class="s1">readonly operand: UnaryExpression;</span>
    <span class="s1">}</span>
    <span class="s1">type PostfixUnaryOperator = SyntaxKind.PlusPlusToken | SyntaxKind.MinusMinusToken;</span>
    <span class="s2">interface </span><span class="s1">PostfixUnaryExpression </span><span class="s2">extends </span><span class="s1">UpdateExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.PostfixUnaryExpression;</span>
        <span class="s1">readonly operand: LeftHandSideExpression;</span>
        <span class="s1">readonly operator: PostfixUnaryOperator;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">LeftHandSideExpression </span><span class="s2">extends </span><span class="s1">UpdateExpression {</span>
        <span class="s1">_leftHandSideExpressionBrand: any;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">MemberExpression </span><span class="s2">extends </span><span class="s1">LeftHandSideExpression {</span>
        <span class="s1">_memberExpressionBrand: any;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">PrimaryExpression </span><span class="s2">extends </span><span class="s1">MemberExpression {</span>
        <span class="s1">_primaryExpressionBrand: any;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">NullLiteral </span><span class="s2">extends </span><span class="s1">PrimaryExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.NullKeyword;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TrueLiteral </span><span class="s2">extends </span><span class="s1">PrimaryExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.TrueKeyword;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">FalseLiteral </span><span class="s2">extends </span><span class="s1">PrimaryExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.FalseKeyword;</span>
    <span class="s1">}</span>
    <span class="s1">type BooleanLiteral = TrueLiteral | FalseLiteral;</span>
    <span class="s2">interface </span><span class="s1">ThisExpression </span><span class="s2">extends </span><span class="s1">PrimaryExpression, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.ThisKeyword;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SuperExpression </span><span class="s2">extends </span><span class="s1">PrimaryExpression, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.SuperKeyword;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ImportExpression </span><span class="s2">extends </span><span class="s1">PrimaryExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.ImportKeyword;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">DeleteExpression </span><span class="s2">extends </span><span class="s1">UnaryExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.DeleteExpression;</span>
        <span class="s1">readonly expression: UnaryExpression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TypeOfExpression </span><span class="s2">extends </span><span class="s1">UnaryExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.TypeOfExpression;</span>
        <span class="s1">readonly expression: UnaryExpression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">VoidExpression </span><span class="s2">extends </span><span class="s1">UnaryExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.VoidExpression;</span>
        <span class="s1">readonly expression: UnaryExpression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">AwaitExpression </span><span class="s2">extends </span><span class="s1">UnaryExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.AwaitExpression;</span>
        <span class="s1">readonly expression: UnaryExpression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">YieldExpression </span><span class="s2">extends </span><span class="s1">Expression {</span>
        <span class="s1">readonly kind: SyntaxKind.YieldExpression;</span>
        <span class="s1">readonly asteriskToken?: AsteriskToken;</span>
        <span class="s1">readonly expression?: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SyntheticExpression </span><span class="s2">extends </span><span class="s1">Expression {</span>
        <span class="s1">readonly kind: SyntaxKind.SyntheticExpression;</span>
        <span class="s1">readonly isSpread: boolean;</span>
        <span class="s1">readonly type: Type;</span>
        <span class="s1">readonly tupleNameSource?: ParameterDeclaration | NamedTupleMember;</span>
    <span class="s1">}</span>
    <span class="s1">type ExponentiationOperator = SyntaxKind.AsteriskAsteriskToken;</span>
    <span class="s1">type MultiplicativeOperator = SyntaxKind.AsteriskToken | SyntaxKind.SlashToken | SyntaxKind.PercentToken;</span>
    <span class="s1">type MultiplicativeOperatorOrHigher = ExponentiationOperator | MultiplicativeOperator;</span>
    <span class="s1">type AdditiveOperator = SyntaxKind.PlusToken | SyntaxKind.MinusToken;</span>
    <span class="s1">type AdditiveOperatorOrHigher = MultiplicativeOperatorOrHigher | AdditiveOperator;</span>
    <span class="s1">type ShiftOperator = SyntaxKind.LessThanLessThanToken | SyntaxKind.GreaterThanGreaterThanToken | SyntaxKind.GreaterThanGreaterThanGreaterThanToken;</span>
    <span class="s1">type ShiftOperatorOrHigher = AdditiveOperatorOrHigher | ShiftOperator;</span>
    <span class="s1">type RelationalOperator = SyntaxKind.LessThanToken | SyntaxKind.LessThanEqualsToken | SyntaxKind.GreaterThanToken | SyntaxKind.GreaterThanEqualsToken | SyntaxKind.InstanceOfKeyword | SyntaxKind.InKeyword;</span>
    <span class="s1">type RelationalOperatorOrHigher = ShiftOperatorOrHigher | RelationalOperator;</span>
    <span class="s1">type EqualityOperator = SyntaxKind.EqualsEqualsToken | SyntaxKind.EqualsEqualsEqualsToken | SyntaxKind.ExclamationEqualsEqualsToken | SyntaxKind.ExclamationEqualsToken;</span>
    <span class="s1">type EqualityOperatorOrHigher = RelationalOperatorOrHigher | EqualityOperator;</span>
    <span class="s1">type BitwiseOperator = SyntaxKind.AmpersandToken | SyntaxKind.BarToken | SyntaxKind.CaretToken;</span>
    <span class="s1">type BitwiseOperatorOrHigher = EqualityOperatorOrHigher | BitwiseOperator;</span>
    <span class="s1">type LogicalOperator = SyntaxKind.AmpersandAmpersandToken | SyntaxKind.BarBarToken;</span>
    <span class="s1">type LogicalOperatorOrHigher = BitwiseOperatorOrHigher | LogicalOperator;</span>
    <span class="s1">type CompoundAssignmentOperator = SyntaxKind.PlusEqualsToken | SyntaxKind.MinusEqualsToken | SyntaxKind.AsteriskAsteriskEqualsToken | SyntaxKind.AsteriskEqualsToken | SyntaxKind.SlashEqualsToken | SyntaxKind.PercentEqualsToken | SyntaxKind.AmpersandEqualsToken | SyntaxKind.BarEqualsToken | SyntaxKind.CaretEqualsToken | SyntaxKind.LessThanLessThanEqualsToken | SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken | SyntaxKind.GreaterThanGreaterThanEqualsToken | SyntaxKind.BarBarEqualsToken | SyntaxKind.AmpersandAmpersandEqualsToken | SyntaxKind.QuestionQuestionEqualsToken;</span>
    <span class="s1">type AssignmentOperator = SyntaxKind.EqualsToken | CompoundAssignmentOperator;</span>
    <span class="s1">type AssignmentOperatorOrHigher = SyntaxKind.QuestionQuestionToken | LogicalOperatorOrHigher | AssignmentOperator;</span>
    <span class="s1">type BinaryOperator = AssignmentOperatorOrHigher | SyntaxKind.CommaToken;</span>
    <span class="s1">type LogicalOrCoalescingAssignmentOperator = SyntaxKind.AmpersandAmpersandEqualsToken | SyntaxKind.BarBarEqualsToken | SyntaxKind.QuestionQuestionEqualsToken;</span>
    <span class="s1">type BinaryOperatorToken = Token&lt;BinaryOperator&gt;;</span>
    <span class="s2">interface </span><span class="s1">BinaryExpression </span><span class="s2">extends </span><span class="s1">Expression, Declaration, JSDocContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.BinaryExpression;</span>
        <span class="s1">readonly left: Expression;</span>
        <span class="s1">readonly operatorToken: BinaryOperatorToken;</span>
        <span class="s1">readonly right: Expression;</span>
    <span class="s1">}</span>
    <span class="s1">type AssignmentOperatorToken = Token&lt;AssignmentOperator&gt;;</span>
    <span class="s2">interface </span><span class="s1">AssignmentExpression&lt;TOperator </span><span class="s2">extends </span><span class="s1">AssignmentOperatorToken&gt; </span><span class="s2">extends </span><span class="s1">BinaryExpression {</span>
        <span class="s1">readonly left: LeftHandSideExpression;</span>
        <span class="s1">readonly operatorToken: TOperator;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ObjectDestructuringAssignment </span><span class="s2">extends </span><span class="s1">AssignmentExpression&lt;EqualsToken&gt; {</span>
        <span class="s1">readonly left: ObjectLiteralExpression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ArrayDestructuringAssignment </span><span class="s2">extends </span><span class="s1">AssignmentExpression&lt;EqualsToken&gt; {</span>
        <span class="s1">readonly left: ArrayLiteralExpression;</span>
    <span class="s1">}</span>
    <span class="s1">type DestructuringAssignment = ObjectDestructuringAssignment | ArrayDestructuringAssignment;</span>
    <span class="s1">type BindingOrAssignmentElement = VariableDeclaration | ParameterDeclaration | ObjectBindingOrAssignmentElement | ArrayBindingOrAssignmentElement;</span>
    <span class="s1">type ObjectBindingOrAssignmentElement = BindingElement | PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment;</span>
    <span class="s1">type ArrayBindingOrAssignmentElement = BindingElement | OmittedExpression | SpreadElement | ArrayLiteralExpression | ObjectLiteralExpression | AssignmentExpression&lt;EqualsToken&gt; | Identifier | PropertyAccessExpression | ElementAccessExpression;</span>
    <span class="s1">type BindingOrAssignmentElementRestIndicator = DotDotDotToken | SpreadElement | SpreadAssignment;</span>
    <span class="s1">type BindingOrAssignmentElementTarget = BindingOrAssignmentPattern | Identifier | PropertyAccessExpression | ElementAccessExpression | OmittedExpression;</span>
    <span class="s1">type ObjectBindingOrAssignmentPattern = ObjectBindingPattern | ObjectLiteralExpression;</span>
    <span class="s1">type ArrayBindingOrAssignmentPattern = ArrayBindingPattern | ArrayLiteralExpression;</span>
    <span class="s1">type AssignmentPattern = ObjectLiteralExpression | ArrayLiteralExpression;</span>
    <span class="s1">type BindingOrAssignmentPattern = ObjectBindingOrAssignmentPattern | ArrayBindingOrAssignmentPattern;</span>
    <span class="s2">interface </span><span class="s1">ConditionalExpression </span><span class="s2">extends </span><span class="s1">Expression {</span>
        <span class="s1">readonly kind: SyntaxKind.ConditionalExpression;</span>
        <span class="s1">readonly condition: Expression;</span>
        <span class="s1">readonly questionToken: QuestionToken;</span>
        <span class="s1">readonly whenTrue: Expression;</span>
        <span class="s1">readonly colonToken: ColonToken;</span>
        <span class="s1">readonly whenFalse: Expression;</span>
    <span class="s1">}</span>
    <span class="s1">type FunctionBody = Block;</span>
    <span class="s1">type ConciseBody = FunctionBody | Expression;</span>
    <span class="s2">interface </span><span class="s1">FunctionExpression </span><span class="s2">extends </span><span class="s1">PrimaryExpression, FunctionLikeDeclarationBase, JSDocContainer, LocalsContainer, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.FunctionExpression;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;Modifier&gt;;</span>
        <span class="s1">readonly name?: Identifier;</span>
        <span class="s1">readonly body: FunctionBody;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ArrowFunction </span><span class="s2">extends </span><span class="s1">Expression, FunctionLikeDeclarationBase, JSDocContainer, LocalsContainer, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.ArrowFunction;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;Modifier&gt;;</span>
        <span class="s1">readonly equalsGreaterThanToken: EqualsGreaterThanToken;</span>
        <span class="s1">readonly body: ConciseBody;</span>
        <span class="s1">readonly name: never;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">LiteralLikeNode </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">text: string;</span>
        <span class="s1">isUnterminated?: boolean;</span>
        <span class="s1">hasExtendedUnicodeEscape?: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TemplateLiteralLikeNode </span><span class="s2">extends </span><span class="s1">LiteralLikeNode {</span>
        <span class="s1">rawText?: string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">LiteralExpression </span><span class="s2">extends </span><span class="s1">LiteralLikeNode, PrimaryExpression {</span>
        <span class="s1">_literalExpressionBrand: any;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">RegularExpressionLiteral </span><span class="s2">extends </span><span class="s1">LiteralExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.RegularExpressionLiteral;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">NoSubstitutionTemplateLiteral </span><span class="s2">extends </span><span class="s1">LiteralExpression, TemplateLiteralLikeNode, Declaration {</span>
        <span class="s1">readonly kind: SyntaxKind.NoSubstitutionTemplateLiteral;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">TokenFlags {</span>
        <span class="s1">None = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">Scientific = </span><span class="s5">16</span><span class="s1">,</span>
        <span class="s1">Octal = </span><span class="s5">32</span><span class="s1">,</span>
        <span class="s1">HexSpecifier = </span><span class="s5">64</span><span class="s1">,</span>
        <span class="s1">BinarySpecifier = </span><span class="s5">128</span><span class="s1">,</span>
        <span class="s1">OctalSpecifier = </span><span class="s5">256</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">NumericLiteral </span><span class="s2">extends </span><span class="s1">LiteralExpression, Declaration {</span>
        <span class="s1">readonly kind: SyntaxKind.NumericLiteral;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">BigIntLiteral </span><span class="s2">extends </span><span class="s1">LiteralExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.BigIntLiteral;</span>
    <span class="s1">}</span>
    <span class="s1">type LiteralToken = NumericLiteral | BigIntLiteral | StringLiteral | JsxText | RegularExpressionLiteral | NoSubstitutionTemplateLiteral;</span>
    <span class="s2">interface </span><span class="s1">TemplateHead </span><span class="s2">extends </span><span class="s1">TemplateLiteralLikeNode {</span>
        <span class="s1">readonly kind: SyntaxKind.TemplateHead;</span>
        <span class="s1">readonly parent: TemplateExpression | TemplateLiteralTypeNode;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TemplateMiddle </span><span class="s2">extends </span><span class="s1">TemplateLiteralLikeNode {</span>
        <span class="s1">readonly kind: SyntaxKind.TemplateMiddle;</span>
        <span class="s1">readonly parent: TemplateSpan | TemplateLiteralTypeSpan;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TemplateTail </span><span class="s2">extends </span><span class="s1">TemplateLiteralLikeNode {</span>
        <span class="s1">readonly kind: SyntaxKind.TemplateTail;</span>
        <span class="s1">readonly parent: TemplateSpan | TemplateLiteralTypeSpan;</span>
    <span class="s1">}</span>
    <span class="s1">type PseudoLiteralToken = TemplateHead | TemplateMiddle | TemplateTail;</span>
    <span class="s1">type TemplateLiteralToken = NoSubstitutionTemplateLiteral | PseudoLiteralToken;</span>
    <span class="s2">interface </span><span class="s1">TemplateExpression </span><span class="s2">extends </span><span class="s1">PrimaryExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.TemplateExpression;</span>
        <span class="s1">readonly head: TemplateHead;</span>
        <span class="s1">readonly templateSpans: NodeArray&lt;TemplateSpan&gt;;</span>
    <span class="s1">}</span>
    <span class="s1">type TemplateLiteral = TemplateExpression | NoSubstitutionTemplateLiteral;</span>
    <span class="s2">interface </span><span class="s1">TemplateSpan </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly kind: SyntaxKind.TemplateSpan;</span>
        <span class="s1">readonly parent: TemplateExpression;</span>
        <span class="s1">readonly expression: Expression;</span>
        <span class="s1">readonly literal: TemplateMiddle | TemplateTail;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ParenthesizedExpression </span><span class="s2">extends </span><span class="s1">PrimaryExpression, JSDocContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.ParenthesizedExpression;</span>
        <span class="s1">readonly expression: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ArrayLiteralExpression </span><span class="s2">extends </span><span class="s1">PrimaryExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.ArrayLiteralExpression;</span>
        <span class="s1">readonly elements: NodeArray&lt;Expression&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SpreadElement </span><span class="s2">extends </span><span class="s1">Expression {</span>
        <span class="s1">readonly kind: SyntaxKind.SpreadElement;</span>
        <span class="s1">readonly parent: ArrayLiteralExpression | CallExpression | NewExpression;</span>
        <span class="s1">readonly expression: Expression;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* This interface is a base interface for ObjectLiteralExpression and JSXAttributes to extend from. JSXAttributes is similar to</span>
     <span class="s0">* ObjectLiteralExpression in that it contains array of properties; however, JSXAttributes' properties can only be</span>
     <span class="s0">* JSXAttribute or JSXSpreadAttribute. ObjectLiteralExpression, on the other hand, can only have properties of type</span>
     <span class="s0">* ObjectLiteralElement (e.g. PropertyAssignment, ShorthandPropertyAssignment etc.)</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">ObjectLiteralExpressionBase&lt;T </span><span class="s2">extends </span><span class="s1">ObjectLiteralElement&gt; </span><span class="s2">extends </span><span class="s1">PrimaryExpression, Declaration {</span>
        <span class="s1">readonly properties: NodeArray&lt;T&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ObjectLiteralExpression </span><span class="s2">extends </span><span class="s1">ObjectLiteralExpressionBase&lt;ObjectLiteralElementLike&gt;, JSDocContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.ObjectLiteralExpression;</span>
    <span class="s1">}</span>
    <span class="s1">type EntityNameExpression = Identifier | PropertyAccessEntityNameExpression;</span>
    <span class="s1">type EntityNameOrEntityNameExpression = EntityName | EntityNameExpression;</span>
    <span class="s1">type AccessExpression = PropertyAccessExpression | ElementAccessExpression;</span>
    <span class="s2">interface </span><span class="s1">PropertyAccessExpression </span><span class="s2">extends </span><span class="s1">MemberExpression, NamedDeclaration, JSDocContainer, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.PropertyAccessExpression;</span>
        <span class="s1">readonly expression: LeftHandSideExpression;</span>
        <span class="s1">readonly questionDotToken?: QuestionDotToken;</span>
        <span class="s1">readonly name: MemberName;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">PropertyAccessChain </span><span class="s2">extends </span><span class="s1">PropertyAccessExpression {</span>
        <span class="s1">_optionalChainBrand: any;</span>
        <span class="s1">readonly name: MemberName;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SuperPropertyAccessExpression </span><span class="s2">extends </span><span class="s1">PropertyAccessExpression {</span>
        <span class="s1">readonly expression: SuperExpression;</span>
    <span class="s1">}</span>
    <span class="s0">/** Brand for a PropertyAccessExpression which, like a QualifiedName, consists of a sequence of identifiers separated by dots. */</span>
    <span class="s2">interface </span><span class="s1">PropertyAccessEntityNameExpression </span><span class="s2">extends </span><span class="s1">PropertyAccessExpression {</span>
        <span class="s1">_propertyAccessExpressionLikeQualifiedNameBrand?: any;</span>
        <span class="s1">readonly expression: EntityNameExpression;</span>
        <span class="s1">readonly name: Identifier;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ElementAccessExpression </span><span class="s2">extends </span><span class="s1">MemberExpression, Declaration, JSDocContainer, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.ElementAccessExpression;</span>
        <span class="s1">readonly expression: LeftHandSideExpression;</span>
        <span class="s1">readonly questionDotToken?: QuestionDotToken;</span>
        <span class="s1">readonly argumentExpression: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ElementAccessChain </span><span class="s2">extends </span><span class="s1">ElementAccessExpression {</span>
        <span class="s1">_optionalChainBrand: any;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SuperElementAccessExpression </span><span class="s2">extends </span><span class="s1">ElementAccessExpression {</span>
        <span class="s1">readonly expression: SuperExpression;</span>
    <span class="s1">}</span>
    <span class="s1">type SuperProperty = SuperPropertyAccessExpression | SuperElementAccessExpression;</span>
    <span class="s2">interface </span><span class="s1">CallExpression </span><span class="s2">extends </span><span class="s1">LeftHandSideExpression, Declaration {</span>
        <span class="s1">readonly kind: SyntaxKind.CallExpression;</span>
        <span class="s1">readonly expression: LeftHandSideExpression;</span>
        <span class="s1">readonly questionDotToken?: QuestionDotToken;</span>
        <span class="s1">readonly typeArguments?: NodeArray&lt;TypeNode&gt;;</span>
        <span class="s1">readonly arguments: NodeArray&lt;Expression&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">CallChain </span><span class="s2">extends </span><span class="s1">CallExpression {</span>
        <span class="s1">_optionalChainBrand: any;</span>
    <span class="s1">}</span>
    <span class="s1">type OptionalChain = PropertyAccessChain | ElementAccessChain | CallChain | NonNullChain;</span>
    <span class="s2">interface </span><span class="s1">SuperCall </span><span class="s2">extends </span><span class="s1">CallExpression {</span>
        <span class="s1">readonly expression: SuperExpression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ImportCall </span><span class="s2">extends </span><span class="s1">CallExpression {</span>
        <span class="s1">readonly expression: ImportExpression | ImportDeferProperty;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ExpressionWithTypeArguments </span><span class="s2">extends </span><span class="s1">MemberExpression, NodeWithTypeArguments {</span>
        <span class="s1">readonly kind: SyntaxKind.ExpressionWithTypeArguments;</span>
        <span class="s1">readonly expression: LeftHandSideExpression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">NewExpression </span><span class="s2">extends </span><span class="s1">PrimaryExpression, Declaration {</span>
        <span class="s1">readonly kind: SyntaxKind.NewExpression;</span>
        <span class="s1">readonly expression: LeftHandSideExpression;</span>
        <span class="s1">readonly typeArguments?: NodeArray&lt;TypeNode&gt;;</span>
        <span class="s1">readonly arguments?: NodeArray&lt;Expression&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TaggedTemplateExpression </span><span class="s2">extends </span><span class="s1">MemberExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.TaggedTemplateExpression;</span>
        <span class="s1">readonly tag: LeftHandSideExpression;</span>
        <span class="s1">readonly typeArguments?: NodeArray&lt;TypeNode&gt;;</span>
        <span class="s1">readonly template: TemplateLiteral;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">InstanceofExpression </span><span class="s2">extends </span><span class="s1">BinaryExpression {</span>
        <span class="s1">readonly operatorToken: Token&lt;SyntaxKind.InstanceOfKeyword&gt;;</span>
    <span class="s1">}</span>
    <span class="s1">type CallLikeExpression = CallExpression | NewExpression | TaggedTemplateExpression | Decorator | JsxCallLike | InstanceofExpression;</span>
    <span class="s2">interface </span><span class="s1">AsExpression </span><span class="s2">extends </span><span class="s1">Expression {</span>
        <span class="s1">readonly kind: SyntaxKind.AsExpression;</span>
        <span class="s1">readonly expression: Expression;</span>
        <span class="s1">readonly type: TypeNode;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TypeAssertion </span><span class="s2">extends </span><span class="s1">UnaryExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.TypeAssertionExpression;</span>
        <span class="s1">readonly type: TypeNode;</span>
        <span class="s1">readonly expression: UnaryExpression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SatisfiesExpression </span><span class="s2">extends </span><span class="s1">Expression {</span>
        <span class="s1">readonly kind: SyntaxKind.SatisfiesExpression;</span>
        <span class="s1">readonly expression: Expression;</span>
        <span class="s1">readonly type: TypeNode;</span>
    <span class="s1">}</span>
    <span class="s1">type AssertionExpression = TypeAssertion | AsExpression;</span>
    <span class="s2">interface </span><span class="s1">NonNullExpression </span><span class="s2">extends </span><span class="s1">LeftHandSideExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.NonNullExpression;</span>
        <span class="s1">readonly expression: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">NonNullChain </span><span class="s2">extends </span><span class="s1">NonNullExpression {</span>
        <span class="s1">_optionalChainBrand: any;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">MetaProperty </span><span class="s2">extends </span><span class="s1">PrimaryExpression, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.MetaProperty;</span>
        <span class="s1">readonly keywordToken: SyntaxKind.NewKeyword | SyntaxKind.ImportKeyword;</span>
        <span class="s1">readonly name: Identifier;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ImportDeferProperty </span><span class="s2">extends </span><span class="s1">MetaProperty {</span>
        <span class="s1">readonly keywordToken: SyntaxKind.ImportKeyword;</span>
        <span class="s1">readonly name: Identifier &amp; {</span>
            <span class="s1">readonly escapedText: __String &amp; </span><span class="s3">&quot;defer&quot;</span><span class="s1">;</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JsxElement </span><span class="s2">extends </span><span class="s1">PrimaryExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.JsxElement;</span>
        <span class="s1">readonly openingElement: JsxOpeningElement;</span>
        <span class="s1">readonly children: NodeArray&lt;JsxChild&gt;;</span>
        <span class="s1">readonly closingElement: JsxClosingElement;</span>
    <span class="s1">}</span>
    <span class="s1">type JsxOpeningLikeElement = JsxSelfClosingElement | JsxOpeningElement;</span>
    <span class="s1">type JsxCallLike = JsxOpeningLikeElement | JsxOpeningFragment;</span>
    <span class="s1">type JsxAttributeLike = JsxAttribute | JsxSpreadAttribute;</span>
    <span class="s1">type JsxAttributeName = Identifier | JsxNamespacedName;</span>
    <span class="s1">type JsxTagNameExpression = Identifier | ThisExpression | JsxTagNamePropertyAccess | JsxNamespacedName;</span>
    <span class="s2">interface </span><span class="s1">JsxTagNamePropertyAccess </span><span class="s2">extends </span><span class="s1">PropertyAccessExpression {</span>
        <span class="s1">readonly expression: Identifier | ThisExpression | JsxTagNamePropertyAccess;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JsxAttributes </span><span class="s2">extends </span><span class="s1">PrimaryExpression, Declaration {</span>
        <span class="s1">readonly properties: NodeArray&lt;JsxAttributeLike&gt;;</span>
        <span class="s1">readonly kind: SyntaxKind.JsxAttributes;</span>
        <span class="s1">readonly parent: JsxOpeningLikeElement;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JsxNamespacedName </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly kind: SyntaxKind.JsxNamespacedName;</span>
        <span class="s1">readonly name: Identifier;</span>
        <span class="s1">readonly namespace: Identifier;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JsxOpeningElement </span><span class="s2">extends </span><span class="s1">Expression {</span>
        <span class="s1">readonly kind: SyntaxKind.JsxOpeningElement;</span>
        <span class="s1">readonly parent: JsxElement;</span>
        <span class="s1">readonly tagName: JsxTagNameExpression;</span>
        <span class="s1">readonly typeArguments?: NodeArray&lt;TypeNode&gt;;</span>
        <span class="s1">readonly attributes: JsxAttributes;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JsxSelfClosingElement </span><span class="s2">extends </span><span class="s1">PrimaryExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.JsxSelfClosingElement;</span>
        <span class="s1">readonly tagName: JsxTagNameExpression;</span>
        <span class="s1">readonly typeArguments?: NodeArray&lt;TypeNode&gt;;</span>
        <span class="s1">readonly attributes: JsxAttributes;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JsxFragment </span><span class="s2">extends </span><span class="s1">PrimaryExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.JsxFragment;</span>
        <span class="s1">readonly openingFragment: JsxOpeningFragment;</span>
        <span class="s1">readonly children: NodeArray&lt;JsxChild&gt;;</span>
        <span class="s1">readonly closingFragment: JsxClosingFragment;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JsxOpeningFragment </span><span class="s2">extends </span><span class="s1">Expression {</span>
        <span class="s1">readonly kind: SyntaxKind.JsxOpeningFragment;</span>
        <span class="s1">readonly parent: JsxFragment;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JsxClosingFragment </span><span class="s2">extends </span><span class="s1">Expression {</span>
        <span class="s1">readonly kind: SyntaxKind.JsxClosingFragment;</span>
        <span class="s1">readonly parent: JsxFragment;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JsxAttribute </span><span class="s2">extends </span><span class="s1">Declaration {</span>
        <span class="s1">readonly kind: SyntaxKind.JsxAttribute;</span>
        <span class="s1">readonly parent: JsxAttributes;</span>
        <span class="s1">readonly name: JsxAttributeName;</span>
        <span class="s1">readonly initializer?: JsxAttributeValue;</span>
    <span class="s1">}</span>
    <span class="s1">type JsxAttributeValue = StringLiteral | JsxExpression | JsxElement | JsxSelfClosingElement | JsxFragment;</span>
    <span class="s2">interface </span><span class="s1">JsxSpreadAttribute </span><span class="s2">extends </span><span class="s1">ObjectLiteralElement {</span>
        <span class="s1">readonly kind: SyntaxKind.JsxSpreadAttribute;</span>
        <span class="s1">readonly parent: JsxAttributes;</span>
        <span class="s1">readonly expression: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JsxClosingElement </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly kind: SyntaxKind.JsxClosingElement;</span>
        <span class="s1">readonly parent: JsxElement;</span>
        <span class="s1">readonly tagName: JsxTagNameExpression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JsxExpression </span><span class="s2">extends </span><span class="s1">Expression {</span>
        <span class="s1">readonly kind: SyntaxKind.JsxExpression;</span>
        <span class="s1">readonly parent: JsxElement | JsxFragment | JsxAttributeLike;</span>
        <span class="s1">readonly dotDotDotToken?: Token&lt;SyntaxKind.DotDotDotToken&gt;;</span>
        <span class="s1">readonly expression?: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JsxText </span><span class="s2">extends </span><span class="s1">LiteralLikeNode {</span>
        <span class="s1">readonly kind: SyntaxKind.JsxText;</span>
        <span class="s1">readonly parent: JsxElement | JsxFragment;</span>
        <span class="s1">readonly containsOnlyTriviaWhiteSpaces: boolean;</span>
    <span class="s1">}</span>
    <span class="s1">type JsxChild = JsxText | JsxExpression | JsxElement | JsxSelfClosingElement | JsxFragment;</span>
    <span class="s2">interface </span><span class="s1">Statement </span><span class="s2">extends </span><span class="s1">Node, JSDocContainer {</span>
        <span class="s1">_statementBrand: any;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">NotEmittedStatement </span><span class="s2">extends </span><span class="s1">Statement {</span>
        <span class="s1">readonly kind: SyntaxKind.NotEmittedStatement;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">NotEmittedTypeElement </span><span class="s2">extends </span><span class="s1">TypeElement {</span>
        <span class="s1">readonly kind: SyntaxKind.NotEmittedTypeElement;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A list of comma-separated expressions. This node is only created by transformations.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">CommaListExpression </span><span class="s2">extends </span><span class="s1">Expression {</span>
        <span class="s1">readonly kind: SyntaxKind.CommaListExpression;</span>
        <span class="s1">readonly elements: NodeArray&lt;Expression&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">EmptyStatement </span><span class="s2">extends </span><span class="s1">Statement {</span>
        <span class="s1">readonly kind: SyntaxKind.EmptyStatement;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">DebuggerStatement </span><span class="s2">extends </span><span class="s1">Statement, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.DebuggerStatement;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">MissingDeclaration </span><span class="s2">extends </span><span class="s1">DeclarationStatement, PrimaryExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.MissingDeclaration;</span>
        <span class="s1">readonly name?: Identifier;</span>
    <span class="s1">}</span>
    <span class="s1">type BlockLike = SourceFile | Block | ModuleBlock | CaseOrDefaultClause;</span>
    <span class="s2">interface </span><span class="s1">Block </span><span class="s2">extends </span><span class="s1">Statement, LocalsContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.Block;</span>
        <span class="s1">readonly statements: NodeArray&lt;Statement&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">VariableStatement </span><span class="s2">extends </span><span class="s1">Statement, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.VariableStatement;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;ModifierLike&gt;;</span>
        <span class="s1">readonly declarationList: VariableDeclarationList;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ExpressionStatement </span><span class="s2">extends </span><span class="s1">Statement, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.ExpressionStatement;</span>
        <span class="s1">readonly expression: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">IfStatement </span><span class="s2">extends </span><span class="s1">Statement, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.IfStatement;</span>
        <span class="s1">readonly expression: Expression;</span>
        <span class="s1">readonly thenStatement: Statement;</span>
        <span class="s1">readonly elseStatement?: Statement;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">IterationStatement </span><span class="s2">extends </span><span class="s1">Statement {</span>
        <span class="s1">readonly statement: Statement;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">DoStatement </span><span class="s2">extends </span><span class="s1">IterationStatement, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.DoStatement;</span>
        <span class="s1">readonly expression: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">WhileStatement </span><span class="s2">extends </span><span class="s1">IterationStatement, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.WhileStatement;</span>
        <span class="s1">readonly expression: Expression;</span>
    <span class="s1">}</span>
    <span class="s1">type ForInitializer = VariableDeclarationList | Expression;</span>
    <span class="s2">interface </span><span class="s1">ForStatement </span><span class="s2">extends </span><span class="s1">IterationStatement, LocalsContainer, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.ForStatement;</span>
        <span class="s1">readonly initializer?: ForInitializer;</span>
        <span class="s1">readonly condition?: Expression;</span>
        <span class="s1">readonly incrementor?: Expression;</span>
    <span class="s1">}</span>
    <span class="s1">type ForInOrOfStatement = ForInStatement | ForOfStatement;</span>
    <span class="s2">interface </span><span class="s1">ForInStatement </span><span class="s2">extends </span><span class="s1">IterationStatement, LocalsContainer, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.ForInStatement;</span>
        <span class="s1">readonly initializer: ForInitializer;</span>
        <span class="s1">readonly expression: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ForOfStatement </span><span class="s2">extends </span><span class="s1">IterationStatement, LocalsContainer, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.ForOfStatement;</span>
        <span class="s1">readonly awaitModifier?: AwaitKeyword;</span>
        <span class="s1">readonly initializer: ForInitializer;</span>
        <span class="s1">readonly expression: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">BreakStatement </span><span class="s2">extends </span><span class="s1">Statement, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.BreakStatement;</span>
        <span class="s1">readonly label?: Identifier;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ContinueStatement </span><span class="s2">extends </span><span class="s1">Statement, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.ContinueStatement;</span>
        <span class="s1">readonly label?: Identifier;</span>
    <span class="s1">}</span>
    <span class="s1">type BreakOrContinueStatement = BreakStatement | ContinueStatement;</span>
    <span class="s2">interface </span><span class="s1">ReturnStatement </span><span class="s2">extends </span><span class="s1">Statement, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.ReturnStatement;</span>
        <span class="s1">readonly expression?: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">WithStatement </span><span class="s2">extends </span><span class="s1">Statement, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.WithStatement;</span>
        <span class="s1">readonly expression: Expression;</span>
        <span class="s1">readonly statement: Statement;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SwitchStatement </span><span class="s2">extends </span><span class="s1">Statement, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.SwitchStatement;</span>
        <span class="s1">readonly expression: Expression;</span>
        <span class="s1">readonly caseBlock: CaseBlock;</span>
        <span class="s1">possiblyExhaustive?: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">CaseBlock </span><span class="s2">extends </span><span class="s1">Node, LocalsContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.CaseBlock;</span>
        <span class="s1">readonly parent: SwitchStatement;</span>
        <span class="s1">readonly clauses: NodeArray&lt;CaseOrDefaultClause&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">CaseClause </span><span class="s2">extends </span><span class="s1">Node, JSDocContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.CaseClause;</span>
        <span class="s1">readonly parent: CaseBlock;</span>
        <span class="s1">readonly expression: Expression;</span>
        <span class="s1">readonly statements: NodeArray&lt;Statement&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">DefaultClause </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly kind: SyntaxKind.DefaultClause;</span>
        <span class="s1">readonly parent: CaseBlock;</span>
        <span class="s1">readonly statements: NodeArray&lt;Statement&gt;;</span>
    <span class="s1">}</span>
    <span class="s1">type CaseOrDefaultClause = CaseClause | DefaultClause;</span>
    <span class="s2">interface </span><span class="s1">LabeledStatement </span><span class="s2">extends </span><span class="s1">Statement, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.LabeledStatement;</span>
        <span class="s1">readonly label: Identifier;</span>
        <span class="s1">readonly statement: Statement;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ThrowStatement </span><span class="s2">extends </span><span class="s1">Statement, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.ThrowStatement;</span>
        <span class="s1">readonly expression: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TryStatement </span><span class="s2">extends </span><span class="s1">Statement, FlowContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.TryStatement;</span>
        <span class="s1">readonly tryBlock: Block;</span>
        <span class="s1">readonly catchClause?: CatchClause;</span>
        <span class="s1">readonly finallyBlock?: Block;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">CatchClause </span><span class="s2">extends </span><span class="s1">Node, LocalsContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.CatchClause;</span>
        <span class="s1">readonly parent: TryStatement;</span>
        <span class="s1">readonly variableDeclaration?: VariableDeclaration;</span>
        <span class="s1">readonly block: Block;</span>
    <span class="s1">}</span>
    <span class="s1">type ObjectTypeDeclaration = ClassLikeDeclaration | InterfaceDeclaration | TypeLiteralNode;</span>
    <span class="s1">type DeclarationWithTypeParameters = DeclarationWithTypeParameterChildren | JSDocTypedefTag | JSDocCallbackTag | JSDocSignature;</span>
    <span class="s1">type DeclarationWithTypeParameterChildren = SignatureDeclaration | ClassLikeDeclaration | InterfaceDeclaration | TypeAliasDeclaration | JSDocTemplateTag;</span>
    <span class="s2">interface </span><span class="s1">ClassLikeDeclarationBase </span><span class="s2">extends </span><span class="s1">NamedDeclaration, JSDocContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.ClassDeclaration | SyntaxKind.ClassExpression;</span>
        <span class="s1">readonly name?: Identifier;</span>
        <span class="s1">readonly typeParameters?: NodeArray&lt;TypeParameterDeclaration&gt;;</span>
        <span class="s1">readonly heritageClauses?: NodeArray&lt;HeritageClause&gt;;</span>
        <span class="s1">readonly members: NodeArray&lt;ClassElement&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ClassDeclaration </span><span class="s2">extends </span><span class="s1">ClassLikeDeclarationBase, DeclarationStatement {</span>
        <span class="s1">readonly kind: SyntaxKind.ClassDeclaration;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;ModifierLike&gt;;</span>
        <span class="s0">/** May be undefined in `export default class { ... }`. */</span>
        <span class="s1">readonly name?: Identifier;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ClassExpression </span><span class="s2">extends </span><span class="s1">ClassLikeDeclarationBase, PrimaryExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.ClassExpression;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;ModifierLike&gt;;</span>
    <span class="s1">}</span>
    <span class="s1">type ClassLikeDeclaration = ClassDeclaration | ClassExpression;</span>
    <span class="s2">interface </span><span class="s1">ClassElement </span><span class="s2">extends </span><span class="s1">NamedDeclaration {</span>
        <span class="s1">_classElementBrand: any;</span>
        <span class="s1">readonly name?: PropertyName;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TypeElement </span><span class="s2">extends </span><span class="s1">NamedDeclaration {</span>
        <span class="s1">_typeElementBrand: any;</span>
        <span class="s1">readonly name?: PropertyName;</span>
        <span class="s1">readonly questionToken?: QuestionToken | undefined;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">InterfaceDeclaration </span><span class="s2">extends </span><span class="s1">DeclarationStatement, JSDocContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.InterfaceDeclaration;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;ModifierLike&gt;;</span>
        <span class="s1">readonly name: Identifier;</span>
        <span class="s1">readonly typeParameters?: NodeArray&lt;TypeParameterDeclaration&gt;;</span>
        <span class="s1">readonly heritageClauses?: NodeArray&lt;HeritageClause&gt;;</span>
        <span class="s1">readonly members: NodeArray&lt;TypeElement&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">HeritageClause </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly kind: SyntaxKind.HeritageClause;</span>
        <span class="s1">readonly parent: InterfaceDeclaration | ClassLikeDeclaration;</span>
        <span class="s1">readonly token: SyntaxKind.ExtendsKeyword | SyntaxKind.ImplementsKeyword;</span>
        <span class="s1">readonly types: NodeArray&lt;ExpressionWithTypeArguments&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TypeAliasDeclaration </span><span class="s2">extends </span><span class="s1">DeclarationStatement, JSDocContainer, LocalsContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.TypeAliasDeclaration;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;ModifierLike&gt;;</span>
        <span class="s1">readonly name: Identifier;</span>
        <span class="s1">readonly typeParameters?: NodeArray&lt;TypeParameterDeclaration&gt;;</span>
        <span class="s1">readonly type: TypeNode;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">EnumMember </span><span class="s2">extends </span><span class="s1">NamedDeclaration, JSDocContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.EnumMember;</span>
        <span class="s1">readonly parent: EnumDeclaration;</span>
        <span class="s1">readonly name: PropertyName;</span>
        <span class="s1">readonly initializer?: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">EnumDeclaration </span><span class="s2">extends </span><span class="s1">DeclarationStatement, JSDocContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.EnumDeclaration;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;ModifierLike&gt;;</span>
        <span class="s1">readonly name: Identifier;</span>
        <span class="s1">readonly members: NodeArray&lt;EnumMember&gt;;</span>
    <span class="s1">}</span>
    <span class="s1">type ModuleName = Identifier | StringLiteral;</span>
    <span class="s1">type ModuleBody = NamespaceBody | JSDocNamespaceBody;</span>
    <span class="s2">interface </span><span class="s1">ModuleDeclaration </span><span class="s2">extends </span><span class="s1">DeclarationStatement, JSDocContainer, LocalsContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.ModuleDeclaration;</span>
        <span class="s1">readonly parent: ModuleBody | SourceFile;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;ModifierLike&gt;;</span>
        <span class="s1">readonly name: ModuleName;</span>
        <span class="s1">readonly body?: ModuleBody | JSDocNamespaceDeclaration;</span>
    <span class="s1">}</span>
    <span class="s1">type NamespaceBody = ModuleBlock | NamespaceDeclaration;</span>
    <span class="s2">interface </span><span class="s1">NamespaceDeclaration </span><span class="s2">extends </span><span class="s1">ModuleDeclaration {</span>
        <span class="s1">readonly name: Identifier;</span>
        <span class="s1">readonly body: NamespaceBody;</span>
    <span class="s1">}</span>
    <span class="s1">type JSDocNamespaceBody = Identifier | JSDocNamespaceDeclaration;</span>
    <span class="s2">interface </span><span class="s1">JSDocNamespaceDeclaration </span><span class="s2">extends </span><span class="s1">ModuleDeclaration {</span>
        <span class="s1">readonly name: Identifier;</span>
        <span class="s1">readonly body?: JSDocNamespaceBody;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ModuleBlock </span><span class="s2">extends </span><span class="s1">Node, Statement {</span>
        <span class="s1">readonly kind: SyntaxKind.ModuleBlock;</span>
        <span class="s1">readonly parent: ModuleDeclaration;</span>
        <span class="s1">readonly statements: NodeArray&lt;Statement&gt;;</span>
    <span class="s1">}</span>
    <span class="s1">type ModuleReference = EntityName | ExternalModuleReference;</span>
    <span class="s0">/**</span>
     <span class="s0">* One of:</span>
     <span class="s0">* - import x = require(&quot;mod&quot;);</span>
     <span class="s0">* - import x = M.x;</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">ImportEqualsDeclaration </span><span class="s2">extends </span><span class="s1">DeclarationStatement, JSDocContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.ImportEqualsDeclaration;</span>
        <span class="s1">readonly parent: SourceFile | ModuleBlock;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;ModifierLike&gt;;</span>
        <span class="s1">readonly name: Identifier;</span>
        <span class="s1">readonly isTypeOnly: boolean;</span>
        <span class="s1">readonly moduleReference: ModuleReference;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ExternalModuleReference </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly kind: SyntaxKind.ExternalModuleReference;</span>
        <span class="s1">readonly parent: ImportEqualsDeclaration;</span>
        <span class="s1">readonly expression: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ImportDeclaration </span><span class="s2">extends </span><span class="s1">Statement {</span>
        <span class="s1">readonly kind: SyntaxKind.ImportDeclaration;</span>
        <span class="s1">readonly parent: SourceFile | ModuleBlock;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;ModifierLike&gt;;</span>
        <span class="s1">readonly importClause?: ImportClause;</span>
        <span class="s0">/** If this is not a StringLiteral it will be a grammar error. */</span>
        <span class="s1">readonly moduleSpecifier: Expression;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/ </span><span class="s1">readonly assertClause?: AssertClause;</span>
        <span class="s1">readonly attributes?: ImportAttributes;</span>
    <span class="s1">}</span>
    <span class="s1">type NamedImportBindings = NamespaceImport | NamedImports;</span>
    <span class="s1">type NamedExportBindings = NamespaceExport | NamedExports;</span>
    <span class="s2">interface </span><span class="s1">ImportClause </span><span class="s2">extends </span><span class="s1">NamedDeclaration {</span>
        <span class="s1">readonly kind: SyntaxKind.ImportClause;</span>
        <span class="s1">readonly parent: ImportDeclaration | JSDocImportTag;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">Use `phaseModifier` instead */</span>
        <span class="s1">readonly isTypeOnly: boolean;</span>
        <span class="s1">readonly phaseModifier: undefined | ImportPhaseModifierSyntaxKind;</span>
        <span class="s1">readonly name?: Identifier;</span>
        <span class="s1">readonly namedBindings?: NamedImportBindings;</span>
    <span class="s1">}</span>
    <span class="s1">type ImportPhaseModifierSyntaxKind = SyntaxKind.TypeKeyword | SyntaxKind.DeferKeyword;</span>
    <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/</span>
    <span class="s1">type AssertionKey = ImportAttributeName;</span>
    <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">AssertEntry </span><span class="s2">extends </span><span class="s1">ImportAttribute {</span>
    <span class="s1">}</span>
    <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">AssertClause </span><span class="s2">extends </span><span class="s1">ImportAttributes {</span>
    <span class="s1">}</span>
    <span class="s1">type ImportAttributeName = Identifier | StringLiteral;</span>
    <span class="s2">interface </span><span class="s1">ImportAttribute </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly kind: SyntaxKind.ImportAttribute;</span>
        <span class="s1">readonly parent: ImportAttributes;</span>
        <span class="s1">readonly name: ImportAttributeName;</span>
        <span class="s1">readonly value: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ImportAttributes </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly token: SyntaxKind.WithKeyword | SyntaxKind.AssertKeyword;</span>
        <span class="s1">readonly kind: SyntaxKind.ImportAttributes;</span>
        <span class="s1">readonly parent: ImportDeclaration | ExportDeclaration;</span>
        <span class="s1">readonly elements: NodeArray&lt;ImportAttribute&gt;;</span>
        <span class="s1">readonly multiLine?: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">NamespaceImport </span><span class="s2">extends </span><span class="s1">NamedDeclaration {</span>
        <span class="s1">readonly kind: SyntaxKind.NamespaceImport;</span>
        <span class="s1">readonly parent: ImportClause;</span>
        <span class="s1">readonly name: Identifier;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">NamespaceExport </span><span class="s2">extends </span><span class="s1">NamedDeclaration {</span>
        <span class="s1">readonly kind: SyntaxKind.NamespaceExport;</span>
        <span class="s1">readonly parent: ExportDeclaration;</span>
        <span class="s1">readonly name: ModuleExportName;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">NamespaceExportDeclaration </span><span class="s2">extends </span><span class="s1">DeclarationStatement, JSDocContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.NamespaceExportDeclaration;</span>
        <span class="s1">readonly name: Identifier;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ExportDeclaration </span><span class="s2">extends </span><span class="s1">DeclarationStatement, JSDocContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.ExportDeclaration;</span>
        <span class="s1">readonly parent: SourceFile | ModuleBlock;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;ModifierLike&gt;;</span>
        <span class="s1">readonly isTypeOnly: boolean;</span>
        <span class="s0">/** Will not be assigned in the case of `export * from &quot;foo&quot;;` */</span>
        <span class="s1">readonly exportClause?: NamedExportBindings;</span>
        <span class="s0">/** If this is not a StringLiteral it will be a grammar error. */</span>
        <span class="s1">readonly moduleSpecifier?: Expression;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/ </span><span class="s1">readonly assertClause?: AssertClause;</span>
        <span class="s1">readonly attributes?: ImportAttributes;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">NamedImports </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly kind: SyntaxKind.NamedImports;</span>
        <span class="s1">readonly parent: ImportClause;</span>
        <span class="s1">readonly elements: NodeArray&lt;ImportSpecifier&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">NamedExports </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly kind: SyntaxKind.NamedExports;</span>
        <span class="s1">readonly parent: ExportDeclaration;</span>
        <span class="s1">readonly elements: NodeArray&lt;ExportSpecifier&gt;;</span>
    <span class="s1">}</span>
    <span class="s1">type NamedImportsOrExports = NamedImports | NamedExports;</span>
    <span class="s2">interface </span><span class="s1">ImportSpecifier </span><span class="s2">extends </span><span class="s1">NamedDeclaration {</span>
        <span class="s1">readonly kind: SyntaxKind.ImportSpecifier;</span>
        <span class="s1">readonly parent: NamedImports;</span>
        <span class="s1">readonly propertyName?: ModuleExportName;</span>
        <span class="s1">readonly name: Identifier;</span>
        <span class="s1">readonly isTypeOnly: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ExportSpecifier </span><span class="s2">extends </span><span class="s1">NamedDeclaration, JSDocContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.ExportSpecifier;</span>
        <span class="s1">readonly parent: NamedExports;</span>
        <span class="s1">readonly isTypeOnly: boolean;</span>
        <span class="s1">readonly propertyName?: ModuleExportName;</span>
        <span class="s1">readonly name: ModuleExportName;</span>
    <span class="s1">}</span>
    <span class="s1">type ModuleExportName = Identifier | StringLiteral;</span>
    <span class="s1">type ImportOrExportSpecifier = ImportSpecifier | ExportSpecifier;</span>
    <span class="s1">type TypeOnlyCompatibleAliasDeclaration = ImportClause | ImportEqualsDeclaration | NamespaceImport | ImportOrExportSpecifier | ExportDeclaration | NamespaceExport;</span>
    <span class="s1">type TypeOnlyImportDeclaration =</span>
        <span class="s1">| ImportClause &amp; {</span>
            <span class="s1">readonly isTypeOnly: </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">readonly name: Identifier;</span>
        <span class="s1">}</span>
        <span class="s1">| ImportEqualsDeclaration &amp; {</span>
            <span class="s1">readonly isTypeOnly: </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">| NamespaceImport &amp; {</span>
            <span class="s1">readonly parent: ImportClause &amp; {</span>
                <span class="s1">readonly isTypeOnly: </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s1">| ImportSpecifier</span>
            <span class="s1">&amp; ({</span>
                <span class="s1">readonly isTypeOnly: </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">} | {</span>
                <span class="s1">readonly parent: NamedImports &amp; {</span>
                    <span class="s1">readonly parent: ImportClause &amp; {</span>
                        <span class="s1">readonly isTypeOnly: </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s1">};</span>
                <span class="s1">};</span>
            <span class="s1">});</span>
    <span class="s1">type TypeOnlyExportDeclaration =</span>
        <span class="s1">| ExportSpecifier</span>
            <span class="s1">&amp; ({</span>
                <span class="s1">readonly isTypeOnly: </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">} | {</span>
                <span class="s1">readonly parent: NamedExports &amp; {</span>
                    <span class="s1">readonly parent: ExportDeclaration &amp; {</span>
                        <span class="s1">readonly isTypeOnly: </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s1">};</span>
                <span class="s1">};</span>
            <span class="s1">})</span>
        <span class="s1">| ExportDeclaration &amp; {</span>
            <span class="s1">readonly isTypeOnly: </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">readonly moduleSpecifier: Expression;</span>
        <span class="s1">}</span>
        <span class="s1">| NamespaceExport &amp; {</span>
            <span class="s1">readonly parent: ExportDeclaration &amp; {</span>
                <span class="s1">readonly isTypeOnly: </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">readonly moduleSpecifier: Expression;</span>
            <span class="s1">};</span>
        <span class="s1">};</span>
    <span class="s1">type TypeOnlyAliasDeclaration = TypeOnlyImportDeclaration | TypeOnlyExportDeclaration;</span>
    <span class="s0">/**</span>
     <span class="s0">* This is either an `export =` or an `export default` declaration.</span>
     <span class="s0">* Unless `isExportEquals` is set, this node was parsed as an `export default`.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">ExportAssignment </span><span class="s2">extends </span><span class="s1">DeclarationStatement, JSDocContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.ExportAssignment;</span>
        <span class="s1">readonly parent: SourceFile;</span>
        <span class="s1">readonly modifiers?: NodeArray&lt;ModifierLike&gt;;</span>
        <span class="s1">readonly isExportEquals?: boolean;</span>
        <span class="s1">readonly expression: Expression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">FileReference </span><span class="s2">extends </span><span class="s1">TextRange {</span>
        <span class="s1">fileName: string;</span>
        <span class="s1">resolutionMode?: ResolutionMode;</span>
        <span class="s1">preserve?: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">CheckJsDirective </span><span class="s2">extends </span><span class="s1">TextRange {</span>
        <span class="s1">enabled: boolean;</span>
    <span class="s1">}</span>
    <span class="s1">type CommentKind = SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia;</span>
    <span class="s2">interface </span><span class="s1">CommentRange </span><span class="s2">extends </span><span class="s1">TextRange {</span>
        <span class="s1">hasTrailingNewLine?: boolean;</span>
        <span class="s1">kind: CommentKind;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SynthesizedComment </span><span class="s2">extends </span><span class="s1">CommentRange {</span>
        <span class="s1">text: string;</span>
        <span class="s1">pos: -</span><span class="s5">1</span><span class="s1">;</span>
        <span class="s1">end: -</span><span class="s5">1</span><span class="s1">;</span>
        <span class="s1">hasLeadingNewline?: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocTypeExpression </span><span class="s2">extends </span><span class="s1">TypeNode {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocTypeExpression;</span>
        <span class="s1">readonly type: TypeNode;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocNameReference </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocNameReference;</span>
        <span class="s1">readonly name: EntityName | JSDocMemberName;</span>
    <span class="s1">}</span>
    <span class="s0">/** Class#method reference in JSDoc */</span>
    <span class="s2">interface </span><span class="s1">JSDocMemberName </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocMemberName;</span>
        <span class="s1">readonly left: EntityName | JSDocMemberName;</span>
        <span class="s1">readonly right: Identifier;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocType </span><span class="s2">extends </span><span class="s1">TypeNode {</span>
        <span class="s1">_jsDocTypeBrand: any;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocAllType </span><span class="s2">extends </span><span class="s1">JSDocType {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocAllType;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocUnknownType </span><span class="s2">extends </span><span class="s1">JSDocType {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocUnknownType;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocNonNullableType </span><span class="s2">extends </span><span class="s1">JSDocType {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocNonNullableType;</span>
        <span class="s1">readonly type: TypeNode;</span>
        <span class="s1">readonly postfix: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocNullableType </span><span class="s2">extends </span><span class="s1">JSDocType {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocNullableType;</span>
        <span class="s1">readonly type: TypeNode;</span>
        <span class="s1">readonly postfix: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocOptionalType </span><span class="s2">extends </span><span class="s1">JSDocType {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocOptionalType;</span>
        <span class="s1">readonly type: TypeNode;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocFunctionType </span><span class="s2">extends </span><span class="s1">JSDocType, SignatureDeclarationBase, LocalsContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocFunctionType;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocVariadicType </span><span class="s2">extends </span><span class="s1">JSDocType {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocVariadicType;</span>
        <span class="s1">readonly type: TypeNode;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocNamepathType </span><span class="s2">extends </span><span class="s1">JSDocType {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocNamepathType;</span>
        <span class="s1">readonly type: TypeNode;</span>
    <span class="s1">}</span>
    <span class="s1">type JSDocTypeReferencingNode = JSDocVariadicType | JSDocOptionalType | JSDocNullableType | JSDocNonNullableType;</span>
    <span class="s2">interface </span><span class="s1">JSDoc </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDoc;</span>
        <span class="s1">readonly parent: HasJSDoc;</span>
        <span class="s1">readonly tags?: NodeArray&lt;JSDocTag&gt;;</span>
        <span class="s1">readonly comment?: string | NodeArray&lt;JSDocComment&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocTag </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly parent: JSDoc | JSDocTypeLiteral;</span>
        <span class="s1">readonly tagName: Identifier;</span>
        <span class="s1">readonly comment?: string | NodeArray&lt;JSDocComment&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocLink </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocLink;</span>
        <span class="s1">readonly name?: EntityName | JSDocMemberName;</span>
        <span class="s1">text: string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocLinkCode </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocLinkCode;</span>
        <span class="s1">readonly name?: EntityName | JSDocMemberName;</span>
        <span class="s1">text: string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocLinkPlain </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocLinkPlain;</span>
        <span class="s1">readonly name?: EntityName | JSDocMemberName;</span>
        <span class="s1">text: string;</span>
    <span class="s1">}</span>
    <span class="s1">type JSDocComment = JSDocText | JSDocLink | JSDocLinkCode | JSDocLinkPlain;</span>
    <span class="s2">interface </span><span class="s1">JSDocText </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocText;</span>
        <span class="s1">text: string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocUnknownTag </span><span class="s2">extends </span><span class="s1">JSDocTag {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocTag;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Note that `@extends` is a synonym of `@augments`.</span>
     <span class="s0">* Both tags are represented by this interface.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">JSDocAugmentsTag </span><span class="s2">extends </span><span class="s1">JSDocTag {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocAugmentsTag;</span>
        <span class="s1">readonly </span><span class="s2">class</span><span class="s1">: ExpressionWithTypeArguments &amp; {</span>
            <span class="s1">readonly expression: Identifier | PropertyAccessEntityNameExpression;</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocImplementsTag </span><span class="s2">extends </span><span class="s1">JSDocTag {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocImplementsTag;</span>
        <span class="s1">readonly </span><span class="s2">class</span><span class="s1">: ExpressionWithTypeArguments &amp; {</span>
            <span class="s1">readonly expression: Identifier | PropertyAccessEntityNameExpression;</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocAuthorTag </span><span class="s2">extends </span><span class="s1">JSDocTag {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocAuthorTag;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocDeprecatedTag </span><span class="s2">extends </span><span class="s1">JSDocTag {</span>
        <span class="s1">kind: SyntaxKind.JSDocDeprecatedTag;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocClassTag </span><span class="s2">extends </span><span class="s1">JSDocTag {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocClassTag;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocPublicTag </span><span class="s2">extends </span><span class="s1">JSDocTag {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocPublicTag;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocPrivateTag </span><span class="s2">extends </span><span class="s1">JSDocTag {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocPrivateTag;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocProtectedTag </span><span class="s2">extends </span><span class="s1">JSDocTag {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocProtectedTag;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocReadonlyTag </span><span class="s2">extends </span><span class="s1">JSDocTag {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocReadonlyTag;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocOverrideTag </span><span class="s2">extends </span><span class="s1">JSDocTag {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocOverrideTag;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocEnumTag </span><span class="s2">extends </span><span class="s1">JSDocTag, Declaration, LocalsContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocEnumTag;</span>
        <span class="s1">readonly parent: JSDoc;</span>
        <span class="s1">readonly typeExpression: JSDocTypeExpression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocThisTag </span><span class="s2">extends </span><span class="s1">JSDocTag {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocThisTag;</span>
        <span class="s1">readonly typeExpression: JSDocTypeExpression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocTemplateTag </span><span class="s2">extends </span><span class="s1">JSDocTag {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocTemplateTag;</span>
        <span class="s1">readonly constraint: JSDocTypeExpression | undefined;</span>
        <span class="s1">readonly typeParameters: NodeArray&lt;TypeParameterDeclaration&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocSeeTag </span><span class="s2">extends </span><span class="s1">JSDocTag {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocSeeTag;</span>
        <span class="s1">readonly name?: JSDocNameReference;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocReturnTag </span><span class="s2">extends </span><span class="s1">JSDocTag {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocReturnTag;</span>
        <span class="s1">readonly typeExpression?: JSDocTypeExpression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocTypeTag </span><span class="s2">extends </span><span class="s1">JSDocTag {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocTypeTag;</span>
        <span class="s1">readonly typeExpression: JSDocTypeExpression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocTypedefTag </span><span class="s2">extends </span><span class="s1">JSDocTag, NamedDeclaration, LocalsContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocTypedefTag;</span>
        <span class="s1">readonly parent: JSDoc;</span>
        <span class="s1">readonly fullName?: JSDocNamespaceDeclaration | Identifier;</span>
        <span class="s1">readonly name?: Identifier;</span>
        <span class="s1">readonly typeExpression?: JSDocTypeExpression | JSDocTypeLiteral;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocCallbackTag </span><span class="s2">extends </span><span class="s1">JSDocTag, NamedDeclaration, LocalsContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocCallbackTag;</span>
        <span class="s1">readonly parent: JSDoc;</span>
        <span class="s1">readonly fullName?: JSDocNamespaceDeclaration | Identifier;</span>
        <span class="s1">readonly name?: Identifier;</span>
        <span class="s1">readonly typeExpression: JSDocSignature;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocOverloadTag </span><span class="s2">extends </span><span class="s1">JSDocTag {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocOverloadTag;</span>
        <span class="s1">readonly parent: JSDoc;</span>
        <span class="s1">readonly typeExpression: JSDocSignature;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocThrowsTag </span><span class="s2">extends </span><span class="s1">JSDocTag {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocThrowsTag;</span>
        <span class="s1">readonly typeExpression?: JSDocTypeExpression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocSignature </span><span class="s2">extends </span><span class="s1">JSDocType, Declaration, JSDocContainer, LocalsContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocSignature;</span>
        <span class="s1">readonly typeParameters?: readonly JSDocTemplateTag[];</span>
        <span class="s1">readonly parameters: readonly JSDocParameterTag[];</span>
        <span class="s1">readonly type: JSDocReturnTag | undefined;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocPropertyLikeTag </span><span class="s2">extends </span><span class="s1">JSDocTag, Declaration {</span>
        <span class="s1">readonly parent: JSDoc;</span>
        <span class="s1">readonly name: EntityName;</span>
        <span class="s1">readonly typeExpression?: JSDocTypeExpression;</span>
        <span class="s0">/** Whether the property name came before the type -- non-standard for JSDoc, but Typescript-like */</span>
        <span class="s1">readonly isNameFirst: boolean;</span>
        <span class="s1">readonly isBracketed: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocPropertyTag </span><span class="s2">extends </span><span class="s1">JSDocPropertyLikeTag {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocPropertyTag;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocParameterTag </span><span class="s2">extends </span><span class="s1">JSDocPropertyLikeTag {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocParameterTag;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocTypeLiteral </span><span class="s2">extends </span><span class="s1">JSDocType, Declaration {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocTypeLiteral;</span>
        <span class="s1">readonly jsDocPropertyTags?: readonly JSDocPropertyLikeTag[];</span>
        <span class="s0">/** If true, then this type literal represents an *array* of its type. */</span>
        <span class="s1">readonly isArrayType: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocSatisfiesTag </span><span class="s2">extends </span><span class="s1">JSDocTag {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocSatisfiesTag;</span>
        <span class="s1">readonly typeExpression: JSDocTypeExpression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocImportTag </span><span class="s2">extends </span><span class="s1">JSDocTag {</span>
        <span class="s1">readonly kind: SyntaxKind.JSDocImportTag;</span>
        <span class="s1">readonly parent: JSDoc;</span>
        <span class="s1">readonly importClause?: ImportClause;</span>
        <span class="s1">readonly moduleSpecifier: Expression;</span>
        <span class="s1">readonly attributes?: ImportAttributes;</span>
    <span class="s1">}</span>
    <span class="s1">type FlowType = Type | IncompleteType;</span>
    <span class="s2">interface </span><span class="s1">IncompleteType {</span>
        <span class="s1">flags: TypeFlags | </span><span class="s5">0</span><span class="s1">;</span>
        <span class="s1">type: Type;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">AmdDependency {</span>
        <span class="s1">path: string;</span>
        <span class="s1">name?: string;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Subset of properties from SourceFile that are used in multiple utility functions</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">SourceFileLike {</span>
        <span class="s1">readonly text: string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SourceFileLike {</span>
        <span class="s1">getLineAndCharacterOfPosition(pos: number): LineAndCharacter;</span>
    <span class="s1">}</span>
    <span class="s1">type ResolutionMode = ModuleKind.ESNext | ModuleKind.CommonJS | undefined;</span>
    <span class="s2">interface </span><span class="s1">SourceFile </span><span class="s2">extends </span><span class="s1">Declaration, LocalsContainer {</span>
        <span class="s1">readonly kind: SyntaxKind.SourceFile;</span>
        <span class="s1">readonly statements: NodeArray&lt;Statement&gt;;</span>
        <span class="s1">readonly endOfFileToken: Token&lt;SyntaxKind.EndOfFileToken&gt;;</span>
        <span class="s1">fileName: string;</span>
        <span class="s1">text: string;</span>
        <span class="s1">amdDependencies: readonly AmdDependency[];</span>
        <span class="s1">moduleName?: string;</span>
        <span class="s1">referencedFiles: readonly FileReference[];</span>
        <span class="s1">typeReferenceDirectives: readonly FileReference[];</span>
        <span class="s1">libReferenceDirectives: readonly FileReference[];</span>
        <span class="s1">languageVariant: LanguageVariant;</span>
        <span class="s1">isDeclarationFile: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* lib.d.ts should have a reference comment like</span>
         <span class="s0">*</span>
         <span class="s0">*  /// &lt;reference no-default-lib=&quot;true&quot;/&gt;</span>
         <span class="s0">*</span>
         <span class="s0">* If any other file has this comment, it signals not to include lib.d.ts</span>
         <span class="s0">* because this containing file is intended to act as a default library.</span>
         <span class="s0">*/</span>
        <span class="s1">hasNoDefaultLib: boolean;</span>
        <span class="s1">languageVersion: ScriptTarget;</span>
        <span class="s0">/**</span>
         <span class="s0">* When `module` is `Node16` or `NodeNext`, this field controls whether the</span>
         <span class="s0">* source file in question is an ESNext-output-format file, or a CommonJS-output-format</span>
         <span class="s0">* module. This is derived by the module resolver as it looks up the file, since</span>
         <span class="s0">* it is derived from either the file extension of the module, or the containing</span>
         <span class="s0">* `package.json` context, and affects both checking and emit.</span>
         <span class="s0">*</span>
         <span class="s0">* It is _public_ so that (pre)transformers can set this field,</span>
         <span class="s0">* since it switches the builtin `node` module transform. Generally speaking, if unset,</span>
         <span class="s0">* the field is treated as though it is `ModuleKind.CommonJS`.</span>
         <span class="s0">*</span>
         <span class="s0">* Note that this field is only set by the module resolution process when</span>
         <span class="s0">* `moduleResolution` is `Node16` or `NodeNext`, which is implied by the `module` setting</span>
         <span class="s0">* of `Node16` or `NodeNext`, respectively, but may be overriden (eg, by a `moduleResolution`</span>
         <span class="s0">* of `node`). If so, this field will be unset and source files will be considered to be</span>
         <span class="s0">* CommonJS-output-format by the node module transformer and type checker, regardless of extension or context.</span>
         <span class="s0">*/</span>
        <span class="s1">impliedNodeFormat?: ResolutionMode;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SourceFile {</span>
        <span class="s1">getLineAndCharacterOfPosition(pos: number): LineAndCharacter;</span>
        <span class="s1">getLineEndOfPosition(pos: number): number;</span>
        <span class="s1">getLineStarts(): readonly number[];</span>
        <span class="s1">getPositionOfLineAndCharacter(line: number, character: number): number;</span>
        <span class="s1">update(newText: string, textChangeRange: TextChangeRange): SourceFile;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">Bundle </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">readonly kind: SyntaxKind.Bundle;</span>
        <span class="s1">readonly sourceFiles: readonly SourceFile[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JsonSourceFile </span><span class="s2">extends </span><span class="s1">SourceFile {</span>
        <span class="s1">readonly statements: NodeArray&lt;JsonObjectExpressionStatement&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TsConfigSourceFile </span><span class="s2">extends </span><span class="s1">JsonSourceFile {</span>
        <span class="s1">extendedSourceFiles?: string[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JsonMinusNumericLiteral </span><span class="s2">extends </span><span class="s1">PrefixUnaryExpression {</span>
        <span class="s1">readonly kind: SyntaxKind.PrefixUnaryExpression;</span>
        <span class="s1">readonly operator: SyntaxKind.MinusToken;</span>
        <span class="s1">readonly operand: NumericLiteral;</span>
    <span class="s1">}</span>
    <span class="s1">type JsonObjectExpression = ObjectLiteralExpression | ArrayLiteralExpression | JsonMinusNumericLiteral | NumericLiteral | StringLiteral | BooleanLiteral | NullLiteral;</span>
    <span class="s2">interface </span><span class="s1">JsonObjectExpressionStatement </span><span class="s2">extends </span><span class="s1">ExpressionStatement {</span>
        <span class="s1">readonly expression: JsonObjectExpression;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ScriptReferenceHost {</span>
        <span class="s1">getCompilerOptions(): CompilerOptions;</span>
        <span class="s1">getSourceFile(fileName: string): SourceFile | undefined;</span>
        <span class="s1">getSourceFileByPath(path: Path): SourceFile | undefined;</span>
        <span class="s1">getCurrentDirectory(): string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ParseConfigHost </span><span class="s2">extends </span><span class="s1">ModuleResolutionHost {</span>
        <span class="s1">useCaseSensitiveFileNames: boolean;</span>
        <span class="s1">readDirectory(rootDir: string, extensions: readonly string[], excludes: readonly string[] | undefined, includes: readonly string[], depth?: number): readonly string[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets a value indicating whether the specified path exists and is a file.</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">path The path to test.</span>
         <span class="s0">*/</span>
        <span class="s1">fileExists(path: string): boolean;</span>
        <span class="s1">readFile(path: string): string | undefined;</span>
        <span class="s1">trace?(s: string): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Branded string for keeping track of when we've turned an ambiguous path</span>
     <span class="s0">* specified like &quot;./blah&quot; to an absolute path to an actual</span>
     <span class="s0">* tsconfig file, e.g. &quot;/root/blah/tsconfig.json&quot;</span>
     <span class="s0">*/</span>
    <span class="s1">type ResolvedConfigFileName = string &amp; {</span>
        <span class="s1">_isResolvedConfigFileName: never;</span>
    <span class="s1">};</span>
    <span class="s2">interface </span><span class="s1">WriteFileCallbackData {</span>
    <span class="s1">}</span>
    <span class="s1">type WriteFileCallback = (fileName: string, text: string, writeByteOrderMark: boolean, onError?: (message: string) =&gt; </span><span class="s2">void</span><span class="s1">, sourceFiles?: readonly SourceFile[], data?: WriteFileCallbackData) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s2">class </span><span class="s1">OperationCanceledException {</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">CancellationToken {</span>
        <span class="s1">isCancellationRequested(): boolean;</span>
        <span class="s0">/** </span><span class="s4">@throws </span><span class="s0">OperationCanceledException if isCancellationRequested is true */</span>
        <span class="s1">throwIfCancellationRequested(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">Program </span><span class="s2">extends </span><span class="s1">ScriptReferenceHost {</span>
        <span class="s1">getCurrentDirectory(): string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Get a list of root file names that were passed to a 'createProgram'</span>
         <span class="s0">*/</span>
        <span class="s1">getRootFileNames(): readonly string[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Get a list of files in the program</span>
         <span class="s0">*/</span>
        <span class="s1">getSourceFiles(): readonly SourceFile[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Emits the JavaScript and declaration files.  If targetSourceFile is not specified, then</span>
         <span class="s0">* the JavaScript and declaration files will be produced for all the files in this program.</span>
         <span class="s0">* If targetSourceFile is specified, then only the JavaScript and declaration for that</span>
         <span class="s0">* specific file will be generated.</span>
         <span class="s0">*</span>
         <span class="s0">* If writeFile is not specified then the writeFile callback from the compiler host will be</span>
         <span class="s0">* used for writing the JavaScript and declaration files.  Otherwise, the writeFile parameter</span>
         <span class="s0">* will be invoked when writing the JavaScript and declaration files.</span>
         <span class="s0">*/</span>
        <span class="s1">emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult;</span>
        <span class="s1">getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];</span>
        <span class="s1">getGlobalDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];</span>
        <span class="s1">getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];</span>
        <span class="s0">/** The first time this is called, it will return global diagnostics (no location). */</span>
        <span class="s1">getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];</span>
        <span class="s1">getDeclarationDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];</span>
        <span class="s1">getConfigFileParsingDiagnostics(): readonly Diagnostic[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets a type checker that can be used to semantically analyze source files in the program.</span>
         <span class="s0">*/</span>
        <span class="s1">getTypeChecker(): TypeChecker;</span>
        <span class="s1">getNodeCount(): number;</span>
        <span class="s1">getIdentifierCount(): number;</span>
        <span class="s1">getSymbolCount(): number;</span>
        <span class="s1">getTypeCount(): number;</span>
        <span class="s1">getInstantiationCount(): number;</span>
        <span class="s1">getRelationCacheSizes(): {</span>
            <span class="s1">assignable: number;</span>
            <span class="s1">identity: number;</span>
            <span class="s1">subtype: number;</span>
            <span class="s1">strictSubtype: number;</span>
        <span class="s1">};</span>
        <span class="s1">isSourceFileFromExternalLibrary(file: SourceFile): boolean;</span>
        <span class="s1">isSourceFileDefaultLibrary(file: SourceFile): boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Calculates the final resolution mode for a given module reference node. This function only returns a result when module resolution</span>
         <span class="s0">* settings allow differing resolution between ESM imports and CJS requires, or when a mode is explicitly provided via import attributes,</span>
         <span class="s0">* which cause an `import` or `require` condition to be used during resolution regardless of module resolution settings. In absence of</span>
         <span class="s0">* overriding attributes, and in modes that support differing resolution, the result indicates the syntax the usage would emit to JavaScript.</span>
         <span class="s0">* Some examples:</span>
         <span class="s0">*</span>
         <span class="s0">* ```ts</span>
         <span class="s0">* // tsc foo.mts --module nodenext</span>
         <span class="s0">* import {} from &quot;mod&quot;;</span>
         <span class="s0">* // Result: ESNext - the import emits as ESM due to `impliedNodeFormat` set by .mts file extension</span>
         <span class="s0">*</span>
         <span class="s0">* // tsc foo.cts --module nodenext</span>
         <span class="s0">* import {} from &quot;mod&quot;;</span>
         <span class="s0">* // Result: CommonJS - the import emits as CJS due to `impliedNodeFormat` set by .cts file extension</span>
         <span class="s0">*</span>
         <span class="s0">* // tsc foo.ts --module preserve --moduleResolution bundler</span>
         <span class="s0">* import {} from &quot;mod&quot;;</span>
         <span class="s0">* // Result: ESNext - the import emits as ESM due to `--module preserve` and `--moduleResolution bundler`</span>
         <span class="s0">* // supports conditional imports/exports</span>
         <span class="s0">*</span>
         <span class="s0">* // tsc foo.ts --module preserve --moduleResolution node10</span>
         <span class="s0">* import {} from &quot;mod&quot;;</span>
         <span class="s0">* // Result: undefined - the import emits as ESM due to `--module preserve`, but `--moduleResolution node10`</span>
         <span class="s0">* // does not support conditional imports/exports</span>
         <span class="s0">*</span>
         <span class="s0">* // tsc foo.ts --module commonjs --moduleResolution node10</span>
         <span class="s0">* import type {} from &quot;mod&quot; with { &quot;resolution-mode&quot;: &quot;import&quot; };</span>
         <span class="s0">* // Result: ESNext - conditional imports/exports always supported with &quot;resolution-mode&quot; attribute</span>
         <span class="s0">* ```</span>
         <span class="s0">*/</span>
        <span class="s1">getModeForUsageLocation(file: SourceFile, usage: StringLiteralLike): ResolutionMode;</span>
        <span class="s0">/**</span>
         <span class="s0">* Calculates the final resolution mode for an import at some index within a file's `imports` list. This function only returns a result</span>
         <span class="s0">* when module resolution settings allow differing resolution between ESM imports and CJS requires, or when a mode is explicitly provided</span>
         <span class="s0">* via import attributes, which cause an `import` or `require` condition to be used during resolution regardless of module resolution</span>
         <span class="s0">* settings. In absence of overriding attributes, and in modes that support differing resolution, the result indicates the syntax the</span>
         <span class="s0">* usage would emit to JavaScript. Some examples:</span>
         <span class="s0">*</span>
         <span class="s0">* ```ts</span>
         <span class="s0">* // tsc foo.mts --module nodenext</span>
         <span class="s0">* import {} from &quot;mod&quot;;</span>
         <span class="s0">* // Result: ESNext - the import emits as ESM due to `impliedNodeFormat` set by .mts file extension</span>
         <span class="s0">*</span>
         <span class="s0">* // tsc foo.cts --module nodenext</span>
         <span class="s0">* import {} from &quot;mod&quot;;</span>
         <span class="s0">* // Result: CommonJS - the import emits as CJS due to `impliedNodeFormat` set by .cts file extension</span>
         <span class="s0">*</span>
         <span class="s0">* // tsc foo.ts --module preserve --moduleResolution bundler</span>
         <span class="s0">* import {} from &quot;mod&quot;;</span>
         <span class="s0">* // Result: ESNext - the import emits as ESM due to `--module preserve` and `--moduleResolution bundler`</span>
         <span class="s0">* // supports conditional imports/exports</span>
         <span class="s0">*</span>
         <span class="s0">* // tsc foo.ts --module preserve --moduleResolution node10</span>
         <span class="s0">* import {} from &quot;mod&quot;;</span>
         <span class="s0">* // Result: undefined - the import emits as ESM due to `--module preserve`, but `--moduleResolution node10`</span>
         <span class="s0">* // does not support conditional imports/exports</span>
         <span class="s0">*</span>
         <span class="s0">* // tsc foo.ts --module commonjs --moduleResolution node10</span>
         <span class="s0">* import type {} from &quot;mod&quot; with { &quot;resolution-mode&quot;: &quot;import&quot; };</span>
         <span class="s0">* // Result: ESNext - conditional imports/exports always supported with &quot;resolution-mode&quot; attribute</span>
         <span class="s0">* ```</span>
         <span class="s0">*/</span>
        <span class="s1">getModeForResolutionAtIndex(file: SourceFile, index: number): ResolutionMode;</span>
        <span class="s1">getProjectReferences(): readonly ProjectReference[] | undefined;</span>
        <span class="s1">getResolvedProjectReferences(): readonly (ResolvedProjectReference | undefined)[] | undefined;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ResolvedProjectReference {</span>
        <span class="s1">commandLine: ParsedCommandLine;</span>
        <span class="s1">sourceFile: SourceFile;</span>
        <span class="s1">references?: readonly (ResolvedProjectReference | undefined)[];</span>
    <span class="s1">}</span>
    <span class="s1">type CustomTransformerFactory = (context: TransformationContext) =&gt; CustomTransformer;</span>
    <span class="s2">interface </span><span class="s1">CustomTransformer {</span>
        <span class="s1">transformSourceFile(node: SourceFile): SourceFile;</span>
        <span class="s1">transformBundle(node: Bundle): Bundle;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">CustomTransformers {</span>
        <span class="s0">/** Custom transformers to evaluate before built-in .js transformations. */</span>
        <span class="s1">before?: (TransformerFactory&lt;SourceFile&gt; | CustomTransformerFactory)[];</span>
        <span class="s0">/** Custom transformers to evaluate after built-in .js transformations. */</span>
        <span class="s1">after?: (TransformerFactory&lt;SourceFile&gt; | CustomTransformerFactory)[];</span>
        <span class="s0">/** Custom transformers to evaluate after built-in .d.ts transformations. */</span>
        <span class="s1">afterDeclarations?: (TransformerFactory&lt;Bundle | SourceFile&gt; | CustomTransformerFactory)[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SourceMapSpan {</span>
        <span class="s0">/** Line number in the .js file. */</span>
        <span class="s1">emittedLine: number;</span>
        <span class="s0">/** Column number in the .js file. */</span>
        <span class="s1">emittedColumn: number;</span>
        <span class="s0">/** Line number in the .ts file. */</span>
        <span class="s1">sourceLine: number;</span>
        <span class="s0">/** Column number in the .ts file. */</span>
        <span class="s1">sourceColumn: number;</span>
        <span class="s0">/** Optional name (index into names array) associated with this span. */</span>
        <span class="s1">nameIndex?: number;</span>
        <span class="s0">/** .ts file (index into sources array) associated with this span */</span>
        <span class="s1">sourceIndex: number;</span>
    <span class="s1">}</span>
    <span class="s0">/** Return code used by getEmitOutput function to indicate status of the function */</span>
    <span class="s2">enum </span><span class="s1">ExitStatus {</span>
        <span class="s1">Success = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">DiagnosticsPresent_OutputsSkipped = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">DiagnosticsPresent_OutputsGenerated = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">InvalidProject_OutputsSkipped = </span><span class="s5">3</span><span class="s1">,</span>
        <span class="s1">ProjectReferenceCycle_OutputsSkipped = </span><span class="s5">4</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">EmitResult {</span>
        <span class="s1">emitSkipped: boolean;</span>
        <span class="s0">/** Contains declaration emit diagnostics */</span>
        <span class="s1">diagnostics: readonly Diagnostic[];</span>
        <span class="s1">emittedFiles?: string[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TypeChecker {</span>
        <span class="s1">getTypeOfSymbolAtLocation(symbol: Symbol, node: Node): Type;</span>
        <span class="s1">getTypeOfSymbol(symbol: Symbol): Type;</span>
        <span class="s1">getDeclaredTypeOfSymbol(symbol: Symbol): Type;</span>
        <span class="s1">getPropertiesOfType(type: Type): Symbol[];</span>
        <span class="s1">getPropertyOfType(type: Type, propertyName: string): Symbol | undefined;</span>
        <span class="s1">getPrivateIdentifierPropertyOfType(leftType: Type, name: string, location: Node): Symbol | undefined;</span>
        <span class="s1">getIndexInfoOfType(type: Type, kind: IndexKind): IndexInfo | undefined;</span>
        <span class="s1">getIndexInfosOfType(type: Type): readonly IndexInfo[];</span>
        <span class="s1">getIndexInfosOfIndexSymbol: (indexSymbol: Symbol, siblingSymbols?: Symbol[] | undefined) =&gt; IndexInfo[];</span>
        <span class="s1">getSignaturesOfType(type: Type, kind: SignatureKind): readonly Signature[];</span>
        <span class="s1">getIndexTypeOfType(type: Type, kind: IndexKind): Type | undefined;</span>
        <span class="s1">getBaseTypes(type: InterfaceType): BaseType[];</span>
        <span class="s1">getBaseTypeOfLiteralType(type: Type): Type;</span>
        <span class="s1">getWidenedType(type: Type): Type;</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets the &quot;awaited type&quot; of a type.</span>
         <span class="s0">*</span>
         <span class="s0">* If an expression has a Promise-like type, the &quot;awaited type&quot; of the expression is</span>
         <span class="s0">* derived from the type of the first argument of the fulfillment callback for that</span>
         <span class="s0">* Promise's `then` method. If the &quot;awaited type&quot; is itself a Promise-like, it is</span>
         <span class="s0">* recursively unwrapped in the same manner until a non-promise type is found.</span>
         <span class="s0">*</span>
         <span class="s0">* If an expression does not have a Promise-like type, its &quot;awaited type&quot; is the type</span>
         <span class="s0">* of the expression.</span>
         <span class="s0">*</span>
         <span class="s0">* If the resulting &quot;awaited type&quot; is a generic object type, then it is wrapped in</span>
         <span class="s0">* an `Awaited&lt;T&gt;`.</span>
         <span class="s0">*</span>
         <span class="s0">* In the event the &quot;awaited type&quot; circularly references itself, or is a non-Promise</span>
         <span class="s0">* object-type with a callable `then()` method, an &quot;awaited type&quot; cannot be determined</span>
         <span class="s0">* and the value `undefined` will be returned.</span>
         <span class="s0">*</span>
         <span class="s0">* This is used to reflect the runtime behavior of the `await` keyword.</span>
         <span class="s0">*/</span>
        <span class="s1">getAwaitedType(type: Type): Type | undefined;</span>
        <span class="s1">getReturnTypeOfSignature(signature: Signature): Type;</span>
        <span class="s1">getNullableType(type: Type, flags: TypeFlags): Type;</span>
        <span class="s1">getNonNullableType(type: Type): Type;</span>
        <span class="s1">getTypeArguments(type: TypeReference): readonly Type[];</span>
        <span class="s0">/** Note that the resulting nodes cannot be checked. */</span>
        <span class="s1">typeToTypeNode(type: Type, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): TypeNode | undefined;</span>
        <span class="s0">/** Note that the resulting nodes cannot be checked. */</span>
        <span class="s1">signatureToSignatureDeclaration(signature: Signature, kind: SyntaxKind, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined):</span>
            <span class="s1">| SignatureDeclaration &amp; {</span>
                <span class="s1">typeArguments?: NodeArray&lt;TypeNode&gt;;</span>
            <span class="s1">}</span>
            <span class="s1">| undefined;</span>
        <span class="s0">/** Note that the resulting nodes cannot be checked. */</span>
        <span class="s1">indexInfoToIndexSignatureDeclaration(indexInfo: IndexInfo, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): IndexSignatureDeclaration | undefined;</span>
        <span class="s0">/** Note that the resulting nodes cannot be checked. */</span>
        <span class="s1">symbolToEntityName(symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): EntityName | undefined;</span>
        <span class="s0">/** Note that the resulting nodes cannot be checked. */</span>
        <span class="s1">symbolToExpression(symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): Expression | undefined;</span>
        <span class="s0">/** Note that the resulting nodes cannot be checked. */</span>
        <span class="s1">symbolToTypeParameterDeclarations(symbol: Symbol, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): NodeArray&lt;TypeParameterDeclaration&gt; | undefined;</span>
        <span class="s0">/** Note that the resulting nodes cannot be checked. */</span>
        <span class="s1">symbolToParameterDeclaration(symbol: Symbol, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): ParameterDeclaration | undefined;</span>
        <span class="s0">/** Note that the resulting nodes cannot be checked. */</span>
        <span class="s1">typeParameterToDeclaration(parameter: TypeParameter, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): TypeParameterDeclaration | undefined;</span>
        <span class="s1">getSymbolsInScope(location: Node, meaning: SymbolFlags): Symbol[];</span>
        <span class="s1">getSymbolAtLocation(node: Node): Symbol | undefined;</span>
        <span class="s1">getSymbolsOfParameterPropertyDeclaration(parameter: ParameterDeclaration, parameterName: string): Symbol[];</span>
        <span class="s0">/**</span>
         <span class="s0">* The function returns the value (local variable) symbol of an identifier in the short-hand property assignment.</span>
         <span class="s0">* This is necessary as an identifier in short-hand property assignment can contains two meaning: property name and property value.</span>
         <span class="s0">*/</span>
        <span class="s1">getShorthandAssignmentValueSymbol(location: Node | undefined): Symbol | undefined;</span>
        <span class="s1">getExportSpecifierLocalTargetSymbol(location: ExportSpecifier | Identifier): Symbol | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* If a symbol is a local symbol with an associated exported symbol, returns the exported symbol.</span>
         <span class="s0">* Otherwise returns its input.</span>
         <span class="s0">* For example, at `export type T = number;`:</span>
         <span class="s0">*     - `getSymbolAtLocation` at the location `T` will return the exported symbol for `T`.</span>
         <span class="s0">*     - But the result of `getSymbolsInScope` will contain the *local* symbol for `T`, not the exported symbol.</span>
         <span class="s0">*     - Calling `getExportSymbolOfSymbol` on that local symbol will return the exported symbol.</span>
         <span class="s0">*/</span>
        <span class="s1">getExportSymbolOfSymbol(symbol: Symbol): Symbol;</span>
        <span class="s1">getPropertySymbolOfDestructuringAssignment(location: Identifier): Symbol | undefined;</span>
        <span class="s1">getTypeOfAssignmentPattern(pattern: AssignmentPattern): Type;</span>
        <span class="s1">getTypeAtLocation(node: Node): Type;</span>
        <span class="s1">getTypeFromTypeNode(node: TypeNode): Type;</span>
        <span class="s1">signatureToString(signature: Signature, enclosingDeclaration?: Node, flags?: TypeFormatFlags, kind?: SignatureKind): string;</span>
        <span class="s1">typeToString(type: Type, enclosingDeclaration?: Node, flags?: TypeFormatFlags): string;</span>
        <span class="s1">symbolToString(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags, flags?: SymbolFormatFlags): string;</span>
        <span class="s1">typePredicateToString(predicate: TypePredicate, enclosingDeclaration?: Node, flags?: TypeFormatFlags): string;</span>
        <span class="s1">getFullyQualifiedName(symbol: Symbol): string;</span>
        <span class="s1">getAugmentedPropertiesOfType(type: Type): Symbol[];</span>
        <span class="s1">getRootSymbols(symbol: Symbol): readonly Symbol[];</span>
        <span class="s1">getSymbolOfExpando(node: Node, allowDeclaration: boolean): Symbol | undefined;</span>
        <span class="s1">getContextualType(node: Expression): Type | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* returns unknownSignature in the case of an error.</span>
         <span class="s0">* returns undefined if the node is not valid.</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">argumentCount Apparent number of arguments, passed in case of a possibly incomplete call. This should come from an ArgumentListInfo. See `signatureHelp.ts`.</span>
         <span class="s0">*/</span>
        <span class="s1">getResolvedSignature(node: CallLikeExpression, candidatesOutArray?: Signature[], argumentCount?: number): Signature | undefined;</span>
        <span class="s1">getSignatureFromDeclaration(declaration: SignatureDeclaration): Signature | undefined;</span>
        <span class="s1">isImplementationOfOverload(node: SignatureDeclaration): boolean | undefined;</span>
        <span class="s1">isUndefinedSymbol(symbol: Symbol): boolean;</span>
        <span class="s1">isArgumentsSymbol(symbol: Symbol): boolean;</span>
        <span class="s1">isUnknownSymbol(symbol: Symbol): boolean;</span>
        <span class="s1">getMergedSymbol(symbol: Symbol): Symbol;</span>
        <span class="s1">getConstantValue(node: EnumMember | PropertyAccessExpression | ElementAccessExpression): string | number | undefined;</span>
        <span class="s1">isValidPropertyAccess(node: PropertyAccessExpression | QualifiedName | ImportTypeNode, propertyName: string): boolean;</span>
        <span class="s0">/** Follow all aliases to get the original symbol. */</span>
        <span class="s1">getAliasedSymbol(symbol: Symbol): Symbol;</span>
        <span class="s0">/** Follow a *single* alias to get the immediately aliased symbol. */</span>
        <span class="s1">getImmediateAliasedSymbol(symbol: Symbol): Symbol | undefined;</span>
        <span class="s1">getExportsOfModule(moduleSymbol: Symbol): Symbol[];</span>
        <span class="s1">getJsxIntrinsicTagNamesAt(location: Node): Symbol[];</span>
        <span class="s1">isOptionalParameter(node: ParameterDeclaration): boolean;</span>
        <span class="s1">getAmbientModules(): Symbol[];</span>
        <span class="s1">tryGetMemberInModuleExports(memberName: string, moduleSymbol: Symbol): Symbol | undefined;</span>
        <span class="s1">getApparentType(type: Type): Type;</span>
        <span class="s1">getBaseConstraintOfType(type: Type): Type | undefined;</span>
        <span class="s1">getDefaultFromTypeParameter(type: Type): Type | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets the intrinsic `any` type. There are multiple types that act as `any` used internally in the compiler,</span>
         <span class="s0">* so the type returned by this function should not be used in equality checks to determine if another type</span>
         <span class="s0">* is `any`. Instead, use `type.flags &amp; TypeFlags.Any`.</span>
         <span class="s0">*/</span>
        <span class="s1">getAnyType(): Type;</span>
        <span class="s1">getStringType(): Type;</span>
        <span class="s1">getStringLiteralType(value: string): StringLiteralType;</span>
        <span class="s1">getNumberType(): Type;</span>
        <span class="s1">getNumberLiteralType(value: number): NumberLiteralType;</span>
        <span class="s1">getBigIntType(): Type;</span>
        <span class="s1">getBigIntLiteralType(value: PseudoBigInt): BigIntLiteralType;</span>
        <span class="s1">getBooleanType(): Type;</span>
        <span class="s1">getUnknownType(): Type;</span>
        <span class="s1">getFalseType(): Type;</span>
        <span class="s1">getTrueType(): Type;</span>
        <span class="s1">getVoidType(): Type;</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets the intrinsic `undefined` type. There are multiple types that act as `undefined` used internally in the compiler</span>
         <span class="s0">* depending on compiler options, so the type returned by this function should not be used in equality checks to determine</span>
         <span class="s0">* if another type is `undefined`. Instead, use `type.flags &amp; TypeFlags.Undefined`.</span>
         <span class="s0">*/</span>
        <span class="s1">getUndefinedType(): Type;</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets the intrinsic `null` type. There are multiple types that act as `null` used internally in the compiler,</span>
         <span class="s0">* so the type returned by this function should not be used in equality checks to determine if another type</span>
         <span class="s0">* is `null`. Instead, use `type.flags &amp; TypeFlags.Null`.</span>
         <span class="s0">*/</span>
        <span class="s1">getNullType(): Type;</span>
        <span class="s1">getESSymbolType(): Type;</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets the intrinsic `never` type. There are multiple types that act as `never` used internally in the compiler,</span>
         <span class="s0">* so the type returned by this function should not be used in equality checks to determine if another type</span>
         <span class="s0">* is `never`. Instead, use `type.flags &amp; TypeFlags.Never`.</span>
         <span class="s0">*/</span>
        <span class="s1">getNeverType(): Type;</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets the intrinsic `object` type.</span>
         <span class="s0">*/</span>
        <span class="s1">getNonPrimitiveType(): Type;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns true if the &quot;source&quot; type is assignable to the &quot;target&quot; type.</span>
         <span class="s0">*</span>
         <span class="s0">* ```ts</span>
         <span class="s0">* declare const abcLiteral: ts.Type; // Type of &quot;abc&quot;</span>
         <span class="s0">* declare const stringType: ts.Type; // Type of string</span>
         <span class="s0">*</span>
         <span class="s0">* isTypeAssignableTo(abcLiteral, abcLiteral); // true; &quot;abc&quot; is assignable to &quot;abc&quot;</span>
         <span class="s0">* isTypeAssignableTo(abcLiteral, stringType); // true; &quot;abc&quot; is assignable to string</span>
         <span class="s0">* isTypeAssignableTo(stringType, abcLiteral); // false; string is not assignable to &quot;abc&quot;</span>
         <span class="s0">* isTypeAssignableTo(stringType, stringType); // true; string is assignable to string</span>
         <span class="s0">* ```</span>
         <span class="s0">*/</span>
        <span class="s1">isTypeAssignableTo(source: Type, target: Type): boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* True if this type is the `Array` or `ReadonlyArray` type from lib.d.ts.</span>
         <span class="s0">* This function will _not_ return true if passed a type which</span>
         <span class="s0">* extends `Array` (for example, the TypeScript AST's `NodeArray` type).</span>
         <span class="s0">*/</span>
        <span class="s1">isArrayType(type: Type): boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* True if this type is a tuple type. This function will _not_ return true if</span>
         <span class="s0">* passed a type which extends from a tuple.</span>
         <span class="s0">*/</span>
        <span class="s1">isTupleType(type: Type): boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* True if this type is assignable to `ReadonlyArray&lt;any&gt;`.</span>
         <span class="s0">*/</span>
        <span class="s1">isArrayLikeType(type: Type): boolean;</span>
        <span class="s1">resolveName(name: string, location: Node | undefined, meaning: SymbolFlags, excludeGlobals: boolean): Symbol | undefined;</span>
        <span class="s1">getTypePredicateOfSignature(signature: Signature): TypePredicate | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* Depending on the operation performed, it may be appropriate to throw away the checker</span>
         <span class="s0">* if the cancellation token is triggered. Typically, if it is used for error checking</span>
         <span class="s0">* and the operation is cancelled, then it should be discarded, otherwise it is safe to keep.</span>
         <span class="s0">*/</span>
        <span class="s1">runWithCancellationToken&lt;T&gt;(token: CancellationToken, cb: (checker: TypeChecker) =&gt; T): T;</span>
        <span class="s1">getTypeArgumentsForResolvedSignature(signature: Signature): readonly Type[] | undefined;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">NodeBuilderFlags {</span>
        <span class="s1">None = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">NoTruncation = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">WriteArrayAsGenericType = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">GenerateNamesForShadowedTypeParams = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">UseStructuralFallback = </span><span class="s5">8</span><span class="s1">,</span>
        <span class="s1">ForbidIndexedAccessSymbolReferences = </span><span class="s5">16</span><span class="s1">,</span>
        <span class="s1">WriteTypeArgumentsOfSignature = </span><span class="s5">32</span><span class="s1">,</span>
        <span class="s1">UseFullyQualifiedType = </span><span class="s5">64</span><span class="s1">,</span>
        <span class="s1">UseOnlyExternalAliasing = </span><span class="s5">128</span><span class="s1">,</span>
        <span class="s1">SuppressAnyReturnType = </span><span class="s5">256</span><span class="s1">,</span>
        <span class="s1">WriteTypeParametersInQualifiedName = </span><span class="s5">512</span><span class="s1">,</span>
        <span class="s1">MultilineObjectLiterals = </span><span class="s5">1024</span><span class="s1">,</span>
        <span class="s1">WriteClassExpressionAsTypeLiteral = </span><span class="s5">2048</span><span class="s1">,</span>
        <span class="s1">UseTypeOfFunction = </span><span class="s5">4096</span><span class="s1">,</span>
        <span class="s1">OmitParameterModifiers = </span><span class="s5">8192</span><span class="s1">,</span>
        <span class="s1">UseAliasDefinedOutsideCurrentScope = </span><span class="s5">16384</span><span class="s1">,</span>
        <span class="s1">UseSingleQuotesForStringLiteralType = </span><span class="s5">268435456</span><span class="s1">,</span>
        <span class="s1">NoTypeReduction = </span><span class="s5">536870912</span><span class="s1">,</span>
        <span class="s1">OmitThisParameter = </span><span class="s5">33554432</span><span class="s1">,</span>
        <span class="s1">AllowThisInObjectLiteral = </span><span class="s5">32768</span><span class="s1">,</span>
        <span class="s1">AllowQualifiedNameInPlaceOfIdentifier = </span><span class="s5">65536</span><span class="s1">,</span>
        <span class="s1">AllowAnonymousIdentifier = </span><span class="s5">131072</span><span class="s1">,</span>
        <span class="s1">AllowEmptyUnionOrIntersection = </span><span class="s5">262144</span><span class="s1">,</span>
        <span class="s1">AllowEmptyTuple = </span><span class="s5">524288</span><span class="s1">,</span>
        <span class="s1">AllowUniqueESSymbolType = </span><span class="s5">1048576</span><span class="s1">,</span>
        <span class="s1">AllowEmptyIndexInfoType = </span><span class="s5">2097152</span><span class="s1">,</span>
        <span class="s1">AllowNodeModulesRelativePaths = </span><span class="s5">67108864</span><span class="s1">,</span>
        <span class="s1">IgnoreErrors = </span><span class="s5">70221824</span><span class="s1">,</span>
        <span class="s1">InObjectTypeLiteral = </span><span class="s5">4194304</span><span class="s1">,</span>
        <span class="s1">InTypeAlias = </span><span class="s5">8388608</span><span class="s1">,</span>
        <span class="s1">InInitialEntityName = </span><span class="s5">16777216</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">TypeFormatFlags {</span>
        <span class="s1">None = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">NoTruncation = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">WriteArrayAsGenericType = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">GenerateNamesForShadowedTypeParams = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">UseStructuralFallback = </span><span class="s5">8</span><span class="s1">,</span>
        <span class="s1">WriteTypeArgumentsOfSignature = </span><span class="s5">32</span><span class="s1">,</span>
        <span class="s1">UseFullyQualifiedType = </span><span class="s5">64</span><span class="s1">,</span>
        <span class="s1">SuppressAnyReturnType = </span><span class="s5">256</span><span class="s1">,</span>
        <span class="s1">MultilineObjectLiterals = </span><span class="s5">1024</span><span class="s1">,</span>
        <span class="s1">WriteClassExpressionAsTypeLiteral = </span><span class="s5">2048</span><span class="s1">,</span>
        <span class="s1">UseTypeOfFunction = </span><span class="s5">4096</span><span class="s1">,</span>
        <span class="s1">OmitParameterModifiers = </span><span class="s5">8192</span><span class="s1">,</span>
        <span class="s1">UseAliasDefinedOutsideCurrentScope = </span><span class="s5">16384</span><span class="s1">,</span>
        <span class="s1">UseSingleQuotesForStringLiteralType = </span><span class="s5">268435456</span><span class="s1">,</span>
        <span class="s1">NoTypeReduction = </span><span class="s5">536870912</span><span class="s1">,</span>
        <span class="s1">OmitThisParameter = </span><span class="s5">33554432</span><span class="s1">,</span>
        <span class="s1">AllowUniqueESSymbolType = </span><span class="s5">1048576</span><span class="s1">,</span>
        <span class="s1">AddUndefined = </span><span class="s5">131072</span><span class="s1">,</span>
        <span class="s1">WriteArrowStyleSignature = </span><span class="s5">262144</span><span class="s1">,</span>
        <span class="s1">InArrayType = </span><span class="s5">524288</span><span class="s1">,</span>
        <span class="s1">InElementType = </span><span class="s5">2097152</span><span class="s1">,</span>
        <span class="s1">InFirstTypeArgument = </span><span class="s5">4194304</span><span class="s1">,</span>
        <span class="s1">InTypeAlias = </span><span class="s5">8388608</span><span class="s1">,</span>
        <span class="s1">NodeBuilderFlagsMask = </span><span class="s5">848330095</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">SymbolFormatFlags {</span>
        <span class="s1">None = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">WriteTypeParametersOrArguments = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">UseOnlyExternalAliasing = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">AllowAnyNodeKind = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">UseAliasDefinedOutsideCurrentScope = </span><span class="s5">8</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">TypePredicateKind {</span>
        <span class="s1">This = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">Identifier = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">AssertsThis = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">AssertsIdentifier = </span><span class="s5">3</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TypePredicateBase {</span>
        <span class="s1">kind: TypePredicateKind;</span>
        <span class="s1">type: Type | undefined;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ThisTypePredicate </span><span class="s2">extends </span><span class="s1">TypePredicateBase {</span>
        <span class="s1">kind: TypePredicateKind.This;</span>
        <span class="s1">parameterName: undefined;</span>
        <span class="s1">parameterIndex: undefined;</span>
        <span class="s1">type: Type;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">IdentifierTypePredicate </span><span class="s2">extends </span><span class="s1">TypePredicateBase {</span>
        <span class="s1">kind: TypePredicateKind.Identifier;</span>
        <span class="s1">parameterName: string;</span>
        <span class="s1">parameterIndex: number;</span>
        <span class="s1">type: Type;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">AssertsThisTypePredicate </span><span class="s2">extends </span><span class="s1">TypePredicateBase {</span>
        <span class="s1">kind: TypePredicateKind.AssertsThis;</span>
        <span class="s1">parameterName: undefined;</span>
        <span class="s1">parameterIndex: undefined;</span>
        <span class="s1">type: Type | undefined;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">AssertsIdentifierTypePredicate </span><span class="s2">extends </span><span class="s1">TypePredicateBase {</span>
        <span class="s1">kind: TypePredicateKind.AssertsIdentifier;</span>
        <span class="s1">parameterName: string;</span>
        <span class="s1">parameterIndex: number;</span>
        <span class="s1">type: Type | undefined;</span>
    <span class="s1">}</span>
    <span class="s1">type TypePredicate = ThisTypePredicate | IdentifierTypePredicate | AssertsThisTypePredicate | AssertsIdentifierTypePredicate;</span>
    <span class="s2">enum </span><span class="s1">SymbolFlags {</span>
        <span class="s1">None = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">FunctionScopedVariable = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">BlockScopedVariable = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">Property = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">EnumMember = </span><span class="s5">8</span><span class="s1">,</span>
        <span class="s1">Function = </span><span class="s5">16</span><span class="s1">,</span>
        <span class="s1">Class = </span><span class="s5">32</span><span class="s1">,</span>
        <span class="s1">Interface = </span><span class="s5">64</span><span class="s1">,</span>
        <span class="s1">ConstEnum = </span><span class="s5">128</span><span class="s1">,</span>
        <span class="s1">RegularEnum = </span><span class="s5">256</span><span class="s1">,</span>
        <span class="s1">ValueModule = </span><span class="s5">512</span><span class="s1">,</span>
        <span class="s1">NamespaceModule = </span><span class="s5">1024</span><span class="s1">,</span>
        <span class="s1">TypeLiteral = </span><span class="s5">2048</span><span class="s1">,</span>
        <span class="s1">ObjectLiteral = </span><span class="s5">4096</span><span class="s1">,</span>
        <span class="s1">Method = </span><span class="s5">8192</span><span class="s1">,</span>
        <span class="s1">Constructor = </span><span class="s5">16384</span><span class="s1">,</span>
        <span class="s1">GetAccessor = </span><span class="s5">32768</span><span class="s1">,</span>
        <span class="s1">SetAccessor = </span><span class="s5">65536</span><span class="s1">,</span>
        <span class="s1">Signature = </span><span class="s5">131072</span><span class="s1">,</span>
        <span class="s1">TypeParameter = </span><span class="s5">262144</span><span class="s1">,</span>
        <span class="s1">TypeAlias = </span><span class="s5">524288</span><span class="s1">,</span>
        <span class="s1">ExportValue = </span><span class="s5">1048576</span><span class="s1">,</span>
        <span class="s1">Alias = </span><span class="s5">2097152</span><span class="s1">,</span>
        <span class="s1">Prototype = </span><span class="s5">4194304</span><span class="s1">,</span>
        <span class="s1">ExportStar = </span><span class="s5">8388608</span><span class="s1">,</span>
        <span class="s1">Optional = </span><span class="s5">16777216</span><span class="s1">,</span>
        <span class="s1">Transient = </span><span class="s5">33554432</span><span class="s1">,</span>
        <span class="s1">Assignment = </span><span class="s5">67108864</span><span class="s1">,</span>
        <span class="s1">ModuleExports = </span><span class="s5">134217728</span><span class="s1">,</span>
        <span class="s1">All = -</span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">Enum = </span><span class="s5">384</span><span class="s1">,</span>
        <span class="s1">Variable = </span><span class="s5">3</span><span class="s1">,</span>
        <span class="s1">Value = </span><span class="s5">111551</span><span class="s1">,</span>
        <span class="s1">Type = </span><span class="s5">788968</span><span class="s1">,</span>
        <span class="s1">Namespace = </span><span class="s5">1920</span><span class="s1">,</span>
        <span class="s1">Module = </span><span class="s5">1536</span><span class="s1">,</span>
        <span class="s1">Accessor = </span><span class="s5">98304</span><span class="s1">,</span>
        <span class="s1">FunctionScopedVariableExcludes = </span><span class="s5">111550</span><span class="s1">,</span>
        <span class="s1">BlockScopedVariableExcludes = </span><span class="s5">111551</span><span class="s1">,</span>
        <span class="s1">ParameterExcludes = </span><span class="s5">111551</span><span class="s1">,</span>
        <span class="s1">PropertyExcludes = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">EnumMemberExcludes = </span><span class="s5">900095</span><span class="s1">,</span>
        <span class="s1">FunctionExcludes = </span><span class="s5">110991</span><span class="s1">,</span>
        <span class="s1">ClassExcludes = </span><span class="s5">899503</span><span class="s1">,</span>
        <span class="s1">InterfaceExcludes = </span><span class="s5">788872</span><span class="s1">,</span>
        <span class="s1">RegularEnumExcludes = </span><span class="s5">899327</span><span class="s1">,</span>
        <span class="s1">ConstEnumExcludes = </span><span class="s5">899967</span><span class="s1">,</span>
        <span class="s1">ValueModuleExcludes = </span><span class="s5">110735</span><span class="s1">,</span>
        <span class="s1">NamespaceModuleExcludes = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">MethodExcludes = </span><span class="s5">103359</span><span class="s1">,</span>
        <span class="s1">GetAccessorExcludes = </span><span class="s5">46015</span><span class="s1">,</span>
        <span class="s1">SetAccessorExcludes = </span><span class="s5">78783</span><span class="s1">,</span>
        <span class="s1">AccessorExcludes = </span><span class="s5">13247</span><span class="s1">,</span>
        <span class="s1">TypeParameterExcludes = </span><span class="s5">526824</span><span class="s1">,</span>
        <span class="s1">TypeAliasExcludes = </span><span class="s5">788968</span><span class="s1">,</span>
        <span class="s1">AliasExcludes = </span><span class="s5">2097152</span><span class="s1">,</span>
        <span class="s1">ModuleMember = </span><span class="s5">2623475</span><span class="s1">,</span>
        <span class="s1">ExportHasLocal = </span><span class="s5">944</span><span class="s1">,</span>
        <span class="s1">BlockScoped = </span><span class="s5">418</span><span class="s1">,</span>
        <span class="s1">PropertyOrAccessor = </span><span class="s5">98308</span><span class="s1">,</span>
        <span class="s1">ClassMember = </span><span class="s5">106500</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">Symbol {</span>
        <span class="s1">flags: SymbolFlags;</span>
        <span class="s1">escapedName: __String;</span>
        <span class="s1">declarations?: Declaration[];</span>
        <span class="s1">valueDeclaration?: Declaration;</span>
        <span class="s1">members?: SymbolTable;</span>
        <span class="s1">exports?: SymbolTable;</span>
        <span class="s1">globalExports?: SymbolTable;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">Symbol {</span>
        <span class="s1">readonly name: string;</span>
        <span class="s1">getFlags(): SymbolFlags;</span>
        <span class="s1">getEscapedName(): __String;</span>
        <span class="s1">getName(): string;</span>
        <span class="s1">getDeclarations(): Declaration[] | undefined;</span>
        <span class="s1">getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];</span>
        <span class="s1">getJsDocTags(checker?: TypeChecker): JSDocTagInfo[];</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">InternalSymbolName {</span>
        <span class="s1">Call = </span><span class="s3">&quot;__call&quot;</span><span class="s1">,</span>
        <span class="s1">Constructor = </span><span class="s3">&quot;__constructor&quot;</span><span class="s1">,</span>
        <span class="s1">New = </span><span class="s3">&quot;__new&quot;</span><span class="s1">,</span>
        <span class="s1">Index = </span><span class="s3">&quot;__index&quot;</span><span class="s1">,</span>
        <span class="s1">ExportStar = </span><span class="s3">&quot;__export&quot;</span><span class="s1">,</span>
        <span class="s1">Global = </span><span class="s3">&quot;__global&quot;</span><span class="s1">,</span>
        <span class="s1">Missing = </span><span class="s3">&quot;__missing&quot;</span><span class="s1">,</span>
        <span class="s1">Type = </span><span class="s3">&quot;__type&quot;</span><span class="s1">,</span>
        <span class="s1">Object = </span><span class="s3">&quot;__object&quot;</span><span class="s1">,</span>
        <span class="s1">JSXAttributes = </span><span class="s3">&quot;__jsxAttributes&quot;</span><span class="s1">,</span>
        <span class="s1">Class = </span><span class="s3">&quot;__class&quot;</span><span class="s1">,</span>
        <span class="s1">Function = </span><span class="s3">&quot;__function&quot;</span><span class="s1">,</span>
        <span class="s1">Computed = </span><span class="s3">&quot;__computed&quot;</span><span class="s1">,</span>
        <span class="s1">Resolving = </span><span class="s3">&quot;__resolving__&quot;</span><span class="s1">,</span>
        <span class="s1">ExportEquals = </span><span class="s3">&quot;export=&quot;</span><span class="s1">,</span>
        <span class="s1">Default = </span><span class="s3">&quot;default&quot;</span><span class="s1">,</span>
        <span class="s1">This = </span><span class="s3">&quot;this&quot;</span><span class="s1">,</span>
        <span class="s1">InstantiationExpression = </span><span class="s3">&quot;__instantiationExpression&quot;</span><span class="s1">,</span>
        <span class="s1">ImportAttributes = </span><span class="s3">&quot;__importAttributes&quot;</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* This represents a string whose leading underscore have been escaped by adding extra leading underscores.</span>
     <span class="s0">* The shape of this brand is rather unique compared to others we've used.</span>
     <span class="s0">* Instead of just an intersection of a string and an object, it is that union-ed</span>
     <span class="s0">* with an intersection of void and an object. This makes it wholly incompatible</span>
     <span class="s0">* with a normal string (which is good, it cannot be misused on assignment or on usage),</span>
     <span class="s0">* while still being comparable with a normal string via === (also good) and castable from a string.</span>
     <span class="s0">*/</span>
    <span class="s1">type __String =</span>
        <span class="s1">| (string &amp; {</span>
            <span class="s1">__escapedIdentifier: </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">})</span>
        <span class="s1">| (</span><span class="s2">void </span><span class="s1">&amp; {</span>
            <span class="s1">__escapedIdentifier: </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">})</span>
        <span class="s1">| InternalSymbolName;</span>
    <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">Use ReadonlyMap&lt;__String, T&gt; instead. */</span>
    <span class="s1">type ReadonlyUnderscoreEscapedMap&lt;T&gt; = ReadonlyMap&lt;__String, T&gt;;</span>
    <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">Use Map&lt;__String, T&gt; instead. */</span>
    <span class="s1">type UnderscoreEscapedMap&lt;T&gt; = Map&lt;__String, T&gt;;</span>
    <span class="s0">/** SymbolTable based on ES6 Map interface. */</span>
    <span class="s1">type SymbolTable = Map&lt;__String, Symbol&gt;;</span>
    <span class="s2">enum </span><span class="s1">TypeFlags {</span>
        <span class="s1">Any = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">Unknown = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">String = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">Number = </span><span class="s5">8</span><span class="s1">,</span>
        <span class="s1">Boolean = </span><span class="s5">16</span><span class="s1">,</span>
        <span class="s1">Enum = </span><span class="s5">32</span><span class="s1">,</span>
        <span class="s1">BigInt = </span><span class="s5">64</span><span class="s1">,</span>
        <span class="s1">StringLiteral = </span><span class="s5">128</span><span class="s1">,</span>
        <span class="s1">NumberLiteral = </span><span class="s5">256</span><span class="s1">,</span>
        <span class="s1">BooleanLiteral = </span><span class="s5">512</span><span class="s1">,</span>
        <span class="s1">EnumLiteral = </span><span class="s5">1024</span><span class="s1">,</span>
        <span class="s1">BigIntLiteral = </span><span class="s5">2048</span><span class="s1">,</span>
        <span class="s1">ESSymbol = </span><span class="s5">4096</span><span class="s1">,</span>
        <span class="s1">UniqueESSymbol = </span><span class="s5">8192</span><span class="s1">,</span>
        <span class="s1">Void = </span><span class="s5">16384</span><span class="s1">,</span>
        <span class="s1">Undefined = </span><span class="s5">32768</span><span class="s1">,</span>
        <span class="s1">Null = </span><span class="s5">65536</span><span class="s1">,</span>
        <span class="s1">Never = </span><span class="s5">131072</span><span class="s1">,</span>
        <span class="s1">TypeParameter = </span><span class="s5">262144</span><span class="s1">,</span>
        <span class="s1">Object = </span><span class="s5">524288</span><span class="s1">,</span>
        <span class="s1">Union = </span><span class="s5">1048576</span><span class="s1">,</span>
        <span class="s1">Intersection = </span><span class="s5">2097152</span><span class="s1">,</span>
        <span class="s1">Index = </span><span class="s5">4194304</span><span class="s1">,</span>
        <span class="s1">IndexedAccess = </span><span class="s5">8388608</span><span class="s1">,</span>
        <span class="s1">Conditional = </span><span class="s5">16777216</span><span class="s1">,</span>
        <span class="s1">Substitution = </span><span class="s5">33554432</span><span class="s1">,</span>
        <span class="s1">NonPrimitive = </span><span class="s5">67108864</span><span class="s1">,</span>
        <span class="s1">TemplateLiteral = </span><span class="s5">134217728</span><span class="s1">,</span>
        <span class="s1">StringMapping = </span><span class="s5">268435456</span><span class="s1">,</span>
        <span class="s1">Literal = </span><span class="s5">2944</span><span class="s1">,</span>
        <span class="s1">Unit = </span><span class="s5">109472</span><span class="s1">,</span>
        <span class="s1">Freshable = </span><span class="s5">2976</span><span class="s1">,</span>
        <span class="s1">StringOrNumberLiteral = </span><span class="s5">384</span><span class="s1">,</span>
        <span class="s1">PossiblyFalsy = </span><span class="s5">117724</span><span class="s1">,</span>
        <span class="s1">StringLike = </span><span class="s5">402653316</span><span class="s1">,</span>
        <span class="s1">NumberLike = </span><span class="s5">296</span><span class="s1">,</span>
        <span class="s1">BigIntLike = </span><span class="s5">2112</span><span class="s1">,</span>
        <span class="s1">BooleanLike = </span><span class="s5">528</span><span class="s1">,</span>
        <span class="s1">EnumLike = </span><span class="s5">1056</span><span class="s1">,</span>
        <span class="s1">ESSymbolLike = </span><span class="s5">12288</span><span class="s1">,</span>
        <span class="s1">VoidLike = </span><span class="s5">49152</span><span class="s1">,</span>
        <span class="s1">UnionOrIntersection = </span><span class="s5">3145728</span><span class="s1">,</span>
        <span class="s1">StructuredType = </span><span class="s5">3670016</span><span class="s1">,</span>
        <span class="s1">TypeVariable = </span><span class="s5">8650752</span><span class="s1">,</span>
        <span class="s1">InstantiableNonPrimitive = </span><span class="s5">58982400</span><span class="s1">,</span>
        <span class="s1">InstantiablePrimitive = </span><span class="s5">406847488</span><span class="s1">,</span>
        <span class="s1">Instantiable = </span><span class="s5">465829888</span><span class="s1">,</span>
        <span class="s1">StructuredOrInstantiable = </span><span class="s5">469499904</span><span class="s1">,</span>
        <span class="s1">Narrowable = </span><span class="s5">536624127</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s1">type DestructuringPattern = BindingPattern | ObjectLiteralExpression | ArrayLiteralExpression;</span>
    <span class="s2">interface </span><span class="s1">Type {</span>
        <span class="s1">flags: TypeFlags;</span>
        <span class="s1">symbol: Symbol;</span>
        <span class="s1">pattern?: DestructuringPattern;</span>
        <span class="s1">aliasSymbol?: Symbol;</span>
        <span class="s1">aliasTypeArguments?: readonly Type[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">Type {</span>
        <span class="s1">getFlags(): TypeFlags;</span>
        <span class="s1">getSymbol(): Symbol | undefined;</span>
        <span class="s1">getProperties(): Symbol[];</span>
        <span class="s1">getProperty(propertyName: string): Symbol | undefined;</span>
        <span class="s1">getApparentProperties(): Symbol[];</span>
        <span class="s1">getCallSignatures(): readonly Signature[];</span>
        <span class="s1">getConstructSignatures(): readonly Signature[];</span>
        <span class="s1">getStringIndexType(): Type | undefined;</span>
        <span class="s1">getNumberIndexType(): Type | undefined;</span>
        <span class="s1">getBaseTypes(): BaseType[] | undefined;</span>
        <span class="s1">getNonNullableType(): Type;</span>
        <span class="s1">getConstraint(): Type | undefined;</span>
        <span class="s1">getDefault(): Type | undefined;</span>
        <span class="s1">isUnion(): </span><span class="s2">this </span><span class="s1">is UnionType;</span>
        <span class="s1">isIntersection(): </span><span class="s2">this </span><span class="s1">is IntersectionType;</span>
        <span class="s1">isUnionOrIntersection(): </span><span class="s2">this </span><span class="s1">is UnionOrIntersectionType;</span>
        <span class="s1">isLiteral(): </span><span class="s2">this </span><span class="s1">is LiteralType;</span>
        <span class="s1">isStringLiteral(): </span><span class="s2">this </span><span class="s1">is StringLiteralType;</span>
        <span class="s1">isNumberLiteral(): </span><span class="s2">this </span><span class="s1">is NumberLiteralType;</span>
        <span class="s1">isTypeParameter(): </span><span class="s2">this </span><span class="s1">is TypeParameter;</span>
        <span class="s1">isClassOrInterface(): </span><span class="s2">this </span><span class="s1">is InterfaceType;</span>
        <span class="s1">isClass(): </span><span class="s2">this </span><span class="s1">is InterfaceType;</span>
        <span class="s1">isIndexType(): </span><span class="s2">this </span><span class="s1">is IndexType;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">FreshableType </span><span class="s2">extends </span><span class="s1">Type {</span>
        <span class="s1">freshType: FreshableType;</span>
        <span class="s1">regularType: FreshableType;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">LiteralType </span><span class="s2">extends </span><span class="s1">FreshableType {</span>
        <span class="s1">value: string | number | PseudoBigInt;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">UniqueESSymbolType </span><span class="s2">extends </span><span class="s1">Type {</span>
        <span class="s1">symbol: Symbol;</span>
        <span class="s1">escapedName: __String;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">StringLiteralType </span><span class="s2">extends </span><span class="s1">LiteralType {</span>
        <span class="s1">value: string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">NumberLiteralType </span><span class="s2">extends </span><span class="s1">LiteralType {</span>
        <span class="s1">value: number;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">BigIntLiteralType </span><span class="s2">extends </span><span class="s1">LiteralType {</span>
        <span class="s1">value: PseudoBigInt;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">EnumType </span><span class="s2">extends </span><span class="s1">FreshableType {</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">ObjectFlags {</span>
        <span class="s1">None = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">Class = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">Interface = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">Reference = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">Tuple = </span><span class="s5">8</span><span class="s1">,</span>
        <span class="s1">Anonymous = </span><span class="s5">16</span><span class="s1">,</span>
        <span class="s1">Mapped = </span><span class="s5">32</span><span class="s1">,</span>
        <span class="s1">Instantiated = </span><span class="s5">64</span><span class="s1">,</span>
        <span class="s1">ObjectLiteral = </span><span class="s5">128</span><span class="s1">,</span>
        <span class="s1">EvolvingArray = </span><span class="s5">256</span><span class="s1">,</span>
        <span class="s1">ObjectLiteralPatternWithComputedProperties = </span><span class="s5">512</span><span class="s1">,</span>
        <span class="s1">ReverseMapped = </span><span class="s5">1024</span><span class="s1">,</span>
        <span class="s1">JsxAttributes = </span><span class="s5">2048</span><span class="s1">,</span>
        <span class="s1">JSLiteral = </span><span class="s5">4096</span><span class="s1">,</span>
        <span class="s1">FreshLiteral = </span><span class="s5">8192</span><span class="s1">,</span>
        <span class="s1">ArrayLiteral = </span><span class="s5">16384</span><span class="s1">,</span>
        <span class="s1">SingleSignatureType = </span><span class="s5">134217728</span><span class="s1">,</span>
        <span class="s1">ClassOrInterface = </span><span class="s5">3</span><span class="s1">,</span>
        <span class="s1">ContainsSpread = </span><span class="s5">2097152</span><span class="s1">,</span>
        <span class="s1">ObjectRestType = </span><span class="s5">4194304</span><span class="s1">,</span>
        <span class="s1">InstantiationExpressionType = </span><span class="s5">8388608</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ObjectType </span><span class="s2">extends </span><span class="s1">Type {</span>
        <span class="s1">objectFlags: ObjectFlags;</span>
    <span class="s1">}</span>
    <span class="s0">/** Class and interface types (ObjectFlags.Class and ObjectFlags.Interface). */</span>
    <span class="s2">interface </span><span class="s1">InterfaceType </span><span class="s2">extends </span><span class="s1">ObjectType {</span>
        <span class="s1">typeParameters: TypeParameter[] | undefined;</span>
        <span class="s1">outerTypeParameters: TypeParameter[] | undefined;</span>
        <span class="s1">localTypeParameters: TypeParameter[] | undefined;</span>
        <span class="s1">thisType: TypeParameter | undefined;</span>
    <span class="s1">}</span>
    <span class="s1">type BaseType = ObjectType | IntersectionType | TypeVariable;</span>
    <span class="s2">interface </span><span class="s1">InterfaceTypeWithDeclaredMembers </span><span class="s2">extends </span><span class="s1">InterfaceType {</span>
        <span class="s1">declaredProperties: Symbol[];</span>
        <span class="s1">declaredCallSignatures: Signature[];</span>
        <span class="s1">declaredConstructSignatures: Signature[];</span>
        <span class="s1">declaredIndexInfos: IndexInfo[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Type references (ObjectFlags.Reference). When a class or interface has type parameters or</span>
     <span class="s0">* a &quot;this&quot; type, references to the class or interface are made using type references. The</span>
     <span class="s0">* typeArguments property specifies the types to substitute for the type parameters of the</span>
     <span class="s0">* class or interface and optionally includes an extra element that specifies the type to</span>
     <span class="s0">* substitute for &quot;this&quot; in the resulting instantiation. When no extra argument is present,</span>
     <span class="s0">* the type reference itself is substituted for &quot;this&quot;. The typeArguments property is undefined</span>
     <span class="s0">* if the class or interface has no type parameters and the reference isn't specifying an</span>
     <span class="s0">* explicit &quot;this&quot; argument.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">TypeReference </span><span class="s2">extends </span><span class="s1">ObjectType {</span>
        <span class="s1">target: GenericType;</span>
        <span class="s1">node?: TypeReferenceNode | ArrayTypeNode | TupleTypeNode;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TypeReference {</span>
        <span class="s1">typeArguments?: readonly Type[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">DeferredTypeReference </span><span class="s2">extends </span><span class="s1">TypeReference {</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">GenericType </span><span class="s2">extends </span><span class="s1">InterfaceType, TypeReference {</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">ElementFlags {</span>
        <span class="s1">Required = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">Optional = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">Rest = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">Variadic = </span><span class="s5">8</span><span class="s1">,</span>
        <span class="s1">Fixed = </span><span class="s5">3</span><span class="s1">,</span>
        <span class="s1">Variable = </span><span class="s5">12</span><span class="s1">,</span>
        <span class="s1">NonRequired = </span><span class="s5">14</span><span class="s1">,</span>
        <span class="s1">NonRest = </span><span class="s5">11</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TupleType </span><span class="s2">extends </span><span class="s1">GenericType {</span>
        <span class="s1">elementFlags: readonly ElementFlags[];</span>
        <span class="s0">/** Number of required or variadic elements */</span>
        <span class="s1">minLength: number;</span>
        <span class="s0">/** Number of initial required or optional elements */</span>
        <span class="s1">fixedLength: number;</span>
        <span class="s0">/**</span>
         <span class="s0">* True if tuple has any rest or variadic elements</span>
         <span class="s0">*</span>
         <span class="s0">* </span><span class="s4">@deprecated </span><span class="s0">Use `.combinedFlags &amp; ElementFlags.Variable` instead</span>
         <span class="s0">*/</span>
        <span class="s1">hasRestElement: boolean;</span>
        <span class="s1">combinedFlags: ElementFlags;</span>
        <span class="s1">readonly: boolean;</span>
        <span class="s1">labeledElementDeclarations?: readonly (NamedTupleMember | ParameterDeclaration | undefined)[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TupleTypeReference </span><span class="s2">extends </span><span class="s1">TypeReference {</span>
        <span class="s1">target: TupleType;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">UnionOrIntersectionType </span><span class="s2">extends </span><span class="s1">Type {</span>
        <span class="s1">types: Type[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">UnionType </span><span class="s2">extends </span><span class="s1">UnionOrIntersectionType {</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">IntersectionType </span><span class="s2">extends </span><span class="s1">UnionOrIntersectionType {</span>
    <span class="s1">}</span>
    <span class="s1">type StructuredType = ObjectType | UnionType | IntersectionType;</span>
    <span class="s2">interface </span><span class="s1">EvolvingArrayType </span><span class="s2">extends </span><span class="s1">ObjectType {</span>
        <span class="s1">elementType: Type;</span>
        <span class="s1">finalArrayType?: Type;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">InstantiableType </span><span class="s2">extends </span><span class="s1">Type {</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TypeParameter </span><span class="s2">extends </span><span class="s1">InstantiableType {</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">IndexedAccessType </span><span class="s2">extends </span><span class="s1">InstantiableType {</span>
        <span class="s1">objectType: Type;</span>
        <span class="s1">indexType: Type;</span>
        <span class="s1">constraint?: Type;</span>
        <span class="s1">simplifiedForReading?: Type;</span>
        <span class="s1">simplifiedForWriting?: Type;</span>
    <span class="s1">}</span>
    <span class="s1">type TypeVariable = TypeParameter | IndexedAccessType;</span>
    <span class="s2">interface </span><span class="s1">IndexType </span><span class="s2">extends </span><span class="s1">InstantiableType {</span>
        <span class="s1">type: InstantiableType | UnionOrIntersectionType;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ConditionalRoot {</span>
        <span class="s1">node: ConditionalTypeNode;</span>
        <span class="s1">checkType: Type;</span>
        <span class="s1">extendsType: Type;</span>
        <span class="s1">isDistributive: boolean;</span>
        <span class="s1">inferTypeParameters?: TypeParameter[];</span>
        <span class="s1">outerTypeParameters?: TypeParameter[];</span>
        <span class="s1">instantiations?: Map&lt;string, Type&gt;;</span>
        <span class="s1">aliasSymbol?: Symbol;</span>
        <span class="s1">aliasTypeArguments?: Type[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ConditionalType </span><span class="s2">extends </span><span class="s1">InstantiableType {</span>
        <span class="s1">root: ConditionalRoot;</span>
        <span class="s1">checkType: Type;</span>
        <span class="s1">extendsType: Type;</span>
        <span class="s1">resolvedTrueType?: Type;</span>
        <span class="s1">resolvedFalseType?: Type;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TemplateLiteralType </span><span class="s2">extends </span><span class="s1">InstantiableType {</span>
        <span class="s1">texts: readonly string[];</span>
        <span class="s1">types: readonly Type[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">StringMappingType </span><span class="s2">extends </span><span class="s1">InstantiableType {</span>
        <span class="s1">symbol: Symbol;</span>
        <span class="s1">type: Type;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SubstitutionType </span><span class="s2">extends </span><span class="s1">InstantiableType {</span>
        <span class="s1">objectFlags: ObjectFlags;</span>
        <span class="s1">baseType: Type;</span>
        <span class="s1">constraint: Type;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">SignatureKind {</span>
        <span class="s1">Call = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">Construct = </span><span class="s5">1</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">Signature {</span>
        <span class="s1">declaration?: SignatureDeclaration | JSDocSignature;</span>
        <span class="s1">typeParameters?: readonly TypeParameter[];</span>
        <span class="s1">parameters: readonly Symbol[];</span>
        <span class="s1">thisParameter?: Symbol;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">Signature {</span>
        <span class="s1">getDeclaration(): SignatureDeclaration;</span>
        <span class="s1">getTypeParameters(): TypeParameter[] | undefined;</span>
        <span class="s1">getParameters(): Symbol[];</span>
        <span class="s1">getTypeParameterAtPosition(pos: number): Type;</span>
        <span class="s1">getReturnType(): Type;</span>
        <span class="s1">getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];</span>
        <span class="s1">getJsDocTags(): JSDocTagInfo[];</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">IndexKind {</span>
        <span class="s1">String = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">Number = </span><span class="s5">1</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s1">type ElementWithComputedPropertyName = (ClassElement | ObjectLiteralElement) &amp; {</span>
        <span class="s1">name: ComputedPropertyName;</span>
    <span class="s1">};</span>
    <span class="s2">interface </span><span class="s1">IndexInfo {</span>
        <span class="s1">keyType: Type;</span>
        <span class="s1">type: Type;</span>
        <span class="s1">isReadonly: boolean;</span>
        <span class="s1">declaration?: IndexSignatureDeclaration;</span>
        <span class="s1">components?: ElementWithComputedPropertyName[];</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">InferencePriority {</span>
        <span class="s1">None = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">NakedTypeVariable = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">SpeculativeTuple = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">SubstituteSource = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">HomomorphicMappedType = </span><span class="s5">8</span><span class="s1">,</span>
        <span class="s1">PartialHomomorphicMappedType = </span><span class="s5">16</span><span class="s1">,</span>
        <span class="s1">MappedTypeConstraint = </span><span class="s5">32</span><span class="s1">,</span>
        <span class="s1">ContravariantConditional = </span><span class="s5">64</span><span class="s1">,</span>
        <span class="s1">ReturnType = </span><span class="s5">128</span><span class="s1">,</span>
        <span class="s1">LiteralKeyof = </span><span class="s5">256</span><span class="s1">,</span>
        <span class="s1">NoConstraints = </span><span class="s5">512</span><span class="s1">,</span>
        <span class="s1">AlwaysStrict = </span><span class="s5">1024</span><span class="s1">,</span>
        <span class="s1">MaxValue = </span><span class="s5">2048</span><span class="s1">,</span>
        <span class="s1">PriorityImpliesCombination = </span><span class="s5">416</span><span class="s1">,</span>
        <span class="s1">Circularity = -</span><span class="s5">1</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">FileExtensionInfo {</span>
        <span class="s1">extension: string;</span>
        <span class="s1">isMixedContent: boolean;</span>
        <span class="s1">scriptKind?: ScriptKind;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">DiagnosticMessage {</span>
        <span class="s1">key: string;</span>
        <span class="s1">category: DiagnosticCategory;</span>
        <span class="s1">code: number;</span>
        <span class="s1">message: string;</span>
        <span class="s1">reportsUnnecessary?: {};</span>
        <span class="s1">reportsDeprecated?: {};</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A linked list of formatted diagnostic messages to be used as part of a multiline message.</span>
     <span class="s0">* It is built from the bottom up, leaving the head to be the &quot;main&quot; diagnostic.</span>
     <span class="s0">* While it seems that DiagnosticMessageChain is structurally similar to DiagnosticMessage,</span>
     <span class="s0">* the difference is that messages are all preformatted in DMC.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">DiagnosticMessageChain {</span>
        <span class="s1">messageText: string;</span>
        <span class="s1">category: DiagnosticCategory;</span>
        <span class="s1">code: number;</span>
        <span class="s1">next?: DiagnosticMessageChain[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">Diagnostic </span><span class="s2">extends </span><span class="s1">DiagnosticRelatedInformation {</span>
        <span class="s0">/** May store more in future. For now, this will simply be `true` to indicate when a diagnostic is an unused-identifier diagnostic. */</span>
        <span class="s1">reportsUnnecessary?: {};</span>
        <span class="s1">reportsDeprecated?: {};</span>
        <span class="s1">source?: string;</span>
        <span class="s1">relatedInformation?: DiagnosticRelatedInformation[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">DiagnosticRelatedInformation {</span>
        <span class="s1">category: DiagnosticCategory;</span>
        <span class="s1">code: number;</span>
        <span class="s1">file: SourceFile | undefined;</span>
        <span class="s1">start: number | undefined;</span>
        <span class="s1">length: number | undefined;</span>
        <span class="s1">messageText: string | DiagnosticMessageChain;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">DiagnosticWithLocation </span><span class="s2">extends </span><span class="s1">Diagnostic {</span>
        <span class="s1">file: SourceFile;</span>
        <span class="s1">start: number;</span>
        <span class="s1">length: number;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">DiagnosticCategory {</span>
        <span class="s1">Warning = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">Error = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">Suggestion = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">Message = </span><span class="s5">3</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">ModuleResolutionKind {</span>
        <span class="s1">Classic = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s4">@deprecated</span>
         <span class="s0">* `NodeJs` was renamed to `Node10` to better reflect the version of Node that it targets.</span>
         <span class="s0">* Use the new name or consider switching to a modern module resolution target.</span>
         <span class="s0">*/</span>
        <span class="s1">NodeJs = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">Node10 = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">Node16 = </span><span class="s5">3</span><span class="s1">,</span>
        <span class="s1">NodeNext = </span><span class="s5">99</span><span class="s1">,</span>
        <span class="s1">Bundler = </span><span class="s5">100</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">ModuleDetectionKind {</span>
        <span class="s0">/**</span>
         <span class="s0">* Files with imports, exports and/or import.meta are considered modules</span>
         <span class="s0">*/</span>
        <span class="s1">Legacy = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s0">/**</span>
         <span class="s0">* Legacy, but also files with jsx under react-jsx or react-jsxdev and esm mode files under moduleResolution: node16+</span>
         <span class="s0">*/</span>
        <span class="s1">Auto = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s0">/**</span>
         <span class="s0">* Consider all non-declaration files modules, regardless of present syntax</span>
         <span class="s0">*/</span>
        <span class="s1">Force = </span><span class="s5">3</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">PluginImport {</span>
        <span class="s1">name: string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ProjectReference {</span>
        <span class="s0">/** A normalized path on disk */</span>
        <span class="s1">path: string;</span>
        <span class="s0">/** The path as the user originally wrote it */</span>
        <span class="s1">originalPath?: string;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/</span>
        <span class="s1">prepend?: boolean;</span>
        <span class="s0">/** True if it is intended that this reference form a circularity */</span>
        <span class="s1">circular?: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">WatchFileKind {</span>
        <span class="s1">FixedPollingInterval = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">PriorityPollingInterval = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">DynamicPriorityPolling = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">FixedChunkSizePolling = </span><span class="s5">3</span><span class="s1">,</span>
        <span class="s1">UseFsEvents = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">UseFsEventsOnParentDirectory = </span><span class="s5">5</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">WatchDirectoryKind {</span>
        <span class="s1">UseFsEvents = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">FixedPollingInterval = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">DynamicPriorityPolling = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">FixedChunkSizePolling = </span><span class="s5">3</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">PollingWatchKind {</span>
        <span class="s1">FixedInterval = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">PriorityInterval = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">DynamicPriority = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">FixedChunkSize = </span><span class="s5">3</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s1">type CompilerOptionsValue = string | number | boolean | (string | number)[] | string[] | MapLike&lt;string[]&gt; | PluginImport[] | ProjectReference[] | </span><span class="s2">null </span><span class="s1">| undefined;</span>
    <span class="s2">interface </span><span class="s1">CompilerOptions {</span>
        <span class="s1">allowImportingTsExtensions?: boolean;</span>
        <span class="s1">allowJs?: boolean;</span>
        <span class="s1">allowArbitraryExtensions?: boolean;</span>
        <span class="s1">allowSyntheticDefaultImports?: boolean;</span>
        <span class="s1">allowUmdGlobalAccess?: boolean;</span>
        <span class="s1">allowUnreachableCode?: boolean;</span>
        <span class="s1">allowUnusedLabels?: boolean;</span>
        <span class="s1">alwaysStrict?: boolean;</span>
        <span class="s1">baseUrl?: string;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/</span>
        <span class="s1">charset?: string;</span>
        <span class="s1">checkJs?: boolean;</span>
        <span class="s1">customConditions?: string[];</span>
        <span class="s1">declaration?: boolean;</span>
        <span class="s1">declarationMap?: boolean;</span>
        <span class="s1">emitDeclarationOnly?: boolean;</span>
        <span class="s1">declarationDir?: string;</span>
        <span class="s1">disableSizeLimit?: boolean;</span>
        <span class="s1">disableSourceOfProjectReferenceRedirect?: boolean;</span>
        <span class="s1">disableSolutionSearching?: boolean;</span>
        <span class="s1">disableReferencedProjectLoad?: boolean;</span>
        <span class="s1">downlevelIteration?: boolean;</span>
        <span class="s1">emitBOM?: boolean;</span>
        <span class="s1">emitDecoratorMetadata?: boolean;</span>
        <span class="s1">exactOptionalPropertyTypes?: boolean;</span>
        <span class="s1">experimentalDecorators?: boolean;</span>
        <span class="s1">forceConsistentCasingInFileNames?: boolean;</span>
        <span class="s1">ignoreDeprecations?: string;</span>
        <span class="s1">importHelpers?: boolean;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/</span>
        <span class="s1">importsNotUsedAsValues?: ImportsNotUsedAsValues;</span>
        <span class="s1">inlineSourceMap?: boolean;</span>
        <span class="s1">inlineSources?: boolean;</span>
        <span class="s1">isolatedModules?: boolean;</span>
        <span class="s1">isolatedDeclarations?: boolean;</span>
        <span class="s1">jsx?: JsxEmit;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/</span>
        <span class="s1">keyofStringsOnly?: boolean;</span>
        <span class="s1">lib?: string[];</span>
        <span class="s1">libReplacement?: boolean;</span>
        <span class="s1">locale?: string;</span>
        <span class="s1">mapRoot?: string;</span>
        <span class="s1">maxNodeModuleJsDepth?: number;</span>
        <span class="s1">module?: ModuleKind;</span>
        <span class="s1">moduleResolution?: ModuleResolutionKind;</span>
        <span class="s1">moduleSuffixes?: string[];</span>
        <span class="s1">moduleDetection?: ModuleDetectionKind;</span>
        <span class="s1">newLine?: NewLineKind;</span>
        <span class="s1">noEmit?: boolean;</span>
        <span class="s1">noCheck?: boolean;</span>
        <span class="s1">noEmitHelpers?: boolean;</span>
        <span class="s1">noEmitOnError?: boolean;</span>
        <span class="s1">noErrorTruncation?: boolean;</span>
        <span class="s1">noFallthroughCasesInSwitch?: boolean;</span>
        <span class="s1">noImplicitAny?: boolean;</span>
        <span class="s1">noImplicitReturns?: boolean;</span>
        <span class="s1">noImplicitThis?: boolean;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/</span>
        <span class="s1">noStrictGenericChecks?: boolean;</span>
        <span class="s1">noUnusedLocals?: boolean;</span>
        <span class="s1">noUnusedParameters?: boolean;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/</span>
        <span class="s1">noImplicitUseStrict?: boolean;</span>
        <span class="s1">noPropertyAccessFromIndexSignature?: boolean;</span>
        <span class="s1">assumeChangesOnlyAffectDirectDependencies?: boolean;</span>
        <span class="s1">noLib?: boolean;</span>
        <span class="s1">noResolve?: boolean;</span>
        <span class="s1">noUncheckedIndexedAccess?: boolean;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/</span>
        <span class="s1">out?: string;</span>
        <span class="s1">outDir?: string;</span>
        <span class="s1">outFile?: string;</span>
        <span class="s1">paths?: MapLike&lt;string[]&gt;;</span>
        <span class="s1">preserveConstEnums?: boolean;</span>
        <span class="s1">noImplicitOverride?: boolean;</span>
        <span class="s1">preserveSymlinks?: boolean;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/</span>
        <span class="s1">preserveValueImports?: boolean;</span>
        <span class="s1">project?: string;</span>
        <span class="s1">reactNamespace?: string;</span>
        <span class="s1">jsxFactory?: string;</span>
        <span class="s1">jsxFragmentFactory?: string;</span>
        <span class="s1">jsxImportSource?: string;</span>
        <span class="s1">composite?: boolean;</span>
        <span class="s1">incremental?: boolean;</span>
        <span class="s1">tsBuildInfoFile?: string;</span>
        <span class="s1">removeComments?: boolean;</span>
        <span class="s1">resolvePackageJsonExports?: boolean;</span>
        <span class="s1">resolvePackageJsonImports?: boolean;</span>
        <span class="s1">rewriteRelativeImportExtensions?: boolean;</span>
        <span class="s1">rootDir?: string;</span>
        <span class="s1">rootDirs?: string[];</span>
        <span class="s1">skipLibCheck?: boolean;</span>
        <span class="s1">skipDefaultLibCheck?: boolean;</span>
        <span class="s1">sourceMap?: boolean;</span>
        <span class="s1">sourceRoot?: string;</span>
        <span class="s1">strict?: boolean;</span>
        <span class="s1">strictFunctionTypes?: boolean;</span>
        <span class="s1">strictBindCallApply?: boolean;</span>
        <span class="s1">strictNullChecks?: boolean;</span>
        <span class="s1">strictPropertyInitialization?: boolean;</span>
        <span class="s1">strictBuiltinIteratorReturn?: boolean;</span>
        <span class="s1">stripInternal?: boolean;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/</span>
        <span class="s1">suppressExcessPropertyErrors?: boolean;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/</span>
        <span class="s1">suppressImplicitAnyIndexErrors?: boolean;</span>
        <span class="s1">target?: ScriptTarget;</span>
        <span class="s1">traceResolution?: boolean;</span>
        <span class="s1">useUnknownInCatchVariables?: boolean;</span>
        <span class="s1">noUncheckedSideEffectImports?: boolean;</span>
        <span class="s1">resolveJsonModule?: boolean;</span>
        <span class="s1">types?: string[];</span>
        <span class="s0">/** Paths used to compute primary types search locations */</span>
        <span class="s1">typeRoots?: string[];</span>
        <span class="s1">verbatimModuleSyntax?: boolean;</span>
        <span class="s1">erasableSyntaxOnly?: boolean;</span>
        <span class="s1">esModuleInterop?: boolean;</span>
        <span class="s1">useDefineForClassFields?: boolean;</span>
        <span class="s1">[option: string]: CompilerOptionsValue | TsConfigSourceFile | undefined;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">WatchOptions {</span>
        <span class="s1">watchFile?: WatchFileKind;</span>
        <span class="s1">watchDirectory?: WatchDirectoryKind;</span>
        <span class="s1">fallbackPolling?: PollingWatchKind;</span>
        <span class="s1">synchronousWatchDirectory?: boolean;</span>
        <span class="s1">excludeDirectories?: string[];</span>
        <span class="s1">excludeFiles?: string[];</span>
        <span class="s1">[option: string]: CompilerOptionsValue | undefined;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TypeAcquisition {</span>
        <span class="s1">enable?: boolean;</span>
        <span class="s1">include?: string[];</span>
        <span class="s1">exclude?: string[];</span>
        <span class="s1">disableFilenameBasedTypeAcquisition?: boolean;</span>
        <span class="s1">[option: string]: CompilerOptionsValue | undefined;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">ModuleKind {</span>
        <span class="s1">None = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">CommonJS = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">AMD = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">UMD = </span><span class="s5">3</span><span class="s1">,</span>
        <span class="s1">System = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">ES2015 = </span><span class="s5">5</span><span class="s1">,</span>
        <span class="s1">ES2020 = </span><span class="s5">6</span><span class="s1">,</span>
        <span class="s1">ES2022 = </span><span class="s5">7</span><span class="s1">,</span>
        <span class="s1">ESNext = </span><span class="s5">99</span><span class="s1">,</span>
        <span class="s1">Node16 = </span><span class="s5">100</span><span class="s1">,</span>
        <span class="s1">Node18 = </span><span class="s5">101</span><span class="s1">,</span>
        <span class="s1">Node20 = </span><span class="s5">102</span><span class="s1">,</span>
        <span class="s1">NodeNext = </span><span class="s5">199</span><span class="s1">,</span>
        <span class="s1">Preserve = </span><span class="s5">200</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">JsxEmit {</span>
        <span class="s1">None = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">Preserve = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">React = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">ReactNative = </span><span class="s5">3</span><span class="s1">,</span>
        <span class="s1">ReactJSX = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">ReactJSXDev = </span><span class="s5">5</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/</span>
    <span class="s2">enum </span><span class="s1">ImportsNotUsedAsValues {</span>
        <span class="s1">Remove = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">Preserve = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">Error = </span><span class="s5">2</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">NewLineKind {</span>
        <span class="s1">CarriageReturnLineFeed = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">LineFeed = </span><span class="s5">1</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">LineAndCharacter {</span>
        <span class="s0">/** 0-based. */</span>
        <span class="s1">line: number;</span>
        <span class="s1">character: number;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">ScriptKind {</span>
        <span class="s1">Unknown = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">JS = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">JSX = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">TS = </span><span class="s5">3</span><span class="s1">,</span>
        <span class="s1">TSX = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">External = </span><span class="s5">5</span><span class="s1">,</span>
        <span class="s1">JSON = </span><span class="s5">6</span><span class="s1">,</span>
        <span class="s0">/**</span>
         <span class="s0">* Used on extensions that doesn't define the ScriptKind but the content defines it.</span>
         <span class="s0">* Deferred extensions are going to be included in all project contexts.</span>
         <span class="s0">*/</span>
        <span class="s1">Deferred = </span><span class="s5">7</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">ScriptTarget {</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/</span>
        <span class="s1">ES3 = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">ES5 = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">ES2015 = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">ES2016 = </span><span class="s5">3</span><span class="s1">,</span>
        <span class="s1">ES2017 = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">ES2018 = </span><span class="s5">5</span><span class="s1">,</span>
        <span class="s1">ES2019 = </span><span class="s5">6</span><span class="s1">,</span>
        <span class="s1">ES2020 = </span><span class="s5">7</span><span class="s1">,</span>
        <span class="s1">ES2021 = </span><span class="s5">8</span><span class="s1">,</span>
        <span class="s1">ES2022 = </span><span class="s5">9</span><span class="s1">,</span>
        <span class="s1">ES2023 = </span><span class="s5">10</span><span class="s1">,</span>
        <span class="s1">ES2024 = </span><span class="s5">11</span><span class="s1">,</span>
        <span class="s1">ESNext = </span><span class="s5">99</span><span class="s1">,</span>
        <span class="s1">JSON = </span><span class="s5">100</span><span class="s1">,</span>
        <span class="s1">Latest = </span><span class="s5">99</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">LanguageVariant {</span>
        <span class="s1">Standard = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">JSX = </span><span class="s5">1</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s0">/** Either a parsed command line or a parsed tsconfig.json */</span>
    <span class="s2">interface </span><span class="s1">ParsedCommandLine {</span>
        <span class="s1">options: CompilerOptions;</span>
        <span class="s1">typeAcquisition?: TypeAcquisition;</span>
        <span class="s1">fileNames: string[];</span>
        <span class="s1">projectReferences?: readonly ProjectReference[];</span>
        <span class="s1">watchOptions?: WatchOptions;</span>
        <span class="s1">raw?: any;</span>
        <span class="s1">errors: Diagnostic[];</span>
        <span class="s1">wildcardDirectories?: MapLike&lt;WatchDirectoryFlags&gt;;</span>
        <span class="s1">compileOnSave?: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">WatchDirectoryFlags {</span>
        <span class="s1">None = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">Recursive = </span><span class="s5">1</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">CreateProgramOptions {</span>
        <span class="s1">rootNames: readonly string[];</span>
        <span class="s1">options: CompilerOptions;</span>
        <span class="s1">projectReferences?: readonly ProjectReference[];</span>
        <span class="s1">host?: CompilerHost;</span>
        <span class="s1">oldProgram?: Program;</span>
        <span class="s1">configFileParsingDiagnostics?: readonly Diagnostic[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ModuleResolutionHost {</span>
        <span class="s1">fileExists(fileName: string): boolean;</span>
        <span class="s1">readFile(fileName: string): string | undefined;</span>
        <span class="s1">trace?(s: string): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">directoryExists?(directoryName: string): boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Resolve a symbolic link.</span>
         <span class="s0">* </span><span class="s4">@see </span><span class="s0">https://nodejs.org/api/fs.html#fs_fs_realpathsync_path_options</span>
         <span class="s0">*/</span>
        <span class="s1">realpath?(path: string): string;</span>
        <span class="s1">getCurrentDirectory?(): string;</span>
        <span class="s1">getDirectories?(path: string): string[];</span>
        <span class="s1">useCaseSensitiveFileNames?: boolean | (() =&gt; boolean) | undefined;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Used by services to specify the minimum host area required to set up source files under any compilation settings</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">MinimalResolutionCacheHost </span><span class="s2">extends </span><span class="s1">ModuleResolutionHost {</span>
        <span class="s1">getCompilationSettings(): CompilerOptions;</span>
        <span class="s1">getCompilerHost?(): CompilerHost | undefined;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Represents the result of module resolution.</span>
     <span class="s0">* Module resolution will pick up tsx/jsx/js files even if '--jsx' and '--allowJs' are turned off.</span>
     <span class="s0">* The Program will then filter results based on these flags.</span>
     <span class="s0">*</span>
     <span class="s0">* Prefer to return a `ResolvedModuleFull` so that the file type does not have to be inferred.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">ResolvedModule {</span>
        <span class="s0">/** Path of the file the module was resolved to. */</span>
        <span class="s1">resolvedFileName: string;</span>
        <span class="s0">/** True if `resolvedFileName` comes from `node_modules`. */</span>
        <span class="s1">isExternalLibraryImport?: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* True if the original module reference used a .ts extension to refer directly to a .ts file,</span>
         <span class="s0">* which should produce an error during checking if emit is enabled.</span>
         <span class="s0">*/</span>
        <span class="s1">resolvedUsingTsExtension?: boolean;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* ResolvedModule with an explicitly provided `extension` property.</span>
     <span class="s0">* Prefer this over `ResolvedModule`.</span>
     <span class="s0">* If changing this, remember to change `moduleResolutionIsEqualTo`.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">ResolvedModuleFull </span><span class="s2">extends </span><span class="s1">ResolvedModule {</span>
        <span class="s0">/**</span>
         <span class="s0">* Extension of resolvedFileName. This must match what's at the end of resolvedFileName.</span>
         <span class="s0">* This is optional for backwards-compatibility, but will be added if not provided.</span>
         <span class="s0">*/</span>
        <span class="s1">extension: string;</span>
        <span class="s1">packageId?: PackageId;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Unique identifier with a package name and version.</span>
     <span class="s0">* If changing this, remember to change `packageIdIsEqual`.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">PackageId {</span>
        <span class="s0">/**</span>
         <span class="s0">* Name of the package.</span>
         <span class="s0">* Should not include `@types`.</span>
         <span class="s0">* If accessing a non-index file, this should include its name e.g. &quot;foo/bar&quot;.</span>
         <span class="s0">*/</span>
        <span class="s1">name: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Name of a submodule within this package.</span>
         <span class="s0">* May be &quot;&quot;.</span>
         <span class="s0">*/</span>
        <span class="s1">subModuleName: string;</span>
        <span class="s0">/** Version of the package, e.g. &quot;1.2.3&quot; */</span>
        <span class="s1">version: string;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">Extension {</span>
        <span class="s1">Ts = </span><span class="s3">&quot;.ts&quot;</span><span class="s1">,</span>
        <span class="s1">Tsx = </span><span class="s3">&quot;.tsx&quot;</span><span class="s1">,</span>
        <span class="s1">Dts = </span><span class="s3">&quot;.d.ts&quot;</span><span class="s1">,</span>
        <span class="s1">Js = </span><span class="s3">&quot;.js&quot;</span><span class="s1">,</span>
        <span class="s1">Jsx = </span><span class="s3">&quot;.jsx&quot;</span><span class="s1">,</span>
        <span class="s1">Json = </span><span class="s3">&quot;.json&quot;</span><span class="s1">,</span>
        <span class="s1">TsBuildInfo = </span><span class="s3">&quot;.tsbuildinfo&quot;</span><span class="s1">,</span>
        <span class="s1">Mjs = </span><span class="s3">&quot;.mjs&quot;</span><span class="s1">,</span>
        <span class="s1">Mts = </span><span class="s3">&quot;.mts&quot;</span><span class="s1">,</span>
        <span class="s1">Dmts = </span><span class="s3">&quot;.d.mts&quot;</span><span class="s1">,</span>
        <span class="s1">Cjs = </span><span class="s3">&quot;.cjs&quot;</span><span class="s1">,</span>
        <span class="s1">Cts = </span><span class="s3">&quot;.cts&quot;</span><span class="s1">,</span>
        <span class="s1">Dcts = </span><span class="s3">&quot;.d.cts&quot;</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ResolvedModuleWithFailedLookupLocations {</span>
        <span class="s1">readonly resolvedModule: ResolvedModuleFull | undefined;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ResolvedTypeReferenceDirective {</span>
        <span class="s1">primary: boolean;</span>
        <span class="s1">resolvedFileName: string | undefined;</span>
        <span class="s1">packageId?: PackageId;</span>
        <span class="s0">/** True if `resolvedFileName` comes from `node_modules`. */</span>
        <span class="s1">isExternalLibraryImport?: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ResolvedTypeReferenceDirectiveWithFailedLookupLocations {</span>
        <span class="s1">readonly resolvedTypeReferenceDirective: ResolvedTypeReferenceDirective | undefined;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">CompilerHost </span><span class="s2">extends </span><span class="s1">ModuleResolutionHost {</span>
        <span class="s1">getSourceFile(fileName: string, languageVersionOrOptions: ScriptTarget | CreateSourceFileOptions, onError?: (message: string) =&gt; </span><span class="s2">void</span><span class="s1">, shouldCreateNewSourceFile?: boolean): SourceFile | undefined;</span>
        <span class="s1">getSourceFileByPath?(fileName: string, path: Path, languageVersionOrOptions: ScriptTarget | CreateSourceFileOptions, onError?: (message: string) =&gt; </span><span class="s2">void</span><span class="s1">, shouldCreateNewSourceFile?: boolean): SourceFile | undefined;</span>
        <span class="s1">getCancellationToken?(): CancellationToken;</span>
        <span class="s1">getDefaultLibFileName(options: CompilerOptions): string;</span>
        <span class="s1">getDefaultLibLocation?(): string;</span>
        <span class="s1">writeFile: WriteFileCallback;</span>
        <span class="s1">getCurrentDirectory(): string;</span>
        <span class="s1">getCanonicalFileName(fileName: string): string;</span>
        <span class="s1">useCaseSensitiveFileNames(): boolean;</span>
        <span class="s1">getNewLine(): string;</span>
        <span class="s1">readDirectory?(rootDir: string, extensions: readonly string[], excludes: readonly string[] | undefined, includes: readonly string[], depth?: number): string[];</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">supply resolveModuleNameLiterals instead for resolution that can handle newer resolution modes like nodenext */</span>
        <span class="s1">resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile?: SourceFile): (ResolvedModule | undefined)[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns the module resolution cache used by a provided `resolveModuleNames` implementation so that any non-name module resolution operations (eg, package.json lookup) can reuse it</span>
         <span class="s0">*/</span>
        <span class="s1">getModuleResolutionCache?(): ModuleResolutionCache | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s4">@deprecated </span><span class="s0">supply resolveTypeReferenceDirectiveReferences instead for resolution that can handle newer resolution modes like nodenext</span>
         <span class="s0">*</span>
         <span class="s0">* This method is a companion for 'resolveModuleNames' and is used to resolve 'types' references to actual type declaration files</span>
         <span class="s0">*/</span>
        <span class="s1">resolveTypeReferenceDirectives?(typeReferenceDirectiveNames: string[] | readonly FileReference[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingFileMode?: ResolutionMode): (ResolvedTypeReferenceDirective | undefined)[];</span>
        <span class="s1">resolveModuleNameLiterals?(moduleLiterals: readonly StringLiteralLike[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile, reusedNames: readonly StringLiteralLike[] | undefined): readonly ResolvedModuleWithFailedLookupLocations[];</span>
        <span class="s1">resolveTypeReferenceDirectiveReferences?&lt;T </span><span class="s2">extends </span><span class="s1">FileReference | string&gt;(typeDirectiveReferences: readonly T[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile | undefined, reusedNames: readonly T[] | undefined): readonly ResolvedTypeReferenceDirectiveWithFailedLookupLocations[];</span>
        <span class="s1">getEnvironmentVariable?(name: string): string | undefined;</span>
        <span class="s0">/** If provided along with custom resolveModuleNames or resolveTypeReferenceDirectives, used to determine if unchanged file path needs to re-resolve modules/type reference directives */</span>
        <span class="s1">hasInvalidatedResolutions?(filePath: Path): boolean;</span>
        <span class="s1">createHash?(data: string): string;</span>
        <span class="s1">getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;</span>
        <span class="s1">jsDocParsingMode?: JSDocParsingMode;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SourceMapRange </span><span class="s2">extends </span><span class="s1">TextRange {</span>
        <span class="s1">source?: SourceMapSource;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SourceMapSource {</span>
        <span class="s1">fileName: string;</span>
        <span class="s1">text: string;</span>
        <span class="s1">skipTrivia?: (pos: number) =&gt; number;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SourceMapSource {</span>
        <span class="s1">getLineAndCharacterOfPosition(pos: number): LineAndCharacter;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">EmitFlags {</span>
        <span class="s1">None = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">SingleLine = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">MultiLine = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">AdviseOnEmitNode = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">NoSubstitution = </span><span class="s5">8</span><span class="s1">,</span>
        <span class="s1">CapturesThis = </span><span class="s5">16</span><span class="s1">,</span>
        <span class="s1">NoLeadingSourceMap = </span><span class="s5">32</span><span class="s1">,</span>
        <span class="s1">NoTrailingSourceMap = </span><span class="s5">64</span><span class="s1">,</span>
        <span class="s1">NoSourceMap = </span><span class="s5">96</span><span class="s1">,</span>
        <span class="s1">NoNestedSourceMaps = </span><span class="s5">128</span><span class="s1">,</span>
        <span class="s1">NoTokenLeadingSourceMaps = </span><span class="s5">256</span><span class="s1">,</span>
        <span class="s1">NoTokenTrailingSourceMaps = </span><span class="s5">512</span><span class="s1">,</span>
        <span class="s1">NoTokenSourceMaps = </span><span class="s5">768</span><span class="s1">,</span>
        <span class="s1">NoLeadingComments = </span><span class="s5">1024</span><span class="s1">,</span>
        <span class="s1">NoTrailingComments = </span><span class="s5">2048</span><span class="s1">,</span>
        <span class="s1">NoComments = </span><span class="s5">3072</span><span class="s1">,</span>
        <span class="s1">NoNestedComments = </span><span class="s5">4096</span><span class="s1">,</span>
        <span class="s1">HelperName = </span><span class="s5">8192</span><span class="s1">,</span>
        <span class="s1">ExportName = </span><span class="s5">16384</span><span class="s1">,</span>
        <span class="s1">LocalName = </span><span class="s5">32768</span><span class="s1">,</span>
        <span class="s1">InternalName = </span><span class="s5">65536</span><span class="s1">,</span>
        <span class="s1">Indented = </span><span class="s5">131072</span><span class="s1">,</span>
        <span class="s1">NoIndentation = </span><span class="s5">262144</span><span class="s1">,</span>
        <span class="s1">AsyncFunctionBody = </span><span class="s5">524288</span><span class="s1">,</span>
        <span class="s1">ReuseTempVariableScope = </span><span class="s5">1048576</span><span class="s1">,</span>
        <span class="s1">CustomPrologue = </span><span class="s5">2097152</span><span class="s1">,</span>
        <span class="s1">NoHoisting = </span><span class="s5">4194304</span><span class="s1">,</span>
        <span class="s1">Iterator = </span><span class="s5">8388608</span><span class="s1">,</span>
        <span class="s1">NoAsciiEscaping = </span><span class="s5">16777216</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">EmitHelperBase {</span>
        <span class="s1">readonly name: string;</span>
        <span class="s1">readonly scoped: boolean;</span>
        <span class="s1">readonly text: string | ((node: EmitHelperUniqueNameCallback) =&gt; string);</span>
        <span class="s1">readonly priority?: number;</span>
        <span class="s1">readonly dependencies?: EmitHelper[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ScopedEmitHelper </span><span class="s2">extends </span><span class="s1">EmitHelperBase {</span>
        <span class="s1">readonly scoped: </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">UnscopedEmitHelper </span><span class="s2">extends </span><span class="s1">EmitHelperBase {</span>
        <span class="s1">readonly scoped: </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">readonly text: string;</span>
    <span class="s1">}</span>
    <span class="s1">type EmitHelper = ScopedEmitHelper | UnscopedEmitHelper;</span>
    <span class="s1">type EmitHelperUniqueNameCallback = (name: string) =&gt; string;</span>
    <span class="s2">enum </span><span class="s1">EmitHint {</span>
        <span class="s1">SourceFile = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">Expression = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">IdentifierName = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">MappedTypeParameter = </span><span class="s5">3</span><span class="s1">,</span>
        <span class="s1">Unspecified = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">EmbeddedStatement = </span><span class="s5">5</span><span class="s1">,</span>
        <span class="s1">JsxAttributeValue = </span><span class="s5">6</span><span class="s1">,</span>
        <span class="s1">ImportTypeNodeAttributes = </span><span class="s5">7</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">OuterExpressionKinds {</span>
        <span class="s1">Parentheses = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">TypeAssertions = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">NonNullAssertions = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">PartiallyEmittedExpressions = </span><span class="s5">8</span><span class="s1">,</span>
        <span class="s1">ExpressionsWithTypeArguments = </span><span class="s5">16</span><span class="s1">,</span>
        <span class="s1">Satisfies = </span><span class="s5">32</span><span class="s1">,</span>
        <span class="s1">Assertions = </span><span class="s5">38</span><span class="s1">,</span>
        <span class="s1">All = </span><span class="s5">63</span><span class="s1">,</span>
        <span class="s1">ExcludeJSDocTypeAssertion = -</span><span class="s5">2147483648</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s1">type ImmediatelyInvokedFunctionExpression = CallExpression &amp; {</span>
        <span class="s1">readonly expression: FunctionExpression;</span>
    <span class="s1">};</span>
    <span class="s1">type ImmediatelyInvokedArrowFunction = CallExpression &amp; {</span>
        <span class="s1">readonly expression: ParenthesizedExpression &amp; {</span>
            <span class="s1">readonly expression: ArrowFunction;</span>
        <span class="s1">};</span>
    <span class="s1">};</span>
    <span class="s2">interface </span><span class="s1">NodeFactory {</span>
        <span class="s1">createNodeArray&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt;(elements?: readonly T[], hasTrailingComma?: boolean): NodeArray&lt;T&gt;;</span>
        <span class="s1">createNumericLiteral(value: string | number, numericLiteralFlags?: TokenFlags): NumericLiteral;</span>
        <span class="s1">createBigIntLiteral(value: string | PseudoBigInt): BigIntLiteral;</span>
        <span class="s1">createStringLiteral(text: string, isSingleQuote?: boolean): StringLiteral;</span>
        <span class="s1">createStringLiteralFromNode(sourceNode: PropertyNameLiteral | PrivateIdentifier, isSingleQuote?: boolean): StringLiteral;</span>
        <span class="s1">createRegularExpressionLiteral(text: string): RegularExpressionLiteral;</span>
        <span class="s1">createIdentifier(text: string): Identifier;</span>
        <span class="s0">/**</span>
         <span class="s0">* Create a unique temporary variable.</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">recordTempVariable An optional callback used to record the temporary variable name. This</span>
         <span class="s0">* should usually be a reference to `hoistVariableDeclaration` from a `TransformationContext`, but</span>
         <span class="s0">* can be `undefined` if you plan to record the temporary variable manually.</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">reservedInNestedScopes When `true`, reserves the temporary variable name in all nested scopes</span>
         <span class="s0">* during emit so that the variable can be referenced in a nested function body. This is an alternative to</span>
         <span class="s0">* setting `EmitFlags.ReuseTempVariableScope` on the nested function itself.</span>
         <span class="s0">*/</span>
        <span class="s1">createTempVariable(recordTempVariable: ((node: Identifier) =&gt; </span><span class="s2">void</span><span class="s1">) | undefined, reservedInNestedScopes?: boolean): Identifier;</span>
        <span class="s0">/**</span>
         <span class="s0">* Create a unique temporary variable for use in a loop.</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">reservedInNestedScopes When `true`, reserves the temporary variable name in all nested scopes</span>
         <span class="s0">* during emit so that the variable can be referenced in a nested function body. This is an alternative to</span>
         <span class="s0">* setting `EmitFlags.ReuseTempVariableScope` on the nested function itself.</span>
         <span class="s0">*/</span>
        <span class="s1">createLoopVariable(reservedInNestedScopes?: boolean): Identifier;</span>
        <span class="s0">/** Create a unique name based on the supplied text. */</span>
        <span class="s1">createUniqueName(text: string, flags?: GeneratedIdentifierFlags): Identifier;</span>
        <span class="s0">/** Create a unique name generated for a node. */</span>
        <span class="s1">getGeneratedNameForNode(node: Node | undefined, flags?: GeneratedIdentifierFlags): Identifier;</span>
        <span class="s1">createPrivateIdentifier(text: string): PrivateIdentifier;</span>
        <span class="s1">createUniquePrivateName(text?: string): PrivateIdentifier;</span>
        <span class="s1">getGeneratedPrivateNameForNode(node: Node): PrivateIdentifier;</span>
        <span class="s1">createToken(token: SyntaxKind.SuperKeyword): SuperExpression;</span>
        <span class="s1">createToken(token: SyntaxKind.ThisKeyword): ThisExpression;</span>
        <span class="s1">createToken(token: SyntaxKind.NullKeyword): NullLiteral;</span>
        <span class="s1">createToken(token: SyntaxKind.TrueKeyword): TrueLiteral;</span>
        <span class="s1">createToken(token: SyntaxKind.FalseKeyword): FalseLiteral;</span>
        <span class="s1">createToken(token: SyntaxKind.EndOfFileToken): EndOfFileToken;</span>
        <span class="s1">createToken(token: SyntaxKind.Unknown): Token&lt;SyntaxKind.Unknown&gt;;</span>
        <span class="s1">createToken&lt;TKind </span><span class="s2">extends </span><span class="s1">PunctuationSyntaxKind&gt;(token: TKind): PunctuationToken&lt;TKind&gt;;</span>
        <span class="s1">createToken&lt;TKind </span><span class="s2">extends </span><span class="s1">KeywordTypeSyntaxKind&gt;(token: TKind): KeywordTypeNode&lt;TKind&gt;;</span>
        <span class="s1">createToken&lt;TKind </span><span class="s2">extends </span><span class="s1">ModifierSyntaxKind&gt;(token: TKind): ModifierToken&lt;TKind&gt;;</span>
        <span class="s1">createToken&lt;TKind </span><span class="s2">extends </span><span class="s1">KeywordSyntaxKind&gt;(token: TKind): KeywordToken&lt;TKind&gt;;</span>
        <span class="s1">createSuper(): SuperExpression;</span>
        <span class="s1">createThis(): ThisExpression;</span>
        <span class="s1">createNull(): NullLiteral;</span>
        <span class="s1">createTrue(): TrueLiteral;</span>
        <span class="s1">createFalse(): FalseLiteral;</span>
        <span class="s1">createModifier&lt;T </span><span class="s2">extends </span><span class="s1">ModifierSyntaxKind&gt;(kind: T): ModifierToken&lt;T&gt;;</span>
        <span class="s1">createModifiersFromModifierFlags(flags: ModifierFlags): Modifier[] | undefined;</span>
        <span class="s1">createQualifiedName(left: EntityName, right: string | Identifier): QualifiedName;</span>
        <span class="s1">updateQualifiedName(node: QualifiedName, left: EntityName, right: Identifier): QualifiedName;</span>
        <span class="s1">createComputedPropertyName(expression: Expression): ComputedPropertyName;</span>
        <span class="s1">updateComputedPropertyName(node: ComputedPropertyName, expression: Expression): ComputedPropertyName;</span>
        <span class="s1">createTypeParameterDeclaration(modifiers: readonly Modifier[] | undefined, name: string | Identifier, constraint?: TypeNode, defaultType?: TypeNode): TypeParameterDeclaration;</span>
        <span class="s1">updateTypeParameterDeclaration(node: TypeParameterDeclaration, modifiers: readonly Modifier[] | undefined, name: Identifier, constraint: TypeNode | undefined, defaultType: TypeNode | undefined): TypeParameterDeclaration;</span>
        <span class="s1">createParameterDeclaration(modifiers: readonly ModifierLike[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken?: QuestionToken, type?: TypeNode, initializer?: Expression): ParameterDeclaration;</span>
        <span class="s1">updateParameterDeclaration(node: ParameterDeclaration, modifiers: readonly ModifierLike[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): ParameterDeclaration;</span>
        <span class="s1">createDecorator(expression: Expression): Decorator;</span>
        <span class="s1">updateDecorator(node: Decorator, expression: Expression): Decorator;</span>
        <span class="s1">createPropertySignature(modifiers: readonly Modifier[] | undefined, name: PropertyName | string, questionToken: QuestionToken | undefined, type: TypeNode | undefined): PropertySignature;</span>
        <span class="s1">updatePropertySignature(node: PropertySignature, modifiers: readonly Modifier[] | undefined, name: PropertyName, questionToken: QuestionToken | undefined, type: TypeNode | undefined): PropertySignature;</span>
        <span class="s1">createPropertyDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;</span>
        <span class="s1">updatePropertyDeclaration(node: PropertyDeclaration, modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;</span>
        <span class="s1">createMethodSignature(modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): MethodSignature;</span>
        <span class="s1">updateMethodSignature(node: MethodSignature, modifiers: readonly Modifier[] | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: NodeArray&lt;TypeParameterDeclaration&gt; | undefined, parameters: NodeArray&lt;ParameterDeclaration&gt;, type: TypeNode | undefined): MethodSignature;</span>
        <span class="s1">createMethodDeclaration(modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;</span>
        <span class="s1">updateMethodDeclaration(node: MethodDeclaration, modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;</span>
        <span class="s1">createConstructorDeclaration(modifiers: readonly ModifierLike[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;</span>
        <span class="s1">updateConstructorDeclaration(node: ConstructorDeclaration, modifiers: readonly ModifierLike[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;</span>
        <span class="s1">createGetAccessorDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;</span>
        <span class="s1">updateGetAccessorDeclaration(node: GetAccessorDeclaration, modifiers: readonly ModifierLike[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;</span>
        <span class="s1">createSetAccessorDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;</span>
        <span class="s1">updateSetAccessorDeclaration(node: SetAccessorDeclaration, modifiers: readonly ModifierLike[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;</span>
        <span class="s1">createCallSignature(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): CallSignatureDeclaration;</span>
        <span class="s1">updateCallSignature(node: CallSignatureDeclaration, typeParameters: NodeArray&lt;TypeParameterDeclaration&gt; | undefined, parameters: NodeArray&lt;ParameterDeclaration&gt;, type: TypeNode | undefined): CallSignatureDeclaration;</span>
        <span class="s1">createConstructSignature(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): ConstructSignatureDeclaration;</span>
        <span class="s1">updateConstructSignature(node: ConstructSignatureDeclaration, typeParameters: NodeArray&lt;TypeParameterDeclaration&gt; | undefined, parameters: NodeArray&lt;ParameterDeclaration&gt;, type: TypeNode | undefined): ConstructSignatureDeclaration;</span>
        <span class="s1">createIndexSignature(modifiers: readonly ModifierLike[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;</span>
        <span class="s1">updateIndexSignature(node: IndexSignatureDeclaration, modifiers: readonly ModifierLike[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;</span>
        <span class="s1">createTemplateLiteralTypeSpan(type: TypeNode, literal: TemplateMiddle | TemplateTail): TemplateLiteralTypeSpan;</span>
        <span class="s1">updateTemplateLiteralTypeSpan(node: TemplateLiteralTypeSpan, type: TypeNode, literal: TemplateMiddle | TemplateTail): TemplateLiteralTypeSpan;</span>
        <span class="s1">createClassStaticBlockDeclaration(body: Block): ClassStaticBlockDeclaration;</span>
        <span class="s1">updateClassStaticBlockDeclaration(node: ClassStaticBlockDeclaration, body: Block): ClassStaticBlockDeclaration;</span>
        <span class="s1">createKeywordTypeNode&lt;TKind </span><span class="s2">extends </span><span class="s1">KeywordTypeSyntaxKind&gt;(kind: TKind): KeywordTypeNode&lt;TKind&gt;;</span>
        <span class="s1">createTypePredicateNode(assertsModifier: AssertsKeyword | undefined, parameterName: Identifier | ThisTypeNode | string, type: TypeNode | undefined): TypePredicateNode;</span>
        <span class="s1">updateTypePredicateNode(node: TypePredicateNode, assertsModifier: AssertsKeyword | undefined, parameterName: Identifier | ThisTypeNode, type: TypeNode | undefined): TypePredicateNode;</span>
        <span class="s1">createTypeReferenceNode(typeName: string | EntityName, typeArguments?: readonly TypeNode[]): TypeReferenceNode;</span>
        <span class="s1">updateTypeReferenceNode(node: TypeReferenceNode, typeName: EntityName, typeArguments: NodeArray&lt;TypeNode&gt; | undefined): TypeReferenceNode;</span>
        <span class="s1">createFunctionTypeNode(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): FunctionTypeNode;</span>
        <span class="s1">updateFunctionTypeNode(node: FunctionTypeNode, typeParameters: NodeArray&lt;TypeParameterDeclaration&gt; | undefined, parameters: NodeArray&lt;ParameterDeclaration&gt;, type: TypeNode): FunctionTypeNode;</span>
        <span class="s1">createConstructorTypeNode(modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): ConstructorTypeNode;</span>
        <span class="s1">updateConstructorTypeNode(node: ConstructorTypeNode, modifiers: readonly Modifier[] | undefined, typeParameters: NodeArray&lt;TypeParameterDeclaration&gt; | undefined, parameters: NodeArray&lt;ParameterDeclaration&gt;, type: TypeNode): ConstructorTypeNode;</span>
        <span class="s1">createTypeQueryNode(exprName: EntityName, typeArguments?: readonly TypeNode[]): TypeQueryNode;</span>
        <span class="s1">updateTypeQueryNode(node: TypeQueryNode, exprName: EntityName, typeArguments?: readonly TypeNode[]): TypeQueryNode;</span>
        <span class="s1">createTypeLiteralNode(members: readonly TypeElement[] | undefined): TypeLiteralNode;</span>
        <span class="s1">updateTypeLiteralNode(node: TypeLiteralNode, members: NodeArray&lt;TypeElement&gt;): TypeLiteralNode;</span>
        <span class="s1">createArrayTypeNode(elementType: TypeNode): ArrayTypeNode;</span>
        <span class="s1">updateArrayTypeNode(node: ArrayTypeNode, elementType: TypeNode): ArrayTypeNode;</span>
        <span class="s1">createTupleTypeNode(elements: readonly (TypeNode | NamedTupleMember)[]): TupleTypeNode;</span>
        <span class="s1">updateTupleTypeNode(node: TupleTypeNode, elements: readonly (TypeNode | NamedTupleMember)[]): TupleTypeNode;</span>
        <span class="s1">createNamedTupleMember(dotDotDotToken: DotDotDotToken | undefined, name: Identifier, questionToken: QuestionToken | undefined, type: TypeNode): NamedTupleMember;</span>
        <span class="s1">updateNamedTupleMember(node: NamedTupleMember, dotDotDotToken: DotDotDotToken | undefined, name: Identifier, questionToken: QuestionToken | undefined, type: TypeNode): NamedTupleMember;</span>
        <span class="s1">createOptionalTypeNode(type: TypeNode): OptionalTypeNode;</span>
        <span class="s1">updateOptionalTypeNode(node: OptionalTypeNode, type: TypeNode): OptionalTypeNode;</span>
        <span class="s1">createRestTypeNode(type: TypeNode): RestTypeNode;</span>
        <span class="s1">updateRestTypeNode(node: RestTypeNode, type: TypeNode): RestTypeNode;</span>
        <span class="s1">createUnionTypeNode(types: readonly TypeNode[]): UnionTypeNode;</span>
        <span class="s1">updateUnionTypeNode(node: UnionTypeNode, types: NodeArray&lt;TypeNode&gt;): UnionTypeNode;</span>
        <span class="s1">createIntersectionTypeNode(types: readonly TypeNode[]): IntersectionTypeNode;</span>
        <span class="s1">updateIntersectionTypeNode(node: IntersectionTypeNode, types: NodeArray&lt;TypeNode&gt;): IntersectionTypeNode;</span>
        <span class="s1">createConditionalTypeNode(checkType: TypeNode, extendsType: TypeNode, trueType: TypeNode, falseType: TypeNode): ConditionalTypeNode;</span>
        <span class="s1">updateConditionalTypeNode(node: ConditionalTypeNode, checkType: TypeNode, extendsType: TypeNode, trueType: TypeNode, falseType: TypeNode): ConditionalTypeNode;</span>
        <span class="s1">createInferTypeNode(typeParameter: TypeParameterDeclaration): InferTypeNode;</span>
        <span class="s1">updateInferTypeNode(node: InferTypeNode, typeParameter: TypeParameterDeclaration): InferTypeNode;</span>
        <span class="s1">createImportTypeNode(argument: TypeNode, attributes?: ImportAttributes, qualifier?: EntityName, typeArguments?: readonly TypeNode[], isTypeOf?: boolean): ImportTypeNode;</span>
        <span class="s1">updateImportTypeNode(node: ImportTypeNode, argument: TypeNode, attributes: ImportAttributes | undefined, qualifier: EntityName | undefined, typeArguments: readonly TypeNode[] | undefined, isTypeOf?: boolean): ImportTypeNode;</span>
        <span class="s1">createParenthesizedType(type: TypeNode): ParenthesizedTypeNode;</span>
        <span class="s1">updateParenthesizedType(node: ParenthesizedTypeNode, type: TypeNode): ParenthesizedTypeNode;</span>
        <span class="s1">createThisTypeNode(): ThisTypeNode;</span>
        <span class="s1">createTypeOperatorNode(operator: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.ReadonlyKeyword, type: TypeNode): TypeOperatorNode;</span>
        <span class="s1">updateTypeOperatorNode(node: TypeOperatorNode, type: TypeNode): TypeOperatorNode;</span>
        <span class="s1">createIndexedAccessTypeNode(objectType: TypeNode, indexType: TypeNode): IndexedAccessTypeNode;</span>
        <span class="s1">updateIndexedAccessTypeNode(node: IndexedAccessTypeNode, objectType: TypeNode, indexType: TypeNode): IndexedAccessTypeNode;</span>
        <span class="s1">createMappedTypeNode(readonlyToken: ReadonlyKeyword | PlusToken | MinusToken | undefined, typeParameter: TypeParameterDeclaration, nameType: TypeNode | undefined, questionToken: QuestionToken | PlusToken | MinusToken | undefined, type: TypeNode | undefined, members: NodeArray&lt;TypeElement&gt; | undefined): MappedTypeNode;</span>
        <span class="s1">updateMappedTypeNode(node: MappedTypeNode, readonlyToken: ReadonlyKeyword | PlusToken | MinusToken | undefined, typeParameter: TypeParameterDeclaration, nameType: TypeNode | undefined, questionToken: QuestionToken | PlusToken | MinusToken | undefined, type: TypeNode | undefined, members: NodeArray&lt;TypeElement&gt; | undefined): MappedTypeNode;</span>
        <span class="s1">createLiteralTypeNode(literal: LiteralTypeNode[</span><span class="s3">&quot;literal&quot;</span><span class="s1">]): LiteralTypeNode;</span>
        <span class="s1">updateLiteralTypeNode(node: LiteralTypeNode, literal: LiteralTypeNode[</span><span class="s3">&quot;literal&quot;</span><span class="s1">]): LiteralTypeNode;</span>
        <span class="s1">createTemplateLiteralType(head: TemplateHead, templateSpans: readonly TemplateLiteralTypeSpan[]): TemplateLiteralTypeNode;</span>
        <span class="s1">updateTemplateLiteralType(node: TemplateLiteralTypeNode, head: TemplateHead, templateSpans: readonly TemplateLiteralTypeSpan[]): TemplateLiteralTypeNode;</span>
        <span class="s1">createObjectBindingPattern(elements: readonly BindingElement[]): ObjectBindingPattern;</span>
        <span class="s1">updateObjectBindingPattern(node: ObjectBindingPattern, elements: readonly BindingElement[]): ObjectBindingPattern;</span>
        <span class="s1">createArrayBindingPattern(elements: readonly ArrayBindingElement[]): ArrayBindingPattern;</span>
        <span class="s1">updateArrayBindingPattern(node: ArrayBindingPattern, elements: readonly ArrayBindingElement[]): ArrayBindingPattern;</span>
        <span class="s1">createBindingElement(dotDotDotToken: DotDotDotToken | undefined, propertyName: string | PropertyName | undefined, name: string | BindingName, initializer?: Expression): BindingElement;</span>
        <span class="s1">updateBindingElement(node: BindingElement, dotDotDotToken: DotDotDotToken | undefined, propertyName: PropertyName | undefined, name: BindingName, initializer: Expression | undefined): BindingElement;</span>
        <span class="s1">createArrayLiteralExpression(elements?: readonly Expression[], multiLine?: boolean): ArrayLiteralExpression;</span>
        <span class="s1">updateArrayLiteralExpression(node: ArrayLiteralExpression, elements: readonly Expression[]): ArrayLiteralExpression;</span>
        <span class="s1">createObjectLiteralExpression(properties?: readonly ObjectLiteralElementLike[], multiLine?: boolean): ObjectLiteralExpression;</span>
        <span class="s1">updateObjectLiteralExpression(node: ObjectLiteralExpression, properties: readonly ObjectLiteralElementLike[]): ObjectLiteralExpression;</span>
        <span class="s1">createPropertyAccessExpression(expression: Expression, name: string | MemberName): PropertyAccessExpression;</span>
        <span class="s1">updatePropertyAccessExpression(node: PropertyAccessExpression, expression: Expression, name: MemberName): PropertyAccessExpression;</span>
        <span class="s1">createPropertyAccessChain(expression: Expression, questionDotToken: QuestionDotToken | undefined, name: string | MemberName): PropertyAccessChain;</span>
        <span class="s1">updatePropertyAccessChain(node: PropertyAccessChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, name: MemberName): PropertyAccessChain;</span>
        <span class="s1">createElementAccessExpression(expression: Expression, index: number | Expression): ElementAccessExpression;</span>
        <span class="s1">updateElementAccessExpression(node: ElementAccessExpression, expression: Expression, argumentExpression: Expression): ElementAccessExpression;</span>
        <span class="s1">createElementAccessChain(expression: Expression, questionDotToken: QuestionDotToken | undefined, index: number | Expression): ElementAccessChain;</span>
        <span class="s1">updateElementAccessChain(node: ElementAccessChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, argumentExpression: Expression): ElementAccessChain;</span>
        <span class="s1">createCallExpression(expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): CallExpression;</span>
        <span class="s1">updateCallExpression(node: CallExpression, expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[]): CallExpression;</span>
        <span class="s1">createCallChain(expression: Expression, questionDotToken: QuestionDotToken | undefined, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): CallChain;</span>
        <span class="s1">updateCallChain(node: CallChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[]): CallChain;</span>
        <span class="s1">createNewExpression(expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): NewExpression;</span>
        <span class="s1">updateNewExpression(node: NewExpression, expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): NewExpression;</span>
        <span class="s1">createTaggedTemplateExpression(tag: Expression, typeArguments: readonly TypeNode[] | undefined, template: TemplateLiteral): TaggedTemplateExpression;</span>
        <span class="s1">updateTaggedTemplateExpression(node: TaggedTemplateExpression, tag: Expression, typeArguments: readonly TypeNode[] | undefined, template: TemplateLiteral): TaggedTemplateExpression;</span>
        <span class="s1">createTypeAssertion(type: TypeNode, expression: Expression): TypeAssertion;</span>
        <span class="s1">updateTypeAssertion(node: TypeAssertion, type: TypeNode, expression: Expression): TypeAssertion;</span>
        <span class="s1">createParenthesizedExpression(expression: Expression): ParenthesizedExpression;</span>
        <span class="s1">updateParenthesizedExpression(node: ParenthesizedExpression, expression: Expression): ParenthesizedExpression;</span>
        <span class="s1">createFunctionExpression(modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[] | undefined, type: TypeNode | undefined, body: Block): FunctionExpression;</span>
        <span class="s1">updateFunctionExpression(node: FunctionExpression, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block): FunctionExpression;</span>
        <span class="s1">createArrowFunction(modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, equalsGreaterThanToken: EqualsGreaterThanToken | undefined, body: ConciseBody): ArrowFunction;</span>
        <span class="s1">updateArrowFunction(node: ArrowFunction, modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, equalsGreaterThanToken: EqualsGreaterThanToken, body: ConciseBody): ArrowFunction;</span>
        <span class="s1">createDeleteExpression(expression: Expression): DeleteExpression;</span>
        <span class="s1">updateDeleteExpression(node: DeleteExpression, expression: Expression): DeleteExpression;</span>
        <span class="s1">createTypeOfExpression(expression: Expression): TypeOfExpression;</span>
        <span class="s1">updateTypeOfExpression(node: TypeOfExpression, expression: Expression): TypeOfExpression;</span>
        <span class="s1">createVoidExpression(expression: Expression): VoidExpression;</span>
        <span class="s1">updateVoidExpression(node: VoidExpression, expression: Expression): VoidExpression;</span>
        <span class="s1">createAwaitExpression(expression: Expression): AwaitExpression;</span>
        <span class="s1">updateAwaitExpression(node: AwaitExpression, expression: Expression): AwaitExpression;</span>
        <span class="s1">createPrefixUnaryExpression(operator: PrefixUnaryOperator, operand: Expression): PrefixUnaryExpression;</span>
        <span class="s1">updatePrefixUnaryExpression(node: PrefixUnaryExpression, operand: Expression): PrefixUnaryExpression;</span>
        <span class="s1">createPostfixUnaryExpression(operand: Expression, operator: PostfixUnaryOperator): PostfixUnaryExpression;</span>
        <span class="s1">updatePostfixUnaryExpression(node: PostfixUnaryExpression, operand: Expression): PostfixUnaryExpression;</span>
        <span class="s1">createBinaryExpression(left: Expression, operator: BinaryOperator | BinaryOperatorToken, right: Expression): BinaryExpression;</span>
        <span class="s1">updateBinaryExpression(node: BinaryExpression, left: Expression, operator: BinaryOperator | BinaryOperatorToken, right: Expression): BinaryExpression;</span>
        <span class="s1">createConditionalExpression(condition: Expression, questionToken: QuestionToken | undefined, whenTrue: Expression, colonToken: ColonToken | undefined, whenFalse: Expression): ConditionalExpression;</span>
        <span class="s1">updateConditionalExpression(node: ConditionalExpression, condition: Expression, questionToken: QuestionToken, whenTrue: Expression, colonToken: ColonToken, whenFalse: Expression): ConditionalExpression;</span>
        <span class="s1">createTemplateExpression(head: TemplateHead, templateSpans: readonly TemplateSpan[]): TemplateExpression;</span>
        <span class="s1">updateTemplateExpression(node: TemplateExpression, head: TemplateHead, templateSpans: readonly TemplateSpan[]): TemplateExpression;</span>
        <span class="s1">createTemplateHead(text: string, rawText?: string, templateFlags?: TokenFlags): TemplateHead;</span>
        <span class="s1">createTemplateHead(text: string | undefined, rawText: string, templateFlags?: TokenFlags): TemplateHead;</span>
        <span class="s1">createTemplateMiddle(text: string, rawText?: string, templateFlags?: TokenFlags): TemplateMiddle;</span>
        <span class="s1">createTemplateMiddle(text: string | undefined, rawText: string, templateFlags?: TokenFlags): TemplateMiddle;</span>
        <span class="s1">createTemplateTail(text: string, rawText?: string, templateFlags?: TokenFlags): TemplateTail;</span>
        <span class="s1">createTemplateTail(text: string | undefined, rawText: string, templateFlags?: TokenFlags): TemplateTail;</span>
        <span class="s1">createNoSubstitutionTemplateLiteral(text: string, rawText?: string): NoSubstitutionTemplateLiteral;</span>
        <span class="s1">createNoSubstitutionTemplateLiteral(text: string | undefined, rawText: string): NoSubstitutionTemplateLiteral;</span>
        <span class="s1">createYieldExpression(asteriskToken: AsteriskToken, expression: Expression): YieldExpression;</span>
        <span class="s1">createYieldExpression(asteriskToken: undefined, expression: Expression | undefined): YieldExpression;</span>
        <span class="s1">updateYieldExpression(node: YieldExpression, asteriskToken: AsteriskToken | undefined, expression: Expression | undefined): YieldExpression;</span>
        <span class="s1">createSpreadElement(expression: Expression): SpreadElement;</span>
        <span class="s1">updateSpreadElement(node: SpreadElement, expression: Expression): SpreadElement;</span>
        <span class="s1">createClassExpression(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;</span>
        <span class="s1">updateClassExpression(node: ClassExpression, modifiers: readonly ModifierLike[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;</span>
        <span class="s1">createOmittedExpression(): OmittedExpression;</span>
        <span class="s1">createExpressionWithTypeArguments(expression: Expression, typeArguments: readonly TypeNode[] | undefined): ExpressionWithTypeArguments;</span>
        <span class="s1">updateExpressionWithTypeArguments(node: ExpressionWithTypeArguments, expression: Expression, typeArguments: readonly TypeNode[] | undefined): ExpressionWithTypeArguments;</span>
        <span class="s1">createAsExpression(expression: Expression, type: TypeNode): AsExpression;</span>
        <span class="s1">updateAsExpression(node: AsExpression, expression: Expression, type: TypeNode): AsExpression;</span>
        <span class="s1">createNonNullExpression(expression: Expression): NonNullExpression;</span>
        <span class="s1">updateNonNullExpression(node: NonNullExpression, expression: Expression): NonNullExpression;</span>
        <span class="s1">createNonNullChain(expression: Expression): NonNullChain;</span>
        <span class="s1">updateNonNullChain(node: NonNullChain, expression: Expression): NonNullChain;</span>
        <span class="s1">createMetaProperty(keywordToken: MetaProperty[</span><span class="s3">&quot;keywordToken&quot;</span><span class="s1">], name: Identifier): MetaProperty;</span>
        <span class="s1">updateMetaProperty(node: MetaProperty, name: Identifier): MetaProperty;</span>
        <span class="s1">createSatisfiesExpression(expression: Expression, type: TypeNode): SatisfiesExpression;</span>
        <span class="s1">updateSatisfiesExpression(node: SatisfiesExpression, expression: Expression, type: TypeNode): SatisfiesExpression;</span>
        <span class="s1">createTemplateSpan(expression: Expression, literal: TemplateMiddle | TemplateTail): TemplateSpan;</span>
        <span class="s1">updateTemplateSpan(node: TemplateSpan, expression: Expression, literal: TemplateMiddle | TemplateTail): TemplateSpan;</span>
        <span class="s1">createSemicolonClassElement(): SemicolonClassElement;</span>
        <span class="s1">createBlock(statements: readonly Statement[], multiLine?: boolean): Block;</span>
        <span class="s1">updateBlock(node: Block, statements: readonly Statement[]): Block;</span>
        <span class="s1">createVariableStatement(modifiers: readonly ModifierLike[] | undefined, declarationList: VariableDeclarationList | readonly VariableDeclaration[]): VariableStatement;</span>
        <span class="s1">updateVariableStatement(node: VariableStatement, modifiers: readonly ModifierLike[] | undefined, declarationList: VariableDeclarationList): VariableStatement;</span>
        <span class="s1">createEmptyStatement(): EmptyStatement;</span>
        <span class="s1">createExpressionStatement(expression: Expression): ExpressionStatement;</span>
        <span class="s1">updateExpressionStatement(node: ExpressionStatement, expression: Expression): ExpressionStatement;</span>
        <span class="s1">createIfStatement(expression: Expression, thenStatement: Statement, elseStatement?: Statement): IfStatement;</span>
        <span class="s1">updateIfStatement(node: IfStatement, expression: Expression, thenStatement: Statement, elseStatement: Statement | undefined): IfStatement;</span>
        <span class="s1">createDoStatement(statement: Statement, expression: Expression): DoStatement;</span>
        <span class="s1">updateDoStatement(node: DoStatement, statement: Statement, expression: Expression): DoStatement;</span>
        <span class="s1">createWhileStatement(expression: Expression, statement: Statement): WhileStatement;</span>
        <span class="s1">updateWhileStatement(node: WhileStatement, expression: Expression, statement: Statement): WhileStatement;</span>
        <span class="s1">createForStatement(initializer: ForInitializer | undefined, condition: Expression | undefined, incrementor: Expression | undefined, statement: Statement): ForStatement;</span>
        <span class="s1">updateForStatement(node: ForStatement, initializer: ForInitializer | undefined, condition: Expression | undefined, incrementor: Expression | undefined, statement: Statement): ForStatement;</span>
        <span class="s1">createForInStatement(initializer: ForInitializer, expression: Expression, statement: Statement): ForInStatement;</span>
        <span class="s1">updateForInStatement(node: ForInStatement, initializer: ForInitializer, expression: Expression, statement: Statement): ForInStatement;</span>
        <span class="s1">createForOfStatement(awaitModifier: AwaitKeyword | undefined, initializer: ForInitializer, expression: Expression, statement: Statement): ForOfStatement;</span>
        <span class="s1">updateForOfStatement(node: ForOfStatement, awaitModifier: AwaitKeyword | undefined, initializer: ForInitializer, expression: Expression, statement: Statement): ForOfStatement;</span>
        <span class="s1">createContinueStatement(label?: string | Identifier): ContinueStatement;</span>
        <span class="s1">updateContinueStatement(node: ContinueStatement, label: Identifier | undefined): ContinueStatement;</span>
        <span class="s1">createBreakStatement(label?: string | Identifier): BreakStatement;</span>
        <span class="s1">updateBreakStatement(node: BreakStatement, label: Identifier | undefined): BreakStatement;</span>
        <span class="s1">createReturnStatement(expression?: Expression): ReturnStatement;</span>
        <span class="s1">updateReturnStatement(node: ReturnStatement, expression: Expression | undefined): ReturnStatement;</span>
        <span class="s1">createWithStatement(expression: Expression, statement: Statement): WithStatement;</span>
        <span class="s1">updateWithStatement(node: WithStatement, expression: Expression, statement: Statement): WithStatement;</span>
        <span class="s1">createSwitchStatement(expression: Expression, caseBlock: CaseBlock): SwitchStatement;</span>
        <span class="s1">updateSwitchStatement(node: SwitchStatement, expression: Expression, caseBlock: CaseBlock): SwitchStatement;</span>
        <span class="s1">createLabeledStatement(label: string | Identifier, statement: Statement): LabeledStatement;</span>
        <span class="s1">updateLabeledStatement(node: LabeledStatement, label: Identifier, statement: Statement): LabeledStatement;</span>
        <span class="s1">createThrowStatement(expression: Expression): ThrowStatement;</span>
        <span class="s1">updateThrowStatement(node: ThrowStatement, expression: Expression): ThrowStatement;</span>
        <span class="s1">createTryStatement(tryBlock: Block, catchClause: CatchClause | undefined, finallyBlock: Block | undefined): TryStatement;</span>
        <span class="s1">updateTryStatement(node: TryStatement, tryBlock: Block, catchClause: CatchClause | undefined, finallyBlock: Block | undefined): TryStatement;</span>
        <span class="s1">createDebuggerStatement(): DebuggerStatement;</span>
        <span class="s1">createVariableDeclaration(name: string | BindingName, exclamationToken?: ExclamationToken, type?: TypeNode, initializer?: Expression): VariableDeclaration;</span>
        <span class="s1">updateVariableDeclaration(node: VariableDeclaration, name: BindingName, exclamationToken: ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): VariableDeclaration;</span>
        <span class="s1">createVariableDeclarationList(declarations: readonly VariableDeclaration[], flags?: NodeFlags): VariableDeclarationList;</span>
        <span class="s1">updateVariableDeclarationList(node: VariableDeclarationList, declarations: readonly VariableDeclaration[]): VariableDeclarationList;</span>
        <span class="s1">createFunctionDeclaration(modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;</span>
        <span class="s1">updateFunctionDeclaration(node: FunctionDeclaration, modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;</span>
        <span class="s1">createClassDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;</span>
        <span class="s1">updateClassDeclaration(node: ClassDeclaration, modifiers: readonly ModifierLike[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;</span>
        <span class="s1">createInterfaceDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;</span>
        <span class="s1">updateInterfaceDeclaration(node: InterfaceDeclaration, modifiers: readonly ModifierLike[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;</span>
        <span class="s1">createTypeAliasDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;</span>
        <span class="s1">updateTypeAliasDeclaration(node: TypeAliasDeclaration, modifiers: readonly ModifierLike[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;</span>
        <span class="s1">createEnumDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier, members: readonly EnumMember[]): EnumDeclaration;</span>
        <span class="s1">updateEnumDeclaration(node: EnumDeclaration, modifiers: readonly ModifierLike[] | undefined, name: Identifier, members: readonly EnumMember[]): EnumDeclaration;</span>
        <span class="s1">createModuleDeclaration(modifiers: readonly ModifierLike[] | undefined, name: ModuleName, body: ModuleBody | undefined, flags?: NodeFlags): ModuleDeclaration;</span>
        <span class="s1">updateModuleDeclaration(node: ModuleDeclaration, modifiers: readonly ModifierLike[] | undefined, name: ModuleName, body: ModuleBody | undefined): ModuleDeclaration;</span>
        <span class="s1">createModuleBlock(statements: readonly Statement[]): ModuleBlock;</span>
        <span class="s1">updateModuleBlock(node: ModuleBlock, statements: readonly Statement[]): ModuleBlock;</span>
        <span class="s1">createCaseBlock(clauses: readonly CaseOrDefaultClause[]): CaseBlock;</span>
        <span class="s1">updateCaseBlock(node: CaseBlock, clauses: readonly CaseOrDefaultClause[]): CaseBlock;</span>
        <span class="s1">createNamespaceExportDeclaration(name: string | Identifier): NamespaceExportDeclaration;</span>
        <span class="s1">updateNamespaceExportDeclaration(node: NamespaceExportDeclaration, name: Identifier): NamespaceExportDeclaration;</span>
        <span class="s1">createImportEqualsDeclaration(modifiers: readonly ModifierLike[] | undefined, isTypeOnly: boolean, name: string | Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;</span>
        <span class="s1">updateImportEqualsDeclaration(node: ImportEqualsDeclaration, modifiers: readonly ModifierLike[] | undefined, isTypeOnly: boolean, name: Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;</span>
        <span class="s1">createImportDeclaration(modifiers: readonly ModifierLike[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, attributes?: ImportAttributes): ImportDeclaration;</span>
        <span class="s1">updateImportDeclaration(node: ImportDeclaration, modifiers: readonly ModifierLike[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, attributes: ImportAttributes | undefined): ImportDeclaration;</span>
        <span class="s1">createImportClause(phaseModifier: ImportPhaseModifierSyntaxKind | undefined, name: Identifier | undefined, namedBindings: NamedImportBindings | undefined): ImportClause;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/ </span><span class="s1">createImportClause(isTypeOnly: boolean, name: Identifier | undefined, namedBindings: NamedImportBindings | undefined): ImportClause;</span>
        <span class="s1">updateImportClause(node: ImportClause, phaseModifier: ImportPhaseModifierSyntaxKind | undefined, name: Identifier | undefined, namedBindings: NamedImportBindings | undefined): ImportClause;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/ </span><span class="s1">updateImportClause(node: ImportClause, isTypeOnly: boolean, name: Identifier | undefined, namedBindings: NamedImportBindings | undefined): ImportClause;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/ </span><span class="s1">createAssertClause(elements: NodeArray&lt;AssertEntry&gt;, multiLine?: boolean): AssertClause;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/ </span><span class="s1">updateAssertClause(node: AssertClause, elements: NodeArray&lt;AssertEntry&gt;, multiLine?: boolean): AssertClause;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/ </span><span class="s1">createAssertEntry(name: AssertionKey, value: Expression): AssertEntry;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/ </span><span class="s1">updateAssertEntry(node: AssertEntry, name: AssertionKey, value: Expression): AssertEntry;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/ </span><span class="s1">createImportTypeAssertionContainer(clause: AssertClause, multiLine?: boolean): ImportTypeAssertionContainer;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/ </span><span class="s1">updateImportTypeAssertionContainer(node: ImportTypeAssertionContainer, clause: AssertClause, multiLine?: boolean): ImportTypeAssertionContainer;</span>
        <span class="s1">createImportAttributes(elements: NodeArray&lt;ImportAttribute&gt;, multiLine?: boolean): ImportAttributes;</span>
        <span class="s1">updateImportAttributes(node: ImportAttributes, elements: NodeArray&lt;ImportAttribute&gt;, multiLine?: boolean): ImportAttributes;</span>
        <span class="s1">createImportAttribute(name: ImportAttributeName, value: Expression): ImportAttribute;</span>
        <span class="s1">updateImportAttribute(node: ImportAttribute, name: ImportAttributeName, value: Expression): ImportAttribute;</span>
        <span class="s1">createNamespaceImport(name: Identifier): NamespaceImport;</span>
        <span class="s1">updateNamespaceImport(node: NamespaceImport, name: Identifier): NamespaceImport;</span>
        <span class="s1">createNamespaceExport(name: ModuleExportName): NamespaceExport;</span>
        <span class="s1">updateNamespaceExport(node: NamespaceExport, name: ModuleExportName): NamespaceExport;</span>
        <span class="s1">createNamedImports(elements: readonly ImportSpecifier[]): NamedImports;</span>
        <span class="s1">updateNamedImports(node: NamedImports, elements: readonly ImportSpecifier[]): NamedImports;</span>
        <span class="s1">createImportSpecifier(isTypeOnly: boolean, propertyName: ModuleExportName | undefined, name: Identifier): ImportSpecifier;</span>
        <span class="s1">updateImportSpecifier(node: ImportSpecifier, isTypeOnly: boolean, propertyName: ModuleExportName | undefined, name: Identifier): ImportSpecifier;</span>
        <span class="s1">createExportAssignment(modifiers: readonly ModifierLike[] | undefined, isExportEquals: boolean | undefined, expression: Expression): ExportAssignment;</span>
        <span class="s1">updateExportAssignment(node: ExportAssignment, modifiers: readonly ModifierLike[] | undefined, expression: Expression): ExportAssignment;</span>
        <span class="s1">createExportDeclaration(modifiers: readonly ModifierLike[] | undefined, isTypeOnly: boolean, exportClause: NamedExportBindings | undefined, moduleSpecifier?: Expression, attributes?: ImportAttributes): ExportDeclaration;</span>
        <span class="s1">updateExportDeclaration(node: ExportDeclaration, modifiers: readonly ModifierLike[] | undefined, isTypeOnly: boolean, exportClause: NamedExportBindings | undefined, moduleSpecifier: Expression | undefined, attributes: ImportAttributes | undefined): ExportDeclaration;</span>
        <span class="s1">createNamedExports(elements: readonly ExportSpecifier[]): NamedExports;</span>
        <span class="s1">updateNamedExports(node: NamedExports, elements: readonly ExportSpecifier[]): NamedExports;</span>
        <span class="s1">createExportSpecifier(isTypeOnly: boolean, propertyName: string | ModuleExportName | undefined, name: string | ModuleExportName): ExportSpecifier;</span>
        <span class="s1">updateExportSpecifier(node: ExportSpecifier, isTypeOnly: boolean, propertyName: ModuleExportName | undefined, name: ModuleExportName): ExportSpecifier;</span>
        <span class="s1">createExternalModuleReference(expression: Expression): ExternalModuleReference;</span>
        <span class="s1">updateExternalModuleReference(node: ExternalModuleReference, expression: Expression): ExternalModuleReference;</span>
        <span class="s1">createJSDocAllType(): JSDocAllType;</span>
        <span class="s1">createJSDocUnknownType(): JSDocUnknownType;</span>
        <span class="s1">createJSDocNonNullableType(type: TypeNode, postfix?: boolean): JSDocNonNullableType;</span>
        <span class="s1">updateJSDocNonNullableType(node: JSDocNonNullableType, type: TypeNode): JSDocNonNullableType;</span>
        <span class="s1">createJSDocNullableType(type: TypeNode, postfix?: boolean): JSDocNullableType;</span>
        <span class="s1">updateJSDocNullableType(node: JSDocNullableType, type: TypeNode): JSDocNullableType;</span>
        <span class="s1">createJSDocOptionalType(type: TypeNode): JSDocOptionalType;</span>
        <span class="s1">updateJSDocOptionalType(node: JSDocOptionalType, type: TypeNode): JSDocOptionalType;</span>
        <span class="s1">createJSDocFunctionType(parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): JSDocFunctionType;</span>
        <span class="s1">updateJSDocFunctionType(node: JSDocFunctionType, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): JSDocFunctionType;</span>
        <span class="s1">createJSDocVariadicType(type: TypeNode): JSDocVariadicType;</span>
        <span class="s1">updateJSDocVariadicType(node: JSDocVariadicType, type: TypeNode): JSDocVariadicType;</span>
        <span class="s1">createJSDocNamepathType(type: TypeNode): JSDocNamepathType;</span>
        <span class="s1">updateJSDocNamepathType(node: JSDocNamepathType, type: TypeNode): JSDocNamepathType;</span>
        <span class="s1">createJSDocTypeExpression(type: TypeNode): JSDocTypeExpression;</span>
        <span class="s1">updateJSDocTypeExpression(node: JSDocTypeExpression, type: TypeNode): JSDocTypeExpression;</span>
        <span class="s1">createJSDocNameReference(name: EntityName | JSDocMemberName): JSDocNameReference;</span>
        <span class="s1">updateJSDocNameReference(node: JSDocNameReference, name: EntityName | JSDocMemberName): JSDocNameReference;</span>
        <span class="s1">createJSDocMemberName(left: EntityName | JSDocMemberName, right: Identifier): JSDocMemberName;</span>
        <span class="s1">updateJSDocMemberName(node: JSDocMemberName, left: EntityName | JSDocMemberName, right: Identifier): JSDocMemberName;</span>
        <span class="s1">createJSDocLink(name: EntityName | JSDocMemberName | undefined, text: string): JSDocLink;</span>
        <span class="s1">updateJSDocLink(node: JSDocLink, name: EntityName | JSDocMemberName | undefined, text: string): JSDocLink;</span>
        <span class="s1">createJSDocLinkCode(name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkCode;</span>
        <span class="s1">updateJSDocLinkCode(node: JSDocLinkCode, name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkCode;</span>
        <span class="s1">createJSDocLinkPlain(name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkPlain;</span>
        <span class="s1">updateJSDocLinkPlain(node: JSDocLinkPlain, name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkPlain;</span>
        <span class="s1">createJSDocTypeLiteral(jsDocPropertyTags?: readonly JSDocPropertyLikeTag[], isArrayType?: boolean): JSDocTypeLiteral;</span>
        <span class="s1">updateJSDocTypeLiteral(node: JSDocTypeLiteral, jsDocPropertyTags: readonly JSDocPropertyLikeTag[] | undefined, isArrayType: boolean | undefined): JSDocTypeLiteral;</span>
        <span class="s1">createJSDocSignature(typeParameters: readonly JSDocTemplateTag[] | undefined, parameters: readonly JSDocParameterTag[], type?: JSDocReturnTag): JSDocSignature;</span>
        <span class="s1">updateJSDocSignature(node: JSDocSignature, typeParameters: readonly JSDocTemplateTag[] | undefined, parameters: readonly JSDocParameterTag[], type: JSDocReturnTag | undefined): JSDocSignature;</span>
        <span class="s1">createJSDocTemplateTag(tagName: Identifier | undefined, constraint: JSDocTypeExpression | undefined, typeParameters: readonly TypeParameterDeclaration[], comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocTemplateTag;</span>
        <span class="s1">updateJSDocTemplateTag(node: JSDocTemplateTag, tagName: Identifier | undefined, constraint: JSDocTypeExpression | undefined, typeParameters: readonly TypeParameterDeclaration[], comment: string | NodeArray&lt;JSDocComment&gt; | undefined): JSDocTemplateTag;</span>
        <span class="s1">createJSDocTypedefTag(tagName: Identifier | undefined, typeExpression?: JSDocTypeExpression | JSDocTypeLiteral, fullName?: Identifier | JSDocNamespaceDeclaration, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocTypedefTag;</span>
        <span class="s1">updateJSDocTypedefTag(node: JSDocTypedefTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | JSDocTypeLiteral | undefined, fullName: Identifier | JSDocNamespaceDeclaration | undefined, comment: string | NodeArray&lt;JSDocComment&gt; | undefined): JSDocTypedefTag;</span>
        <span class="s1">createJSDocParameterTag(tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression, isNameFirst?: boolean, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocParameterTag;</span>
        <span class="s1">updateJSDocParameterTag(node: JSDocParameterTag, tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression: JSDocTypeExpression | undefined, isNameFirst: boolean, comment: string | NodeArray&lt;JSDocComment&gt; | undefined): JSDocParameterTag;</span>
        <span class="s1">createJSDocPropertyTag(tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression, isNameFirst?: boolean, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocPropertyTag;</span>
        <span class="s1">updateJSDocPropertyTag(node: JSDocPropertyTag, tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression: JSDocTypeExpression | undefined, isNameFirst: boolean, comment: string | NodeArray&lt;JSDocComment&gt; | undefined): JSDocPropertyTag;</span>
        <span class="s1">createJSDocTypeTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocTypeTag;</span>
        <span class="s1">updateJSDocTypeTag(node: JSDocTypeTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment: string | NodeArray&lt;JSDocComment&gt; | undefined): JSDocTypeTag;</span>
        <span class="s1">createJSDocSeeTag(tagName: Identifier | undefined, nameExpression: JSDocNameReference | undefined, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocSeeTag;</span>
        <span class="s1">updateJSDocSeeTag(node: JSDocSeeTag, tagName: Identifier | undefined, nameExpression: JSDocNameReference | undefined, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocSeeTag;</span>
        <span class="s1">createJSDocReturnTag(tagName: Identifier | undefined, typeExpression?: JSDocTypeExpression, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocReturnTag;</span>
        <span class="s1">updateJSDocReturnTag(node: JSDocReturnTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | undefined, comment: string | NodeArray&lt;JSDocComment&gt; | undefined): JSDocReturnTag;</span>
        <span class="s1">createJSDocThisTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocThisTag;</span>
        <span class="s1">updateJSDocThisTag(node: JSDocThisTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | undefined, comment: string | NodeArray&lt;JSDocComment&gt; | undefined): JSDocThisTag;</span>
        <span class="s1">createJSDocEnumTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocEnumTag;</span>
        <span class="s1">updateJSDocEnumTag(node: JSDocEnumTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment: string | NodeArray&lt;JSDocComment&gt; | undefined): JSDocEnumTag;</span>
        <span class="s1">createJSDocCallbackTag(tagName: Identifier | undefined, typeExpression: JSDocSignature, fullName?: Identifier | JSDocNamespaceDeclaration, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocCallbackTag;</span>
        <span class="s1">updateJSDocCallbackTag(node: JSDocCallbackTag, tagName: Identifier | undefined, typeExpression: JSDocSignature, fullName: Identifier | JSDocNamespaceDeclaration | undefined, comment: string | NodeArray&lt;JSDocComment&gt; | undefined): JSDocCallbackTag;</span>
        <span class="s1">createJSDocOverloadTag(tagName: Identifier | undefined, typeExpression: JSDocSignature, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocOverloadTag;</span>
        <span class="s1">updateJSDocOverloadTag(node: JSDocOverloadTag, tagName: Identifier | undefined, typeExpression: JSDocSignature, comment: string | NodeArray&lt;JSDocComment&gt; | undefined): JSDocOverloadTag;</span>
        <span class="s1">createJSDocAugmentsTag(tagName: Identifier | undefined, className: JSDocAugmentsTag[</span><span class="s3">&quot;class&quot;</span><span class="s1">], comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocAugmentsTag;</span>
        <span class="s1">updateJSDocAugmentsTag(node: JSDocAugmentsTag, tagName: Identifier | undefined, className: JSDocAugmentsTag[</span><span class="s3">&quot;class&quot;</span><span class="s1">], comment: string | NodeArray&lt;JSDocComment&gt; | undefined): JSDocAugmentsTag;</span>
        <span class="s1">createJSDocImplementsTag(tagName: Identifier | undefined, className: JSDocImplementsTag[</span><span class="s3">&quot;class&quot;</span><span class="s1">], comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocImplementsTag;</span>
        <span class="s1">updateJSDocImplementsTag(node: JSDocImplementsTag, tagName: Identifier | undefined, className: JSDocImplementsTag[</span><span class="s3">&quot;class&quot;</span><span class="s1">], comment: string | NodeArray&lt;JSDocComment&gt; | undefined): JSDocImplementsTag;</span>
        <span class="s1">createJSDocAuthorTag(tagName: Identifier | undefined, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocAuthorTag;</span>
        <span class="s1">updateJSDocAuthorTag(node: JSDocAuthorTag, tagName: Identifier | undefined, comment: string | NodeArray&lt;JSDocComment&gt; | undefined): JSDocAuthorTag;</span>
        <span class="s1">createJSDocClassTag(tagName: Identifier | undefined, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocClassTag;</span>
        <span class="s1">updateJSDocClassTag(node: JSDocClassTag, tagName: Identifier | undefined, comment: string | NodeArray&lt;JSDocComment&gt; | undefined): JSDocClassTag;</span>
        <span class="s1">createJSDocPublicTag(tagName: Identifier | undefined, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocPublicTag;</span>
        <span class="s1">updateJSDocPublicTag(node: JSDocPublicTag, tagName: Identifier | undefined, comment: string | NodeArray&lt;JSDocComment&gt; | undefined): JSDocPublicTag;</span>
        <span class="s1">createJSDocPrivateTag(tagName: Identifier | undefined, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocPrivateTag;</span>
        <span class="s1">updateJSDocPrivateTag(node: JSDocPrivateTag, tagName: Identifier | undefined, comment: string | NodeArray&lt;JSDocComment&gt; | undefined): JSDocPrivateTag;</span>
        <span class="s1">createJSDocProtectedTag(tagName: Identifier | undefined, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocProtectedTag;</span>
        <span class="s1">updateJSDocProtectedTag(node: JSDocProtectedTag, tagName: Identifier | undefined, comment: string | NodeArray&lt;JSDocComment&gt; | undefined): JSDocProtectedTag;</span>
        <span class="s1">createJSDocReadonlyTag(tagName: Identifier | undefined, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocReadonlyTag;</span>
        <span class="s1">updateJSDocReadonlyTag(node: JSDocReadonlyTag, tagName: Identifier | undefined, comment: string | NodeArray&lt;JSDocComment&gt; | undefined): JSDocReadonlyTag;</span>
        <span class="s1">createJSDocUnknownTag(tagName: Identifier, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocUnknownTag;</span>
        <span class="s1">updateJSDocUnknownTag(node: JSDocUnknownTag, tagName: Identifier, comment: string | NodeArray&lt;JSDocComment&gt; | undefined): JSDocUnknownTag;</span>
        <span class="s1">createJSDocDeprecatedTag(tagName: Identifier | undefined, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocDeprecatedTag;</span>
        <span class="s1">updateJSDocDeprecatedTag(node: JSDocDeprecatedTag, tagName: Identifier | undefined, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocDeprecatedTag;</span>
        <span class="s1">createJSDocOverrideTag(tagName: Identifier | undefined, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocOverrideTag;</span>
        <span class="s1">updateJSDocOverrideTag(node: JSDocOverrideTag, tagName: Identifier | undefined, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocOverrideTag;</span>
        <span class="s1">createJSDocThrowsTag(tagName: Identifier, typeExpression: JSDocTypeExpression | undefined, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocThrowsTag;</span>
        <span class="s1">updateJSDocThrowsTag(node: JSDocThrowsTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | undefined, comment?: string | NodeArray&lt;JSDocComment&gt; | undefined): JSDocThrowsTag;</span>
        <span class="s1">createJSDocSatisfiesTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocSatisfiesTag;</span>
        <span class="s1">updateJSDocSatisfiesTag(node: JSDocSatisfiesTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment: string | NodeArray&lt;JSDocComment&gt; | undefined): JSDocSatisfiesTag;</span>
        <span class="s1">createJSDocImportTag(tagName: Identifier | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, attributes?: ImportAttributes, comment?: string | NodeArray&lt;JSDocComment&gt;): JSDocImportTag;</span>
        <span class="s1">updateJSDocImportTag(node: JSDocImportTag, tagName: Identifier | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, attributes: ImportAttributes | undefined, comment: string | NodeArray&lt;JSDocComment&gt; | undefined): JSDocImportTag;</span>
        <span class="s1">createJSDocText(text: string): JSDocText;</span>
        <span class="s1">updateJSDocText(node: JSDocText, text: string): JSDocText;</span>
        <span class="s1">createJSDocComment(comment?: string | NodeArray&lt;JSDocComment&gt; | undefined, tags?: readonly JSDocTag[] | undefined): JSDoc;</span>
        <span class="s1">updateJSDocComment(node: JSDoc, comment: string | NodeArray&lt;JSDocComment&gt; | undefined, tags: readonly JSDocTag[] | undefined): JSDoc;</span>
        <span class="s1">createJsxElement(openingElement: JsxOpeningElement, children: readonly JsxChild[], closingElement: JsxClosingElement): JsxElement;</span>
        <span class="s1">updateJsxElement(node: JsxElement, openingElement: JsxOpeningElement, children: readonly JsxChild[], closingElement: JsxClosingElement): JsxElement;</span>
        <span class="s1">createJsxSelfClosingElement(tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxSelfClosingElement;</span>
        <span class="s1">updateJsxSelfClosingElement(node: JsxSelfClosingElement, tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxSelfClosingElement;</span>
        <span class="s1">createJsxOpeningElement(tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxOpeningElement;</span>
        <span class="s1">updateJsxOpeningElement(node: JsxOpeningElement, tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxOpeningElement;</span>
        <span class="s1">createJsxClosingElement(tagName: JsxTagNameExpression): JsxClosingElement;</span>
        <span class="s1">updateJsxClosingElement(node: JsxClosingElement, tagName: JsxTagNameExpression): JsxClosingElement;</span>
        <span class="s1">createJsxFragment(openingFragment: JsxOpeningFragment, children: readonly JsxChild[], closingFragment: JsxClosingFragment): JsxFragment;</span>
        <span class="s1">createJsxText(text: string, containsOnlyTriviaWhiteSpaces?: boolean): JsxText;</span>
        <span class="s1">updateJsxText(node: JsxText, text: string, containsOnlyTriviaWhiteSpaces?: boolean): JsxText;</span>
        <span class="s1">createJsxOpeningFragment(): JsxOpeningFragment;</span>
        <span class="s1">createJsxJsxClosingFragment(): JsxClosingFragment;</span>
        <span class="s1">updateJsxFragment(node: JsxFragment, openingFragment: JsxOpeningFragment, children: readonly JsxChild[], closingFragment: JsxClosingFragment): JsxFragment;</span>
        <span class="s1">createJsxAttribute(name: JsxAttributeName, initializer: JsxAttributeValue | undefined): JsxAttribute;</span>
        <span class="s1">updateJsxAttribute(node: JsxAttribute, name: JsxAttributeName, initializer: JsxAttributeValue | undefined): JsxAttribute;</span>
        <span class="s1">createJsxAttributes(properties: readonly JsxAttributeLike[]): JsxAttributes;</span>
        <span class="s1">updateJsxAttributes(node: JsxAttributes, properties: readonly JsxAttributeLike[]): JsxAttributes;</span>
        <span class="s1">createJsxSpreadAttribute(expression: Expression): JsxSpreadAttribute;</span>
        <span class="s1">updateJsxSpreadAttribute(node: JsxSpreadAttribute, expression: Expression): JsxSpreadAttribute;</span>
        <span class="s1">createJsxExpression(dotDotDotToken: DotDotDotToken | undefined, expression: Expression | undefined): JsxExpression;</span>
        <span class="s1">updateJsxExpression(node: JsxExpression, expression: Expression | undefined): JsxExpression;</span>
        <span class="s1">createJsxNamespacedName(namespace: Identifier, name: Identifier): JsxNamespacedName;</span>
        <span class="s1">updateJsxNamespacedName(node: JsxNamespacedName, namespace: Identifier, name: Identifier): JsxNamespacedName;</span>
        <span class="s1">createCaseClause(expression: Expression, statements: readonly Statement[]): CaseClause;</span>
        <span class="s1">updateCaseClause(node: CaseClause, expression: Expression, statements: readonly Statement[]): CaseClause;</span>
        <span class="s1">createDefaultClause(statements: readonly Statement[]): DefaultClause;</span>
        <span class="s1">updateDefaultClause(node: DefaultClause, statements: readonly Statement[]): DefaultClause;</span>
        <span class="s1">createHeritageClause(token: HeritageClause[</span><span class="s3">&quot;token&quot;</span><span class="s1">], types: readonly ExpressionWithTypeArguments[]): HeritageClause;</span>
        <span class="s1">updateHeritageClause(node: HeritageClause, types: readonly ExpressionWithTypeArguments[]): HeritageClause;</span>
        <span class="s1">createCatchClause(variableDeclaration: string | BindingName | VariableDeclaration | undefined, block: Block): CatchClause;</span>
        <span class="s1">updateCatchClause(node: CatchClause, variableDeclaration: VariableDeclaration | undefined, block: Block): CatchClause;</span>
        <span class="s1">createPropertyAssignment(name: string | PropertyName, initializer: Expression): PropertyAssignment;</span>
        <span class="s1">updatePropertyAssignment(node: PropertyAssignment, name: PropertyName, initializer: Expression): PropertyAssignment;</span>
        <span class="s1">createShorthandPropertyAssignment(name: string | Identifier, objectAssignmentInitializer?: Expression): ShorthandPropertyAssignment;</span>
        <span class="s1">updateShorthandPropertyAssignment(node: ShorthandPropertyAssignment, name: Identifier, objectAssignmentInitializer: Expression | undefined): ShorthandPropertyAssignment;</span>
        <span class="s1">createSpreadAssignment(expression: Expression): SpreadAssignment;</span>
        <span class="s1">updateSpreadAssignment(node: SpreadAssignment, expression: Expression): SpreadAssignment;</span>
        <span class="s1">createEnumMember(name: string | PropertyName, initializer?: Expression): EnumMember;</span>
        <span class="s1">updateEnumMember(node: EnumMember, name: PropertyName, initializer: Expression | undefined): EnumMember;</span>
        <span class="s1">createSourceFile(statements: readonly Statement[], endOfFileToken: EndOfFileToken, flags: NodeFlags): SourceFile;</span>
        <span class="s1">updateSourceFile(node: SourceFile, statements: readonly Statement[], isDeclarationFile?: boolean, referencedFiles?: readonly FileReference[], typeReferences?: readonly FileReference[], hasNoDefaultLib?: boolean, libReferences?: readonly FileReference[]): SourceFile;</span>
        <span class="s1">createNotEmittedStatement(original: Node): NotEmittedStatement;</span>
        <span class="s1">createNotEmittedTypeElement(): NotEmittedTypeElement;</span>
        <span class="s1">createPartiallyEmittedExpression(expression: Expression, original?: Node): PartiallyEmittedExpression;</span>
        <span class="s1">updatePartiallyEmittedExpression(node: PartiallyEmittedExpression, expression: Expression): PartiallyEmittedExpression;</span>
        <span class="s1">createCommaListExpression(elements: readonly Expression[]): CommaListExpression;</span>
        <span class="s1">updateCommaListExpression(node: CommaListExpression, elements: readonly Expression[]): CommaListExpression;</span>
        <span class="s1">createBundle(sourceFiles: readonly SourceFile[]): Bundle;</span>
        <span class="s1">updateBundle(node: Bundle, sourceFiles: readonly SourceFile[]): Bundle;</span>
        <span class="s1">createComma(left: Expression, right: Expression): BinaryExpression;</span>
        <span class="s1">createAssignment(left: ObjectLiteralExpression | ArrayLiteralExpression, right: Expression): DestructuringAssignment;</span>
        <span class="s1">createAssignment(left: Expression, right: Expression): AssignmentExpression&lt;EqualsToken&gt;;</span>
        <span class="s1">createLogicalOr(left: Expression, right: Expression): BinaryExpression;</span>
        <span class="s1">createLogicalAnd(left: Expression, right: Expression): BinaryExpression;</span>
        <span class="s1">createBitwiseOr(left: Expression, right: Expression): BinaryExpression;</span>
        <span class="s1">createBitwiseXor(left: Expression, right: Expression): BinaryExpression;</span>
        <span class="s1">createBitwiseAnd(left: Expression, right: Expression): BinaryExpression;</span>
        <span class="s1">createStrictEquality(left: Expression, right: Expression): BinaryExpression;</span>
        <span class="s1">createStrictInequality(left: Expression, right: Expression): BinaryExpression;</span>
        <span class="s1">createEquality(left: Expression, right: Expression): BinaryExpression;</span>
        <span class="s1">createInequality(left: Expression, right: Expression): BinaryExpression;</span>
        <span class="s1">createLessThan(left: Expression, right: Expression): BinaryExpression;</span>
        <span class="s1">createLessThanEquals(left: Expression, right: Expression): BinaryExpression;</span>
        <span class="s1">createGreaterThan(left: Expression, right: Expression): BinaryExpression;</span>
        <span class="s1">createGreaterThanEquals(left: Expression, right: Expression): BinaryExpression;</span>
        <span class="s1">createLeftShift(left: Expression, right: Expression): BinaryExpression;</span>
        <span class="s1">createRightShift(left: Expression, right: Expression): BinaryExpression;</span>
        <span class="s1">createUnsignedRightShift(left: Expression, right: Expression): BinaryExpression;</span>
        <span class="s1">createAdd(left: Expression, right: Expression): BinaryExpression;</span>
        <span class="s1">createSubtract(left: Expression, right: Expression): BinaryExpression;</span>
        <span class="s1">createMultiply(left: Expression, right: Expression): BinaryExpression;</span>
        <span class="s1">createDivide(left: Expression, right: Expression): BinaryExpression;</span>
        <span class="s1">createModulo(left: Expression, right: Expression): BinaryExpression;</span>
        <span class="s1">createExponent(left: Expression, right: Expression): BinaryExpression;</span>
        <span class="s1">createPrefixPlus(operand: Expression): PrefixUnaryExpression;</span>
        <span class="s1">createPrefixMinus(operand: Expression): PrefixUnaryExpression;</span>
        <span class="s1">createPrefixIncrement(operand: Expression): PrefixUnaryExpression;</span>
        <span class="s1">createPrefixDecrement(operand: Expression): PrefixUnaryExpression;</span>
        <span class="s1">createBitwiseNot(operand: Expression): PrefixUnaryExpression;</span>
        <span class="s1">createLogicalNot(operand: Expression): PrefixUnaryExpression;</span>
        <span class="s1">createPostfixIncrement(operand: Expression): PostfixUnaryExpression;</span>
        <span class="s1">createPostfixDecrement(operand: Expression): PostfixUnaryExpression;</span>
        <span class="s1">createImmediatelyInvokedFunctionExpression(statements: readonly Statement[]): CallExpression;</span>
        <span class="s1">createImmediatelyInvokedFunctionExpression(statements: readonly Statement[], param: ParameterDeclaration, paramValue: Expression): CallExpression;</span>
        <span class="s1">createImmediatelyInvokedArrowFunction(statements: readonly Statement[]): ImmediatelyInvokedArrowFunction;</span>
        <span class="s1">createImmediatelyInvokedArrowFunction(statements: readonly Statement[], param: ParameterDeclaration, paramValue: Expression): ImmediatelyInvokedArrowFunction;</span>
        <span class="s1">createVoidZero(): VoidExpression;</span>
        <span class="s1">createExportDefault(expression: Expression): ExportAssignment;</span>
        <span class="s1">createExternalModuleExport(exportName: Identifier): ExportDeclaration;</span>
        <span class="s1">restoreOuterExpressions(outerExpression: Expression | undefined, innerExpression: Expression, kinds?: OuterExpressionKinds): Expression;</span>
        <span class="s0">/**</span>
         <span class="s0">* Updates a node that may contain modifiers, replacing only the modifiers of the node.</span>
         <span class="s0">*/</span>
        <span class="s1">replaceModifiers&lt;T </span><span class="s2">extends </span><span class="s1">HasModifiers&gt;(node: T, modifiers: readonly Modifier[] | ModifierFlags | undefined): T;</span>
        <span class="s0">/**</span>
         <span class="s0">* Updates a node that may contain decorators or modifiers, replacing only the decorators and modifiers of the node.</span>
         <span class="s0">*/</span>
        <span class="s1">replaceDecoratorsAndModifiers&lt;T </span><span class="s2">extends </span><span class="s1">HasModifiers &amp; HasDecorators&gt;(node: T, modifiers: readonly ModifierLike[] | undefined): T;</span>
        <span class="s0">/**</span>
         <span class="s0">* Updates a node that contains a property name, replacing only the name of the node.</span>
         <span class="s0">*/</span>
        <span class="s1">replacePropertyName&lt;T </span><span class="s2">extends </span><span class="s1">AccessorDeclaration | MethodDeclaration | MethodSignature | PropertyDeclaration | PropertySignature | PropertyAssignment&gt;(node: T, name: T[</span><span class="s3">&quot;name&quot;</span><span class="s1">]): T;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">CoreTransformationContext {</span>
        <span class="s1">readonly factory: NodeFactory;</span>
        <span class="s0">/** Gets the compiler options supplied to the transformer. */</span>
        <span class="s1">getCompilerOptions(): CompilerOptions;</span>
        <span class="s0">/** Starts a new lexical environment. */</span>
        <span class="s1">startLexicalEnvironment(): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s0">/** Suspends the current lexical environment, usually after visiting a parameter list. */</span>
        <span class="s1">suspendLexicalEnvironment(): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s0">/** Resumes a suspended lexical environment, usually before visiting a function body. */</span>
        <span class="s1">resumeLexicalEnvironment(): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s0">/** Ends a lexical environment, returning any declarations. */</span>
        <span class="s1">endLexicalEnvironment(): Statement[] | undefined;</span>
        <span class="s0">/** Hoists a function declaration to the containing scope. */</span>
        <span class="s1">hoistFunctionDeclaration(node: FunctionDeclaration): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s0">/** Hoists a variable declaration to the containing scope. */</span>
        <span class="s1">hoistVariableDeclaration(node: Identifier): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TransformationContext </span><span class="s2">extends </span><span class="s1">CoreTransformationContext {</span>
        <span class="s0">/** Records a request for a non-scoped emit helper in the current context. */</span>
        <span class="s1">requestEmitHelper(helper: EmitHelper): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s0">/** Gets and resets the requested non-scoped emit helpers. */</span>
        <span class="s1">readEmitHelpers(): EmitHelper[] | undefined;</span>
        <span class="s0">/** Enables expression substitutions in the pretty printer for the provided SyntaxKind. */</span>
        <span class="s1">enableSubstitution(kind: SyntaxKind): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s0">/** Determines whether expression substitutions are enabled for the provided node. */</span>
        <span class="s1">isSubstitutionEnabled(node: Node): boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Hook used by transformers to substitute expressions just before they</span>
         <span class="s0">* are emitted by the pretty printer.</span>
         <span class="s0">*</span>
         <span class="s0">* NOTE: Transformation hooks should only be modified during `Transformer` initialization,</span>
         <span class="s0">* before returning the `NodeTransformer` callback.</span>
         <span class="s0">*/</span>
        <span class="s1">onSubstituteNode: (hint: EmitHint, node: Node) =&gt; Node;</span>
        <span class="s0">/**</span>
         <span class="s0">* Enables before/after emit notifications in the pretty printer for the provided</span>
         <span class="s0">* SyntaxKind.</span>
         <span class="s0">*/</span>
        <span class="s1">enableEmitNotification(kind: SyntaxKind): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Determines whether before/after emit notifications should be raised in the pretty</span>
         <span class="s0">* printer when it emits a node.</span>
         <span class="s0">*/</span>
        <span class="s1">isEmitNotificationEnabled(node: Node): boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Hook used to allow transformers to capture state before or after</span>
         <span class="s0">* the printer emits a node.</span>
         <span class="s0">*</span>
         <span class="s0">* NOTE: Transformation hooks should only be modified during `Transformer` initialization,</span>
         <span class="s0">* before returning the `NodeTransformer` callback.</span>
         <span class="s0">*/</span>
        <span class="s1">onEmitNode: (hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) =&gt; </span><span class="s2">void</span><span class="s1">) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TransformationResult&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt; {</span>
        <span class="s0">/** Gets the transformed source files. */</span>
        <span class="s1">transformed: T[];</span>
        <span class="s0">/** Gets diagnostics for the transformation. */</span>
        <span class="s1">diagnostics?: DiagnosticWithLocation[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets a substitute for a node, if one is available; otherwise, returns the original node.</span>
         <span class="s0">*</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">hint A hint as to the intended usage of the node.</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">node The node to substitute.</span>
         <span class="s0">*/</span>
        <span class="s1">substituteNode(hint: EmitHint, node: Node): Node;</span>
        <span class="s0">/**</span>
         <span class="s0">* Emits a node with possible notification.</span>
         <span class="s0">*</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">hint A hint as to the intended usage of the node.</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">node The node to emit.</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">emitCallback A callback used to emit the node.</span>
         <span class="s0">*/</span>
        <span class="s1">emitNodeWithNotification(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) =&gt; </span><span class="s2">void</span><span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Indicates if a given node needs an emit notification</span>
         <span class="s0">*</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">node The node to emit.</span>
         <span class="s0">*/</span>
        <span class="s1">isEmitNotificationEnabled?(node: Node): boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Clean up EmitNode entries on any parse-tree nodes.</span>
         <span class="s0">*/</span>
        <span class="s1">dispose(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A function that is used to initialize and return a `Transformer` callback, which in turn</span>
     <span class="s0">* will be used to transform one or more nodes.</span>
     <span class="s0">*/</span>
    <span class="s1">type TransformerFactory&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt; = (context: TransformationContext) =&gt; Transformer&lt;T&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* A function that transforms a node.</span>
     <span class="s0">*/</span>
    <span class="s1">type Transformer&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt; = (node: T) =&gt; T;</span>
    <span class="s0">/**</span>
     <span class="s0">* A function that accepts and possibly transforms a node.</span>
     <span class="s0">*/</span>
    <span class="s1">type Visitor&lt;TIn </span><span class="s2">extends </span><span class="s1">Node = Node, TOut </span><span class="s2">extends </span><span class="s1">Node | undefined = TIn | undefined&gt; = (node: TIn) =&gt; VisitResult&lt;TOut&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* A function that walks a node using the given visitor, lifting node arrays into single nodes,</span>
     <span class="s0">* returning an node which satisfies the test.</span>
     <span class="s0">*</span>
     <span class="s0">* - If the input node is undefined, then the output is undefined.</span>
     <span class="s0">* - If the visitor returns undefined, then the output is undefined.</span>
     <span class="s0">* - If the output node is not undefined, then it will satisfy the test function.</span>
     <span class="s0">* - In order to obtain a return type that is more specific than `Node`, a test</span>
     <span class="s0">*   function _must_ be provided, and that function must be a type predicate.</span>
     <span class="s0">*</span>
     <span class="s0">* For the canonical implementation of this type, @see {visitNode}.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">NodeVisitor {</span>
        <span class="s1">&lt;TIn </span><span class="s2">extends </span><span class="s1">Node | undefined, TVisited </span><span class="s2">extends </span><span class="s1">Node | undefined, TOut </span><span class="s2">extends </span><span class="s1">Node&gt;(node: TIn, visitor: Visitor&lt;NonNullable&lt;TIn&gt;, TVisited&gt;, test: (node: Node) =&gt; node is TOut, lift?: (node: readonly Node[]) =&gt; Node): TOut | (TIn &amp; undefined) | (TVisited &amp; undefined);</span>
        <span class="s1">&lt;TIn </span><span class="s2">extends </span><span class="s1">Node | undefined, TVisited </span><span class="s2">extends </span><span class="s1">Node | undefined&gt;(node: TIn, visitor: Visitor&lt;NonNullable&lt;TIn&gt;, TVisited&gt;, test?: (node: Node) =&gt; boolean, lift?: (node: readonly Node[]) =&gt; Node): Node | (TIn &amp; undefined) | (TVisited &amp; undefined);</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A function that walks a node array using the given visitor, returning an array whose contents satisfy the test.</span>
     <span class="s0">*</span>
     <span class="s0">* - If the input node array is undefined, the output is undefined.</span>
     <span class="s0">* - If the visitor can return undefined, the node it visits in the array will be reused.</span>
     <span class="s0">* - If the output node array is not undefined, then its contents will satisfy the test.</span>
     <span class="s0">* - In order to obtain a return type that is more specific than `NodeArray&lt;Node&gt;`, a test</span>
     <span class="s0">*   function _must_ be provided, and that function must be a type predicate.</span>
     <span class="s0">*</span>
     <span class="s0">* For the canonical implementation of this type, @see {visitNodes}.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">NodesVisitor {</span>
        <span class="s1">&lt;TIn </span><span class="s2">extends </span><span class="s1">Node, TInArray </span><span class="s2">extends </span><span class="s1">NodeArray&lt;TIn&gt; | undefined, TOut </span><span class="s2">extends </span><span class="s1">Node&gt;(nodes: TInArray, visitor: Visitor&lt;TIn, Node | undefined&gt;, test: (node: Node) =&gt; node is TOut, start?: number, count?: number): NodeArray&lt;TOut&gt; | (TInArray &amp; undefined);</span>
        <span class="s1">&lt;TIn </span><span class="s2">extends </span><span class="s1">Node, TInArray </span><span class="s2">extends </span><span class="s1">NodeArray&lt;TIn&gt; | undefined&gt;(nodes: TInArray, visitor: Visitor&lt;TIn, Node | undefined&gt;, test?: (node: Node) =&gt; boolean, start?: number, count?: number): NodeArray&lt;Node&gt; | (TInArray &amp; undefined);</span>
    <span class="s1">}</span>
    <span class="s1">type VisitResult&lt;T </span><span class="s2">extends </span><span class="s1">Node | undefined&gt; = T | readonly Node[];</span>
    <span class="s2">interface </span><span class="s1">Printer {</span>
        <span class="s0">/**</span>
         <span class="s0">* Print a node and its subtree as-is, without any emit transformations.</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">hint A value indicating the purpose of a node. This is primarily used to</span>
         <span class="s0">* distinguish between an `Identifier` used in an expression position, versus an</span>
         <span class="s0">* `Identifier` used as an `IdentifierName` as part of a declaration. For most nodes you</span>
         <span class="s0">* should just pass `Unspecified`.</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">node The node to print. The node and its subtree are printed as-is, without any</span>
         <span class="s0">* emit transformations.</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">sourceFile A source file that provides context for the node. The source text of</span>
         <span class="s0">* the file is used to emit the original source content for literals and identifiers, while</span>
         <span class="s0">* the identifiers of the source file are used when generating unique names to avoid</span>
         <span class="s0">* collisions.</span>
         <span class="s0">*/</span>
        <span class="s1">printNode(hint: EmitHint, node: Node, sourceFile: SourceFile): string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Prints a list of nodes using the given format flags</span>
         <span class="s0">*/</span>
        <span class="s1">printList&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt;(format: ListFormat, list: NodeArray&lt;T&gt;, sourceFile: SourceFile): string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Prints a source file as-is, without any emit transformations.</span>
         <span class="s0">*/</span>
        <span class="s1">printFile(sourceFile: SourceFile): string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Prints a bundle of source files as-is, without any emit transformations.</span>
         <span class="s0">*/</span>
        <span class="s1">printBundle(bundle: Bundle): string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">PrintHandlers {</span>
        <span class="s0">/**</span>
         <span class="s0">* A hook used by the Printer when generating unique names to avoid collisions with</span>
         <span class="s0">* globally defined names that exist outside of the current source file.</span>
         <span class="s0">*/</span>
        <span class="s1">hasGlobalName?(name: string): boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* A hook used by the Printer to provide notifications prior to emitting a node. A</span>
         <span class="s0">* compatible implementation **must** invoke `emitCallback` with the provided `hint` and</span>
         <span class="s0">* `node` values.</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">hint A hint indicating the intended purpose of the node.</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">node The node to emit.</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">emitCallback A callback that, when invoked, will emit the node.</span>
         <span class="s0">* </span><span class="s4">@example</span>
         <span class="s0">* ```ts</span>
         <span class="s0">* var printer = createPrinter(printerOptions, {</span>
         <span class="s0">*   onEmitNode(hint, node, emitCallback) {</span>
         <span class="s0">*     // set up or track state prior to emitting the node...</span>
         <span class="s0">*     emitCallback(hint, node);</span>
         <span class="s0">*     // restore state after emitting the node...</span>
         <span class="s0">*   }</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">*/</span>
        <span class="s1">onEmitNode?(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) =&gt; </span><span class="s2">void</span><span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A hook used to check if an emit notification is required for a node.</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">node The node to emit.</span>
         <span class="s0">*/</span>
        <span class="s1">isEmitNotificationEnabled?(node: Node): boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* A hook used by the Printer to perform just-in-time substitution of a node. This is</span>
         <span class="s0">* primarily used by node transformations that need to substitute one node for another,</span>
         <span class="s0">* such as replacing `myExportedVar` with `exports.myExportedVar`.</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">hint A hint indicating the intended purpose of the node.</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">node The node to emit.</span>
         <span class="s0">* </span><span class="s4">@example</span>
         <span class="s0">* ```ts</span>
         <span class="s0">* var printer = createPrinter(printerOptions, {</span>
         <span class="s0">*   substituteNode(hint, node) {</span>
         <span class="s0">*     // perform substitution if necessary...</span>
         <span class="s0">*     return node;</span>
         <span class="s0">*   }</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">*/</span>
        <span class="s1">substituteNode?(hint: EmitHint, node: Node): Node;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">PrinterOptions {</span>
        <span class="s1">removeComments?: boolean;</span>
        <span class="s1">newLine?: NewLineKind;</span>
        <span class="s1">omitTrailingSemicolon?: boolean;</span>
        <span class="s1">noEmitHelpers?: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">GetEffectiveTypeRootsHost {</span>
        <span class="s1">getCurrentDirectory?(): string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TextSpan {</span>
        <span class="s1">start: number;</span>
        <span class="s1">length: number;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TextChangeRange {</span>
        <span class="s1">span: TextSpan;</span>
        <span class="s1">newLength: number;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SyntaxList </span><span class="s2">extends </span><span class="s1">Node {</span>
        <span class="s1">kind: SyntaxKind.SyntaxList;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">ListFormat {</span>
        <span class="s1">None = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">SingleLine = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">MultiLine = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">PreserveLines = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">LinesMask = </span><span class="s5">3</span><span class="s1">,</span>
        <span class="s1">NotDelimited = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">BarDelimited = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">AmpersandDelimited = </span><span class="s5">8</span><span class="s1">,</span>
        <span class="s1">CommaDelimited = </span><span class="s5">16</span><span class="s1">,</span>
        <span class="s1">AsteriskDelimited = </span><span class="s5">32</span><span class="s1">,</span>
        <span class="s1">DelimitersMask = </span><span class="s5">60</span><span class="s1">,</span>
        <span class="s1">AllowTrailingComma = </span><span class="s5">64</span><span class="s1">,</span>
        <span class="s1">Indented = </span><span class="s5">128</span><span class="s1">,</span>
        <span class="s1">SpaceBetweenBraces = </span><span class="s5">256</span><span class="s1">,</span>
        <span class="s1">SpaceBetweenSiblings = </span><span class="s5">512</span><span class="s1">,</span>
        <span class="s1">Braces = </span><span class="s5">1024</span><span class="s1">,</span>
        <span class="s1">Parenthesis = </span><span class="s5">2048</span><span class="s1">,</span>
        <span class="s1">AngleBrackets = </span><span class="s5">4096</span><span class="s1">,</span>
        <span class="s1">SquareBrackets = </span><span class="s5">8192</span><span class="s1">,</span>
        <span class="s1">BracketsMask = </span><span class="s5">15360</span><span class="s1">,</span>
        <span class="s1">OptionalIfUndefined = </span><span class="s5">16384</span><span class="s1">,</span>
        <span class="s1">OptionalIfEmpty = </span><span class="s5">32768</span><span class="s1">,</span>
        <span class="s1">Optional = </span><span class="s5">49152</span><span class="s1">,</span>
        <span class="s1">PreferNewLine = </span><span class="s5">65536</span><span class="s1">,</span>
        <span class="s1">NoTrailingNewLine = </span><span class="s5">131072</span><span class="s1">,</span>
        <span class="s1">NoInterveningComments = </span><span class="s5">262144</span><span class="s1">,</span>
        <span class="s1">NoSpaceIfEmpty = </span><span class="s5">524288</span><span class="s1">,</span>
        <span class="s1">SingleElement = </span><span class="s5">1048576</span><span class="s1">,</span>
        <span class="s1">SpaceAfterList = </span><span class="s5">2097152</span><span class="s1">,</span>
        <span class="s1">Modifiers = </span><span class="s5">2359808</span><span class="s1">,</span>
        <span class="s1">HeritageClauses = </span><span class="s5">512</span><span class="s1">,</span>
        <span class="s1">SingleLineTypeLiteralMembers = </span><span class="s5">768</span><span class="s1">,</span>
        <span class="s1">MultiLineTypeLiteralMembers = </span><span class="s5">32897</span><span class="s1">,</span>
        <span class="s1">SingleLineTupleTypeElements = </span><span class="s5">528</span><span class="s1">,</span>
        <span class="s1">MultiLineTupleTypeElements = </span><span class="s5">657</span><span class="s1">,</span>
        <span class="s1">UnionTypeConstituents = </span><span class="s5">516</span><span class="s1">,</span>
        <span class="s1">IntersectionTypeConstituents = </span><span class="s5">520</span><span class="s1">,</span>
        <span class="s1">ObjectBindingPatternElements = </span><span class="s5">525136</span><span class="s1">,</span>
        <span class="s1">ArrayBindingPatternElements = </span><span class="s5">524880</span><span class="s1">,</span>
        <span class="s1">ObjectLiteralExpressionProperties = </span><span class="s5">526226</span><span class="s1">,</span>
        <span class="s1">ImportAttributes = </span><span class="s5">526226</span><span class="s1">,</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/ </span><span class="s1">ImportClauseEntries = </span><span class="s5">526226</span><span class="s1">,</span>
        <span class="s1">ArrayLiteralExpressionElements = </span><span class="s5">8914</span><span class="s1">,</span>
        <span class="s1">CommaListElements = </span><span class="s5">528</span><span class="s1">,</span>
        <span class="s1">CallExpressionArguments = </span><span class="s5">2576</span><span class="s1">,</span>
        <span class="s1">NewExpressionArguments = </span><span class="s5">18960</span><span class="s1">,</span>
        <span class="s1">TemplateExpressionSpans = </span><span class="s5">262144</span><span class="s1">,</span>
        <span class="s1">SingleLineBlockStatements = </span><span class="s5">768</span><span class="s1">,</span>
        <span class="s1">MultiLineBlockStatements = </span><span class="s5">129</span><span class="s1">,</span>
        <span class="s1">VariableDeclarationList = </span><span class="s5">528</span><span class="s1">,</span>
        <span class="s1">SingleLineFunctionBodyStatements = </span><span class="s5">768</span><span class="s1">,</span>
        <span class="s1">MultiLineFunctionBodyStatements = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">ClassHeritageClauses = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">ClassMembers = </span><span class="s5">129</span><span class="s1">,</span>
        <span class="s1">InterfaceMembers = </span><span class="s5">129</span><span class="s1">,</span>
        <span class="s1">EnumMembers = </span><span class="s5">145</span><span class="s1">,</span>
        <span class="s1">CaseBlockClauses = </span><span class="s5">129</span><span class="s1">,</span>
        <span class="s1">NamedImportsOrExportsElements = </span><span class="s5">525136</span><span class="s1">,</span>
        <span class="s1">JsxElementOrFragmentChildren = </span><span class="s5">262144</span><span class="s1">,</span>
        <span class="s1">JsxElementAttributes = </span><span class="s5">262656</span><span class="s1">,</span>
        <span class="s1">CaseOrDefaultClauseStatements = </span><span class="s5">163969</span><span class="s1">,</span>
        <span class="s1">HeritageClauseTypes = </span><span class="s5">528</span><span class="s1">,</span>
        <span class="s1">SourceFileStatements = </span><span class="s5">131073</span><span class="s1">,</span>
        <span class="s1">Decorators = </span><span class="s5">2146305</span><span class="s1">,</span>
        <span class="s1">TypeArguments = </span><span class="s5">53776</span><span class="s1">,</span>
        <span class="s1">TypeParameters = </span><span class="s5">53776</span><span class="s1">,</span>
        <span class="s1">Parameters = </span><span class="s5">2576</span><span class="s1">,</span>
        <span class="s1">IndexSignatureParameters = </span><span class="s5">8848</span><span class="s1">,</span>
        <span class="s1">JSDocComment = </span><span class="s5">33</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">JSDocParsingMode {</span>
        <span class="s0">/**</span>
         <span class="s0">* Always parse JSDoc comments and include them in the AST.</span>
         <span class="s0">*</span>
         <span class="s0">* This is the default if no mode is provided.</span>
         <span class="s0">*/</span>
        <span class="s1">ParseAll = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/**</span>
         <span class="s0">* Never parse JSDoc comments, mo matter the file type.</span>
         <span class="s0">*/</span>
        <span class="s1">ParseNone = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s0">/**</span>
         <span class="s0">* Parse only JSDoc comments which are needed to provide correct type errors.</span>
         <span class="s0">*</span>
         <span class="s0">* This will always parse JSDoc in non-TS files, but only parse JSDoc comments</span>
         <span class="s0">* containing `@see` and `@link` in TS files.</span>
         <span class="s0">*/</span>
        <span class="s1">ParseForTypeErrors = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s0">/**</span>
         <span class="s0">* Parse only JSDoc comments which are needed to provide correct type info.</span>
         <span class="s0">*</span>
         <span class="s0">* This will always parse JSDoc in non-TS files, but never in TS files.</span>
         <span class="s0">*</span>
         <span class="s0">* Note: Do not use this mode if you require accurate type errors; use {</span><span class="s4">@link </span><span class="s0">ParseForTypeErrors} instead.</span>
         <span class="s0">*/</span>
        <span class="s1">ParseForTypeInfo = </span><span class="s5">3</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">UserPreferences {</span>
        <span class="s1">readonly disableSuggestions?: boolean;</span>
        <span class="s1">readonly quotePreference?: </span><span class="s3">&quot;auto&quot; </span><span class="s1">| </span><span class="s3">&quot;double&quot; </span><span class="s1">| </span><span class="s3">&quot;single&quot;</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If enabled, TypeScript will search through all external modules' exports and add them to the completions list.</span>
         <span class="s0">* This affects lone identifier completions but not completions on the right hand side of `obj.`.</span>
         <span class="s0">*/</span>
        <span class="s1">readonly includeCompletionsForModuleExports?: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Enables auto-import-style completions on partially-typed import statements. E.g., allows</span>
         <span class="s0">* `import write|` to be completed to `import { writeFile } from &quot;fs&quot;`.</span>
         <span class="s0">*/</span>
        <span class="s1">readonly includeCompletionsForImportStatements?: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Allows completions to be formatted with snippet text, indicated by `CompletionItem[&quot;isSnippet&quot;]`.</span>
         <span class="s0">*/</span>
        <span class="s1">readonly includeCompletionsWithSnippetText?: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Unless this option is `false`, or `includeCompletionsWithInsertText` is not enabled,</span>
         <span class="s0">* member completion lists triggered with `.` will include entries on potentially-null and potentially-undefined</span>
         <span class="s0">* values, with insertion text to replace preceding `.` tokens with `?.`.</span>
         <span class="s0">*/</span>
        <span class="s1">readonly includeAutomaticOptionalChainCompletions?: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* If enabled, the completion list will include completions with invalid identifier names.</span>
         <span class="s0">* For those entries, The `insertText` and `replacementSpan` properties will be set to change from `.x` property access to `[&quot;x&quot;]`.</span>
         <span class="s0">*/</span>
        <span class="s1">readonly includeCompletionsWithInsertText?: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* If enabled, completions for class members (e.g. methods and properties) will include</span>
         <span class="s0">* a whole declaration for the member.</span>
         <span class="s0">* E.g., `class A { f| }` could be completed to `class A { foo(): number {} }`, instead of</span>
         <span class="s0">* `class A { foo }`.</span>
         <span class="s0">*/</span>
        <span class="s1">readonly includeCompletionsWithClassMemberSnippets?: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* If enabled, object literal methods will have a method declaration completion entry in addition</span>
         <span class="s0">* to the regular completion entry containing just the method name.</span>
         <span class="s0">* E.g., `const objectLiteral: T = { f| }` could be completed to `const objectLiteral: T = { foo(): void {} }`,</span>
         <span class="s0">* in addition to `const objectLiteral: T = { foo }`.</span>
         <span class="s0">*/</span>
        <span class="s1">readonly includeCompletionsWithObjectLiteralMethodSnippets?: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Indicates whether {</span><span class="s4">@link </span><span class="s0">CompletionEntry.labelDetails completion entry label details} are supported.</span>
         <span class="s0">* If not, contents of `labelDetails` may be included in the {</span><span class="s4">@link </span><span class="s0">CompletionEntry.name} property.</span>
         <span class="s0">*/</span>
        <span class="s1">readonly useLabelDetailsInCompletionEntries?: boolean;</span>
        <span class="s1">readonly allowIncompleteCompletions?: boolean;</span>
        <span class="s1">readonly importModuleSpecifierPreference?: </span><span class="s3">&quot;shortest&quot; </span><span class="s1">| </span><span class="s3">&quot;project-relative&quot; </span><span class="s1">| </span><span class="s3">&quot;relative&quot; </span><span class="s1">| </span><span class="s3">&quot;non-relative&quot;</span><span class="s1">;</span>
        <span class="s0">/** Determines whether we import `foo/index.ts` as &quot;foo&quot;, &quot;foo/index&quot;, or &quot;foo/index.js&quot; */</span>
        <span class="s1">readonly importModuleSpecifierEnding?: </span><span class="s3">&quot;auto&quot; </span><span class="s1">| </span><span class="s3">&quot;minimal&quot; </span><span class="s1">| </span><span class="s3">&quot;index&quot; </span><span class="s1">| </span><span class="s3">&quot;js&quot;</span><span class="s1">;</span>
        <span class="s1">readonly allowTextChangesInNewFiles?: boolean;</span>
        <span class="s1">readonly providePrefixAndSuffixTextForRename?: boolean;</span>
        <span class="s1">readonly includePackageJsonAutoImports?: </span><span class="s3">&quot;auto&quot; </span><span class="s1">| </span><span class="s3">&quot;on&quot; </span><span class="s1">| </span><span class="s3">&quot;off&quot;</span><span class="s1">;</span>
        <span class="s1">readonly provideRefactorNotApplicableReason?: boolean;</span>
        <span class="s1">readonly jsxAttributeCompletionStyle?: </span><span class="s3">&quot;auto&quot; </span><span class="s1">| </span><span class="s3">&quot;braces&quot; </span><span class="s1">| </span><span class="s3">&quot;none&quot;</span><span class="s1">;</span>
        <span class="s1">readonly includeInlayParameterNameHints?: </span><span class="s3">&quot;none&quot; </span><span class="s1">| </span><span class="s3">&quot;literals&quot; </span><span class="s1">| </span><span class="s3">&quot;all&quot;</span><span class="s1">;</span>
        <span class="s1">readonly includeInlayParameterNameHintsWhenArgumentMatchesName?: boolean;</span>
        <span class="s1">readonly includeInlayFunctionParameterTypeHints?: boolean;</span>
        <span class="s1">readonly includeInlayVariableTypeHints?: boolean;</span>
        <span class="s1">readonly includeInlayVariableTypeHintsWhenTypeMatchesName?: boolean;</span>
        <span class="s1">readonly includeInlayPropertyDeclarationTypeHints?: boolean;</span>
        <span class="s1">readonly includeInlayFunctionLikeReturnTypeHints?: boolean;</span>
        <span class="s1">readonly includeInlayEnumMemberValueHints?: boolean;</span>
        <span class="s1">readonly interactiveInlayHints?: boolean;</span>
        <span class="s1">readonly allowRenameOfImportPath?: boolean;</span>
        <span class="s1">readonly autoImportFileExcludePatterns?: string[];</span>
        <span class="s1">readonly autoImportSpecifierExcludeRegexes?: string[];</span>
        <span class="s1">readonly preferTypeOnlyAutoImports?: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Indicates whether imports should be organized in a case-insensitive manner.</span>
         <span class="s0">*/</span>
        <span class="s1">readonly organizeImportsIgnoreCase?: </span><span class="s3">&quot;auto&quot; </span><span class="s1">| boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Indicates whether imports should be organized via an &quot;ordinal&quot; (binary) comparison using the numeric value</span>
         <span class="s0">* of their code points, or via &quot;unicode&quot; collation (via the</span>
         <span class="s0">* [Unicode Collation Algorithm](https://unicode.org/reports/tr10/#Scope)) using rules associated with the locale</span>
         <span class="s0">* specified in {</span><span class="s4">@link </span><span class="s0">organizeImportsCollationLocale}.</span>
         <span class="s0">*</span>
         <span class="s0">* Default: `&quot;ordinal&quot;`.</span>
         <span class="s0">*/</span>
        <span class="s1">readonly organizeImportsCollation?: </span><span class="s3">&quot;ordinal&quot; </span><span class="s1">| </span><span class="s3">&quot;unicode&quot;</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Indicates the locale to use for &quot;unicode&quot; collation. If not specified, the locale `&quot;en&quot;` is used as an invariant</span>
         <span class="s0">* for the sake of consistent sorting. Use `&quot;auto&quot;` to use the detected UI locale.</span>
         <span class="s0">*</span>
         <span class="s0">* This preference is ignored if {</span><span class="s4">@link </span><span class="s0">organizeImportsCollation} is not `&quot;unicode&quot;`.</span>
         <span class="s0">*</span>
         <span class="s0">* Default: `&quot;en&quot;`</span>
         <span class="s0">*/</span>
        <span class="s1">readonly organizeImportsLocale?: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Indicates whether numeric collation should be used for digit sequences in strings. When `true`, will collate</span>
         <span class="s0">* strings such that `a1z &lt; a2z &lt; a100z`. When `false`, will collate strings such that `a1z &lt; a100z &lt; a2z`.</span>
         <span class="s0">*</span>
         <span class="s0">* This preference is ignored if {</span><span class="s4">@link </span><span class="s0">organizeImportsCollation} is not `&quot;unicode&quot;`.</span>
         <span class="s0">*</span>
         <span class="s0">* Default: `false`</span>
         <span class="s0">*/</span>
        <span class="s1">readonly organizeImportsNumericCollation?: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Indicates whether accents and other diacritic marks are considered unequal for the purpose of collation. When</span>
         <span class="s0">* `true`, characters with accents and other diacritics will be collated in the order defined by the locale specified</span>
         <span class="s0">* in {</span><span class="s4">@link </span><span class="s0">organizeImportsCollationLocale}.</span>
         <span class="s0">*</span>
         <span class="s0">* This preference is ignored if {</span><span class="s4">@link </span><span class="s0">organizeImportsCollation} is not `&quot;unicode&quot;`.</span>
         <span class="s0">*</span>
         <span class="s0">* Default: `true`</span>
         <span class="s0">*/</span>
        <span class="s1">readonly organizeImportsAccentCollation?: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Indicates whether upper case or lower case should sort first. When `false`, the default order for the locale</span>
         <span class="s0">* specified in {</span><span class="s4">@link </span><span class="s0">organizeImportsCollationLocale} is used.</span>
         <span class="s0">*</span>
         <span class="s0">* This preference is ignored if {</span><span class="s4">@link </span><span class="s0">organizeImportsCollation} is not `&quot;unicode&quot;`. This preference is also</span>
         <span class="s0">* ignored if we are using case-insensitive sorting, which occurs when {</span><span class="s4">@link </span><span class="s0">organizeImportsIgnoreCase} is `true`,</span>
         <span class="s0">* or if {</span><span class="s4">@link </span><span class="s0">organizeImportsIgnoreCase} is `&quot;auto&quot;` and the auto-detected case sensitivity is determined to be</span>
         <span class="s0">* case-insensitive.</span>
         <span class="s0">*</span>
         <span class="s0">* Default: `false`</span>
         <span class="s0">*/</span>
        <span class="s1">readonly organizeImportsCaseFirst?: </span><span class="s3">&quot;upper&quot; </span><span class="s1">| </span><span class="s3">&quot;lower&quot; </span><span class="s1">| </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Indicates where named type-only imports should sort. &quot;inline&quot; sorts named imports without regard to if the import is</span>
         <span class="s0">* type-only.</span>
         <span class="s0">*</span>
         <span class="s0">* Default: `last`</span>
         <span class="s0">*/</span>
        <span class="s1">readonly organizeImportsTypeOrder?: OrganizeImportsTypeOrder;</span>
        <span class="s0">/**</span>
         <span class="s0">* Indicates whether to exclude standard library and node_modules file symbols from navTo results.</span>
         <span class="s0">*/</span>
        <span class="s1">readonly excludeLibrarySymbolsInNavTo?: boolean;</span>
        <span class="s1">readonly lazyConfiguredProjectsFromExternalProject?: boolean;</span>
        <span class="s1">readonly displayPartsForJSDoc?: boolean;</span>
        <span class="s1">readonly generateReturnInDocTemplate?: boolean;</span>
        <span class="s1">readonly disableLineTextInReferences?: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* A positive integer indicating the maximum length of a hover text before it is truncated.</span>
         <span class="s0">*</span>
         <span class="s0">* Default: `500`</span>
         <span class="s0">*/</span>
        <span class="s1">readonly maximumHoverLength?: number;</span>
    <span class="s1">}</span>
    <span class="s1">type OrganizeImportsTypeOrder = </span><span class="s3">&quot;last&quot; </span><span class="s1">| </span><span class="s3">&quot;inline&quot; </span><span class="s1">| </span><span class="s3">&quot;first&quot;</span><span class="s1">;</span>
    <span class="s0">/** Represents a bigint literal value without requiring bigint support */</span>
    <span class="s2">interface </span><span class="s1">PseudoBigInt {</span>
        <span class="s1">negative: boolean;</span>
        <span class="s1">base10Value: string;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">FileWatcherEventKind {</span>
        <span class="s1">Created = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">Changed = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">Deleted = </span><span class="s5">2</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s1">type FileWatcherCallback = (fileName: string, eventKind: FileWatcherEventKind, modifiedTime?: Date) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">type DirectoryWatcherCallback = (fileName: string) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">type BufferEncoding = </span><span class="s3">&quot;ascii&quot; </span><span class="s1">| </span><span class="s3">&quot;utf8&quot; </span><span class="s1">| </span><span class="s3">&quot;utf-8&quot; </span><span class="s1">| </span><span class="s3">&quot;utf16le&quot; </span><span class="s1">| </span><span class="s3">&quot;ucs2&quot; </span><span class="s1">| </span><span class="s3">&quot;ucs-2&quot; </span><span class="s1">| </span><span class="s3">&quot;base64&quot; </span><span class="s1">| </span><span class="s3">&quot;latin1&quot; </span><span class="s1">| </span><span class="s3">&quot;binary&quot; </span><span class="s1">| </span><span class="s3">&quot;hex&quot;</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s1">System {</span>
        <span class="s1">args: string[];</span>
        <span class="s1">newLine: string;</span>
        <span class="s1">useCaseSensitiveFileNames: boolean;</span>
        <span class="s1">write(s: string): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">writeOutputIsTTY?(): boolean;</span>
        <span class="s1">getWidthOfTerminal?(): number;</span>
        <span class="s1">readFile(path: string, encoding?: string): string | undefined;</span>
        <span class="s1">getFileSize?(path: string): number;</span>
        <span class="s1">writeFile(path: string, data: string, writeByteOrderMark?: boolean): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s4">@pollingInterval </span><span class="s0">- this parameter is used in polling-based watchers and ignored in watchers that</span>
         <span class="s0">* use native OS file watching</span>
         <span class="s0">*/</span>
        <span class="s1">watchFile?(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: WatchOptions): FileWatcher;</span>
        <span class="s1">watchDirectory?(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: WatchOptions): FileWatcher;</span>
        <span class="s1">resolvePath(path: string): string;</span>
        <span class="s1">fileExists(path: string): boolean;</span>
        <span class="s1">directoryExists(path: string): boolean;</span>
        <span class="s1">createDirectory(path: string): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">getExecutingFilePath(): string;</span>
        <span class="s1">getCurrentDirectory(): string;</span>
        <span class="s1">getDirectories(path: string): string[];</span>
        <span class="s1">readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];</span>
        <span class="s1">getModifiedTime?(path: string): Date | undefined;</span>
        <span class="s1">setModifiedTime?(path: string, time: Date): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">deleteFile?(path: string): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A good implementation is node.js' `crypto.createHash`. (https://nodejs.org/api/crypto.html#crypto_crypto_createhash_algorithm)</span>
         <span class="s0">*/</span>
        <span class="s1">createHash?(data: string): string;</span>
        <span class="s0">/** This must be cryptographically secure. Only implement this method using `crypto.createHash(&quot;sha256&quot;)`. */</span>
        <span class="s1">createSHA256Hash?(data: string): string;</span>
        <span class="s1">getMemoryUsage?(): number;</span>
        <span class="s1">exit(exitCode?: number): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">realpath?(path: string): string;</span>
        <span class="s1">setTimeout?(callback: (...args: any[]) =&gt; </span><span class="s2">void</span><span class="s1">, ms: number, ...args: any[]): any;</span>
        <span class="s1">clearTimeout?(timeoutId: any): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">clearScreen?(): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">base64decode?(input: string): string;</span>
        <span class="s1">base64encode?(input: string): string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">FileWatcher {</span>
        <span class="s1">close(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">sys: System;</span>
    <span class="s2">function </span><span class="s1">tokenToString(t: SyntaxKind): string | undefined;</span>
    <span class="s2">function </span><span class="s1">getPositionOfLineAndCharacter(sourceFile: SourceFileLike, line: number, character: number): number;</span>
    <span class="s2">function </span><span class="s1">getLineAndCharacterOfPosition(sourceFile: SourceFileLike, position: number): LineAndCharacter;</span>
    <span class="s2">function </span><span class="s1">isWhiteSpaceLike(ch: number): boolean;</span>
    <span class="s0">/** Does not include line breaks. For that, see isWhiteSpaceLike. */</span>
    <span class="s2">function </span><span class="s1">isWhiteSpaceSingleLine(ch: number): boolean;</span>
    <span class="s2">function </span><span class="s1">isLineBreak(ch: number): boolean;</span>
    <span class="s2">function </span><span class="s1">couldStartTrivia(text: string, pos: number): boolean;</span>
    <span class="s2">function </span><span class="s1">forEachLeadingCommentRange&lt;U&gt;(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) =&gt; U): U | undefined;</span>
    <span class="s2">function </span><span class="s1">forEachLeadingCommentRange&lt;T, U&gt;(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) =&gt; U, state: T): U | undefined;</span>
    <span class="s2">function </span><span class="s1">forEachTrailingCommentRange&lt;U&gt;(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) =&gt; U): U | undefined;</span>
    <span class="s2">function </span><span class="s1">forEachTrailingCommentRange&lt;T, U&gt;(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) =&gt; U, state: T): U | undefined;</span>
    <span class="s2">function </span><span class="s1">reduceEachLeadingCommentRange&lt;T, U&gt;(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) =&gt; U, state: T, initial: U): U | undefined;</span>
    <span class="s2">function </span><span class="s1">reduceEachTrailingCommentRange&lt;T, U&gt;(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) =&gt; U, state: T, initial: U): U | undefined;</span>
    <span class="s2">function </span><span class="s1">getLeadingCommentRanges(text: string, pos: number): CommentRange[] | undefined;</span>
    <span class="s2">function </span><span class="s1">getTrailingCommentRanges(text: string, pos: number): CommentRange[] | undefined;</span>
    <span class="s0">/** Optionally, get the shebang */</span>
    <span class="s2">function </span><span class="s1">getShebang(text: string): string | undefined;</span>
    <span class="s2">function </span><span class="s1">isIdentifierStart(ch: number, languageVersion: ScriptTarget | undefined): boolean;</span>
    <span class="s2">function </span><span class="s1">isIdentifierPart(ch: number, languageVersion: ScriptTarget | undefined, identifierVariant?: LanguageVariant): boolean;</span>
    <span class="s2">function </span><span class="s1">createScanner(languageVersion: ScriptTarget, skipTrivia: boolean, languageVariant?: LanguageVariant, textInitial?: string, onError?: ErrorCallback, start?: number, length?: number): Scanner;</span>
    <span class="s1">type ErrorCallback = (message: DiagnosticMessage, length: number, arg0?: any) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s1">Scanner {</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">use {</span><span class="s4">@link </span><span class="s0">getTokenFullStart} */</span>
        <span class="s1">getStartPos(): number;</span>
        <span class="s1">getToken(): SyntaxKind;</span>
        <span class="s1">getTokenFullStart(): number;</span>
        <span class="s1">getTokenStart(): number;</span>
        <span class="s1">getTokenEnd(): number;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">use {</span><span class="s4">@link </span><span class="s0">getTokenEnd} */</span>
        <span class="s1">getTextPos(): number;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">use {</span><span class="s4">@link </span><span class="s0">getTokenStart} */</span>
        <span class="s1">getTokenPos(): number;</span>
        <span class="s1">getTokenText(): string;</span>
        <span class="s1">getTokenValue(): string;</span>
        <span class="s1">hasUnicodeEscape(): boolean;</span>
        <span class="s1">hasExtendedUnicodeEscape(): boolean;</span>
        <span class="s1">hasPrecedingLineBreak(): boolean;</span>
        <span class="s1">isIdentifier(): boolean;</span>
        <span class="s1">isReservedWord(): boolean;</span>
        <span class="s1">isUnterminated(): boolean;</span>
        <span class="s1">reScanGreaterToken(): SyntaxKind;</span>
        <span class="s1">reScanSlashToken(): SyntaxKind;</span>
        <span class="s1">reScanAsteriskEqualsToken(): SyntaxKind;</span>
        <span class="s1">reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">use {</span><span class="s4">@link </span><span class="s0">reScanTemplateToken}(false) */</span>
        <span class="s1">reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind;</span>
        <span class="s1">scanJsxIdentifier(): SyntaxKind;</span>
        <span class="s1">scanJsxAttributeValue(): SyntaxKind;</span>
        <span class="s1">reScanJsxAttributeValue(): SyntaxKind;</span>
        <span class="s1">reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind;</span>
        <span class="s1">reScanLessThanToken(): SyntaxKind;</span>
        <span class="s1">reScanHashToken(): SyntaxKind;</span>
        <span class="s1">reScanQuestionToken(): SyntaxKind;</span>
        <span class="s1">reScanInvalidIdentifier(): SyntaxKind;</span>
        <span class="s1">scanJsxToken(): JsxTokenSyntaxKind;</span>
        <span class="s1">scanJsDocToken(): JSDocSyntaxKind;</span>
        <span class="s1">scan(): SyntaxKind;</span>
        <span class="s1">getText(): string;</span>
        <span class="s1">setText(text: string | undefined, start?: number, length?: number): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">setOnError(onError: ErrorCallback | undefined): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">setScriptTarget(scriptTarget: ScriptTarget): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">setLanguageVariant(variant: LanguageVariant): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">setScriptKind(scriptKind: ScriptKind): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">setJSDocParsingMode(kind: JSDocParsingMode): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">use {</span><span class="s4">@link </span><span class="s0">resetTokenState} */</span>
        <span class="s1">setTextPos(textPos: number): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">resetTokenState(pos: number): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">lookAhead&lt;T&gt;(callback: () =&gt; T): T;</span>
        <span class="s1">scanRange&lt;T&gt;(start: number, length: number, callback: () =&gt; T): T;</span>
        <span class="s1">tryScan&lt;T&gt;(callback: () =&gt; T): T;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">isExternalModuleNameRelative(moduleName: string): boolean;</span>
    <span class="s2">function </span><span class="s1">sortAndDeduplicateDiagnostics&lt;T </span><span class="s2">extends </span><span class="s1">Diagnostic&gt;(diagnostics: readonly T[]): SortedReadonlyArray&lt;T&gt;;</span>
    <span class="s2">function </span><span class="s1">getDefaultLibFileName(options: CompilerOptions): string;</span>
    <span class="s2">function </span><span class="s1">textSpanEnd(span: TextSpan): number;</span>
    <span class="s2">function </span><span class="s1">textSpanIsEmpty(span: TextSpan): boolean;</span>
    <span class="s2">function </span><span class="s1">textSpanContainsPosition(span: TextSpan, position: number): boolean;</span>
    <span class="s2">function </span><span class="s1">textSpanContainsTextSpan(span: TextSpan, other: TextSpan): boolean;</span>
    <span class="s2">function </span><span class="s1">textSpanOverlapsWith(span: TextSpan, other: TextSpan): boolean;</span>
    <span class="s2">function </span><span class="s1">textSpanOverlap(span1: TextSpan, span2: TextSpan): TextSpan | undefined;</span>
    <span class="s2">function </span><span class="s1">textSpanIntersectsWithTextSpan(span: TextSpan, other: TextSpan): boolean;</span>
    <span class="s2">function </span><span class="s1">textSpanIntersectsWith(span: TextSpan, start: number, length: number): boolean;</span>
    <span class="s2">function </span><span class="s1">decodedTextSpanIntersectsWith(start1: number, length1: number, start2: number, length2: number): boolean;</span>
    <span class="s2">function </span><span class="s1">textSpanIntersectsWithPosition(span: TextSpan, position: number): boolean;</span>
    <span class="s2">function </span><span class="s1">textSpanIntersection(span1: TextSpan, span2: TextSpan): TextSpan | undefined;</span>
    <span class="s2">function </span><span class="s1">createTextSpan(start: number, length: number): TextSpan;</span>
    <span class="s2">function </span><span class="s1">createTextSpanFromBounds(start: number, end: number): TextSpan;</span>
    <span class="s2">function </span><span class="s1">textChangeRangeNewSpan(range: TextChangeRange): TextSpan;</span>
    <span class="s2">function </span><span class="s1">textChangeRangeIsUnchanged(range: TextChangeRange): boolean;</span>
    <span class="s2">function </span><span class="s1">createTextChangeRange(span: TextSpan, newLength: number): TextChangeRange;</span>
    <span class="s0">/**</span>
     <span class="s0">* Called to merge all the changes that occurred across several versions of a script snapshot</span>
     <span class="s0">* into a single change.  i.e. if a user keeps making successive edits to a script we will</span>
     <span class="s0">* have a text change from V1 to V2, V2 to V3, ..., Vn.</span>
     <span class="s0">*</span>
     <span class="s0">* This function will then merge those changes into a single change range valid between V1 and</span>
     <span class="s0">* Vn.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">collapseTextChangeRangesAcrossMultipleVersions(changes: readonly TextChangeRange[]): TextChangeRange;</span>
    <span class="s2">function </span><span class="s1">getTypeParameterOwner(d: Declaration): Declaration | undefined;</span>
    <span class="s2">function </span><span class="s1">isParameterPropertyDeclaration(node: Node, parent: Node): node is ParameterPropertyDeclaration;</span>
    <span class="s2">function </span><span class="s1">isEmptyBindingPattern(node: BindingName): node is BindingPattern;</span>
    <span class="s2">function </span><span class="s1">isEmptyBindingElement(node: BindingElement | ArrayBindingElement): boolean;</span>
    <span class="s2">function </span><span class="s1">walkUpBindingElementsAndPatterns(binding: BindingElement): VariableDeclaration | ParameterDeclaration;</span>
    <span class="s2">function </span><span class="s1">getCombinedModifierFlags(node: Declaration): ModifierFlags;</span>
    <span class="s2">function </span><span class="s1">getCombinedNodeFlags(node: Node): NodeFlags;</span>
    <span class="s0">/**</span>
     <span class="s0">* Checks to see if the locale is in the appropriate format,</span>
     <span class="s0">* and if it is, attempts to set the appropriate language.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">validateLocaleAndSetLanguage(locale: string, sys: {</span>
        <span class="s1">getExecutingFilePath(): string;</span>
        <span class="s1">resolvePath(path: string): string;</span>
        <span class="s1">fileExists(fileName: string): boolean;</span>
        <span class="s1">readFile(fileName: string): string | undefined;</span>
    <span class="s1">}, errors?: Diagnostic[]): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">getOriginalNode(node: Node): Node;</span>
    <span class="s2">function </span><span class="s1">getOriginalNode&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt;(node: Node, nodeTest: (node: Node) =&gt; node is T): T;</span>
    <span class="s2">function </span><span class="s1">getOriginalNode(node: Node | undefined): Node | undefined;</span>
    <span class="s2">function </span><span class="s1">getOriginalNode&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt;(node: Node | undefined, nodeTest: (node: Node) =&gt; node is T): T | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Iterates through the parent chain of a node and performs the callback on each parent until the callback</span>
     <span class="s0">* returns a truthy value, then returns that value.</span>
     <span class="s0">* If no such value is found, it applies the callback until the parent pointer is undefined or the callback returns &quot;quit&quot;</span>
     <span class="s0">* At that point findAncestor returns undefined.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">findAncestor&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt;(node: Node | undefined, callback: (element: Node) =&gt; element is T): T | undefined;</span>
    <span class="s2">function </span><span class="s1">findAncestor(node: Node | undefined, callback: (element: Node) =&gt; boolean | </span><span class="s3">&quot;quit&quot;</span><span class="s1">): Node | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets a value indicating whether a node originated in the parse tree.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">node The node to test.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">isParseTreeNode(node: Node): boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets the original parse tree node for a node.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">node The original node.</span>
     <span class="s0">* </span><span class="s4">@returns </span><span class="s0">The original parse tree node if found; otherwise, undefined.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">getParseTreeNode(node: Node | undefined): Node | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets the original parse tree node for a node.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">node The original node.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">nodeTest A callback used to ensure the correct type of parse tree node is returned.</span>
     <span class="s0">* </span><span class="s4">@returns </span><span class="s0">The original parse tree node if found; otherwise, undefined.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">getParseTreeNode&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt;(node: T | undefined, nodeTest?: (node: Node) =&gt; node is T): T | undefined;</span>
    <span class="s0">/** Add an extra underscore to identifiers that start with two underscores to avoid issues with magic names like '__proto__' */</span>
    <span class="s2">function </span><span class="s1">escapeLeadingUnderscores(identifier: string): __String;</span>
    <span class="s0">/**</span>
     <span class="s0">* Remove extra underscore from escaped identifier text content.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">identifier The escaped identifier text.</span>
     <span class="s0">* </span><span class="s4">@returns </span><span class="s0">The unescaped identifier text.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">unescapeLeadingUnderscores(identifier: __String): string;</span>
    <span class="s2">function </span><span class="s1">idText(identifierOrPrivateName: Identifier | PrivateIdentifier): string;</span>
    <span class="s0">/**</span>
     <span class="s0">* If the text of an Identifier matches a keyword (including contextual and TypeScript-specific keywords), returns the</span>
     <span class="s0">* SyntaxKind for the matching keyword.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">identifierToKeywordKind(node: Identifier): KeywordSyntaxKind | undefined;</span>
    <span class="s2">function </span><span class="s1">symbolName(symbol: Symbol): string;</span>
    <span class="s2">function </span><span class="s1">getNameOfJSDocTypedef(declaration: JSDocTypedefTag): Identifier | PrivateIdentifier | undefined;</span>
    <span class="s2">function </span><span class="s1">getNameOfDeclaration(declaration: Declaration | Expression | undefined): DeclarationName | undefined;</span>
    <span class="s2">function </span><span class="s1">getDecorators(node: HasDecorators): readonly Decorator[] | undefined;</span>
    <span class="s2">function </span><span class="s1">getModifiers(node: HasModifiers): readonly Modifier[] | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets the JSDoc parameter tags for the node if present.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@remarks </span><span class="s0">Returns any JSDoc param tag whose name matches the provided</span>
     <span class="s0">* parameter, whether a param tag on a containing function</span>
     <span class="s0">* expression, or a param tag on a variable declaration whose</span>
     <span class="s0">* initializer is the containing function. The tags closest to the</span>
     <span class="s0">* node are returned first, so in the previous example, the param</span>
     <span class="s0">* tag on the containing function expression would be first.</span>
     <span class="s0">*</span>
     <span class="s0">* For binding patterns, parameter tags are matched by position.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">getJSDocParameterTags(param: ParameterDeclaration): readonly JSDocParameterTag[];</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets the JSDoc type parameter tags for the node if present.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@remarks </span><span class="s0">Returns any JSDoc template tag whose names match the provided</span>
     <span class="s0">* parameter, whether a template tag on a containing function</span>
     <span class="s0">* expression, or a template tag on a variable declaration whose</span>
     <span class="s0">* initializer is the containing function. The tags closest to the</span>
     <span class="s0">* node are returned first, so in the previous example, the template</span>
     <span class="s0">* tag on the containing function expression would be first.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">getJSDocTypeParameterTags(param: TypeParameterDeclaration): readonly JSDocTemplateTag[];</span>
    <span class="s0">/**</span>
     <span class="s0">* Return true if the node has JSDoc parameter tags.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@remarks </span><span class="s0">Includes parameter tags that are not directly on the node,</span>
     <span class="s0">* for example on a variable declaration whose initializer is a function expression.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">hasJSDocParameterTags(node: FunctionLikeDeclaration | SignatureDeclaration): boolean;</span>
    <span class="s0">/** Gets the JSDoc augments tag for the node if present */</span>
    <span class="s2">function </span><span class="s1">getJSDocAugmentsTag(node: Node): JSDocAugmentsTag | undefined;</span>
    <span class="s0">/** Gets the JSDoc implements tags for the node if present */</span>
    <span class="s2">function </span><span class="s1">getJSDocImplementsTags(node: Node): readonly JSDocImplementsTag[];</span>
    <span class="s0">/** Gets the JSDoc class tag for the node if present */</span>
    <span class="s2">function </span><span class="s1">getJSDocClassTag(node: Node): JSDocClassTag | undefined;</span>
    <span class="s0">/** Gets the JSDoc public tag for the node if present */</span>
    <span class="s2">function </span><span class="s1">getJSDocPublicTag(node: Node): JSDocPublicTag | undefined;</span>
    <span class="s0">/** Gets the JSDoc private tag for the node if present */</span>
    <span class="s2">function </span><span class="s1">getJSDocPrivateTag(node: Node): JSDocPrivateTag | undefined;</span>
    <span class="s0">/** Gets the JSDoc protected tag for the node if present */</span>
    <span class="s2">function </span><span class="s1">getJSDocProtectedTag(node: Node): JSDocProtectedTag | undefined;</span>
    <span class="s0">/** Gets the JSDoc protected tag for the node if present */</span>
    <span class="s2">function </span><span class="s1">getJSDocReadonlyTag(node: Node): JSDocReadonlyTag | undefined;</span>
    <span class="s2">function </span><span class="s1">getJSDocOverrideTagNoCache(node: Node): JSDocOverrideTag | undefined;</span>
    <span class="s0">/** Gets the JSDoc deprecated tag for the node if present */</span>
    <span class="s2">function </span><span class="s1">getJSDocDeprecatedTag(node: Node): JSDocDeprecatedTag | undefined;</span>
    <span class="s0">/** Gets the JSDoc enum tag for the node if present */</span>
    <span class="s2">function </span><span class="s1">getJSDocEnumTag(node: Node): JSDocEnumTag | undefined;</span>
    <span class="s0">/** Gets the JSDoc this tag for the node if present */</span>
    <span class="s2">function </span><span class="s1">getJSDocThisTag(node: Node): JSDocThisTag | undefined;</span>
    <span class="s0">/** Gets the JSDoc return tag for the node if present */</span>
    <span class="s2">function </span><span class="s1">getJSDocReturnTag(node: Node): JSDocReturnTag | undefined;</span>
    <span class="s0">/** Gets the JSDoc template tag for the node if present */</span>
    <span class="s2">function </span><span class="s1">getJSDocTemplateTag(node: Node): JSDocTemplateTag | undefined;</span>
    <span class="s2">function </span><span class="s1">getJSDocSatisfiesTag(node: Node): JSDocSatisfiesTag | undefined;</span>
    <span class="s0">/** Gets the JSDoc type tag for the node if present and valid */</span>
    <span class="s2">function </span><span class="s1">getJSDocTypeTag(node: Node): JSDocTypeTag | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets the type node for the node if provided via JSDoc.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@remarks </span><span class="s0">The search includes any JSDoc param tag that relates</span>
     <span class="s0">* to the provided parameter, for example a type tag on the</span>
     <span class="s0">* parameter itself, or a param tag on a containing function</span>
     <span class="s0">* expression, or a param tag on a variable declaration whose</span>
     <span class="s0">* initializer is the containing function. The tags closest to the</span>
     <span class="s0">* node are examined first, so in the previous example, the type</span>
     <span class="s0">* tag directly on the node would be returned.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">getJSDocType(node: Node): TypeNode | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets the return type node for the node if provided via JSDoc return tag or type tag.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@remarks </span><span class="s0">`getJSDocReturnTag` just gets the whole JSDoc tag. This function</span>
     <span class="s0">* gets the type from inside the braces, after the fat arrow, etc.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">getJSDocReturnType(node: Node): TypeNode | undefined;</span>
    <span class="s0">/** Get all JSDoc tags related to a node, including those on parent nodes. */</span>
    <span class="s2">function </span><span class="s1">getJSDocTags(node: Node): readonly JSDocTag[];</span>
    <span class="s0">/** Gets all JSDoc tags that match a specified predicate */</span>
    <span class="s2">function </span><span class="s1">getAllJSDocTags&lt;T </span><span class="s2">extends </span><span class="s1">JSDocTag&gt;(node: Node, predicate: (tag: JSDocTag) =&gt; tag is T): readonly T[];</span>
    <span class="s0">/** Gets all JSDoc tags of a specified kind */</span>
    <span class="s2">function </span><span class="s1">getAllJSDocTagsOfKind(node: Node, kind: SyntaxKind): readonly JSDocTag[];</span>
    <span class="s0">/** Gets the text of a jsdoc comment, flattening links to their text. */</span>
    <span class="s2">function </span><span class="s1">getTextOfJSDocComment(comment?: string | NodeArray&lt;JSDocComment&gt;): string | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets the effective type parameters. If the node was parsed in a</span>
     <span class="s0">* JavaScript file, gets the type parameters from the `@template` tag from JSDoc.</span>
     <span class="s0">*</span>
     <span class="s0">* This does *not* return type parameters from a jsdoc reference to a generic type, eg</span>
     <span class="s0">*</span>
     <span class="s0">* type Id = &lt;T&gt;(x: T) =&gt; T</span>
     <span class="s0">* /** @type {Id} /</span>
     <span class="s0">* function id(x) { return x }</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">getEffectiveTypeParameterDeclarations(node: DeclarationWithTypeParameters): readonly TypeParameterDeclaration[];</span>
    <span class="s2">function </span><span class="s1">getEffectiveConstraintOfTypeParameter(node: TypeParameterDeclaration): TypeNode | undefined;</span>
    <span class="s2">function </span><span class="s1">isMemberName(node: Node): node is MemberName;</span>
    <span class="s2">function </span><span class="s1">isPropertyAccessChain(node: Node): node is PropertyAccessChain;</span>
    <span class="s2">function </span><span class="s1">isElementAccessChain(node: Node): node is ElementAccessChain;</span>
    <span class="s2">function </span><span class="s1">isCallChain(node: Node): node is CallChain;</span>
    <span class="s2">function </span><span class="s1">isOptionalChain(node: Node): node is PropertyAccessChain | ElementAccessChain | CallChain | NonNullChain;</span>
    <span class="s2">function </span><span class="s1">isNullishCoalesce(node: Node): boolean;</span>
    <span class="s2">function </span><span class="s1">isConstTypeReference(node: Node): boolean;</span>
    <span class="s2">function </span><span class="s1">skipPartiallyEmittedExpressions(node: Expression): Expression;</span>
    <span class="s2">function </span><span class="s1">skipPartiallyEmittedExpressions(node: Node): Node;</span>
    <span class="s2">function </span><span class="s1">isNonNullChain(node: Node): node is NonNullChain;</span>
    <span class="s2">function </span><span class="s1">isBreakOrContinueStatement(node: Node): node is BreakOrContinueStatement;</span>
    <span class="s2">function </span><span class="s1">isNamedExportBindings(node: Node): node is NamedExportBindings;</span>
    <span class="s2">function </span><span class="s1">isJSDocPropertyLikeTag(node: Node): node is JSDocPropertyLikeTag;</span>
    <span class="s0">/**</span>
     <span class="s0">* True if kind is of some token syntax kind.</span>
     <span class="s0">* For example, this is true for an IfKeyword but not for an IfStatement.</span>
     <span class="s0">* Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">isTokenKind(kind: SyntaxKind): boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* True if node is of some token syntax kind.</span>
     <span class="s0">* For example, this is true for an IfKeyword but not for an IfStatement.</span>
     <span class="s0">* Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">isToken(n: Node): boolean;</span>
    <span class="s2">function </span><span class="s1">isLiteralExpression(node: Node): node is LiteralExpression;</span>
    <span class="s2">function </span><span class="s1">isTemplateLiteralToken(node: Node): node is TemplateLiteralToken;</span>
    <span class="s2">function </span><span class="s1">isTemplateMiddleOrTemplateTail(node: Node): node is TemplateMiddle | TemplateTail;</span>
    <span class="s2">function </span><span class="s1">isImportOrExportSpecifier(node: Node): node is ImportSpecifier | ExportSpecifier;</span>
    <span class="s2">function </span><span class="s1">isTypeOnlyImportDeclaration(node: Node): node is TypeOnlyImportDeclaration;</span>
    <span class="s2">function </span><span class="s1">isTypeOnlyExportDeclaration(node: Node): node is TypeOnlyExportDeclaration;</span>
    <span class="s2">function </span><span class="s1">isTypeOnlyImportOrExportDeclaration(node: Node): node is TypeOnlyAliasDeclaration;</span>
    <span class="s2">function </span><span class="s1">isPartOfTypeOnlyImportOrExportDeclaration(node: Node): boolean;</span>
    <span class="s2">function </span><span class="s1">isStringTextContainingNode(node: Node): node is StringLiteral | TemplateLiteralToken;</span>
    <span class="s2">function </span><span class="s1">isImportAttributeName(node: Node): node is ImportAttributeName;</span>
    <span class="s2">function </span><span class="s1">isModifier(node: Node): node is Modifier;</span>
    <span class="s2">function </span><span class="s1">isEntityName(node: Node): node is EntityName;</span>
    <span class="s2">function </span><span class="s1">isPropertyName(node: Node): node is PropertyName;</span>
    <span class="s2">function </span><span class="s1">isBindingName(node: Node): node is BindingName;</span>
    <span class="s2">function </span><span class="s1">isFunctionLike(node: Node | undefined): node is SignatureDeclaration;</span>
    <span class="s2">function </span><span class="s1">isClassElement(node: Node): node is ClassElement;</span>
    <span class="s2">function </span><span class="s1">isClassLike(node: Node): node is ClassLikeDeclaration;</span>
    <span class="s2">function </span><span class="s1">isAccessor(node: Node): node is AccessorDeclaration;</span>
    <span class="s2">function </span><span class="s1">isAutoAccessorPropertyDeclaration(node: Node): node is AutoAccessorPropertyDeclaration;</span>
    <span class="s2">function </span><span class="s1">isModifierLike(node: Node): node is ModifierLike;</span>
    <span class="s2">function </span><span class="s1">isTypeElement(node: Node): node is TypeElement;</span>
    <span class="s2">function </span><span class="s1">isClassOrTypeElement(node: Node): node is ClassElement | TypeElement;</span>
    <span class="s2">function </span><span class="s1">isObjectLiteralElementLike(node: Node): node is ObjectLiteralElementLike;</span>
    <span class="s0">/**</span>
     <span class="s0">* Node test that determines whether a node is a valid type node.</span>
     <span class="s0">* This differs from the `isPartOfTypeNode` function which determines whether a node is *part*</span>
     <span class="s0">* of a TypeNode.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">isTypeNode(node: Node): node is TypeNode;</span>
    <span class="s2">function </span><span class="s1">isFunctionOrConstructorTypeNode(node: Node): node is FunctionTypeNode | ConstructorTypeNode;</span>
    <span class="s2">function </span><span class="s1">isArrayBindingElement(node: Node): node is ArrayBindingElement;</span>
    <span class="s2">function </span><span class="s1">isPropertyAccessOrQualifiedName(node: Node): node is PropertyAccessExpression | QualifiedName;</span>
    <span class="s2">function </span><span class="s1">isCallLikeExpression(node: Node): node is CallLikeExpression;</span>
    <span class="s2">function </span><span class="s1">isCallOrNewExpression(node: Node): node is CallExpression | NewExpression;</span>
    <span class="s2">function </span><span class="s1">isTemplateLiteral(node: Node): node is TemplateLiteral;</span>
    <span class="s2">function </span><span class="s1">isLeftHandSideExpression(node: Node): node is LeftHandSideExpression;</span>
    <span class="s2">function </span><span class="s1">isLiteralTypeLiteral(node: Node): node is NullLiteral | BooleanLiteral | LiteralExpression | PrefixUnaryExpression;</span>
    <span class="s0">/**</span>
     <span class="s0">* Determines whether a node is an expression based only on its kind.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">isExpression(node: Node): node is Expression;</span>
    <span class="s2">function </span><span class="s1">isAssertionExpression(node: Node): node is AssertionExpression;</span>
    <span class="s2">function </span><span class="s1">isIterationStatement(node: Node, lookInLabeledStatements: </span><span class="s2">false</span><span class="s1">): node is IterationStatement;</span>
    <span class="s2">function </span><span class="s1">isIterationStatement(node: Node, lookInLabeledStatements: boolean): node is IterationStatement | LabeledStatement;</span>
    <span class="s2">function </span><span class="s1">isConciseBody(node: Node): node is ConciseBody;</span>
    <span class="s2">function </span><span class="s1">isForInitializer(node: Node): node is ForInitializer;</span>
    <span class="s2">function </span><span class="s1">isModuleBody(node: Node): node is ModuleBody;</span>
    <span class="s2">function </span><span class="s1">isNamedImportBindings(node: Node): node is NamedImportBindings;</span>
    <span class="s2">function </span><span class="s1">isDeclarationStatement(node: Node): node is DeclarationStatement;</span>
    <span class="s2">function </span><span class="s1">isStatement(node: Node): node is Statement;</span>
    <span class="s2">function </span><span class="s1">isModuleReference(node: Node): node is ModuleReference;</span>
    <span class="s2">function </span><span class="s1">isJsxTagNameExpression(node: Node): node is JsxTagNameExpression;</span>
    <span class="s2">function </span><span class="s1">isJsxChild(node: Node): node is JsxChild;</span>
    <span class="s2">function </span><span class="s1">isJsxAttributeLike(node: Node): node is JsxAttributeLike;</span>
    <span class="s2">function </span><span class="s1">isStringLiteralOrJsxExpression(node: Node): node is StringLiteral | JsxExpression;</span>
    <span class="s2">function </span><span class="s1">isJsxOpeningLikeElement(node: Node): node is JsxOpeningLikeElement;</span>
    <span class="s2">function </span><span class="s1">isJsxCallLike(node: Node): node is JsxCallLike;</span>
    <span class="s2">function </span><span class="s1">isCaseOrDefaultClause(node: Node): node is CaseOrDefaultClause;</span>
    <span class="s0">/** True if node is of a kind that may contain comment text. */</span>
    <span class="s2">function </span><span class="s1">isJSDocCommentContainingNode(node: Node): boolean;</span>
    <span class="s2">function </span><span class="s1">isSetAccessor(node: Node): node is SetAccessorDeclaration;</span>
    <span class="s2">function </span><span class="s1">isGetAccessor(node: Node): node is GetAccessorDeclaration;</span>
    <span class="s0">/** True if has initializer node attached to it. */</span>
    <span class="s2">function </span><span class="s1">hasOnlyExpressionInitializer(node: Node): node is HasExpressionInitializer;</span>
    <span class="s2">function </span><span class="s1">isObjectLiteralElement(node: Node): node is ObjectLiteralElement;</span>
    <span class="s2">function </span><span class="s1">isStringLiteralLike(node: Node | FileReference): node is StringLiteralLike;</span>
    <span class="s2">function </span><span class="s1">isJSDocLinkLike(node: Node): node is JSDocLink | JSDocLinkCode | JSDocLinkPlain;</span>
    <span class="s2">function </span><span class="s1">hasRestParameter(s: SignatureDeclaration | JSDocSignature): boolean;</span>
    <span class="s2">function </span><span class="s1">isRestParameter(node: ParameterDeclaration | JSDocParameterTag): boolean;</span>
    <span class="s2">function </span><span class="s1">isInternalDeclaration(node: Node, sourceFile?: SourceFile): boolean;</span>
    <span class="s2">const </span><span class="s1">unchangedTextChangeRange: TextChangeRange;</span>
    <span class="s1">type ParameterPropertyDeclaration = ParameterDeclaration &amp; {</span>
        <span class="s1">parent: ConstructorDeclaration;</span>
        <span class="s1">name: Identifier;</span>
    <span class="s1">};</span>
    <span class="s2">function </span><span class="s1">isPartOfTypeNode(node: Node): boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* This function checks multiple locations for JSDoc comments that apply to a host node.</span>
     <span class="s0">* At each location, the whole comment may apply to the node, or only a specific tag in</span>
     <span class="s0">* the comment. In the first case, location adds the entire {</span><span class="s4">@link </span><span class="s0">JSDoc} object. In the</span>
     <span class="s0">* second case, it adds the applicable {</span><span class="s4">@link </span><span class="s0">JSDocTag}.</span>
     <span class="s0">*</span>
     <span class="s0">* For example, a JSDoc comment before a parameter adds the entire {</span><span class="s4">@link </span><span class="s0">JSDoc}. But a</span>
     <span class="s0">* `@param` tag on the parent function only adds the {</span><span class="s4">@link </span><span class="s0">JSDocTag} for the `@param`.</span>
     <span class="s0">*</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* /** JSDoc will be returned for `a` *\/</span>
     <span class="s0">* const a = 0</span>
     <span class="s0">* /**</span>
     <span class="s0">*  * Entire JSDoc will be returned for `b`</span>
     <span class="s0">*  * @param c JSDocTag will be returned for `c`</span>
     <span class="s0">*  *\/</span>
     <span class="s0">* function b(/** JSDoc will be returned for `c` *\/ c) {}</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">getJSDocCommentsAndTags(hostNode: Node): readonly (JSDoc | JSDocTag)[];</span>
    <span class="s0">/**</span>
     <span class="s0">* Create an external source map source file reference</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">createSourceMapSource(fileName: string, text: string, skipTrivia?: (pos: number) =&gt; number): SourceMapSource;</span>
    <span class="s2">function </span><span class="s1">setOriginalNode&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt;(node: T, original: Node | undefined): T;</span>
    <span class="s2">const </span><span class="s1">factory: NodeFactory;</span>
    <span class="s0">/**</span>
     <span class="s0">* Clears any `EmitNode` entries from parse-tree nodes.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">sourceFile A source file.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">disposeEmitNodes(sourceFile: SourceFile | undefined): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Sets flags that control emit behavior of a node.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">setEmitFlags&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt;(node: T, emitFlags: EmitFlags): T;</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets a custom text range to use when emitting source maps.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">getSourceMapRange(node: Node): SourceMapRange;</span>
    <span class="s0">/**</span>
     <span class="s0">* Sets a custom text range to use when emitting source maps.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">setSourceMapRange&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt;(node: T, range: SourceMapRange | undefined): T;</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets the TextRange to use for source maps for a token of a node.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">getTokenSourceMapRange(node: Node, token: SyntaxKind): SourceMapRange | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Sets the TextRange to use for source maps for a token of a node.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">setTokenSourceMapRange&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt;(node: T, token: SyntaxKind, range: SourceMapRange | undefined): T;</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets a custom text range to use when emitting comments.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">getCommentRange(node: Node): TextRange;</span>
    <span class="s0">/**</span>
     <span class="s0">* Sets a custom text range to use when emitting comments.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">setCommentRange&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt;(node: T, range: TextRange): T;</span>
    <span class="s2">function </span><span class="s1">getSyntheticLeadingComments(node: Node): SynthesizedComment[] | undefined;</span>
    <span class="s2">function </span><span class="s1">setSyntheticLeadingComments&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt;(node: T, comments: SynthesizedComment[] | undefined): T;</span>
    <span class="s2">function </span><span class="s1">addSyntheticLeadingComment&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt;(node: T, kind: SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia, text: string, hasTrailingNewLine?: boolean): T;</span>
    <span class="s2">function </span><span class="s1">getSyntheticTrailingComments(node: Node): SynthesizedComment[] | undefined;</span>
    <span class="s2">function </span><span class="s1">setSyntheticTrailingComments&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt;(node: T, comments: SynthesizedComment[] | undefined): T;</span>
    <span class="s2">function </span><span class="s1">addSyntheticTrailingComment&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt;(node: T, kind: SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia, text: string, hasTrailingNewLine?: boolean): T;</span>
    <span class="s2">function </span><span class="s1">moveSyntheticComments&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt;(node: T, original: Node): T;</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets the constant value to emit for an expression representing an enum.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">getConstantValue(node: AccessExpression): string | number | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Sets the constant value to emit for an expression.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">setConstantValue(node: AccessExpression, value: string | number): AccessExpression;</span>
    <span class="s0">/**</span>
     <span class="s0">* Adds an EmitHelper to a node.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">addEmitHelper&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt;(node: T, helper: EmitHelper): T;</span>
    <span class="s0">/**</span>
     <span class="s0">* Add EmitHelpers to a node.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">addEmitHelpers&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt;(node: T, helpers: EmitHelper[] | undefined): T;</span>
    <span class="s0">/**</span>
     <span class="s0">* Removes an EmitHelper from a node.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">removeEmitHelper(node: Node, helper: EmitHelper): boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets the EmitHelpers of a node.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">getEmitHelpers(node: Node): EmitHelper[] | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Moves matching emit helpers from a source node to a target node.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">moveEmitHelpers(source: Node, target: Node, predicate: (helper: EmitHelper) =&gt; boolean): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isNumericLiteral(node: Node): node is NumericLiteral;</span>
    <span class="s2">function </span><span class="s1">isBigIntLiteral(node: Node): node is BigIntLiteral;</span>
    <span class="s2">function </span><span class="s1">isStringLiteral(node: Node): node is StringLiteral;</span>
    <span class="s2">function </span><span class="s1">isJsxText(node: Node): node is JsxText;</span>
    <span class="s2">function </span><span class="s1">isRegularExpressionLiteral(node: Node): node is RegularExpressionLiteral;</span>
    <span class="s2">function </span><span class="s1">isNoSubstitutionTemplateLiteral(node: Node): node is NoSubstitutionTemplateLiteral;</span>
    <span class="s2">function </span><span class="s1">isTemplateHead(node: Node): node is TemplateHead;</span>
    <span class="s2">function </span><span class="s1">isTemplateMiddle(node: Node): node is TemplateMiddle;</span>
    <span class="s2">function </span><span class="s1">isTemplateTail(node: Node): node is TemplateTail;</span>
    <span class="s2">function </span><span class="s1">isDotDotDotToken(node: Node): node is DotDotDotToken;</span>
    <span class="s2">function </span><span class="s1">isPlusToken(node: Node): node is PlusToken;</span>
    <span class="s2">function </span><span class="s1">isMinusToken(node: Node): node is MinusToken;</span>
    <span class="s2">function </span><span class="s1">isAsteriskToken(node: Node): node is AsteriskToken;</span>
    <span class="s2">function </span><span class="s1">isExclamationToken(node: Node): node is ExclamationToken;</span>
    <span class="s2">function </span><span class="s1">isQuestionToken(node: Node): node is QuestionToken;</span>
    <span class="s2">function </span><span class="s1">isColonToken(node: Node): node is ColonToken;</span>
    <span class="s2">function </span><span class="s1">isQuestionDotToken(node: Node): node is QuestionDotToken;</span>
    <span class="s2">function </span><span class="s1">isEqualsGreaterThanToken(node: Node): node is EqualsGreaterThanToken;</span>
    <span class="s2">function </span><span class="s1">isIdentifier(node: Node): node is Identifier;</span>
    <span class="s2">function </span><span class="s1">isPrivateIdentifier(node: Node): node is PrivateIdentifier;</span>
    <span class="s2">function </span><span class="s1">isAssertsKeyword(node: Node): node is AssertsKeyword;</span>
    <span class="s2">function </span><span class="s1">isAwaitKeyword(node: Node): node is AwaitKeyword;</span>
    <span class="s2">function </span><span class="s1">isQualifiedName(node: Node): node is QualifiedName;</span>
    <span class="s2">function </span><span class="s1">isComputedPropertyName(node: Node): node is ComputedPropertyName;</span>
    <span class="s2">function </span><span class="s1">isTypeParameterDeclaration(node: Node): node is TypeParameterDeclaration;</span>
    <span class="s2">function </span><span class="s1">isParameter(node: Node): node is ParameterDeclaration;</span>
    <span class="s2">function </span><span class="s1">isDecorator(node: Node): node is Decorator;</span>
    <span class="s2">function </span><span class="s1">isPropertySignature(node: Node): node is PropertySignature;</span>
    <span class="s2">function </span><span class="s1">isPropertyDeclaration(node: Node): node is PropertyDeclaration;</span>
    <span class="s2">function </span><span class="s1">isMethodSignature(node: Node): node is MethodSignature;</span>
    <span class="s2">function </span><span class="s1">isMethodDeclaration(node: Node): node is MethodDeclaration;</span>
    <span class="s2">function </span><span class="s1">isClassStaticBlockDeclaration(node: Node): node is ClassStaticBlockDeclaration;</span>
    <span class="s2">function </span><span class="s1">isConstructorDeclaration(node: Node): node is ConstructorDeclaration;</span>
    <span class="s2">function </span><span class="s1">isGetAccessorDeclaration(node: Node): node is GetAccessorDeclaration;</span>
    <span class="s2">function </span><span class="s1">isSetAccessorDeclaration(node: Node): node is SetAccessorDeclaration;</span>
    <span class="s2">function </span><span class="s1">isCallSignatureDeclaration(node: Node): node is CallSignatureDeclaration;</span>
    <span class="s2">function </span><span class="s1">isConstructSignatureDeclaration(node: Node): node is ConstructSignatureDeclaration;</span>
    <span class="s2">function </span><span class="s1">isIndexSignatureDeclaration(node: Node): node is IndexSignatureDeclaration;</span>
    <span class="s2">function </span><span class="s1">isTypePredicateNode(node: Node): node is TypePredicateNode;</span>
    <span class="s2">function </span><span class="s1">isTypeReferenceNode(node: Node): node is TypeReferenceNode;</span>
    <span class="s2">function </span><span class="s1">isFunctionTypeNode(node: Node): node is FunctionTypeNode;</span>
    <span class="s2">function </span><span class="s1">isConstructorTypeNode(node: Node): node is ConstructorTypeNode;</span>
    <span class="s2">function </span><span class="s1">isTypeQueryNode(node: Node): node is TypeQueryNode;</span>
    <span class="s2">function </span><span class="s1">isTypeLiteralNode(node: Node): node is TypeLiteralNode;</span>
    <span class="s2">function </span><span class="s1">isArrayTypeNode(node: Node): node is ArrayTypeNode;</span>
    <span class="s2">function </span><span class="s1">isTupleTypeNode(node: Node): node is TupleTypeNode;</span>
    <span class="s2">function </span><span class="s1">isNamedTupleMember(node: Node): node is NamedTupleMember;</span>
    <span class="s2">function </span><span class="s1">isOptionalTypeNode(node: Node): node is OptionalTypeNode;</span>
    <span class="s2">function </span><span class="s1">isRestTypeNode(node: Node): node is RestTypeNode;</span>
    <span class="s2">function </span><span class="s1">isUnionTypeNode(node: Node): node is UnionTypeNode;</span>
    <span class="s2">function </span><span class="s1">isIntersectionTypeNode(node: Node): node is IntersectionTypeNode;</span>
    <span class="s2">function </span><span class="s1">isConditionalTypeNode(node: Node): node is ConditionalTypeNode;</span>
    <span class="s2">function </span><span class="s1">isInferTypeNode(node: Node): node is InferTypeNode;</span>
    <span class="s2">function </span><span class="s1">isParenthesizedTypeNode(node: Node): node is ParenthesizedTypeNode;</span>
    <span class="s2">function </span><span class="s1">isThisTypeNode(node: Node): node is ThisTypeNode;</span>
    <span class="s2">function </span><span class="s1">isTypeOperatorNode(node: Node): node is TypeOperatorNode;</span>
    <span class="s2">function </span><span class="s1">isIndexedAccessTypeNode(node: Node): node is IndexedAccessTypeNode;</span>
    <span class="s2">function </span><span class="s1">isMappedTypeNode(node: Node): node is MappedTypeNode;</span>
    <span class="s2">function </span><span class="s1">isLiteralTypeNode(node: Node): node is LiteralTypeNode;</span>
    <span class="s2">function </span><span class="s1">isImportTypeNode(node: Node): node is ImportTypeNode;</span>
    <span class="s2">function </span><span class="s1">isTemplateLiteralTypeSpan(node: Node): node is TemplateLiteralTypeSpan;</span>
    <span class="s2">function </span><span class="s1">isTemplateLiteralTypeNode(node: Node): node is TemplateLiteralTypeNode;</span>
    <span class="s2">function </span><span class="s1">isObjectBindingPattern(node: Node): node is ObjectBindingPattern;</span>
    <span class="s2">function </span><span class="s1">isArrayBindingPattern(node: Node): node is ArrayBindingPattern;</span>
    <span class="s2">function </span><span class="s1">isBindingElement(node: Node): node is BindingElement;</span>
    <span class="s2">function </span><span class="s1">isArrayLiteralExpression(node: Node): node is ArrayLiteralExpression;</span>
    <span class="s2">function </span><span class="s1">isObjectLiteralExpression(node: Node): node is ObjectLiteralExpression;</span>
    <span class="s2">function </span><span class="s1">isPropertyAccessExpression(node: Node): node is PropertyAccessExpression;</span>
    <span class="s2">function </span><span class="s1">isElementAccessExpression(node: Node): node is ElementAccessExpression;</span>
    <span class="s2">function </span><span class="s1">isCallExpression(node: Node): node is CallExpression;</span>
    <span class="s2">function </span><span class="s1">isNewExpression(node: Node): node is NewExpression;</span>
    <span class="s2">function </span><span class="s1">isTaggedTemplateExpression(node: Node): node is TaggedTemplateExpression;</span>
    <span class="s2">function </span><span class="s1">isTypeAssertionExpression(node: Node): node is TypeAssertion;</span>
    <span class="s2">function </span><span class="s1">isParenthesizedExpression(node: Node): node is ParenthesizedExpression;</span>
    <span class="s2">function </span><span class="s1">isFunctionExpression(node: Node): node is FunctionExpression;</span>
    <span class="s2">function </span><span class="s1">isArrowFunction(node: Node): node is ArrowFunction;</span>
    <span class="s2">function </span><span class="s1">isDeleteExpression(node: Node): node is DeleteExpression;</span>
    <span class="s2">function </span><span class="s1">isTypeOfExpression(node: Node): node is TypeOfExpression;</span>
    <span class="s2">function </span><span class="s1">isVoidExpression(node: Node): node is VoidExpression;</span>
    <span class="s2">function </span><span class="s1">isAwaitExpression(node: Node): node is AwaitExpression;</span>
    <span class="s2">function </span><span class="s1">isPrefixUnaryExpression(node: Node): node is PrefixUnaryExpression;</span>
    <span class="s2">function </span><span class="s1">isPostfixUnaryExpression(node: Node): node is PostfixUnaryExpression;</span>
    <span class="s2">function </span><span class="s1">isBinaryExpression(node: Node): node is BinaryExpression;</span>
    <span class="s2">function </span><span class="s1">isConditionalExpression(node: Node): node is ConditionalExpression;</span>
    <span class="s2">function </span><span class="s1">isTemplateExpression(node: Node): node is TemplateExpression;</span>
    <span class="s2">function </span><span class="s1">isYieldExpression(node: Node): node is YieldExpression;</span>
    <span class="s2">function </span><span class="s1">isSpreadElement(node: Node): node is SpreadElement;</span>
    <span class="s2">function </span><span class="s1">isClassExpression(node: Node): node is ClassExpression;</span>
    <span class="s2">function </span><span class="s1">isOmittedExpression(node: Node): node is OmittedExpression;</span>
    <span class="s2">function </span><span class="s1">isExpressionWithTypeArguments(node: Node): node is ExpressionWithTypeArguments;</span>
    <span class="s2">function </span><span class="s1">isAsExpression(node: Node): node is AsExpression;</span>
    <span class="s2">function </span><span class="s1">isSatisfiesExpression(node: Node): node is SatisfiesExpression;</span>
    <span class="s2">function </span><span class="s1">isNonNullExpression(node: Node): node is NonNullExpression;</span>
    <span class="s2">function </span><span class="s1">isMetaProperty(node: Node): node is MetaProperty;</span>
    <span class="s2">function </span><span class="s1">isSyntheticExpression(node: Node): node is SyntheticExpression;</span>
    <span class="s2">function </span><span class="s1">isPartiallyEmittedExpression(node: Node): node is PartiallyEmittedExpression;</span>
    <span class="s2">function </span><span class="s1">isCommaListExpression(node: Node): node is CommaListExpression;</span>
    <span class="s2">function </span><span class="s1">isTemplateSpan(node: Node): node is TemplateSpan;</span>
    <span class="s2">function </span><span class="s1">isSemicolonClassElement(node: Node): node is SemicolonClassElement;</span>
    <span class="s2">function </span><span class="s1">isBlock(node: Node): node is Block;</span>
    <span class="s2">function </span><span class="s1">isVariableStatement(node: Node): node is VariableStatement;</span>
    <span class="s2">function </span><span class="s1">isEmptyStatement(node: Node): node is EmptyStatement;</span>
    <span class="s2">function </span><span class="s1">isExpressionStatement(node: Node): node is ExpressionStatement;</span>
    <span class="s2">function </span><span class="s1">isIfStatement(node: Node): node is IfStatement;</span>
    <span class="s2">function </span><span class="s1">isDoStatement(node: Node): node is DoStatement;</span>
    <span class="s2">function </span><span class="s1">isWhileStatement(node: Node): node is WhileStatement;</span>
    <span class="s2">function </span><span class="s1">isForStatement(node: Node): node is ForStatement;</span>
    <span class="s2">function </span><span class="s1">isForInStatement(node: Node): node is ForInStatement;</span>
    <span class="s2">function </span><span class="s1">isForOfStatement(node: Node): node is ForOfStatement;</span>
    <span class="s2">function </span><span class="s1">isContinueStatement(node: Node): node is ContinueStatement;</span>
    <span class="s2">function </span><span class="s1">isBreakStatement(node: Node): node is BreakStatement;</span>
    <span class="s2">function </span><span class="s1">isReturnStatement(node: Node): node is ReturnStatement;</span>
    <span class="s2">function </span><span class="s1">isWithStatement(node: Node): node is WithStatement;</span>
    <span class="s2">function </span><span class="s1">isSwitchStatement(node: Node): node is SwitchStatement;</span>
    <span class="s2">function </span><span class="s1">isLabeledStatement(node: Node): node is LabeledStatement;</span>
    <span class="s2">function </span><span class="s1">isThrowStatement(node: Node): node is ThrowStatement;</span>
    <span class="s2">function </span><span class="s1">isTryStatement(node: Node): node is TryStatement;</span>
    <span class="s2">function </span><span class="s1">isDebuggerStatement(node: Node): node is DebuggerStatement;</span>
    <span class="s2">function </span><span class="s1">isVariableDeclaration(node: Node): node is VariableDeclaration;</span>
    <span class="s2">function </span><span class="s1">isVariableDeclarationList(node: Node): node is VariableDeclarationList;</span>
    <span class="s2">function </span><span class="s1">isFunctionDeclaration(node: Node): node is FunctionDeclaration;</span>
    <span class="s2">function </span><span class="s1">isClassDeclaration(node: Node): node is ClassDeclaration;</span>
    <span class="s2">function </span><span class="s1">isInterfaceDeclaration(node: Node): node is InterfaceDeclaration;</span>
    <span class="s2">function </span><span class="s1">isTypeAliasDeclaration(node: Node): node is TypeAliasDeclaration;</span>
    <span class="s2">function </span><span class="s1">isEnumDeclaration(node: Node): node is EnumDeclaration;</span>
    <span class="s2">function </span><span class="s1">isModuleDeclaration(node: Node): node is ModuleDeclaration;</span>
    <span class="s2">function </span><span class="s1">isModuleBlock(node: Node): node is ModuleBlock;</span>
    <span class="s2">function </span><span class="s1">isCaseBlock(node: Node): node is CaseBlock;</span>
    <span class="s2">function </span><span class="s1">isNamespaceExportDeclaration(node: Node): node is NamespaceExportDeclaration;</span>
    <span class="s2">function </span><span class="s1">isImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration;</span>
    <span class="s2">function </span><span class="s1">isImportDeclaration(node: Node): node is ImportDeclaration;</span>
    <span class="s2">function </span><span class="s1">isImportClause(node: Node): node is ImportClause;</span>
    <span class="s2">function </span><span class="s1">isImportTypeAssertionContainer(node: Node): node is ImportTypeAssertionContainer;</span>
    <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">isAssertClause(node: Node): node is AssertClause;</span>
    <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">isAssertEntry(node: Node): node is AssertEntry;</span>
    <span class="s2">function </span><span class="s1">isImportAttributes(node: Node): node is ImportAttributes;</span>
    <span class="s2">function </span><span class="s1">isImportAttribute(node: Node): node is ImportAttribute;</span>
    <span class="s2">function </span><span class="s1">isNamespaceImport(node: Node): node is NamespaceImport;</span>
    <span class="s2">function </span><span class="s1">isNamespaceExport(node: Node): node is NamespaceExport;</span>
    <span class="s2">function </span><span class="s1">isNamedImports(node: Node): node is NamedImports;</span>
    <span class="s2">function </span><span class="s1">isImportSpecifier(node: Node): node is ImportSpecifier;</span>
    <span class="s2">function </span><span class="s1">isExportAssignment(node: Node): node is ExportAssignment;</span>
    <span class="s2">function </span><span class="s1">isExportDeclaration(node: Node): node is ExportDeclaration;</span>
    <span class="s2">function </span><span class="s1">isNamedExports(node: Node): node is NamedExports;</span>
    <span class="s2">function </span><span class="s1">isExportSpecifier(node: Node): node is ExportSpecifier;</span>
    <span class="s2">function </span><span class="s1">isModuleExportName(node: Node): node is ModuleExportName;</span>
    <span class="s2">function </span><span class="s1">isMissingDeclaration(node: Node): node is MissingDeclaration;</span>
    <span class="s2">function </span><span class="s1">isNotEmittedStatement(node: Node): node is NotEmittedStatement;</span>
    <span class="s2">function </span><span class="s1">isExternalModuleReference(node: Node): node is ExternalModuleReference;</span>
    <span class="s2">function </span><span class="s1">isJsxElement(node: Node): node is JsxElement;</span>
    <span class="s2">function </span><span class="s1">isJsxSelfClosingElement(node: Node): node is JsxSelfClosingElement;</span>
    <span class="s2">function </span><span class="s1">isJsxOpeningElement(node: Node): node is JsxOpeningElement;</span>
    <span class="s2">function </span><span class="s1">isJsxClosingElement(node: Node): node is JsxClosingElement;</span>
    <span class="s2">function </span><span class="s1">isJsxFragment(node: Node): node is JsxFragment;</span>
    <span class="s2">function </span><span class="s1">isJsxOpeningFragment(node: Node): node is JsxOpeningFragment;</span>
    <span class="s2">function </span><span class="s1">isJsxClosingFragment(node: Node): node is JsxClosingFragment;</span>
    <span class="s2">function </span><span class="s1">isJsxAttribute(node: Node): node is JsxAttribute;</span>
    <span class="s2">function </span><span class="s1">isJsxAttributes(node: Node): node is JsxAttributes;</span>
    <span class="s2">function </span><span class="s1">isJsxSpreadAttribute(node: Node): node is JsxSpreadAttribute;</span>
    <span class="s2">function </span><span class="s1">isJsxExpression(node: Node): node is JsxExpression;</span>
    <span class="s2">function </span><span class="s1">isJsxNamespacedName(node: Node): node is JsxNamespacedName;</span>
    <span class="s2">function </span><span class="s1">isCaseClause(node: Node): node is CaseClause;</span>
    <span class="s2">function </span><span class="s1">isDefaultClause(node: Node): node is DefaultClause;</span>
    <span class="s2">function </span><span class="s1">isHeritageClause(node: Node): node is HeritageClause;</span>
    <span class="s2">function </span><span class="s1">isCatchClause(node: Node): node is CatchClause;</span>
    <span class="s2">function </span><span class="s1">isPropertyAssignment(node: Node): node is PropertyAssignment;</span>
    <span class="s2">function </span><span class="s1">isShorthandPropertyAssignment(node: Node): node is ShorthandPropertyAssignment;</span>
    <span class="s2">function </span><span class="s1">isSpreadAssignment(node: Node): node is SpreadAssignment;</span>
    <span class="s2">function </span><span class="s1">isEnumMember(node: Node): node is EnumMember;</span>
    <span class="s2">function </span><span class="s1">isSourceFile(node: Node): node is SourceFile;</span>
    <span class="s2">function </span><span class="s1">isBundle(node: Node): node is Bundle;</span>
    <span class="s2">function </span><span class="s1">isJSDocTypeExpression(node: Node): node is JSDocTypeExpression;</span>
    <span class="s2">function </span><span class="s1">isJSDocNameReference(node: Node): node is JSDocNameReference;</span>
    <span class="s2">function </span><span class="s1">isJSDocMemberName(node: Node): node is JSDocMemberName;</span>
    <span class="s2">function </span><span class="s1">isJSDocLink(node: Node): node is JSDocLink;</span>
    <span class="s2">function </span><span class="s1">isJSDocLinkCode(node: Node): node is JSDocLinkCode;</span>
    <span class="s2">function </span><span class="s1">isJSDocLinkPlain(node: Node): node is JSDocLinkPlain;</span>
    <span class="s2">function </span><span class="s1">isJSDocAllType(node: Node): node is JSDocAllType;</span>
    <span class="s2">function </span><span class="s1">isJSDocUnknownType(node: Node): node is JSDocUnknownType;</span>
    <span class="s2">function </span><span class="s1">isJSDocNullableType(node: Node): node is JSDocNullableType;</span>
    <span class="s2">function </span><span class="s1">isJSDocNonNullableType(node: Node): node is JSDocNonNullableType;</span>
    <span class="s2">function </span><span class="s1">isJSDocOptionalType(node: Node): node is JSDocOptionalType;</span>
    <span class="s2">function </span><span class="s1">isJSDocFunctionType(node: Node): node is JSDocFunctionType;</span>
    <span class="s2">function </span><span class="s1">isJSDocVariadicType(node: Node): node is JSDocVariadicType;</span>
    <span class="s2">function </span><span class="s1">isJSDocNamepathType(node: Node): node is JSDocNamepathType;</span>
    <span class="s2">function </span><span class="s1">isJSDoc(node: Node): node is JSDoc;</span>
    <span class="s2">function </span><span class="s1">isJSDocTypeLiteral(node: Node): node is JSDocTypeLiteral;</span>
    <span class="s2">function </span><span class="s1">isJSDocSignature(node: Node): node is JSDocSignature;</span>
    <span class="s2">function </span><span class="s1">isJSDocAugmentsTag(node: Node): node is JSDocAugmentsTag;</span>
    <span class="s2">function </span><span class="s1">isJSDocAuthorTag(node: Node): node is JSDocAuthorTag;</span>
    <span class="s2">function </span><span class="s1">isJSDocClassTag(node: Node): node is JSDocClassTag;</span>
    <span class="s2">function </span><span class="s1">isJSDocCallbackTag(node: Node): node is JSDocCallbackTag;</span>
    <span class="s2">function </span><span class="s1">isJSDocPublicTag(node: Node): node is JSDocPublicTag;</span>
    <span class="s2">function </span><span class="s1">isJSDocPrivateTag(node: Node): node is JSDocPrivateTag;</span>
    <span class="s2">function </span><span class="s1">isJSDocProtectedTag(node: Node): node is JSDocProtectedTag;</span>
    <span class="s2">function </span><span class="s1">isJSDocReadonlyTag(node: Node): node is JSDocReadonlyTag;</span>
    <span class="s2">function </span><span class="s1">isJSDocOverrideTag(node: Node): node is JSDocOverrideTag;</span>
    <span class="s2">function </span><span class="s1">isJSDocOverloadTag(node: Node): node is JSDocOverloadTag;</span>
    <span class="s2">function </span><span class="s1">isJSDocDeprecatedTag(node: Node): node is JSDocDeprecatedTag;</span>
    <span class="s2">function </span><span class="s1">isJSDocSeeTag(node: Node): node is JSDocSeeTag;</span>
    <span class="s2">function </span><span class="s1">isJSDocEnumTag(node: Node): node is JSDocEnumTag;</span>
    <span class="s2">function </span><span class="s1">isJSDocParameterTag(node: Node): node is JSDocParameterTag;</span>
    <span class="s2">function </span><span class="s1">isJSDocReturnTag(node: Node): node is JSDocReturnTag;</span>
    <span class="s2">function </span><span class="s1">isJSDocThisTag(node: Node): node is JSDocThisTag;</span>
    <span class="s2">function </span><span class="s1">isJSDocTypeTag(node: Node): node is JSDocTypeTag;</span>
    <span class="s2">function </span><span class="s1">isJSDocTemplateTag(node: Node): node is JSDocTemplateTag;</span>
    <span class="s2">function </span><span class="s1">isJSDocTypedefTag(node: Node): node is JSDocTypedefTag;</span>
    <span class="s2">function </span><span class="s1">isJSDocUnknownTag(node: Node): node is JSDocUnknownTag;</span>
    <span class="s2">function </span><span class="s1">isJSDocPropertyTag(node: Node): node is JSDocPropertyTag;</span>
    <span class="s2">function </span><span class="s1">isJSDocImplementsTag(node: Node): node is JSDocImplementsTag;</span>
    <span class="s2">function </span><span class="s1">isJSDocSatisfiesTag(node: Node): node is JSDocSatisfiesTag;</span>
    <span class="s2">function </span><span class="s1">isJSDocThrowsTag(node: Node): node is JSDocThrowsTag;</span>
    <span class="s2">function </span><span class="s1">isJSDocImportTag(node: Node): node is JSDocImportTag;</span>
    <span class="s2">function </span><span class="s1">isQuestionOrExclamationToken(node: Node): node is QuestionToken | ExclamationToken;</span>
    <span class="s2">function </span><span class="s1">isIdentifierOrThisTypeNode(node: Node): node is Identifier | ThisTypeNode;</span>
    <span class="s2">function </span><span class="s1">isReadonlyKeywordOrPlusOrMinusToken(node: Node): node is ReadonlyKeyword | PlusToken | MinusToken;</span>
    <span class="s2">function </span><span class="s1">isQuestionOrPlusOrMinusToken(node: Node): node is QuestionToken | PlusToken | MinusToken;</span>
    <span class="s2">function </span><span class="s1">isModuleName(node: Node): node is ModuleName;</span>
    <span class="s2">function </span><span class="s1">isBinaryOperatorToken(node: Node): node is BinaryOperatorToken;</span>
    <span class="s2">function </span><span class="s1">setTextRange&lt;T </span><span class="s2">extends </span><span class="s1">TextRange&gt;(range: T, location: TextRange | undefined): T;</span>
    <span class="s2">function </span><span class="s1">canHaveModifiers(node: Node): node is HasModifiers;</span>
    <span class="s2">function </span><span class="s1">canHaveDecorators(node: Node): node is HasDecorators;</span>
    <span class="s0">/**</span>
     <span class="s0">* Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes</span>
     <span class="s0">* stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; otherwise,</span>
     <span class="s0">* embedded arrays are flattened and the 'cbNode' callback is invoked for each element. If a callback returns</span>
     <span class="s0">* a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">node a given node to visit its children</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">cbNode a callback to be invoked for all child nodes</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">cbNodes a callback to be invoked for embedded array</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@remarks </span><span class="s0">`forEachChild` must visit the children of a node in the order</span>
     <span class="s0">* that they appear in the source code. The language service depends on this property to locate nodes by position.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">forEachChild&lt;T&gt;(node: Node, cbNode: (node: Node) =&gt; T | undefined, cbNodes?: (nodes: NodeArray&lt;Node&gt;) =&gt; T | undefined): T | undefined;</span>
    <span class="s2">function </span><span class="s1">createSourceFile(fileName: string, sourceText: string, languageVersionOrOptions: ScriptTarget | CreateSourceFileOptions, setParentNodes?: boolean, scriptKind?: ScriptKind): SourceFile;</span>
    <span class="s2">function </span><span class="s1">parseIsolatedEntityName(text: string, languageVersion: ScriptTarget): EntityName | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Parse json text into SyntaxTree and return node and parse errors if any</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">fileName</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">sourceText</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">parseJsonText(fileName: string, sourceText: string): JsonSourceFile;</span>
    <span class="s2">function </span><span class="s1">isExternalModule(file: SourceFile): boolean;</span>
    <span class="s2">function </span><span class="s1">updateSourceFile(sourceFile: SourceFile, newText: string, textChangeRange: TextChangeRange, aggressiveChecks?: boolean): SourceFile;</span>
    <span class="s2">interface </span><span class="s1">CreateSourceFileOptions {</span>
        <span class="s1">languageVersion: ScriptTarget;</span>
        <span class="s0">/**</span>
         <span class="s0">* Controls the format the file is detected as - this can be derived from only the path</span>
         <span class="s0">* and files on disk, but needs to be done with a module resolution cache in scope to be performant.</span>
         <span class="s0">* This is usually `undefined` for compilations that do not have `moduleResolution` values of `node16` or `nodenext`.</span>
         <span class="s0">*/</span>
        <span class="s1">impliedNodeFormat?: ResolutionMode;</span>
        <span class="s0">/**</span>
         <span class="s0">* Controls how module-y-ness is set for the given file. Usually the result of calling</span>
         <span class="s0">* `getSetExternalModuleIndicator` on a valid `CompilerOptions` object. If not present, the default</span>
         <span class="s0">* check specified by `isFileProbablyExternalModule` will be used to set the field.</span>
         <span class="s0">*/</span>
        <span class="s1">setExternalModuleIndicator?: (file: SourceFile) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">jsDocParsingMode?: JSDocParsingMode;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">parseCommandLine(commandLine: readonly string[], readFile?: (path: string) =&gt; string | undefined): ParsedCommandLine;</span>
    <span class="s2">function </span><span class="s1">parseBuildCommand(commandLine: readonly string[]): ParsedBuildCommand;</span>
    <span class="s0">/**</span>
     <span class="s0">* Reads the config file, reports errors if any and exits if the config file cannot be found</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">getParsedCommandLineOfConfigFile(configFileName: string, optionsToExtend: CompilerOptions | undefined, host: ParseConfigFileHost, extendedConfigCache?: Map&lt;string, ExtendedConfigCacheEntry&gt;, watchOptionsToExtend?: WatchOptions, extraFileExtensions?: readonly FileExtensionInfo[]): ParsedCommandLine | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Read tsconfig.json file</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">fileName The path to the config file</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">readConfigFile(fileName: string, readFile: (path: string) =&gt; string | undefined): {</span>
        <span class="s1">config?: any;</span>
        <span class="s1">error?: Diagnostic;</span>
    <span class="s1">};</span>
    <span class="s0">/**</span>
     <span class="s0">* Parse the text of the tsconfig.json file</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">fileName The path to the config file</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">jsonText The text of the config file</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">parseConfigFileTextToJson(fileName: string, jsonText: string): {</span>
        <span class="s1">config?: any;</span>
        <span class="s1">error?: Diagnostic;</span>
    <span class="s1">};</span>
    <span class="s0">/**</span>
     <span class="s0">* Read tsconfig.json file</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">fileName The path to the config file</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">readJsonConfigFile(fileName: string, readFile: (path: string) =&gt; string | undefined): TsConfigSourceFile;</span>
    <span class="s0">/**</span>
     <span class="s0">* Convert the json syntax tree into the json value</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">convertToObject(sourceFile: JsonSourceFile, errors: Diagnostic[]): any;</span>
    <span class="s0">/**</span>
     <span class="s0">* Parse the contents of a config file (tsconfig.json).</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">json The contents of the config file to parse</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">host Instance of ParseConfigHost used to enumerate files in folder.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">basePath A root directory to resolve relative path entries in the config</span>
     <span class="s0">*    file to. e.g. outDir</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">parseJsonConfigFileContent(json: any, host: ParseConfigHost, basePath: string, existingOptions?: CompilerOptions, configFileName?: string, resolutionStack?: Path[], extraFileExtensions?: readonly FileExtensionInfo[], extendedConfigCache?: Map&lt;string, ExtendedConfigCacheEntry&gt;, existingWatchOptions?: WatchOptions): ParsedCommandLine;</span>
    <span class="s0">/**</span>
     <span class="s0">* Parse the contents of a config file (tsconfig.json).</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">jsonNode The contents of the config file to parse</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">host Instance of ParseConfigHost used to enumerate files in folder.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">basePath A root directory to resolve relative path entries in the config</span>
     <span class="s0">*    file to. e.g. outDir</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">parseJsonSourceFileConfigFileContent(sourceFile: TsConfigSourceFile, host: ParseConfigHost, basePath: string, existingOptions?: CompilerOptions, configFileName?: string, resolutionStack?: Path[], extraFileExtensions?: readonly FileExtensionInfo[], extendedConfigCache?: Map&lt;string, ExtendedConfigCacheEntry&gt;, existingWatchOptions?: WatchOptions): ParsedCommandLine;</span>
    <span class="s2">function </span><span class="s1">convertCompilerOptionsFromJson(jsonOptions: any, basePath: string, configFileName?: string): {</span>
        <span class="s1">options: CompilerOptions;</span>
        <span class="s1">errors: Diagnostic[];</span>
    <span class="s1">};</span>
    <span class="s2">function </span><span class="s1">convertTypeAcquisitionFromJson(jsonOptions: any, basePath: string, configFileName?: string): {</span>
        <span class="s1">options: TypeAcquisition;</span>
        <span class="s1">errors: Diagnostic[];</span>
    <span class="s1">};</span>
    <span class="s0">/** Parsed command line for build */</span>
    <span class="s2">interface </span><span class="s1">ParsedBuildCommand {</span>
        <span class="s1">buildOptions: BuildOptions;</span>
        <span class="s1">watchOptions: WatchOptions | undefined;</span>
        <span class="s1">projects: string[];</span>
        <span class="s1">errors: Diagnostic[];</span>
    <span class="s1">}</span>
    <span class="s1">type DiagnosticReporter = (diagnostic: Diagnostic) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Reports config file diagnostics</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">ConfigFileDiagnosticsReporter {</span>
        <span class="s0">/**</span>
         <span class="s0">* Reports unrecoverable error when parsing config file</span>
         <span class="s0">*/</span>
        <span class="s1">onUnRecoverableConfigFileDiagnostic: DiagnosticReporter;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Interface extending ParseConfigHost to support ParseConfigFile that reads config file and reports errors</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">ParseConfigFileHost </span><span class="s2">extends </span><span class="s1">ParseConfigHost, ConfigFileDiagnosticsReporter {</span>
        <span class="s1">getCurrentDirectory(): string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ParsedTsconfig {</span>
        <span class="s1">raw: any;</span>
        <span class="s1">options?: CompilerOptions;</span>
        <span class="s1">watchOptions?: WatchOptions;</span>
        <span class="s1">typeAcquisition?: TypeAcquisition;</span>
        <span class="s0">/**</span>
         <span class="s0">* Note that the case of the config path has not yet been normalized, as no files have been imported into the project yet</span>
         <span class="s0">*/</span>
        <span class="s1">extendedConfigPath?: string | string[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ExtendedConfigCacheEntry {</span>
        <span class="s1">extendedResult: TsConfigSourceFile;</span>
        <span class="s1">extendedConfig: ParsedTsconfig | undefined;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">getEffectiveTypeRoots(options: CompilerOptions, host: GetEffectiveTypeRootsHost): string[] | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">{string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.</span>
     <span class="s0">* This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups</span>
     <span class="s0">* is assumed to be the same as root directory of the project.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">resolveTypeReferenceDirective(typeReferenceDirectiveName: string, containingFile: string | undefined, options: CompilerOptions, host: ModuleResolutionHost, redirectedReference?: ResolvedProjectReference, cache?: TypeReferenceDirectiveResolutionCache, resolutionMode?: ResolutionMode): ResolvedTypeReferenceDirectiveWithFailedLookupLocations;</span>
    <span class="s0">/**</span>
     <span class="s0">* Given a set of options, returns the set of type directive names</span>
     <span class="s0">*   that should be included for this program automatically.</span>
     <span class="s0">* This list could either come from the config file,</span>
     <span class="s0">*   or from enumerating the types root + initial secondary types lookup location.</span>
     <span class="s0">* More type directives might appear in the program later as a result of loading actual source files;</span>
     <span class="s0">*   this list is only the set of defaults that are implicitly included.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">getAutomaticTypeDirectiveNames(options: CompilerOptions, host: ModuleResolutionHost): string[];</span>
    <span class="s2">function </span><span class="s1">createModuleResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) =&gt; string, options?: CompilerOptions, packageJsonInfoCache?: PackageJsonInfoCache): ModuleResolutionCache;</span>
    <span class="s2">function </span><span class="s1">createTypeReferenceDirectiveResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) =&gt; string, options?: CompilerOptions, packageJsonInfoCache?: PackageJsonInfoCache): TypeReferenceDirectiveResolutionCache;</span>
    <span class="s2">function </span><span class="s1">resolveModuleNameFromCache(moduleName: string, containingFile: string, cache: ModuleResolutionCache, mode?: ResolutionMode): ResolvedModuleWithFailedLookupLocations | undefined;</span>
    <span class="s2">function </span><span class="s1">resolveModuleName(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference, resolutionMode?: ResolutionMode): ResolvedModuleWithFailedLookupLocations;</span>
    <span class="s2">function </span><span class="s1">bundlerModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;</span>
    <span class="s2">function </span><span class="s1">nodeModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;</span>
    <span class="s2">function </span><span class="s1">classicNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: NonRelativeModuleNameResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;</span>
    <span class="s2">interface </span><span class="s1">TypeReferenceDirectiveResolutionCache </span><span class="s2">extends </span><span class="s1">PerDirectoryResolutionCache&lt;ResolvedTypeReferenceDirectiveWithFailedLookupLocations&gt;, NonRelativeNameResolutionCache&lt;ResolvedTypeReferenceDirectiveWithFailedLookupLocations&gt;, PackageJsonInfoCache {</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ModeAwareCache&lt;T&gt; {</span>
        <span class="s1">get(key: string, mode: ResolutionMode): T | undefined;</span>
        <span class="s1">set(key: string, mode: ResolutionMode, value: T): </span><span class="s2">this</span><span class="s1">;</span>
        <span class="s2">delete</span><span class="s1">(key: string, mode: ResolutionMode): </span><span class="s2">this</span><span class="s1">;</span>
        <span class="s1">has(key: string, mode: ResolutionMode): boolean;</span>
        <span class="s1">forEach(cb: (elem: T, key: string, mode: ResolutionMode) =&gt; </span><span class="s2">void</span><span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">size(): number;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Cached resolutions per containing directory.</span>
     <span class="s0">* This assumes that any module id will have the same resolution for sibling files located in the same folder.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">PerDirectoryResolutionCache&lt;T&gt; {</span>
        <span class="s1">getFromDirectoryCache(name: string, mode: ResolutionMode, directoryName: string, redirectedReference: ResolvedProjectReference | undefined): T | undefined;</span>
        <span class="s1">getOrCreateCacheForDirectory(directoryName: string, redirectedReference?: ResolvedProjectReference): ModeAwareCache&lt;T&gt;;</span>
        <span class="s1">clear(): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">*  Updates with the current compilerOptions the cache will operate with.</span>
         <span class="s0">*  This updates the redirects map as well if needed so module resolutions are cached if they can across the projects</span>
         <span class="s0">*/</span>
        <span class="s1">update(options: CompilerOptions): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">NonRelativeNameResolutionCache&lt;T&gt; {</span>
        <span class="s1">getFromNonRelativeNameCache(nonRelativeName: string, mode: ResolutionMode, directoryName: string, redirectedReference: ResolvedProjectReference | undefined): T | undefined;</span>
        <span class="s1">getOrCreateCacheForNonRelativeName(nonRelativeName: string, mode: ResolutionMode, redirectedReference?: ResolvedProjectReference): PerNonRelativeNameCache&lt;T&gt;;</span>
        <span class="s1">clear(): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">*  Updates with the current compilerOptions the cache will operate with.</span>
         <span class="s0">*  This updates the redirects map as well if needed so module resolutions are cached if they can across the projects</span>
         <span class="s0">*/</span>
        <span class="s1">update(options: CompilerOptions): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">PerNonRelativeNameCache&lt;T&gt; {</span>
        <span class="s1">get(directory: string): T | undefined;</span>
        <span class="s1">set(directory: string, result: T): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ModuleResolutionCache </span><span class="s2">extends </span><span class="s1">PerDirectoryResolutionCache&lt;ResolvedModuleWithFailedLookupLocations&gt;, NonRelativeModuleNameResolutionCache, PackageJsonInfoCache {</span>
        <span class="s1">getPackageJsonInfoCache(): PackageJsonInfoCache;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Stored map from non-relative module name to a table: directory -&gt; result of module lookup in this directory</span>
     <span class="s0">* We support only non-relative module names because resolution of relative module names is usually more deterministic and thus less expensive.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">NonRelativeModuleNameResolutionCache </span><span class="s2">extends </span><span class="s1">NonRelativeNameResolutionCache&lt;ResolvedModuleWithFailedLookupLocations&gt;, PackageJsonInfoCache {</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">Use getOrCreateCacheForNonRelativeName */</span>
        <span class="s1">getOrCreateCacheForModuleName(nonRelativeModuleName: string, mode: ResolutionMode, redirectedReference?: ResolvedProjectReference): PerModuleNameCache;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">PackageJsonInfoCache {</span>
        <span class="s1">clear(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">type PerModuleNameCache = PerNonRelativeNameCache&lt;ResolvedModuleWithFailedLookupLocations&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Visits a Node using the supplied visitor, possibly returning a new Node in its place.</span>
     <span class="s0">*</span>
     <span class="s0">* - If the input node is undefined, then the output is undefined.</span>
     <span class="s0">* - If the visitor returns undefined, then the output is undefined.</span>
     <span class="s0">* - If the output node is not undefined, then it will satisfy the test function.</span>
     <span class="s0">* - In order to obtain a return type that is more specific than `Node`, a test</span>
     <span class="s0">*   function _must_ be provided, and that function must be a type predicate.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">node The Node to visit.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">visitor The callback used to visit the Node.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">test A callback to execute to verify the Node is valid.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">lift An optional callback to execute to lift a NodeArray into a valid Node.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">visitNode&lt;TIn </span><span class="s2">extends </span><span class="s1">Node | undefined, TVisited </span><span class="s2">extends </span><span class="s1">Node | undefined, TOut </span><span class="s2">extends </span><span class="s1">Node&gt;(node: TIn, visitor: Visitor&lt;NonNullable&lt;TIn&gt;, TVisited&gt;, test: (node: Node) =&gt; node is TOut, lift?: (node: readonly Node[]) =&gt; Node): TOut | (TIn &amp; undefined) | (TVisited &amp; undefined);</span>
    <span class="s0">/**</span>
     <span class="s0">* Visits a Node using the supplied visitor, possibly returning a new Node in its place.</span>
     <span class="s0">*</span>
     <span class="s0">* - If the input node is undefined, then the output is undefined.</span>
     <span class="s0">* - If the visitor returns undefined, then the output is undefined.</span>
     <span class="s0">* - If the output node is not undefined, then it will satisfy the test function.</span>
     <span class="s0">* - In order to obtain a return type that is more specific than `Node`, a test</span>
     <span class="s0">*   function _must_ be provided, and that function must be a type predicate.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">node The Node to visit.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">visitor The callback used to visit the Node.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">test A callback to execute to verify the Node is valid.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">lift An optional callback to execute to lift a NodeArray into a valid Node.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">visitNode&lt;TIn </span><span class="s2">extends </span><span class="s1">Node | undefined, TVisited </span><span class="s2">extends </span><span class="s1">Node | undefined&gt;(node: TIn, visitor: Visitor&lt;NonNullable&lt;TIn&gt;, TVisited&gt;, test?: (node: Node) =&gt; boolean, lift?: (node: readonly Node[]) =&gt; Node): Node | (TIn &amp; undefined) | (TVisited &amp; undefined);</span>
    <span class="s0">/**</span>
     <span class="s0">* Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.</span>
     <span class="s0">*</span>
     <span class="s0">* - If the input node array is undefined, the output is undefined.</span>
     <span class="s0">* - If the visitor can return undefined, the node it visits in the array will be reused.</span>
     <span class="s0">* - If the output node array is not undefined, then its contents will satisfy the test.</span>
     <span class="s0">* - In order to obtain a return type that is more specific than `NodeArray&lt;Node&gt;`, a test</span>
     <span class="s0">*   function _must_ be provided, and that function must be a type predicate.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">nodes The NodeArray to visit.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">visitor The callback used to visit a Node.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">test A node test to execute for each node.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">start An optional value indicating the starting offset at which to start visiting.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">count An optional value indicating the maximum number of nodes to visit.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">visitNodes&lt;TIn </span><span class="s2">extends </span><span class="s1">Node, TInArray </span><span class="s2">extends </span><span class="s1">NodeArray&lt;TIn&gt; | undefined, TOut </span><span class="s2">extends </span><span class="s1">Node&gt;(nodes: TInArray, visitor: Visitor&lt;TIn, Node | undefined&gt;, test: (node: Node) =&gt; node is TOut, start?: number, count?: number): NodeArray&lt;TOut&gt; | (TInArray &amp; undefined);</span>
    <span class="s0">/**</span>
     <span class="s0">* Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.</span>
     <span class="s0">*</span>
     <span class="s0">* - If the input node array is undefined, the output is undefined.</span>
     <span class="s0">* - If the visitor can return undefined, the node it visits in the array will be reused.</span>
     <span class="s0">* - If the output node array is not undefined, then its contents will satisfy the test.</span>
     <span class="s0">* - In order to obtain a return type that is more specific than `NodeArray&lt;Node&gt;`, a test</span>
     <span class="s0">*   function _must_ be provided, and that function must be a type predicate.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">nodes The NodeArray to visit.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">visitor The callback used to visit a Node.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">test A node test to execute for each node.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">start An optional value indicating the starting offset at which to start visiting.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">count An optional value indicating the maximum number of nodes to visit.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">visitNodes&lt;TIn </span><span class="s2">extends </span><span class="s1">Node, TInArray </span><span class="s2">extends </span><span class="s1">NodeArray&lt;TIn&gt; | undefined&gt;(nodes: TInArray, visitor: Visitor&lt;TIn, Node | undefined&gt;, test?: (node: Node) =&gt; boolean, start?: number, count?: number): NodeArray&lt;Node&gt; | (TInArray &amp; undefined);</span>
    <span class="s0">/**</span>
     <span class="s0">* Starts a new lexical environment and visits a statement list, ending the lexical environment</span>
     <span class="s0">* and merging hoisted declarations upon completion.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">visitLexicalEnvironment(statements: NodeArray&lt;Statement&gt;, visitor: Visitor, context: TransformationContext, start?: number, ensureUseStrict?: boolean, nodesVisitor?: NodesVisitor): NodeArray&lt;Statement&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Starts a new lexical environment and visits a parameter list, suspending the lexical</span>
     <span class="s0">* environment upon completion.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">visitParameterList(nodes: NodeArray&lt;ParameterDeclaration&gt;, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor): NodeArray&lt;ParameterDeclaration&gt;;</span>
    <span class="s2">function </span><span class="s1">visitParameterList(nodes: NodeArray&lt;ParameterDeclaration&gt; | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor): NodeArray&lt;ParameterDeclaration&gt; | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Resumes a suspended lexical environment and visits a function body, ending the lexical</span>
     <span class="s0">* environment and merging hoisted declarations upon completion.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">visitFunctionBody(node: FunctionBody, visitor: Visitor, context: TransformationContext): FunctionBody;</span>
    <span class="s0">/**</span>
     <span class="s0">* Resumes a suspended lexical environment and visits a function body, ending the lexical</span>
     <span class="s0">* environment and merging hoisted declarations upon completion.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">visitFunctionBody(node: FunctionBody | undefined, visitor: Visitor, context: TransformationContext): FunctionBody | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Resumes a suspended lexical environment and visits a concise body, ending the lexical</span>
     <span class="s0">* environment and merging hoisted declarations upon completion.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">visitFunctionBody(node: ConciseBody, visitor: Visitor, context: TransformationContext): ConciseBody;</span>
    <span class="s0">/**</span>
     <span class="s0">* Visits an iteration body, adding any block-scoped variables required by the transformation.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">visitIterationBody(body: Statement, visitor: Visitor, context: TransformationContext): Statement;</span>
    <span class="s0">/**</span>
     <span class="s0">* Visits the elements of a {</span><span class="s4">@link </span><span class="s0">CommaListExpression}.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">visitor The visitor to use when visiting expressions whose result will not be discarded at runtime.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">discardVisitor The visitor to use when visiting expressions whose result will be discarded at runtime. Defaults to {</span><span class="s4">@link </span><span class="s0">visitor}.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">visitCommaListElements(elements: NodeArray&lt;Expression&gt;, visitor: Visitor, discardVisitor?: Visitor): NodeArray&lt;Expression&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">node The Node whose children will be visited.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">visitor The callback used to visit each child.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">context A lexical environment context for the visitor.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">visitEachChild&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt;(node: T, visitor: Visitor, context: TransformationContext | undefined): T;</span>
    <span class="s0">/**</span>
     <span class="s0">* Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">node The Node whose children will be visited.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">visitor The callback used to visit each child.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">context A lexical environment context for the visitor.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">visitEachChild&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt;(node: T | undefined, visitor: Visitor, context: TransformationContext | undefined, nodesVisitor?: </span><span class="s2">typeof </span><span class="s1">visitNodes, tokenVisitor?: Visitor): T | undefined;</span>
    <span class="s2">function </span><span class="s1">getTsBuildInfoEmitOutputFilePath(options: CompilerOptions): string | undefined;</span>
    <span class="s2">function </span><span class="s1">getOutputFileNames(commandLine: ParsedCommandLine, inputFileName: string, ignoreCase: boolean): readonly string[];</span>
    <span class="s2">function </span><span class="s1">createPrinter(printerOptions?: PrinterOptions, handlers?: PrintHandlers): Printer;</span>
    <span class="s2">enum </span><span class="s1">ProgramUpdateLevel {</span>
        <span class="s0">/** Program is updated with same root file names and options */</span>
        <span class="s1">Update = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/** Loads program after updating root file names from the disk */</span>
        <span class="s1">RootNamesAndUpdate = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s0">/**</span>
         <span class="s0">* Loads program completely, including:</span>
         <span class="s0">*  - re-reading contents of config file from disk</span>
         <span class="s0">*  - calculating root file names for the program</span>
         <span class="s0">*  - Updating the program</span>
         <span class="s0">*/</span>
        <span class="s1">Full = </span><span class="s5">2</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">findConfigFile(searchPath: string, fileExists: (fileName: string) =&gt; boolean, configName?: string): string | undefined;</span>
    <span class="s2">function </span><span class="s1">resolveTripleslashReference(moduleName: string, containingFile: string): string;</span>
    <span class="s2">function </span><span class="s1">createCompilerHost(options: CompilerOptions, setParentNodes?: boolean): CompilerHost;</span>
    <span class="s2">function </span><span class="s1">getPreEmitDiagnostics(program: Program, sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];</span>
    <span class="s2">function </span><span class="s1">formatDiagnostics(diagnostics: readonly Diagnostic[], host: FormatDiagnosticsHost): string;</span>
    <span class="s2">function </span><span class="s1">formatDiagnostic(diagnostic: Diagnostic, host: FormatDiagnosticsHost): string;</span>
    <span class="s2">function </span><span class="s1">formatDiagnosticsWithColorAndContext(diagnostics: readonly Diagnostic[], host: FormatDiagnosticsHost): string;</span>
    <span class="s2">function </span><span class="s1">flattenDiagnosticMessageText(diag: string | DiagnosticMessageChain | undefined, newLine: string, indent?: number): string;</span>
    <span class="s0">/**</span>
     <span class="s0">* Calculates the resulting resolution mode for some reference in some file - this is generally the explicitly</span>
     <span class="s0">* provided resolution mode in the reference, unless one is not present, in which case it is the mode of the containing file.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">getModeForFileReference(ref: FileReference | string, containingFileMode: ResolutionMode): ResolutionMode;</span>
    <span class="s0">/**</span>
     <span class="s0">* Use `program.getModeForResolutionAtIndex`, which retrieves the correct `compilerOptions`, instead of this function whenever possible.</span>
     <span class="s0">* Calculates the final resolution mode for an import at some index within a file's `imports` list. This is the resolution mode</span>
     <span class="s0">* explicitly provided via import attributes, if present, or the syntax the usage would have if emitted to JavaScript. In</span>
     <span class="s0">* `--module node16` or `nodenext`, this may depend on the file's `impliedNodeFormat`. In `--module preserve`, it depends only on the</span>
     <span class="s0">* input syntax of the reference. In other `module` modes, when overriding import attributes are not provided, this function returns</span>
     <span class="s0">* `undefined`, as the result would have no impact on module resolution, emit, or type checking.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">file File to fetch the resolution mode within</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">index Index into the file's complete resolution list to get the resolution of - this is a concatenation of the file's imports and module augmentations</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">compilerOptions The compiler options for the program that owns the file. If the file belongs to a referenced project, the compiler options</span>
     <span class="s0">* should be the options of the referenced project, not the referencing project.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">getModeForResolutionAtIndex(file: SourceFile, index: number, compilerOptions: CompilerOptions): ResolutionMode;</span>
    <span class="s0">/**</span>
     <span class="s0">* Use `program.getModeForUsageLocation`, which retrieves the correct `compilerOptions`, instead of this function whenever possible.</span>
     <span class="s0">* Calculates the final resolution mode for a given module reference node. This function only returns a result when module resolution</span>
     <span class="s0">* settings allow differing resolution between ESM imports and CJS requires, or when a mode is explicitly provided via import attributes,</span>
     <span class="s0">* which cause an `import` or `require` condition to be used during resolution regardless of module resolution settings. In absence of</span>
     <span class="s0">* overriding attributes, and in modes that support differing resolution, the result indicates the syntax the usage would emit to JavaScript.</span>
     <span class="s0">* Some examples:</span>
     <span class="s0">*</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* // tsc foo.mts --module nodenext</span>
     <span class="s0">* import {} from &quot;mod&quot;;</span>
     <span class="s0">* // Result: ESNext - the import emits as ESM due to `impliedNodeFormat` set by .mts file extension</span>
     <span class="s0">*</span>
     <span class="s0">* // tsc foo.cts --module nodenext</span>
     <span class="s0">* import {} from &quot;mod&quot;;</span>
     <span class="s0">* // Result: CommonJS - the import emits as CJS due to `impliedNodeFormat` set by .cts file extension</span>
     <span class="s0">*</span>
     <span class="s0">* // tsc foo.ts --module preserve --moduleResolution bundler</span>
     <span class="s0">* import {} from &quot;mod&quot;;</span>
     <span class="s0">* // Result: ESNext - the import emits as ESM due to `--module preserve` and `--moduleResolution bundler`</span>
     <span class="s0">* // supports conditional imports/exports</span>
     <span class="s0">*</span>
     <span class="s0">* // tsc foo.ts --module preserve --moduleResolution node10</span>
     <span class="s0">* import {} from &quot;mod&quot;;</span>
     <span class="s0">* // Result: undefined - the import emits as ESM due to `--module preserve`, but `--moduleResolution node10`</span>
     <span class="s0">* // does not support conditional imports/exports</span>
     <span class="s0">*</span>
     <span class="s0">* // tsc foo.ts --module commonjs --moduleResolution node10</span>
     <span class="s0">* import type {} from &quot;mod&quot; with { &quot;resolution-mode&quot;: &quot;import&quot; };</span>
     <span class="s0">* // Result: ESNext - conditional imports/exports always supported with &quot;resolution-mode&quot; attribute</span>
     <span class="s0">* ```</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">file The file the import or import-like reference is contained within</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">usage The module reference string</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">compilerOptions The compiler options for the program that owns the file. If the file belongs to a referenced project, the compiler options</span>
     <span class="s0">* should be the options of the referenced project, not the referencing project.</span>
     <span class="s0">* </span><span class="s4">@returns </span><span class="s0">The final resolution mode of the import</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">getModeForUsageLocation(file: SourceFile, usage: StringLiteralLike, compilerOptions: CompilerOptions): ResolutionMode;</span>
    <span class="s2">function </span><span class="s1">getConfigFileParsingDiagnostics(configFileParseResult: ParsedCommandLine): readonly Diagnostic[];</span>
    <span class="s0">/**</span>
     <span class="s0">* A function for determining if a given file is esm or cjs format, assuming modern node module resolution rules, as configured by the</span>
     <span class="s0">* `options` parameter.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">fileName The file name to check the format of (it need not exist on disk)</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">[packageJsonInfoCache] A cache for package file lookups - it's best to have a cache when this function is called often</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">host The ModuleResolutionHost which can perform the filesystem lookups for package json data</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">options The compiler options to perform the analysis under - relevant options are `moduleResolution` and `traceResolution`</span>
     <span class="s0">* </span><span class="s4">@returns </span><span class="s0">`undefined` if the path has no relevant implied format, `ModuleKind.ESNext` for esm format, and `ModuleKind.CommonJS` for cjs format</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">getImpliedNodeFormatForFile(fileName: string, packageJsonInfoCache: PackageJsonInfoCache | undefined, host: ModuleResolutionHost, options: CompilerOptions): ResolutionMode;</span>
    <span class="s0">/**</span>
     <span class="s0">* Create a new 'Program' instance. A Program is an immutable collection of 'SourceFile's and a 'CompilerOptions'</span>
     <span class="s0">* that represent a compilation unit.</span>
     <span class="s0">*</span>
     <span class="s0">* Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and</span>
     <span class="s0">* triple-slash-reference-path directives transitively. '@types' and triple-slash-reference-types are also pulled in.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">createProgramOptions - The options for creating a program.</span>
     <span class="s0">* </span><span class="s4">@returns </span><span class="s0">A 'Program' object.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">createProgram(createProgramOptions: CreateProgramOptions): Program;</span>
    <span class="s0">/**</span>
     <span class="s0">* Create a new 'Program' instance. A Program is an immutable collection of 'SourceFile's and a 'CompilerOptions'</span>
     <span class="s0">* that represent a compilation unit.</span>
     <span class="s0">*</span>
     <span class="s0">* Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and</span>
     <span class="s0">* triple-slash-reference-path directives transitively. '@types' and triple-slash-reference-types are also pulled in.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">rootNames - A set of root files.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">options - The compiler options which should be used.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">host - The host interacts with the underlying file system.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">oldProgram - Reuses an old program structure.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">configFileParsingDiagnostics - error during config file parsing</span>
     <span class="s0">* </span><span class="s4">@returns </span><span class="s0">A 'Program' object.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">createProgram(rootNames: readonly string[], options: CompilerOptions, host?: CompilerHost, oldProgram?: Program, configFileParsingDiagnostics?: readonly Diagnostic[]): Program;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns the target config filename of a project reference.</span>
     <span class="s0">* Note: The file might not exist.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">resolveProjectReferencePath(ref: ProjectReference): ResolvedConfigFileName;</span>
    <span class="s2">interface </span><span class="s1">FormatDiagnosticsHost {</span>
        <span class="s1">getCurrentDirectory(): string;</span>
        <span class="s1">getCanonicalFileName(fileName: string): string;</span>
        <span class="s1">getNewLine(): string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">EmitOutput {</span>
        <span class="s1">outputFiles: OutputFile[];</span>
        <span class="s1">emitSkipped: boolean;</span>
        <span class="s1">diagnostics: readonly Diagnostic[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">OutputFile {</span>
        <span class="s1">name: string;</span>
        <span class="s1">writeByteOrderMark: boolean;</span>
        <span class="s1">text: string;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Create the builder to manage semantic diagnostics and cache them</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">createSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram?: SemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): SemanticDiagnosticsBuilderProgram;</span>
    <span class="s2">function </span><span class="s1">createSemanticDiagnosticsBuilderProgram(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: SemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): SemanticDiagnosticsBuilderProgram;</span>
    <span class="s0">/**</span>
     <span class="s0">* Create the builder that can handle the changes in program and iterate through changed files</span>
     <span class="s0">* to emit the those files and manage semantic diagnostics cache as well</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">createEmitAndSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): EmitAndSemanticDiagnosticsBuilderProgram;</span>
    <span class="s2">function </span><span class="s1">createEmitAndSemanticDiagnosticsBuilderProgram(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): EmitAndSemanticDiagnosticsBuilderProgram;</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates a builder thats just abstraction over program and can be used with watch</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">createAbstractBuilder(newProgram: Program, host: BuilderProgramHost, oldProgram?: BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): BuilderProgram;</span>
    <span class="s2">function </span><span class="s1">createAbstractBuilder(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): BuilderProgram;</span>
    <span class="s1">type AffectedFileResult&lt;T&gt; = {</span>
        <span class="s1">result: T;</span>
        <span class="s1">affected: SourceFile | Program;</span>
    <span class="s1">} | undefined;</span>
    <span class="s2">interface </span><span class="s1">BuilderProgramHost {</span>
        <span class="s0">/**</span>
         <span class="s0">* If provided this would be used this hash instead of actual file shape text for detecting changes</span>
         <span class="s0">*/</span>
        <span class="s1">createHash?: (data: string) =&gt; string;</span>
        <span class="s0">/**</span>
         <span class="s0">* When emit or emitNextAffectedFile are called without writeFile,</span>
         <span class="s0">* this callback if present would be used to write files</span>
         <span class="s0">*/</span>
        <span class="s1">writeFile?: WriteFileCallback;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Builder to manage the program state changes</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">BuilderProgram {</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns current program</span>
         <span class="s0">*/</span>
        <span class="s1">getProgram(): Program;</span>
        <span class="s0">/**</span>
         <span class="s0">* Get compiler options of the program</span>
         <span class="s0">*/</span>
        <span class="s1">getCompilerOptions(): CompilerOptions;</span>
        <span class="s0">/**</span>
         <span class="s0">* Get the source file in the program with file name</span>
         <span class="s0">*/</span>
        <span class="s1">getSourceFile(fileName: string): SourceFile | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* Get a list of files in the program</span>
         <span class="s0">*/</span>
        <span class="s1">getSourceFiles(): readonly SourceFile[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Get the diagnostics for compiler options</span>
         <span class="s0">*/</span>
        <span class="s1">getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Get the diagnostics that dont belong to any file</span>
         <span class="s0">*/</span>
        <span class="s1">getGlobalDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Get the diagnostics from config file parsing</span>
         <span class="s0">*/</span>
        <span class="s1">getConfigFileParsingDiagnostics(): readonly Diagnostic[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Get the syntax diagnostics, for all source files if source file is not supplied</span>
         <span class="s0">*/</span>
        <span class="s1">getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Get the declaration diagnostics, for all source files if source file is not supplied</span>
         <span class="s0">*/</span>
        <span class="s1">getDeclarationDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Get all the dependencies of the file</span>
         <span class="s0">*/</span>
        <span class="s1">getAllDependencies(sourceFile: SourceFile): readonly string[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets the semantic diagnostics from the program corresponding to this state of file (if provided) or whole program</span>
         <span class="s0">* The semantic diagnostics are cached and managed here</span>
         <span class="s0">* Note that it is assumed that when asked about semantic diagnostics through this API,</span>
         <span class="s0">* the file has been taken out of affected files so it is safe to use cache or get from program and cache the diagnostics</span>
         <span class="s0">* In case of SemanticDiagnosticsBuilderProgram if the source file is not provided,</span>
         <span class="s0">* it will iterate through all the affected files, to ensure that cache stays valid and yet provide a way to get all semantic diagnostics</span>
         <span class="s0">*/</span>
        <span class="s1">getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Emits the JavaScript and declaration files.</span>
         <span class="s0">* When targetSource file is specified, emits the files corresponding to that source file,</span>
         <span class="s0">* otherwise for the whole program.</span>
         <span class="s0">* In case of EmitAndSemanticDiagnosticsBuilderProgram, when targetSourceFile is specified,</span>
         <span class="s0">* it is assumed that that file is handled from affected file list. If targetSourceFile is not specified,</span>
         <span class="s0">* it will only emit all the affected files instead of whole program</span>
         <span class="s0">*</span>
         <span class="s0">* The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host</span>
         <span class="s0">* in that order would be used to write the files</span>
         <span class="s0">*/</span>
        <span class="s1">emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult;</span>
        <span class="s0">/**</span>
         <span class="s0">* Get the current directory of the program</span>
         <span class="s0">*/</span>
        <span class="s1">getCurrentDirectory(): string;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* The builder that caches the semantic diagnostics for the program and handles the changed files and affected files</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">SemanticDiagnosticsBuilderProgram </span><span class="s2">extends </span><span class="s1">BuilderProgram {</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets the semantic diagnostics from the program for the next affected file and caches it</span>
         <span class="s0">* Returns undefined if the iteration is complete</span>
         <span class="s0">*/</span>
        <span class="s1">getSemanticDiagnosticsOfNextAffectedFile(cancellationToken?: CancellationToken, ignoreSourceFile?: (sourceFile: SourceFile) =&gt; boolean): AffectedFileResult&lt;readonly Diagnostic[]&gt;;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* The builder that can handle the changes in program and iterate through changed file to emit the files</span>
     <span class="s0">* The semantic diagnostics are cached per file and managed by clearing for the changed/affected files</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">EmitAndSemanticDiagnosticsBuilderProgram </span><span class="s2">extends </span><span class="s1">SemanticDiagnosticsBuilderProgram {</span>
        <span class="s0">/**</span>
         <span class="s0">* Emits the next affected file's emit result (EmitResult and sourceFiles emitted) or returns undefined if iteration is complete</span>
         <span class="s0">* The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host</span>
         <span class="s0">* in that order would be used to write the files</span>
         <span class="s0">*/</span>
        <span class="s1">emitNextAffectedFile(writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): AffectedFileResult&lt;EmitResult&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">readBuilderProgram(compilerOptions: CompilerOptions, host: ReadBuildProgramHost): EmitAndSemanticDiagnosticsBuilderProgram | undefined;</span>
    <span class="s2">function </span><span class="s1">createIncrementalCompilerHost(options: CompilerOptions, system?: System): CompilerHost;</span>
    <span class="s2">function </span><span class="s1">createIncrementalProgram&lt;T </span><span class="s2">extends </span><span class="s1">BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram&gt;({ rootNames, options, configFileParsingDiagnostics, projectReferences, host, createProgram }: IncrementalProgramOptions&lt;T&gt;): T;</span>
    <span class="s0">/**</span>
     <span class="s0">* Create the watch compiler host for either configFile or fileNames and its options</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">createWatchCompilerHost&lt;T </span><span class="s2">extends </span><span class="s1">BuilderProgram&gt;(configFileName: string, optionsToExtend: CompilerOptions | undefined, system: System, createProgram?: CreateProgram&lt;T&gt;, reportDiagnostic?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter, watchOptionsToExtend?: WatchOptions, extraFileExtensions?: readonly FileExtensionInfo[]): WatchCompilerHostOfConfigFile&lt;T&gt;;</span>
    <span class="s2">function </span><span class="s1">createWatchCompilerHost&lt;T </span><span class="s2">extends </span><span class="s1">BuilderProgram&gt;(rootFiles: string[], options: CompilerOptions, system: System, createProgram?: CreateProgram&lt;T&gt;, reportDiagnostic?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter, projectReferences?: readonly ProjectReference[], watchOptions?: WatchOptions): WatchCompilerHostOfFilesAndCompilerOptions&lt;T&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates the watch from the host for root files and compiler options</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">createWatchProgram&lt;T </span><span class="s2">extends </span><span class="s1">BuilderProgram&gt;(host: WatchCompilerHostOfFilesAndCompilerOptions&lt;T&gt;): WatchOfFilesAndCompilerOptions&lt;T&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates the watch from the host for config file</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">createWatchProgram&lt;T </span><span class="s2">extends </span><span class="s1">BuilderProgram&gt;(host: WatchCompilerHostOfConfigFile&lt;T&gt;): WatchOfConfigFile&lt;T&gt;;</span>
    <span class="s2">interface </span><span class="s1">ReadBuildProgramHost {</span>
        <span class="s1">useCaseSensitiveFileNames(): boolean;</span>
        <span class="s1">getCurrentDirectory(): string;</span>
        <span class="s1">readFile(fileName: string): string | undefined;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">IncrementalProgramOptions&lt;T </span><span class="s2">extends </span><span class="s1">BuilderProgram&gt; {</span>
        <span class="s1">rootNames: readonly string[];</span>
        <span class="s1">options: CompilerOptions;</span>
        <span class="s1">configFileParsingDiagnostics?: readonly Diagnostic[];</span>
        <span class="s1">projectReferences?: readonly ProjectReference[];</span>
        <span class="s1">host?: CompilerHost;</span>
        <span class="s1">createProgram?: CreateProgram&lt;T&gt;;</span>
    <span class="s1">}</span>
    <span class="s1">type WatchStatusReporter = (diagnostic: Diagnostic, newLine: string, options: CompilerOptions, errorCount?: number) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s0">/** Create the program with rootNames and options, if they are undefined, oldProgram and new configFile diagnostics create new program */</span>
    <span class="s1">type CreateProgram&lt;T </span><span class="s2">extends </span><span class="s1">BuilderProgram&gt; = (rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: T, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[] | undefined) =&gt; T;</span>
    <span class="s0">/** Host that has watch functionality used in --watch mode */</span>
    <span class="s2">interface </span><span class="s1">WatchHost {</span>
        <span class="s0">/** If provided, called with Diagnostic message that informs about change in watch status */</span>
        <span class="s1">onWatchStatusChange?(diagnostic: Diagnostic, newLine: string, options: CompilerOptions, errorCount?: number): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s0">/** Used to watch changes in source files, missing files needed to update the program or config file */</span>
        <span class="s1">watchFile(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: WatchOptions): FileWatcher;</span>
        <span class="s0">/** Used to watch resolved module's failed lookup locations, config file specs, type roots where auto type reference directives are added */</span>
        <span class="s1">watchDirectory(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: WatchOptions): FileWatcher;</span>
        <span class="s0">/** If provided, will be used to set delayed compilation, so that multiple changes in short span are compiled together */</span>
        <span class="s1">setTimeout?(callback: (...args: any[]) =&gt; </span><span class="s2">void</span><span class="s1">, ms: number, ...args: any[]): any;</span>
        <span class="s0">/** If provided, will be used to reset existing delayed compilation */</span>
        <span class="s1">clearTimeout?(timeoutId: any): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">preferNonRecursiveWatch?: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ProgramHost&lt;T </span><span class="s2">extends </span><span class="s1">BuilderProgram&gt; {</span>
        <span class="s0">/**</span>
         <span class="s0">* Used to create the program when need for program creation or recreation detected</span>
         <span class="s0">*/</span>
        <span class="s1">createProgram: CreateProgram&lt;T&gt;;</span>
        <span class="s1">useCaseSensitiveFileNames(): boolean;</span>
        <span class="s1">getNewLine(): string;</span>
        <span class="s1">getCurrentDirectory(): string;</span>
        <span class="s1">getDefaultLibFileName(options: CompilerOptions): string;</span>
        <span class="s1">getDefaultLibLocation?(): string;</span>
        <span class="s1">createHash?(data: string): string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Use to check file presence for source files and</span>
         <span class="s0">* if resolveModuleNames is not provided (complier is in charge of module resolution) then module files as well</span>
         <span class="s0">*/</span>
        <span class="s1">fileExists(path: string): boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Use to read file text for source files and</span>
         <span class="s0">* if resolveModuleNames is not provided (complier is in charge of module resolution) then module files as well</span>
         <span class="s0">*/</span>
        <span class="s1">readFile(path: string, encoding?: string): string | undefined;</span>
        <span class="s0">/** If provided, used for module resolution as well as to handle directory structure */</span>
        <span class="s1">directoryExists?(path: string): boolean;</span>
        <span class="s0">/** If provided, used in resolutions as well as handling directory structure */</span>
        <span class="s1">getDirectories?(path: string): string[];</span>
        <span class="s0">/** If provided, used to cache and handle directory structure modifications */</span>
        <span class="s1">readDirectory?(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];</span>
        <span class="s0">/** Symbol links resolution */</span>
        <span class="s1">realpath?(path: string): string;</span>
        <span class="s0">/** If provided would be used to write log about compilation */</span>
        <span class="s1">trace?(s: string): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s0">/** If provided is used to get the environment variable */</span>
        <span class="s1">getEnvironmentVariable?(name: string): string | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s4">@deprecated </span><span class="s0">supply resolveModuleNameLiterals instead for resolution that can handle newer resolution modes like nodenext</span>
         <span class="s0">*</span>
         <span class="s0">* If provided, used to resolve the module names, otherwise typescript's default module resolution</span>
         <span class="s0">*/</span>
        <span class="s1">resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile?: SourceFile): (ResolvedModule | undefined)[];</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s4">@deprecated </span><span class="s0">supply resolveTypeReferenceDirectiveReferences instead for resolution that can handle newer resolution modes like nodenext</span>
         <span class="s0">*</span>
         <span class="s0">* If provided, used to resolve type reference directives, otherwise typescript's default resolution</span>
         <span class="s0">*/</span>
        <span class="s1">resolveTypeReferenceDirectives?(typeReferenceDirectiveNames: string[] | readonly FileReference[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingFileMode?: ResolutionMode): (ResolvedTypeReferenceDirective | undefined)[];</span>
        <span class="s1">resolveModuleNameLiterals?(moduleLiterals: readonly StringLiteralLike[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile, reusedNames: readonly StringLiteralLike[] | undefined): readonly ResolvedModuleWithFailedLookupLocations[];</span>
        <span class="s1">resolveTypeReferenceDirectiveReferences?&lt;T </span><span class="s2">extends </span><span class="s1">FileReference | string&gt;(typeDirectiveReferences: readonly T[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile | undefined, reusedNames: readonly T[] | undefined): readonly ResolvedTypeReferenceDirectiveWithFailedLookupLocations[];</span>
        <span class="s0">/** If provided along with custom resolveModuleNames or resolveTypeReferenceDirectives, used to determine if unchanged file path needs to re-resolve modules/type reference directives */</span>
        <span class="s1">hasInvalidatedResolutions?(filePath: Path): boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns the module resolution cache used by a provided `resolveModuleNames` implementation so that any non-name module resolution operations (eg, package.json lookup) can reuse it</span>
         <span class="s0">*/</span>
        <span class="s1">getModuleResolutionCache?(): ModuleResolutionCache | undefined;</span>
        <span class="s1">jsDocParsingMode?: JSDocParsingMode;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">WatchCompilerHost&lt;T </span><span class="s2">extends </span><span class="s1">BuilderProgram&gt; </span><span class="s2">extends </span><span class="s1">ProgramHost&lt;T&gt;, WatchHost {</span>
        <span class="s0">/** Instead of using output d.ts file from project reference, use its source file */</span>
        <span class="s1">useSourceOfProjectReferenceRedirect?(): boolean;</span>
        <span class="s0">/** If provided, use this method to get parsed command lines for referenced projects */</span>
        <span class="s1">getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;</span>
        <span class="s0">/** If provided, callback to invoke after every new program creation */</span>
        <span class="s1">afterProgramCreate?(program: T): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Host to create watch with root files and options</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">WatchCompilerHostOfFilesAndCompilerOptions&lt;T </span><span class="s2">extends </span><span class="s1">BuilderProgram&gt; </span><span class="s2">extends </span><span class="s1">WatchCompilerHost&lt;T&gt; {</span>
        <span class="s0">/** root files to use to generate program */</span>
        <span class="s1">rootFiles: string[];</span>
        <span class="s0">/** Compiler options */</span>
        <span class="s1">options: CompilerOptions;</span>
        <span class="s1">watchOptions?: WatchOptions;</span>
        <span class="s0">/** Project References */</span>
        <span class="s1">projectReferences?: readonly ProjectReference[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Host to create watch with config file</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">WatchCompilerHostOfConfigFile&lt;T </span><span class="s2">extends </span><span class="s1">BuilderProgram&gt; </span><span class="s2">extends </span><span class="s1">WatchCompilerHost&lt;T&gt;, ConfigFileDiagnosticsReporter {</span>
        <span class="s0">/** Name of the config file to compile */</span>
        <span class="s1">configFileName: string;</span>
        <span class="s0">/** Options to extend */</span>
        <span class="s1">optionsToExtend?: CompilerOptions;</span>
        <span class="s1">watchOptionsToExtend?: WatchOptions;</span>
        <span class="s1">extraFileExtensions?: readonly FileExtensionInfo[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Used to generate source file names from the config file and its include, exclude, files rules</span>
         <span class="s0">* and also to cache the directory stucture</span>
         <span class="s0">*/</span>
        <span class="s1">readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">Watch&lt;T&gt; {</span>
        <span class="s0">/** Synchronize with host and get updated program */</span>
        <span class="s1">getProgram(): T;</span>
        <span class="s0">/** Closes the watch */</span>
        <span class="s1">close(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates the watch what generates program using the config file</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">WatchOfConfigFile&lt;T&gt; </span><span class="s2">extends </span><span class="s1">Watch&lt;T&gt; {</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates the watch that generates program using the root files and compiler options</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">WatchOfFilesAndCompilerOptions&lt;T&gt; </span><span class="s2">extends </span><span class="s1">Watch&lt;T&gt; {</span>
        <span class="s0">/** Updates the root files in the program, only if this is not config file compilation */</span>
        <span class="s1">updateRootFileNames(fileNames: string[]): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Create a function that reports watch status by writing to the system and handles the formating of the diagnostic</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">createBuilderStatusReporter(system: System, pretty?: boolean): DiagnosticReporter;</span>
    <span class="s2">function </span><span class="s1">createSolutionBuilderHost&lt;T </span><span class="s2">extends </span><span class="s1">BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram&gt;(system?: System, createProgram?: CreateProgram&lt;T&gt;, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportErrorSummary?: ReportEmitErrorSummary): SolutionBuilderHost&lt;T&gt;;</span>
    <span class="s2">function </span><span class="s1">createSolutionBuilderWithWatchHost&lt;T </span><span class="s2">extends </span><span class="s1">BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram&gt;(system?: System, createProgram?: CreateProgram&lt;T&gt;, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter): SolutionBuilderWithWatchHost&lt;T&gt;;</span>
    <span class="s2">function </span><span class="s1">createSolutionBuilder&lt;T </span><span class="s2">extends </span><span class="s1">BuilderProgram&gt;(host: SolutionBuilderHost&lt;T&gt;, rootNames: readonly string[], defaultOptions: BuildOptions): SolutionBuilder&lt;T&gt;;</span>
    <span class="s2">function </span><span class="s1">createSolutionBuilderWithWatch&lt;T </span><span class="s2">extends </span><span class="s1">BuilderProgram&gt;(host: SolutionBuilderWithWatchHost&lt;T&gt;, rootNames: readonly string[], defaultOptions: BuildOptions, baseWatchOptions?: WatchOptions): SolutionBuilder&lt;T&gt;;</span>
    <span class="s2">interface </span><span class="s1">BuildOptions {</span>
        <span class="s1">dry?: boolean;</span>
        <span class="s1">force?: boolean;</span>
        <span class="s1">verbose?: boolean;</span>
        <span class="s1">stopBuildOnErrors?: boolean;</span>
        <span class="s1">incremental?: boolean;</span>
        <span class="s1">assumeChangesOnlyAffectDirectDependencies?: boolean;</span>
        <span class="s1">declaration?: boolean;</span>
        <span class="s1">declarationMap?: boolean;</span>
        <span class="s1">emitDeclarationOnly?: boolean;</span>
        <span class="s1">sourceMap?: boolean;</span>
        <span class="s1">inlineSourceMap?: boolean;</span>
        <span class="s1">traceResolution?: boolean;</span>
        <span class="s1">[option: string]: CompilerOptionsValue | undefined;</span>
    <span class="s1">}</span>
    <span class="s1">type ReportEmitErrorSummary = (errorCount: number, filesInError: (ReportFileInError | undefined)[]) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s1">ReportFileInError {</span>
        <span class="s1">fileName: string;</span>
        <span class="s1">line: number;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SolutionBuilderHostBase&lt;T </span><span class="s2">extends </span><span class="s1">BuilderProgram&gt; </span><span class="s2">extends </span><span class="s1">ProgramHost&lt;T&gt; {</span>
        <span class="s1">createDirectory?(path: string): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Should provide create directory and writeFile if done of invalidatedProjects is not invoked with</span>
         <span class="s0">* writeFileCallback</span>
         <span class="s0">*/</span>
        <span class="s1">writeFile?(path: string, data: string, writeByteOrderMark?: boolean): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">getCustomTransformers?: (project: string) =&gt; CustomTransformers | undefined;</span>
        <span class="s1">getModifiedTime(fileName: string): Date | undefined;</span>
        <span class="s1">setModifiedTime(fileName: string, date: Date): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">deleteFile(fileName: string): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;</span>
        <span class="s1">reportDiagnostic: DiagnosticReporter;</span>
        <span class="s1">reportSolutionBuilderStatus: DiagnosticReporter;</span>
        <span class="s1">afterProgramEmitAndDiagnostics?(program: T): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SolutionBuilderHost&lt;T </span><span class="s2">extends </span><span class="s1">BuilderProgram&gt; </span><span class="s2">extends </span><span class="s1">SolutionBuilderHostBase&lt;T&gt; {</span>
        <span class="s1">reportErrorSummary?: ReportEmitErrorSummary;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SolutionBuilderWithWatchHost&lt;T </span><span class="s2">extends </span><span class="s1">BuilderProgram&gt; </span><span class="s2">extends </span><span class="s1">SolutionBuilderHostBase&lt;T&gt;, WatchHost {</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SolutionBuilder&lt;T </span><span class="s2">extends </span><span class="s1">BuilderProgram&gt; {</span>
        <span class="s1">build(project?: string, cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, getCustomTransformers?: (project: string) =&gt; CustomTransformers): ExitStatus;</span>
        <span class="s1">clean(project?: string): ExitStatus;</span>
        <span class="s1">buildReferences(project: string, cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, getCustomTransformers?: (project: string) =&gt; CustomTransformers): ExitStatus;</span>
        <span class="s1">cleanReferences(project?: string): ExitStatus;</span>
        <span class="s1">getNextInvalidatedProject(cancellationToken?: CancellationToken): InvalidatedProject&lt;T&gt; | undefined;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">InvalidatedProjectKind {</span>
        <span class="s1">Build = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">UpdateOutputFileStamps = </span><span class="s5">1</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">InvalidatedProjectBase {</span>
        <span class="s1">readonly kind: InvalidatedProjectKind;</span>
        <span class="s1">readonly project: ResolvedConfigFileName;</span>
        <span class="s0">/**</span>
         <span class="s0">*  To dispose this project and ensure that all the necessary actions are taken and state is updated accordingly</span>
         <span class="s0">*/</span>
        <span class="s1">done(cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, customTransformers?: CustomTransformers): ExitStatus;</span>
        <span class="s1">getCompilerOptions(): CompilerOptions;</span>
        <span class="s1">getCurrentDirectory(): string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">UpdateOutputFileStampsProject </span><span class="s2">extends </span><span class="s1">InvalidatedProjectBase {</span>
        <span class="s1">readonly kind: InvalidatedProjectKind.UpdateOutputFileStamps;</span>
        <span class="s1">updateOutputFileStatmps(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">BuildInvalidedProject&lt;T </span><span class="s2">extends </span><span class="s1">BuilderProgram&gt; </span><span class="s2">extends </span><span class="s1">InvalidatedProjectBase {</span>
        <span class="s1">readonly kind: InvalidatedProjectKind.Build;</span>
        <span class="s1">getBuilderProgram(): T | undefined;</span>
        <span class="s1">getProgram(): Program | undefined;</span>
        <span class="s1">getSourceFile(fileName: string): SourceFile | undefined;</span>
        <span class="s1">getSourceFiles(): readonly SourceFile[];</span>
        <span class="s1">getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];</span>
        <span class="s1">getGlobalDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];</span>
        <span class="s1">getConfigFileParsingDiagnostics(): readonly Diagnostic[];</span>
        <span class="s1">getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];</span>
        <span class="s1">getAllDependencies(sourceFile: SourceFile): readonly string[];</span>
        <span class="s1">getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];</span>
        <span class="s1">getSemanticDiagnosticsOfNextAffectedFile(cancellationToken?: CancellationToken, ignoreSourceFile?: (sourceFile: SourceFile) =&gt; boolean): AffectedFileResult&lt;readonly Diagnostic[]&gt;;</span>
        <span class="s1">emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult | undefined;</span>
    <span class="s1">}</span>
    <span class="s1">type InvalidatedProject&lt;T </span><span class="s2">extends </span><span class="s1">BuilderProgram&gt; = UpdateOutputFileStampsProject | BuildInvalidedProject&lt;T&gt;;</span>
    <span class="s0">/** Returns true if commandline is --build and needs to be parsed useing parseBuildCommand */</span>
    <span class="s2">function </span><span class="s1">isBuildCommand(commandLineArgs: readonly string[]): boolean;</span>
    <span class="s2">function </span><span class="s1">getDefaultFormatCodeSettings(newLineCharacter?: string): FormatCodeSettings;</span>
    <span class="s0">/**</span>
     <span class="s0">* Represents an immutable snapshot of a script at a specified time.Once acquired, the</span>
     <span class="s0">* snapshot is observably immutable. i.e. the same calls with the same parameters will return</span>
     <span class="s0">* the same values.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">IScriptSnapshot {</span>
        <span class="s0">/** Gets a portion of the script snapshot specified by [start, end). */</span>
        <span class="s1">getText(start: number, end: number): string;</span>
        <span class="s0">/** Gets the length of this script snapshot. */</span>
        <span class="s1">getLength(): number;</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets the TextChangeRange that describe how the text changed between this text and</span>
         <span class="s0">* an older version.  This information is used by the incremental parser to determine</span>
         <span class="s0">* what sections of the script need to be re-parsed.  'undefined' can be returned if the</span>
         <span class="s0">* change range cannot be determined.  However, in that case, incremental parsing will</span>
         <span class="s0">* not happen and the entire document will be re - parsed.</span>
         <span class="s0">*/</span>
        <span class="s1">getChangeRange(oldSnapshot: IScriptSnapshot): TextChangeRange | undefined;</span>
        <span class="s0">/** Releases all resources held by this script snapshot */</span>
        <span class="s1">dispose?(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">namespace ScriptSnapshot {</span>
        <span class="s2">function </span><span class="s1">fromString(text: string): IScriptSnapshot;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">PreProcessedFileInfo {</span>
        <span class="s1">referencedFiles: FileReference[];</span>
        <span class="s1">typeReferenceDirectives: FileReference[];</span>
        <span class="s1">libReferenceDirectives: FileReference[];</span>
        <span class="s1">importedFiles: FileReference[];</span>
        <span class="s1">ambientExternalModules?: string[];</span>
        <span class="s1">isLibFile: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">HostCancellationToken {</span>
        <span class="s1">isCancellationRequested(): boolean;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">InstallPackageOptions {</span>
        <span class="s1">fileName: Path;</span>
        <span class="s1">packageName: string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">PerformanceEvent {</span>
        <span class="s1">kind: </span><span class="s3">&quot;UpdateGraph&quot; </span><span class="s1">| </span><span class="s3">&quot;CreatePackageJsonAutoImportProvider&quot;</span><span class="s1">;</span>
        <span class="s1">durationMs: number;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">LanguageServiceMode {</span>
        <span class="s1">Semantic = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">PartialSemantic = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">Syntactic = </span><span class="s5">2</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">IncompleteCompletionsCache {</span>
        <span class="s1">get(): CompletionInfo | undefined;</span>
        <span class="s1">set(response: CompletionInfo): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">clear(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">LanguageServiceHost </span><span class="s2">extends </span><span class="s1">GetEffectiveTypeRootsHost, MinimalResolutionCacheHost {</span>
        <span class="s1">getCompilationSettings(): CompilerOptions;</span>
        <span class="s1">getNewLine?(): string;</span>
        <span class="s1">getProjectVersion?(): string;</span>
        <span class="s1">getScriptFileNames(): string[];</span>
        <span class="s1">getScriptKind?(fileName: string): ScriptKind;</span>
        <span class="s1">getScriptVersion(fileName: string): string;</span>
        <span class="s1">getScriptSnapshot(fileName: string): IScriptSnapshot | undefined;</span>
        <span class="s1">getProjectReferences?(): readonly ProjectReference[] | undefined;</span>
        <span class="s1">getLocalizedDiagnosticMessages?(): any;</span>
        <span class="s1">getCancellationToken?(): HostCancellationToken;</span>
        <span class="s1">getCurrentDirectory(): string;</span>
        <span class="s1">getDefaultLibFileName(options: CompilerOptions): string;</span>
        <span class="s1">log?(s: string): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">trace?(s: string): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">error?(s: string): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">useCaseSensitiveFileNames?(): boolean;</span>
        <span class="s1">readDirectory?(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];</span>
        <span class="s1">realpath?(path: string): string;</span>
        <span class="s1">readFile(path: string, encoding?: string): string | undefined;</span>
        <span class="s1">fileExists(path: string): boolean;</span>
        <span class="s1">getTypeRootsVersion?(): number;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">supply resolveModuleNameLiterals instead for resolution that can handle newer resolution modes like nodenext */</span>
        <span class="s1">resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile?: SourceFile): (ResolvedModule | undefined)[];</span>
        <span class="s1">getResolvedModuleWithFailedLookupLocationsFromCache?(modulename: string, containingFile: string, resolutionMode?: ResolutionMode): ResolvedModuleWithFailedLookupLocations | undefined;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">supply resolveTypeReferenceDirectiveReferences instead for resolution that can handle newer resolution modes like nodenext */</span>
        <span class="s1">resolveTypeReferenceDirectives?(typeDirectiveNames: string[] | FileReference[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingFileMode?: ResolutionMode): (ResolvedTypeReferenceDirective | undefined)[];</span>
        <span class="s1">resolveModuleNameLiterals?(moduleLiterals: readonly StringLiteralLike[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile, reusedNames: readonly StringLiteralLike[] | undefined): readonly ResolvedModuleWithFailedLookupLocations[];</span>
        <span class="s1">resolveTypeReferenceDirectiveReferences?&lt;T </span><span class="s2">extends </span><span class="s1">FileReference | string&gt;(typeDirectiveReferences: readonly T[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile | undefined, reusedNames: readonly T[] | undefined): readonly ResolvedTypeReferenceDirectiveWithFailedLookupLocations[];</span>
        <span class="s1">getDirectories?(directoryName: string): string[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets a set of custom transformers to use during emit.</span>
         <span class="s0">*/</span>
        <span class="s1">getCustomTransformers?(): CustomTransformers | undefined;</span>
        <span class="s1">isKnownTypesPackageName?(name: string): boolean;</span>
        <span class="s1">installPackage?(options: InstallPackageOptions): Promise&lt;ApplyCodeActionCommandResult&gt;;</span>
        <span class="s1">writeFile?(fileName: string, content: string): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;</span>
        <span class="s1">jsDocParsingMode?: JSDocParsingMode | undefined;</span>
    <span class="s1">}</span>
    <span class="s1">type WithMetadata&lt;T&gt; = T &amp; {</span>
        <span class="s1">metadata?: unknown;</span>
    <span class="s1">};</span>
    <span class="s2">enum </span><span class="s1">SemanticClassificationFormat {</span>
        <span class="s1">Original = </span><span class="s3">&quot;original&quot;</span><span class="s1">,</span>
        <span class="s1">TwentyTwenty = </span><span class="s3">&quot;2020&quot;</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">LanguageService {</span>
        <span class="s0">/** This is used as a part of restarting the language service. */</span>
        <span class="s1">cleanupSemanticCache(): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets errors indicating invalid syntax in a file.</span>
         <span class="s0">*</span>
         <span class="s0">* In English, &quot;this cdeo have, erorrs&quot; is syntactically invalid because it has typos,</span>
         <span class="s0">* grammatical errors, and misplaced punctuation. Likewise, examples of syntax</span>
         <span class="s0">* errors in TypeScript are missing parentheses in an `if` statement, mismatched</span>
         <span class="s0">* curly braces, and using a reserved keyword as a variable name.</span>
         <span class="s0">*</span>
         <span class="s0">* These diagnostics are inexpensive to compute and don't require knowledge of</span>
         <span class="s0">* other files. Note that a non-empty result increases the likelihood of false positives</span>
         <span class="s0">* from `getSemanticDiagnostics`.</span>
         <span class="s0">*</span>
         <span class="s0">* While these represent the majority of syntax-related diagnostics, there are some</span>
         <span class="s0">* that require the type system, which will be present in `getSemanticDiagnostics`.</span>
         <span class="s0">*</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">fileName A path to the file you want syntactic diagnostics for</span>
         <span class="s0">*/</span>
        <span class="s1">getSyntacticDiagnostics(fileName: string): DiagnosticWithLocation[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets warnings or errors indicating type system issues in a given file.</span>
         <span class="s0">* Requesting semantic diagnostics may start up the type system and</span>
         <span class="s0">* run deferred work, so the first call may take longer than subsequent calls.</span>
         <span class="s0">*</span>
         <span class="s0">* Unlike the other get*Diagnostics functions, these diagnostics can potentially not</span>
         <span class="s0">* include a reference to a source file. Specifically, the first time this is called,</span>
         <span class="s0">* it will return global diagnostics with no associated location.</span>
         <span class="s0">*</span>
         <span class="s0">* To contrast the differences between semantic and syntactic diagnostics, consider the</span>
         <span class="s0">* sentence: &quot;The sun is green.&quot; is syntactically correct; those are real English words with</span>
         <span class="s0">* correct sentence structure. However, it is semantically invalid, because it is not true.</span>
         <span class="s0">*</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">fileName A path to the file you want semantic diagnostics for</span>
         <span class="s0">*/</span>
        <span class="s1">getSemanticDiagnostics(fileName: string): Diagnostic[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets suggestion diagnostics for a specific file. These diagnostics tend to</span>
         <span class="s0">* proactively suggest refactors, as opposed to diagnostics that indicate</span>
         <span class="s0">* potentially incorrect runtime behavior.</span>
         <span class="s0">*</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">fileName A path to the file you want semantic diagnostics for</span>
         <span class="s0">*/</span>
        <span class="s1">getSuggestionDiagnostics(fileName: string): DiagnosticWithLocation[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets global diagnostics related to the program configuration and compiler options.</span>
         <span class="s0">*/</span>
        <span class="s1">getCompilerOptionsDiagnostics(): Diagnostic[];</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">Use getEncodedSyntacticClassifications instead. */</span>
        <span class="s1">getSyntacticClassifications(fileName: string, span: TextSpan): ClassifiedSpan[];</span>
        <span class="s1">getSyntacticClassifications(fileName: string, span: TextSpan, format: SemanticClassificationFormat): ClassifiedSpan[] | ClassifiedSpan2020[];</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">Use getEncodedSemanticClassifications instead. */</span>
        <span class="s1">getSemanticClassifications(fileName: string, span: TextSpan): ClassifiedSpan[];</span>
        <span class="s1">getSemanticClassifications(fileName: string, span: TextSpan, format: SemanticClassificationFormat): ClassifiedSpan[] | ClassifiedSpan2020[];</span>
        <span class="s0">/** Encoded as triples of [start, length, ClassificationType]. */</span>
        <span class="s1">getEncodedSyntacticClassifications(fileName: string, span: TextSpan): Classifications;</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets semantic highlights information for a particular file. Has two formats, an older</span>
         <span class="s0">* version used by VS and a format used by VS Code.</span>
         <span class="s0">*</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">fileName The path to the file</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">position A text span to return results within</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">format Which format to use, defaults to &quot;original&quot;</span>
         <span class="s0">* </span><span class="s4">@returns </span><span class="s0">a number array encoded as triples of [start, length, ClassificationType, ...].</span>
         <span class="s0">*/</span>
        <span class="s1">getEncodedSemanticClassifications(fileName: string, span: TextSpan, format?: SemanticClassificationFormat): Classifications;</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets completion entries at a particular position in a file.</span>
         <span class="s0">*</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">fileName The path to the file</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">position A zero-based index of the character where you want the entries</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">options An object describing how the request was triggered and what kinds</span>
         <span class="s0">* of code actions can be returned with the completions.</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">formattingSettings settings needed for calling formatting functions.</span>
         <span class="s0">*/</span>
        <span class="s1">getCompletionsAtPosition(fileName: string, position: number, options: GetCompletionsAtPositionOptions | undefined, formattingSettings?: FormatCodeSettings): WithMetadata&lt;CompletionInfo&gt; | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets the extended details for a completion entry retrieved from `getCompletionsAtPosition`.</span>
         <span class="s0">*</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">fileName The path to the file</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">position A zero based index of the character where you want the entries</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">entryName The `name` from an existing completion which came from `getCompletionsAtPosition`</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">formatOptions How should code samples in the completions be formatted, can be undefined for backwards compatibility</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">source `source` property from the completion entry</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">preferences User settings, can be undefined for backwards compatibility</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">data `data` property from the completion entry</span>
         <span class="s0">*/</span>
        <span class="s1">getCompletionEntryDetails(fileName: string, position: number, entryName: string, formatOptions: FormatCodeOptions | FormatCodeSettings | undefined, source: string | undefined, preferences: UserPreferences | undefined, data: CompletionEntryData | undefined): CompletionEntryDetails | undefined;</span>
        <span class="s1">getCompletionEntrySymbol(fileName: string, position: number, name: string, source: string | undefined): Symbol | undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets semantic information about the identifier at a particular position in a</span>
         <span class="s0">* file. Quick info is what you typically see when you hover in an editor.</span>
         <span class="s0">*</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">fileName The path to the file</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">position A zero-based index of the character where you want the quick info</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">maximumLength Maximum length of a quickinfo text before it is truncated.</span>
         <span class="s0">*/</span>
        <span class="s1">getQuickInfoAtPosition(fileName: string, position: number, maximumLength?: number): QuickInfo | undefined;</span>
        <span class="s1">getNameOrDottedNameSpan(fileName: string, startPos: number, endPos: number): TextSpan | undefined;</span>
        <span class="s1">getBreakpointStatementAtPosition(fileName: string, position: number): TextSpan | undefined;</span>
        <span class="s1">getSignatureHelpItems(fileName: string, position: number, options: SignatureHelpItemsOptions | undefined): SignatureHelpItems | undefined;</span>
        <span class="s1">getRenameInfo(fileName: string, position: number, preferences: UserPreferences): RenameInfo;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">Use the signature with `UserPreferences` instead. */</span>
        <span class="s1">getRenameInfo(fileName: string, position: number, options?: RenameInfoOptions): RenameInfo;</span>
        <span class="s1">findRenameLocations(fileName: string, position: number, findInStrings: boolean, findInComments: boolean, preferences: UserPreferences): readonly RenameLocation[] | undefined;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">Pass `providePrefixAndSuffixTextForRename` as part of a `UserPreferences` parameter. */</span>
        <span class="s1">findRenameLocations(fileName: string, position: number, findInStrings: boolean, findInComments: boolean, providePrefixAndSuffixTextForRename?: boolean): readonly RenameLocation[] | undefined;</span>
        <span class="s1">getSmartSelectionRange(fileName: string, position: number): SelectionRange;</span>
        <span class="s1">getDefinitionAtPosition(fileName: string, position: number): readonly DefinitionInfo[] | undefined;</span>
        <span class="s1">getDefinitionAndBoundSpan(fileName: string, position: number): DefinitionInfoAndBoundSpan | undefined;</span>
        <span class="s1">getTypeDefinitionAtPosition(fileName: string, position: number): readonly DefinitionInfo[] | undefined;</span>
        <span class="s1">getImplementationAtPosition(fileName: string, position: number): readonly ImplementationLocation[] | undefined;</span>
        <span class="s1">getReferencesAtPosition(fileName: string, position: number): ReferenceEntry[] | undefined;</span>
        <span class="s1">findReferences(fileName: string, position: number): ReferencedSymbol[] | undefined;</span>
        <span class="s1">getDocumentHighlights(fileName: string, position: number, filesToSearch: string[]): DocumentHighlights[] | undefined;</span>
        <span class="s1">getFileReferences(fileName: string): ReferenceEntry[];</span>
        <span class="s1">getNavigateToItems(searchValue: string, maxResultCount?: number, fileName?: string, excludeDtsFiles?: boolean, excludeLibFiles?: boolean): NavigateToItem[];</span>
        <span class="s1">getNavigationBarItems(fileName: string): NavigationBarItem[];</span>
        <span class="s1">getNavigationTree(fileName: string): NavigationTree;</span>
        <span class="s1">prepareCallHierarchy(fileName: string, position: number): CallHierarchyItem | CallHierarchyItem[] | undefined;</span>
        <span class="s1">provideCallHierarchyIncomingCalls(fileName: string, position: number): CallHierarchyIncomingCall[];</span>
        <span class="s1">provideCallHierarchyOutgoingCalls(fileName: string, position: number): CallHierarchyOutgoingCall[];</span>
        <span class="s1">provideInlayHints(fileName: string, span: TextSpan, preferences: UserPreferences | undefined): InlayHint[];</span>
        <span class="s1">getOutliningSpans(fileName: string): OutliningSpan[];</span>
        <span class="s1">getTodoComments(fileName: string, descriptors: TodoCommentDescriptor[]): TodoComment[];</span>
        <span class="s1">getBraceMatchingAtPosition(fileName: string, position: number): TextSpan[];</span>
        <span class="s1">getIndentationAtPosition(fileName: string, position: number, options: EditorOptions | EditorSettings): number;</span>
        <span class="s1">getFormattingEditsForRange(fileName: string, start: number, end: number, options: FormatCodeOptions | FormatCodeSettings): TextChange[];</span>
        <span class="s1">getFormattingEditsForDocument(fileName: string, options: FormatCodeOptions | FormatCodeSettings): TextChange[];</span>
        <span class="s1">getFormattingEditsAfterKeystroke(fileName: string, position: number, key: string, options: FormatCodeOptions | FormatCodeSettings): TextChange[];</span>
        <span class="s1">getDocCommentTemplateAtPosition(fileName: string, position: number, options?: DocCommentTemplateOptions, formatOptions?: FormatCodeSettings): TextInsertion | undefined;</span>
        <span class="s1">isValidBraceCompletionAtPosition(fileName: string, position: number, openingBrace: number): boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* This will return a defined result if the position is after the `&gt;` of the opening tag, or somewhere in the text, of a JSXElement with no closing tag.</span>
         <span class="s0">* Editors should call this after `&gt;` is typed.</span>
         <span class="s0">*/</span>
        <span class="s1">getJsxClosingTagAtPosition(fileName: string, position: number): JsxClosingTagInfo | undefined;</span>
        <span class="s1">getLinkedEditingRangeAtPosition(fileName: string, position: number): LinkedEditingInfo | undefined;</span>
        <span class="s1">getSpanOfEnclosingComment(fileName: string, position: number, onlyMultiLine: boolean): TextSpan | undefined;</span>
        <span class="s1">toLineColumnOffset?(fileName: string, position: number): LineAndCharacter;</span>
        <span class="s1">getCodeFixesAtPosition(fileName: string, start: number, end: number, errorCodes: readonly number[], formatOptions: FormatCodeSettings, preferences: UserPreferences): readonly CodeFixAction[];</span>
        <span class="s1">getCombinedCodeFix(scope: CombinedCodeFixScope, fixId: {}, formatOptions: FormatCodeSettings, preferences: UserPreferences): CombinedCodeActions;</span>
        <span class="s1">applyCodeActionCommand(action: CodeActionCommand, formatSettings?: FormatCodeSettings): Promise&lt;ApplyCodeActionCommandResult&gt;;</span>
        <span class="s1">applyCodeActionCommand(action: CodeActionCommand[], formatSettings?: FormatCodeSettings): Promise&lt;ApplyCodeActionCommandResult[]&gt;;</span>
        <span class="s1">applyCodeActionCommand(action: CodeActionCommand | CodeActionCommand[], formatSettings?: FormatCodeSettings): Promise&lt;ApplyCodeActionCommandResult | ApplyCodeActionCommandResult[]&gt;;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">`fileName` will be ignored */</span>
        <span class="s1">applyCodeActionCommand(fileName: string, action: CodeActionCommand): Promise&lt;ApplyCodeActionCommandResult&gt;;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">`fileName` will be ignored */</span>
        <span class="s1">applyCodeActionCommand(fileName: string, action: CodeActionCommand[]): Promise&lt;ApplyCodeActionCommandResult[]&gt;;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">`fileName` will be ignored */</span>
        <span class="s1">applyCodeActionCommand(fileName: string, action: CodeActionCommand | CodeActionCommand[]): Promise&lt;ApplyCodeActionCommandResult | ApplyCodeActionCommandResult[]&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">includeInteractiveActions Include refactor actions that require additional arguments to be</span>
         <span class="s0">* passed when calling `getEditsForRefactor`. When true, clients should inspect the `isInteractive`</span>
         <span class="s0">* property of each returned `RefactorActionInfo` and ensure they are able to collect the appropriate</span>
         <span class="s0">* arguments for any interactive action before offering it.</span>
         <span class="s0">*/</span>
        <span class="s1">getApplicableRefactors(fileName: string, positionOrRange: number | TextRange, preferences: UserPreferences | undefined, triggerReason?: RefactorTriggerReason, kind?: string, includeInteractiveActions?: boolean): ApplicableRefactorInfo[];</span>
        <span class="s1">getEditsForRefactor(fileName: string, formatOptions: FormatCodeSettings, positionOrRange: number | TextRange, refactorName: string, actionName: string, preferences: UserPreferences | undefined, interactiveRefactorArguments?: InteractiveRefactorArguments): RefactorEditInfo | undefined;</span>
        <span class="s1">getMoveToRefactoringFileSuggestions(fileName: string, positionOrRange: number | TextRange, preferences: UserPreferences | undefined, triggerReason?: RefactorTriggerReason, kind?: string): {</span>
            <span class="s1">newFileName: string;</span>
            <span class="s1">files: string[];</span>
        <span class="s1">};</span>
        <span class="s1">organizeImports(args: OrganizeImportsArgs, formatOptions: FormatCodeSettings, preferences: UserPreferences | undefined): readonly FileTextChanges[];</span>
        <span class="s1">getEditsForFileRename(oldFilePath: string, newFilePath: string, formatOptions: FormatCodeSettings, preferences: UserPreferences | undefined): readonly FileTextChanges[];</span>
        <span class="s1">getEmitOutput(fileName: string, emitOnlyDtsFiles?: boolean, forceDtsEmit?: boolean): EmitOutput;</span>
        <span class="s1">getProgram(): Program | undefined;</span>
        <span class="s1">toggleLineComment(fileName: string, textRange: TextRange): TextChange[];</span>
        <span class="s1">toggleMultilineComment(fileName: string, textRange: TextRange): TextChange[];</span>
        <span class="s1">commentSelection(fileName: string, textRange: TextRange): TextChange[];</span>
        <span class="s1">uncommentSelection(fileName: string, textRange: TextRange): TextChange[];</span>
        <span class="s1">getSupportedCodeFixes(fileName?: string): readonly string[];</span>
        <span class="s1">dispose(): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">preparePasteEditsForFile(fileName: string, copiedTextRanges: TextRange[]): boolean;</span>
        <span class="s1">getPasteEdits(args: PasteEditsArgs, formatOptions: FormatCodeSettings): PasteEdits;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JsxClosingTagInfo {</span>
        <span class="s1">readonly newText: string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">LinkedEditingInfo {</span>
        <span class="s1">readonly ranges: TextSpan[];</span>
        <span class="s1">wordPattern?: string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">CombinedCodeFixScope {</span>
        <span class="s1">type: </span><span class="s3">&quot;file&quot;</span><span class="s1">;</span>
        <span class="s1">fileName: string;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">OrganizeImportsMode {</span>
        <span class="s1">All = </span><span class="s3">&quot;All&quot;</span><span class="s1">,</span>
        <span class="s1">SortAndCombine = </span><span class="s3">&quot;SortAndCombine&quot;</span><span class="s1">,</span>
        <span class="s1">RemoveUnused = </span><span class="s3">&quot;RemoveUnused&quot;</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">PasteEdits {</span>
        <span class="s1">edits: readonly FileTextChanges[];</span>
        <span class="s1">fixId?: {};</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">PasteEditsArgs {</span>
        <span class="s1">targetFile: string;</span>
        <span class="s1">pastedText: string[];</span>
        <span class="s1">pasteLocations: TextRange[];</span>
        <span class="s1">copiedFrom: {</span>
            <span class="s1">file: string;</span>
            <span class="s1">range: TextRange[];</span>
        <span class="s1">} | undefined;</span>
        <span class="s1">preferences: UserPreferences;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">OrganizeImportsArgs </span><span class="s2">extends </span><span class="s1">CombinedCodeFixScope {</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">Use `mode` instead */</span>
        <span class="s1">skipDestructiveCodeActions?: boolean;</span>
        <span class="s1">mode?: OrganizeImportsMode;</span>
    <span class="s1">}</span>
    <span class="s1">type CompletionsTriggerCharacter = </span><span class="s3">&quot;.&quot; </span><span class="s1">| </span><span class="s3">'&quot;' </span><span class="s1">| </span><span class="s3">&quot;'&quot; </span><span class="s1">| </span><span class="s3">&quot;`&quot; </span><span class="s1">| </span><span class="s3">&quot;/&quot; </span><span class="s1">| </span><span class="s3">&quot;@&quot; </span><span class="s1">| </span><span class="s3">&quot;&lt;&quot; </span><span class="s1">| </span><span class="s3">&quot;#&quot; </span><span class="s1">| </span><span class="s3">&quot; &quot;</span><span class="s1">;</span>
    <span class="s2">enum </span><span class="s1">CompletionTriggerKind {</span>
        <span class="s0">/** Completion was triggered by typing an identifier, manual invocation (e.g Ctrl+Space) or via API. */</span>
        <span class="s1">Invoked = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s0">/** Completion was triggered by a trigger character. */</span>
        <span class="s1">TriggerCharacter = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s0">/** Completion was re-triggered as the current completion list is incomplete. */</span>
        <span class="s1">TriggerForIncompleteCompletions = </span><span class="s5">3</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">GetCompletionsAtPositionOptions </span><span class="s2">extends </span><span class="s1">UserPreferences {</span>
        <span class="s0">/**</span>
         <span class="s0">* If the editor is asking for completions because a certain character was typed</span>
         <span class="s0">* (as opposed to when the user explicitly requested them) this should be set.</span>
         <span class="s0">*/</span>
        <span class="s1">triggerCharacter?: CompletionsTriggerCharacter;</span>
        <span class="s1">triggerKind?: CompletionTriggerKind;</span>
        <span class="s0">/**</span>
         <span class="s0">* Include a `symbol` property on each completion entry object.</span>
         <span class="s0">* Symbols reference cyclic data structures and sometimes an entire TypeChecker instance,</span>
         <span class="s0">* so use caution when serializing or retaining completion entries retrieved with this option.</span>
         <span class="s0">* </span><span class="s4">@default </span><span class="s0">false</span>
         <span class="s0">*/</span>
        <span class="s1">includeSymbol?: boolean;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">Use includeCompletionsForModuleExports */</span>
        <span class="s1">includeExternalModuleExports?: boolean;</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">Use includeCompletionsWithInsertText */</span>
        <span class="s1">includeInsertTextCompletions?: boolean;</span>
    <span class="s1">}</span>
    <span class="s1">type SignatureHelpTriggerCharacter = </span><span class="s3">&quot;,&quot; </span><span class="s1">| </span><span class="s3">&quot;(&quot; </span><span class="s1">| </span><span class="s3">&quot;&lt;&quot;</span><span class="s1">;</span>
    <span class="s1">type SignatureHelpRetriggerCharacter = SignatureHelpTriggerCharacter | </span><span class="s3">&quot;)&quot;</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s1">SignatureHelpItemsOptions {</span>
        <span class="s1">triggerReason?: SignatureHelpTriggerReason;</span>
    <span class="s1">}</span>
    <span class="s1">type SignatureHelpTriggerReason = SignatureHelpInvokedReason | SignatureHelpCharacterTypedReason | SignatureHelpRetriggeredReason;</span>
    <span class="s0">/**</span>
     <span class="s0">* Signals that the user manually requested signature help.</span>
     <span class="s0">* The language service will unconditionally attempt to provide a result.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">SignatureHelpInvokedReason {</span>
        <span class="s1">kind: </span><span class="s3">&quot;invoked&quot;</span><span class="s1">;</span>
        <span class="s1">triggerCharacter?: undefined;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Signals that the signature help request came from a user typing a character.</span>
     <span class="s0">* Depending on the character and the syntactic context, the request may or may not be served a result.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">SignatureHelpCharacterTypedReason {</span>
        <span class="s1">kind: </span><span class="s3">&quot;characterTyped&quot;</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Character that was responsible for triggering signature help.</span>
         <span class="s0">*/</span>
        <span class="s1">triggerCharacter: SignatureHelpTriggerCharacter;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Signals that this signature help request came from typing a character or moving the cursor.</span>
     <span class="s0">* This should only occur if a signature help session was already active and the editor needs to see if it should adjust.</span>
     <span class="s0">* The language service will unconditionally attempt to provide a result.</span>
     <span class="s0">* `triggerCharacter` can be `undefined` for a retrigger caused by a cursor move.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">SignatureHelpRetriggeredReason {</span>
        <span class="s1">kind: </span><span class="s3">&quot;retrigger&quot;</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Character that was responsible for triggering signature help.</span>
         <span class="s0">*/</span>
        <span class="s1">triggerCharacter?: SignatureHelpRetriggerCharacter;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ApplyCodeActionCommandResult {</span>
        <span class="s1">successMessage: string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">Classifications {</span>
        <span class="s1">spans: number[];</span>
        <span class="s1">endOfLineState: EndOfLineState;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ClassifiedSpan {</span>
        <span class="s1">textSpan: TextSpan;</span>
        <span class="s1">classificationType: ClassificationTypeNames;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ClassifiedSpan2020 {</span>
        <span class="s1">textSpan: TextSpan;</span>
        <span class="s1">classificationType: number;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Navigation bar interface designed for visual studio's dual-column layout.</span>
     <span class="s0">* This does not form a proper tree.</span>
     <span class="s0">* The navbar is returned as a list of top-level items, each of which has a list of child items.</span>
     <span class="s0">* Child items always have an empty array for their `childItems`.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">NavigationBarItem {</span>
        <span class="s1">text: string;</span>
        <span class="s1">kind: ScriptElementKind;</span>
        <span class="s1">kindModifiers: string;</span>
        <span class="s1">spans: TextSpan[];</span>
        <span class="s1">childItems: NavigationBarItem[];</span>
        <span class="s1">indent: number;</span>
        <span class="s1">bolded: boolean;</span>
        <span class="s1">grayed: boolean;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Node in a tree of nested declarations in a file.</span>
     <span class="s0">* The top node is always a script or module node.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">NavigationTree {</span>
        <span class="s0">/** Name of the declaration, or a short description, e.g. &quot;&lt;class&gt;&quot;. */</span>
        <span class="s1">text: string;</span>
        <span class="s1">kind: ScriptElementKind;</span>
        <span class="s0">/** ScriptElementKindModifier separated by commas, e.g. &quot;public,abstract&quot; */</span>
        <span class="s1">kindModifiers: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Spans of the nodes that generated this declaration.</span>
         <span class="s0">* There will be more than one if this is the result of merging.</span>
         <span class="s0">*/</span>
        <span class="s1">spans: TextSpan[];</span>
        <span class="s1">nameSpan: TextSpan | undefined;</span>
        <span class="s0">/** Present if non-empty */</span>
        <span class="s1">childItems?: NavigationTree[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">CallHierarchyItem {</span>
        <span class="s1">name: string;</span>
        <span class="s1">kind: ScriptElementKind;</span>
        <span class="s1">kindModifiers?: string;</span>
        <span class="s1">file: string;</span>
        <span class="s1">span: TextSpan;</span>
        <span class="s1">selectionSpan: TextSpan;</span>
        <span class="s1">containerName?: string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">CallHierarchyIncomingCall {</span>
        <span class="s1">from: CallHierarchyItem;</span>
        <span class="s1">fromSpans: TextSpan[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">CallHierarchyOutgoingCall {</span>
        <span class="s1">to: CallHierarchyItem;</span>
        <span class="s1">fromSpans: TextSpan[];</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">InlayHintKind {</span>
        <span class="s1">Type = </span><span class="s3">&quot;Type&quot;</span><span class="s1">,</span>
        <span class="s1">Parameter = </span><span class="s3">&quot;Parameter&quot;</span><span class="s1">,</span>
        <span class="s1">Enum = </span><span class="s3">&quot;Enum&quot;</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">InlayHint {</span>
        <span class="s0">/** This property will be the empty string when displayParts is set. */</span>
        <span class="s1">text: string;</span>
        <span class="s1">position: number;</span>
        <span class="s1">kind: InlayHintKind;</span>
        <span class="s1">whitespaceBefore?: boolean;</span>
        <span class="s1">whitespaceAfter?: boolean;</span>
        <span class="s1">displayParts?: InlayHintDisplayPart[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">InlayHintDisplayPart {</span>
        <span class="s1">text: string;</span>
        <span class="s1">span?: TextSpan;</span>
        <span class="s1">file?: string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TodoCommentDescriptor {</span>
        <span class="s1">text: string;</span>
        <span class="s1">priority: number;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TodoComment {</span>
        <span class="s1">descriptor: TodoCommentDescriptor;</span>
        <span class="s1">message: string;</span>
        <span class="s1">position: number;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TextChange {</span>
        <span class="s1">span: TextSpan;</span>
        <span class="s1">newText: string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">FileTextChanges {</span>
        <span class="s1">fileName: string;</span>
        <span class="s1">textChanges: readonly TextChange[];</span>
        <span class="s1">isNewFile?: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">CodeAction {</span>
        <span class="s0">/** Description of the code action to display in the UI of the editor */</span>
        <span class="s1">description: string;</span>
        <span class="s0">/** Text changes to apply to each file as part of the code action */</span>
        <span class="s1">changes: FileTextChanges[];</span>
        <span class="s0">/**</span>
         <span class="s0">* If the user accepts the code fix, the editor should send the action back in a `applyAction` request.</span>
         <span class="s0">* This allows the language service to have side effects (e.g. installing dependencies) upon a code fix.</span>
         <span class="s0">*/</span>
        <span class="s1">commands?: CodeActionCommand[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">CodeFixAction </span><span class="s2">extends </span><span class="s1">CodeAction {</span>
        <span class="s0">/** Short name to identify the fix, for use by telemetry. */</span>
        <span class="s1">fixName: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* If present, one may call 'getCombinedCodeFix' with this fixId.</span>
         <span class="s0">* This may be omitted to indicate that the code fix can't be applied in a group.</span>
         <span class="s0">*/</span>
        <span class="s1">fixId?: {};</span>
        <span class="s1">fixAllDescription?: string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">CombinedCodeActions {</span>
        <span class="s1">changes: readonly FileTextChanges[];</span>
        <span class="s1">commands?: readonly CodeActionCommand[];</span>
    <span class="s1">}</span>
    <span class="s1">type CodeActionCommand = InstallPackageAction;</span>
    <span class="s2">interface </span><span class="s1">InstallPackageAction {</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A set of one or more available refactoring actions, grouped under a parent refactoring.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">ApplicableRefactorInfo {</span>
        <span class="s0">/**</span>
         <span class="s0">* The programmatic name of the refactoring</span>
         <span class="s0">*/</span>
        <span class="s1">name: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* A description of this refactoring category to show to the user.</span>
         <span class="s0">* If the refactoring gets inlined (see below), this text will not be visible.</span>
         <span class="s0">*/</span>
        <span class="s1">description: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Inlineable refactorings can have their actions hoisted out to the top level</span>
         <span class="s0">* of a context menu. Non-inlineanable refactorings should always be shown inside</span>
         <span class="s0">* their parent grouping.</span>
         <span class="s0">*</span>
         <span class="s0">* If not specified, this value is assumed to be 'true'</span>
         <span class="s0">*/</span>
        <span class="s1">inlineable?: boolean;</span>
        <span class="s1">actions: RefactorActionInfo[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Represents a single refactoring action - for example, the &quot;Extract Method...&quot; refactor might</span>
     <span class="s0">* offer several actions, each corresponding to a surround class or closure to extract into.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">RefactorActionInfo {</span>
        <span class="s0">/**</span>
         <span class="s0">* The programmatic name of the refactoring action</span>
         <span class="s0">*/</span>
        <span class="s1">name: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* A description of this refactoring action to show to the user.</span>
         <span class="s0">* If the parent refactoring is inlined away, this will be the only text shown,</span>
         <span class="s0">* so this description should make sense by itself if the parent is inlineable=true</span>
         <span class="s0">*/</span>
        <span class="s1">description: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* A message to show to the user if the refactoring cannot be applied in</span>
         <span class="s0">* the current context.</span>
         <span class="s0">*/</span>
        <span class="s1">notApplicableReason?: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* The hierarchical dotted name of the refactor action.</span>
         <span class="s0">*/</span>
        <span class="s1">kind?: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Indicates that the action requires additional arguments to be passed</span>
         <span class="s0">* when calling `getEditsForRefactor`.</span>
         <span class="s0">*/</span>
        <span class="s1">isInteractive?: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Range of code the refactoring will be applied to.</span>
         <span class="s0">*/</span>
        <span class="s1">range?: {</span>
            <span class="s1">start: {</span>
                <span class="s1">line: number;</span>
                <span class="s1">offset: number;</span>
            <span class="s1">};</span>
            <span class="s1">end: {</span>
                <span class="s1">line: number;</span>
                <span class="s1">offset: number;</span>
            <span class="s1">};</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A set of edits to make in response to a refactor action, plus an optional</span>
     <span class="s0">* location where renaming should be invoked from</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">RefactorEditInfo {</span>
        <span class="s1">edits: FileTextChanges[];</span>
        <span class="s1">renameFilename?: string;</span>
        <span class="s1">renameLocation?: number;</span>
        <span class="s1">commands?: CodeActionCommand[];</span>
        <span class="s1">notApplicableReason?: string;</span>
    <span class="s1">}</span>
    <span class="s1">type RefactorTriggerReason = </span><span class="s3">&quot;implicit&quot; </span><span class="s1">| </span><span class="s3">&quot;invoked&quot;</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s1">TextInsertion {</span>
        <span class="s1">newText: string;</span>
        <span class="s0">/** The position in newText the caret should point to after the insertion. */</span>
        <span class="s1">caretOffset: number;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">DocumentSpan {</span>
        <span class="s1">textSpan: TextSpan;</span>
        <span class="s1">fileName: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* If the span represents a location that was remapped (e.g. via a .d.ts.map file),</span>
         <span class="s0">* then the original filename and span will be specified here</span>
         <span class="s0">*/</span>
        <span class="s1">originalTextSpan?: TextSpan;</span>
        <span class="s1">originalFileName?: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* If DocumentSpan.textSpan is the span for name of the declaration,</span>
         <span class="s0">* then this is the span for relevant declaration</span>
         <span class="s0">*/</span>
        <span class="s1">contextSpan?: TextSpan;</span>
        <span class="s1">originalContextSpan?: TextSpan;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">RenameLocation </span><span class="s2">extends </span><span class="s1">DocumentSpan {</span>
        <span class="s1">readonly prefixText?: string;</span>
        <span class="s1">readonly suffixText?: string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ReferenceEntry </span><span class="s2">extends </span><span class="s1">DocumentSpan {</span>
        <span class="s1">isWriteAccess: boolean;</span>
        <span class="s1">isInString?: </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ImplementationLocation </span><span class="s2">extends </span><span class="s1">DocumentSpan {</span>
        <span class="s1">kind: ScriptElementKind;</span>
        <span class="s1">displayParts: SymbolDisplayPart[];</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">HighlightSpanKind {</span>
        <span class="s1">none = </span><span class="s3">&quot;none&quot;</span><span class="s1">,</span>
        <span class="s1">definition = </span><span class="s3">&quot;definition&quot;</span><span class="s1">,</span>
        <span class="s1">reference = </span><span class="s3">&quot;reference&quot;</span><span class="s1">,</span>
        <span class="s1">writtenReference = </span><span class="s3">&quot;writtenReference&quot;</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">HighlightSpan {</span>
        <span class="s1">fileName?: string;</span>
        <span class="s1">isInString?: </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">textSpan: TextSpan;</span>
        <span class="s1">contextSpan?: TextSpan;</span>
        <span class="s1">kind: HighlightSpanKind;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">NavigateToItem {</span>
        <span class="s1">name: string;</span>
        <span class="s1">kind: ScriptElementKind;</span>
        <span class="s1">kindModifiers: string;</span>
        <span class="s1">matchKind: </span><span class="s3">&quot;exact&quot; </span><span class="s1">| </span><span class="s3">&quot;prefix&quot; </span><span class="s1">| </span><span class="s3">&quot;substring&quot; </span><span class="s1">| </span><span class="s3">&quot;camelCase&quot;</span><span class="s1">;</span>
        <span class="s1">isCaseSensitive: boolean;</span>
        <span class="s1">fileName: string;</span>
        <span class="s1">textSpan: TextSpan;</span>
        <span class="s1">containerName: string;</span>
        <span class="s1">containerKind: ScriptElementKind;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">IndentStyle {</span>
        <span class="s1">None = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">Block = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">Smart = </span><span class="s5">2</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">SemicolonPreference {</span>
        <span class="s1">Ignore = </span><span class="s3">&quot;ignore&quot;</span><span class="s1">,</span>
        <span class="s1">Insert = </span><span class="s3">&quot;insert&quot;</span><span class="s1">,</span>
        <span class="s1">Remove = </span><span class="s3">&quot;remove&quot;</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">- consider using EditorSettings instead */</span>
    <span class="s2">interface </span><span class="s1">EditorOptions {</span>
        <span class="s1">BaseIndentSize?: number;</span>
        <span class="s1">IndentSize: number;</span>
        <span class="s1">TabSize: number;</span>
        <span class="s1">NewLineCharacter: string;</span>
        <span class="s1">ConvertTabsToSpaces: boolean;</span>
        <span class="s1">IndentStyle: IndentStyle;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">EditorSettings {</span>
        <span class="s1">baseIndentSize?: number;</span>
        <span class="s1">indentSize?: number;</span>
        <span class="s1">tabSize?: number;</span>
        <span class="s1">newLineCharacter?: string;</span>
        <span class="s1">convertTabsToSpaces?: boolean;</span>
        <span class="s1">indentStyle?: IndentStyle;</span>
        <span class="s1">trimTrailingWhitespace?: boolean;</span>
    <span class="s1">}</span>
    <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">- consider using FormatCodeSettings instead */</span>
    <span class="s2">interface </span><span class="s1">FormatCodeOptions </span><span class="s2">extends </span><span class="s1">EditorOptions {</span>
        <span class="s1">InsertSpaceAfterCommaDelimiter: boolean;</span>
        <span class="s1">InsertSpaceAfterSemicolonInForStatements: boolean;</span>
        <span class="s1">InsertSpaceBeforeAndAfterBinaryOperators: boolean;</span>
        <span class="s1">InsertSpaceAfterConstructor?: boolean;</span>
        <span class="s1">InsertSpaceAfterKeywordsInControlFlowStatements: boolean;</span>
        <span class="s1">InsertSpaceAfterFunctionKeywordForAnonymousFunctions: boolean;</span>
        <span class="s1">InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: boolean;</span>
        <span class="s1">InsertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: boolean;</span>
        <span class="s1">InsertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean;</span>
        <span class="s1">InsertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: boolean;</span>
        <span class="s1">InsertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean;</span>
        <span class="s1">InsertSpaceAfterTypeAssertion?: boolean;</span>
        <span class="s1">InsertSpaceBeforeFunctionParenthesis?: boolean;</span>
        <span class="s1">PlaceOpenBraceOnNewLineForFunctions: boolean;</span>
        <span class="s1">PlaceOpenBraceOnNewLineForControlBlocks: boolean;</span>
        <span class="s1">insertSpaceBeforeTypeAnnotation?: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">FormatCodeSettings </span><span class="s2">extends </span><span class="s1">EditorSettings {</span>
        <span class="s1">readonly insertSpaceAfterCommaDelimiter?: boolean;</span>
        <span class="s1">readonly insertSpaceAfterSemicolonInForStatements?: boolean;</span>
        <span class="s1">readonly insertSpaceBeforeAndAfterBinaryOperators?: boolean;</span>
        <span class="s1">readonly insertSpaceAfterConstructor?: boolean;</span>
        <span class="s1">readonly insertSpaceAfterKeywordsInControlFlowStatements?: boolean;</span>
        <span class="s1">readonly insertSpaceAfterFunctionKeywordForAnonymousFunctions?: boolean;</span>
        <span class="s1">readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis?: boolean;</span>
        <span class="s1">readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets?: boolean;</span>
        <span class="s1">readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean;</span>
        <span class="s1">readonly insertSpaceAfterOpeningAndBeforeClosingEmptyBraces?: boolean;</span>
        <span class="s1">readonly insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces?: boolean;</span>
        <span class="s1">readonly insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean;</span>
        <span class="s1">readonly insertSpaceAfterTypeAssertion?: boolean;</span>
        <span class="s1">readonly insertSpaceBeforeFunctionParenthesis?: boolean;</span>
        <span class="s1">readonly placeOpenBraceOnNewLineForFunctions?: boolean;</span>
        <span class="s1">readonly placeOpenBraceOnNewLineForControlBlocks?: boolean;</span>
        <span class="s1">readonly insertSpaceBeforeTypeAnnotation?: boolean;</span>
        <span class="s1">readonly indentMultiLineObjectLiteralBeginningOnBlankLine?: boolean;</span>
        <span class="s1">readonly semicolons?: SemicolonPreference;</span>
        <span class="s1">readonly indentSwitchCase?: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">DefinitionInfo </span><span class="s2">extends </span><span class="s1">DocumentSpan {</span>
        <span class="s1">kind: ScriptElementKind;</span>
        <span class="s1">name: string;</span>
        <span class="s1">containerKind: ScriptElementKind;</span>
        <span class="s1">containerName: string;</span>
        <span class="s1">unverified?: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">DefinitionInfoAndBoundSpan {</span>
        <span class="s1">definitions?: readonly DefinitionInfo[];</span>
        <span class="s1">textSpan: TextSpan;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ReferencedSymbolDefinitionInfo </span><span class="s2">extends </span><span class="s1">DefinitionInfo {</span>
        <span class="s1">displayParts: SymbolDisplayPart[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ReferencedSymbol {</span>
        <span class="s1">definition: ReferencedSymbolDefinitionInfo;</span>
        <span class="s1">references: ReferencedSymbolEntry[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ReferencedSymbolEntry </span><span class="s2">extends </span><span class="s1">ReferenceEntry {</span>
        <span class="s1">isDefinition?: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">SymbolDisplayPartKind {</span>
        <span class="s1">aliasName = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">className = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">enumName = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">fieldName = </span><span class="s5">3</span><span class="s1">,</span>
        <span class="s1">interfaceName = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">keyword = </span><span class="s5">5</span><span class="s1">,</span>
        <span class="s1">lineBreak = </span><span class="s5">6</span><span class="s1">,</span>
        <span class="s1">numericLiteral = </span><span class="s5">7</span><span class="s1">,</span>
        <span class="s1">stringLiteral = </span><span class="s5">8</span><span class="s1">,</span>
        <span class="s1">localName = </span><span class="s5">9</span><span class="s1">,</span>
        <span class="s1">methodName = </span><span class="s5">10</span><span class="s1">,</span>
        <span class="s1">moduleName = </span><span class="s5">11</span><span class="s1">,</span>
        <span class="s1">operator = </span><span class="s5">12</span><span class="s1">,</span>
        <span class="s1">parameterName = </span><span class="s5">13</span><span class="s1">,</span>
        <span class="s1">propertyName = </span><span class="s5">14</span><span class="s1">,</span>
        <span class="s1">punctuation = </span><span class="s5">15</span><span class="s1">,</span>
        <span class="s1">space = </span><span class="s5">16</span><span class="s1">,</span>
        <span class="s1">text = </span><span class="s5">17</span><span class="s1">,</span>
        <span class="s1">typeParameterName = </span><span class="s5">18</span><span class="s1">,</span>
        <span class="s1">enumMemberName = </span><span class="s5">19</span><span class="s1">,</span>
        <span class="s1">functionName = </span><span class="s5">20</span><span class="s1">,</span>
        <span class="s1">regularExpressionLiteral = </span><span class="s5">21</span><span class="s1">,</span>
        <span class="s1">link = </span><span class="s5">22</span><span class="s1">,</span>
        <span class="s1">linkName = </span><span class="s5">23</span><span class="s1">,</span>
        <span class="s1">linkText = </span><span class="s5">24</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SymbolDisplayPart {</span>
        <span class="s0">/**</span>
         <span class="s0">* Text of an item describing the symbol.</span>
         <span class="s0">*/</span>
        <span class="s1">text: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* The symbol's kind (such as 'className' or 'parameterName' or plain 'text').</span>
         <span class="s0">*/</span>
        <span class="s1">kind: string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocLinkDisplayPart </span><span class="s2">extends </span><span class="s1">SymbolDisplayPart {</span>
        <span class="s1">target: DocumentSpan;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">JSDocTagInfo {</span>
        <span class="s1">name: string;</span>
        <span class="s1">text?: SymbolDisplayPart[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">QuickInfo {</span>
        <span class="s1">kind: ScriptElementKind;</span>
        <span class="s1">kindModifiers: string;</span>
        <span class="s1">textSpan: TextSpan;</span>
        <span class="s1">displayParts?: SymbolDisplayPart[];</span>
        <span class="s1">documentation?: SymbolDisplayPart[];</span>
        <span class="s1">tags?: JSDocTagInfo[];</span>
        <span class="s1">canIncreaseVerbosityLevel?: boolean;</span>
    <span class="s1">}</span>
    <span class="s1">type RenameInfo = RenameInfoSuccess | RenameInfoFailure;</span>
    <span class="s2">interface </span><span class="s1">RenameInfoSuccess {</span>
        <span class="s1">canRename: </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* File or directory to rename.</span>
         <span class="s0">* If set, `getEditsForFileRename` should be called instead of `findRenameLocations`.</span>
         <span class="s0">*/</span>
        <span class="s1">fileToRename?: string;</span>
        <span class="s1">displayName: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Full display name of item to be renamed.</span>
         <span class="s0">* If item to be renamed is a file, then this is the original text of the module specifer</span>
         <span class="s0">*/</span>
        <span class="s1">fullDisplayName: string;</span>
        <span class="s1">kind: ScriptElementKind;</span>
        <span class="s1">kindModifiers: string;</span>
        <span class="s1">triggerSpan: TextSpan;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">RenameInfoFailure {</span>
        <span class="s1">canRename: </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">localizedErrorMessage: string;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s4">@deprecated </span><span class="s0">Use `UserPreferences` instead.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">RenameInfoOptions {</span>
        <span class="s1">readonly allowRenameOfImportPath?: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">DocCommentTemplateOptions {</span>
        <span class="s1">readonly generateReturnInDocTemplate?: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">InteractiveRefactorArguments {</span>
        <span class="s1">targetFile: string;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Signature help information for a single parameter</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">SignatureHelpParameter {</span>
        <span class="s1">name: string;</span>
        <span class="s1">documentation: SymbolDisplayPart[];</span>
        <span class="s1">displayParts: SymbolDisplayPart[];</span>
        <span class="s1">isOptional: boolean;</span>
        <span class="s1">isRest?: boolean;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">SelectionRange {</span>
        <span class="s1">textSpan: TextSpan;</span>
        <span class="s1">parent?: SelectionRange;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Represents a single signature to show in signature help.</span>
     <span class="s0">* The id is used for subsequent calls into the language service to ask questions about the</span>
     <span class="s0">* signature help item in the context of any documents that have been updated.  i.e. after</span>
     <span class="s0">* an edit has happened, while signature help is still active, the host can ask important</span>
     <span class="s0">* questions like 'what parameter is the user currently contained within?'.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">SignatureHelpItem {</span>
        <span class="s1">isVariadic: boolean;</span>
        <span class="s1">prefixDisplayParts: SymbolDisplayPart[];</span>
        <span class="s1">suffixDisplayParts: SymbolDisplayPart[];</span>
        <span class="s1">separatorDisplayParts: SymbolDisplayPart[];</span>
        <span class="s1">parameters: SignatureHelpParameter[];</span>
        <span class="s1">documentation: SymbolDisplayPart[];</span>
        <span class="s1">tags: JSDocTagInfo[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Represents a set of signature help items, and the preferred item that should be selected.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">SignatureHelpItems {</span>
        <span class="s1">items: SignatureHelpItem[];</span>
        <span class="s1">applicableSpan: TextSpan;</span>
        <span class="s1">selectedItemIndex: number;</span>
        <span class="s1">argumentIndex: number;</span>
        <span class="s1">argumentCount: number;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">CompletionInfoFlags {</span>
        <span class="s1">None = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">MayIncludeAutoImports = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">IsImportStatementCompletion = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">IsContinuation = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">ResolvedModuleSpecifiers = </span><span class="s5">8</span><span class="s1">,</span>
        <span class="s1">ResolvedModuleSpecifiersBeyondLimit = </span><span class="s5">16</span><span class="s1">,</span>
        <span class="s1">MayIncludeMethodSnippets = </span><span class="s5">32</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">CompletionInfo {</span>
        <span class="s0">/** For performance telemetry. */</span>
        <span class="s1">flags?: CompletionInfoFlags;</span>
        <span class="s0">/** Not true for all global completions. This will be true if the enclosing scope matches a few syntax kinds. See `isSnippetScope`. */</span>
        <span class="s1">isGlobalCompletion: boolean;</span>
        <span class="s1">isMemberCompletion: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* In the absence of `CompletionEntry[&quot;replacementSpan&quot;]`, the editor may choose whether to use</span>
         <span class="s0">* this span or its default one. If `CompletionEntry[&quot;replacementSpan&quot;]` is defined, that span</span>
         <span class="s0">* must be used to commit that completion entry.</span>
         <span class="s0">*/</span>
        <span class="s1">optionalReplacementSpan?: TextSpan;</span>
        <span class="s0">/**</span>
         <span class="s0">* true when the current location also allows for a new identifier</span>
         <span class="s0">*/</span>
        <span class="s1">isNewIdentifierLocation: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Indicates to client to continue requesting completions on subsequent keystrokes.</span>
         <span class="s0">*/</span>
        <span class="s1">isIncomplete?: </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">entries: CompletionEntry[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Default commit characters for the completion entries.</span>
         <span class="s0">*/</span>
        <span class="s1">defaultCommitCharacters?: string[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">CompletionEntryDataAutoImport {</span>
        <span class="s0">/**</span>
         <span class="s0">* The name of the property or export in the module's symbol table. Differs from the completion name</span>
         <span class="s0">* in the case of InternalSymbolName.ExportEquals and InternalSymbolName.Default.</span>
         <span class="s0">*/</span>
        <span class="s1">exportName: string;</span>
        <span class="s1">exportMapKey?: ExportMapInfoKey;</span>
        <span class="s1">moduleSpecifier?: string;</span>
        <span class="s0">/** The file name declaring the export's module symbol, if it was an external module */</span>
        <span class="s1">fileName?: string;</span>
        <span class="s0">/** The module name (with quotes stripped) of the export's module symbol, if it was an ambient module */</span>
        <span class="s1">ambientModuleName?: string;</span>
        <span class="s0">/** True if the export was found in the package.json AutoImportProvider */</span>
        <span class="s1">isPackageJsonImport?: </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">CompletionEntryDataUnresolved </span><span class="s2">extends </span><span class="s1">CompletionEntryDataAutoImport {</span>
        <span class="s1">exportMapKey: ExportMapInfoKey;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">CompletionEntryDataResolved </span><span class="s2">extends </span><span class="s1">CompletionEntryDataAutoImport {</span>
        <span class="s1">moduleSpecifier: string;</span>
    <span class="s1">}</span>
    <span class="s1">type CompletionEntryData = CompletionEntryDataUnresolved | CompletionEntryDataResolved;</span>
    <span class="s2">interface </span><span class="s1">CompletionEntry {</span>
        <span class="s1">name: string;</span>
        <span class="s1">kind: ScriptElementKind;</span>
        <span class="s1">kindModifiers?: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* A string that is used for comparing completion items so that they can be ordered. This</span>
         <span class="s0">* is often the same as the name but may be different in certain circumstances.</span>
         <span class="s0">*/</span>
        <span class="s1">sortText: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Text to insert instead of `name`.</span>
         <span class="s0">* This is used to support bracketed completions; If `name` might be &quot;a-b&quot; but `insertText` would be `[&quot;a-b&quot;]`,</span>
         <span class="s0">* coupled with `replacementSpan` to replace a dotted access with a bracket access.</span>
         <span class="s0">*/</span>
        <span class="s1">insertText?: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* A string that should be used when filtering a set of</span>
         <span class="s0">* completion items.</span>
         <span class="s0">*/</span>
        <span class="s1">filterText?: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* `insertText` should be interpreted as a snippet if true.</span>
         <span class="s0">*/</span>
        <span class="s1">isSnippet?: </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An optional span that indicates the text to be replaced by this completion item.</span>
         <span class="s0">* If present, this span should be used instead of the default one.</span>
         <span class="s0">* It will be set if the required span differs from the one generated by the default replacement behavior.</span>
         <span class="s0">*/</span>
        <span class="s1">replacementSpan?: TextSpan;</span>
        <span class="s0">/**</span>
         <span class="s0">* Indicates whether commiting this completion entry will require additional code actions to be</span>
         <span class="s0">* made to avoid errors. The CompletionEntryDetails will have these actions.</span>
         <span class="s0">*/</span>
        <span class="s1">hasAction?: </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Identifier (not necessarily human-readable) identifying where this completion came from.</span>
         <span class="s0">*/</span>
        <span class="s1">source?: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Human-readable description of the `source`.</span>
         <span class="s0">*/</span>
        <span class="s1">sourceDisplay?: SymbolDisplayPart[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Additional details for the label.</span>
         <span class="s0">*/</span>
        <span class="s1">labelDetails?: CompletionEntryLabelDetails;</span>
        <span class="s0">/**</span>
         <span class="s0">* If true, this completion should be highlighted as recommended. There will only be one of these.</span>
         <span class="s0">* This will be set when we know the user should write an expression with a certain type and that type is an enum or constructable class.</span>
         <span class="s0">* Then either that enum/class or a namespace containing it will be the recommended symbol.</span>
         <span class="s0">*/</span>
        <span class="s1">isRecommended?: </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If true, this completion was generated from traversing the name table of an unchecked JS file,</span>
         <span class="s0">* and therefore may not be accurate.</span>
         <span class="s0">*/</span>
        <span class="s1">isFromUncheckedFile?: </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If true, this completion was for an auto-import of a module not yet in the program, but listed</span>
         <span class="s0">* in the project package.json. Used for telemetry reporting.</span>
         <span class="s0">*/</span>
        <span class="s1">isPackageJsonImport?: </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If true, this completion was an auto-import-style completion of an import statement (i.e., the</span>
         <span class="s0">* module specifier was inserted along with the imported identifier). Used for telemetry reporting.</span>
         <span class="s0">*/</span>
        <span class="s1">isImportStatementCompletion?: </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* For API purposes.</span>
         <span class="s0">* Included for non-string completions only when `includeSymbol: true` option is passed to `getCompletionsAtPosition`.</span>
         <span class="s0">* </span><span class="s4">@example </span><span class="s0">Get declaration of completion: `symbol.valueDeclaration`</span>
         <span class="s0">*/</span>
        <span class="s1">symbol?: Symbol;</span>
        <span class="s0">/**</span>
         <span class="s0">* A property to be sent back to TS Server in the CompletionDetailsRequest, along with `name`,</span>
         <span class="s0">* that allows TS Server to look up the symbol represented by the completion item, disambiguating</span>
         <span class="s0">* items with the same name. Currently only defined for auto-import completions, but the type is</span>
         <span class="s0">* `unknown` in the protocol, so it can be changed as needed to support other kinds of completions.</span>
         <span class="s0">* The presence of this property should generally not be used to assume that this completion entry</span>
         <span class="s0">* is an auto-import.</span>
         <span class="s0">*/</span>
        <span class="s1">data?: CompletionEntryData;</span>
        <span class="s0">/**</span>
         <span class="s0">* If this completion entry is selected, typing a commit character will cause the entry to be accepted.</span>
         <span class="s0">*/</span>
        <span class="s1">commitCharacters?: string[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">CompletionEntryLabelDetails {</span>
        <span class="s0">/**</span>
         <span class="s0">* An optional string which is rendered less prominently directly after</span>
         <span class="s0">* {</span><span class="s4">@link </span><span class="s0">CompletionEntry.name name}, without any spacing. Should be</span>
         <span class="s0">* used for function signatures or type annotations.</span>
         <span class="s0">*/</span>
        <span class="s1">detail?: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* An optional string which is rendered less prominently after</span>
         <span class="s0">* {</span><span class="s4">@link </span><span class="s0">CompletionEntryLabelDetails.detail}. Should be used for fully qualified</span>
         <span class="s0">* names or file path.</span>
         <span class="s0">*/</span>
        <span class="s1">description?: string;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">CompletionEntryDetails {</span>
        <span class="s1">name: string;</span>
        <span class="s1">kind: ScriptElementKind;</span>
        <span class="s1">kindModifiers: string;</span>
        <span class="s1">displayParts: SymbolDisplayPart[];</span>
        <span class="s1">documentation?: SymbolDisplayPart[];</span>
        <span class="s1">tags?: JSDocTagInfo[];</span>
        <span class="s1">codeActions?: CodeAction[];</span>
        <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">Use `sourceDisplay` instead. */</span>
        <span class="s1">source?: SymbolDisplayPart[];</span>
        <span class="s1">sourceDisplay?: SymbolDisplayPart[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">OutliningSpan {</span>
        <span class="s0">/** The span of the document to actually collapse. */</span>
        <span class="s1">textSpan: TextSpan;</span>
        <span class="s0">/** The span of the document to display when the user hovers over the collapsed span. */</span>
        <span class="s1">hintSpan: TextSpan;</span>
        <span class="s0">/** The text to display in the editor for the collapsed region. */</span>
        <span class="s1">bannerText: string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Whether or not this region should be automatically collapsed when</span>
         <span class="s0">* the 'Collapse to Definitions' command is invoked.</span>
         <span class="s0">*/</span>
        <span class="s1">autoCollapse: boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Classification of the contents of the span</span>
         <span class="s0">*/</span>
        <span class="s1">kind: OutliningSpanKind;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">OutliningSpanKind {</span>
        <span class="s0">/** Single or multi-line comments */</span>
        <span class="s1">Comment = </span><span class="s3">&quot;comment&quot;</span><span class="s1">,</span>
        <span class="s0">/** Sections marked by '// #region' and '// #endregion' comments */</span>
        <span class="s1">Region = </span><span class="s3">&quot;region&quot;</span><span class="s1">,</span>
        <span class="s0">/** Declarations and expressions */</span>
        <span class="s1">Code = </span><span class="s3">&quot;code&quot;</span><span class="s1">,</span>
        <span class="s0">/** Contiguous blocks of import declarations */</span>
        <span class="s1">Imports = </span><span class="s3">&quot;imports&quot;</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">OutputFileType {</span>
        <span class="s1">JavaScript = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">SourceMap = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">Declaration = </span><span class="s5">2</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">EndOfLineState {</span>
        <span class="s1">None = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">InMultiLineCommentTrivia = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">InSingleQuoteStringLiteral = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">InDoubleQuoteStringLiteral = </span><span class="s5">3</span><span class="s1">,</span>
        <span class="s1">InTemplateHeadOrNoSubstitutionTemplate = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">InTemplateMiddleOrTail = </span><span class="s5">5</span><span class="s1">,</span>
        <span class="s1">InTemplateSubstitutionPosition = </span><span class="s5">6</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">TokenClass {</span>
        <span class="s1">Punctuation = </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s1">Keyword = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">Operator = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">Comment = </span><span class="s5">3</span><span class="s1">,</span>
        <span class="s1">Whitespace = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">Identifier = </span><span class="s5">5</span><span class="s1">,</span>
        <span class="s1">NumberLiteral = </span><span class="s5">6</span><span class="s1">,</span>
        <span class="s1">BigIntLiteral = </span><span class="s5">7</span><span class="s1">,</span>
        <span class="s1">StringLiteral = </span><span class="s5">8</span><span class="s1">,</span>
        <span class="s1">RegExpLiteral = </span><span class="s5">9</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ClassificationResult {</span>
        <span class="s1">finalLexState: EndOfLineState;</span>
        <span class="s1">entries: ClassificationInfo[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">ClassificationInfo {</span>
        <span class="s1">length: number;</span>
        <span class="s1">classification: TokenClass;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">Classifier {</span>
        <span class="s0">/**</span>
         <span class="s0">* Gives lexical classifications of tokens on a line without any syntactic context.</span>
         <span class="s0">* For instance, a token consisting of the text 'string' can be either an identifier</span>
         <span class="s0">* named 'string' or the keyword 'string', however, because this classifier is not aware,</span>
         <span class="s0">* it relies on certain heuristics to give acceptable results. For classifications where</span>
         <span class="s0">* speed trumps accuracy, this function is preferable; however, for true accuracy, the</span>
         <span class="s0">* syntactic classifier is ideal. In fact, in certain editing scenarios, combining the</span>
         <span class="s0">* lexical, syntactic, and semantic classifiers may issue the best user experience.</span>
         <span class="s0">*</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">text                      The text of a line to classify.</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">lexState                  The state of the lexical classifier at the end of the previous line.</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">syntacticClassifierAbsent Whether the client is *not* using a syntactic classifier.</span>
         <span class="s0">*                                  If there is no syntactic classifier (syntacticClassifierAbsent=true),</span>
         <span class="s0">*                                  certain heuristics may be used in its place; however, if there is a</span>
         <span class="s0">*                                  syntactic classifier (syntacticClassifierAbsent=false), certain</span>
         <span class="s0">*                                  classifications which may be incorrectly categorized will be given</span>
         <span class="s0">*                                  back as Identifiers in order to allow the syntactic classifier to</span>
         <span class="s0">*                                  subsume the classification.</span>
         <span class="s0">* </span><span class="s4">@deprecated </span><span class="s0">Use getLexicalClassifications instead.</span>
         <span class="s0">*/</span>
        <span class="s1">getClassificationsForLine(text: string, lexState: EndOfLineState, syntacticClassifierAbsent: boolean): ClassificationResult;</span>
        <span class="s1">getEncodedLexicalClassifications(text: string, endOfLineState: EndOfLineState, syntacticClassifierAbsent: boolean): Classifications;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">ScriptElementKind {</span>
        <span class="s1">unknown = </span><span class="s3">&quot;&quot;</span><span class="s1">,</span>
        <span class="s1">warning = </span><span class="s3">&quot;warning&quot;</span><span class="s1">,</span>
        <span class="s0">/** predefined type (void) or keyword (class) */</span>
        <span class="s1">keyword = </span><span class="s3">&quot;keyword&quot;</span><span class="s1">,</span>
        <span class="s0">/** top level script node */</span>
        <span class="s1">scriptElement = </span><span class="s3">&quot;script&quot;</span><span class="s1">,</span>
        <span class="s0">/** module foo {} */</span>
        <span class="s1">moduleElement = </span><span class="s3">&quot;module&quot;</span><span class="s1">,</span>
        <span class="s0">/** class X {} */</span>
        <span class="s1">classElement = </span><span class="s3">&quot;class&quot;</span><span class="s1">,</span>
        <span class="s0">/** var x = class X {} */</span>
        <span class="s1">localClassElement = </span><span class="s3">&quot;local class&quot;</span><span class="s1">,</span>
        <span class="s0">/** interface Y {} */</span>
        <span class="s1">interfaceElement = </span><span class="s3">&quot;interface&quot;</span><span class="s1">,</span>
        <span class="s0">/** type T = ... */</span>
        <span class="s1">typeElement = </span><span class="s3">&quot;type&quot;</span><span class="s1">,</span>
        <span class="s0">/** enum E */</span>
        <span class="s1">enumElement = </span><span class="s3">&quot;enum&quot;</span><span class="s1">,</span>
        <span class="s1">enumMemberElement = </span><span class="s3">&quot;enum member&quot;</span><span class="s1">,</span>
        <span class="s0">/**</span>
         <span class="s0">* Inside module and script only</span>
         <span class="s0">* const v = ..</span>
         <span class="s0">*/</span>
        <span class="s1">variableElement = </span><span class="s3">&quot;var&quot;</span><span class="s1">,</span>
        <span class="s0">/** Inside function */</span>
        <span class="s1">localVariableElement = </span><span class="s3">&quot;local var&quot;</span><span class="s1">,</span>
        <span class="s0">/** using foo = ... */</span>
        <span class="s1">variableUsingElement = </span><span class="s3">&quot;using&quot;</span><span class="s1">,</span>
        <span class="s0">/** await using foo = ... */</span>
        <span class="s1">variableAwaitUsingElement = </span><span class="s3">&quot;await using&quot;</span><span class="s1">,</span>
        <span class="s0">/**</span>
         <span class="s0">* Inside module and script only</span>
         <span class="s0">* function f() { }</span>
         <span class="s0">*/</span>
        <span class="s1">functionElement = </span><span class="s3">&quot;function&quot;</span><span class="s1">,</span>
        <span class="s0">/** Inside function */</span>
        <span class="s1">localFunctionElement = </span><span class="s3">&quot;local function&quot;</span><span class="s1">,</span>
        <span class="s0">/** class X { [public|private]* foo() {} } */</span>
        <span class="s1">memberFunctionElement = </span><span class="s3">&quot;method&quot;</span><span class="s1">,</span>
        <span class="s0">/** class X { [public|private]* [get|set] foo:number; } */</span>
        <span class="s1">memberGetAccessorElement = </span><span class="s3">&quot;getter&quot;</span><span class="s1">,</span>
        <span class="s1">memberSetAccessorElement = </span><span class="s3">&quot;setter&quot;</span><span class="s1">,</span>
        <span class="s0">/**</span>
         <span class="s0">* class X { [public|private]* foo:number; }</span>
         <span class="s0">* interface Y { foo:number; }</span>
         <span class="s0">*/</span>
        <span class="s1">memberVariableElement = </span><span class="s3">&quot;property&quot;</span><span class="s1">,</span>
        <span class="s0">/** class X { [public|private]* accessor foo: number; } */</span>
        <span class="s1">memberAccessorVariableElement = </span><span class="s3">&quot;accessor&quot;</span><span class="s1">,</span>
        <span class="s0">/**</span>
         <span class="s0">* class X { constructor() { } }</span>
         <span class="s0">* class X { static { } }</span>
         <span class="s0">*/</span>
        <span class="s1">constructorImplementationElement = </span><span class="s3">&quot;constructor&quot;</span><span class="s1">,</span>
        <span class="s0">/** interface Y { ():number; } */</span>
        <span class="s1">callSignatureElement = </span><span class="s3">&quot;call&quot;</span><span class="s1">,</span>
        <span class="s0">/** interface Y { []:number; } */</span>
        <span class="s1">indexSignatureElement = </span><span class="s3">&quot;index&quot;</span><span class="s1">,</span>
        <span class="s0">/** interface Y { new():Y; } */</span>
        <span class="s1">constructSignatureElement = </span><span class="s3">&quot;construct&quot;</span><span class="s1">,</span>
        <span class="s0">/** function foo(*Y*: string) */</span>
        <span class="s1">parameterElement = </span><span class="s3">&quot;parameter&quot;</span><span class="s1">,</span>
        <span class="s1">typeParameterElement = </span><span class="s3">&quot;type parameter&quot;</span><span class="s1">,</span>
        <span class="s1">primitiveType = </span><span class="s3">&quot;primitive type&quot;</span><span class="s1">,</span>
        <span class="s1">label = </span><span class="s3">&quot;label&quot;</span><span class="s1">,</span>
        <span class="s1">alias = </span><span class="s3">&quot;alias&quot;</span><span class="s1">,</span>
        <span class="s1">constElement = </span><span class="s3">&quot;const&quot;</span><span class="s1">,</span>
        <span class="s1">letElement = </span><span class="s3">&quot;let&quot;</span><span class="s1">,</span>
        <span class="s1">directory = </span><span class="s3">&quot;directory&quot;</span><span class="s1">,</span>
        <span class="s1">externalModuleName = </span><span class="s3">&quot;external module name&quot;</span><span class="s1">,</span>
        <span class="s0">/**</span>
         <span class="s0">* &lt;JsxTagName attribute1 attribute2={0} /&gt;</span>
         <span class="s0">* </span><span class="s4">@deprecated</span>
         <span class="s0">*/</span>
        <span class="s1">jsxAttribute = </span><span class="s3">&quot;JSX attribute&quot;</span><span class="s1">,</span>
        <span class="s0">/** String literal */</span>
        <span class="s1">string = </span><span class="s3">&quot;string&quot;</span><span class="s1">,</span>
        <span class="s0">/** Jsdoc @link: in `{@link C link text}`, the before and after text &quot;{</span><span class="s4">@link </span><span class="s0">&quot; and &quot;}&quot; */</span>
        <span class="s1">link = </span><span class="s3">&quot;link&quot;</span><span class="s1">,</span>
        <span class="s0">/** Jsdoc @link: in `{@link C link text}`, the entity name &quot;C&quot; */</span>
        <span class="s1">linkName = </span><span class="s3">&quot;link name&quot;</span><span class="s1">,</span>
        <span class="s0">/** Jsdoc @link: in `{@link C link text}`, the link text &quot;link text&quot; */</span>
        <span class="s1">linkText = </span><span class="s3">&quot;link text&quot;</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">ScriptElementKindModifier {</span>
        <span class="s1">none = </span><span class="s3">&quot;&quot;</span><span class="s1">,</span>
        <span class="s1">publicMemberModifier = </span><span class="s3">&quot;public&quot;</span><span class="s1">,</span>
        <span class="s1">privateMemberModifier = </span><span class="s3">&quot;private&quot;</span><span class="s1">,</span>
        <span class="s1">protectedMemberModifier = </span><span class="s3">&quot;protected&quot;</span><span class="s1">,</span>
        <span class="s1">exportedModifier = </span><span class="s3">&quot;export&quot;</span><span class="s1">,</span>
        <span class="s1">ambientModifier = </span><span class="s3">&quot;declare&quot;</span><span class="s1">,</span>
        <span class="s1">staticModifier = </span><span class="s3">&quot;static&quot;</span><span class="s1">,</span>
        <span class="s1">abstractModifier = </span><span class="s3">&quot;abstract&quot;</span><span class="s1">,</span>
        <span class="s1">optionalModifier = </span><span class="s3">&quot;optional&quot;</span><span class="s1">,</span>
        <span class="s1">deprecatedModifier = </span><span class="s3">&quot;deprecated&quot;</span><span class="s1">,</span>
        <span class="s1">dtsModifier = </span><span class="s3">&quot;.d.ts&quot;</span><span class="s1">,</span>
        <span class="s1">tsModifier = </span><span class="s3">&quot;.ts&quot;</span><span class="s1">,</span>
        <span class="s1">tsxModifier = </span><span class="s3">&quot;.tsx&quot;</span><span class="s1">,</span>
        <span class="s1">jsModifier = </span><span class="s3">&quot;.js&quot;</span><span class="s1">,</span>
        <span class="s1">jsxModifier = </span><span class="s3">&quot;.jsx&quot;</span><span class="s1">,</span>
        <span class="s1">jsonModifier = </span><span class="s3">&quot;.json&quot;</span><span class="s1">,</span>
        <span class="s1">dmtsModifier = </span><span class="s3">&quot;.d.mts&quot;</span><span class="s1">,</span>
        <span class="s1">mtsModifier = </span><span class="s3">&quot;.mts&quot;</span><span class="s1">,</span>
        <span class="s1">mjsModifier = </span><span class="s3">&quot;.mjs&quot;</span><span class="s1">,</span>
        <span class="s1">dctsModifier = </span><span class="s3">&quot;.d.cts&quot;</span><span class="s1">,</span>
        <span class="s1">ctsModifier = </span><span class="s3">&quot;.cts&quot;</span><span class="s1">,</span>
        <span class="s1">cjsModifier = </span><span class="s3">&quot;.cjs&quot;</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">ClassificationTypeNames {</span>
        <span class="s1">comment = </span><span class="s3">&quot;comment&quot;</span><span class="s1">,</span>
        <span class="s1">identifier = </span><span class="s3">&quot;identifier&quot;</span><span class="s1">,</span>
        <span class="s1">keyword = </span><span class="s3">&quot;keyword&quot;</span><span class="s1">,</span>
        <span class="s1">numericLiteral = </span><span class="s3">&quot;number&quot;</span><span class="s1">,</span>
        <span class="s1">bigintLiteral = </span><span class="s3">&quot;bigint&quot;</span><span class="s1">,</span>
        <span class="s1">operator = </span><span class="s3">&quot;operator&quot;</span><span class="s1">,</span>
        <span class="s1">stringLiteral = </span><span class="s3">&quot;string&quot;</span><span class="s1">,</span>
        <span class="s1">whiteSpace = </span><span class="s3">&quot;whitespace&quot;</span><span class="s1">,</span>
        <span class="s1">text = </span><span class="s3">&quot;text&quot;</span><span class="s1">,</span>
        <span class="s1">punctuation = </span><span class="s3">&quot;punctuation&quot;</span><span class="s1">,</span>
        <span class="s1">className = </span><span class="s3">&quot;class name&quot;</span><span class="s1">,</span>
        <span class="s1">enumName = </span><span class="s3">&quot;enum name&quot;</span><span class="s1">,</span>
        <span class="s1">interfaceName = </span><span class="s3">&quot;interface name&quot;</span><span class="s1">,</span>
        <span class="s1">moduleName = </span><span class="s3">&quot;module name&quot;</span><span class="s1">,</span>
        <span class="s1">typeParameterName = </span><span class="s3">&quot;type parameter name&quot;</span><span class="s1">,</span>
        <span class="s1">typeAliasName = </span><span class="s3">&quot;type alias name&quot;</span><span class="s1">,</span>
        <span class="s1">parameterName = </span><span class="s3">&quot;parameter name&quot;</span><span class="s1">,</span>
        <span class="s1">docCommentTagName = </span><span class="s3">&quot;doc comment tag name&quot;</span><span class="s1">,</span>
        <span class="s1">jsxOpenTagName = </span><span class="s3">&quot;jsx open tag name&quot;</span><span class="s1">,</span>
        <span class="s1">jsxCloseTagName = </span><span class="s3">&quot;jsx close tag name&quot;</span><span class="s1">,</span>
        <span class="s1">jsxSelfClosingTagName = </span><span class="s3">&quot;jsx self closing tag name&quot;</span><span class="s1">,</span>
        <span class="s1">jsxAttribute = </span><span class="s3">&quot;jsx attribute&quot;</span><span class="s1">,</span>
        <span class="s1">jsxText = </span><span class="s3">&quot;jsx text&quot;</span><span class="s1">,</span>
        <span class="s1">jsxAttributeStringLiteralValue = </span><span class="s3">&quot;jsx attribute string literal value&quot;</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s1">ClassificationType {</span>
        <span class="s1">comment = </span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">identifier = </span><span class="s5">2</span><span class="s1">,</span>
        <span class="s1">keyword = </span><span class="s5">3</span><span class="s1">,</span>
        <span class="s1">numericLiteral = </span><span class="s5">4</span><span class="s1">,</span>
        <span class="s1">operator = </span><span class="s5">5</span><span class="s1">,</span>
        <span class="s1">stringLiteral = </span><span class="s5">6</span><span class="s1">,</span>
        <span class="s1">regularExpressionLiteral = </span><span class="s5">7</span><span class="s1">,</span>
        <span class="s1">whiteSpace = </span><span class="s5">8</span><span class="s1">,</span>
        <span class="s1">text = </span><span class="s5">9</span><span class="s1">,</span>
        <span class="s1">punctuation = </span><span class="s5">10</span><span class="s1">,</span>
        <span class="s1">className = </span><span class="s5">11</span><span class="s1">,</span>
        <span class="s1">enumName = </span><span class="s5">12</span><span class="s1">,</span>
        <span class="s1">interfaceName = </span><span class="s5">13</span><span class="s1">,</span>
        <span class="s1">moduleName = </span><span class="s5">14</span><span class="s1">,</span>
        <span class="s1">typeParameterName = </span><span class="s5">15</span><span class="s1">,</span>
        <span class="s1">typeAliasName = </span><span class="s5">16</span><span class="s1">,</span>
        <span class="s1">parameterName = </span><span class="s5">17</span><span class="s1">,</span>
        <span class="s1">docCommentTagName = </span><span class="s5">18</span><span class="s1">,</span>
        <span class="s1">jsxOpenTagName = </span><span class="s5">19</span><span class="s1">,</span>
        <span class="s1">jsxCloseTagName = </span><span class="s5">20</span><span class="s1">,</span>
        <span class="s1">jsxSelfClosingTagName = </span><span class="s5">21</span><span class="s1">,</span>
        <span class="s1">jsxAttribute = </span><span class="s5">22</span><span class="s1">,</span>
        <span class="s1">jsxText = </span><span class="s5">23</span><span class="s1">,</span>
        <span class="s1">jsxAttributeStringLiteralValue = </span><span class="s5">24</span><span class="s1">,</span>
        <span class="s1">bigintLiteral = </span><span class="s5">25</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">InlayHintsContext {</span>
        <span class="s1">file: SourceFile;</span>
        <span class="s1">program: Program;</span>
        <span class="s1">cancellationToken: CancellationToken;</span>
        <span class="s1">host: LanguageServiceHost;</span>
        <span class="s1">span: TextSpan;</span>
        <span class="s1">preferences: UserPreferences;</span>
    <span class="s1">}</span>
    <span class="s1">type ExportMapInfoKey = string &amp; {</span>
        <span class="s1">__exportInfoKey: </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** The classifier is used for syntactic highlighting in editors via the TSServer */</span>
    <span class="s2">function </span><span class="s1">createClassifier(): Classifier;</span>
    <span class="s2">interface </span><span class="s1">DocumentHighlights {</span>
        <span class="s1">fileName: string;</span>
        <span class="s1">highlightSpans: HighlightSpan[];</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">createDocumentRegistry(useCaseSensitiveFileNames?: boolean, currentDirectory?: string, jsDocParsingMode?: JSDocParsingMode): DocumentRegistry;</span>
    <span class="s0">/**</span>
     <span class="s0">* The document registry represents a store of SourceFile objects that can be shared between</span>
     <span class="s0">* multiple LanguageService instances. A LanguageService instance holds on the SourceFile (AST)</span>
     <span class="s0">* of files in the context.</span>
     <span class="s0">* SourceFile objects account for most of the memory usage by the language service. Sharing</span>
     <span class="s0">* the same DocumentRegistry instance between different instances of LanguageService allow</span>
     <span class="s0">* for more efficient memory utilization since all projects will share at least the library</span>
     <span class="s0">* file (lib.d.ts).</span>
     <span class="s0">*</span>
     <span class="s0">* A more advanced use of the document registry is to serialize sourceFile objects to disk</span>
     <span class="s0">* and re-hydrate them when needed.</span>
     <span class="s0">*</span>
     <span class="s0">* To create a default DocumentRegistry, use createDocumentRegistry to create one, and pass it</span>
     <span class="s0">* to all subsequent createLanguageService calls.</span>
     <span class="s0">*/</span>
    <span class="s2">interface </span><span class="s1">DocumentRegistry {</span>
        <span class="s0">/**</span>
         <span class="s0">* Request a stored SourceFile with a given fileName and compilationSettings.</span>
         <span class="s0">* The first call to acquire will call createLanguageServiceSourceFile to generate</span>
         <span class="s0">* the SourceFile if was not found in the registry.</span>
         <span class="s0">*</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">fileName The name of the file requested</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">compilationSettingsOrHost Some compilation settings like target affects the</span>
         <span class="s0">* shape of a the resulting SourceFile. This allows the DocumentRegistry to store</span>
         <span class="s0">* multiple copies of the same file for different compilation settings. A minimal</span>
         <span class="s0">* resolution cache is needed to fully define a source file's shape when</span>
         <span class="s0">* the compilation settings include `module: node16`+, so providing a cache host</span>
         <span class="s0">* object should be preferred. A common host is a language service `ConfiguredProject`.</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">scriptSnapshot Text of the file. Only used if the file was not found</span>
         <span class="s0">* in the registry and a new one was created.</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">version Current version of the file. Only used if the file was not found</span>
         <span class="s0">* in the registry and a new one was created.</span>
         <span class="s0">*/</span>
        <span class="s1">acquireDocument(fileName: string, compilationSettingsOrHost: CompilerOptions | MinimalResolutionCacheHost, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind, sourceFileOptions?: CreateSourceFileOptions | ScriptTarget): SourceFile;</span>
        <span class="s1">acquireDocumentWithKey(fileName: string, path: Path, compilationSettingsOrHost: CompilerOptions | MinimalResolutionCacheHost, key: DocumentRegistryBucketKey, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind, sourceFileOptions?: CreateSourceFileOptions | ScriptTarget): SourceFile;</span>
        <span class="s0">/**</span>
         <span class="s0">* Request an updated version of an already existing SourceFile with a given fileName</span>
         <span class="s0">* and compilationSettings. The update will in-turn call updateLanguageServiceSourceFile</span>
         <span class="s0">* to get an updated SourceFile.</span>
         <span class="s0">*</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">fileName The name of the file requested</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">compilationSettingsOrHost Some compilation settings like target affects the</span>
         <span class="s0">* shape of a the resulting SourceFile. This allows the DocumentRegistry to store</span>
         <span class="s0">* multiple copies of the same file for different compilation settings. A minimal</span>
         <span class="s0">* resolution cache is needed to fully define a source file's shape when</span>
         <span class="s0">* the compilation settings include `module: node16`+, so providing a cache host</span>
         <span class="s0">* object should be preferred. A common host is a language service `ConfiguredProject`.</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">scriptSnapshot Text of the file.</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">version Current version of the file.</span>
         <span class="s0">*/</span>
        <span class="s1">updateDocument(fileName: string, compilationSettingsOrHost: CompilerOptions | MinimalResolutionCacheHost, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind, sourceFileOptions?: CreateSourceFileOptions | ScriptTarget): SourceFile;</span>
        <span class="s1">updateDocumentWithKey(fileName: string, path: Path, compilationSettingsOrHost: CompilerOptions | MinimalResolutionCacheHost, key: DocumentRegistryBucketKey, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind, sourceFileOptions?: CreateSourceFileOptions | ScriptTarget): SourceFile;</span>
        <span class="s1">getKeyForCompilationSettings(settings: CompilerOptions): DocumentRegistryBucketKey;</span>
        <span class="s0">/**</span>
         <span class="s0">* Informs the DocumentRegistry that a file is not needed any longer.</span>
         <span class="s0">*</span>
         <span class="s0">* Note: It is not allowed to call release on a SourceFile that was not acquired from</span>
         <span class="s0">* this registry originally.</span>
         <span class="s0">*</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">fileName The name of the file to be released</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">compilationSettings The compilation settings used to acquire the file</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">scriptKind The script kind of the file to be released</span>
         <span class="s0">*</span>
         <span class="s0">* </span><span class="s4">@deprecated </span><span class="s0">pass scriptKind and impliedNodeFormat for correctness</span>
         <span class="s0">*/</span>
        <span class="s1">releaseDocument(fileName: string, compilationSettings: CompilerOptions, scriptKind?: ScriptKind): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Informs the DocumentRegistry that a file is not needed any longer.</span>
         <span class="s0">*</span>
         <span class="s0">* Note: It is not allowed to call release on a SourceFile that was not acquired from</span>
         <span class="s0">* this registry originally.</span>
         <span class="s0">*</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">fileName The name of the file to be released</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">compilationSettings The compilation settings used to acquire the file</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">scriptKind The script kind of the file to be released</span>
         <span class="s0">* </span><span class="s4">@param </span><span class="s0">impliedNodeFormat The implied source file format of the file to be released</span>
         <span class="s0">*/</span>
        <span class="s1">releaseDocument(fileName: string, compilationSettings: CompilerOptions, scriptKind: ScriptKind, impliedNodeFormat: ResolutionMode): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s4">@deprecated </span><span class="s0">pass scriptKind for and impliedNodeFormat correctness */</span>
        <span class="s1">releaseDocumentWithKey(path: Path, key: DocumentRegistryBucketKey, scriptKind?: ScriptKind): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">releaseDocumentWithKey(path: Path, key: DocumentRegistryBucketKey, scriptKind: ScriptKind, impliedNodeFormat: ResolutionMode): </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">reportStats(): string;</span>
    <span class="s1">}</span>
    <span class="s1">type DocumentRegistryBucketKey = string &amp; {</span>
        <span class="s1">__bucketKey: any;</span>
    <span class="s1">};</span>
    <span class="s2">function </span><span class="s1">preProcessFile(sourceText: string, readImportFiles?: boolean, detectJavaScriptImports?: boolean): PreProcessedFileInfo;</span>
    <span class="s2">function </span><span class="s1">transpileModule(input: string, transpileOptions: TranspileOptions): TranspileOutput;</span>
    <span class="s2">function </span><span class="s1">transpileDeclaration(input: string, transpileOptions: TranspileOptions): TranspileOutput;</span>
    <span class="s2">function </span><span class="s1">transpile(input: string, compilerOptions?: CompilerOptions, fileName?: string, diagnostics?: Diagnostic[], moduleName?: string): string;</span>
    <span class="s2">interface </span><span class="s1">TranspileOptions {</span>
        <span class="s1">compilerOptions?: CompilerOptions;</span>
        <span class="s1">fileName?: string;</span>
        <span class="s1">reportDiagnostics?: boolean;</span>
        <span class="s1">moduleName?: string;</span>
        <span class="s1">renamedDependencies?: MapLike&lt;string&gt;;</span>
        <span class="s1">transformers?: CustomTransformers;</span>
        <span class="s1">jsDocParsingMode?: JSDocParsingMode;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s1">TranspileOutput {</span>
        <span class="s1">outputText: string;</span>
        <span class="s1">diagnostics?: Diagnostic[];</span>
        <span class="s1">sourceMapText?: string;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">toEditorSettings(options: EditorOptions | EditorSettings): EditorSettings;</span>
    <span class="s2">function </span><span class="s1">displayPartsToString(displayParts: SymbolDisplayPart[] | undefined): string;</span>
    <span class="s2">function </span><span class="s1">getDefaultCompilerOptions(): CompilerOptions;</span>
    <span class="s2">function </span><span class="s1">getSupportedCodeFixes(): readonly string[];</span>
    <span class="s2">function </span><span class="s1">createLanguageServiceSourceFile(fileName: string, scriptSnapshot: IScriptSnapshot, scriptTargetOrOptions: ScriptTarget | CreateSourceFileOptions, version: string, setNodeParents: boolean, scriptKind?: ScriptKind): SourceFile;</span>
    <span class="s2">function </span><span class="s1">updateLanguageServiceSourceFile(sourceFile: SourceFile, scriptSnapshot: IScriptSnapshot, version: string, textChangeRange: TextChangeRange | undefined, aggressiveChecks?: boolean): SourceFile;</span>
    <span class="s2">function </span><span class="s1">createLanguageService(host: LanguageServiceHost, documentRegistry?: DocumentRegistry, syntaxOnlyOrLanguageServiceMode?: boolean | LanguageServiceMode): LanguageService;</span>
    <span class="s0">/**</span>
     <span class="s0">* Get the path of the default library files (lib.d.ts) as distributed with the typescript</span>
     <span class="s0">* node package.</span>
     <span class="s0">* The functionality is not supported if the ts module is consumed outside of a node module.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">getDefaultLibFilePath(options: CompilerOptions): string;</span>
    <span class="s0">/** The version of the language service API */</span>
    <span class="s2">const </span><span class="s1">servicesVersion = </span><span class="s3">&quot;0.8&quot;</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Transform one or more nodes using the supplied transformers.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">source A single `Node` or an array of `Node` objects.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">transformers An array of `TransformerFactory` callbacks used to process the transformation.</span>
     <span class="s0">* </span><span class="s4">@param </span><span class="s0">compilerOptions Optional compiler options.</span>
     <span class="s0">*/</span>
    <span class="s2">function </span><span class="s1">transform&lt;T </span><span class="s2">extends </span><span class="s1">Node&gt;(source: T | T[], transformers: TransformerFactory&lt;T&gt;[], compilerOptions?: CompilerOptions): TransformationResult&lt;T&gt;;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">= ts;</span>
</pre>
</body>
</html>