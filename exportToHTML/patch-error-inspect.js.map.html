<html>
<head>
<title>patch-error-inspect.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
patch-error-inspect.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/server/patch-error-inspect.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { findSourceMap as nativeFindSourceMap } from 'module'</span><span class="s3">\n</span><span class="s1">import * as path from 'path'</span><span class="s3">\n</span><span class="s1">import * as url from 'url'</span><span class="s3">\n</span><span class="s1">import type * as util from 'util'</span><span class="s3">\n</span><span class="s1">import { SourceMapConsumer as SyncSourceMapConsumer } from 'next/dist/compiled/source-map'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">type ModernSourceMapPayload,</span><span class="s3">\n  </span><span class="s1">findApplicableSourceMapPayload,</span><span class="s3">\n  </span><span class="s1">ignoreListAnonymousStackFramesIfSandwiched as ignoreListAnonymousStackFramesIfSandwichedGeneric,</span><span class="s3">\n  </span><span class="s1">sourceMapIgnoreListsEverything,</span><span class="s3">\n</span><span class="s1">} from './lib/source-maps'</span><span class="s3">\n</span><span class="s1">import { parseStack, type StackFrame } from './lib/parse-stack'</span><span class="s3">\n</span><span class="s1">import { getOriginalCodeFrame } from '../next-devtools/server/shared'</span><span class="s3">\n</span><span class="s1">import { workUnitAsyncStorage } from './app-render/work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { dim } from '../lib/picocolors'</span><span class="s3">\n\n</span><span class="s1">type FindSourceMapPayload = (</span><span class="s3">\n  </span><span class="s1">sourceURL: string</span><span class="s3">\n</span><span class="s1">) =&gt; ModernSourceMapPayload | undefined</span><span class="s3">\n</span><span class="s1">// Find a source map using the bundler's API.</span><span class="s3">\n</span><span class="s1">// This is only a fallback for when Node.js fails to due to bugs e.g. https://github.com/nodejs/node/issues/52102</span><span class="s3">\n</span><span class="s1">// TODO: Remove once all supported Node.js versions are fixed.</span><span class="s3">\n</span><span class="s1">// TODO(veil): Set from Webpack as well</span><span class="s3">\n</span><span class="s1">let bundlerFindSourceMapPayload: FindSourceMapPayload = () =&gt; undefined</span><span class="s3">\n\n</span><span class="s1">export function setBundlerFindSourceMapImplementation(</span><span class="s3">\n  </span><span class="s1">findSourceMapImplementation: FindSourceMapPayload</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">bundlerFindSourceMapPayload = findSourceMapImplementation</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface IgnorableStackFrame extends StackFrame {</span><span class="s3">\n  </span><span class="s1">ignored: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type SourceMapCache = Map&lt;</span><span class="s3">\n  </span><span class="s1">string,</span><span class="s3">\n  </span><span class="s1">null | { map: SyncSourceMapConsumer; payload: ModernSourceMapPayload }</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">function frameToString(</span><span class="s3">\n  </span><span class="s1">methodName: string | null,</span><span class="s3">\n  </span><span class="s1">sourceURL: string | null,</span><span class="s3">\n  </span><span class="s1">line1: number | null,</span><span class="s3">\n  </span><span class="s1">column1: number | null</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">let sourceLocation = line1 !== null ? `:${line1}` : ''</span><span class="s3">\n  </span><span class="s1">if (column1 !== null &amp;&amp; sourceLocation !== '') {</span><span class="s3">\n    </span><span class="s1">sourceLocation += `:${column1}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let fileLocation: string | null</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">sourceURL !== null &amp;&amp;</span><span class="s3">\n    </span><span class="s1">sourceURL.startsWith('file://') &amp;&amp;</span><span class="s3">\n    </span><span class="s1">URL.canParse(sourceURL)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// If not relative to CWD, the path is ambiguous to IDEs and clicking will prompt to select the file first.</span><span class="s3">\n    </span><span class="s1">// In a multi-app repo, this leads to potentially larger file names but will make clicking snappy.</span><span class="s3">\n    </span><span class="s1">// There's no tradeoff for the cases where `dir` in `next dev [dir]` is omitted</span><span class="s3">\n    </span><span class="s1">// since relative to cwd is both the shortest and snappiest.</span><span class="s3">\n    </span><span class="s1">fileLocation = path.relative(process.cwd(), url.fileURLToPath(sourceURL))</span><span class="s3">\n  </span><span class="s1">} else if (sourceURL !== null &amp;&amp; sourceURL.startsWith('/')) {</span><span class="s3">\n    </span><span class="s1">fileLocation = path.relative(process.cwd(), sourceURL)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">fileLocation = sourceURL</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return methodName</span><span class="s3">\n    </span><span class="s1">? `    at ${methodName} (${fileLocation}${sourceLocation})`</span><span class="s3">\n    </span><span class="s1">: `    at ${fileLocation}${sourceLocation}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function computeErrorName(error: Error): string {</span><span class="s3">\n  </span><span class="s1">// TODO: Node.js seems to use a different algorithm</span><span class="s3">\n  </span><span class="s1">// class ReadonlyRequestCookiesError extends Error {}` would read `ReadonlyRequestCookiesError: [...]`</span><span class="s3">\n  </span><span class="s1">// in the stack i.e. seems like under certain conditions it favors the constructor name.</span><span class="s3">\n  </span><span class="s1">return error.name || 'Error'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function prepareUnsourcemappedStackTrace(</span><span class="s3">\n  </span><span class="s1">error: Error,</span><span class="s3">\n  </span><span class="s1">structuredStackTrace: any[]</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">const name = computeErrorName(error)</span><span class="s3">\n  </span><span class="s1">const message = error.message || ''</span><span class="s3">\n  </span><span class="s1">let stack = name + ': ' + message</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; structuredStackTrace.length; i++) {</span><span class="s3">\n    </span><span class="s1">stack += '</span><span class="s3">\\</span><span class="s1">n    at ' + structuredStackTrace[i].toString()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return stack</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function shouldIgnoreListGeneratedFrame(file: string): boolean {</span><span class="s3">\n  </span><span class="s1">return file.startsWith('node:') || file.includes('node_modules')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function shouldIgnoreListOriginalFrame(file: string): boolean {</span><span class="s3">\n  </span><span class="s1">return file.includes('node_modules')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface SourcemappableStackFrame extends StackFrame {</span><span class="s3">\n  </span><span class="s1">file: NonNullable&lt;StackFrame['file']&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface SourceMappedFrame {</span><span class="s3">\n  </span><span class="s1">stack: IgnorableStackFrame</span><span class="s3">\n  </span><span class="s1">// DEV only</span><span class="s3">\n  </span><span class="s1">code: string | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createUnsourcemappedFrame(</span><span class="s3">\n  </span><span class="s1">frame: SourcemappableStackFrame</span><span class="s3">\n</span><span class="s1">): SourceMappedFrame {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">stack: {</span><span class="s3">\n      </span><span class="s1">file: frame.file,</span><span class="s3">\n      </span><span class="s1">line1: frame.line1,</span><span class="s3">\n      </span><span class="s1">column1: frame.column1,</span><span class="s3">\n      </span><span class="s1">methodName: frame.methodName,</span><span class="s3">\n      </span><span class="s1">arguments: frame.arguments,</span><span class="s3">\n      </span><span class="s1">ignored: shouldIgnoreListGeneratedFrame(frame.file),</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">code: null,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function ignoreListAnonymousStackFramesIfSandwiched(</span><span class="s3">\n  </span><span class="s1">sourceMappedFrames: Array&lt;{</span><span class="s3">\n    </span><span class="s1">stack: IgnorableStackFrame</span><span class="s3">\n    </span><span class="s1">code: string | null</span><span class="s3">\n  </span><span class="s1">}&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return ignoreListAnonymousStackFramesIfSandwichedGeneric(</span><span class="s3">\n    </span><span class="s1">sourceMappedFrames,</span><span class="s3">\n    </span><span class="s1">(frame) =&gt; frame.stack.file === '&lt;anonymous&gt;',</span><span class="s3">\n    </span><span class="s1">(frame) =&gt; frame.stack.ignored,</span><span class="s3">\n    </span><span class="s1">(frame) =&gt; frame.stack.methodName,</span><span class="s3">\n    </span><span class="s1">(frame) =&gt; {</span><span class="s3">\n      </span><span class="s1">frame.stack.ignored = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param frame</span><span class="s3">\n </span><span class="s1">* @param sourceMapCache</span><span class="s3">\n </span><span class="s1">* @returns The original frame if not sourcemapped.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getSourcemappedFrameIfPossible(</span><span class="s3">\n  </span><span class="s1">frame: SourcemappableStackFrame,</span><span class="s3">\n  </span><span class="s1">sourceMapCache: SourceMapCache,</span><span class="s3">\n  </span><span class="s1">inspectOptions: util.InspectOptions</span><span class="s3">\n</span><span class="s1">): {</span><span class="s3">\n  </span><span class="s1">stack: IgnorableStackFrame</span><span class="s3">\n  </span><span class="s1">code: string | null</span><span class="s3">\n</span><span class="s1">} {</span><span class="s3">\n  </span><span class="s1">const sourceMapCacheEntry = sourceMapCache.get(frame.file)</span><span class="s3">\n  </span><span class="s1">let sourceMapConsumer: SyncSourceMapConsumer</span><span class="s3">\n  </span><span class="s1">let sourceMapPayload: ModernSourceMapPayload</span><span class="s3">\n  </span><span class="s1">if (sourceMapCacheEntry === undefined) {</span><span class="s3">\n    </span><span class="s1">let sourceURL = frame.file</span><span class="s3">\n    </span><span class="s1">// e.g. </span><span class="s3">\&quot;</span><span class="s1">/APP/.next/server/chunks/ssr/[root-of-the-server]__2934a0._.js</span><span class="s3">\&quot;\n    </span><span class="s1">// will be keyed by Node.js as </span><span class="s3">\&quot;</span><span class="s1">file:///APP/.next/server/chunks/ssr/[root-of-the-server]__2934a0._.js</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n    </span><span class="s1">// This is likely caused by `callsite.toString()` in `Error.prepareStackTrace converting file URLs to paths.</span><span class="s3">\n    </span><span class="s1">if (sourceURL.startsWith('/')) {</span><span class="s3">\n      </span><span class="s1">sourceURL = url.pathToFileURL(frame.file).toString()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let maybeSourceMapPayload: ModernSourceMapPayload | undefined</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">const sourceMap = nativeFindSourceMap(sourceURL)</span><span class="s3">\n      </span><span class="s1">maybeSourceMapPayload = sourceMap?.payload</span><span class="s3">\n    </span><span class="s1">} catch (cause) {</span><span class="s3">\n      </span><span class="s1">// We should not log an actual error instance here because that will re-enter</span><span class="s3">\n      </span><span class="s1">// this codepath during error inspection and could lead to infinite recursion.</span><span class="s3">\n      </span><span class="s1">console.error(</span><span class="s3">\n        </span><span class="s1">`${sourceURL}: Invalid source map. Only conformant source maps can be used to find the original code. Cause: ${cause}`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">// If loading fails once, it'll fail every time.</span><span class="s3">\n      </span><span class="s1">// So set the cache to avoid duplicate errors.</span><span class="s3">\n      </span><span class="s1">sourceMapCache.set(frame.file, null)</span><span class="s3">\n      </span><span class="s1">// Don't even fall back to the bundler because it might be not as strict</span><span class="s3">\n      </span><span class="s1">// with regards to parsing and then we fail later once we consume the</span><span class="s3">\n      </span><span class="s1">// source map payload.</span><span class="s3">\n      </span><span class="s1">// This essentially avoids a redundant error where we fail here and then</span><span class="s3">\n      </span><span class="s1">// later on consumption because the bundler just handed back an invalid</span><span class="s3">\n      </span><span class="s1">// source map.</span><span class="s3">\n      </span><span class="s1">return createUnsourcemappedFrame(frame)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (maybeSourceMapPayload === undefined) {</span><span class="s3">\n      </span><span class="s1">maybeSourceMapPayload = bundlerFindSourceMapPayload(sourceURL)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (maybeSourceMapPayload === undefined) {</span><span class="s3">\n      </span><span class="s1">return createUnsourcemappedFrame(frame)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">sourceMapPayload = maybeSourceMapPayload</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">sourceMapConsumer = new SyncSourceMapConsumer(</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error -- Module.SourceMap['version'] is number but SyncSourceMapConsumer wants a string</span><span class="s3">\n        </span><span class="s1">sourceMapPayload</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} catch (cause) {</span><span class="s3">\n      </span><span class="s1">// We should not log an actual error instance here because that will re-enter</span><span class="s3">\n      </span><span class="s1">// this codepath during error inspection and could lead to infinite recursion.</span><span class="s3">\n      </span><span class="s1">console.error(</span><span class="s3">\n        </span><span class="s1">`${sourceURL}: Invalid source map. Only conformant source maps can be used to find the original code. Cause: ${cause}`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">// If creating the consumer fails once, it'll fail every time.</span><span class="s3">\n      </span><span class="s1">// So set the cache to avoid duplicate errors.</span><span class="s3">\n      </span><span class="s1">sourceMapCache.set(frame.file, null)</span><span class="s3">\n      </span><span class="s1">return createUnsourcemappedFrame(frame)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">sourceMapCache.set(frame.file, {</span><span class="s3">\n      </span><span class="s1">map: sourceMapConsumer,</span><span class="s3">\n      </span><span class="s1">payload: sourceMapPayload,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">} else if (sourceMapCacheEntry === null) {</span><span class="s3">\n    </span><span class="s1">// We failed earlier getting the payload or consumer.</span><span class="s3">\n    </span><span class="s1">// Just return an unsourcemapped frame.</span><span class="s3">\n    </span><span class="s1">// Errors will already be logged.</span><span class="s3">\n    </span><span class="s1">return createUnsourcemappedFrame(frame)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">sourceMapConsumer = sourceMapCacheEntry.map</span><span class="s3">\n    </span><span class="s1">sourceMapPayload = sourceMapCacheEntry.payload</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const sourcePosition = sourceMapConsumer.originalPositionFor({</span><span class="s3">\n    </span><span class="s1">column: (frame.column1 ?? 1) - 1,</span><span class="s3">\n    </span><span class="s1">line: frame.line1 ?? 1,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const applicableSourceMap = findApplicableSourceMapPayload(</span><span class="s3">\n    </span><span class="s1">(frame.line1 ?? 1) - 1,</span><span class="s3">\n    </span><span class="s1">(frame.column1 ?? 1) - 1,</span><span class="s3">\n    </span><span class="s1">sourceMapPayload</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">let ignored =</span><span class="s3">\n    </span><span class="s1">applicableSourceMap !== undefined &amp;&amp;</span><span class="s3">\n    </span><span class="s1">sourceMapIgnoreListsEverything(applicableSourceMap)</span><span class="s3">\n  </span><span class="s1">if (sourcePosition.source === null) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">stack: {</span><span class="s3">\n        </span><span class="s1">arguments: frame.arguments,</span><span class="s3">\n        </span><span class="s1">file: frame.file,</span><span class="s3">\n        </span><span class="s1">line1: frame.line1,</span><span class="s3">\n        </span><span class="s1">column1: frame.column1,</span><span class="s3">\n        </span><span class="s1">methodName: frame.methodName,</span><span class="s3">\n        </span><span class="s1">ignored: ignored || shouldIgnoreListGeneratedFrame(frame.file),</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">code: null,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// TODO(veil): Upstream a method to sourcemap consumer that immediately says if a frame is ignored or not.</span><span class="s3">\n  </span><span class="s1">if (applicableSourceMap === undefined) {</span><span class="s3">\n    </span><span class="s1">console.error('No applicable source map found in sections for frame', frame)</span><span class="s3">\n  </span><span class="s1">} else if (!ignored &amp;&amp; shouldIgnoreListOriginalFrame(sourcePosition.source)) {</span><span class="s3">\n    </span><span class="s1">// Externals may be libraries that don't ship ignoreLists.</span><span class="s3">\n    </span><span class="s1">// This is really taking control away from libraries.</span><span class="s3">\n    </span><span class="s1">// They should still ship `ignoreList` so that attached debuggers ignore-list their frames.</span><span class="s3">\n    </span><span class="s1">// TODO: Maybe only ignore library sourcemaps if `ignoreList` is absent?</span><span class="s3">\n    </span><span class="s1">// Though keep in mind that Turbopack omits empty `ignoreList`.</span><span class="s3">\n    </span><span class="s1">// So if we establish this convention, we should communicate it to the ecosystem.</span><span class="s3">\n    </span><span class="s1">ignored = true</span><span class="s3">\n  </span><span class="s1">} else if (!ignored) {</span><span class="s3">\n    </span><span class="s1">// TODO: O(n^2). Consider moving `ignoreList` into a Set</span><span class="s3">\n    </span><span class="s1">const sourceIndex = applicableSourceMap.sources.indexOf(</span><span class="s3">\n      </span><span class="s1">sourcePosition.source</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">ignored = applicableSourceMap.ignoreList?.includes(sourceIndex) ?? false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const originalFrame: IgnorableStackFrame = {</span><span class="s3">\n    </span><span class="s1">// We ignore the sourcemapped name since it won't be the correct name.</span><span class="s3">\n    </span><span class="s1">// The callsite will point to the column of the variable name instead of the</span><span class="s3">\n    </span><span class="s1">// name of the enclosing function.</span><span class="s3">\n    </span><span class="s1">// TODO(NDX-531): Spy on prepareStackTrace to get the enclosing line number for method name mapping.</span><span class="s3">\n    </span><span class="s1">methodName: frame.methodName</span><span class="s3">\n      </span><span class="s1">?.replace('__WEBPACK_DEFAULT_EXPORT__', 'default')</span><span class="s3">\n      </span><span class="s1">?.replace('__webpack_exports__.', ''),</span><span class="s3">\n    </span><span class="s1">file: sourcePosition.source,</span><span class="s3">\n    </span><span class="s1">line1: sourcePosition.line,</span><span class="s3">\n    </span><span class="s1">column1: sourcePosition.column + 1,</span><span class="s3">\n    </span><span class="s1">// TODO: c&amp;p from async createOriginalStackFrame but why not frame.arguments?</span><span class="s3">\n    </span><span class="s1">arguments: [],</span><span class="s3">\n    </span><span class="s1">ignored,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/** undefined = not yet computed*/</span><span class="s3">\n  </span><span class="s1">let codeFrame: string | null | undefined</span><span class="s3">\n\n  </span><span class="s1">return Object.defineProperty(</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">stack: originalFrame,</span><span class="s3">\n      </span><span class="s1">code: null,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">'code',</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">get: () =&gt; {</span><span class="s3">\n        </span><span class="s1">if (codeFrame === undefined) {</span><span class="s3">\n          </span><span class="s1">const sourceContent: string | null =</span><span class="s3">\n            </span><span class="s1">sourceMapConsumer.sourceContentFor(</span><span class="s3">\n              </span><span class="s1">sourcePosition.source,</span><span class="s3">\n              </span><span class="s1">/* returnNullOnMissing */ true</span><span class="s3">\n            </span><span class="s1">) ?? null</span><span class="s3">\n          </span><span class="s1">codeFrame = getOriginalCodeFrame(</span><span class="s3">\n            </span><span class="s1">originalFrame,</span><span class="s3">\n            </span><span class="s1">sourceContent,</span><span class="s3">\n            </span><span class="s1">inspectOptions.colors</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return codeFrame</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function parseAndSourceMap(</span><span class="s3">\n  </span><span class="s1">error: Error,</span><span class="s3">\n  </span><span class="s1">inspectOptions: util.InspectOptions</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">// TODO(veil): Expose as CLI arg or config option. Useful for local debugging.</span><span class="s3">\n  </span><span class="s1">const showIgnoreListed = false</span><span class="s3">\n  </span><span class="s1">// We overwrote Error.prepareStackTrace earlier so error.stack is not sourcemapped.</span><span class="s3">\n  </span><span class="s1">let unparsedStack = String(error.stack)</span><span class="s3">\n  </span><span class="s1">// We could just read it from `error.stack`.</span><span class="s3">\n  </span><span class="s1">// This works around cases where a 3rd party `Error.prepareStackTrace` implementation</span><span class="s3">\n  </span><span class="s1">// doesn't implement the name computation correctly.</span><span class="s3">\n  </span><span class="s1">const errorName = computeErrorName(error)</span><span class="s3">\n\n  </span><span class="s1">let idx = unparsedStack.indexOf('react_stack_bottom_frame')</span><span class="s3">\n  </span><span class="s1">if (idx !== -1) {</span><span class="s3">\n    </span><span class="s1">idx = unparsedStack.lastIndexOf('</span><span class="s3">\\</span><span class="s1">n', idx)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">idx = unparsedStack.indexOf('react-stack-bottom-frame')</span><span class="s3">\n    </span><span class="s1">if (idx !== -1) {</span><span class="s3">\n      </span><span class="s1">idx = unparsedStack.lastIndexOf('</span><span class="s3">\\</span><span class="s1">n', idx)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (idx !== -1 &amp;&amp; !showIgnoreListed) {</span><span class="s3">\n    </span><span class="s1">// Cut off everything after the bottom frame since it'll be React internals.</span><span class="s3">\n    </span><span class="s1">unparsedStack = unparsedStack.slice(0, idx)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const unsourcemappedStack = parseStack(unparsedStack)</span><span class="s3">\n  </span><span class="s1">const sourceMapCache: SourceMapCache = new Map()</span><span class="s3">\n\n  </span><span class="s1">const sourceMappedFrames: Array&lt;{</span><span class="s3">\n    </span><span class="s1">stack: IgnorableStackFrame</span><span class="s3">\n    </span><span class="s1">code: string | null</span><span class="s3">\n  </span><span class="s1">}&gt; = []</span><span class="s3">\n  </span><span class="s1">let sourceFrame: null | string = null</span><span class="s3">\n  </span><span class="s1">for (const frame of unsourcemappedStack) {</span><span class="s3">\n    </span><span class="s1">if (frame.file === null) {</span><span class="s3">\n      </span><span class="s1">sourceMappedFrames.push({</span><span class="s3">\n        </span><span class="s1">code: null,</span><span class="s3">\n        </span><span class="s1">stack: {</span><span class="s3">\n          </span><span class="s1">file: frame.file,</span><span class="s3">\n          </span><span class="s1">line1: frame.line1,</span><span class="s3">\n          </span><span class="s1">column1: frame.column1,</span><span class="s3">\n          </span><span class="s1">methodName: frame.methodName,</span><span class="s3">\n          </span><span class="s1">arguments: frame.arguments,</span><span class="s3">\n          </span><span class="s1">ignored: false,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const sourcemappedFrame = getSourcemappedFrameIfPossible(</span><span class="s3">\n        </span><span class="s1">// We narrowed this earlier by bailing if `frame.file` is null.</span><span class="s3">\n        </span><span class="s1">frame as SourcemappableStackFrame,</span><span class="s3">\n        </span><span class="s1">sourceMapCache,</span><span class="s3">\n        </span><span class="s1">inspectOptions</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">sourceMappedFrames.push(sourcemappedFrame)</span><span class="s3">\n\n      </span><span class="s1">// We can determine the sourceframe here.</span><span class="s3">\n      </span><span class="s1">// anonymous frames won't have a sourceframe so we don't need to scan</span><span class="s3">\n      </span><span class="s1">// all stacks again to check if they are sandwiched between ignored frames.</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">sourceFrame === null &amp;&amp;</span><span class="s3">\n        </span><span class="s1">// TODO: Is this the right choice?</span><span class="s3">\n        </span><span class="s1">!sourcemappedFrame.stack.ignored &amp;&amp;</span><span class="s3">\n        </span><span class="s1">sourcemappedFrame.code !== null</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">sourceFrame = sourcemappedFrame.code</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">ignoreListAnonymousStackFramesIfSandwiched(sourceMappedFrames)</span><span class="s3">\n\n  </span><span class="s1">let sourceMappedStack = ''</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; sourceMappedFrames.length; i++) {</span><span class="s3">\n    </span><span class="s1">const frame = sourceMappedFrames[i]</span><span class="s3">\n\n    </span><span class="s1">if (!frame.stack.ignored) {</span><span class="s3">\n      </span><span class="s1">sourceMappedStack +=</span><span class="s3">\n        </span><span class="s1">'</span><span class="s3">\\</span><span class="s1">n' +</span><span class="s3">\n        </span><span class="s1">frameToString(</span><span class="s3">\n          </span><span class="s1">frame.stack.methodName,</span><span class="s3">\n          </span><span class="s1">frame.stack.file,</span><span class="s3">\n          </span><span class="s1">frame.stack.line1,</span><span class="s3">\n          </span><span class="s1">frame.stack.column1</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (showIgnoreListed) {</span><span class="s3">\n      </span><span class="s1">sourceMappedStack +=</span><span class="s3">\n        </span><span class="s1">'</span><span class="s3">\\</span><span class="s1">n' +</span><span class="s3">\n        </span><span class="s1">dim(</span><span class="s3">\n          </span><span class="s1">frameToString(</span><span class="s3">\n            </span><span class="s1">frame.stack.methodName,</span><span class="s3">\n            </span><span class="s1">frame.stack.file,</span><span class="s3">\n            </span><span class="s1">frame.stack.line1,</span><span class="s3">\n            </span><span class="s1">frame.stack.column1</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">errorName +</span><span class="s3">\n    </span><span class="s1">': ' +</span><span class="s3">\n    </span><span class="s1">error.message +</span><span class="s3">\n    </span><span class="s1">sourceMappedStack +</span><span class="s3">\n    </span><span class="s1">(sourceFrame !== null ? '</span><span class="s3">\\</span><span class="s1">n' + sourceFrame : '')</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function sourceMapError(</span><span class="s3">\n  </span><span class="s1">this: void,</span><span class="s3">\n  </span><span class="s1">error: Error,</span><span class="s3">\n  </span><span class="s1">inspectOptions: util.InspectOptions</span><span class="s3">\n</span><span class="s1">): Error {</span><span class="s3">\n  </span><span class="s1">// Create a new Error object with the source mapping applied and then use native</span><span class="s3">\n  </span><span class="s1">// Node.js formatting on the result.</span><span class="s3">\n  </span><span class="s1">const newError =</span><span class="s3">\n    </span><span class="s1">error.cause !== undefined</span><span class="s3">\n      </span><span class="s1">? // Setting an undefined `cause` would print `[cause]: undefined`</span><span class="s3">\n        </span><span class="s1">new Error(error.message, { cause: error.cause })</span><span class="s3">\n      </span><span class="s1">: new Error(error.message)</span><span class="s3">\n\n  </span><span class="s1">// TODO: Ensure `class MyError extends Error {}` prints `MyError` as the name</span><span class="s3">\n  </span><span class="s1">newError.stack = parseAndSourceMap(error, inspectOptions)</span><span class="s3">\n\n  </span><span class="s1">for (const key in error) {</span><span class="s3">\n    </span><span class="s1">if (!Object.prototype.hasOwnProperty.call(newError, key)) {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error -- We're copying all enumerable properties.</span><span class="s3">\n      </span><span class="s1">// So they definitely exist on `this` and obviously have no type on `newError` (yet)</span><span class="s3">\n      </span><span class="s1">newError[key] = error[key]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return newError</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function patchErrorInspectNodeJS(</span><span class="s3">\n  </span><span class="s1">errorConstructor: ErrorConstructor</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const inspectSymbol = Symbol.for('nodejs.util.inspect.custom')</span><span class="s3">\n\n  </span><span class="s1">errorConstructor.prepareStackTrace = prepareUnsourcemappedStackTrace</span><span class="s3">\n\n  </span><span class="s1">// @ts-expect-error -- TODO upstream types</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line no-extend-native -- We're not extending but overriding.</span><span class="s3">\n  </span><span class="s1">errorConstructor.prototype[inspectSymbol] = function (</span><span class="s3">\n    </span><span class="s1">depth: number,</span><span class="s3">\n    </span><span class="s1">inspectOptions: util.InspectOptions,</span><span class="s3">\n    </span><span class="s1">inspect: typeof util.inspect</span><span class="s3">\n  </span><span class="s1">): string {</span><span class="s3">\n    </span><span class="s1">// avoid false-positive dynamic i/o warnings e.g. due to usage of `Math.random` in `source-map`.</span><span class="s3">\n    </span><span class="s1">return workUnitAsyncStorage.exit(() =&gt; {</span><span class="s3">\n      </span><span class="s1">const newError = sourceMapError(this, inspectOptions)</span><span class="s3">\n\n      </span><span class="s1">const originalCustomInspect = (newError as any)[inspectSymbol]</span><span class="s3">\n      </span><span class="s1">// Prevent infinite recursion.</span><span class="s3">\n      </span><span class="s1">// { customInspect: false } would result in `error.cause` not using our inspect.</span><span class="s3">\n      </span><span class="s1">Object.defineProperty(newError, inspectSymbol, {</span><span class="s3">\n        </span><span class="s1">value: undefined,</span><span class="s3">\n        </span><span class="s1">enumerable: false,</span><span class="s3">\n        </span><span class="s1">writable: true,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">return inspect(newError, {</span><span class="s3">\n          </span><span class="s1">...inspectOptions,</span><span class="s3">\n          </span><span class="s1">depth:</span><span class="s3">\n            </span><span class="s1">(inspectOptions.depth ??</span><span class="s3">\n              </span><span class="s1">// Default in Node.js</span><span class="s3">\n              </span><span class="s1">2) - depth,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">;(newError as any)[inspectSymbol] = originalCustomInspect</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function patchErrorInspectEdgeLite(</span><span class="s3">\n  </span><span class="s1">errorConstructor: ErrorConstructor</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const inspectSymbol = Symbol.for('edge-runtime.inspect.custom')</span><span class="s3">\n\n  </span><span class="s1">errorConstructor.prepareStackTrace = prepareUnsourcemappedStackTrace</span><span class="s3">\n\n  </span><span class="s1">// @ts-expect-error -- TODO upstream types</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line no-extend-native -- We're not extending but overriding.</span><span class="s3">\n  </span><span class="s1">errorConstructor.prototype[inspectSymbol] = function ({</span><span class="s3">\n    </span><span class="s1">format,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">format: (...args: unknown[]) =&gt; string</span><span class="s3">\n  </span><span class="s1">}): string {</span><span class="s3">\n    </span><span class="s1">// avoid false-positive dynamic i/o warnings e.g. due to usage of `Math.random` in `source-map`.</span><span class="s3">\n    </span><span class="s1">return workUnitAsyncStorage.exit(() =&gt; {</span><span class="s3">\n      </span><span class="s1">const newError = sourceMapError(this, {})</span><span class="s3">\n\n      </span><span class="s1">const originalCustomInspect = (newError as any)[inspectSymbol]</span><span class="s3">\n      </span><span class="s1">// Prevent infinite recursion.</span><span class="s3">\n      </span><span class="s1">Object.defineProperty(newError, inspectSymbol, {</span><span class="s3">\n        </span><span class="s1">value: undefined,</span><span class="s3">\n        </span><span class="s1">enumerable: false,</span><span class="s3">\n        </span><span class="s1">writable: true,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">return format(newError)</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">;(newError as any)[inspectSymbol] = originalCustomInspect</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;patchErrorInspectEdgeLite&quot;</span><span class="s0">,</span><span class="s1">&quot;patchErrorInspectNodeJS&quot;</span><span class="s0">,</span><span class="s1">&quot;setBundlerFindSourceMapImplementation&quot;</span><span class="s0">,</span><span class="s1">&quot;bundlerFindSourceMapPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;findSourceMapImplementation&quot;</span><span class="s0">,</span><span class="s1">&quot;frameToString&quot;</span><span class="s0">,</span><span class="s1">&quot;methodName&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceURL&quot;</span><span class="s0">,</span><span class="s1">&quot;line1&quot;</span><span class="s0">,</span><span class="s1">&quot;column1&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;fileLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;canParse&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;relative&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;cwd&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;fileURLToPath&quot;</span><span class="s0">,</span><span class="s1">&quot;computeErrorName&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;prepareUnsourcemappedStackTrace&quot;</span><span class="s0">,</span><span class="s1">&quot;structuredStackTrace&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;stack&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldIgnoreListGeneratedFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldIgnoreListOriginalFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;createUnsourcemappedFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;frame&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;ignored&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreListAnonymousStackFramesIfSandwiched&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceMappedFrames&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreListAnonymousStackFramesIfSandwichedGeneric&quot;</span><span class="s0">,</span><span class="s1">&quot;getSourcemappedFrameIfPossible&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceMapCache&quot;</span><span class="s0">,</span><span class="s1">&quot;inspectOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceMapCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceMapConsumer&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceMapPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;pathToFileURL&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeSourceMapPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceMap&quot;</span><span class="s0">,</span><span class="s1">&quot;nativeFindSourceMap&quot;</span><span class="s0">,</span><span class="s1">&quot;payload&quot;</span><span class="s0">,</span><span class="s1">&quot;cause&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;SyncSourceMapConsumer&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcePosition&quot;</span><span class="s0">,</span><span class="s1">&quot;originalPositionFor&quot;</span><span class="s0">,</span><span class="s1">&quot;column&quot;</span><span class="s0">,</span><span class="s1">&quot;line&quot;</span><span class="s0">,</span><span class="s1">&quot;applicableSourceMap&quot;</span><span class="s0">,</span><span class="s1">&quot;findApplicableSourceMapPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceMapIgnoreListsEverything&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">,</span><span class="s1">&quot;originalFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;codeFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceContent&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceContentFor&quot;</span><span class="s0">,</span><span class="s1">&quot;getOriginalCodeFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;colors&quot;</span><span class="s0">,</span><span class="s1">&quot;parseAndSourceMap&quot;</span><span class="s0">,</span><span class="s1">&quot;showIgnoreListed&quot;</span><span class="s0">,</span><span class="s1">&quot;unparsedStack&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;errorName&quot;</span><span class="s0">,</span><span class="s1">&quot;idx&quot;</span><span class="s0">,</span><span class="s1">&quot;lastIndexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;unsourcemappedStack&quot;</span><span class="s0">,</span><span class="s1">&quot;parseStack&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcemappedFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceMappedStack&quot;</span><span class="s0">,</span><span class="s1">&quot;dim&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceMapError&quot;</span><span class="s0">,</span><span class="s1">&quot;newError&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;errorConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;inspectSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;for&quot;</span><span class="s0">,</span><span class="s1">&quot;prepareStackTrace&quot;</span><span class="s0">,</span><span class="s1">&quot;depth&quot;</span><span class="s0">,</span><span class="s1">&quot;inspect&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;exit&quot;</span><span class="s0">,</span><span class="s1">&quot;originalCustomInspect&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;enumerable&quot;</span><span class="s0">,</span><span class="s1">&quot;writable&quot;</span><span class="s0">,</span><span class="s1">&quot;format&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>