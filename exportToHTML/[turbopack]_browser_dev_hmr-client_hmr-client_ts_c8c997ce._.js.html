<html>
<head>
<title>[turbopack]_browser_dev_hmr-client_hmr-client_ts_c8c997ce._.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #0033b3;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
[turbopack]_browser_dev_hmr-client_hmr-client_ts_c8c997ce._.js</font>
</center></td></tr></table>
<pre><span class="s0">(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([</span><span class="s1">typeof </span><span class="s0">document === </span><span class="s2">&quot;object&quot; </span><span class="s0">? document.currentScript : undefined,</span>
<span class="s2">&quot;[turbopack]/browser/dev/hmr-client/hmr-client.ts [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s3">/// &lt;reference path=&quot;../../../shared/runtime-types.d.ts&quot; /&gt;</span>
<span class="s3">/// &lt;reference path=&quot;../../runtime/base/dev-globals.d.ts&quot; /&gt;</span>
<span class="s3">/// &lt;reference path=&quot;../../runtime/base/dev-protocol.d.ts&quot; /&gt;</span>
<span class="s3">/// &lt;reference path=&quot;../../runtime/base/dev-extensions.ts&quot; /&gt;</span>
<span class="s0">__turbopack_context__.s([</span>
    <span class="s2">&quot;connect&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;connect,</span>
    <span class="s2">&quot;setHooks&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;setHooks,</span>
    <span class="s2">&quot;subscribeToUpdate&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;subscribeToUpdate</span>
<span class="s0">]);</span>
<span class="s1">function </span><span class="s0">connect(param) {</span>
    <span class="s1">let </span><span class="s0">{ addMessageListener, sendMessage, onUpdateError = console.error } = param;</span>
    <span class="s0">addMessageListener((msg)=&gt;{</span>
        <span class="s1">switch</span><span class="s0">(msg.type){</span>
            <span class="s1">case </span><span class="s2">'turbopack-connected'</span><span class="s0">:</span>
                <span class="s0">handleSocketConnected(sendMessage);</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s1">default</span><span class="s0">:</span>
                <span class="s1">try </span><span class="s0">{</span>
                    <span class="s1">if </span><span class="s0">(Array.isArray(msg.data)) {</span>
                        <span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; msg.data.length; i++){</span>
                            <span class="s0">handleSocketMessage(msg.data[i]);</span>
                        <span class="s0">}</span>
                    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                        <span class="s0">handleSocketMessage(msg.data);</span>
                    <span class="s0">}</span>
                    <span class="s0">applyAggregatedUpdates();</span>
                <span class="s0">} </span><span class="s1">catch </span><span class="s0">(e) {</span>
                    <span class="s0">console.warn(</span><span class="s2">'[Fast Refresh] performing full reload</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s0">+ </span><span class="s2">&quot;Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s0">+ </span><span class="s2">'You might have a file which exports a React component but also exports a value that is imported by a non-React component file.</span><span class="s5">\n</span><span class="s2">' </span><span class="s0">+ </span><span class="s2">'Consider migrating the non-React component export to a separate file and importing it into both files.</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s0">+ </span><span class="s2">'It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.</span><span class="s5">\n</span><span class="s2">' </span><span class="s0">+ </span><span class="s2">'Fast Refresh requires at least one parent function component in your React tree.'</span><span class="s0">);</span>
                    <span class="s0">onUpdateError(e);</span>
                    <span class="s0">location.reload();</span>
                <span class="s0">}</span>
                <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s1">const </span><span class="s0">queued = globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS;</span>
    <span class="s1">if </span><span class="s0">(queued != </span><span class="s1">null </span><span class="s0">&amp;&amp; !Array.isArray(queued)) {</span>
        <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'A separate HMR handler was already registered'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s0">globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS = {</span>
        <span class="s0">push: (param)=&gt;{</span>
            <span class="s1">let </span><span class="s0">[chunkPath, callback] = param;</span>
            <span class="s0">subscribeToChunkUpdate(chunkPath, sendMessage, callback);</span>
        <span class="s0">}</span>
    <span class="s0">};</span>
    <span class="s1">if </span><span class="s0">(Array.isArray(queued)) {</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">[chunkPath, callback] of queued){</span>
            <span class="s0">subscribeToChunkUpdate(chunkPath, sendMessage, callback);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">updateCallbackSets = </span><span class="s1">new </span><span class="s0">Map();</span>
<span class="s1">function </span><span class="s0">sendJSON(sendMessage, message) {</span>
    <span class="s0">sendMessage(JSON.stringify(message));</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">resourceKey(resource) {</span>
    <span class="s1">return </span><span class="s0">JSON.stringify({</span>
        <span class="s0">path: resource.path,</span>
        <span class="s0">headers: resource.headers || </span><span class="s1">null</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">subscribeToUpdates(sendMessage, resource) {</span>
    <span class="s0">sendJSON(sendMessage, {</span>
        <span class="s0">type: </span><span class="s2">'turbopack-subscribe'</span><span class="s0">,</span>
        <span class="s0">...resource</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">()=&gt;{</span>
        <span class="s0">sendJSON(sendMessage, {</span>
            <span class="s0">type: </span><span class="s2">'turbopack-unsubscribe'</span><span class="s0">,</span>
            <span class="s0">...resource</span>
        <span class="s0">});</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">handleSocketConnected(sendMessage) {</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key of updateCallbackSets.keys()){</span>
        <span class="s0">subscribeToUpdates(sendMessage, JSON.parse(key));</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s3">// we aggregate all pending updates until the issues are resolved</span>
<span class="s1">const </span><span class="s0">chunkListsWithPendingUpdates = </span><span class="s1">new </span><span class="s0">Map();</span>
<span class="s1">function </span><span class="s0">aggregateUpdates(msg) {</span>
    <span class="s1">const </span><span class="s0">key = resourceKey(msg.resource);</span>
    <span class="s1">let </span><span class="s0">aggregated = chunkListsWithPendingUpdates.get(key);</span>
    <span class="s1">if </span><span class="s0">(aggregated) {</span>
        <span class="s0">aggregated.instruction = mergeChunkListUpdates(aggregated.instruction, msg.instruction);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">chunkListsWithPendingUpdates.set(key, msg);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">applyAggregatedUpdates() {</span>
    <span class="s1">if </span><span class="s0">(chunkListsWithPendingUpdates.size === </span><span class="s4">0</span><span class="s0">) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s0">hooks.beforeRefresh();</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">msg of chunkListsWithPendingUpdates.values()){</span>
        <span class="s0">triggerUpdate(msg);</span>
    <span class="s0">}</span>
    <span class="s0">chunkListsWithPendingUpdates.clear();</span>
    <span class="s0">finalizeUpdate();</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">mergeChunkListUpdates(updateA, updateB) {</span>
    <span class="s1">let </span><span class="s0">chunks;</span>
    <span class="s1">if </span><span class="s0">(updateA.chunks != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">if </span><span class="s0">(updateB.chunks == </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">chunks = updateA.chunks;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">chunks = mergeChunkListChunks(updateA.chunks, updateB.chunks);</span>
        <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(updateB.chunks != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">chunks = updateB.chunks;</span>
    <span class="s0">}</span>
    <span class="s1">let </span><span class="s0">merged;</span>
    <span class="s1">if </span><span class="s0">(updateA.merged != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">if </span><span class="s0">(updateB.merged == </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">merged = updateA.merged;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s3">// Since `merged` is an array of updates, we need to merge them all into</span>
            <span class="s3">// one, consistent update.</span>
            <span class="s3">// Since there can only be `EcmascriptMergeUpdates` in the array, there is</span>
            <span class="s3">// no need to key on the `type` field.</span>
            <span class="s1">let </span><span class="s0">update = updateA.merged[</span><span class="s4">0</span><span class="s0">];</span>
            <span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">1</span><span class="s0">; i &lt; updateA.merged.length; i++){</span>
                <span class="s0">update = mergeChunkListEcmascriptMergedUpdates(update, updateA.merged[i]);</span>
            <span class="s0">}</span>
            <span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; updateB.merged.length; i++){</span>
                <span class="s0">update = mergeChunkListEcmascriptMergedUpdates(update, updateB.merged[i]);</span>
            <span class="s0">}</span>
            <span class="s0">merged = [</span>
                <span class="s0">update</span>
            <span class="s0">];</span>
        <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(updateB.merged != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">merged = updateB.merged;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">type: </span><span class="s2">'ChunkListUpdate'</span><span class="s0">,</span>
        <span class="s0">chunks,</span>
        <span class="s0">merged</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">mergeChunkListChunks(chunksA, chunksB) {</span>
    <span class="s1">const </span><span class="s0">chunks = {};</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">[chunkPath, chunkUpdateA] of Object.entries(chunksA)){</span>
        <span class="s1">const </span><span class="s0">chunkUpdateB = chunksB[chunkPath];</span>
        <span class="s1">if </span><span class="s0">(chunkUpdateB != </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">const </span><span class="s0">mergedUpdate = mergeChunkUpdates(chunkUpdateA, chunkUpdateB);</span>
            <span class="s1">if </span><span class="s0">(mergedUpdate != </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s0">chunks[chunkPath] = mergedUpdate;</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">chunks[chunkPath] = chunkUpdateA;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">[chunkPath, chunkUpdateB] of Object.entries(chunksB)){</span>
        <span class="s1">if </span><span class="s0">(chunks[chunkPath] == </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">chunks[chunkPath] = chunkUpdateB;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">chunks;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">mergeChunkUpdates(updateA, updateB) {</span>
    <span class="s1">if </span><span class="s0">(updateA.type === </span><span class="s2">'added' </span><span class="s0">&amp;&amp; updateB.type === </span><span class="s2">'deleted' </span><span class="s0">|| updateA.type === </span><span class="s2">'deleted' </span><span class="s0">&amp;&amp; updateB.type === </span><span class="s2">'added'</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">undefined;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(updateA.type === </span><span class="s2">'partial'</span><span class="s0">) {</span>
        <span class="s0">invariant(updateA.instruction, </span><span class="s2">'Partial updates are unsupported'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(updateB.type === </span><span class="s2">'partial'</span><span class="s0">) {</span>
        <span class="s0">invariant(updateB.instruction, </span><span class="s2">'Partial updates are unsupported'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">undefined;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">mergeChunkListEcmascriptMergedUpdates(mergedA, mergedB) {</span>
    <span class="s1">const </span><span class="s0">entries = mergeEcmascriptChunkEntries(mergedA.entries, mergedB.entries);</span>
    <span class="s1">const </span><span class="s0">chunks = mergeEcmascriptChunksUpdates(mergedA.chunks, mergedB.chunks);</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">type: </span><span class="s2">'EcmascriptMergedUpdate'</span><span class="s0">,</span>
        <span class="s0">entries,</span>
        <span class="s0">chunks</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">mergeEcmascriptChunkEntries(entriesA, entriesB) {</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">...entriesA,</span>
        <span class="s0">...entriesB</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">mergeEcmascriptChunksUpdates(chunksA, chunksB) {</span>
    <span class="s1">if </span><span class="s0">(chunksA == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">chunksB;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(chunksB == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">chunksA;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">chunks = {};</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">[chunkPath, chunkUpdateA] of Object.entries(chunksA)){</span>
        <span class="s1">const </span><span class="s0">chunkUpdateB = chunksB[chunkPath];</span>
        <span class="s1">if </span><span class="s0">(chunkUpdateB != </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">const </span><span class="s0">mergedUpdate = mergeEcmascriptChunkUpdates(chunkUpdateA, chunkUpdateB);</span>
            <span class="s1">if </span><span class="s0">(mergedUpdate != </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s0">chunks[chunkPath] = mergedUpdate;</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">chunks[chunkPath] = chunkUpdateA;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">[chunkPath, chunkUpdateB] of Object.entries(chunksB)){</span>
        <span class="s1">if </span><span class="s0">(chunks[chunkPath] == </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">chunks[chunkPath] = chunkUpdateB;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(Object.keys(chunks).length === </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">undefined;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">chunks;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">mergeEcmascriptChunkUpdates(updateA, updateB) {</span>
    <span class="s1">if </span><span class="s0">(updateA.type === </span><span class="s2">'added' </span><span class="s0">&amp;&amp; updateB.type === </span><span class="s2">'deleted'</span><span class="s0">) {</span>
        <span class="s3">// These two completely cancel each other out.</span>
        <span class="s1">return </span><span class="s0">undefined;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(updateA.type === </span><span class="s2">'deleted' </span><span class="s0">&amp;&amp; updateB.type === </span><span class="s2">'added'</span><span class="s0">) {</span>
        <span class="s1">const </span><span class="s0">added = [];</span>
        <span class="s1">const </span><span class="s0">deleted = [];</span>
        <span class="s1">var </span><span class="s0">_updateA_modules;</span>
        <span class="s1">const </span><span class="s0">deletedModules = </span><span class="s1">new </span><span class="s0">Set((_updateA_modules = updateA.modules) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _updateA_modules !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _updateA_modules : []);</span>
        <span class="s1">var </span><span class="s0">_updateB_modules;</span>
        <span class="s1">const </span><span class="s0">addedModules = </span><span class="s1">new </span><span class="s0">Set((_updateB_modules = updateB.modules) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _updateB_modules !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _updateB_modules : []);</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">moduleId of addedModules){</span>
            <span class="s1">if </span><span class="s0">(!deletedModules.has(moduleId)) {</span>
                <span class="s0">added.push(moduleId);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">moduleId of deletedModules){</span>
            <span class="s1">if </span><span class="s0">(!addedModules.has(moduleId)) {</span>
                <span class="s0">deleted.push(moduleId);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(added.length === </span><span class="s4">0 </span><span class="s0">&amp;&amp; deleted.length === </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">undefined;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">'partial'</span><span class="s0">,</span>
            <span class="s0">added,</span>
            <span class="s0">deleted</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(updateA.type === </span><span class="s2">'partial' </span><span class="s0">&amp;&amp; updateB.type === </span><span class="s2">'partial'</span><span class="s0">) {</span>
        <span class="s1">var </span><span class="s0">_updateA_added, _updateB_added;</span>
        <span class="s1">const </span><span class="s0">added = </span><span class="s1">new </span><span class="s0">Set([</span>
            <span class="s0">...(_updateA_added = updateA.added) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _updateA_added !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _updateA_added : [],</span>
            <span class="s0">...(_updateB_added = updateB.added) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _updateB_added !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _updateB_added : []</span>
        <span class="s0">]);</span>
        <span class="s1">var </span><span class="s0">_updateA_deleted, _updateB_deleted;</span>
        <span class="s1">const </span><span class="s0">deleted = </span><span class="s1">new </span><span class="s0">Set([</span>
            <span class="s0">...(_updateA_deleted = updateA.deleted) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _updateA_deleted !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _updateA_deleted : [],</span>
            <span class="s0">...(_updateB_deleted = updateB.deleted) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _updateB_deleted !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _updateB_deleted : []</span>
        <span class="s0">]);</span>
        <span class="s1">if </span><span class="s0">(updateB.added != </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">moduleId of updateB.added){</span>
                <span class="s0">deleted.delete(moduleId);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(updateB.deleted != </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">moduleId of updateB.deleted){</span>
                <span class="s0">added.delete(moduleId);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">'partial'</span><span class="s0">,</span>
            <span class="s0">added: [</span>
                <span class="s0">...added</span>
            <span class="s0">],</span>
            <span class="s0">deleted: [</span>
                <span class="s0">...deleted</span>
            <span class="s0">]</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(updateA.type === </span><span class="s2">'added' </span><span class="s0">&amp;&amp; updateB.type === </span><span class="s2">'partial'</span><span class="s0">) {</span>
        <span class="s1">var </span><span class="s0">_updateA_modules1, _updateB_added1;</span>
        <span class="s1">const </span><span class="s0">modules = </span><span class="s1">new </span><span class="s0">Set([</span>
            <span class="s0">...(_updateA_modules1 = updateA.modules) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _updateA_modules1 !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _updateA_modules1 : [],</span>
            <span class="s0">...(_updateB_added1 = updateB.added) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _updateB_added1 !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _updateB_added1 : []</span>
        <span class="s0">]);</span>
        <span class="s1">var </span><span class="s0">_updateB_deleted1;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">moduleId of (_updateB_deleted1 = updateB.deleted) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _updateB_deleted1 !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _updateB_deleted1 : []){</span>
            <span class="s0">modules.delete(moduleId);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">'added'</span><span class="s0">,</span>
            <span class="s0">modules: [</span>
                <span class="s0">...modules</span>
            <span class="s0">]</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(updateA.type === </span><span class="s2">'partial' </span><span class="s0">&amp;&amp; updateB.type === </span><span class="s2">'deleted'</span><span class="s0">) {</span>
        <span class="s1">var </span><span class="s0">_updateB_modules1;</span>
        <span class="s3">// We could eagerly return `updateB` here, but this would potentially be</span>
        <span class="s3">// incorrect if `updateA` has added modules.</span>
        <span class="s1">const </span><span class="s0">modules = </span><span class="s1">new </span><span class="s0">Set((_updateB_modules1 = updateB.modules) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _updateB_modules1 !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _updateB_modules1 : []);</span>
        <span class="s1">if </span><span class="s0">(updateA.added != </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">moduleId of updateA.added){</span>
                <span class="s0">modules.delete(moduleId);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">'deleted'</span><span class="s0">,</span>
            <span class="s0">modules: [</span>
                <span class="s0">...modules</span>
            <span class="s0">]</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s3">// Any other update combination is invalid.</span>
    <span class="s1">return </span><span class="s0">undefined;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">invariant(_, message) {</span>
    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Invariant: &quot;</span><span class="s0">.concat(message));</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">CRITICAL = [</span>
    <span class="s2">'bug'</span><span class="s0">,</span>
    <span class="s2">'error'</span><span class="s0">,</span>
    <span class="s2">'fatal'</span>
<span class="s0">];</span>
<span class="s1">function </span><span class="s0">compareByList(list, a, b) {</span>
    <span class="s1">const </span><span class="s0">aI = list.indexOf(a) + </span><span class="s4">1 </span><span class="s0">|| list.length;</span>
    <span class="s1">const </span><span class="s0">bI = list.indexOf(b) + </span><span class="s4">1 </span><span class="s0">|| list.length;</span>
    <span class="s1">return </span><span class="s0">aI - bI;</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">chunksWithIssues = </span><span class="s1">new </span><span class="s0">Map();</span>
<span class="s1">function </span><span class="s0">emitIssues() {</span>
    <span class="s1">const </span><span class="s0">issues = [];</span>
    <span class="s1">const </span><span class="s0">deduplicationSet = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">[_, chunkIssues] of chunksWithIssues){</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">chunkIssue of chunkIssues){</span>
            <span class="s1">if </span><span class="s0">(deduplicationSet.has(chunkIssue.formatted)) </span><span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">issues.push(chunkIssue);</span>
            <span class="s0">deduplicationSet.add(chunkIssue.formatted);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">sortIssues(issues);</span>
    <span class="s0">hooks.issues(issues);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">handleIssues(msg) {</span>
    <span class="s1">const </span><span class="s0">key = resourceKey(msg.resource);</span>
    <span class="s1">let </span><span class="s0">hasCriticalIssues = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">issue of msg.issues){</span>
        <span class="s1">if </span><span class="s0">(CRITICAL.includes(issue.severity)) {</span>
            <span class="s0">hasCriticalIssues = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(msg.issues.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s0">chunksWithIssues.set(key, msg.issues);</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(chunksWithIssues.has(key)) {</span>
        <span class="s0">chunksWithIssues.delete(key);</span>
    <span class="s0">}</span>
    <span class="s0">emitIssues();</span>
    <span class="s1">return </span><span class="s0">hasCriticalIssues;</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">SEVERITY_ORDER = [</span>
    <span class="s2">'bug'</span><span class="s0">,</span>
    <span class="s2">'fatal'</span><span class="s0">,</span>
    <span class="s2">'error'</span><span class="s0">,</span>
    <span class="s2">'warning'</span><span class="s0">,</span>
    <span class="s2">'info'</span><span class="s0">,</span>
    <span class="s2">'log'</span>
<span class="s0">];</span>
<span class="s1">const </span><span class="s0">CATEGORY_ORDER = [</span>
    <span class="s2">'parse'</span><span class="s0">,</span>
    <span class="s2">'resolve'</span><span class="s0">,</span>
    <span class="s2">'code generation'</span><span class="s0">,</span>
    <span class="s2">'rendering'</span><span class="s0">,</span>
    <span class="s2">'typescript'</span><span class="s0">,</span>
    <span class="s2">'other'</span>
<span class="s0">];</span>
<span class="s1">function </span><span class="s0">sortIssues(issues) {</span>
    <span class="s0">issues.sort((a, b)=&gt;{</span>
        <span class="s1">const </span><span class="s0">first = compareByList(SEVERITY_ORDER, a.severity, b.severity);</span>
        <span class="s1">if </span><span class="s0">(first !== </span><span class="s4">0</span><span class="s0">) </span><span class="s1">return </span><span class="s0">first;</span>
        <span class="s1">return </span><span class="s0">compareByList(CATEGORY_ORDER, a.category, b.category);</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">hooks = {</span>
    <span class="s0">beforeRefresh: ()=&gt;{},</span>
    <span class="s0">refresh: ()=&gt;{},</span>
    <span class="s0">buildOk: ()=&gt;{},</span>
    <span class="s0">issues: (_issues)=&gt;{}</span>
<span class="s0">};</span>
<span class="s1">function </span><span class="s0">setHooks(newHooks) {</span>
    <span class="s0">Object.assign(hooks, newHooks);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">handleSocketMessage(msg) {</span>
    <span class="s0">sortIssues(msg.issues);</span>
    <span class="s0">handleIssues(msg);</span>
    <span class="s1">switch</span><span class="s0">(msg.type){</span>
        <span class="s1">case </span><span class="s2">'issues'</span><span class="s0">:</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">'partial'</span><span class="s0">:</span>
            <span class="s3">// aggregate updates</span>
            <span class="s0">aggregateUpdates(msg);</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s1">default</span><span class="s0">:</span>
            <span class="s3">// run single update</span>
            <span class="s1">const </span><span class="s0">runHooks = chunkListsWithPendingUpdates.size === </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(runHooks) hooks.beforeRefresh();</span>
            <span class="s0">triggerUpdate(msg);</span>
            <span class="s1">if </span><span class="s0">(runHooks) finalizeUpdate();</span>
            <span class="s1">break</span><span class="s0">;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">finalizeUpdate() {</span>
    <span class="s0">hooks.refresh();</span>
    <span class="s0">hooks.buildOk();</span>
    <span class="s3">// This is used by the Next.js integration test suite to notify it when HMR</span>
    <span class="s3">// updates have been completed.</span>
    <span class="s3">// TODO: Only run this in test environments (gate by `process.env.__NEXT_TEST_MODE`)</span>
    <span class="s1">if </span><span class="s0">(globalThis.__NEXT_HMR_CB) {</span>
        <span class="s0">globalThis.__NEXT_HMR_CB();</span>
        <span class="s0">globalThis.__NEXT_HMR_CB = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">subscribeToChunkUpdate(chunkListPath, sendMessage, callback) {</span>
    <span class="s1">return </span><span class="s0">subscribeToUpdate({</span>
        <span class="s0">path: chunkListPath</span>
    <span class="s0">}, sendMessage, callback);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">subscribeToUpdate(resource, sendMessage, callback) {</span>
    <span class="s1">const </span><span class="s0">key = resourceKey(resource);</span>
    <span class="s1">let </span><span class="s0">callbackSet;</span>
    <span class="s1">const </span><span class="s0">existingCallbackSet = updateCallbackSets.get(key);</span>
    <span class="s1">if </span><span class="s0">(!existingCallbackSet) {</span>
        <span class="s0">callbackSet = {</span>
            <span class="s0">callbacks: </span><span class="s1">new </span><span class="s0">Set([</span>
                <span class="s0">callback</span>
            <span class="s0">]),</span>
            <span class="s0">unsubscribe: subscribeToUpdates(sendMessage, resource)</span>
        <span class="s0">};</span>
        <span class="s0">updateCallbackSets.set(key, callbackSet);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">existingCallbackSet.callbacks.add(callback);</span>
        <span class="s0">callbackSet = existingCallbackSet;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">()=&gt;{</span>
        <span class="s0">callbackSet.callbacks.delete(callback);</span>
        <span class="s1">if </span><span class="s0">(callbackSet.callbacks.size === </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s0">callbackSet.unsubscribe();</span>
            <span class="s0">updateCallbackSets.delete(key);</span>
        <span class="s0">}</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">triggerUpdate(msg) {</span>
    <span class="s1">const </span><span class="s0">key = resourceKey(msg.resource);</span>
    <span class="s1">const </span><span class="s0">callbackSet = updateCallbackSets.get(key);</span>
    <span class="s1">if </span><span class="s0">(!callbackSet) {</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">callback of callbackSet.callbacks){</span>
        <span class="s0">callback(msg);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(msg.type === </span><span class="s2">'notFound'</span><span class="s0">) {</span>
        <span class="s3">// This indicates that the resource which we subscribed to either does not exist or</span>
        <span class="s3">// has been deleted. In either case, we should clear all update callbacks, so if a</span>
        <span class="s3">// new subscription is created for the same resource, it will send a new &quot;subscribe&quot;</span>
        <span class="s3">// message to the server.</span>
        <span class="s3">// No need to send an &quot;unsubscribe&quot; message to the server, it will have already</span>
        <span class="s3">// dropped the update stream before sending the &quot;notFound&quot; message.</span>
        <span class="s0">updateCallbackSets.delete(key);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">}),</span>
<span class="s0">]);</span>

<span class="s3">//# sourceMappingURL=%5Bturbopack%5D_browser_dev_hmr-client_hmr-client_ts_c8c997ce._.js.map</span></pre>
</body>
</html>