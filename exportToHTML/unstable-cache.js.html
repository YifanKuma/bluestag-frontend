<html>
<head>
<title>unstable-cache.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
unstable-cache.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;unstable_cache&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">unstable_cache;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_constants = require(</span><span class="s0">&quot;../../../lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_patchfetch = require(</span><span class="s0">&quot;../../lib/patch-fetch&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_workasyncstorageexternal = require(</span><span class="s0">&quot;../../app-render/work-async-storage.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_workunitasyncstorageexternal = require(</span><span class="s0">&quot;../../app-render/work-unit-async-storage.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_responsecache = require(</span><span class="s0">&quot;../../response-cache&quot;</span><span class="s1">);</span>
<span class="s2">let </span><span class="s1">noStoreFetchIdx = </span><span class="s3">0</span><span class="s1">;</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">cacheNewResult(result, incrementalCache, cacheKey, tags, revalidate, fetchIdx, fetchUrl) {</span>
    <span class="s2">await </span><span class="s1">incrementalCache.set(cacheKey, {</span>
        <span class="s1">kind: _responsecache.CachedRouteKind.FETCH,</span>
        <span class="s1">data: {</span>
            <span class="s1">headers: {},</span>
            <span class="s4">// TODO: handle non-JSON values?</span>
            <span class="s1">body: JSON.stringify(result),</span>
            <span class="s1">status: </span><span class="s3">200</span><span class="s1">,</span>
            <span class="s1">url: </span><span class="s0">''</span>
        <span class="s1">},</span>
        <span class="s1">revalidate: </span><span class="s2">typeof </span><span class="s1">revalidate !== </span><span class="s0">'number' </span><span class="s1">? _constants.CACHE_ONE_YEAR : revalidate</span>
    <span class="s1">}, {</span>
        <span class="s1">fetchCache: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">tags,</span>
        <span class="s1">fetchIdx,</span>
        <span class="s1">fetchUrl</span>
    <span class="s1">});</span>
    <span class="s2">return</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">unstable_cache(cb, keyParts, options = {}) {</span>
    <span class="s2">if </span><span class="s1">(options.revalidate === </span><span class="s3">0</span><span class="s1">) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Invariant revalidate: 0 can not be passed to unstable_cache(), must be &quot;false&quot; or &quot;&gt; 0&quot; </span><span class="s1">${cb.toString()}</span><span class="s0">`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E57&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s4">// Validate the tags provided are valid</span>
    <span class="s2">const </span><span class="s1">tags = options.tags ? (</span><span class="s3">0</span><span class="s1">, _patchfetch.validateTags)(options.tags, </span><span class="s0">`unstable_cache </span><span class="s1">${cb.toString()}</span><span class="s0">`</span><span class="s1">) : [];</span>
    <span class="s4">// Validate the revalidate options</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _patchfetch.validateRevalidate)(options.revalidate, </span><span class="s0">`unstable_cache </span><span class="s1">${cb.name || cb.toString()}</span><span class="s0">`</span><span class="s1">);</span>
    <span class="s4">// Stash the fixed part of the key at construction time. The invocation key will combine</span>
    <span class="s4">// the fixed key with the arguments when actually called</span>
    <span class="s4">// @TODO if cb.toString() is long we should hash it</span>
    <span class="s4">// @TODO come up with a collision-free way to combine keyParts</span>
    <span class="s4">// @TODO consider validating the keyParts are all strings. TS can't provide runtime guarantees</span>
    <span class="s4">// and the error produced by accidentally using something that cannot be safely coerced is likely</span>
    <span class="s4">// hard to debug</span>
    <span class="s2">const </span><span class="s1">fixedKey = </span><span class="s0">`</span><span class="s1">${cb.toString()}</span><span class="s0">-</span><span class="s1">${Array.isArray(keyParts) &amp;&amp; keyParts.join(</span><span class="s0">','</span><span class="s1">)}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">cachedCb = async (...args)=&gt;{</span>
        <span class="s2">const </span><span class="s1">workStore = _workasyncstorageexternal.workAsyncStorage.getStore();</span>
        <span class="s2">const </span><span class="s1">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
        <span class="s4">// We must be able to find the incremental cache otherwise we throw</span>
        <span class="s2">const </span><span class="s1">maybeIncrementalCache = (workStore == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: workStore.incrementalCache) || globalThis.__incrementalCache;</span>
        <span class="s2">if </span><span class="s1">(!maybeIncrementalCache) {</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Invariant: incrementalCache missing in unstable_cache </span><span class="s1">${cb.toString()}</span><span class="s0">`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E469&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">incrementalCache = maybeIncrementalCache;</span>
        <span class="s2">const </span><span class="s1">cacheSignal = workUnitStore ? (</span><span class="s3">0</span><span class="s1">, _workunitasyncstorageexternal.getCacheSignal)(workUnitStore) : </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(cacheSignal) {</span>
            <span class="s1">cacheSignal.beginRead();</span>
        <span class="s1">}</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s4">// If there's no request store, we aren't in a request (or we're not in</span>
            <span class="s4">// app router) and if there's no static generation store, we aren't in app</span>
            <span class="s4">// router. Default to an empty pathname and search params when there's no</span>
            <span class="s4">// request store or static generation store available.</span>
            <span class="s2">const </span><span class="s1">fetchUrlPrefix = workStore &amp;&amp; workUnitStore ? getFetchUrlPrefix(workStore, workUnitStore) : </span><span class="s0">''</span><span class="s1">;</span>
            <span class="s4">// Construct the complete cache key for this function invocation</span>
            <span class="s4">// @TODO stringify is likely not safe here. We will coerce undefined to null which will make</span>
            <span class="s4">// the keyspace smaller than the execution space</span>
            <span class="s2">const </span><span class="s1">invocationKey = </span><span class="s0">`</span><span class="s1">${fixedKey}</span><span class="s0">-</span><span class="s1">${JSON.stringify(args)}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">cacheKey = </span><span class="s2">await </span><span class="s1">incrementalCache.generateCacheKey(invocationKey);</span>
            <span class="s4">// $urlWithPath,$sortedQueryStringKeys,$hashOfEveryThingElse</span>
            <span class="s2">const </span><span class="s1">fetchUrl = </span><span class="s0">`unstable_cache </span><span class="s1">${fetchUrlPrefix} ${cb.name ? </span><span class="s0">` </span><span class="s1">${cb.name}</span><span class="s0">` </span><span class="s1">: cacheKey}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">fetchIdx = (workStore ? workStore.nextFetchId : noStoreFetchIdx) ?? </span><span class="s3">1</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">implicitTags = workUnitStore == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: workUnitStore.implicitTags;</span>
            <span class="s2">const </span><span class="s1">innerCacheStore = {</span>
                <span class="s1">type: </span><span class="s0">'unstable-cache'</span><span class="s1">,</span>
                <span class="s1">phase: </span><span class="s0">'render'</span><span class="s1">,</span>
                <span class="s1">implicitTags,</span>
                <span class="s1">draftMode: workUnitStore &amp;&amp; workStore &amp;&amp; (</span><span class="s3">0</span><span class="s1">, _workunitasyncstorageexternal.getDraftModeProviderForCacheScope)(workStore, workUnitStore)</span>
            <span class="s1">};</span>
            <span class="s2">if </span><span class="s1">(workStore) {</span>
                <span class="s1">workStore.nextFetchId = fetchIdx + </span><span class="s3">1</span><span class="s1">;</span>
                <span class="s4">// We are in an App Router context. We try to return the cached entry if it exists and is valid</span>
                <span class="s4">// If the entry is fresh we return it. If the entry is stale we return it but revalidate the entry in</span>
                <span class="s4">// the background. If the entry is missing or invalid we generate a new entry and return it.</span>
                <span class="s2">let </span><span class="s1">isNestedUnstableCache = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(workUnitStore) {</span>
                    <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
                        <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
                        <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
                        <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
                        <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                        <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
                        <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                            <span class="s4">// We update the store's revalidate property if the option.revalidate is a higher precedence</span>
                            <span class="s4">// options.revalidate === undefined doesn't affect timing.</span>
                            <span class="s4">// options.revalidate === false doesn't shrink timing. it stays at the maximum.</span>
                            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">options.revalidate === </span><span class="s0">'number'</span><span class="s1">) {</span>
                                <span class="s2">if </span><span class="s1">(workUnitStore.revalidate &lt; options.revalidate) {</span>
                                <span class="s4">// The store is already revalidating on a shorter time interval, leave it alone</span>
                                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                                    <span class="s1">workUnitStore.revalidate = options.revalidate;</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                            <span class="s4">// We need to accumulate the tags for this invocation within the store</span>
                            <span class="s2">const </span><span class="s1">collectedTags = workUnitStore.tags;</span>
                            <span class="s2">if </span><span class="s1">(collectedTags === </span><span class="s2">null</span><span class="s1">) {</span>
                                <span class="s1">workUnitStore.tags = tags.slice();</span>
                            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">tag of tags){</span>
                                    <span class="s4">// @TODO refactor tags to be a set to avoid this O(n) lookup</span>
                                    <span class="s2">if </span><span class="s1">(!collectedTags.includes(tag)) {</span>
                                        <span class="s1">collectedTags.push(tag);</span>
                                    <span class="s1">}</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                            <span class="s2">break</span><span class="s1">;</span>
                        <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                            <span class="s1">isNestedUnstableCache = </span><span class="s2">true</span><span class="s1">;</span>
                            <span class="s2">break</span><span class="s1">;</span>
                        <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
                        <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                            <span class="s2">break</span><span class="s1">;</span>
                        <span class="s2">default</span><span class="s1">:</span>
                            <span class="s1">workUnitStore;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s4">// when we are nested inside of other unstable_cache's</span>
                <span class="s4">// we should bypass cache similar to fetches</span>
                <span class="s1">!isNestedUnstableCache &amp;&amp; workStore.fetchCache !== </span><span class="s0">'force-no-store' </span><span class="s1">&amp;&amp; !workStore.isOnDemandRevalidate &amp;&amp; !incrementalCache.isOnDemandRevalidate &amp;&amp; !workStore.isDraftMode) {</span>
                    <span class="s4">// We attempt to get the current cache entry from the incremental cache.</span>
                    <span class="s2">const </span><span class="s1">cacheEntry = </span><span class="s2">await </span><span class="s1">incrementalCache.get(cacheKey, {</span>
                        <span class="s1">kind: _responsecache.IncrementalCacheKind.FETCH,</span>
                        <span class="s1">revalidate: options.revalidate,</span>
                        <span class="s1">tags,</span>
                        <span class="s1">softTags: implicitTags == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: implicitTags.tags,</span>
                        <span class="s1">fetchIdx,</span>
                        <span class="s1">fetchUrl</span>
                    <span class="s1">});</span>
                    <span class="s2">if </span><span class="s1">(cacheEntry &amp;&amp; cacheEntry.value) {</span>
                        <span class="s4">// The entry exists and has a value</span>
                        <span class="s2">if </span><span class="s1">(cacheEntry.value.kind !== _responsecache.CachedRouteKind.FETCH) {</span>
                            <span class="s4">// The entry is invalid and we need a special warning</span>
                            <span class="s4">// @TODO why do we warn this way? Should this just be an error? How are these errors surfaced</span>
                            <span class="s4">// so bugs can be reported</span>
                            <span class="s4">// @TODO the invocation key can have sensitive data in it. we should not log this entire object</span>
                            <span class="s1">console.error(</span><span class="s0">`Invariant invalid cacheEntry returned for </span><span class="s1">${invocationKey}</span><span class="s0">`</span><span class="s1">);</span>
                        <span class="s4">// will fall through to generating a new cache entry below</span>
                        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                            <span class="s4">// We have a valid cache entry so we will be returning it. We also check to see if we need</span>
                            <span class="s4">// to background revalidate it by checking if it is stale.</span>
                            <span class="s2">const </span><span class="s1">cachedResponse = cacheEntry.value.data.body !== undefined ? JSON.parse(cacheEntry.value.data.body) : undefined;</span>
                            <span class="s2">if </span><span class="s1">(cacheEntry.isStale) {</span>
                                <span class="s4">// In App Router we return the stale result and revalidate in the background</span>
                                <span class="s2">if </span><span class="s1">(!workStore.pendingRevalidates) {</span>
                                    <span class="s1">workStore.pendingRevalidates = {};</span>
                                <span class="s1">}</span>
                                <span class="s4">// We run the cache function asynchronously and save the result when it completes</span>
                                <span class="s1">workStore.pendingRevalidates[invocationKey] = _workunitasyncstorageexternal.workUnitAsyncStorage.run(innerCacheStore, cb, ...args).then((result)=&gt;{</span>
                                    <span class="s2">return </span><span class="s1">cacheNewResult(result, incrementalCache, cacheKey, tags, options.revalidate, fetchIdx, fetchUrl);</span>
                                <span class="s1">})</span><span class="s4">// @TODO This error handling seems wrong. We swallow the error?</span>
                                <span class="s1">.catch((err)=&gt;console.error(</span><span class="s0">`revalidating cache with key: </span><span class="s1">${invocationKey}</span><span class="s0">`</span><span class="s1">, err));</span>
                            <span class="s1">}</span>
                            <span class="s4">// We had a valid cache entry so we return it here</span>
                            <span class="s2">return </span><span class="s1">cachedResponse;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s4">// If we got this far then we had an invalid cache entry and need to generate a new one</span>
                <span class="s2">const </span><span class="s1">result = </span><span class="s2">await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(innerCacheStore, cb, ...args);</span>
                <span class="s2">if </span><span class="s1">(!workStore.isDraftMode) {</span>
                    <span class="s2">if </span><span class="s1">(!workStore.pendingRevalidates) {</span>
                        <span class="s1">workStore.pendingRevalidates = {};</span>
                    <span class="s1">}</span>
                    <span class="s4">// We need to push the cache result promise to pending</span>
                    <span class="s4">// revalidates otherwise it won't be awaited and is just</span>
                    <span class="s4">// dangling</span>
                    <span class="s1">workStore.pendingRevalidates[invocationKey] = cacheNewResult(result, incrementalCache, cacheKey, tags, options.revalidate, fetchIdx, fetchUrl);</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">noStoreFetchIdx += </span><span class="s3">1</span><span class="s1">;</span>
                <span class="s4">// We are in Pages Router or were called outside of a render. We don't have a store</span>
                <span class="s4">// so we just call the callback directly when it needs to run.</span>
                <span class="s4">// If the entry is fresh we return it. If the entry is stale we return it but revalidate the entry in</span>
                <span class="s4">// the background. If the entry is missing or invalid we generate a new entry and return it.</span>
                <span class="s2">if </span><span class="s1">(!incrementalCache.isOnDemandRevalidate) {</span>
                    <span class="s4">// We aren't doing an on demand revalidation so we check use the cache if valid</span>
                    <span class="s2">const </span><span class="s1">cacheEntry = </span><span class="s2">await </span><span class="s1">incrementalCache.get(cacheKey, {</span>
                        <span class="s1">kind: _responsecache.IncrementalCacheKind.FETCH,</span>
                        <span class="s1">revalidate: options.revalidate,</span>
                        <span class="s1">tags,</span>
                        <span class="s1">fetchIdx,</span>
                        <span class="s1">fetchUrl,</span>
                        <span class="s1">softTags: implicitTags == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: implicitTags.tags</span>
                    <span class="s1">});</span>
                    <span class="s2">if </span><span class="s1">(cacheEntry &amp;&amp; cacheEntry.value) {</span>
                        <span class="s4">// The entry exists and has a value</span>
                        <span class="s2">if </span><span class="s1">(cacheEntry.value.kind !== _responsecache.CachedRouteKind.FETCH) {</span>
                            <span class="s4">// The entry is invalid and we need a special warning</span>
                            <span class="s4">// @TODO why do we warn this way? Should this just be an error? How are these errors surfaced</span>
                            <span class="s4">// so bugs can be reported</span>
                            <span class="s1">console.error(</span><span class="s0">`Invariant invalid cacheEntry returned for </span><span class="s1">${invocationKey}</span><span class="s0">`</span><span class="s1">);</span>
                        <span class="s4">// will fall through to generating a new cache entry below</span>
                        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!cacheEntry.isStale) {</span>
                            <span class="s4">// We have a valid cache entry and it is fresh so we return it</span>
                            <span class="s2">return </span><span class="s1">cacheEntry.value.data.body !== undefined ? JSON.parse(cacheEntry.value.data.body) : undefined;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s4">// If we got this far then we had an invalid cache entry and need to generate a new one</span>
                <span class="s2">const </span><span class="s1">result = </span><span class="s2">await </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(innerCacheStore, cb, ...args);</span>
                <span class="s4">// we need to wait setting the new cache result here as</span>
                <span class="s4">// we don't have pending revalidates on workStore to</span>
                <span class="s4">// push to and we can't have a dangling promise</span>
                <span class="s2">await </span><span class="s1">cacheNewResult(result, incrementalCache, cacheKey, tags, options.revalidate, fetchIdx, fetchUrl);</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">finally</span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(cacheSignal) {</span>
                <span class="s1">cacheSignal.endRead();</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s4">// TODO: once AsyncLocalStorage.run() returns the correct types this override will no longer be necessary</span>
    <span class="s2">return </span><span class="s1">cachedCb;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getFetchUrlPrefix(workStore, workUnitStore) {</span>
    <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
        <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
            <span class="s2">const </span><span class="s1">pathname = workUnitStore.url.pathname;</span>
            <span class="s2">const </span><span class="s1">searchParams = </span><span class="s2">new </span><span class="s1">URLSearchParams(workUnitStore.url.search);</span>
            <span class="s2">const </span><span class="s1">sortedSearch = [</span>
                <span class="s1">...searchParams.keys()</span>
            <span class="s1">].sort((a, b)=&gt;a.localeCompare(b)).map((key)=&gt;</span><span class="s0">`</span><span class="s1">${key}</span><span class="s0">=</span><span class="s1">${searchParams.get(key)}</span><span class="s0">`</span><span class="s1">).join(</span><span class="s0">'&amp;'</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s0">`</span><span class="s1">${pathname}${sortedSearch.length ? </span><span class="s0">'?' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">}${sortedSearch}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">workStore.route;</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">workUnitStore;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=unstable-cache.js.map</span></pre>
</body>
</html>