<html>
<head>
<title>pack.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #8c8c8c; font-style: italic;}
.s3 { color: #0033b3;}
.s4 { color: #1750eb;}
.s5 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
pack.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">// A readable tar stream creator</span>
<span class="s2">// Technically, this is a transform stream that you write paths into,</span>
<span class="s2">// and tar format comes out of.</span>
<span class="s2">// The `add()` method is like `write()` but returns this,</span>
<span class="s2">// and end() return `this` as well, so you can</span>
<span class="s2">// do `new Pack(opt).add('files').add('dir').end().pipe(output)</span>
<span class="s2">// You could also do something like:</span>
<span class="s2">// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))</span>
<span class="s3">var </span><span class="s1">__createBinding = (</span><span class="s3">this </span><span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.__createBinding) || (Object.create ? (</span><span class="s3">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s3">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s3">var </span><span class="s1">desc = Object.getOwnPropertyDescriptor(m, k);</span>
    <span class="s3">if </span><span class="s1">(!desc || (</span><span class="s0">&quot;get&quot; </span><span class="s3">in </span><span class="s1">desc ? !m.__esModule : desc.writable || desc.configurable)) {</span>
      <span class="s1">desc = { enumerable: </span><span class="s3">true</span><span class="s1">, get: </span><span class="s3">function</span><span class="s1">() { </span><span class="s3">return </span><span class="s1">m[k]; } };</span>
    <span class="s1">}</span>
    <span class="s1">Object.defineProperty(o, k2, desc);</span>
<span class="s1">}) : (</span><span class="s3">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s3">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s1">o[k2] = m[k];</span>
<span class="s1">}));</span>
<span class="s3">var </span><span class="s1">__setModuleDefault = (</span><span class="s3">this </span><span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.__setModuleDefault) || (Object.create ? (</span><span class="s3">function</span><span class="s1">(o, v) {</span>
    <span class="s1">Object.defineProperty(o, </span><span class="s0">&quot;default&quot;</span><span class="s1">, { enumerable: </span><span class="s3">true</span><span class="s1">, value: v });</span>
<span class="s1">}) : </span><span class="s3">function</span><span class="s1">(o, v) {</span>
    <span class="s1">o[</span><span class="s0">&quot;default&quot;</span><span class="s1">] = v;</span>
<span class="s1">});</span>
<span class="s3">var </span><span class="s1">__importStar = (</span><span class="s3">this </span><span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.__importStar) || </span><span class="s3">function </span><span class="s1">(mod) {</span>
    <span class="s3">if </span><span class="s1">(mod &amp;&amp; mod.__esModule) </span><span class="s3">return </span><span class="s1">mod;</span>
    <span class="s3">var </span><span class="s1">result = {};</span>
    <span class="s3">if </span><span class="s1">(mod != </span><span class="s3">null</span><span class="s1">) </span><span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">k </span><span class="s3">in </span><span class="s1">mod) </span><span class="s3">if </span><span class="s1">(k !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);</span>
    <span class="s1">__setModuleDefault(result, mod);</span>
    <span class="s3">return </span><span class="s1">result;</span>
<span class="s1">};</span>
<span class="s3">var </span><span class="s1">__importDefault = (</span><span class="s3">this </span><span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.__importDefault) || </span><span class="s3">function </span><span class="s1">(mod) {</span>
    <span class="s3">return </span><span class="s1">(mod &amp;&amp; mod.__esModule) ? mod : { </span><span class="s0">&quot;default&quot;</span><span class="s1">: mod };</span>
<span class="s1">};</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s3">true </span><span class="s1">});</span>
<span class="s1">exports.PackSync = exports.Pack = exports.PackJob = </span><span class="s3">void </span><span class="s4">0</span><span class="s1">;</span>
<span class="s3">const </span><span class="s1">fs_1 = __importDefault(require(</span><span class="s0">&quot;fs&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">write_entry_js_1 = require(</span><span class="s0">&quot;./write-entry.js&quot;</span><span class="s1">);</span>
<span class="s3">class </span><span class="s1">PackJob {</span>
    <span class="s1">path;</span>
    <span class="s1">absolute;</span>
    <span class="s1">entry;</span>
    <span class="s1">stat;</span>
    <span class="s1">readdir;</span>
    <span class="s1">pending = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">ignore = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">piped = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">constructor(path, absolute) {</span>
        <span class="s3">this</span><span class="s1">.path = path || </span><span class="s0">'./'</span><span class="s1">;</span>
        <span class="s3">this</span><span class="s1">.absolute = absolute;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.PackJob = PackJob;</span>
<span class="s3">const </span><span class="s1">minipass_1 = require(</span><span class="s0">&quot;minipass&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">zlib = __importStar(require(</span><span class="s0">&quot;minizlib&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">yallist_1 = require(</span><span class="s0">&quot;yallist&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">read_entry_js_1 = require(</span><span class="s0">&quot;./read-entry.js&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">warn_method_js_1 = require(</span><span class="s0">&quot;./warn-method.js&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">EOF = Buffer.alloc(</span><span class="s4">1024</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">ONSTAT = Symbol(</span><span class="s0">'onStat'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">ENDED = Symbol(</span><span class="s0">'ended'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">QUEUE = Symbol(</span><span class="s0">'queue'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">CURRENT = Symbol(</span><span class="s0">'current'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">PROCESS = Symbol(</span><span class="s0">'process'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">PROCESSING = Symbol(</span><span class="s0">'processing'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">PROCESSJOB = Symbol(</span><span class="s0">'processJob'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">JOBS = Symbol(</span><span class="s0">'jobs'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">JOBDONE = Symbol(</span><span class="s0">'jobDone'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">ADDFSENTRY = Symbol(</span><span class="s0">'addFSEntry'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">ADDTARENTRY = Symbol(</span><span class="s0">'addTarEntry'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">STAT = Symbol(</span><span class="s0">'stat'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">READDIR = Symbol(</span><span class="s0">'readdir'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">ONREADDIR = Symbol(</span><span class="s0">'onreaddir'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">PIPE = Symbol(</span><span class="s0">'pipe'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">ENTRY = Symbol(</span><span class="s0">'entry'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">ENTRYOPT = Symbol(</span><span class="s0">'entryOpt'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">WRITEENTRYCLASS = Symbol(</span><span class="s0">'writeEntryClass'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">WRITE = Symbol(</span><span class="s0">'write'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">ONDRAIN = Symbol(</span><span class="s0">'ondrain'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">path_1 = __importDefault(require(</span><span class="s0">&quot;path&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">normalize_windows_path_js_1 = require(</span><span class="s0">&quot;./normalize-windows-path.js&quot;</span><span class="s1">);</span>
<span class="s3">class </span><span class="s1">Pack </span><span class="s3">extends </span><span class="s1">minipass_1.Minipass {</span>
    <span class="s1">opt;</span>
    <span class="s1">cwd;</span>
    <span class="s1">maxReadSize;</span>
    <span class="s1">preservePaths;</span>
    <span class="s1">strict;</span>
    <span class="s1">noPax;</span>
    <span class="s1">prefix;</span>
    <span class="s1">linkCache;</span>
    <span class="s1">statCache;</span>
    <span class="s1">file;</span>
    <span class="s1">portable;</span>
    <span class="s1">zip;</span>
    <span class="s1">readdirCache;</span>
    <span class="s1">noDirRecurse;</span>
    <span class="s1">follow;</span>
    <span class="s1">noMtime;</span>
    <span class="s1">mtime;</span>
    <span class="s1">filter;</span>
    <span class="s1">jobs;</span>
    <span class="s1">[WRITEENTRYCLASS];</span>
    <span class="s1">onWriteEntry;</span>
    <span class="s2">// Note: we actually DO need a linked list here, because we</span>
    <span class="s2">// shift() to update the head of the list where we start, but still</span>
    <span class="s2">// while that happens, need to know what the next item in the queue</span>
    <span class="s2">// will be. Since we do multiple jobs in parallel, it's not as simple</span>
    <span class="s2">// as just an Array.shift(), since that would lose the information about</span>
    <span class="s2">// the next job in the list. We could add a .next field on the PackJob</span>
    <span class="s2">// class, but then we'd have to be tracking the tail of the queue the</span>
    <span class="s2">// whole time, and Yallist just does that for us anyway.</span>
    <span class="s1">[QUEUE];</span>
    <span class="s1">[JOBS] = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">[PROCESSING] = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">[ENDED] = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">constructor(opt = {}) {</span>
        <span class="s2">//@ts-ignore</span>
        <span class="s3">super</span><span class="s1">();</span>
        <span class="s3">this</span><span class="s1">.opt = opt;</span>
        <span class="s3">this</span><span class="s1">.file = opt.file || </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s3">this</span><span class="s1">.cwd = opt.cwd || process.cwd();</span>
        <span class="s3">this</span><span class="s1">.maxReadSize = opt.maxReadSize;</span>
        <span class="s3">this</span><span class="s1">.preservePaths = !!opt.preservePaths;</span>
        <span class="s3">this</span><span class="s1">.strict = !!opt.strict;</span>
        <span class="s3">this</span><span class="s1">.noPax = !!opt.noPax;</span>
        <span class="s3">this</span><span class="s1">.prefix = (</span><span class="s4">0</span><span class="s1">, normalize_windows_path_js_1.normalizeWindowsPath)(opt.prefix || </span><span class="s0">''</span><span class="s1">);</span>
        <span class="s3">this</span><span class="s1">.linkCache = opt.linkCache || </span><span class="s3">new </span><span class="s1">Map();</span>
        <span class="s3">this</span><span class="s1">.statCache = opt.statCache || </span><span class="s3">new </span><span class="s1">Map();</span>
        <span class="s3">this</span><span class="s1">.readdirCache = opt.readdirCache || </span><span class="s3">new </span><span class="s1">Map();</span>
        <span class="s3">this</span><span class="s1">.onWriteEntry = opt.onWriteEntry;</span>
        <span class="s3">this</span><span class="s1">[WRITEENTRYCLASS] = write_entry_js_1.WriteEntry;</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">opt.onwarn === </span><span class="s0">'function'</span><span class="s1">) {</span>
            <span class="s3">this</span><span class="s1">.on(</span><span class="s0">'warn'</span><span class="s1">, opt.onwarn);</span>
        <span class="s1">}</span>
        <span class="s3">this</span><span class="s1">.portable = !!opt.portable;</span>
        <span class="s3">if </span><span class="s1">(opt.gzip || opt.brotli || opt.zstd) {</span>
            <span class="s3">if </span><span class="s1">((opt.gzip ? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">) + (opt.brotli ? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">) + (opt.zstd ? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">) &gt; </span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s0">'gzip, brotli, zstd are mutually exclusive'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(opt.gzip) {</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">opt.gzip !== </span><span class="s0">'object'</span><span class="s1">) {</span>
                    <span class="s1">opt.gzip = {};</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.portable) {</span>
                    <span class="s1">opt.gzip.portable = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">this</span><span class="s1">.zip = </span><span class="s3">new </span><span class="s1">zlib.Gzip(opt.gzip);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(opt.brotli) {</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">opt.brotli !== </span><span class="s0">'object'</span><span class="s1">) {</span>
                    <span class="s1">opt.brotli = {};</span>
                <span class="s1">}</span>
                <span class="s3">this</span><span class="s1">.zip = </span><span class="s3">new </span><span class="s1">zlib.BrotliCompress(opt.brotli);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(opt.zstd) {</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">opt.zstd !== </span><span class="s0">'object'</span><span class="s1">) {</span>
                    <span class="s1">opt.zstd = {};</span>
                <span class="s1">}</span>
                <span class="s3">this</span><span class="s1">.zip = </span><span class="s3">new </span><span class="s1">zlib.ZstdCompress(opt.zstd);</span>
            <span class="s1">}</span>
            <span class="s2">/* c8 ignore next */</span>
            <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.zip)</span>
                <span class="s3">throw new </span><span class="s1">Error(</span><span class="s0">'impossible'</span><span class="s1">);</span>
            <span class="s3">const </span><span class="s1">zip = </span><span class="s3">this</span><span class="s1">.zip;</span>
            <span class="s1">zip.on(</span><span class="s0">'data'</span><span class="s1">, chunk =&gt; </span><span class="s3">super</span><span class="s1">.write(chunk));</span>
            <span class="s1">zip.on(</span><span class="s0">'end'</span><span class="s1">, () =&gt; </span><span class="s3">super</span><span class="s1">.end());</span>
            <span class="s1">zip.on(</span><span class="s0">'drain'</span><span class="s1">, () =&gt; </span><span class="s3">this</span><span class="s1">[ONDRAIN]());</span>
            <span class="s3">this</span><span class="s1">.on(</span><span class="s0">'resume'</span><span class="s1">, () =&gt; zip.resume());</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">this</span><span class="s1">.on(</span><span class="s0">'drain'</span><span class="s1">, </span><span class="s3">this</span><span class="s1">[ONDRAIN]);</span>
        <span class="s1">}</span>
        <span class="s3">this</span><span class="s1">.noDirRecurse = !!opt.noDirRecurse;</span>
        <span class="s3">this</span><span class="s1">.follow = !!opt.follow;</span>
        <span class="s3">this</span><span class="s1">.noMtime = !!opt.noMtime;</span>
        <span class="s3">if </span><span class="s1">(opt.mtime)</span>
            <span class="s3">this</span><span class="s1">.mtime = opt.mtime;</span>
        <span class="s3">this</span><span class="s1">.filter =</span>
            <span class="s3">typeof </span><span class="s1">opt.filter === </span><span class="s0">'function' </span><span class="s1">? opt.filter : () =&gt; </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">this</span><span class="s1">[QUEUE] = </span><span class="s3">new </span><span class="s1">yallist_1.Yallist();</span>
        <span class="s3">this</span><span class="s1">[JOBS] = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s3">this</span><span class="s1">.jobs = Number(opt.jobs) || </span><span class="s4">4</span><span class="s1">;</span>
        <span class="s3">this</span><span class="s1">[PROCESSING] = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s3">this</span><span class="s1">[ENDED] = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">[WRITE](chunk) {</span>
        <span class="s3">return super</span><span class="s1">.write(chunk);</span>
    <span class="s1">}</span>
    <span class="s1">add(path) {</span>
        <span class="s3">this</span><span class="s1">.write(path);</span>
        <span class="s3">return this</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">end(path, encoding, cb) {</span>
        <span class="s2">/* c8 ignore start */</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">path === </span><span class="s0">'function'</span><span class="s1">) {</span>
            <span class="s1">cb = path;</span>
            <span class="s1">path = undefined;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">encoding === </span><span class="s0">'function'</span><span class="s1">) {</span>
            <span class="s1">cb = encoding;</span>
            <span class="s1">encoding = undefined;</span>
        <span class="s1">}</span>
        <span class="s2">/* c8 ignore stop */</span>
        <span class="s3">if </span><span class="s1">(path) {</span>
            <span class="s3">this</span><span class="s1">.add(path);</span>
        <span class="s1">}</span>
        <span class="s3">this</span><span class="s1">[ENDED] = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">this</span><span class="s1">[PROCESS]();</span>
        <span class="s2">/* c8 ignore next */</span>
        <span class="s3">if </span><span class="s1">(cb)</span>
            <span class="s1">cb();</span>
        <span class="s3">return this</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">write(path) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">[ENDED]) {</span>
            <span class="s3">throw new </span><span class="s1">Error(</span><span class="s0">'write after end'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(path </span><span class="s3">instanceof </span><span class="s1">read_entry_js_1.ReadEntry) {</span>
            <span class="s3">this</span><span class="s1">[ADDTARENTRY](path);</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">this</span><span class="s1">[ADDFSENTRY](path);</span>
        <span class="s1">}</span>
        <span class="s3">return this</span><span class="s1">.flowing;</span>
    <span class="s1">}</span>
    <span class="s1">[ADDTARENTRY](p) {</span>
        <span class="s3">const </span><span class="s1">absolute = (</span><span class="s4">0</span><span class="s1">, normalize_windows_path_js_1.normalizeWindowsPath)(path_1.default.resolve(</span><span class="s3">this</span><span class="s1">.cwd, p.path));</span>
        <span class="s2">// in this case, we don't have to wait for the stat</span>
        <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.filter(p.path, p)) {</span>
            <span class="s1">p.resume();</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">const </span><span class="s1">job = </span><span class="s3">new </span><span class="s1">PackJob(p.path, absolute);</span>
            <span class="s1">job.entry = </span><span class="s3">new </span><span class="s1">write_entry_js_1.WriteEntryTar(p, </span><span class="s3">this</span><span class="s1">[ENTRYOPT](job));</span>
            <span class="s1">job.entry.on(</span><span class="s0">'end'</span><span class="s1">, () =&gt; </span><span class="s3">this</span><span class="s1">[JOBDONE](job));</span>
            <span class="s3">this</span><span class="s1">[JOBS] += </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s3">this</span><span class="s1">[QUEUE].push(job);</span>
        <span class="s1">}</span>
        <span class="s3">this</span><span class="s1">[PROCESS]();</span>
    <span class="s1">}</span>
    <span class="s1">[ADDFSENTRY](p) {</span>
        <span class="s3">const </span><span class="s1">absolute = (</span><span class="s4">0</span><span class="s1">, normalize_windows_path_js_1.normalizeWindowsPath)(path_1.default.resolve(</span><span class="s3">this</span><span class="s1">.cwd, p));</span>
        <span class="s3">this</span><span class="s1">[QUEUE].push(</span><span class="s3">new </span><span class="s1">PackJob(p, absolute));</span>
        <span class="s3">this</span><span class="s1">[PROCESS]();</span>
    <span class="s1">}</span>
    <span class="s1">[STAT](job) {</span>
        <span class="s1">job.pending = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">this</span><span class="s1">[JOBS] += </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s3">const </span><span class="s1">stat = </span><span class="s3">this</span><span class="s1">.follow ? </span><span class="s0">'stat' </span><span class="s1">: </span><span class="s0">'lstat'</span><span class="s1">;</span>
        <span class="s1">fs_1.default[stat](job.absolute, (er, stat) =&gt; {</span>
            <span class="s1">job.pending = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s3">this</span><span class="s1">[JOBS] -= </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(er) {</span>
                <span class="s3">this</span><span class="s1">.emit(</span><span class="s0">'error'</span><span class="s1">, er);</span>
            <span class="s1">}</span>
            <span class="s3">else </span><span class="s1">{</span>
                <span class="s3">this</span><span class="s1">[ONSTAT](job, stat);</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">[ONSTAT](job, stat) {</span>
        <span class="s3">this</span><span class="s1">.statCache.set(job.absolute, stat);</span>
        <span class="s1">job.stat = stat;</span>
        <span class="s2">// now we have the stat, we can filter it.</span>
        <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.filter(job.path, stat)) {</span>
            <span class="s1">job.ignore = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">this</span><span class="s1">[PROCESS]();</span>
    <span class="s1">}</span>
    <span class="s1">[READDIR](job) {</span>
        <span class="s1">job.pending = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">this</span><span class="s1">[JOBS] += </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">fs_1.default.readdir(job.absolute, (er, entries) =&gt; {</span>
            <span class="s1">job.pending = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s3">this</span><span class="s1">[JOBS] -= </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(er) {</span>
                <span class="s3">return this</span><span class="s1">.emit(</span><span class="s0">'error'</span><span class="s1">, er);</span>
            <span class="s1">}</span>
            <span class="s3">this</span><span class="s1">[ONREADDIR](job, entries);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">[ONREADDIR](job, entries) {</span>
        <span class="s3">this</span><span class="s1">.readdirCache.set(job.absolute, entries);</span>
        <span class="s1">job.readdir = entries;</span>
        <span class="s3">this</span><span class="s1">[PROCESS]();</span>
    <span class="s1">}</span>
    <span class="s1">[PROCESS]() {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">[PROCESSING]) {</span>
            <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">this</span><span class="s1">[PROCESSING] = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">w = </span><span class="s3">this</span><span class="s1">[QUEUE].head; !!w &amp;&amp; </span><span class="s3">this</span><span class="s1">[JOBS] &lt; </span><span class="s3">this</span><span class="s1">.jobs; w = w.next) {</span>
            <span class="s3">this</span><span class="s1">[PROCESSJOB](w.value);</span>
            <span class="s3">if </span><span class="s1">(w.value.ignore) {</span>
                <span class="s3">const </span><span class="s1">p = w.next;</span>
                <span class="s3">this</span><span class="s1">[QUEUE].removeNode(w);</span>
                <span class="s1">w.next = p;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">this</span><span class="s1">[PROCESSING] = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">[ENDED] &amp;&amp; !</span><span class="s3">this</span><span class="s1">[QUEUE].length &amp;&amp; </span><span class="s3">this</span><span class="s1">[JOBS] === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.zip) {</span>
                <span class="s3">this</span><span class="s1">.zip.end(EOF);</span>
            <span class="s1">}</span>
            <span class="s3">else </span><span class="s1">{</span>
                <span class="s3">super</span><span class="s1">.write(EOF);</span>
                <span class="s3">super</span><span class="s1">.end();</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">get [CURRENT]() {</span>
        <span class="s3">return this</span><span class="s1">[QUEUE] &amp;&amp; </span><span class="s3">this</span><span class="s1">[QUEUE].head &amp;&amp; </span><span class="s3">this</span><span class="s1">[QUEUE].head.value;</span>
    <span class="s1">}</span>
    <span class="s1">[JOBDONE](_job) {</span>
        <span class="s3">this</span><span class="s1">[QUEUE].shift();</span>
        <span class="s3">this</span><span class="s1">[JOBS] -= </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s3">this</span><span class="s1">[PROCESS]();</span>
    <span class="s1">}</span>
    <span class="s1">[PROCESSJOB](job) {</span>
        <span class="s3">if </span><span class="s1">(job.pending) {</span>
            <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(job.entry) {</span>
            <span class="s3">if </span><span class="s1">(job === </span><span class="s3">this</span><span class="s1">[CURRENT] &amp;&amp; !job.piped) {</span>
                <span class="s3">this</span><span class="s1">[PIPE](job);</span>
            <span class="s1">}</span>
            <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(!job.stat) {</span>
            <span class="s3">const </span><span class="s1">sc = </span><span class="s3">this</span><span class="s1">.statCache.get(job.absolute);</span>
            <span class="s3">if </span><span class="s1">(sc) {</span>
                <span class="s3">this</span><span class="s1">[ONSTAT](job, sc);</span>
            <span class="s1">}</span>
            <span class="s3">else </span><span class="s1">{</span>
                <span class="s3">this</span><span class="s1">[STAT](job);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(!job.stat) {</span>
            <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">// filtered out!</span>
        <span class="s3">if </span><span class="s1">(job.ignore) {</span>
            <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.noDirRecurse &amp;&amp;</span>
            <span class="s1">job.stat.isDirectory() &amp;&amp;</span>
            <span class="s1">!job.readdir) {</span>
            <span class="s3">const </span><span class="s1">rc = </span><span class="s3">this</span><span class="s1">.readdirCache.get(job.absolute);</span>
            <span class="s3">if </span><span class="s1">(rc) {</span>
                <span class="s3">this</span><span class="s1">[ONREADDIR](job, rc);</span>
            <span class="s1">}</span>
            <span class="s3">else </span><span class="s1">{</span>
                <span class="s3">this</span><span class="s1">[READDIR](job);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(!job.readdir) {</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">// we know it doesn't have an entry, because that got checked above</span>
        <span class="s1">job.entry = </span><span class="s3">this</span><span class="s1">[ENTRY](job);</span>
        <span class="s3">if </span><span class="s1">(!job.entry) {</span>
            <span class="s1">job.ignore = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(job === </span><span class="s3">this</span><span class="s1">[CURRENT] &amp;&amp; !job.piped) {</span>
            <span class="s3">this</span><span class="s1">[PIPE](job);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">[ENTRYOPT](job) {</span>
        <span class="s3">return </span><span class="s1">{</span>
            <span class="s1">onwarn: (code, msg, data) =&gt; </span><span class="s3">this</span><span class="s1">.warn(code, msg, data),</span>
            <span class="s1">noPax: </span><span class="s3">this</span><span class="s1">.noPax,</span>
            <span class="s1">cwd: </span><span class="s3">this</span><span class="s1">.cwd,</span>
            <span class="s1">absolute: job.absolute,</span>
            <span class="s1">preservePaths: </span><span class="s3">this</span><span class="s1">.preservePaths,</span>
            <span class="s1">maxReadSize: </span><span class="s3">this</span><span class="s1">.maxReadSize,</span>
            <span class="s1">strict: </span><span class="s3">this</span><span class="s1">.strict,</span>
            <span class="s1">portable: </span><span class="s3">this</span><span class="s1">.portable,</span>
            <span class="s1">linkCache: </span><span class="s3">this</span><span class="s1">.linkCache,</span>
            <span class="s1">statCache: </span><span class="s3">this</span><span class="s1">.statCache,</span>
            <span class="s1">noMtime: </span><span class="s3">this</span><span class="s1">.noMtime,</span>
            <span class="s1">mtime: </span><span class="s3">this</span><span class="s1">.mtime,</span>
            <span class="s1">prefix: </span><span class="s3">this</span><span class="s1">.prefix,</span>
            <span class="s1">onWriteEntry: </span><span class="s3">this</span><span class="s1">.onWriteEntry,</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s1">[ENTRY](job) {</span>
        <span class="s3">this</span><span class="s1">[JOBS] += </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s3">try </span><span class="s1">{</span>
            <span class="s3">const </span><span class="s1">e = </span><span class="s3">new this</span><span class="s1">[WRITEENTRYCLASS](job.path, </span><span class="s3">this</span><span class="s1">[ENTRYOPT](job));</span>
            <span class="s3">return </span><span class="s1">e</span>
                <span class="s1">.on(</span><span class="s0">'end'</span><span class="s1">, () =&gt; </span><span class="s3">this</span><span class="s1">[JOBDONE](job))</span>
                <span class="s1">.on(</span><span class="s0">'error'</span><span class="s1">, er =&gt; </span><span class="s3">this</span><span class="s1">.emit(</span><span class="s0">'error'</span><span class="s1">, er));</span>
        <span class="s1">}</span>
        <span class="s3">catch </span><span class="s1">(er) {</span>
            <span class="s3">this</span><span class="s1">.emit(</span><span class="s0">'error'</span><span class="s1">, er);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">[ONDRAIN]() {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">[CURRENT] &amp;&amp; </span><span class="s3">this</span><span class="s1">[CURRENT].entry) {</span>
            <span class="s3">this</span><span class="s1">[CURRENT].entry.resume();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">// like .pipe() but using super, because our write() is special</span>
    <span class="s1">[PIPE](job) {</span>
        <span class="s1">job.piped = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(job.readdir) {</span>
            <span class="s1">job.readdir.forEach(entry =&gt; {</span>
                <span class="s3">const </span><span class="s1">p = job.path;</span>
                <span class="s3">const </span><span class="s1">base = p === </span><span class="s0">'./' </span><span class="s1">? </span><span class="s0">'' </span><span class="s1">: p.replace(</span><span class="s5">/\/*$/</span><span class="s1">, </span><span class="s0">'/'</span><span class="s1">);</span>
                <span class="s3">this</span><span class="s1">[ADDFSENTRY](base + entry);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">const </span><span class="s1">source = job.entry;</span>
        <span class="s3">const </span><span class="s1">zip = </span><span class="s3">this</span><span class="s1">.zip;</span>
        <span class="s2">/* c8 ignore start */</span>
        <span class="s3">if </span><span class="s1">(!source)</span>
            <span class="s3">throw new </span><span class="s1">Error(</span><span class="s0">'cannot pipe without source'</span><span class="s1">);</span>
        <span class="s2">/* c8 ignore stop */</span>
        <span class="s3">if </span><span class="s1">(zip) {</span>
            <span class="s1">source.on(</span><span class="s0">'data'</span><span class="s1">, chunk =&gt; {</span>
                <span class="s3">if </span><span class="s1">(!zip.write(chunk)) {</span>
                    <span class="s1">source.pause();</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s1">source.on(</span><span class="s0">'data'</span><span class="s1">, chunk =&gt; {</span>
                <span class="s3">if </span><span class="s1">(!</span><span class="s3">super</span><span class="s1">.write(chunk)) {</span>
                    <span class="s1">source.pause();</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">pause() {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.zip) {</span>
            <span class="s3">this</span><span class="s1">.zip.pause();</span>
        <span class="s1">}</span>
        <span class="s3">return super</span><span class="s1">.pause();</span>
    <span class="s1">}</span>
    <span class="s1">warn(code, message, data = {}) {</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s1">, warn_method_js_1.warnMethod)(</span><span class="s3">this</span><span class="s1">, code, message, data);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.Pack = Pack;</span>
<span class="s3">class </span><span class="s1">PackSync </span><span class="s3">extends </span><span class="s1">Pack {</span>
    <span class="s1">sync = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">constructor(opt) {</span>
        <span class="s3">super</span><span class="s1">(opt);</span>
        <span class="s3">this</span><span class="s1">[WRITEENTRYCLASS] = write_entry_js_1.WriteEntrySync;</span>
    <span class="s1">}</span>
    <span class="s2">// pause/resume are no-ops in sync streams.</span>
    <span class="s1">pause() { }</span>
    <span class="s1">resume() { }</span>
    <span class="s1">[STAT](job) {</span>
        <span class="s3">const </span><span class="s1">stat = </span><span class="s3">this</span><span class="s1">.follow ? </span><span class="s0">'statSync' </span><span class="s1">: </span><span class="s0">'lstatSync'</span><span class="s1">;</span>
        <span class="s3">this</span><span class="s1">[ONSTAT](job, fs_1.default[stat](job.absolute));</span>
    <span class="s1">}</span>
    <span class="s1">[READDIR](job) {</span>
        <span class="s3">this</span><span class="s1">[ONREADDIR](job, fs_1.default.readdirSync(job.absolute));</span>
    <span class="s1">}</span>
    <span class="s2">// gotta get it all in this tick</span>
    <span class="s1">[PIPE](job) {</span>
        <span class="s3">const </span><span class="s1">source = job.entry;</span>
        <span class="s3">const </span><span class="s1">zip = </span><span class="s3">this</span><span class="s1">.zip;</span>
        <span class="s3">if </span><span class="s1">(job.readdir) {</span>
            <span class="s1">job.readdir.forEach(entry =&gt; {</span>
                <span class="s3">const </span><span class="s1">p = job.path;</span>
                <span class="s3">const </span><span class="s1">base = p === </span><span class="s0">'./' </span><span class="s1">? </span><span class="s0">'' </span><span class="s1">: p.replace(</span><span class="s5">/\/*$/</span><span class="s1">, </span><span class="s0">'/'</span><span class="s1">);</span>
                <span class="s3">this</span><span class="s1">[ADDFSENTRY](base + entry);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">/* c8 ignore start */</span>
        <span class="s3">if </span><span class="s1">(!source)</span>
            <span class="s3">throw new </span><span class="s1">Error(</span><span class="s0">'Cannot pipe without source'</span><span class="s1">);</span>
        <span class="s2">/* c8 ignore stop */</span>
        <span class="s3">if </span><span class="s1">(zip) {</span>
            <span class="s1">source.on(</span><span class="s0">'data'</span><span class="s1">, chunk =&gt; {</span>
                <span class="s1">zip.write(chunk);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s1">source.on(</span><span class="s0">'data'</span><span class="s1">, chunk =&gt; {</span>
                <span class="s3">super</span><span class="s1">[WRITE](chunk);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.PackSync = PackSync;</span>
<span class="s2">//# sourceMappingURL=pack.js.map</span></pre>
</body>
</html>