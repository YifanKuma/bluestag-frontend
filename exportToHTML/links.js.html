<html>
<head>
<title>links.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
links.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">IDLE_LINK_STATUS: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">PENDING_LINK_STATUS: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">mountFormInstance: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">mountLinkInstance: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">onLinkVisibilityChanged: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">onNavigationIntent: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">pingVisibleLinks: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">setLinkForCurrentNavigation: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">unmountLinkForCurrentNavigation: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">unmountPrefetchableInstance: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">IDLE_LINK_STATUS: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">IDLE_LINK_STATUS;</span>
    <span class="s1">},</span>
    <span class="s1">PENDING_LINK_STATUS: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">PENDING_LINK_STATUS;</span>
    <span class="s1">},</span>
    <span class="s1">mountFormInstance: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">mountFormInstance;</span>
    <span class="s1">},</span>
    <span class="s1">mountLinkInstance: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">mountLinkInstance;</span>
    <span class="s1">},</span>
    <span class="s1">onLinkVisibilityChanged: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">onLinkVisibilityChanged;</span>
    <span class="s1">},</span>
    <span class="s1">onNavigationIntent: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">onNavigationIntent;</span>
    <span class="s1">},</span>
    <span class="s1">pingVisibleLinks: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">pingVisibleLinks;</span>
    <span class="s1">},</span>
    <span class="s1">setLinkForCurrentNavigation: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">setLinkForCurrentNavigation;</span>
    <span class="s1">},</span>
    <span class="s1">unmountLinkForCurrentNavigation: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">unmountLinkForCurrentNavigation;</span>
    <span class="s1">},</span>
    <span class="s1">unmountPrefetchableInstance: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">unmountPrefetchableInstance;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_approuterinstance = require(</span><span class="s0">&quot;./app-router-instance&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_approuter = require(</span><span class="s0">&quot;./app-router&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_segmentcache = require(</span><span class="s0">&quot;./segment-cache&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_react = require(</span><span class="s0">&quot;react&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_routerreducertypes = require(</span><span class="s0">&quot;./router-reducer/router-reducer-types&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_invarianterror = require(</span><span class="s0">&quot;../../shared/lib/invariant-error&quot;</span><span class="s1">);</span>
<span class="s4">// Tracks the most recently navigated link instance. When null, indicates</span>
<span class="s4">// the current navigation was not initiated by a link click.</span>
<span class="s2">let </span><span class="s1">linkForMostRecentNavigation = </span><span class="s2">null</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">PENDING_LINK_STATUS = {</span>
    <span class="s1">pending: </span><span class="s2">true</span>
<span class="s1">};</span>
<span class="s2">const </span><span class="s1">IDLE_LINK_STATUS = {</span>
    <span class="s1">pending: </span><span class="s2">false</span>
<span class="s1">};</span>
<span class="s2">function </span><span class="s1">setLinkForCurrentNavigation(link) {</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _react.startTransition)(()=&gt;{</span>
        <span class="s1">linkForMostRecentNavigation == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: linkForMostRecentNavigation.setOptimisticLinkStatus(IDLE_LINK_STATUS);</span>
        <span class="s1">link == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: link.setOptimisticLinkStatus(PENDING_LINK_STATUS);</span>
        <span class="s1">linkForMostRecentNavigation = link;</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">unmountLinkForCurrentNavigation(link) {</span>
    <span class="s2">if </span><span class="s1">(linkForMostRecentNavigation === link) {</span>
        <span class="s1">linkForMostRecentNavigation = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s4">// Use a WeakMap to associate a Link instance with its DOM element. This is</span>
<span class="s4">// used by the IntersectionObserver to track the link's visibility.</span>
<span class="s2">const </span><span class="s1">prefetchable = </span><span class="s2">typeof </span><span class="s1">WeakMap === </span><span class="s0">'function' </span><span class="s1">? </span><span class="s2">new </span><span class="s1">WeakMap() : </span><span class="s2">new </span><span class="s1">Map();</span>
<span class="s4">// A Set of the currently visible links. We re-prefetch visible links after a</span>
<span class="s4">// cache invalidation, or when the current URL changes. It's a separate data</span>
<span class="s4">// structure from the WeakMap above because only the visible links need to</span>
<span class="s4">// be enumerated.</span>
<span class="s2">const </span><span class="s1">prefetchableAndVisible = </span><span class="s2">new </span><span class="s1">Set();</span>
<span class="s4">// A single IntersectionObserver instance shared by all &lt;Link&gt; components.</span>
<span class="s2">const </span><span class="s1">observer = </span><span class="s2">typeof </span><span class="s1">IntersectionObserver === </span><span class="s0">'function' </span><span class="s1">? </span><span class="s2">new </span><span class="s1">IntersectionObserver(handleIntersect, {</span>
    <span class="s1">rootMargin: </span><span class="s0">'200px'</span>
<span class="s1">}) : </span><span class="s2">null</span><span class="s1">;</span>
<span class="s2">function </span><span class="s1">observeVisibility(element, instance) {</span>
    <span class="s2">const </span><span class="s1">existingInstance = prefetchable.get(element);</span>
    <span class="s2">if </span><span class="s1">(existingInstance !== undefined) {</span>
        <span class="s4">// This shouldn't happen because each &lt;Link&gt; component should have its own</span>
        <span class="s4">// anchor tag instance, but it's defensive coding to avoid a memory leak in</span>
        <span class="s4">// case there's a logical error somewhere else.</span>
        <span class="s1">unmountPrefetchableInstance(element);</span>
    <span class="s1">}</span>
    <span class="s4">// Only track prefetchable links that have a valid prefetch URL</span>
    <span class="s1">prefetchable.set(element, instance);</span>
    <span class="s2">if </span><span class="s1">(observer !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">observer.observe(element);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">coercePrefetchableUrl(href) {</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _approuter.createPrefetchURL)(href);</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
        <span class="s4">// createPrefetchURL sometimes throws an error if an invalid URL is</span>
        <span class="s4">// provided, though I'm not sure if it's actually necessary.</span>
        <span class="s4">// TODO: Consider removing the throw from the inner function, or change it</span>
        <span class="s4">// to reportError. Or maybe the error isn't even necessary for automatic</span>
        <span class="s4">// prefetches, just navigations.</span>
        <span class="s2">const </span><span class="s1">reportErrorFn = </span><span class="s2">typeof </span><span class="s1">reportError === </span><span class="s0">'function' </span><span class="s1">? reportError : console.error;</span>
        <span class="s1">reportErrorFn(</span><span class="s0">&quot;Cannot prefetch '&quot; </span><span class="s1">+ href + </span><span class="s0">&quot;' because it cannot be converted to a URL.&quot;</span><span class="s1">);</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">mountLinkInstance(element, href, router, fetchStrategy, prefetchEnabled, setOptimisticLinkStatus) {</span>
    <span class="s2">if </span><span class="s1">(prefetchEnabled) {</span>
        <span class="s2">const </span><span class="s1">prefetchURL = coercePrefetchableUrl(href);</span>
        <span class="s2">if </span><span class="s1">(prefetchURL !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">instance = {</span>
                <span class="s1">router,</span>
                <span class="s1">fetchStrategy,</span>
                <span class="s1">isVisible: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">prefetchTask: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">prefetchHref: prefetchURL.href,</span>
                <span class="s1">setOptimisticLinkStatus</span>
            <span class="s1">};</span>
            <span class="s4">// We only observe the link's visibility if it's prefetchable. For</span>
            <span class="s4">// example, this excludes links to external URLs.</span>
            <span class="s1">observeVisibility(element, instance);</span>
            <span class="s2">return </span><span class="s1">instance;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">// If the link is not prefetchable, we still create an instance so we can</span>
    <span class="s4">// track its optimistic state (i.e. useLinkStatus).</span>
    <span class="s2">const </span><span class="s1">instance = {</span>
        <span class="s1">router,</span>
        <span class="s1">fetchStrategy,</span>
        <span class="s1">isVisible: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">prefetchTask: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">prefetchHref: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">setOptimisticLinkStatus</span>
    <span class="s1">};</span>
    <span class="s2">return </span><span class="s1">instance;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">mountFormInstance(element, href, router, fetchStrategy) {</span>
    <span class="s2">const </span><span class="s1">prefetchURL = coercePrefetchableUrl(href);</span>
    <span class="s2">if </span><span class="s1">(prefetchURL === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s4">// This href is not prefetchable, so we don't track it.</span>
        <span class="s4">// TODO: We currently observe/unobserve a form every time its href changes.</span>
        <span class="s4">// For Links, this isn't a big deal because the href doesn't usually change,</span>
        <span class="s4">// but for forms it's extremely common. We should optimize this.</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">instance = {</span>
        <span class="s1">router,</span>
        <span class="s1">fetchStrategy,</span>
        <span class="s1">isVisible: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">prefetchTask: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">prefetchHref: prefetchURL.href,</span>
        <span class="s1">setOptimisticLinkStatus: </span><span class="s2">null</span>
    <span class="s1">};</span>
    <span class="s1">observeVisibility(element, instance);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">unmountPrefetchableInstance(element) {</span>
    <span class="s2">const </span><span class="s1">instance = prefetchable.get(element);</span>
    <span class="s2">if </span><span class="s1">(instance !== undefined) {</span>
        <span class="s1">prefetchable.delete(element);</span>
        <span class="s1">prefetchableAndVisible.delete(instance);</span>
        <span class="s2">const </span><span class="s1">prefetchTask = instance.prefetchTask;</span>
        <span class="s2">if </span><span class="s1">(prefetchTask !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _segmentcache.cancelPrefetchTask)(prefetchTask);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(observer !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">observer.unobserve(element);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">handleIntersect(entries) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">entry of entries){</span>
        <span class="s4">// Some extremely old browsers or polyfills don't reliably support</span>
        <span class="s4">// isIntersecting so we check intersectionRatio instead. (Do we care? Not</span>
        <span class="s4">// really. But whatever this is fine.)</span>
        <span class="s2">const </span><span class="s1">isVisible = entry.intersectionRatio &gt; </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s1">onLinkVisibilityChanged(entry.target, isVisible);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">onLinkVisibilityChanged(element, isVisible) {</span>
    <span class="s2">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s0">'production'</span><span class="s1">) {</span>
        <span class="s4">// Prefetching on viewport is disabled in development for performance</span>
        <span class="s4">// reasons, because it requires compiling the target page.</span>
        <span class="s4">// TODO: Investigate re-enabling this.</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">instance = prefetchable.get(element);</span>
    <span class="s2">if </span><span class="s1">(instance === undefined) {</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">instance.isVisible = isVisible;</span>
    <span class="s2">if </span><span class="s1">(isVisible) {</span>
        <span class="s1">prefetchableAndVisible.add(instance);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">prefetchableAndVisible.delete(instance);</span>
    <span class="s1">}</span>
    <span class="s1">rescheduleLinkPrefetch(instance, _segmentcache.PrefetchPriority.Default);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">onNavigationIntent(element, unstable_upgradeToDynamicPrefetch) {</span>
    <span class="s2">const </span><span class="s1">instance = prefetchable.get(element);</span>
    <span class="s2">if </span><span class="s1">(instance === undefined) {</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">// Prefetch the link on hover/touchstart.</span>
    <span class="s2">if </span><span class="s1">(instance !== undefined) {</span>
        <span class="s2">if </span><span class="s1">(process.env.__NEXT_DYNAMIC_ON_HOVER &amp;&amp; unstable_upgradeToDynamicPrefetch) {</span>
            <span class="s4">// Switch to a full prefetch</span>
            <span class="s1">instance.fetchStrategy = _segmentcache.FetchStrategy.Full;</span>
        <span class="s1">}</span>
        <span class="s1">rescheduleLinkPrefetch(instance, _segmentcache.PrefetchPriority.Intent);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">rescheduleLinkPrefetch(instance, priority) {</span>
    <span class="s2">const </span><span class="s1">existingPrefetchTask = instance.prefetchTask;</span>
    <span class="s2">if </span><span class="s1">(!instance.isVisible) {</span>
        <span class="s4">// Cancel any in-progress prefetch task. (If it already finished then this</span>
        <span class="s4">// is a no-op.)</span>
        <span class="s2">if </span><span class="s1">(existingPrefetchTask !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _segmentcache.cancelPrefetchTask)(existingPrefetchTask);</span>
        <span class="s1">}</span>
        <span class="s4">// We don't need to reset the prefetchTask to null upon cancellation; an</span>
        <span class="s4">// old task object can be rescheduled with reschedulePrefetchTask. This is a</span>
        <span class="s4">// micro-optimization but also makes the code simpler (don't need to</span>
        <span class="s4">// worry about whether an old task object is stale).</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!process.env.__NEXT_CLIENT_SEGMENT_CACHE) {</span>
        <span class="s4">// The old prefetch implementation does not have different priority levels.</span>
        <span class="s4">// Just schedule a new prefetch task.</span>
        <span class="s1">prefetchWithOldCacheImplementation(instance);</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">appRouterState = (</span><span class="s3">0</span><span class="s1">, _approuterinstance.getCurrentAppRouterState)();</span>
    <span class="s2">if </span><span class="s1">(appRouterState !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">treeAtTimeOfPrefetch = appRouterState.tree;</span>
        <span class="s2">if </span><span class="s1">(existingPrefetchTask === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s4">// Initiate a prefetch task.</span>
            <span class="s2">const </span><span class="s1">nextUrl = appRouterState.nextUrl;</span>
            <span class="s2">const </span><span class="s1">cacheKey = (</span><span class="s3">0</span><span class="s1">, _segmentcache.createCacheKey)(instance.prefetchHref, nextUrl);</span>
            <span class="s1">instance.prefetchTask = (</span><span class="s3">0</span><span class="s1">, _segmentcache.schedulePrefetchTask)(cacheKey, treeAtTimeOfPrefetch, instance.fetchStrategy, priority, </span><span class="s2">null</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s4">// We already have an old task object that we can reschedule. This is</span>
            <span class="s4">// effectively the same as canceling the old task and creating a new one.</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _segmentcache.reschedulePrefetchTask)(existingPrefetchTask, treeAtTimeOfPrefetch, instance.fetchStrategy, priority);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">pingVisibleLinks(nextUrl, tree) {</span>
    <span class="s4">// For each currently visible link, cancel the existing prefetch task (if it</span>
    <span class="s4">// exists) and schedule a new one. This is effectively the same as if all the</span>
    <span class="s4">// visible links left and then re-entered the viewport.</span>
    <span class="s4">//</span>
    <span class="s4">// This is called when the Next-Url or the base tree changes, since those</span>
    <span class="s4">// may affect the result of a prefetch task. It's also called after a</span>
    <span class="s4">// cache invalidation.</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">instance of prefetchableAndVisible){</span>
        <span class="s2">const </span><span class="s1">task = instance.prefetchTask;</span>
        <span class="s2">if </span><span class="s1">(task !== </span><span class="s2">null </span><span class="s1">&amp;&amp; !(</span><span class="s3">0</span><span class="s1">, _segmentcache.isPrefetchTaskDirty)(task, nextUrl, tree)) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">// Something changed. Cancel the existing prefetch task and schedule a</span>
        <span class="s4">// new one.</span>
        <span class="s2">if </span><span class="s1">(task !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _segmentcache.cancelPrefetchTask)(task);</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">cacheKey = (</span><span class="s3">0</span><span class="s1">, _segmentcache.createCacheKey)(instance.prefetchHref, nextUrl);</span>
        <span class="s1">instance.prefetchTask = (</span><span class="s3">0</span><span class="s1">, _segmentcache.schedulePrefetchTask)(cacheKey, tree, instance.fetchStrategy, _segmentcache.PrefetchPriority.Default, </span><span class="s2">null</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">prefetchWithOldCacheImplementation(instance) {</span>
    <span class="s4">// This is the path used when the Segment Cache is not enabled.</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">window === </span><span class="s0">'undefined'</span><span class="s1">) {</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">doPrefetch = async ()=&gt;{</span>
        <span class="s4">// note that `appRouter.prefetch()` is currently sync,</span>
        <span class="s4">// so we have to wrap this call in an async function to be able to catch() errors below.</span>
        <span class="s2">let </span><span class="s1">prefetchKind;</span>
        <span class="s2">switch</span><span class="s1">(instance.fetchStrategy){</span>
            <span class="s2">case </span><span class="s1">_segmentcache.FetchStrategy.PPR:</span>
                <span class="s1">{</span>
                    <span class="s1">prefetchKind = _routerreducertypes.PrefetchKind.AUTO;</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">_segmentcache.FetchStrategy.Full:</span>
                <span class="s1">{</span>
                    <span class="s1">prefetchKind = _routerreducertypes.PrefetchKind.FULL;</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">_segmentcache.FetchStrategy.PPRRuntime:</span>
                <span class="s1">{</span>
                    <span class="s4">// We can only get here if Client Segment Cache is off, and in that case</span>
                    <span class="s4">// it shouldn't be possible for a link to request a runtime prefetch.</span>
                    <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">'FetchStrategy.PPRRuntime should never be used when `experimental.clientSegmentCache` is disabled'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E772&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s1">{</span>
                    <span class="s1">instance.fetchStrategy;</span>
                    <span class="s4">// Unreachable, but otherwise typescript will consider the variable unassigned</span>
                    <span class="s1">prefetchKind = undefined;</span>
                <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">instance.router.prefetch(instance.prefetchHref, {</span>
            <span class="s1">kind: prefetchKind</span>
        <span class="s1">});</span>
    <span class="s1">};</span>
    <span class="s4">// Prefetch the page if asked (only in the client)</span>
    <span class="s4">// We need to handle a prefetch error here since we may be</span>
    <span class="s4">// loading with priority which can reject but we don't</span>
    <span class="s4">// want to force navigation since this is only a prefetch</span>
    <span class="s1">doPrefetch().catch((err)=&gt;{</span>
        <span class="s2">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s0">'production'</span><span class="s1">) {</span>
            <span class="s4">// rethrow to show invalid URL errors</span>
            <span class="s2">throw </span><span class="s1">err;</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
<span class="s1">}</span>

<span class="s2">if </span><span class="s1">((</span><span class="s2">typeof </span><span class="s1">exports.default === </span><span class="s0">'function' </span><span class="s1">|| (</span><span class="s2">typeof </span><span class="s1">exports.default === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; exports.default !== </span><span class="s2">null</span><span class="s1">)) &amp;&amp; </span><span class="s2">typeof </span><span class="s1">exports.default.__esModule === </span><span class="s0">'undefined'</span><span class="s1">) {</span>
  <span class="s1">Object.defineProperty(exports.default, </span><span class="s0">'__esModule'</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
  <span class="s1">Object.assign(exports.default, exports);</span>
  <span class="s1">module.exports = exports.default;</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=links.js.map</span></pre>
</body>
</html>