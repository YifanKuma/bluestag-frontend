<html>
<head>
<title>navigate-reducer.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
navigate-reducer.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">generateSegmentsFromPatch: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">handleExternalUrl: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">navigateReducer: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">generateSegmentsFromPatch: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">generateSegmentsFromPatch;</span>
    <span class="s1">},</span>
    <span class="s1">handleExternalUrl: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">handleExternalUrl;</span>
    <span class="s1">},</span>
    <span class="s1">navigateReducer: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">navigateReducer;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_fetchserverresponse = require(</span><span class="s0">&quot;../fetch-server-response&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_createhreffromurl = require(</span><span class="s0">&quot;../create-href-from-url&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_invalidatecachebelowflightsegmentpath = require(</span><span class="s0">&quot;../invalidate-cache-below-flight-segmentpath&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_applyrouterstatepatchtotree = require(</span><span class="s0">&quot;../apply-router-state-patch-to-tree&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_shouldhardnavigate = require(</span><span class="s0">&quot;../should-hard-navigate&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_isnavigatingtonewrootlayout = require(</span><span class="s0">&quot;../is-navigating-to-new-root-layout&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_routerreducertypes = require(</span><span class="s0">&quot;../router-reducer-types&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_handlemutable = require(</span><span class="s0">&quot;../handle-mutable&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_applyflightdata = require(</span><span class="s0">&quot;../apply-flight-data&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_prefetchreducer = require(</span><span class="s0">&quot;./prefetch-reducer&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_approuter = require(</span><span class="s0">&quot;../../app-router&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_segment = require(</span><span class="s0">&quot;../../../../shared/lib/segment&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_pprnavigations = require(</span><span class="s0">&quot;../ppr-navigations&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_prefetchcacheutils = require(</span><span class="s0">&quot;../prefetch-cache-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_clearcachenodedataforsegmentpath = require(</span><span class="s0">&quot;../clear-cache-node-data-for-segment-path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_aliasedprefetchnavigations = require(</span><span class="s0">&quot;../aliased-prefetch-navigations&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_segmentcache = require(</span><span class="s0">&quot;../../segment-cache&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">handleExternalUrl(state, mutable, url, pendingPush) {</span>
    <span class="s1">mutable.mpaNavigation = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">mutable.canonicalUrl = url;</span>
    <span class="s1">mutable.pendingPush = pendingPush;</span>
    <span class="s1">mutable.scrollableSegments = undefined;</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _handlemutable.handleMutable)(state, mutable);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">generateSegmentsFromPatch(flightRouterPatch) {</span>
    <span class="s2">const </span><span class="s1">segments = [];</span>
    <span class="s2">const </span><span class="s1">[segment, parallelRoutes] = flightRouterPatch;</span>
    <span class="s2">if </span><span class="s1">(Object.keys(parallelRoutes).length === </span><span class="s3">0</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">[</span>
            <span class="s1">[</span>
                <span class="s1">segment</span>
            <span class="s1">]</span>
        <span class="s1">];</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[parallelRouteKey, parallelRoute] of Object.entries(parallelRoutes)){</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">childSegment of generateSegmentsFromPatch(parallelRoute)){</span>
            <span class="s4">// If the segment is empty, it means we are at the root of the tree</span>
            <span class="s2">if </span><span class="s1">(segment === </span><span class="s0">''</span><span class="s1">) {</span>
                <span class="s1">segments.push([</span>
                    <span class="s1">parallelRouteKey,</span>
                    <span class="s1">...childSegment</span>
                <span class="s1">]);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">segments.push([</span>
                    <span class="s1">segment,</span>
                    <span class="s1">parallelRouteKey,</span>
                    <span class="s1">...childSegment</span>
                <span class="s1">]);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">segments;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">triggerLazyFetchForLeafSegments(newCache, currentCache, flightSegmentPath, treePatch) {</span>
    <span class="s2">let </span><span class="s1">appliedPatch = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">newCache.rsc = currentCache.rsc;</span>
    <span class="s1">newCache.prefetchRsc = currentCache.prefetchRsc;</span>
    <span class="s1">newCache.loading = currentCache.loading;</span>
    <span class="s1">newCache.parallelRoutes = </span><span class="s2">new </span><span class="s1">Map(currentCache.parallelRoutes);</span>
    <span class="s2">const </span><span class="s1">segmentPathsToFill = generateSegmentsFromPatch(treePatch).map((segment)=&gt;[</span>
            <span class="s1">...flightSegmentPath,</span>
            <span class="s1">...segment</span>
        <span class="s1">]);</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">segmentPaths of segmentPathsToFill){</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _clearcachenodedataforsegmentpath.clearCacheNodeDataForSegmentPath)(newCache, currentCache, segmentPaths);</span>
        <span class="s1">appliedPatch = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">appliedPatch;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">handleNavigationResult(url, state, mutable, pendingPush, result) {</span>
    <span class="s2">switch</span><span class="s1">(result.tag){</span>
        <span class="s2">case </span><span class="s1">_segmentcache.NavigationResultTag.MPA:</span>
            <span class="s1">{</span>
                <span class="s4">// Perform an MPA navigation.</span>
                <span class="s2">const </span><span class="s1">newUrl = result.data;</span>
                <span class="s2">return </span><span class="s1">handleExternalUrl(state, mutable, newUrl, pendingPush);</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s1">_segmentcache.NavigationResultTag.NoOp:</span>
            <span class="s1">{</span>
                <span class="s4">// The server responded with no change to the current page. However, if</span>
                <span class="s4">// the URL changed, we still need to update that.</span>
                <span class="s2">const </span><span class="s1">newCanonicalUrl = result.data.canonicalUrl;</span>
                <span class="s1">mutable.canonicalUrl = newCanonicalUrl;</span>
                <span class="s4">// Check if the only thing that changed was the hash fragment.</span>
                <span class="s2">const </span><span class="s1">oldUrl = </span><span class="s2">new </span><span class="s1">URL(state.canonicalUrl, url);</span>
                <span class="s2">const </span><span class="s1">onlyHashChange = </span><span class="s4">// We don't need to compare the origins, because client-driven</span>
                <span class="s4">// navigations are always same-origin.</span>
                <span class="s1">url.pathname === oldUrl.pathname &amp;&amp; url.search === oldUrl.search &amp;&amp; url.hash !== oldUrl.hash;</span>
                <span class="s2">if </span><span class="s1">(onlyHashChange) {</span>
                    <span class="s4">// The only updated part of the URL is the hash.</span>
                    <span class="s1">mutable.onlyHashChange = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s1">mutable.shouldScroll = result.data.shouldScroll;</span>
                    <span class="s1">mutable.hashFragment = url.hash;</span>
                    <span class="s4">// Setting this to an empty array triggers a scroll for all new and</span>
                    <span class="s4">// updated segments. See `ScrollAndFocusHandler` for more details.</span>
                    <span class="s1">mutable.scrollableSegments = [];</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _handlemutable.handleMutable)(state, mutable);</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s1">_segmentcache.NavigationResultTag.Success:</span>
            <span class="s1">{</span>
                <span class="s4">// Received a new result.</span>
                <span class="s1">mutable.cache = result.data.cacheNode;</span>
                <span class="s1">mutable.patchedTree = result.data.flightRouterState;</span>
                <span class="s1">mutable.canonicalUrl = result.data.canonicalUrl;</span>
                <span class="s1">mutable.scrollableSegments = result.data.scrollableSegments;</span>
                <span class="s1">mutable.shouldScroll = result.data.shouldScroll;</span>
                <span class="s1">mutable.hashFragment = result.data.hash;</span>
                <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _handlemutable.handleMutable)(state, mutable);</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s1">_segmentcache.NavigationResultTag.Async:</span>
            <span class="s1">{</span>
                <span class="s2">return </span><span class="s1">result.data.then((asyncResult)=&gt;handleNavigationResult(url, state, mutable, pendingPush, asyncResult), </span><span class="s4">// If the navigation failed, return the current state.</span>
                <span class="s4">// TODO: This matches the current behavior but we need to do something</span>
                <span class="s4">// better here if the network fails.</span>
                <span class="s1">()=&gt;{</span>
                    <span class="s2">return </span><span class="s1">state;</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s1">result;</span>
                <span class="s2">return </span><span class="s1">state;</span>
            <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">navigateReducer(state, action) {</span>
    <span class="s2">const </span><span class="s1">{ url, isExternalUrl, navigateType, shouldScroll, allowAliasing } = action;</span>
    <span class="s2">const </span><span class="s1">mutable = {};</span>
    <span class="s2">const </span><span class="s1">{ hash } = url;</span>
    <span class="s2">const </span><span class="s1">href = (</span><span class="s3">0</span><span class="s1">, _createhreffromurl.createHrefFromUrl)(url);</span>
    <span class="s2">const </span><span class="s1">pendingPush = navigateType === </span><span class="s0">'push'</span><span class="s1">;</span>
    <span class="s4">// we want to prune the prefetch cache on every navigation to avoid it growing too large</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);</span>
    <span class="s1">mutable.preserveCustomHistoryState = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">mutable.pendingPush = pendingPush;</span>
    <span class="s2">if </span><span class="s1">(isExternalUrl) {</span>
        <span class="s2">return </span><span class="s1">handleExternalUrl(state, mutable, url.toString(), pendingPush);</span>
    <span class="s1">}</span>
    <span class="s4">// Handles case where `&lt;meta http-equiv=&quot;refresh&quot;&gt;` tag is present,</span>
    <span class="s4">// which will trigger an MPA navigation.</span>
    <span class="s2">if </span><span class="s1">(document.getElementById(</span><span class="s0">'__next-page-redirect'</span><span class="s1">)) {</span>
        <span class="s2">return </span><span class="s1">handleExternalUrl(state, mutable, href, pendingPush);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(process.env.__NEXT_CLIENT_SEGMENT_CACHE) {</span>
        <span class="s4">// (Very Early Experimental Feature) Segment Cache</span>
        <span class="s4">//</span>
        <span class="s4">// Bypass the normal prefetch cache and use the new per-segment cache</span>
        <span class="s4">// implementation instead. This is only supported if PPR is enabled, too.</span>
        <span class="s4">//</span>
        <span class="s4">// Temporary glue code between the router reducer and the new navigation</span>
        <span class="s4">// implementation. Eventually we'll rewrite the router reducer to a</span>
        <span class="s4">// state machine.</span>
        <span class="s2">const </span><span class="s1">result = (</span><span class="s3">0</span><span class="s1">, _segmentcache.navigate)(url, state.cache, state.tree, state.nextUrl, shouldScroll);</span>
        <span class="s2">return </span><span class="s1">handleNavigationResult(url, state, mutable, pendingPush, result);</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">prefetchValues = (</span><span class="s3">0</span><span class="s1">, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({</span>
        <span class="s1">url,</span>
        <span class="s1">nextUrl: state.nextUrl,</span>
        <span class="s1">tree: state.tree,</span>
        <span class="s1">prefetchCache: state.prefetchCache,</span>
        <span class="s1">allowAliasing</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">{ treeAtTimeOfPrefetch, data } = prefetchValues;</span>
    <span class="s1">_prefetchreducer.prefetchQueue.bump(data);</span>
    <span class="s2">return </span><span class="s1">data.then((param)=&gt;{</span>
        <span class="s2">let </span><span class="s1">{ flightData, canonicalUrl: canonicalUrlOverride, postponed } = param;</span>
        <span class="s2">const </span><span class="s1">navigatedAt = Date.now();</span>
        <span class="s2">let </span><span class="s1">isFirstRead = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s4">// we only want to mark this once</span>
        <span class="s2">if </span><span class="s1">(!prefetchValues.lastUsedTime) {</span>
            <span class="s4">// important: we should only mark the cache node as dirty after we unsuspend from the call above</span>
            <span class="s1">prefetchValues.lastUsedTime = navigatedAt;</span>
            <span class="s1">isFirstRead = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(prefetchValues.aliased) {</span>
            <span class="s4">// When alias is enabled, search param may not be included in the canonicalUrl.</span>
            <span class="s4">// But we want to set url to canonicalUrl so that we use redirected path for fetching dynamic data.</span>
            <span class="s2">const </span><span class="s1">urlWithCanonicalPathname = </span><span class="s2">new </span><span class="s1">URL(url.href);</span>
            <span class="s2">if </span><span class="s1">(canonicalUrlOverride) {</span>
                <span class="s1">urlWithCanonicalPathname.pathname = canonicalUrlOverride.pathname;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">result = (</span><span class="s3">0</span><span class="s1">, _aliasedprefetchnavigations.handleAliasedPrefetchEntry)(navigatedAt, state, flightData, urlWithCanonicalPathname, mutable);</span>
            <span class="s4">// We didn't return new router state because we didn't apply the aliased entry for some reason.</span>
            <span class="s4">// We'll re-invoke the navigation handler but ensure that we don't attempt to use the aliased entry. This</span>
            <span class="s4">// will create an on-demand prefetch entry.</span>
            <span class="s2">if </span><span class="s1">(result === </span><span class="s2">false</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">navigateReducer(state, {</span>
                    <span class="s1">...action,</span>
                    <span class="s1">allowAliasing: </span><span class="s2">false</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">result;</span>
        <span class="s1">}</span>
        <span class="s4">// Handle case when navigating to page in `pages` from `app`</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">flightData === </span><span class="s0">'string'</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">handleExternalUrl(state, mutable, flightData, pendingPush);</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">updatedCanonicalUrl = canonicalUrlOverride ? (</span><span class="s3">0</span><span class="s1">, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : href;</span>
        <span class="s2">const </span><span class="s1">onlyHashChange = !!hash &amp;&amp; state.canonicalUrl.split(</span><span class="s0">'#'</span><span class="s1">, </span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">] === updatedCanonicalUrl.split(</span><span class="s0">'#'</span><span class="s1">, </span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">];</span>
        <span class="s4">// If only the hash has changed, the server hasn't sent us any new data. We can just update</span>
        <span class="s4">// the mutable properties responsible for URL and scroll handling and return early.</span>
        <span class="s2">if </span><span class="s1">(onlyHashChange) {</span>
            <span class="s1">mutable.onlyHashChange = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">mutable.canonicalUrl = updatedCanonicalUrl;</span>
            <span class="s1">mutable.shouldScroll = shouldScroll;</span>
            <span class="s1">mutable.hashFragment = hash;</span>
            <span class="s1">mutable.scrollableSegments = [];</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _handlemutable.handleMutable)(state, mutable);</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">currentTree = state.tree;</span>
        <span class="s2">let </span><span class="s1">currentCache = state.cache;</span>
        <span class="s2">let </span><span class="s1">scrollableSegments = [];</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">normalizedFlightData of flightData){</span>
            <span class="s2">const </span><span class="s1">{ pathToSegment: flightSegmentPath, seedData, head, isHeadPartial, isRootRender } = normalizedFlightData;</span>
            <span class="s2">let </span><span class="s1">treePatch = normalizedFlightData.tree;</span>
            <span class="s4">// TODO-APP: remove ''</span>
            <span class="s2">const </span><span class="s1">flightSegmentPathWithLeadingEmpty = [</span>
                <span class="s0">''</span><span class="s1">,</span>
                <span class="s1">...flightSegmentPath</span>
            <span class="s1">];</span>
            <span class="s4">// Create new tree based on the flightSegmentPath and router state patch</span>
            <span class="s2">let </span><span class="s1">newTree = (</span><span class="s3">0</span><span class="s1">, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(</span><span class="s4">// TODO-APP: remove ''</span>
            <span class="s1">flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);</span>
            <span class="s4">// If the tree patch can't be applied to the current tree then we use the tree at time of prefetch</span>
            <span class="s4">// TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.</span>
            <span class="s2">if </span><span class="s1">(newTree === </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s1">newTree = (</span><span class="s3">0</span><span class="s1">, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(</span><span class="s4">// TODO-APP: remove ''</span>
                <span class="s1">flightSegmentPathWithLeadingEmpty, treeAtTimeOfPrefetch, treePatch, href);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(newTree !== </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s4">// This is just a paranoid check. When a route is PPRed, the server</span>
                <span class="s4">// will send back a static response that's rendered from</span>
                <span class="s4">// the root. If for some reason it doesn't, we fall back to the</span>
                <span class="s4">// non-PPR implementation.</span>
                <span class="s4">// TODO: We should get rid of the else branch and do all navigations</span>
                <span class="s4">// via startPPRNavigation. The current structure is just</span>
                <span class="s4">// an incremental step.</span>
                <span class="s1">seedData &amp;&amp; isRootRender &amp;&amp; postponed) {</span>
                    <span class="s2">const </span><span class="s1">task = (</span><span class="s3">0</span><span class="s1">, _pprnavigations.startPPRNavigation)(navigatedAt, currentCache, currentTree, treePatch, seedData, head, isHeadPartial, </span><span class="s2">false</span><span class="s1">, scrollableSegments);</span>
                    <span class="s2">if </span><span class="s1">(task !== </span><span class="s2">null</span><span class="s1">) {</span>
                        <span class="s2">if </span><span class="s1">(task.route === </span><span class="s2">null</span><span class="s1">) {</span>
                            <span class="s4">// Detected a change to the root layout. Perform an full-</span>
                            <span class="s4">// page navigation.</span>
                            <span class="s2">return </span><span class="s1">handleExternalUrl(state, mutable, href, pendingPush);</span>
                        <span class="s1">}</span>
                        <span class="s4">// Use the tree computed by startPPRNavigation instead</span>
                        <span class="s4">// of the one computed by applyRouterStatePatchToTree.</span>
                        <span class="s4">// TODO: We should remove applyRouterStatePatchToTree</span>
                        <span class="s4">// from the PPR path entirely.</span>
                        <span class="s2">const </span><span class="s1">patchedRouterState = task.route;</span>
                        <span class="s1">newTree = patchedRouterState;</span>
                        <span class="s2">const </span><span class="s1">newCache = task.node;</span>
                        <span class="s2">if </span><span class="s1">(newCache !== </span><span class="s2">null</span><span class="s1">) {</span>
                            <span class="s4">// We've created a new Cache Node tree that contains a prefetched</span>
                            <span class="s4">// version of the next page. This can be rendered instantly.</span>
                            <span class="s1">mutable.cache = newCache;</span>
                        <span class="s1">}</span>
                        <span class="s2">const </span><span class="s1">dynamicRequestTree = task.dynamicRequestTree;</span>
                        <span class="s2">if </span><span class="s1">(dynamicRequestTree !== </span><span class="s2">null</span><span class="s1">) {</span>
                            <span class="s4">// The prefetched tree has dynamic holes in it. We initiate a</span>
                            <span class="s4">// dynamic request to fill them in.</span>
                            <span class="s4">//</span>
                            <span class="s4">// Do not block on the result. We'll immediately render the Cache</span>
                            <span class="s4">// Node tree and suspend on the dynamic parts. When the request</span>
                            <span class="s4">// comes in, we'll fill in missing data and ping React to</span>
                            <span class="s4">// re-render. Unlike the lazy fetching model in the non-PPR</span>
                            <span class="s4">// implementation, this is modeled as a single React update +</span>
                            <span class="s4">// streaming, rather than multiple top-level updates. (However,</span>
                            <span class="s4">// even in the new model, we'll still need to sometimes update the</span>
                            <span class="s4">// root multiple times per navigation, like if the server sends us</span>
                            <span class="s4">// a different response than we expected. For now, we revert back</span>
                            <span class="s4">// to the lazy fetching mechanism in that case.)</span>
                            <span class="s2">const </span><span class="s1">dynamicRequest = (</span><span class="s3">0</span><span class="s1">, _fetchserverresponse.fetchServerResponse)(</span><span class="s2">new </span><span class="s1">URL(updatedCanonicalUrl, url.origin), {</span>
                                <span class="s1">flightRouterState: dynamicRequestTree,</span>
                                <span class="s1">nextUrl: state.nextUrl</span>
                            <span class="s1">});</span>
                            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _pprnavigations.listenForDynamicRequest)(task, dynamicRequest);</span>
                        <span class="s4">// We store the dynamic request on the `lazyData` property of the CacheNode</span>
                        <span class="s4">// because we're not going to await the dynamic request here. Since we're not blocking</span>
                        <span class="s4">// on the dynamic request, `layout-router` will</span>
                        <span class="s4">// task.node.lazyData = dynamicRequest</span>
                        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s4">// The prefetched tree does not contain dynamic holes â€” it's</span>
                        <span class="s4">// fully static. We can skip the dynamic request.</span>
                        <span class="s1">}</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s4">// Nothing changed, so reuse the old cache.</span>
                        <span class="s4">// TODO: What if the head changed but not any of the segment data?</span>
                        <span class="s4">// Is that possible? If so, we should clone the whole tree and</span>
                        <span class="s4">// update the head.</span>
                        <span class="s1">newTree = treePatch;</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s4">// The static response does not include any dynamic holes, so</span>
                    <span class="s4">// there's no need to do a second request.</span>
                    <span class="s4">// TODO: As an incremental step this just reverts back to the</span>
                    <span class="s4">// non-PPR implementation. We can simplify this branch further,</span>
                    <span class="s4">// given that PPR prefetches are always static and return the whole</span>
                    <span class="s4">// tree. Or in the meantime we could factor it out into a</span>
                    <span class="s4">// separate function.</span>
                    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {</span>
                        <span class="s2">return </span><span class="s1">handleExternalUrl(state, mutable, href, pendingPush);</span>
                    <span class="s1">}</span>
                    <span class="s2">const </span><span class="s1">cache = (</span><span class="s3">0</span><span class="s1">, _approuter.createEmptyCacheNode)();</span>
                    <span class="s2">let </span><span class="s1">applied = </span><span class="s2">false</span><span class="s1">;</span>
                    <span class="s2">if </span><span class="s1">(prefetchValues.status === _routerreducertypes.PrefetchCacheEntryStatus.stale &amp;&amp; !isFirstRead) {</span>
                        <span class="s4">// When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations</span>
                        <span class="s4">// this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,</span>
                        <span class="s4">// while copying over the `loading` for the segment that contains the page data.</span>
                        <span class="s4">// We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.</span>
                        <span class="s4">// We skip this branch if only the hash fragment has changed, as we don't want to trigger a lazy fetch in that case</span>
                        <span class="s1">applied = triggerLazyFetchForLeafSegments(cache, currentCache, flightSegmentPath, treePatch);</span>
                        <span class="s4">// since we re-used the stale cache's loading state &amp; refreshed the data,</span>
                        <span class="s4">// update the `lastUsedTime` so that it can continue to be re-used for the next 30s</span>
                        <span class="s1">prefetchValues.lastUsedTime = navigatedAt;</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">applied = (</span><span class="s3">0</span><span class="s1">, _applyflightdata.applyFlightData)(navigatedAt, currentCache, cache, normalizedFlightData, prefetchValues);</span>
                    <span class="s1">}</span>
                    <span class="s2">const </span><span class="s1">hardNavigate = (</span><span class="s3">0</span><span class="s1">, _shouldhardnavigate.shouldHardNavigate)(</span><span class="s4">// TODO-APP: remove ''</span>
                    <span class="s1">flightSegmentPathWithLeadingEmpty, currentTree);</span>
                    <span class="s2">if </span><span class="s1">(hardNavigate) {</span>
                        <span class="s4">// Copy rsc for the root node of the cache.</span>
                        <span class="s1">cache.rsc = currentCache.rsc;</span>
                        <span class="s1">cache.prefetchRsc = currentCache.prefetchRsc;</span>
                        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _invalidatecachebelowflightsegmentpath.invalidateCacheBelowFlightSegmentPath)(cache, currentCache, flightSegmentPath);</span>
                        <span class="s4">// Ensure the existing cache value is used when the cache was not invalidated.</span>
                        <span class="s1">mutable.cache = cache;</span>
                    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(applied) {</span>
                        <span class="s1">mutable.cache = cache;</span>
                        <span class="s4">// If we applied the cache, we update the &quot;current cache&quot; value so any other</span>
                        <span class="s4">// segments in the FlightDataPath will be able to reference the updated cache.</span>
                        <span class="s1">currentCache = cache;</span>
                    <span class="s1">}</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">subSegment of generateSegmentsFromPatch(treePatch)){</span>
                        <span class="s2">const </span><span class="s1">scrollableSegmentPath = [</span>
                            <span class="s1">...flightSegmentPath,</span>
                            <span class="s1">...subSegment</span>
                        <span class="s1">];</span>
                        <span class="s4">// Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.</span>
                        <span class="s2">if </span><span class="s1">(scrollableSegmentPath[scrollableSegmentPath.length - </span><span class="s3">1</span><span class="s1">] !== _segment.DEFAULT_SEGMENT_KEY) {</span>
                            <span class="s1">scrollableSegments.push(scrollableSegmentPath);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s1">currentTree = newTree;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">mutable.patchedTree = currentTree;</span>
        <span class="s1">mutable.canonicalUrl = updatedCanonicalUrl;</span>
        <span class="s1">mutable.scrollableSegments = scrollableSegments;</span>
        <span class="s1">mutable.hashFragment = hash;</span>
        <span class="s1">mutable.shouldScroll = shouldScroll;</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _handlemutable.handleMutable)(state, mutable);</span>
    <span class="s1">}, ()=&gt;state);</span>
<span class="s1">}</span>

<span class="s2">if </span><span class="s1">((</span><span class="s2">typeof </span><span class="s1">exports.default === </span><span class="s0">'function' </span><span class="s1">|| (</span><span class="s2">typeof </span><span class="s1">exports.default === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; exports.default !== </span><span class="s2">null</span><span class="s1">)) &amp;&amp; </span><span class="s2">typeof </span><span class="s1">exports.default.__esModule === </span><span class="s0">'undefined'</span><span class="s1">) {</span>
  <span class="s1">Object.defineProperty(exports.default, </span><span class="s0">'__esModule'</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
  <span class="s1">Object.assign(exports.default, exports);</span>
  <span class="s1">module.exports = exports.default;</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=navigate-reducer.js.map</span></pre>
</body>
</html>