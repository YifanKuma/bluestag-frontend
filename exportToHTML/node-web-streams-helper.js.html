<html>
<head>
<title>node-web-streams-helper.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
node-web-streams-helper.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">chainStreams: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">continueDynamicHTMLResume: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">continueDynamicPrerender: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">continueFizzStream: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">continueStaticPrerender: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">createBufferedTransformStream: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">createDocumentClosingStream: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">createRootLayoutValidatorStream: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">renderToInitialFizzStream: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">streamFromBuffer: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">streamFromString: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">streamToBuffer: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">streamToString: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">chainStreams: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">chainStreams;</span>
    <span class="s1">},</span>
    <span class="s1">continueDynamicHTMLResume: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">continueDynamicHTMLResume;</span>
    <span class="s1">},</span>
    <span class="s1">continueDynamicPrerender: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">continueDynamicPrerender;</span>
    <span class="s1">},</span>
    <span class="s1">continueFizzStream: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">continueFizzStream;</span>
    <span class="s1">},</span>
    <span class="s1">continueStaticPrerender: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">continueStaticPrerender;</span>
    <span class="s1">},</span>
    <span class="s1">createBufferedTransformStream: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createBufferedTransformStream;</span>
    <span class="s1">},</span>
    <span class="s1">createDocumentClosingStream: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createDocumentClosingStream;</span>
    <span class="s1">},</span>
    <span class="s1">createRootLayoutValidatorStream: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createRootLayoutValidatorStream;</span>
    <span class="s1">},</span>
    <span class="s1">renderToInitialFizzStream: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">renderToInitialFizzStream;</span>
    <span class="s1">},</span>
    <span class="s1">streamFromBuffer: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">streamFromBuffer;</span>
    <span class="s1">},</span>
    <span class="s1">streamFromString: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">streamFromString;</span>
    <span class="s1">},</span>
    <span class="s1">streamToBuffer: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">streamToBuffer;</span>
    <span class="s1">},</span>
    <span class="s1">streamToString: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">streamToString;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_tracer = require(</span><span class="s0">&quot;../lib/trace/tracer&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants = require(</span><span class="s0">&quot;../lib/trace/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_detachedpromise = require(</span><span class="s0">&quot;../../lib/detached-promise&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_scheduler = require(</span><span class="s0">&quot;../../lib/scheduler&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_encodedtags = require(</span><span class="s0">&quot;./encoded-tags&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_uint8arrayhelpers = require(</span><span class="s0">&quot;./uint8array-helpers&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants1 = require(</span><span class="s0">&quot;../../shared/lib/errors/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_outputexportprefetchencoding = require(</span><span class="s0">&quot;../../shared/lib/segment-cache/output-export-prefetch-encoding&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">voidCatch() {</span>
<span class="s4">// this catcher is designed to be used with pipeTo where we expect the underlying</span>
<span class="s4">// pipe implementation to forward errors but we don't want the pipeTo promise to reject</span>
<span class="s4">// and be unhandled</span>
<span class="s1">}</span>
<span class="s4">// We can share the same encoder instance everywhere</span>
<span class="s4">// Notably we cannot do the same for TextDecoder because it is stateful</span>
<span class="s4">// when handling streaming data</span>
<span class="s2">const </span><span class="s1">encoder = </span><span class="s2">new </span><span class="s1">TextEncoder();</span>
<span class="s2">function </span><span class="s1">chainStreams(...streams) {</span>
    <span class="s4">// If we have no streams, return an empty stream. This behavior is</span>
    <span class="s4">// intentional as we're now providing the `RenderResult.EMPTY` value.</span>
    <span class="s2">if </span><span class="s1">(streams.length === </span><span class="s3">0</span><span class="s1">) {</span>
        <span class="s2">return new </span><span class="s1">ReadableStream({</span>
            <span class="s1">start (controller) {</span>
                <span class="s1">controller.close();</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s4">// If we only have 1 stream we fast path it by returning just this stream</span>
    <span class="s2">if </span><span class="s1">(streams.length === </span><span class="s3">1</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">streams[</span><span class="s3">0</span><span class="s1">];</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">{ readable, writable } = </span><span class="s2">new </span><span class="s1">TransformStream();</span>
    <span class="s4">// We always initiate pipeTo immediately. We know we have at least 2 streams</span>
    <span class="s4">// so we need to avoid closing the writable when this one finishes.</span>
    <span class="s2">let </span><span class="s1">promise = streams[</span><span class="s3">0</span><span class="s1">].pipeTo(writable, {</span>
        <span class="s1">preventClose: </span><span class="s2">true</span>
    <span class="s1">});</span>
    <span class="s2">let </span><span class="s1">i = </span><span class="s3">1</span><span class="s1">;</span>
    <span class="s2">for</span><span class="s1">(; i &lt; streams.length - </span><span class="s3">1</span><span class="s1">; i++){</span>
        <span class="s2">const </span><span class="s1">nextStream = streams[i];</span>
        <span class="s1">promise = promise.then(()=&gt;nextStream.pipeTo(writable, {</span>
                <span class="s1">preventClose: </span><span class="s2">true</span>
            <span class="s1">}));</span>
    <span class="s1">}</span>
    <span class="s4">// We can omit the length check because we halted before the last stream and there</span>
    <span class="s4">// is at least two streams so the lastStream here will always be defined</span>
    <span class="s2">const </span><span class="s1">lastStream = streams[i];</span>
    <span class="s1">promise = promise.then(()=&gt;lastStream.pipeTo(writable));</span>
    <span class="s4">// Catch any errors from the streams and ignore them, they will be handled</span>
    <span class="s4">// by whatever is consuming the readable stream.</span>
    <span class="s1">promise.catch(voidCatch);</span>
    <span class="s2">return </span><span class="s1">readable;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">streamFromString(str) {</span>
    <span class="s2">return new </span><span class="s1">ReadableStream({</span>
        <span class="s1">start (controller) {</span>
            <span class="s1">controller.enqueue(encoder.encode(str));</span>
            <span class="s1">controller.close();</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">streamFromBuffer(chunk) {</span>
    <span class="s2">return new </span><span class="s1">ReadableStream({</span>
        <span class="s1">start (controller) {</span>
            <span class="s1">controller.enqueue(chunk);</span>
            <span class="s1">controller.close();</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">streamToBuffer(stream) {</span>
    <span class="s2">const </span><span class="s1">reader = stream.getReader();</span>
    <span class="s2">const </span><span class="s1">chunks = [];</span>
    <span class="s2">while</span><span class="s1">(</span><span class="s2">true</span><span class="s1">){</span>
        <span class="s2">const </span><span class="s1">{ done, value } = </span><span class="s2">await </span><span class="s1">reader.read();</span>
        <span class="s2">if </span><span class="s1">(done) {</span>
            <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">chunks.push(value);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">Buffer.concat(chunks);</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">streamToString(stream, signal) {</span>
    <span class="s2">const </span><span class="s1">decoder = </span><span class="s2">new </span><span class="s1">TextDecoder(</span><span class="s0">'utf-8'</span><span class="s1">, {</span>
        <span class="s1">fatal: </span><span class="s2">true</span>
    <span class="s1">});</span>
    <span class="s2">let </span><span class="s1">string = </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">for await </span><span class="s1">(</span><span class="s2">const </span><span class="s1">chunk of stream){</span>
        <span class="s2">if </span><span class="s1">(signal == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: signal.aborted) {</span>
            <span class="s2">return </span><span class="s1">string;</span>
        <span class="s1">}</span>
        <span class="s1">string += decoder.decode(chunk, {</span>
            <span class="s1">stream: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">string += decoder.decode();</span>
    <span class="s2">return </span><span class="s1">string;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createBufferedTransformStream() {</span>
    <span class="s2">let </span><span class="s1">bufferedChunks = [];</span>
    <span class="s2">let </span><span class="s1">bufferByteLength = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">pending;</span>
    <span class="s2">const </span><span class="s1">flush = (controller)=&gt;{</span>
        <span class="s4">// If we already have a pending flush, then return early.</span>
        <span class="s2">if </span><span class="s1">(pending) </span><span class="s2">return</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">detached = </span><span class="s2">new </span><span class="s1">_detachedpromise.DetachedPromise();</span>
        <span class="s1">pending = detached;</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _scheduler.scheduleImmediate)(()=&gt;{</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s2">const </span><span class="s1">chunk = </span><span class="s2">new </span><span class="s1">Uint8Array(bufferByteLength);</span>
                <span class="s2">let </span><span class="s1">copiedBytes = </span><span class="s3">0</span><span class="s1">;</span>
                <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; bufferedChunks.length; i++){</span>
                    <span class="s2">const </span><span class="s1">bufferedChunk = bufferedChunks[i];</span>
                    <span class="s1">chunk.set(bufferedChunk, copiedBytes);</span>
                    <span class="s1">copiedBytes += bufferedChunk.byteLength;</span>
                <span class="s1">}</span>
                <span class="s4">// We just wrote all the buffered chunks so we need to reset the bufferedChunks array</span>
                <span class="s4">// and our bufferByteLength to prepare for the next round of buffered chunks</span>
                <span class="s1">bufferedChunks.length = </span><span class="s3">0</span><span class="s1">;</span>
                <span class="s1">bufferByteLength = </span><span class="s3">0</span><span class="s1">;</span>
                <span class="s1">controller.enqueue(chunk);</span>
            <span class="s1">} </span><span class="s2">catch  </span><span class="s1">{</span>
            <span class="s4">// If an error occurs while enqueuing it can't be due to this</span>
            <span class="s4">// transformers fault. It's likely due to the controller being</span>
            <span class="s4">// errored due to the stream being cancelled.</span>
            <span class="s1">} </span><span class="s2">finally</span><span class="s1">{</span>
                <span class="s1">pending = undefined;</span>
                <span class="s1">detached.resolve();</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
    <span class="s1">};</span>
    <span class="s2">return new </span><span class="s1">TransformStream({</span>
        <span class="s1">transform (chunk, controller) {</span>
            <span class="s4">// Combine the previous buffer with the new chunk.</span>
            <span class="s1">bufferedChunks.push(chunk);</span>
            <span class="s1">bufferByteLength += chunk.byteLength;</span>
            <span class="s4">// Flush the buffer to the controller.</span>
            <span class="s1">flush(controller);</span>
        <span class="s1">},</span>
        <span class="s1">flush () {</span>
            <span class="s2">if </span><span class="s1">(!pending) </span><span class="s2">return</span><span class="s1">;</span>
            <span class="s2">return </span><span class="s1">pending.promise;</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createPrefetchCommentStream(isBuildTimePrerendering, buildId) {</span>
    <span class="s4">// Insert an extra comment at the beginning of the HTML document. This must</span>
    <span class="s4">// come after the DOCTYPE, which is inserted by React.</span>
    <span class="s4">//</span>
    <span class="s4">// The first chunk sent by React will contain the doctype. After that, we can</span>
    <span class="s4">// pass through the rest of the chunks as-is.</span>
    <span class="s2">let </span><span class="s1">didTransformFirstChunk = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">return new </span><span class="s1">TransformStream({</span>
        <span class="s1">transform (chunk, controller) {</span>
            <span class="s2">if </span><span class="s1">(isBuildTimePrerendering &amp;&amp; !didTransformFirstChunk) {</span>
                <span class="s1">didTransformFirstChunk = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">decoder = </span><span class="s2">new </span><span class="s1">TextDecoder(</span><span class="s0">'utf-8'</span><span class="s1">, {</span>
                    <span class="s1">fatal: </span><span class="s2">true</span>
                <span class="s1">});</span>
                <span class="s2">const </span><span class="s1">chunkStr = decoder.decode(chunk, {</span>
                    <span class="s1">stream: </span><span class="s2">true</span>
                <span class="s1">});</span>
                <span class="s2">const </span><span class="s1">updatedChunkStr = (</span><span class="s3">0</span><span class="s1">, _outputexportprefetchencoding.insertBuildIdComment)(chunkStr, buildId);</span>
                <span class="s1">controller.enqueue(encoder.encode(updatedChunkStr));</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">controller.enqueue(chunk);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">renderToInitialFizzStream({ ReactDOMServer, element, streamOptions }) {</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _tracer.getTracer)().trace(_constants.AppRenderSpan.renderToReadableStream, async ()=&gt;ReactDOMServer.renderToReadableStream(element, streamOptions));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createMetadataTransformStream(insert) {</span>
    <span class="s2">let </span><span class="s1">chunkIndex = -</span><span class="s3">1</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">isMarkRemoved = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">return new </span><span class="s1">TransformStream({</span>
        <span class="s1">async transform (chunk, controller) {</span>
            <span class="s2">let </span><span class="s1">iconMarkIndex = -</span><span class="s3">1</span><span class="s1">;</span>
            <span class="s2">let </span><span class="s1">closedHeadIndex = -</span><span class="s3">1</span><span class="s1">;</span>
            <span class="s1">chunkIndex++;</span>
            <span class="s2">if </span><span class="s1">(isMarkRemoved) {</span>
                <span class="s1">controller.enqueue(chunk);</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">let </span><span class="s1">iconMarkLength = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s4">// Only search for the closed head tag once</span>
            <span class="s2">if </span><span class="s1">(iconMarkIndex === -</span><span class="s3">1</span><span class="s1">) {</span>
                <span class="s1">iconMarkIndex = (</span><span class="s3">0</span><span class="s1">, _uint8arrayhelpers.indexOfUint8Array)(chunk, _encodedtags.ENCODED_TAGS.META.ICON_MARK);</span>
                <span class="s2">if </span><span class="s1">(iconMarkIndex === -</span><span class="s3">1</span><span class="s1">) {</span>
                    <span class="s1">controller.enqueue(chunk);</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s4">// When we found the `&lt;meta name=&quot;«nxt-icon»&quot;` tag prefix, we will remove it from the chunk.</span>
                    <span class="s4">// Its close tag could either be `/&gt;` or `&gt;`, checking the next char to ensure we cover both cases.</span>
                    <span class="s1">iconMarkLength = _encodedtags.ENCODED_TAGS.META.ICON_MARK.length;</span>
                    <span class="s4">// Check if next char is /, this is for xml mode.</span>
                    <span class="s2">if </span><span class="s1">(chunk[iconMarkIndex + iconMarkLength] === </span><span class="s3">47</span><span class="s1">) {</span>
                        <span class="s1">iconMarkLength += </span><span class="s3">2</span><span class="s1">;</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s4">// The last char is `&gt;`</span>
                        <span class="s1">iconMarkLength++;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s4">// Check if icon mark is inside &lt;head&gt; tag in the first chunk.</span>
            <span class="s2">if </span><span class="s1">(chunkIndex === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">closedHeadIndex = (</span><span class="s3">0</span><span class="s1">, _uint8arrayhelpers.indexOfUint8Array)(chunk, _encodedtags.ENCODED_TAGS.CLOSED.HEAD);</span>
                <span class="s2">if </span><span class="s1">(iconMarkIndex !== -</span><span class="s3">1</span><span class="s1">) {</span>
                    <span class="s4">// The mark icon is located in the 1st chunk before the head tag.</span>
                    <span class="s4">// We do not need to insert the script tag in this case because it's in the head.</span>
                    <span class="s4">// Just remove the icon mark from the chunk.</span>
                    <span class="s2">if </span><span class="s1">(iconMarkIndex &lt; closedHeadIndex) {</span>
                        <span class="s2">const </span><span class="s1">replaced = </span><span class="s2">new </span><span class="s1">Uint8Array(chunk.length - iconMarkLength);</span>
                        <span class="s4">// Remove the icon mark from the chunk.</span>
                        <span class="s1">replaced.set(chunk.subarray(</span><span class="s3">0</span><span class="s1">, iconMarkIndex));</span>
                        <span class="s1">replaced.set(chunk.subarray(iconMarkIndex + iconMarkLength), iconMarkIndex);</span>
                        <span class="s1">chunk = replaced;</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s4">// The icon mark is after the head tag, replace and insert the script tag at that position.</span>
                        <span class="s2">const </span><span class="s1">insertion = </span><span class="s2">await </span><span class="s1">insert();</span>
                        <span class="s2">const </span><span class="s1">encodedInsertion = encoder.encode(insertion);</span>
                        <span class="s2">const </span><span class="s1">insertionLength = encodedInsertion.length;</span>
                        <span class="s2">const </span><span class="s1">replaced = </span><span class="s2">new </span><span class="s1">Uint8Array(chunk.length - iconMarkLength + insertionLength);</span>
                        <span class="s1">replaced.set(chunk.subarray(</span><span class="s3">0</span><span class="s1">, iconMarkIndex));</span>
                        <span class="s1">replaced.set(encodedInsertion, iconMarkIndex);</span>
                        <span class="s1">replaced.set(chunk.subarray(iconMarkIndex + iconMarkLength), iconMarkIndex + insertionLength);</span>
                        <span class="s1">chunk = replaced;</span>
                    <span class="s1">}</span>
                    <span class="s1">isMarkRemoved = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s4">// If there's no icon mark located, it will be handled later when if present in the following chunks.</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s4">// When it's appeared in the following chunks, we'll need to</span>
                <span class="s4">// remove the mark and then insert the script tag at that position.</span>
                <span class="s2">const </span><span class="s1">insertion = </span><span class="s2">await </span><span class="s1">insert();</span>
                <span class="s2">const </span><span class="s1">encodedInsertion = encoder.encode(insertion);</span>
                <span class="s2">const </span><span class="s1">insertionLength = encodedInsertion.length;</span>
                <span class="s4">// Replace the icon mark with the hoist script or empty string.</span>
                <span class="s2">const </span><span class="s1">replaced = </span><span class="s2">new </span><span class="s1">Uint8Array(chunk.length - iconMarkLength + insertionLength);</span>
                <span class="s4">// Set the first part of the chunk, before the icon mark.</span>
                <span class="s1">replaced.set(chunk.subarray(</span><span class="s3">0</span><span class="s1">, iconMarkIndex));</span>
                <span class="s4">// Set the insertion after the icon mark.</span>
                <span class="s1">replaced.set(encodedInsertion, iconMarkIndex);</span>
                <span class="s4">// Set the rest of the chunk after the icon mark.</span>
                <span class="s1">replaced.set(chunk.subarray(iconMarkIndex + iconMarkLength), iconMarkIndex + insertionLength);</span>
                <span class="s1">chunk = replaced;</span>
                <span class="s1">isMarkRemoved = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">controller.enqueue(chunk);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createHeadInsertionTransformStream(insert) {</span>
    <span class="s2">let </span><span class="s1">inserted = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s4">// We need to track if this transform saw any bytes because if it didn't</span>
    <span class="s4">// we won't want to insert any server HTML at all</span>
    <span class="s2">let </span><span class="s1">hasBytes = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">return new </span><span class="s1">TransformStream({</span>
        <span class="s1">async transform (chunk, controller) {</span>
            <span class="s1">hasBytes = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">insertion = </span><span class="s2">await </span><span class="s1">insert();</span>
            <span class="s2">if </span><span class="s1">(inserted) {</span>
                <span class="s2">if </span><span class="s1">(insertion) {</span>
                    <span class="s2">const </span><span class="s1">encodedInsertion = encoder.encode(insertion);</span>
                    <span class="s1">controller.enqueue(encodedInsertion);</span>
                <span class="s1">}</span>
                <span class="s1">controller.enqueue(chunk);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s4">// TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.</span>
                <span class="s2">const </span><span class="s1">index = (</span><span class="s3">0</span><span class="s1">, _uint8arrayhelpers.indexOfUint8Array)(chunk, _encodedtags.ENCODED_TAGS.CLOSED.HEAD);</span>
                <span class="s4">// In fully static rendering or non PPR rendering cases:</span>
                <span class="s4">// `/head&gt;` will always be found in the chunk in first chunk rendering.</span>
                <span class="s2">if </span><span class="s1">(index !== -</span><span class="s3">1</span><span class="s1">) {</span>
                    <span class="s2">if </span><span class="s1">(insertion) {</span>
                        <span class="s2">const </span><span class="s1">encodedInsertion = encoder.encode(insertion);</span>
                        <span class="s4">// Get the total count of the bytes in the chunk and the insertion</span>
                        <span class="s4">// e.g.</span>
                        <span class="s4">// chunk = &lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;</span>
                        <span class="s4">// insertion = &lt;script&gt;...&lt;/script&gt;</span>
                        <span class="s4">// output = &lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; [ &lt;script&gt;...&lt;/script&gt; ] &lt;/head&gt;</span>
                        <span class="s2">const </span><span class="s1">insertedHeadContent = </span><span class="s2">new </span><span class="s1">Uint8Array(chunk.length + encodedInsertion.length);</span>
                        <span class="s4">// Append the first part of the chunk, before the head tag</span>
                        <span class="s1">insertedHeadContent.set(chunk.slice(</span><span class="s3">0</span><span class="s1">, index));</span>
                        <span class="s4">// Append the server inserted content</span>
                        <span class="s1">insertedHeadContent.set(encodedInsertion, index);</span>
                        <span class="s4">// Append the rest of the chunk</span>
                        <span class="s1">insertedHeadContent.set(chunk.slice(index), index + encodedInsertion.length);</span>
                        <span class="s1">controller.enqueue(insertedHeadContent);</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">controller.enqueue(chunk);</span>
                    <span class="s1">}</span>
                    <span class="s1">inserted = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s4">// This will happens in PPR rendering during next start, when the page is partially rendered.</span>
                    <span class="s4">// When the page resumes, the head tag will be found in the middle of the chunk.</span>
                    <span class="s4">// Where we just need to append the insertion and chunk to the current stream.</span>
                    <span class="s4">// e.g.</span>
                    <span class="s4">// PPR-static: &lt;head&gt;...&lt;/head&gt;&lt;body&gt; [ resume content ] &lt;/body&gt;</span>
                    <span class="s4">// PPR-resume: [ insertion ] [ rest content ]</span>
                    <span class="s2">if </span><span class="s1">(insertion) {</span>
                        <span class="s1">controller.enqueue(encoder.encode(insertion));</span>
                    <span class="s1">}</span>
                    <span class="s1">controller.enqueue(chunk);</span>
                    <span class="s1">inserted = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">async flush (controller) {</span>
            <span class="s4">// Check before closing if there's anything remaining to insert.</span>
            <span class="s2">if </span><span class="s1">(hasBytes) {</span>
                <span class="s2">const </span><span class="s1">insertion = </span><span class="s2">await </span><span class="s1">insert();</span>
                <span class="s2">if </span><span class="s1">(insertion) {</span>
                    <span class="s1">controller.enqueue(encoder.encode(insertion));</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s4">// Suffix after main body content - scripts before &lt;/body&gt;,</span>
<span class="s4">// but wait for the major chunks to be enqueued.</span>
<span class="s2">function </span><span class="s1">createDeferredSuffixStream(suffix) {</span>
    <span class="s2">let </span><span class="s1">flushed = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">pending;</span>
    <span class="s2">const </span><span class="s1">flush = (controller)=&gt;{</span>
        <span class="s2">const </span><span class="s1">detached = </span><span class="s2">new </span><span class="s1">_detachedpromise.DetachedPromise();</span>
        <span class="s1">pending = detached;</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _scheduler.scheduleImmediate)(()=&gt;{</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s1">controller.enqueue(encoder.encode(suffix));</span>
            <span class="s1">} </span><span class="s2">catch  </span><span class="s1">{</span>
            <span class="s4">// If an error occurs while enqueuing it can't be due to this</span>
            <span class="s4">// transformers fault. It's likely due to the controller being</span>
            <span class="s4">// errored due to the stream being cancelled.</span>
            <span class="s1">} </span><span class="s2">finally</span><span class="s1">{</span>
                <span class="s1">pending = undefined;</span>
                <span class="s1">detached.resolve();</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
    <span class="s1">};</span>
    <span class="s2">return new </span><span class="s1">TransformStream({</span>
        <span class="s1">transform (chunk, controller) {</span>
            <span class="s1">controller.enqueue(chunk);</span>
            <span class="s4">// If we've already flushed, we're done.</span>
            <span class="s2">if </span><span class="s1">(flushed) </span><span class="s2">return</span><span class="s1">;</span>
            <span class="s4">// Schedule the flush to happen.</span>
            <span class="s1">flushed = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">flush(controller);</span>
        <span class="s1">},</span>
        <span class="s1">flush (controller) {</span>
            <span class="s2">if </span><span class="s1">(pending) </span><span class="s2">return </span><span class="s1">pending.promise;</span>
            <span class="s2">if </span><span class="s1">(flushed) </span><span class="s2">return</span><span class="s1">;</span>
            <span class="s4">// Flush now.</span>
            <span class="s1">controller.enqueue(encoder.encode(suffix));</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createFlightDataInjectionTransformStream(stream, delayDataUntilFirstHtmlChunk) {</span>
    <span class="s2">let </span><span class="s1">htmlStreamFinished = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">pull = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">donePulling = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">startOrContinuePulling(controller) {</span>
        <span class="s2">if </span><span class="s1">(!pull) {</span>
            <span class="s1">pull = startPulling(controller);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">pull;</span>
    <span class="s1">}</span>
    <span class="s1">async </span><span class="s2">function </span><span class="s1">startPulling(controller) {</span>
        <span class="s2">const </span><span class="s1">reader = stream.getReader();</span>
        <span class="s2">if </span><span class="s1">(delayDataUntilFirstHtmlChunk) {</span>
            <span class="s4">// NOTE: streaming flush</span>
            <span class="s4">// We are buffering here for the inlined data stream because the</span>
            <span class="s4">// &quot;shell&quot; stream might be chunkenized again by the underlying stream</span>
            <span class="s4">// implementation, e.g. with a specific high-water mark. To ensure it's</span>
            <span class="s4">// the safe timing to pipe the data stream, this extra tick is</span>
            <span class="s4">// necessary.</span>
            <span class="s4">// We don't start reading until we've left the current Task to ensure</span>
            <span class="s4">// that it's inserted after flushing the shell. Note that this implementation</span>
            <span class="s4">// might get stale if impl details of Fizz change in the future.</span>
            <span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _scheduler.atLeastOneTask)();</span>
        <span class="s1">}</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">while</span><span class="s1">(</span><span class="s2">true</span><span class="s1">){</span>
                <span class="s2">const </span><span class="s1">{ done, value } = </span><span class="s2">await </span><span class="s1">reader.read();</span>
                <span class="s2">if </span><span class="s1">(done) {</span>
                    <span class="s1">donePulling = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s4">// We want to prioritize HTML over RSC data.</span>
                <span class="s4">// The SSR render is based on the same RSC stream, so when we get a new RSC chunk,</span>
                <span class="s4">// we're likely to produce an HTML chunk as well, so give it a chance to flush first.</span>
                <span class="s2">if </span><span class="s1">(!delayDataUntilFirstHtmlChunk &amp;&amp; !htmlStreamFinished) {</span>
                    <span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _scheduler.atLeastOneTask)();</span>
                <span class="s1">}</span>
                <span class="s1">controller.enqueue(value);</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
            <span class="s1">controller.error(err);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return new </span><span class="s1">TransformStream({</span>
        <span class="s1">start (controller) {</span>
            <span class="s2">if </span><span class="s1">(!delayDataUntilFirstHtmlChunk) {</span>
                <span class="s1">startOrContinuePulling(controller);</span>
            <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">transform (chunk, controller) {</span>
            <span class="s1">controller.enqueue(chunk);</span>
            <span class="s4">// Start the streaming if it hasn't already been started yet.</span>
            <span class="s2">if </span><span class="s1">(delayDataUntilFirstHtmlChunk) {</span>
                <span class="s1">startOrContinuePulling(controller);</span>
            <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">flush (controller) {</span>
            <span class="s1">htmlStreamFinished = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(donePulling) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">startOrContinuePulling(controller);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">CLOSE_TAG = </span><span class="s0">'&lt;/body&gt;&lt;/html&gt;'</span><span class="s1">;</span>
<span class="s4">/**</span>
 <span class="s4">* This transform stream moves the suffix to the end of the stream, so results</span>
 <span class="s4">* like `&lt;/body&gt;&lt;/html&gt;&lt;script&gt;...&lt;/script&gt;` will be transformed to</span>
 <span class="s4">* `&lt;script&gt;...&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;`.</span>
 <span class="s4">*/ </span><span class="s2">function </span><span class="s1">createMoveSuffixStream() {</span>
    <span class="s2">let </span><span class="s1">foundSuffix = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">return new </span><span class="s1">TransformStream({</span>
        <span class="s1">transform (chunk, controller) {</span>
            <span class="s2">if </span><span class="s1">(foundSuffix) {</span>
                <span class="s2">return </span><span class="s1">controller.enqueue(chunk);</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">index = (</span><span class="s3">0</span><span class="s1">, _uint8arrayhelpers.indexOfUint8Array)(chunk, _encodedtags.ENCODED_TAGS.CLOSED.BODY_AND_HTML);</span>
            <span class="s2">if </span><span class="s1">(index &gt; -</span><span class="s3">1</span><span class="s1">) {</span>
                <span class="s1">foundSuffix = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s4">// If the whole chunk is the suffix, then don't write anything, it will</span>
                <span class="s4">// be written in the flush.</span>
                <span class="s2">if </span><span class="s1">(chunk.length === _encodedtags.ENCODED_TAGS.CLOSED.BODY_AND_HTML.length) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s4">// Write out the part before the suffix.</span>
                <span class="s2">const </span><span class="s1">before = chunk.slice(</span><span class="s3">0</span><span class="s1">, index);</span>
                <span class="s1">controller.enqueue(before);</span>
                <span class="s4">// In the case where the suffix is in the middle of the chunk, we need</span>
                <span class="s4">// to split the chunk into two parts.</span>
                <span class="s2">if </span><span class="s1">(chunk.length &gt; _encodedtags.ENCODED_TAGS.CLOSED.BODY_AND_HTML.length + index) {</span>
                    <span class="s4">// Write out the part after the suffix.</span>
                    <span class="s2">const </span><span class="s1">after = chunk.slice(index + _encodedtags.ENCODED_TAGS.CLOSED.BODY_AND_HTML.length);</span>
                    <span class="s1">controller.enqueue(after);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">controller.enqueue(chunk);</span>
            <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">flush (controller) {</span>
            <span class="s4">// Even if we didn't find the suffix, the HTML is not valid if we don't</span>
            <span class="s4">// add it, so insert it at the end.</span>
            <span class="s1">controller.enqueue(_encodedtags.ENCODED_TAGS.CLOSED.BODY_AND_HTML);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createStripDocumentClosingTagsTransform() {</span>
    <span class="s2">return new </span><span class="s1">TransformStream({</span>
        <span class="s1">transform (chunk, controller) {</span>
            <span class="s4">// We rely on the assumption that chunks will never break across a code unit.</span>
            <span class="s4">// This is reasonable because we currently concat all of React's output from a single</span>
            <span class="s4">// flush into one chunk before streaming it forward which means the chunk will represent</span>
            <span class="s4">// a single coherent utf-8 string. This is not safe to use if we change our streaming to no</span>
            <span class="s4">// longer do this large buffered chunk</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _uint8arrayhelpers.isEquivalentUint8Arrays)(chunk, _encodedtags.ENCODED_TAGS.CLOSED.BODY_AND_HTML) || (</span><span class="s3">0</span><span class="s1">, _uint8arrayhelpers.isEquivalentUint8Arrays)(chunk, _encodedtags.ENCODED_TAGS.CLOSED.BODY) || (</span><span class="s3">0</span><span class="s1">, _uint8arrayhelpers.isEquivalentUint8Arrays)(chunk, _encodedtags.ENCODED_TAGS.CLOSED.HTML)) {</span>
                <span class="s4">// the entire chunk is the closing tags; return without enqueueing anything.</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// We assume these tags will go at together at the end of the document and that</span>
            <span class="s4">// they won't appear anywhere else in the document. This is not really a safe assumption</span>
            <span class="s4">// but until we revamp our streaming infra this is a performant way to string the tags</span>
            <span class="s1">chunk = (</span><span class="s3">0</span><span class="s1">, _uint8arrayhelpers.removeFromUint8Array)(chunk, _encodedtags.ENCODED_TAGS.CLOSED.BODY);</span>
            <span class="s1">chunk = (</span><span class="s3">0</span><span class="s1">, _uint8arrayhelpers.removeFromUint8Array)(chunk, _encodedtags.ENCODED_TAGS.CLOSED.HTML);</span>
            <span class="s1">controller.enqueue(chunk);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createRootLayoutValidatorStream() {</span>
    <span class="s2">let </span><span class="s1">foundHtml = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">foundBody = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">return new </span><span class="s1">TransformStream({</span>
        <span class="s1">async transform (chunk, controller) {</span>
            <span class="s4">// Peek into the streamed chunk to see if the tags are present.</span>
            <span class="s2">if </span><span class="s1">(!foundHtml &amp;&amp; (</span><span class="s3">0</span><span class="s1">, _uint8arrayhelpers.indexOfUint8Array)(chunk, _encodedtags.ENCODED_TAGS.OPENING.HTML) &gt; -</span><span class="s3">1</span><span class="s1">) {</span>
                <span class="s1">foundHtml = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!foundBody &amp;&amp; (</span><span class="s3">0</span><span class="s1">, _uint8arrayhelpers.indexOfUint8Array)(chunk, _encodedtags.ENCODED_TAGS.OPENING.BODY) &gt; -</span><span class="s3">1</span><span class="s1">) {</span>
                <span class="s1">foundBody = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">controller.enqueue(chunk);</span>
        <span class="s1">},</span>
        <span class="s1">flush (controller) {</span>
            <span class="s2">const </span><span class="s1">missingTags = [];</span>
            <span class="s2">if </span><span class="s1">(!foundHtml) missingTags.push(</span><span class="s0">'html'</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(!foundBody) missingTags.push(</span><span class="s0">'body'</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(!missingTags.length) </span><span class="s2">return</span><span class="s1">;</span>
            <span class="s1">controller.enqueue(encoder.encode(</span><span class="s0">`&lt;html id=&quot;__next_error__&quot;&gt; 
            &lt;template 
              data-next-error-message=&quot;Missing </span><span class="s1">${missingTags.map((c)=&gt;</span><span class="s0">`&lt;</span><span class="s1">${c}</span><span class="s0">&gt;`</span><span class="s1">).join(missingTags.length &gt; </span><span class="s3">1 </span><span class="s1">? </span><span class="s0">' and ' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">)} </span><span class="s0">tags in the root layout.</span><span class="s5">\n</span><span class="s0">Read more at https://nextjs.org/docs/messages/missing-root-layout-tags&quot; 
              data-next-error-digest=&quot;</span><span class="s1">${_constants1.MISSING_ROOT_TAGS_ERROR}</span><span class="s0">&quot; 
              data-next-error-stack=&quot;&quot; 
            &gt;&lt;/template&gt; 
          `</span><span class="s1">));</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">chainTransformers(readable, transformers) {</span>
    <span class="s2">let </span><span class="s1">stream = readable;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">transformer of transformers){</span>
        <span class="s2">if </span><span class="s1">(!transformer) </span><span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">stream = stream.pipeThrough(transformer);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">stream;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">continueFizzStream(renderStream, { suffix, inlinedDataStream, isStaticGeneration, isBuildTimePrerendering, buildId, getServerInsertedHTML, getServerInsertedMetadata, validateRootLayout }) {</span>
    <span class="s4">// Suffix itself might contain close tags at the end, so we need to split it.</span>
    <span class="s2">const </span><span class="s1">suffixUnclosed = suffix ? suffix.split(CLOSE_TAG, </span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">] : </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s4">// If we're generating static HTML we need to wait for it to resolve before continuing.</span>
    <span class="s2">if </span><span class="s1">(isStaticGeneration) {</span>
        <span class="s2">await </span><span class="s1">renderStream.allReady;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">chainTransformers(renderStream, [</span>
        <span class="s4">// Buffer everything to avoid flushing too frequently</span>
        <span class="s1">createBufferedTransformStream(),</span>
        <span class="s4">// Add build id comment to start of the HTML document (in export mode)</span>
        <span class="s1">createPrefetchCommentStream(isBuildTimePrerendering, buildId),</span>
        <span class="s4">// Transform metadata</span>
        <span class="s1">createMetadataTransformStream(getServerInsertedMetadata),</span>
        <span class="s4">// Insert suffix content</span>
        <span class="s1">suffixUnclosed != </span><span class="s2">null </span><span class="s1">&amp;&amp; suffixUnclosed.length &gt; </span><span class="s3">0 </span><span class="s1">? createDeferredSuffixStream(suffixUnclosed) : </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s4">// Insert the inlined data (Flight data, form state, etc.) stream into the HTML</span>
        <span class="s1">inlinedDataStream ? createFlightDataInjectionTransformStream(inlinedDataStream, </span><span class="s2">true</span><span class="s1">) : </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s4">// Validate the root layout for missing html or body tags</span>
        <span class="s1">validateRootLayout ? createRootLayoutValidatorStream() : </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s4">// Close tags should always be deferred to the end</span>
        <span class="s1">createMoveSuffixStream(),</span>
        <span class="s4">// Special head insertions</span>
        <span class="s4">// TODO-APP: Insert server side html to end of head in app layout rendering, to avoid</span>
        <span class="s4">// hydration errors. Remove this once it's ready to be handled by react itself.</span>
        <span class="s1">createHeadInsertionTransformStream(getServerInsertedHTML)</span>
    <span class="s1">]);</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">continueDynamicPrerender(prerenderStream, { getServerInsertedHTML, getServerInsertedMetadata }) {</span>
    <span class="s2">return </span><span class="s1">prerenderStream</span><span class="s4">// Buffer everything to avoid flushing too frequently</span>
    <span class="s1">.pipeThrough(createBufferedTransformStream()).pipeThrough(createStripDocumentClosingTagsTransform())</span><span class="s4">// Insert generated tags to head</span>
    <span class="s1">.pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))</span><span class="s4">// Transform metadata</span>
    <span class="s1">.pipeThrough(createMetadataTransformStream(getServerInsertedMetadata));</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">continueStaticPrerender(prerenderStream, { inlinedDataStream, getServerInsertedHTML, getServerInsertedMetadata, isBuildTimePrerendering, buildId }) {</span>
    <span class="s2">return </span><span class="s1">prerenderStream</span><span class="s4">// Buffer everything to avoid flushing too frequently</span>
    <span class="s1">.pipeThrough(createBufferedTransformStream())</span><span class="s4">// Add build id comment to start of the HTML document (in export mode)</span>
    <span class="s1">.pipeThrough(createPrefetchCommentStream(isBuildTimePrerendering, buildId))</span><span class="s4">// Insert generated tags to head</span>
    <span class="s1">.pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))</span><span class="s4">// Transform metadata</span>
    <span class="s1">.pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))</span><span class="s4">// Insert the inlined data (Flight data, form state, etc.) stream into the HTML</span>
    <span class="s1">.pipeThrough(createFlightDataInjectionTransformStream(inlinedDataStream, </span><span class="s2">true</span><span class="s1">))</span><span class="s4">// Close tags should always be deferred to the end</span>
    <span class="s1">.pipeThrough(createMoveSuffixStream());</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">continueDynamicHTMLResume(renderStream, { delayDataUntilFirstHtmlChunk, inlinedDataStream, getServerInsertedHTML, getServerInsertedMetadata }) {</span>
    <span class="s2">return </span><span class="s1">renderStream</span><span class="s4">// Buffer everything to avoid flushing too frequently</span>
    <span class="s1">.pipeThrough(createBufferedTransformStream())</span><span class="s4">// Insert generated tags to head</span>
    <span class="s1">.pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))</span><span class="s4">// Transform metadata</span>
    <span class="s1">.pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))</span><span class="s4">// Insert the inlined data (Flight data, form state, etc.) stream into the HTML</span>
    <span class="s1">.pipeThrough(createFlightDataInjectionTransformStream(inlinedDataStream, delayDataUntilFirstHtmlChunk))</span><span class="s4">// Close tags should always be deferred to the end</span>
    <span class="s1">.pipeThrough(createMoveSuffixStream());</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createDocumentClosingStream() {</span>
    <span class="s2">return </span><span class="s1">streamFromString(CLOSE_TAG);</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=node-web-streams-helper.js.map</span></pre>
</body>
</html>