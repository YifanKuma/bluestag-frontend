<html>
<head>
<title>wasi-threads.cjs.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #1750eb;}
.s4 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
wasi-threads.cjs.js</font>
</center></td></tr></table>
<pre><span class="s0">const </span><span class="s1">_WebAssembly = </span><span class="s0">typeof </span><span class="s1">WebAssembly !== </span><span class="s2">'undefined'</span>
    <span class="s1">? WebAssembly</span>
    <span class="s1">: </span><span class="s0">typeof </span><span class="s1">WXWebAssembly !== </span><span class="s2">'undefined'</span>
        <span class="s1">? WXWebAssembly</span>
        <span class="s1">: undefined;</span>
<span class="s0">const </span><span class="s1">ENVIRONMENT_IS_NODE = </span><span class="s0">typeof </span><span class="s1">process === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; process !== </span><span class="s0">null </span><span class="s1">&amp;&amp;</span>
    <span class="s0">typeof </span><span class="s1">process.versions === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; process.versions !== </span><span class="s0">null </span><span class="s1">&amp;&amp;</span>
    <span class="s0">typeof </span><span class="s1">process.versions.node === </span><span class="s2">'string'</span><span class="s1">;</span>
<span class="s0">function </span><span class="s1">getPostMessage(options) {</span>
    <span class="s0">return typeof </span><span class="s1">(options === </span><span class="s0">null </span><span class="s1">|| options === </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">: options.postMessage) === </span><span class="s2">'function'</span>
        <span class="s1">? options.postMessage</span>
        <span class="s1">: </span><span class="s0">typeof </span><span class="s1">postMessage === </span><span class="s2">'function'</span>
            <span class="s1">? postMessage</span>
            <span class="s1">: undefined;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">serizeErrorToBuffer(sab, code, error) {</span>
    <span class="s0">const </span><span class="s1">i32array = </span><span class="s0">new </span><span class="s1">Int32Array(sab);</span>
    <span class="s1">Atomics.store(i32array, </span><span class="s3">0</span><span class="s1">, code);</span>
    <span class="s0">if </span><span class="s1">(code &gt; </span><span class="s3">1 </span><span class="s1">&amp;&amp; error) {</span>
        <span class="s0">const </span><span class="s1">name = error.name;</span>
        <span class="s0">const </span><span class="s1">message = error.message;</span>
        <span class="s0">const </span><span class="s1">stack = error.stack;</span>
        <span class="s0">const </span><span class="s1">nameBuffer = </span><span class="s0">new </span><span class="s1">TextEncoder().encode(name);</span>
        <span class="s0">const </span><span class="s1">messageBuffer = </span><span class="s0">new </span><span class="s1">TextEncoder().encode(message);</span>
        <span class="s0">const </span><span class="s1">stackBuffer = </span><span class="s0">new </span><span class="s1">TextEncoder().encode(stack);</span>
        <span class="s1">Atomics.store(i32array, </span><span class="s3">1</span><span class="s1">, nameBuffer.length);</span>
        <span class="s1">Atomics.store(i32array, </span><span class="s3">2</span><span class="s1">, messageBuffer.length);</span>
        <span class="s1">Atomics.store(i32array, </span><span class="s3">3</span><span class="s1">, stackBuffer.length);</span>
        <span class="s0">const </span><span class="s1">buffer = </span><span class="s0">new </span><span class="s1">Uint8Array(sab);</span>
        <span class="s1">buffer.set(nameBuffer, </span><span class="s3">16</span><span class="s1">);</span>
        <span class="s1">buffer.set(messageBuffer, </span><span class="s3">16 </span><span class="s1">+ nameBuffer.length);</span>
        <span class="s1">buffer.set(stackBuffer, </span><span class="s3">16 </span><span class="s1">+ nameBuffer.length + messageBuffer.length);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">deserizeErrorFromBuffer(sab) {</span>
    <span class="s0">var </span><span class="s1">_a, _b;</span>
    <span class="s0">const </span><span class="s1">i32array = </span><span class="s0">new </span><span class="s1">Int32Array(sab);</span>
    <span class="s0">const </span><span class="s1">status = Atomics.load(i32array, </span><span class="s3">0</span><span class="s1">);</span>
    <span class="s0">if </span><span class="s1">(status &lt;= </span><span class="s3">1</span><span class="s1">) {</span>
        <span class="s0">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">nameLength = Atomics.load(i32array, </span><span class="s3">1</span><span class="s1">);</span>
    <span class="s0">const </span><span class="s1">messageLength = Atomics.load(i32array, </span><span class="s3">2</span><span class="s1">);</span>
    <span class="s0">const </span><span class="s1">stackLength = Atomics.load(i32array, </span><span class="s3">3</span><span class="s1">);</span>
    <span class="s0">const </span><span class="s1">buffer = </span><span class="s0">new </span><span class="s1">Uint8Array(sab);</span>
    <span class="s0">const </span><span class="s1">nameBuffer = buffer.slice(</span><span class="s3">16</span><span class="s1">, </span><span class="s3">16 </span><span class="s1">+ nameLength);</span>
    <span class="s0">const </span><span class="s1">messageBuffer = buffer.slice(</span><span class="s3">16 </span><span class="s1">+ nameLength, </span><span class="s3">16 </span><span class="s1">+ nameLength + messageLength);</span>
    <span class="s0">const </span><span class="s1">stackBuffer = buffer.slice(</span><span class="s3">16 </span><span class="s1">+ nameLength + messageLength, </span><span class="s3">16 </span><span class="s1">+ nameLength + messageLength + stackLength);</span>
    <span class="s0">const </span><span class="s1">name = </span><span class="s0">new </span><span class="s1">TextDecoder().decode(nameBuffer);</span>
    <span class="s0">const </span><span class="s1">message = </span><span class="s0">new </span><span class="s1">TextDecoder().decode(messageBuffer);</span>
    <span class="s0">const </span><span class="s1">stack = </span><span class="s0">new </span><span class="s1">TextDecoder().decode(stackBuffer);</span>
    <span class="s0">const </span><span class="s1">ErrorConstructor = (_a = globalThis[name]) !== </span><span class="s0">null </span><span class="s1">&amp;&amp; _a !== </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">? _a : (name === </span><span class="s2">'RuntimeError' </span><span class="s1">? ((_b = _WebAssembly.RuntimeError) !== </span><span class="s0">null </span><span class="s1">&amp;&amp; _b !== </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">? _b : Error) : Error);</span>
    <span class="s0">const </span><span class="s1">error = </span><span class="s0">new </span><span class="s1">ErrorConstructor(message);</span>
    <span class="s1">Object.defineProperty(error, </span><span class="s2">'stack'</span><span class="s1">, {</span>
        <span class="s1">value: stack,</span>
        <span class="s1">writable: </span><span class="s0">true</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s0">false</span><span class="s1">,</span>
        <span class="s1">configurable: </span><span class="s0">true</span>
    <span class="s1">});</span>
    <span class="s0">return </span><span class="s1">error;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isSharedArrayBuffer(value) {</span>
    <span class="s0">return </span><span class="s1">((</span><span class="s0">typeof </span><span class="s1">SharedArrayBuffer === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; value </span><span class="s0">instanceof </span><span class="s1">SharedArrayBuffer) ||</span>
        <span class="s1">(Object.prototype.toString.call(value) === </span><span class="s2">'[object SharedArrayBuffer]'</span><span class="s1">));</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isTrapError(e) {</span>
    <span class="s0">try </span><span class="s1">{</span>
        <span class="s0">return </span><span class="s1">e </span><span class="s0">instanceof </span><span class="s1">_WebAssembly.RuntimeError;</span>
    <span class="s1">}</span>
    <span class="s0">catch </span><span class="s1">(_) {</span>
        <span class="s0">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">createMessage(type, payload) {</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">__emnapi__: {</span>
            <span class="s1">type,</span>
            <span class="s1">payload</span>
        <span class="s1">}</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">WASI_THREADS_MAX_TID = </span><span class="s3">0x1FFFFFFF</span><span class="s1">;</span>
<span class="s0">function </span><span class="s1">checkSharedWasmMemory(wasmMemory) {</span>
    <span class="s0">if </span><span class="s1">(wasmMemory) {</span>
        <span class="s0">if </span><span class="s1">(!isSharedArrayBuffer(wasmMemory.buffer)) {</span>
            <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">'Multithread features require shared wasm memory. ' </span><span class="s1">+</span>
                <span class="s2">'Try to compile with `-matomics -mbulk-memory` and use `--import-memory --shared-memory` during linking, ' </span><span class="s1">+</span>
                <span class="s2">'then create WebAssembly.Memory with `shared: true` option'</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">SharedArrayBuffer === </span><span class="s2">'undefined'</span><span class="s1">) {</span>
            <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">'Current environment does not support SharedArrayBuffer, threads are not available!'</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getReuseWorker(value) {</span>
    <span class="s0">var </span><span class="s1">_a;</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">value === </span><span class="s2">'boolean'</span><span class="s1">) {</span>
        <span class="s0">return </span><span class="s1">value ? { size: </span><span class="s3">0</span><span class="s1">, strict: </span><span class="s0">false </span><span class="s1">} : </span><span class="s0">false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">value === </span><span class="s2">'number'</span><span class="s1">) {</span>
        <span class="s0">if </span><span class="s1">(!(value &gt;= </span><span class="s3">0</span><span class="s1">)) {</span>
            <span class="s0">throw new </span><span class="s1">RangeError(</span><span class="s2">'reuseWorker: size must be a non-negative integer'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">{ size: value, strict: </span><span class="s0">false </span><span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(!value) {</span>
        <span class="s0">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">size = (_a = Number(value.size)) !== </span><span class="s0">null </span><span class="s1">&amp;&amp; _a !== </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">? _a : </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s0">const </span><span class="s1">strict = Boolean(value.strict);</span>
    <span class="s0">if </span><span class="s1">(!(size &gt; </span><span class="s3">0</span><span class="s1">) &amp;&amp; strict) {</span>
        <span class="s0">throw new </span><span class="s1">RangeError(</span><span class="s2">'reuseWorker: size must be set to positive integer if strict is set to true'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">{ size, strict };</span>
<span class="s1">}</span>
<span class="s0">let </span><span class="s1">nextWorkerID = </span><span class="s3">0</span><span class="s1">;</span>
<span class="s0">class </span><span class="s1">ThreadManager {</span>
    <span class="s1">get nextWorkerID() { </span><span class="s0">return </span><span class="s1">nextWorkerID; }</span>
    <span class="s1">constructor(options) {</span>
        <span class="s0">var </span><span class="s1">_a;</span>
        <span class="s0">this</span><span class="s1">.unusedWorkers = [];</span>
        <span class="s0">this</span><span class="s1">.runningWorkers = [];</span>
        <span class="s0">this</span><span class="s1">.pthreads = Object.create(</span><span class="s0">null</span><span class="s1">);</span>
        <span class="s0">this</span><span class="s1">.wasmModule = </span><span class="s0">null</span><span class="s1">;</span>
        <span class="s0">this</span><span class="s1">.wasmMemory = </span><span class="s0">null</span><span class="s1">;</span>
        <span class="s0">this</span><span class="s1">.messageEvents = </span><span class="s0">new </span><span class="s1">WeakMap();</span>
        <span class="s0">if </span><span class="s1">(!options) {</span>
            <span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">'ThreadManager(): options is not provided'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s2">'childThread' </span><span class="s0">in </span><span class="s1">options) {</span>
            <span class="s0">this</span><span class="s1">._childThread = Boolean(options.childThread);</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s0">this</span><span class="s1">._childThread = </span><span class="s0">false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">._childThread) {</span>
            <span class="s0">this</span><span class="s1">._onCreateWorker = undefined;</span>
            <span class="s0">this</span><span class="s1">._reuseWorker = </span><span class="s0">false</span><span class="s1">;</span>
            <span class="s0">this</span><span class="s1">._beforeLoad = undefined;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s0">this</span><span class="s1">._onCreateWorker = options.onCreateWorker;</span>
            <span class="s0">this</span><span class="s1">._reuseWorker = getReuseWorker(options.reuseWorker);</span>
            <span class="s0">this</span><span class="s1">._beforeLoad = options.beforeLoad;</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">.printErr = (_a = options.printErr) !== </span><span class="s0">null </span><span class="s1">&amp;&amp; _a !== </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">? _a : console.error.bind(console);</span>
    <span class="s1">}</span>
    <span class="s1">init() {</span>
        <span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">._childThread) {</span>
            <span class="s0">this</span><span class="s1">.initMainThread();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">initMainThread() {</span>
        <span class="s0">this</span><span class="s1">.preparePool();</span>
    <span class="s1">}</span>
    <span class="s1">preparePool() {</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">._reuseWorker) {</span>
            <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">._reuseWorker.size) {</span>
                <span class="s0">let </span><span class="s1">pthreadPoolSize = </span><span class="s0">this</span><span class="s1">._reuseWorker.size;</span>
                <span class="s0">while </span><span class="s1">(pthreadPoolSize--) {</span>
                    <span class="s0">const </span><span class="s1">worker = </span><span class="s0">this</span><span class="s1">.allocateUnusedWorker();</span>
                    <span class="s0">if </span><span class="s1">(ENVIRONMENT_IS_NODE) {</span>
                        <span class="s1">worker.once(</span><span class="s2">'message'</span><span class="s1">, () =&gt; { });</span>
                        <span class="s1">worker.unref();</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">shouldPreloadWorkers() {</span>
        <span class="s0">return </span><span class="s1">!</span><span class="s0">this</span><span class="s1">._childThread &amp;&amp; </span><span class="s0">this</span><span class="s1">._reuseWorker &amp;&amp; </span><span class="s0">this</span><span class="s1">._reuseWorker.size &gt; </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">loadWasmModuleToAllWorkers() {</span>
        <span class="s0">const </span><span class="s1">promises = Array(</span><span class="s0">this</span><span class="s1">.unusedWorkers.length);</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; </span><span class="s0">this</span><span class="s1">.unusedWorkers.length; ++i) {</span>
            <span class="s0">const </span><span class="s1">worker = </span><span class="s0">this</span><span class="s1">.unusedWorkers[i];</span>
            <span class="s0">if </span><span class="s1">(ENVIRONMENT_IS_NODE)</span>
                <span class="s1">worker.ref();</span>
            <span class="s1">promises[i] = </span><span class="s0">this</span><span class="s1">.loadWasmModuleToWorker(worker).then((w) =&gt; {</span>
                <span class="s0">if </span><span class="s1">(ENVIRONMENT_IS_NODE)</span>
                    <span class="s1">worker.unref();</span>
                <span class="s0">return </span><span class="s1">w;</span>
            <span class="s1">}, (e) =&gt; {</span>
                <span class="s0">if </span><span class="s1">(ENVIRONMENT_IS_NODE)</span>
                    <span class="s1">worker.unref();</span>
                <span class="s0">throw </span><span class="s1">e;</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">Promise.all(promises).catch((err) =&gt; {</span>
            <span class="s0">this</span><span class="s1">.terminateAllThreads();</span>
            <span class="s0">throw </span><span class="s1">err;</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">preloadWorkers() {</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.shouldPreloadWorkers()) {</span>
            <span class="s0">return this</span><span class="s1">.loadWasmModuleToAllWorkers();</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">Promise.resolve([]);</span>
    <span class="s1">}</span>
    <span class="s1">setup(wasmModule, wasmMemory) {</span>
        <span class="s0">this</span><span class="s1">.wasmModule = wasmModule;</span>
        <span class="s0">this</span><span class="s1">.wasmMemory = wasmMemory;</span>
    <span class="s1">}</span>
    <span class="s1">markId(worker) {</span>
        <span class="s0">if </span><span class="s1">(worker.__emnapi_tid)</span>
            <span class="s0">return </span><span class="s1">worker.__emnapi_tid;</span>
        <span class="s0">const </span><span class="s1">tid = nextWorkerID + </span><span class="s3">43</span><span class="s1">;</span>
        <span class="s1">nextWorkerID = (nextWorkerID + </span><span class="s3">1</span><span class="s1">) % (WASI_THREADS_MAX_TID - </span><span class="s3">42</span><span class="s1">);</span>
        <span class="s0">this</span><span class="s1">.pthreads[tid] = worker;</span>
        <span class="s1">worker.__emnapi_tid = tid;</span>
        <span class="s0">return </span><span class="s1">tid;</span>
    <span class="s1">}</span>
    <span class="s1">returnWorkerToPool(worker) {</span>
        <span class="s0">var </span><span class="s1">tid = worker.__emnapi_tid;</span>
        <span class="s0">if </span><span class="s1">(tid !== undefined) {</span>
            <span class="s0">delete this</span><span class="s1">.pthreads[tid];</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">.unusedWorkers.push(worker);</span>
        <span class="s0">this</span><span class="s1">.runningWorkers.splice(</span><span class="s0">this</span><span class="s1">.runningWorkers.indexOf(worker), </span><span class="s3">1</span><span class="s1">);</span>
        <span class="s0">delete </span><span class="s1">worker.__emnapi_tid;</span>
        <span class="s0">if </span><span class="s1">(ENVIRONMENT_IS_NODE) {</span>
            <span class="s1">worker.unref();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">loadWasmModuleToWorker(worker, sab) {</span>
        <span class="s0">if </span><span class="s1">(worker.whenLoaded)</span>
            <span class="s0">return </span><span class="s1">worker.whenLoaded;</span>
        <span class="s0">const </span><span class="s1">err = </span><span class="s0">this</span><span class="s1">.printErr;</span>
        <span class="s0">const </span><span class="s1">beforeLoad = </span><span class="s0">this</span><span class="s1">._beforeLoad;</span>
        <span class="s0">const </span><span class="s1">_this = </span><span class="s0">this</span><span class="s1">;</span>
        <span class="s1">worker.whenLoaded = </span><span class="s0">new </span><span class="s1">Promise((resolve, reject) =&gt; {</span>
            <span class="s0">const </span><span class="s1">handleError = </span><span class="s0">function </span><span class="s1">(e) {</span>
                <span class="s0">let </span><span class="s1">message = </span><span class="s2">'worker sent an error!'</span><span class="s1">;</span>
                <span class="s0">if </span><span class="s1">(worker.__emnapi_tid !== undefined) {</span>
                    <span class="s1">message = </span><span class="s2">'worker (tid = ' </span><span class="s1">+ worker.__emnapi_tid + </span><span class="s2">') sent an error!'</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">if </span><span class="s1">(</span><span class="s2">'message' </span><span class="s0">in </span><span class="s1">e) {</span>
                    <span class="s1">err(message + </span><span class="s2">' ' </span><span class="s1">+ e.message);</span>
                    <span class="s0">if </span><span class="s1">(e.message.indexOf(</span><span class="s2">'RuntimeError'</span><span class="s1">) !== -</span><span class="s3">1 </span><span class="s1">|| e.message.indexOf(</span><span class="s2">'unreachable'</span><span class="s1">) !== -</span><span class="s3">1</span><span class="s1">) {</span>
                        <span class="s0">try </span><span class="s1">{</span>
                            <span class="s1">_this.terminateAllThreads();</span>
                        <span class="s1">}</span>
                        <span class="s0">catch </span><span class="s1">(_) { }</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s1">err(message);</span>
                <span class="s1">}</span>
                <span class="s1">reject(e);</span>
                <span class="s0">throw </span><span class="s1">e;</span>
            <span class="s1">};</span>
            <span class="s0">const </span><span class="s1">handleMessage = (data) =&gt; {</span>
                <span class="s0">if </span><span class="s1">(data.__emnapi__) {</span>
                    <span class="s0">const </span><span class="s1">type = data.__emnapi__.type;</span>
                    <span class="s0">const </span><span class="s1">payload = data.__emnapi__.payload;</span>
                    <span class="s0">if </span><span class="s1">(type === </span><span class="s2">'loaded'</span><span class="s1">) {</span>
                        <span class="s1">worker.loaded = </span><span class="s0">true</span><span class="s1">;</span>
                        <span class="s0">if </span><span class="s1">(ENVIRONMENT_IS_NODE &amp;&amp; !worker.__emnapi_tid) {</span>
                            <span class="s1">worker.unref();</span>
                        <span class="s1">}</span>
                        <span class="s1">resolve(worker);</span>
                    <span class="s1">}</span>
                    <span class="s0">else if </span><span class="s1">(type === </span><span class="s2">'cleanup-thread'</span><span class="s1">) {</span>
                        <span class="s0">if </span><span class="s1">(payload.tid </span><span class="s0">in this</span><span class="s1">.pthreads) {</span>
                            <span class="s0">this</span><span class="s1">.cleanThread(worker, payload.tid);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">};</span>
            <span class="s1">worker.onmessage = (e) =&gt; {</span>
                <span class="s1">handleMessage(e.data);</span>
                <span class="s0">this</span><span class="s1">.fireMessageEvent(worker, e);</span>
            <span class="s1">};</span>
            <span class="s1">worker.onerror = handleError;</span>
            <span class="s0">if </span><span class="s1">(ENVIRONMENT_IS_NODE) {</span>
                <span class="s1">worker.on(</span><span class="s2">'message'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(data) {</span>
                    <span class="s0">var </span><span class="s1">_a, _b;</span>
                    <span class="s1">(_b = (_a = worker).onmessage) === </span><span class="s0">null </span><span class="s1">|| _b === </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">: _b.call(_a, {</span>
                        <span class="s1">data</span>
                    <span class="s1">});</span>
                <span class="s1">});</span>
                <span class="s1">worker.on(</span><span class="s2">'error'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(e) {</span>
                    <span class="s0">var </span><span class="s1">_a, _b;</span>
                    <span class="s1">(_b = (_a = worker).onerror) === </span><span class="s0">null </span><span class="s1">|| _b === </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">: _b.call(_a, e);</span>
                <span class="s1">});</span>
                <span class="s1">worker.on(</span><span class="s2">'detachedExit'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">() { });</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">beforeLoad === </span><span class="s2">'function'</span><span class="s1">) {</span>
                <span class="s1">beforeLoad(worker);</span>
            <span class="s1">}</span>
            <span class="s0">try </span><span class="s1">{</span>
                <span class="s1">worker.postMessage(createMessage(</span><span class="s2">'load'</span><span class="s1">, {</span>
                    <span class="s1">wasmModule: </span><span class="s0">this</span><span class="s1">.wasmModule,</span>
                    <span class="s1">wasmMemory: </span><span class="s0">this</span><span class="s1">.wasmMemory,</span>
                    <span class="s1">sab</span>
                <span class="s1">}));</span>
            <span class="s1">}</span>
            <span class="s0">catch </span><span class="s1">(err) {</span>
                <span class="s1">checkSharedWasmMemory(</span><span class="s0">this</span><span class="s1">.wasmMemory);</span>
                <span class="s0">throw </span><span class="s1">err;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s0">return </span><span class="s1">worker.whenLoaded;</span>
    <span class="s1">}</span>
    <span class="s1">allocateUnusedWorker() {</span>
        <span class="s0">const </span><span class="s1">_onCreateWorker = </span><span class="s0">this</span><span class="s1">._onCreateWorker;</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">_onCreateWorker !== </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">'`options.onCreateWorker` is not provided'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">worker = _onCreateWorker({ type: </span><span class="s2">'thread'</span><span class="s1">, name: </span><span class="s2">'emnapi-pthread' </span><span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.unusedWorkers.push(worker);</span>
        <span class="s0">return </span><span class="s1">worker;</span>
    <span class="s1">}</span>
    <span class="s1">getNewWorker(sab) {</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">._reuseWorker) {</span>
            <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.unusedWorkers.length === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">._reuseWorker.strict) {</span>
                    <span class="s0">if </span><span class="s1">(!ENVIRONMENT_IS_NODE) {</span>
                        <span class="s0">const </span><span class="s1">err = </span><span class="s0">this</span><span class="s1">.printErr;</span>
                        <span class="s1">err(</span><span class="s2">'Tried to spawn a new thread, but the thread pool is exhausted.</span><span class="s4">\n</span><span class="s2">' </span><span class="s1">+</span>
                            <span class="s2">'This might result in a deadlock unless some threads eventually exit or the code explicitly breaks out to the event loop.'</span><span class="s1">);</span>
                        <span class="s0">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s0">const </span><span class="s1">worker = </span><span class="s0">this</span><span class="s1">.allocateUnusedWorker();</span>
                <span class="s0">this</span><span class="s1">.loadWasmModuleToWorker(worker, sab);</span>
            <span class="s1">}</span>
            <span class="s0">return this</span><span class="s1">.unusedWorkers.pop();</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">worker = </span><span class="s0">this</span><span class="s1">.allocateUnusedWorker();</span>
        <span class="s0">this</span><span class="s1">.loadWasmModuleToWorker(worker, sab);</span>
        <span class="s0">return this</span><span class="s1">.unusedWorkers.pop();</span>
    <span class="s1">}</span>
    <span class="s1">cleanThread(worker, tid, force) {</span>
        <span class="s0">if </span><span class="s1">(!force &amp;&amp; </span><span class="s0">this</span><span class="s1">._reuseWorker) {</span>
            <span class="s0">this</span><span class="s1">.returnWorkerToPool(worker);</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s0">delete this</span><span class="s1">.pthreads[tid];</span>
            <span class="s0">const </span><span class="s1">index = </span><span class="s0">this</span><span class="s1">.runningWorkers.indexOf(worker);</span>
            <span class="s0">if </span><span class="s1">(index !== -</span><span class="s3">1</span><span class="s1">) {</span>
                <span class="s0">this</span><span class="s1">.runningWorkers.splice(index, </span><span class="s3">1</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s0">this</span><span class="s1">.terminateWorker(worker);</span>
            <span class="s0">delete </span><span class="s1">worker.__emnapi_tid;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">terminateWorker(worker) {</span>
        <span class="s0">var </span><span class="s1">_a;</span>
        <span class="s0">const </span><span class="s1">tid = worker.__emnapi_tid;</span>
        <span class="s1">worker.terminate();</span>
        <span class="s1">(_a = </span><span class="s0">this</span><span class="s1">.messageEvents.get(worker)) === </span><span class="s0">null </span><span class="s1">|| _a === </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">: _a.clear();</span>
        <span class="s0">this</span><span class="s1">.messageEvents.delete(worker);</span>
        <span class="s1">worker.onmessage = (e) =&gt; {</span>
            <span class="s0">if </span><span class="s1">(e.data.__emnapi__) {</span>
                <span class="s0">const </span><span class="s1">err = </span><span class="s0">this</span><span class="s1">.printErr;</span>
                <span class="s1">err(</span><span class="s2">'received &quot;' </span><span class="s1">+ e.data.__emnapi__.type + </span><span class="s2">'&quot; command from terminated worker: ' </span><span class="s1">+ tid);</span>
            <span class="s1">}</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s1">terminateAllThreads() {</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; </span><span class="s0">this</span><span class="s1">.runningWorkers.length; ++i) {</span>
            <span class="s0">this</span><span class="s1">.terminateWorker(</span><span class="s0">this</span><span class="s1">.runningWorkers[i]);</span>
        <span class="s1">}</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; </span><span class="s0">this</span><span class="s1">.unusedWorkers.length; ++i) {</span>
            <span class="s0">this</span><span class="s1">.terminateWorker(</span><span class="s0">this</span><span class="s1">.unusedWorkers[i]);</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">.unusedWorkers = [];</span>
        <span class="s0">this</span><span class="s1">.runningWorkers = [];</span>
        <span class="s0">this</span><span class="s1">.pthreads = Object.create(</span><span class="s0">null</span><span class="s1">);</span>
        <span class="s0">this</span><span class="s1">.preparePool();</span>
    <span class="s1">}</span>
    <span class="s1">addMessageEventListener(worker, onMessage) {</span>
        <span class="s0">let </span><span class="s1">listeners = </span><span class="s0">this</span><span class="s1">.messageEvents.get(worker);</span>
        <span class="s0">if </span><span class="s1">(!listeners) {</span>
            <span class="s1">listeners = </span><span class="s0">new </span><span class="s1">Set();</span>
            <span class="s0">this</span><span class="s1">.messageEvents.set(worker, listeners);</span>
        <span class="s1">}</span>
        <span class="s1">listeners.add(onMessage);</span>
        <span class="s0">return </span><span class="s1">() =&gt; {</span>
            <span class="s1">listeners === </span><span class="s0">null </span><span class="s1">|| listeners === </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">: listeners.delete(onMessage);</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s1">fireMessageEvent(worker, e) {</span>
        <span class="s0">const </span><span class="s1">listeners = </span><span class="s0">this</span><span class="s1">.messageEvents.get(worker);</span>
        <span class="s0">if </span><span class="s1">(!listeners)</span>
            <span class="s0">return</span><span class="s1">;</span>
        <span class="s0">const </span><span class="s1">err = </span><span class="s0">this</span><span class="s1">.printErr;</span>
        <span class="s1">listeners.forEach((listener) =&gt; {</span>
            <span class="s0">try </span><span class="s1">{</span>
                <span class="s1">listener(e);</span>
            <span class="s1">}</span>
            <span class="s0">catch </span><span class="s1">(e) {</span>
                <span class="s1">err(e.stack);</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">kIsProxy = Symbol(</span><span class="s2">'kIsProxy'</span><span class="s1">);</span>
<span class="s0">function </span><span class="s1">createInstanceProxy(instance, memory) {</span>
    <span class="s0">if </span><span class="s1">(instance[kIsProxy])</span>
        <span class="s0">return </span><span class="s1">instance;</span>
    <span class="s0">const </span><span class="s1">originalExports = instance.exports;</span>
    <span class="s0">const </span><span class="s1">createHandler = </span><span class="s0">function </span><span class="s1">(target) {</span>
        <span class="s0">const </span><span class="s1">handlers = [</span>
            <span class="s2">'apply'</span><span class="s1">,</span>
            <span class="s2">'construct'</span><span class="s1">,</span>
            <span class="s2">'defineProperty'</span><span class="s1">,</span>
            <span class="s2">'deleteProperty'</span><span class="s1">,</span>
            <span class="s2">'get'</span><span class="s1">,</span>
            <span class="s2">'getOwnPropertyDescriptor'</span><span class="s1">,</span>
            <span class="s2">'getPrototypeOf'</span><span class="s1">,</span>
            <span class="s2">'has'</span><span class="s1">,</span>
            <span class="s2">'isExtensible'</span><span class="s1">,</span>
            <span class="s2">'ownKeys'</span><span class="s1">,</span>
            <span class="s2">'preventExtensions'</span><span class="s1">,</span>
            <span class="s2">'set'</span><span class="s1">,</span>
            <span class="s2">'setPrototypeOf'</span>
        <span class="s1">];</span>
        <span class="s0">const </span><span class="s1">handler = {};</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; handlers.length; i++) {</span>
            <span class="s0">const </span><span class="s1">name = handlers[i];</span>
            <span class="s1">handler[name] = </span><span class="s0">function </span><span class="s1">() {</span>
                <span class="s0">const </span><span class="s1">args = Array.prototype.slice.call(arguments, </span><span class="s3">1</span><span class="s1">);</span>
                <span class="s1">args.unshift(target);</span>
                <span class="s0">return </span><span class="s1">Reflect[name].apply(Reflect, args);</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">handler;</span>
    <span class="s1">};</span>
    <span class="s0">const </span><span class="s1">handler = createHandler(originalExports);</span>
    <span class="s0">const </span><span class="s1">_initialize = () =&gt; { };</span>
    <span class="s0">const </span><span class="s1">_start = () =&gt; </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">handler.get = </span><span class="s0">function </span><span class="s1">(_target, p, receiver) {</span>
        <span class="s0">var </span><span class="s1">_a;</span>
        <span class="s0">if </span><span class="s1">(p === </span><span class="s2">'memory'</span><span class="s1">) {</span>
            <span class="s0">return </span><span class="s1">(_a = (</span><span class="s0">typeof </span><span class="s1">memory === </span><span class="s2">'function' </span><span class="s1">? memory() : memory)) !== </span><span class="s0">null </span><span class="s1">&amp;&amp; _a !== </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">? _a : Reflect.get(originalExports, p, receiver);</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(p === </span><span class="s2">'_initialize'</span><span class="s1">) {</span>
            <span class="s0">return </span><span class="s1">p </span><span class="s0">in </span><span class="s1">originalExports ? _initialize : undefined;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(p === </span><span class="s2">'_start'</span><span class="s1">) {</span>
            <span class="s0">return </span><span class="s1">p </span><span class="s0">in </span><span class="s1">originalExports ? _start : undefined;</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">Reflect.get(originalExports, p, receiver);</span>
    <span class="s1">};</span>
    <span class="s1">handler.has = </span><span class="s0">function </span><span class="s1">(_target, p) {</span>
        <span class="s0">if </span><span class="s1">(p === </span><span class="s2">'memory'</span><span class="s1">)</span>
            <span class="s0">return true</span><span class="s1">;</span>
        <span class="s0">return </span><span class="s1">Reflect.has(originalExports, p);</span>
    <span class="s1">};</span>
    <span class="s0">const </span><span class="s1">exportsProxy = </span><span class="s0">new </span><span class="s1">Proxy(Object.create(</span><span class="s0">null</span><span class="s1">), handler);</span>
    <span class="s0">return new </span><span class="s1">Proxy(instance, {</span>
        <span class="s1">get(target, p, receiver) {</span>
            <span class="s0">if </span><span class="s1">(p === </span><span class="s2">'exports'</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">exportsProxy;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(p === kIsProxy) {</span>
                <span class="s0">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s1">Reflect.get(target, p, receiver);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">patchedWasiInstances = </span><span class="s0">new </span><span class="s1">WeakMap();</span>
<span class="s0">class </span><span class="s1">WASIThreads {</span>
    <span class="s1">constructor(options) {</span>
        <span class="s0">if </span><span class="s1">(!options) {</span>
            <span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">'WASIThreads(): options is not provided'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(!options.wasi) {</span>
            <span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">'WASIThreads(): options.wasi is not provided'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">patchedWasiInstances.set(</span><span class="s0">this</span><span class="s1">, </span><span class="s0">new </span><span class="s1">WeakSet());</span>
        <span class="s0">const </span><span class="s1">wasi = options.wasi;</span>
        <span class="s1">patchWasiInstance(</span><span class="s0">this</span><span class="s1">, wasi);</span>
        <span class="s0">this</span><span class="s1">.wasi = wasi;</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s2">'childThread' </span><span class="s0">in </span><span class="s1">options) {</span>
            <span class="s0">this</span><span class="s1">.childThread = Boolean(options.childThread);</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s0">this</span><span class="s1">.childThread = </span><span class="s0">false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">.PThread = undefined;</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s2">'threadManager' </span><span class="s0">in </span><span class="s1">options) {</span>
            <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">options.threadManager === </span><span class="s2">'function'</span><span class="s1">) {</span>
                <span class="s0">this</span><span class="s1">.PThread = options.threadManager();</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s0">this</span><span class="s1">.PThread = options.threadManager;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.childThread) {</span>
                <span class="s0">this</span><span class="s1">.PThread = </span><span class="s0">new </span><span class="s1">ThreadManager(options);</span>
                <span class="s0">this</span><span class="s1">.PThread.init();</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">let </span><span class="s1">waitThreadStart = </span><span class="s0">false</span><span class="s1">;</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s2">'waitThreadStart' </span><span class="s0">in </span><span class="s1">options) {</span>
            <span class="s1">waitThreadStart = </span><span class="s0">typeof </span><span class="s1">options.waitThreadStart === </span><span class="s2">'number' </span><span class="s1">? options.waitThreadStart : Boolean(options.waitThreadStart);</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">postMessage = getPostMessage(options);</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.childThread &amp;&amp; </span><span class="s0">typeof </span><span class="s1">postMessage !== </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">'options.postMessage is not a function'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">.postMessage = postMessage;</span>
        <span class="s0">const </span><span class="s1">wasm64 = Boolean(options.wasm64);</span>
        <span class="s0">const </span><span class="s1">onMessage = (e) =&gt; {</span>
            <span class="s0">if </span><span class="s1">(e.data.__emnapi__) {</span>
                <span class="s0">const </span><span class="s1">type = e.data.__emnapi__.type;</span>
                <span class="s0">const </span><span class="s1">payload = e.data.__emnapi__.payload;</span>
                <span class="s0">if </span><span class="s1">(type === </span><span class="s2">'spawn-thread'</span><span class="s1">) {</span>
                    <span class="s1">threadSpawn(payload.startArg, payload.errorOrTid);</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(type === </span><span class="s2">'terminate-all-threads'</span><span class="s1">) {</span>
                    <span class="s0">this</span><span class="s1">.terminateAllThreads();</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">};</span>
        <span class="s0">const </span><span class="s1">threadSpawn = (startArg, errorOrTid) =&gt; {</span>
            <span class="s0">var </span><span class="s1">_a;</span>
            <span class="s0">const </span><span class="s1">EAGAIN = </span><span class="s3">6</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">isNewABI = errorOrTid !== undefined;</span>
            <span class="s0">try </span><span class="s1">{</span>
                <span class="s1">checkSharedWasmMemory(</span><span class="s0">this</span><span class="s1">.wasmMemory);</span>
            <span class="s1">}</span>
            <span class="s0">catch </span><span class="s1">(err) {</span>
                <span class="s1">(_a = </span><span class="s0">this</span><span class="s1">.PThread) === </span><span class="s0">null </span><span class="s1">|| _a === </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">: _a.printErr(err.stack);</span>
                <span class="s0">if </span><span class="s1">(isNewABI) {</span>
                    <span class="s0">const </span><span class="s1">struct = </span><span class="s0">new </span><span class="s1">Int32Array(</span><span class="s0">this</span><span class="s1">.wasmMemory.buffer, errorOrTid, </span><span class="s3">2</span><span class="s1">);</span>
                    <span class="s1">Atomics.store(struct, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">1</span><span class="s1">);</span>
                    <span class="s1">Atomics.store(struct, </span><span class="s3">1</span><span class="s1">, EAGAIN);</span>
                    <span class="s1">Atomics.notify(struct, </span><span class="s3">1</span><span class="s1">);</span>
                    <span class="s0">return </span><span class="s3">1</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s0">return </span><span class="s1">-EAGAIN;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(!isNewABI) {</span>
                <span class="s0">const </span><span class="s1">malloc = </span><span class="s0">this</span><span class="s1">.wasmInstance.exports.malloc;</span>
                <span class="s1">errorOrTid = wasm64 ? Number(malloc(BigInt(</span><span class="s3">8</span><span class="s1">))) : malloc(</span><span class="s3">8</span><span class="s1">);</span>
                <span class="s0">if </span><span class="s1">(!errorOrTid) {</span>
                    <span class="s0">return </span><span class="s1">-</span><span class="s3">48</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">_free = </span><span class="s0">this</span><span class="s1">.wasmInstance.exports.free;</span>
            <span class="s0">const </span><span class="s1">free = wasm64 ? (ptr) =&gt; { _free(BigInt(ptr)); } : _free;</span>
            <span class="s0">const </span><span class="s1">struct = </span><span class="s0">new </span><span class="s1">Int32Array(</span><span class="s0">this</span><span class="s1">.wasmMemory.buffer, errorOrTid, </span><span class="s3">2</span><span class="s1">);</span>
            <span class="s1">Atomics.store(struct, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">);</span>
            <span class="s1">Atomics.store(struct, </span><span class="s3">1</span><span class="s1">, </span><span class="s3">0</span><span class="s1">);</span>
            <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.childThread) {</span>
                <span class="s1">postMessage(createMessage(</span><span class="s2">'spawn-thread'</span><span class="s1">, {</span>
                    <span class="s1">startArg,</span>
                    <span class="s1">errorOrTid: errorOrTid</span>
                <span class="s1">}));</span>
                <span class="s1">Atomics.wait(struct, </span><span class="s3">1</span><span class="s1">, </span><span class="s3">0</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">isError = Atomics.load(struct, </span><span class="s3">0</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">result = Atomics.load(struct, </span><span class="s3">1</span><span class="s1">);</span>
                <span class="s0">if </span><span class="s1">(isNewABI) {</span>
                    <span class="s0">return </span><span class="s1">isError;</span>
                <span class="s1">}</span>
                <span class="s1">free(errorOrTid);</span>
                <span class="s0">return </span><span class="s1">isError ? -result : result;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">shouldWait = waitThreadStart || (waitThreadStart === </span><span class="s3">0</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">sab;</span>
            <span class="s0">if </span><span class="s1">(shouldWait) {</span>
                <span class="s1">sab = </span><span class="s0">new </span><span class="s1">Int32Array(</span><span class="s0">new </span><span class="s1">SharedArrayBuffer(</span><span class="s3">16 </span><span class="s1">+ </span><span class="s3">8192</span><span class="s1">));</span>
                <span class="s1">Atomics.store(sab, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s0">let </span><span class="s1">worker;</span>
            <span class="s0">let </span><span class="s1">tid;</span>
            <span class="s0">const </span><span class="s1">PThread = </span><span class="s0">this</span><span class="s1">.PThread;</span>
            <span class="s0">try </span><span class="s1">{</span>
                <span class="s1">worker = PThread.getNewWorker(sab);</span>
                <span class="s0">if </span><span class="s1">(!worker) {</span>
                    <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">'failed to get new worker'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s1">PThread.addMessageEventListener(worker, onMessage);</span>
                <span class="s1">tid = PThread.markId(worker);</span>
                <span class="s0">if </span><span class="s1">(ENVIRONMENT_IS_NODE) {</span>
                    <span class="s1">worker.ref();</span>
                <span class="s1">}</span>
                <span class="s1">worker.postMessage(createMessage(</span><span class="s2">'start'</span><span class="s1">, {</span>
                    <span class="s1">tid,</span>
                    <span class="s1">arg: startArg,</span>
                    <span class="s1">sab</span>
                <span class="s1">}));</span>
                <span class="s0">if </span><span class="s1">(shouldWait) {</span>
                    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">waitThreadStart === </span><span class="s2">'number'</span><span class="s1">) {</span>
                        <span class="s0">const </span><span class="s1">waitResult = Atomics.wait(sab, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, waitThreadStart);</span>
                        <span class="s0">if </span><span class="s1">(waitResult === </span><span class="s2">'timed-out'</span><span class="s1">) {</span>
                            <span class="s0">try </span><span class="s1">{</span>
                                <span class="s1">PThread.cleanThread(worker, tid, </span><span class="s0">true</span><span class="s1">);</span>
                            <span class="s1">}</span>
                            <span class="s0">catch </span><span class="s1">(_) { }</span>
                            <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">'Spawning thread timed out. Please check if the worker is created successfully and if message is handled properly in the worker.'</span><span class="s1">);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s0">else </span><span class="s1">{</span>
                        <span class="s1">Atomics.wait(sab, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s0">const </span><span class="s1">r = Atomics.load(sab, </span><span class="s3">0</span><span class="s1">);</span>
                    <span class="s0">if </span><span class="s1">(r &gt; </span><span class="s3">1</span><span class="s1">) {</span>
                        <span class="s0">try </span><span class="s1">{</span>
                            <span class="s1">PThread.cleanThread(worker, tid, </span><span class="s0">true</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s0">catch </span><span class="s1">(_) { }</span>
                        <span class="s0">throw </span><span class="s1">deserizeErrorFromBuffer(sab.buffer);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">catch </span><span class="s1">(e) {</span>
                <span class="s1">Atomics.store(struct, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">1</span><span class="s1">);</span>
                <span class="s1">Atomics.store(struct, </span><span class="s3">1</span><span class="s1">, EAGAIN);</span>
                <span class="s1">Atomics.notify(struct, </span><span class="s3">1</span><span class="s1">);</span>
                <span class="s1">PThread === </span><span class="s0">null </span><span class="s1">|| PThread === </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">: PThread.printErr(e.stack);</span>
                <span class="s0">if </span><span class="s1">(isNewABI) {</span>
                    <span class="s0">return </span><span class="s3">1</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">free(errorOrTid);</span>
                <span class="s0">return </span><span class="s1">-EAGAIN;</span>
            <span class="s1">}</span>
            <span class="s1">Atomics.store(struct, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">);</span>
            <span class="s1">Atomics.store(struct, </span><span class="s3">1</span><span class="s1">, tid);</span>
            <span class="s1">Atomics.notify(struct, </span><span class="s3">1</span><span class="s1">);</span>
            <span class="s1">PThread.runningWorkers.push(worker);</span>
            <span class="s0">if </span><span class="s1">(!shouldWait) {</span>
                <span class="s1">worker.whenLoaded.catch((err) =&gt; {</span>
                    <span class="s0">delete </span><span class="s1">worker.whenLoaded;</span>
                    <span class="s1">PThread.cleanThread(worker, tid, </span><span class="s0">true</span><span class="s1">);</span>
                    <span class="s0">throw </span><span class="s1">err;</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(isNewABI) {</span>
                <span class="s0">return </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">free(errorOrTid);</span>
            <span class="s0">return </span><span class="s1">tid;</span>
        <span class="s1">};</span>
        <span class="s0">this</span><span class="s1">.threadSpawn = threadSpawn;</span>
    <span class="s1">}</span>
    <span class="s1">getImportObject() {</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s1">wasi: {</span>
                <span class="s2">'thread-spawn'</span><span class="s1">: </span><span class="s0">this</span><span class="s1">.threadSpawn</span>
            <span class="s1">}</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s1">setup(wasmInstance, wasmModule, wasmMemory) {</span>
        <span class="s1">wasmMemory !== </span><span class="s0">null </span><span class="s1">&amp;&amp; wasmMemory !== </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">? wasmMemory : (wasmMemory = wasmInstance.exports.memory);</span>
        <span class="s0">this</span><span class="s1">.wasmInstance = wasmInstance;</span>
        <span class="s0">this</span><span class="s1">.wasmMemory = wasmMemory;</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.PThread) {</span>
            <span class="s0">this</span><span class="s1">.PThread.setup(wasmModule, wasmMemory);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">preloadWorkers() {</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.PThread) {</span>
            <span class="s0">return this</span><span class="s1">.PThread.preloadWorkers();</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">Promise.resolve([]);</span>
    <span class="s1">}</span>
    <span class="s1">initialize(instance, module, memory) {</span>
        <span class="s0">const </span><span class="s1">exports = instance.exports;</span>
        <span class="s1">memory !== </span><span class="s0">null </span><span class="s1">&amp;&amp; memory !== </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">? memory : (memory = exports.memory);</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.childThread) {</span>
            <span class="s1">instance = createInstanceProxy(instance, memory);</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">.setup(instance, module, memory);</span>
        <span class="s0">const </span><span class="s1">wasi = </span><span class="s0">this</span><span class="s1">.wasi;</span>
        <span class="s0">if </span><span class="s1">((</span><span class="s2">'_start' </span><span class="s0">in </span><span class="s1">exports) &amp;&amp; (</span><span class="s0">typeof </span><span class="s1">exports._start === </span><span class="s2">'function'</span><span class="s1">)) {</span>
            <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.childThread) {</span>
                <span class="s1">wasi.start(instance);</span>
                <span class="s0">try </span><span class="s1">{</span>
                    <span class="s0">const </span><span class="s1">kStarted = getWasiSymbol(wasi, </span><span class="s2">'kStarted'</span><span class="s1">);</span>
                    <span class="s1">wasi[kStarted] = </span><span class="s0">false</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">catch </span><span class="s1">(_) { }</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">setupInstance(wasi, instance);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s1">wasi.initialize(instance);</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">instance;</span>
    <span class="s1">}</span>
    <span class="s1">start(instance, module, memory) {</span>
        <span class="s0">const </span><span class="s1">exports = instance.exports;</span>
        <span class="s1">memory !== </span><span class="s0">null </span><span class="s1">&amp;&amp; memory !== </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">? memory : (memory = exports.memory);</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.childThread) {</span>
            <span class="s1">instance = createInstanceProxy(instance, memory);</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">.setup(instance, module, memory);</span>
        <span class="s0">const </span><span class="s1">exitCode = </span><span class="s0">this</span><span class="s1">.wasi.start(instance);</span>
        <span class="s0">return </span><span class="s1">{ exitCode, instance };</span>
    <span class="s1">}</span>
    <span class="s1">terminateAllThreads() {</span>
        <span class="s0">var </span><span class="s1">_a;</span>
        <span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.childThread) {</span>
            <span class="s1">(_a = </span><span class="s0">this</span><span class="s1">.PThread) === </span><span class="s0">null </span><span class="s1">|| _a === </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">: _a.terminateAllThreads();</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s0">this</span><span class="s1">.postMessage(createMessage(</span><span class="s2">'terminate-all-threads'</span><span class="s1">, {}));</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">patchWasiInstance(wasiThreads, wasi) {</span>
    <span class="s0">const </span><span class="s1">patched = patchedWasiInstances.get(wasiThreads);</span>
    <span class="s0">if </span><span class="s1">(patched.has(wasi)) {</span>
        <span class="s0">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">_this = wasiThreads;</span>
    <span class="s0">const </span><span class="s1">wasiImport = wasi.wasiImport;</span>
    <span class="s0">if </span><span class="s1">(wasiImport) {</span>
        <span class="s0">const </span><span class="s1">proc_exit = wasiImport.proc_exit;</span>
        <span class="s1">wasiImport.proc_exit = </span><span class="s0">function </span><span class="s1">(code) {</span>
            <span class="s1">_this.terminateAllThreads();</span>
            <span class="s0">return </span><span class="s1">proc_exit.call(</span><span class="s0">this</span><span class="s1">, code);</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(!_this.childThread) {</span>
        <span class="s0">const </span><span class="s1">start = wasi.start;</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">start === </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s1">wasi.start = </span><span class="s0">function </span><span class="s1">(instance) {</span>
                <span class="s0">try </span><span class="s1">{</span>
                    <span class="s0">return </span><span class="s1">start.call(</span><span class="s0">this</span><span class="s1">, instance);</span>
                <span class="s1">}</span>
                <span class="s0">catch </span><span class="s1">(err) {</span>
                    <span class="s0">if </span><span class="s1">(isTrapError(err)) {</span>
                        <span class="s1">_this.terminateAllThreads();</span>
                    <span class="s1">}</span>
                    <span class="s0">throw </span><span class="s1">err;</span>
                <span class="s1">}</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">patched.add(wasi);</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getWasiSymbol(wasi, description) {</span>
    <span class="s0">const </span><span class="s1">symbols = Object.getOwnPropertySymbols(wasi);</span>
    <span class="s0">const </span><span class="s1">selectDescription = (description) =&gt; (s) =&gt; {</span>
        <span class="s0">if </span><span class="s1">(s.description) {</span>
            <span class="s0">return </span><span class="s1">s.description === description;</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">s.toString() === </span><span class="s2">`Symbol(</span><span class="s1">${description}</span><span class="s2">)`</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">if </span><span class="s1">(Array.isArray(description)) {</span>
        <span class="s0">return </span><span class="s1">description.map(d =&gt; symbols.filter(selectDescription(d))[</span><span class="s3">0</span><span class="s1">]);</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">symbols.filter(selectDescription(description))[</span><span class="s3">0</span><span class="s1">];</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">setupInstance(wasi, instance) {</span>
    <span class="s0">const </span><span class="s1">[kInstance, kSetMemory] = getWasiSymbol(wasi, [</span><span class="s2">'kInstance'</span><span class="s1">, </span><span class="s2">'kSetMemory'</span><span class="s1">]);</span>
    <span class="s1">wasi[kInstance] = instance;</span>
    <span class="s1">wasi[kSetMemory](instance.exports.memory);</span>
<span class="s1">}</span>

<span class="s0">class </span><span class="s1">ThreadMessageHandler {</span>
    <span class="s1">constructor(options) {</span>
        <span class="s0">const </span><span class="s1">postMsg = getPostMessage(options);</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">postMsg !== </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">'options.postMessage is not a function'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">.postMessage = postMsg;</span>
        <span class="s0">this</span><span class="s1">.onLoad = options === </span><span class="s0">null </span><span class="s1">|| options === </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">: options.onLoad;</span>
        <span class="s0">this</span><span class="s1">.onError = </span><span class="s0">typeof </span><span class="s1">(options === </span><span class="s0">null </span><span class="s1">|| options === </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">: options.onError) === </span><span class="s2">'function' </span><span class="s1">? options.onError : (_type, err) =&gt; { </span><span class="s0">throw </span><span class="s1">err; };</span>
        <span class="s0">this</span><span class="s1">.instance = undefined;</span>
        <span class="s0">this</span><span class="s1">.messagesBeforeLoad = [];</span>
    <span class="s1">}</span>
    <span class="s1">instantiate(data) {</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof this</span><span class="s1">.onLoad === </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s0">return this</span><span class="s1">.onLoad(data);</span>
        <span class="s1">}</span>
        <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">'ThreadMessageHandler.prototype.instantiate is not implemented'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">handle(e) {</span>
        <span class="s0">var </span><span class="s1">_a;</span>
        <span class="s0">if </span><span class="s1">((_a = e === </span><span class="s0">null </span><span class="s1">|| e === </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">: e.data) === </span><span class="s0">null </span><span class="s1">|| _a === </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">: _a.__emnapi__) {</span>
            <span class="s0">const </span><span class="s1">type = e.data.__emnapi__.type;</span>
            <span class="s0">const </span><span class="s1">payload = e.data.__emnapi__.payload;</span>
            <span class="s0">try </span><span class="s1">{</span>
                <span class="s0">if </span><span class="s1">(type === </span><span class="s2">'load'</span><span class="s1">) {</span>
                    <span class="s0">this</span><span class="s1">._load(payload);</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(type === </span><span class="s2">'start'</span><span class="s1">) {</span>
                    <span class="s0">this</span><span class="s1">.handleAfterLoad(e, () =&gt; {</span>
                        <span class="s0">this</span><span class="s1">._start(payload);</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">catch </span><span class="s1">(err) {</span>
                <span class="s0">this</span><span class="s1">.onError(err, type);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">_load(payload) {</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.instance !== undefined)</span>
            <span class="s0">return</span><span class="s1">;</span>
        <span class="s0">let </span><span class="s1">source;</span>
        <span class="s0">try </span><span class="s1">{</span>
            <span class="s1">source = </span><span class="s0">this</span><span class="s1">.instantiate(payload);</span>
        <span class="s1">}</span>
        <span class="s0">catch </span><span class="s1">(err) {</span>
            <span class="s0">this</span><span class="s1">._loaded(err, </span><span class="s0">null</span><span class="s1">, payload);</span>
            <span class="s0">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">then = source &amp;&amp; </span><span class="s2">'then' </span><span class="s0">in </span><span class="s1">source ? source.then : undefined;</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">then === </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s1">then.call(source, (source) =&gt; { </span><span class="s0">this</span><span class="s1">._loaded(</span><span class="s0">null</span><span class="s1">, source, payload); }, (err) =&gt; { </span><span class="s0">this</span><span class="s1">._loaded(err, </span><span class="s0">null</span><span class="s1">, payload); });</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s0">this</span><span class="s1">._loaded(</span><span class="s0">null</span><span class="s1">, source, payload);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">_start(payload) {</span>
        <span class="s0">const </span><span class="s1">wasi_thread_start = </span><span class="s0">this</span><span class="s1">.instance.exports.wasi_thread_start;</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">wasi_thread_start !== </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s0">const </span><span class="s1">err = </span><span class="s0">new </span><span class="s1">TypeError(</span><span class="s2">'wasi_thread_start is not exported'</span><span class="s1">);</span>
            <span class="s1">notifyPthreadCreateResult(payload.sab, </span><span class="s3">2</span><span class="s1">, err);</span>
            <span class="s0">throw </span><span class="s1">err;</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">postMessage = </span><span class="s0">this</span><span class="s1">.postMessage;</span>
        <span class="s0">const </span><span class="s1">tid = payload.tid;</span>
        <span class="s0">const </span><span class="s1">startArg = payload.arg;</span>
        <span class="s1">notifyPthreadCreateResult(payload.sab, </span><span class="s3">1</span><span class="s1">);</span>
        <span class="s0">try </span><span class="s1">{</span>
            <span class="s1">wasi_thread_start(tid, startArg);</span>
        <span class="s1">}</span>
        <span class="s0">catch </span><span class="s1">(err) {</span>
            <span class="s0">if </span><span class="s1">(err !== </span><span class="s2">'unwind'</span><span class="s1">) {</span>
                <span class="s0">throw </span><span class="s1">err;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s0">return</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">postMessage(createMessage(</span><span class="s2">'cleanup-thread'</span><span class="s1">, { tid }));</span>
    <span class="s1">}</span>
    <span class="s1">_loaded(err, source, payload) {</span>
        <span class="s0">if </span><span class="s1">(err) {</span>
            <span class="s1">notifyPthreadCreateResult(payload.sab, </span><span class="s3">2</span><span class="s1">, err);</span>
            <span class="s0">throw </span><span class="s1">err;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(source == </span><span class="s0">null</span><span class="s1">) {</span>
            <span class="s0">const </span><span class="s1">err = </span><span class="s0">new </span><span class="s1">TypeError(</span><span class="s2">'onLoad should return an object'</span><span class="s1">);</span>
            <span class="s1">notifyPthreadCreateResult(payload.sab, </span><span class="s3">2</span><span class="s1">, err);</span>
            <span class="s0">throw </span><span class="s1">err;</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">instance = source.instance;</span>
        <span class="s0">if </span><span class="s1">(!instance) {</span>
            <span class="s0">const </span><span class="s1">err = </span><span class="s0">new </span><span class="s1">TypeError(</span><span class="s2">'onLoad should return an object which includes &quot;instance&quot;'</span><span class="s1">);</span>
            <span class="s1">notifyPthreadCreateResult(payload.sab, </span><span class="s3">2</span><span class="s1">, err);</span>
            <span class="s0">throw </span><span class="s1">err;</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">.instance = instance;</span>
        <span class="s0">const </span><span class="s1">postMessage = </span><span class="s0">this</span><span class="s1">.postMessage;</span>
        <span class="s1">postMessage(createMessage(</span><span class="s2">'loaded'</span><span class="s1">, {}));</span>
        <span class="s0">const </span><span class="s1">messages = </span><span class="s0">this</span><span class="s1">.messagesBeforeLoad;</span>
        <span class="s0">this</span><span class="s1">.messagesBeforeLoad = [];</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; messages.length; i++) {</span>
            <span class="s0">const </span><span class="s1">data = messages[i];</span>
            <span class="s0">this</span><span class="s1">.handle({ data });</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">handleAfterLoad(e, f) {</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.instance !== undefined) {</span>
            <span class="s1">f.call(</span><span class="s0">this</span><span class="s1">, e);</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s0">this</span><span class="s1">.messagesBeforeLoad.push(e.data);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">notifyPthreadCreateResult(sab, result, error) {</span>
    <span class="s0">if </span><span class="s1">(sab) {</span>
        <span class="s1">serizeErrorToBuffer(sab.buffer, result, error);</span>
        <span class="s1">Atomics.notify(sab, </span><span class="s3">0</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">exports.ThreadManager = ThreadManager;</span>
<span class="s1">exports.ThreadMessageHandler = ThreadMessageHandler;</span>
<span class="s1">exports.WASIThreads = WASIThreads;</span>
<span class="s1">exports.createInstanceProxy = createInstanceProxy;</span>
<span class="s1">exports.isSharedArrayBuffer = isSharedArrayBuffer;</span>
<span class="s1">exports.isTrapError = isTrapError;</span>
</pre>
</body>
</html>