<html>
<head>
<title>AsYouTypeParser.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
AsYouTypeParser.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;AsYouTypeParser.js&quot;</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_extractCountryCallingCode2&quot;</span><span class="s0">,</span><span class="s1">&quot;_interopRequireDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_extractCountryCallingCodeFromInternationalNumberWithoutPlusSign&quot;</span><span class="s0">,</span><span class="s1">&quot;_extractNationalNumberFromPossiblyIncompleteNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;_stripIddPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;_parseDigits&quot;</span><span class="s0">,</span><span class="s1">&quot;_constants&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;__esModule&quot;</span><span class="s0">,</span><span class="s1">&quot;_typeof&quot;</span><span class="s0">,</span><span class="s1">&quot;o&quot;</span><span class="s0">,</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;iterator&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;_slicedToArray&quot;</span><span class="s0">,</span><span class="s1">&quot;r&quot;</span><span class="s0">,</span><span class="s1">&quot;_arrayWithHoles&quot;</span><span class="s0">,</span><span class="s1">&quot;_iterableToArrayLimit&quot;</span><span class="s0">,</span><span class="s1">&quot;_unsupportedIterableToArray&quot;</span><span class="s0">,</span><span class="s1">&quot;_nonIterableRest&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeError&quot;</span><span class="s0">,</span><span class="s1">&quot;a&quot;</span><span class="s0">,</span><span class="s1">&quot;_arrayLikeToArray&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;n&quot;</span><span class="s0">,</span><span class="s1">&quot;l&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;u&quot;</span><span class="s0">,</span><span class="s1">&quot;f&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;done&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;_classCallCheck&quot;</span><span class="s0">,</span><span class="s1">&quot;_defineProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;enumerable&quot;</span><span class="s0">,</span><span class="s1">&quot;configurable&quot;</span><span class="s0">,</span><span class="s1">&quot;writable&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;_toPropertyKey&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;_createClass&quot;</span><span class="s0">,</span><span class="s1">&quot;_toPrimitive&quot;</span><span class="s0">,</span><span class="s1">&quot;toPrimitive&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;Number&quot;</span><span class="s0">,</span><span class="s1">&quot;VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART&quot;</span><span class="s0">,</span><span class="s1">&quot;VALID_PUNCTUATION&quot;</span><span class="s0">,</span><span class="s1">&quot;VALID_DIGITS&quot;</span><span class="s0">,</span><span class="s1">&quot;VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;VALID_FORMATTED_PHONE_NUMBER_PART&quot;</span><span class="s0">,</span><span class="s1">&quot;PLUS_CHARS&quot;</span><span class="s0">,</span><span class="s1">&quot;AFTER_PHONE_NUMBER_DIGITS_END_PATTERN&quot;</span><span class="s0">,</span><span class="s1">&quot;COMPLEX_NATIONAL_PREFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;AsYouTypeParser&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;_ref&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultCountry&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultCallingCode&quot;</span><span class="s0">,</span><span class="s1">&quot;metadata&quot;</span><span class="s0">,</span><span class="s1">&quot;onNationalSignificantNumberChange&quot;</span><span class="s0">,</span><span class="s1">&quot;input&quot;</span><span class="s0">,</span><span class="s1">&quot;text&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;_extractFormattedDigi&quot;</span><span class="s0">,</span><span class="s1">&quot;extractFormattedDigitsAndPlus&quot;</span><span class="s0">,</span><span class="s1">&quot;_extractFormattedDigi2&quot;</span><span class="s0">,</span><span class="s1">&quot;formattedDigits&quot;</span><span class="s0">,</span><span class="s1">&quot;hasPlus&quot;</span><span class="s0">,</span><span class="s1">&quot;digits&quot;</span><span class="s0">,</span><span class="s1">&quot;parseDigits&quot;</span><span class="s0">,</span><span class="s1">&quot;justLeadingPlus&quot;</span><span class="s0">,</span><span class="s1">&quot;startInternationalNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;inputDigits&quot;</span><span class="s0">,</span><span class="s1">&quot;nextDigits&quot;</span><span class="s0">,</span><span class="s1">&quot;hasReceivedThreeLeadingDigits&quot;</span><span class="s0">,</span><span class="s1">&quot;appendDigits&quot;</span><span class="s0">,</span><span class="s1">&quot;extractIddPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;isWaitingForCountryCallingCode&quot;</span><span class="s0">,</span><span class="s1">&quot;extractCountryCallingCode&quot;</span><span class="s0">,</span><span class="s1">&quot;appendNationalSignificantNumberDigits&quot;</span><span class="s0">,</span><span class="s1">&quot;international&quot;</span><span class="s0">,</span><span class="s1">&quot;hasExtractedNationalSignificantNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;extractNationalSignificantNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;getNationalDigits&quot;</span><span class="s0">,</span><span class="s1">&quot;stateUpdate&quot;</span><span class="s0">,</span><span class="s1">&quot;update&quot;</span><span class="s0">,</span><span class="s1">&quot;_ref2&quot;</span><span class="s0">,</span><span class="s1">&quot;callingCode&quot;</span><span class="s0">,</span><span class="s1">&quot;_extractCountryCallin&quot;</span><span class="s0">,</span><span class="s1">&quot;getDigitsWithoutInternationalPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;country&quot;</span><span class="s0">,</span><span class="s1">&quot;countryCallingCode&quot;</span><span class="s0">,</span><span class="s1">&quot;number&quot;</span><span class="s0">,</span><span class="s1">&quot;setCallingCode&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalSignificantNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;reset&quot;</span><span class="s0">,</span><span class="s1">&quot;numberingPlan&quot;</span><span class="s0">,</span><span class="s1">&quot;hasSelectedNumberingPlan&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalPrefixForParsing&quot;</span><span class="s0">,</span><span class="s1">&quot;_nationalPrefixForParsing&quot;</span><span class="s0">,</span><span class="s1">&quot;couldPossiblyExtractAnotherNationalSignificantNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalDigits&quot;</span><span class="s0">,</span><span class="s1">&quot;setState&quot;</span><span class="s0">,</span><span class="s1">&quot;_extractNationalNumbe&quot;</span><span class="s0">,</span><span class="s1">&quot;extractNationalNumberFromPossiblyIncompleteNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;carrierCode&quot;</span><span class="s0">,</span><span class="s1">&quot;onExtractedNationalNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;extractAnotherNationalSignificantNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;prevNationalSignificantNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;_extractNationalNumbe2&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalSignificantNumberIsModified&quot;</span><span class="s0">,</span><span class="s1">&quot;prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalSignificantNumberIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;lastIndexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;prefixBeforeNationalNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;reExtractNationalSignificantNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;extractCallingCodeAndNationalSignificantNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;fixMissingPlus&quot;</span><span class="s0">,</span><span class="s1">&quot;IDDPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;numberWithoutIDD&quot;</span><span class="s0">,</span><span class="s1">&quot;stripIddPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;_extractCountryCallin2&quot;</span><span class="s0">,</span><span class="s1">&quot;extractCountryCallingCodeFromInternationalNumberWithoutPlusSign&quot;</span><span class="s0">,</span><span class="s1">&quot;newCallingCode&quot;</span><span class="s0">,</span><span class="s1">&quot;missingPlus&quot;</span><span class="s0">,</span><span class="s1">&quot;_ref3&quot;</span><span class="s0">,</span><span class="s1">&quot;resetNationalSignificantNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;extractFormattedPhoneNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;startsAt&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;_extractFormattedDigitsAndPlus&quot;</span><span class="s0">,</span><span class="s1">&quot;extractedNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;_extractFormattedDigi3&quot;</span><span class="s0">,</span><span class="s1">&quot;_extractFormattedDigi4&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../source/AsYouTypeParser.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import extractCountryCallingCode from './helpers/extractCountryCallingCode.js'</span><span class="s3">\r\n</span><span class="s1">import extractCountryCallingCodeFromInternationalNumberWithoutPlusSign from './helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js'</span><span class="s3">\r\n</span><span class="s1">import extractNationalNumberFromPossiblyIncompleteNumber from './helpers/extractNationalNumberFromPossiblyIncompleteNumber.js'</span><span class="s3">\r\n</span><span class="s1">import stripIddPrefix from './helpers/stripIddPrefix.js'</span><span class="s3">\r\n</span><span class="s1">import parseDigits from './helpers/parseDigits.js'</span><span class="s3">\r\n\r\n</span><span class="s1">import {</span><span class="s3">\r\n\t</span><span class="s1">VALID_DIGITS,</span><span class="s3">\r\n\t</span><span class="s1">VALID_PUNCTUATION,</span><span class="s3">\r\n\t</span><span class="s1">PLUS_CHARS</span><span class="s3">\r\n</span><span class="s1">} from './constants.js'</span><span class="s3">\r\n\r\n</span><span class="s1">const VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART =</span><span class="s3">\r\n\t</span><span class="s1">'[' +</span><span class="s3">\r\n\t\t</span><span class="s1">VALID_PUNCTUATION +</span><span class="s3">\r\n\t\t</span><span class="s1">VALID_DIGITS +</span><span class="s3">\r\n\t</span><span class="s1">']+'</span><span class="s3">\r\n\r\n</span><span class="s1">const VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN = new RegExp('^' + VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART + '$', 'i')</span><span class="s3">\r\n\r\n</span><span class="s1">const VALID_FORMATTED_PHONE_NUMBER_PART =</span><span class="s3">\r\n\t</span><span class="s1">'(?:' +</span><span class="s3">\r\n\t\t</span><span class="s1">'[' + PLUS_CHARS + ']' +</span><span class="s3">\r\n\t\t</span><span class="s1">'[' +</span><span class="s3">\r\n\t\t\t</span><span class="s1">VALID_PUNCTUATION +</span><span class="s3">\r\n\t\t\t</span><span class="s1">VALID_DIGITS +</span><span class="s3">\r\n\t\t</span><span class="s1">']*' +</span><span class="s3">\r\n\t\t</span><span class="s1">'|' +</span><span class="s3">\r\n\t\t</span><span class="s1">'[' +</span><span class="s3">\r\n\t\t\t</span><span class="s1">VALID_PUNCTUATION +</span><span class="s3">\r\n\t\t\t</span><span class="s1">VALID_DIGITS +</span><span class="s3">\r\n\t\t</span><span class="s1">']+' +</span><span class="s3">\r\n\t</span><span class="s1">')'</span><span class="s3">\r\n\r\n</span><span class="s1">const AFTER_PHONE_NUMBER_DIGITS_END_PATTERN = new RegExp(</span><span class="s3">\r\n\t</span><span class="s1">'[^' +</span><span class="s3">\r\n\t\t</span><span class="s1">VALID_PUNCTUATION +</span><span class="s3">\r\n\t\t</span><span class="s1">VALID_DIGITS +</span><span class="s3">\r\n\t</span><span class="s1">']+' +</span><span class="s3">\r\n\t</span><span class="s1">'.*' +</span><span class="s3">\r\n\t</span><span class="s1">'$'</span><span class="s3">\r\n</span><span class="s1">)</span><span class="s3">\r\n\r\n</span><span class="s1">// Tests whether `national_prefix_for_parsing` could match</span><span class="s3">\r\n</span><span class="s1">// different national prefixes.</span><span class="s3">\r\n</span><span class="s1">// Matches anything that's not a digit or a square bracket.</span><span class="s3">\r\n</span><span class="s1">const COMPLEX_NATIONAL_PREFIX = /[^</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">]]/</span><span class="s3">\r\n\r\n</span><span class="s1">export default class AsYouTypeParser {</span><span class="s3">\r\n\t</span><span class="s1">constructor({</span><span class="s3">\r\n\t\t</span><span class="s1">defaultCountry,</span><span class="s3">\r\n\t\t</span><span class="s1">defaultCallingCode,</span><span class="s3">\r\n\t\t</span><span class="s1">metadata,</span><span class="s3">\r\n\t\t</span><span class="s1">onNationalSignificantNumberChange</span><span class="s3">\r\n\t</span><span class="s1">}) {</span><span class="s3">\r\n\t\t</span><span class="s1">this.defaultCountry = defaultCountry</span><span class="s3">\r\n\t\t</span><span class="s1">this.defaultCallingCode = defaultCallingCode</span><span class="s3">\r\n\t\t</span><span class="s1">this.metadata = metadata</span><span class="s3">\r\n\t\t</span><span class="s1">this.onNationalSignificantNumberChange = onNationalSignificantNumberChange</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">input(text, state) {</span><span class="s3">\r\n\t\t</span><span class="s1">const [formattedDigits, hasPlus] = extractFormattedDigitsAndPlus(text)</span><span class="s3">\r\n\t\t</span><span class="s1">const digits = parseDigits(formattedDigits)</span><span class="s3">\r\n\t\t</span><span class="s1">// Checks for a special case: just a leading `+` has been entered.</span><span class="s3">\r\n\t\t</span><span class="s1">let justLeadingPlus</span><span class="s3">\r\n\t\t</span><span class="s1">if (hasPlus) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (!state.digits) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">state.startInternationalNumber(undefined, undefined)</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">if (!digits) {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">justLeadingPlus = true</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">if (digits) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.inputDigits(digits, state)</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">return {</span><span class="s3">\r\n\t\t\t</span><span class="s1">digits,</span><span class="s3">\r\n\t\t\t</span><span class="s1">justLeadingPlus</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">/**</span><span class="s3">\r\n\t </span><span class="s1">* Inputs </span><span class="s3">\&quot;</span><span class="s1">next</span><span class="s3">\&quot; </span><span class="s1">phone number digits.</span><span class="s3">\r\n\t </span><span class="s1">* @param  {string} digits</span><span class="s3">\r\n\t </span><span class="s1">* @return {string} [formattedNumber] Formatted national phone number (if it can be formatted at this stage). Returning `undefined` means </span><span class="s3">\&quot;</span><span class="s1">don't format the national phone number at this stage</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\r\n\t </span><span class="s1">*/</span><span class="s3">\r\n\t</span><span class="s1">inputDigits(nextDigits, state) {</span><span class="s3">\r\n\t\t</span><span class="s1">const { digits } = state</span><span class="s3">\r\n\t\t</span><span class="s1">const hasReceivedThreeLeadingDigits = digits.length &lt; 3 &amp;&amp; digits.length + nextDigits.length &gt;= 3</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// Append phone number digits.</span><span class="s3">\r\n\t\t</span><span class="s1">state.appendDigits(nextDigits)</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// Attempt to extract IDD prefix:</span><span class="s3">\r\n\t\t</span><span class="s1">// Some users input their phone number in international format,</span><span class="s3">\r\n\t\t</span><span class="s1">// but in an </span><span class="s3">\&quot;</span><span class="s1">out-of-country</span><span class="s3">\&quot; </span><span class="s1">dialing format instead of using the leading `+`.</span><span class="s3">\r\n\t\t</span><span class="s1">// https://github.com/catamphetamine/libphonenumber-js/issues/185</span><span class="s3">\r\n\t\t</span><span class="s1">// Detect such numbers as soon as there're at least 3 digits.</span><span class="s3">\r\n\t\t</span><span class="s1">// Google's library attempts to extract IDD prefix at 3 digits,</span><span class="s3">\r\n\t\t</span><span class="s1">// so this library just copies that behavior.</span><span class="s3">\r\n\t\t</span><span class="s1">// I guess that's because the most commot IDD prefixes are</span><span class="s3">\r\n\t\t</span><span class="s1">// `00` (Europe) and `011` (US).</span><span class="s3">\r\n\t\t</span><span class="s1">// There exist really long IDD prefixes too:</span><span class="s3">\r\n\t\t</span><span class="s1">// for example, in Australia the default IDD prefix is `0011`,</span><span class="s3">\r\n\t\t</span><span class="s1">// and it could even be as long as `14880011`.</span><span class="s3">\r\n\t\t</span><span class="s1">// An IDD prefix is extracted here, and then every time when</span><span class="s3">\r\n\t\t</span><span class="s1">// there's a new digit and the number couldn't be formatted.</span><span class="s3">\r\n\t\t</span><span class="s1">if (hasReceivedThreeLeadingDigits) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.extractIddPrefix(state)</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">if (this.isWaitingForCountryCallingCode(state)) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (!this.extractCountryCallingCode(state)) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">return</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">} else {</span><span class="s3">\r\n\t\t\t</span><span class="s1">state.appendNationalSignificantNumberDigits(nextDigits)</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// If a phone number is being input in international format,</span><span class="s3">\r\n\t\t</span><span class="s1">// then it's not valid for it to have a national prefix.</span><span class="s3">\r\n\t\t</span><span class="s1">// Still, some people incorrectly input such numbers with a national prefix.</span><span class="s3">\r\n\t\t</span><span class="s1">// In such cases, only attempt to strip a national prefix if the number becomes too long.</span><span class="s3">\r\n\t\t</span><span class="s1">// (but that is done later, not here)</span><span class="s3">\r\n\t\t</span><span class="s1">if (!state.international) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (!this.hasExtractedNationalSignificantNumber) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">this.extractNationalSignificantNumber(</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">state.getNationalDigits(),</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">(stateUpdate) =&gt; state.update(stateUpdate)</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">)</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">isWaitingForCountryCallingCode({ international, callingCode }) {</span><span class="s3">\r\n\t\t</span><span class="s1">return international &amp;&amp; !callingCode</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">// Extracts a country calling code from a number</span><span class="s3">\r\n\t</span><span class="s1">// being entered in internatonal format.</span><span class="s3">\r\n\t</span><span class="s1">extractCountryCallingCode(state) {</span><span class="s3">\r\n\t\t</span><span class="s1">const { countryCallingCode, number } = extractCountryCallingCode(</span><span class="s3">\r\n\t\t\t</span><span class="s1">'+' + state.getDigitsWithoutInternationalPrefix(),</span><span class="s3">\r\n\t\t\t</span><span class="s1">state.country,</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.defaultCountry,</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.defaultCallingCode,</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.metadata.metadata</span><span class="s3">\r\n\t\t</span><span class="s1">)</span><span class="s3">\r\n\t\t</span><span class="s1">if (countryCallingCode) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">state.setCallingCode(countryCallingCode)</span><span class="s3">\r\n\t\t\t</span><span class="s1">state.update({</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">nationalSignificantNumber: number</span><span class="s3">\r\n\t\t\t</span><span class="s1">})</span><span class="s3">\r\n\t\t\t</span><span class="s1">return true</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">reset(numberingPlan) {</span><span class="s3">\r\n\t\t</span><span class="s1">if (numberingPlan) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.hasSelectedNumberingPlan = true</span><span class="s3">\r\n\t\t\t</span><span class="s1">const nationalPrefixForParsing = numberingPlan._nationalPrefixForParsing()</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.couldPossiblyExtractAnotherNationalSignificantNumber = nationalPrefixForParsing &amp;&amp; COMPLEX_NATIONAL_PREFIX.test(nationalPrefixForParsing)</span><span class="s3">\r\n\t\t</span><span class="s1">} else {</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.hasSelectedNumberingPlan = undefined</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.couldPossiblyExtractAnotherNationalSignificantNumber = undefined</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">/**</span><span class="s3">\r\n\t </span><span class="s1">* Extracts a national (significant) number from user input.</span><span class="s3">\r\n\t </span><span class="s1">* Google's library is different in that it only applies `national_prefix_for_parsing`</span><span class="s3">\r\n\t </span><span class="s1">* and doesn't apply `national_prefix_transform_rule` after that.</span><span class="s3">\r\n\t </span><span class="s1">* https://github.com/google/libphonenumber/blob/a3d70b0487875475e6ad659af404943211d26456/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L539</span><span class="s3">\r\n\t </span><span class="s1">* @return {boolean} [extracted]</span><span class="s3">\r\n\t </span><span class="s1">*/</span><span class="s3">\r\n\t</span><span class="s1">extractNationalSignificantNumber(nationalDigits, setState) {</span><span class="s3">\r\n\t\t</span><span class="s1">if (!this.hasSelectedNumberingPlan) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">return</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">const {</span><span class="s3">\r\n\t\t\t</span><span class="s1">nationalPrefix,</span><span class="s3">\r\n\t\t\t</span><span class="s1">nationalNumber,</span><span class="s3">\r\n\t\t\t</span><span class="s1">carrierCode</span><span class="s3">\r\n\t\t</span><span class="s1">} = extractNationalNumberFromPossiblyIncompleteNumber(</span><span class="s3">\r\n\t\t\t</span><span class="s1">nationalDigits,</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.metadata</span><span class="s3">\r\n\t\t</span><span class="s1">)</span><span class="s3">\r\n\t\t</span><span class="s1">if (nationalNumber === nationalDigits) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">return</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">this.onExtractedNationalNumber(</span><span class="s3">\r\n\t\t\t</span><span class="s1">nationalPrefix,</span><span class="s3">\r\n\t\t\t</span><span class="s1">carrierCode,</span><span class="s3">\r\n\t\t\t</span><span class="s1">nationalNumber,</span><span class="s3">\r\n\t\t\t</span><span class="s1">nationalDigits,</span><span class="s3">\r\n\t\t\t</span><span class="s1">setState</span><span class="s3">\r\n\t\t</span><span class="s1">)</span><span class="s3">\r\n\t\t</span><span class="s1">return true</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">/**</span><span class="s3">\r\n\t </span><span class="s1">* In Google's code this function is called </span><span class="s3">\&quot;</span><span class="s1">attempt to extract longer NDD</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\r\n\t </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">Some national prefixes are a substring of others</span><span class="s3">\&quot;</span><span class="s1">, they say.</span><span class="s3">\r\n\t </span><span class="s1">* @return {boolean} [result] — Returns `true` if extracting a national prefix produced different results from what they were.</span><span class="s3">\r\n\t </span><span class="s1">*/</span><span class="s3">\r\n\t</span><span class="s1">extractAnotherNationalSignificantNumber(nationalDigits, prevNationalSignificantNumber, setState) {</span><span class="s3">\r\n\t\t</span><span class="s1">if (!this.hasExtractedNationalSignificantNumber) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">return this.extractNationalSignificantNumber(nationalDigits, setState)</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">if (!this.couldPossiblyExtractAnotherNationalSignificantNumber) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">return</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">const {</span><span class="s3">\r\n\t\t\t</span><span class="s1">nationalPrefix,</span><span class="s3">\r\n\t\t\t</span><span class="s1">nationalNumber,</span><span class="s3">\r\n\t\t\t</span><span class="s1">carrierCode</span><span class="s3">\r\n\t\t</span><span class="s1">} = extractNationalNumberFromPossiblyIncompleteNumber(</span><span class="s3">\r\n\t\t\t</span><span class="s1">nationalDigits,</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.metadata</span><span class="s3">\r\n\t\t</span><span class="s1">)</span><span class="s3">\r\n\t\t</span><span class="s1">// If a national prefix has been extracted previously,</span><span class="s3">\r\n\t\t</span><span class="s1">// then it's always extracted as additional digits are added.</span><span class="s3">\r\n\t\t</span><span class="s1">// That's assuming `extractNationalNumberFromPossiblyIncompleteNumber()`</span><span class="s3">\r\n\t\t</span><span class="s1">// doesn't do anything different from what it currently does.</span><span class="s3">\r\n\t\t</span><span class="s1">// So, just in case, here's this check, though it doesn't occur.</span><span class="s3">\r\n\t\t</span><span class="s1">/* istanbul ignore if */</span><span class="s3">\r\n\t\t</span><span class="s1">if (nationalNumber === prevNationalSignificantNumber) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">return</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">this.onExtractedNationalNumber(</span><span class="s3">\r\n\t\t\t</span><span class="s1">nationalPrefix,</span><span class="s3">\r\n\t\t\t</span><span class="s1">carrierCode,</span><span class="s3">\r\n\t\t\t</span><span class="s1">nationalNumber,</span><span class="s3">\r\n\t\t\t</span><span class="s1">nationalDigits,</span><span class="s3">\r\n\t\t\t</span><span class="s1">setState</span><span class="s3">\r\n\t\t</span><span class="s1">)</span><span class="s3">\r\n\t\t</span><span class="s1">return true</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">onExtractedNationalNumber(</span><span class="s3">\r\n\t\t</span><span class="s1">nationalPrefix,</span><span class="s3">\r\n\t\t</span><span class="s1">carrierCode,</span><span class="s3">\r\n\t\t</span><span class="s1">nationalSignificantNumber,</span><span class="s3">\r\n\t\t</span><span class="s1">nationalDigits,</span><span class="s3">\r\n\t\t</span><span class="s1">setState</span><span class="s3">\r\n\t</span><span class="s1">) {</span><span class="s3">\r\n\t\t</span><span class="s1">// Tells if the parsed national (significant) number is present as-is in the input string.</span><span class="s3">\r\n\t\t</span><span class="s1">// For example, when inputting </span><span class="s3">\&quot;</span><span class="s1">0343515551212999</span><span class="s3">\&quot; </span><span class="s1">Argentinian mobile number,</span><span class="s3">\r\n\t\t</span><span class="s1">// the parsed national (significant) number is </span><span class="s3">\&quot;</span><span class="s1">93435551212999</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\r\n\t\t</span><span class="s1">// There, one can see how it stripped </span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot; </span><span class="s1">national prefix and prepended a </span><span class="s3">\&quot;</span><span class="s1">9</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\r\n\t\t</span><span class="s1">// because that's how it is instructed to do in Argentina's metadata.</span><span class="s3">\r\n\t\t</span><span class="s1">// So in the described example, the parsed national (significant) number is not present</span><span class="s3">\r\n\t\t</span><span class="s1">// as-is in the input string. Instead, it's </span><span class="s3">\&quot;</span><span class="s1">modified</span><span class="s3">\&quot; </span><span class="s1">in the input string.</span><span class="s3">\r\n\t\t</span><span class="s1">// https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule</span><span class="s3">\r\n\t\t</span><span class="s1">let nationalSignificantNumberIsModified = false</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// In some countries, a phone number could have a prefix that is not a </span><span class="s3">\&quot;</span><span class="s1">national prefix</span><span class="s3">\&quot;\r\n\t\t</span><span class="s1">// but rather some other type of </span><span class="s3">\&quot;</span><span class="s1">utility</span><span class="s3">\&quot; </span><span class="s1">prefix.</span><span class="s3">\r\n\t\t</span><span class="s1">// For example, when calling within Australia, one could prepend `1831` prefix to hide</span><span class="s3">\r\n\t\t</span><span class="s1">// caller's phone number.</span><span class="s3">\r\n\t\t</span><span class="s1">// https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule</span><span class="s3">\r\n\t\t</span><span class="s1">let prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// `nationalSignificantNumber` could be empty. In that case, `.lastIndexOf()` still works correctly.</span><span class="s3">\r\n\t\t</span><span class="s1">const nationalSignificantNumberIndex = nationalDigits.lastIndexOf(nationalSignificantNumber)</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// If the parsed national (significant) number is the last substring of the `nationalDigits`,</span><span class="s3">\r\n\t\t</span><span class="s1">// then it means that it's present as-is in the input string.</span><span class="s3">\r\n\t\t</span><span class="s1">// In any other case, the parsed national (significant) number is </span><span class="s3">\&quot;</span><span class="s1">modified</span><span class="s3">\&quot; </span><span class="s1">in the input string.</span><span class="s3">\r\n\t\t</span><span class="s1">if (</span><span class="s3">\r\n\t\t\t</span><span class="s1">nationalSignificantNumberIndex &lt; 0 ||</span><span class="s3">\r\n\t\t\t</span><span class="s1">nationalSignificantNumberIndex !== nationalDigits.length - nationalSignificantNumber.length</span><span class="s3">\r\n\t\t</span><span class="s1">) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">nationalSignificantNumberIsModified = true</span><span class="s3">\r\n\t\t</span><span class="s1">} else {</span><span class="s3">\r\n\t\t\t</span><span class="s1">const prefixBeforeNationalNumber = nationalDigits.slice(0, nationalSignificantNumberIndex)</span><span class="s3">\r\n\t\t\t</span><span class="s1">// When national (significant) number is equal to the `nationalDigits`,</span><span class="s3">\r\n\t\t\t</span><span class="s1">// this `onExtractedNationalNumber()` function simply doesn't get called.</span><span class="s3">\r\n\t\t\t</span><span class="s1">// This means that at this point, `prefixBeforeNationalNumber` is always non-empty.</span><span class="s3">\r\n\t\t\t</span><span class="s1">// Still, added this `if` check just to prevent potential silly bugs.</span><span class="s3">\r\n\t\t\t</span><span class="s1">// The `!prefixBeforeNationalNumber` case is not really testable</span><span class="s3">\r\n\t\t\t</span><span class="s1">// so this line is exluded from the code coverage.</span><span class="s3">\r\n\t\t\t</span><span class="s1">/* istanbul ignore if */</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (prefixBeforeNationalNumber) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">if (prefixBeforeNationalNumber !== nationalPrefix) {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix = prefixBeforeNationalNumber</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">setState({</span><span class="s3">\r\n\t\t\t</span><span class="s1">nationalPrefix,</span><span class="s3">\r\n\t\t\t</span><span class="s1">carrierCode,</span><span class="s3">\r\n\t\t\t</span><span class="s1">nationalSignificantNumber,</span><span class="s3">\r\n\t\t\t</span><span class="s1">nationalSignificantNumberIsModified,</span><span class="s3">\r\n\t\t\t</span><span class="s1">prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix</span><span class="s3">\r\n\t\t</span><span class="s1">})</span><span class="s3">\r\n\t\t</span><span class="s1">// `onExtractedNationalNumber()` is only called when</span><span class="s3">\r\n\t\t</span><span class="s1">// the national (significant) number actually did change.</span><span class="s3">\r\n\t\t</span><span class="s1">this.hasExtractedNationalSignificantNumber = true</span><span class="s3">\r\n\t\t</span><span class="s1">this.onNationalSignificantNumberChange()</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">reExtractNationalSignificantNumber(state) {</span><span class="s3">\r\n\t\t</span><span class="s1">// Attempt to extract a national prefix.</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">// Some people incorrectly input national prefix</span><span class="s3">\r\n\t\t</span><span class="s1">// in an international phone number.</span><span class="s3">\r\n\t\t</span><span class="s1">// For example, some people write British phone numbers as `+44(0)...`.</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">// Also, in some rare cases, it is valid for a national prefix</span><span class="s3">\r\n\t\t</span><span class="s1">// to be a part of an international phone number.</span><span class="s3">\r\n\t\t</span><span class="s1">// For example, mobile phone numbers in Mexico are supposed to be</span><span class="s3">\r\n\t\t</span><span class="s1">// dialled internationally using a `1` national prefix,</span><span class="s3">\r\n\t\t</span><span class="s1">// so the national prefix will be part of an international number.</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">// Quote from:</span><span class="s3">\r\n\t\t</span><span class="s1">// https://www.mexperience.com/dialing-cell-phones-in-mexico/</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">Dialing a Mexican cell phone from abroad</span><span class="s3">\r\n\t\t</span><span class="s1">// When you are calling a cell phone number in Mexico from outside Mexico,</span><span class="s3">\r\n\t\t</span><span class="s1">// it’s necessary to dial an additional “1” after Mexico’s country code</span><span class="s3">\r\n\t\t</span><span class="s1">// (which is “52”) and before the area code.</span><span class="s3">\r\n\t\t</span><span class="s1">// You also ignore the 045, and simply dial the area code and the</span><span class="s3">\r\n\t\t</span><span class="s1">// cell phone’s number.</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">// If you don’t add the “1”, you’ll receive a recorded announcement</span><span class="s3">\r\n\t\t</span><span class="s1">// asking you to redial using it.</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">// For example, if you are calling from the USA to a cell phone</span><span class="s3">\r\n\t\t</span><span class="s1">// in Mexico City, you would dial +52 – 1 – 55 – 1234 5678.</span><span class="s3">\r\n\t\t</span><span class="s1">// (Note that this is different to calling a land line in Mexico City</span><span class="s3">\r\n\t\t</span><span class="s1">// from abroad, where the number dialed would be +52 – 55 – 1234 5678)</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">// Google's demo output:</span><span class="s3">\r\n\t\t</span><span class="s1">// https://libphonenumber.appspot.com/phonenumberparser?number=%2b5215512345678&amp;country=MX</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">if (this.extractAnotherNationalSignificantNumber(</span><span class="s3">\r\n\t\t\t</span><span class="s1">state.getNationalDigits(),</span><span class="s3">\r\n\t\t\t</span><span class="s1">state.nationalSignificantNumber,</span><span class="s3">\r\n\t\t\t</span><span class="s1">(stateUpdate) =&gt; state.update(stateUpdate)</span><span class="s3">\r\n\t\t</span><span class="s1">)) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">return true</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">// If no format matches the phone number, then it could be</span><span class="s3">\r\n\t\t</span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">a really long IDD</span><span class="s3">\&quot; </span><span class="s1">(quote from a comment in Google's library).</span><span class="s3">\r\n\t\t</span><span class="s1">// An IDD prefix is first extracted when the user has entered at least 3 digits,</span><span class="s3">\r\n\t\t</span><span class="s1">// and then here — every time when there's a new digit and the number</span><span class="s3">\r\n\t\t</span><span class="s1">// couldn't be formatted.</span><span class="s3">\r\n\t\t</span><span class="s1">// For example, in Australia the default IDD prefix is `0011`,</span><span class="s3">\r\n\t\t</span><span class="s1">// and it could even be as long as `14880011`.</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">// Could also check `!hasReceivedThreeLeadingDigits` here</span><span class="s3">\r\n\t\t</span><span class="s1">// to filter out the case when this check duplicates the one</span><span class="s3">\r\n\t\t</span><span class="s1">// already performed when there're 3 leading digits,</span><span class="s3">\r\n\t\t</span><span class="s1">// but it's not a big deal, and in most cases there</span><span class="s3">\r\n\t\t</span><span class="s1">// will be a suitable `format` when there're 3 leading digits.</span><span class="s3">\r\n\t\t</span><span class="s1">//</span><span class="s3">\r\n\t\t</span><span class="s1">if (this.extractIddPrefix(state)) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.extractCallingCodeAndNationalSignificantNumber(state)</span><span class="s3">\r\n\t\t\t</span><span class="s1">return true</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">// Google's AsYouType formatter supports sort of an </span><span class="s3">\&quot;</span><span class="s1">autocorrection</span><span class="s3">\&quot; </span><span class="s1">feature</span><span class="s3">\r\n\t\t</span><span class="s1">// when it </span><span class="s3">\&quot;</span><span class="s1">autocorrects</span><span class="s3">\&quot; </span><span class="s1">numbers that have been input for a country</span><span class="s3">\r\n\t\t</span><span class="s1">// with that country's calling code.</span><span class="s3">\r\n\t\t</span><span class="s1">// Such </span><span class="s3">\&quot;</span><span class="s1">autocorrection</span><span class="s3">\&quot; </span><span class="s1">feature looks weird, but different people have been requesting it:</span><span class="s3">\r\n\t\t</span><span class="s1">// https://github.com/catamphetamine/libphonenumber-js/issues/376</span><span class="s3">\r\n\t\t</span><span class="s1">// https://github.com/catamphetamine/libphonenumber-js/issues/375</span><span class="s3">\r\n\t\t</span><span class="s1">// https://github.com/catamphetamine/libphonenumber-js/issues/316</span><span class="s3">\r\n\t\t</span><span class="s1">if (this.fixMissingPlus(state)) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.extractCallingCodeAndNationalSignificantNumber(state)</span><span class="s3">\r\n\t\t\t</span><span class="s1">return true</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">extractIddPrefix(state) {</span><span class="s3">\r\n\t\t</span><span class="s1">// An IDD prefix can't be present in a number written with a `+`.</span><span class="s3">\r\n\t\t</span><span class="s1">// Also, don't re-extract an IDD prefix if has already been extracted.</span><span class="s3">\r\n\t\t</span><span class="s1">const {</span><span class="s3">\r\n\t\t\t</span><span class="s1">international,</span><span class="s3">\r\n\t\t\t</span><span class="s1">IDDPrefix,</span><span class="s3">\r\n\t\t\t</span><span class="s1">digits,</span><span class="s3">\r\n\t\t\t</span><span class="s1">nationalSignificantNumber</span><span class="s3">\r\n\t\t</span><span class="s1">} = state</span><span class="s3">\r\n\t\t</span><span class="s1">if (international || IDDPrefix) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">return</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">// Some users input their phone number in </span><span class="s3">\&quot;</span><span class="s1">out-of-country</span><span class="s3">\&quot;\r\n\t\t</span><span class="s1">// dialing format instead of using the leading `+`.</span><span class="s3">\r\n\t\t</span><span class="s1">// https://github.com/catamphetamine/libphonenumber-js/issues/185</span><span class="s3">\r\n\t\t</span><span class="s1">// Detect such numbers.</span><span class="s3">\r\n\t\t</span><span class="s1">const numberWithoutIDD = stripIddPrefix(</span><span class="s3">\r\n\t\t\t</span><span class="s1">digits,</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.defaultCountry,</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.defaultCallingCode,</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.metadata.metadata</span><span class="s3">\r\n\t\t</span><span class="s1">)</span><span class="s3">\r\n\t\t</span><span class="s1">if (numberWithoutIDD !== undefined &amp;&amp; numberWithoutIDD !== digits) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">// If an IDD prefix was stripped then convert the IDD-prefixed number</span><span class="s3">\r\n\t\t\t</span><span class="s1">// to international number for subsequent parsing.</span><span class="s3">\r\n\t\t\t</span><span class="s1">state.update({</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">IDDPrefix: digits.slice(0, digits.length - numberWithoutIDD.length)</span><span class="s3">\r\n\t\t\t</span><span class="s1">})</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.startInternationalNumber(state, {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">country: undefined,</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">callingCode: undefined</span><span class="s3">\r\n\t\t\t</span><span class="s1">})</span><span class="s3">\r\n\t\t\t</span><span class="s1">return true</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">fixMissingPlus(state) {</span><span class="s3">\r\n\t\t</span><span class="s1">if (!state.international) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">const {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">countryCallingCode: newCallingCode</span><span class="s3">\r\n\t\t\t</span><span class="s1">} = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">state.digits,</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">state.country,</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">this.defaultCountry,</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">this.defaultCallingCode,</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">this.metadata.metadata</span><span class="s3">\r\n\t\t\t</span><span class="s1">)</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (newCallingCode) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">state.update({</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">missingPlus: true</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">})</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">this.startInternationalNumber(state, {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">country: state.country,</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">callingCode: newCallingCode</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">})</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">return true</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">startInternationalNumber(state, { country, callingCode }) {</span><span class="s3">\r\n\t\t</span><span class="s1">state.startInternationalNumber(country, callingCode)</span><span class="s3">\r\n\t\t</span><span class="s1">// If a national (significant) number has been extracted before, reset it.</span><span class="s3">\r\n\t\t</span><span class="s1">if (state.nationalSignificantNumber) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">state.resetNationalSignificantNumber()</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.onNationalSignificantNumberChange()</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.hasExtractedNationalSignificantNumber = undefined</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">extractCallingCodeAndNationalSignificantNumber(state) {</span><span class="s3">\r\n\t\t</span><span class="s1">if (this.extractCountryCallingCode(state)) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">// `this.extractCallingCode()` is currently called when the number</span><span class="s3">\r\n\t\t\t</span><span class="s1">// couldn't be formatted during the standard procedure.</span><span class="s3">\r\n\t\t\t</span><span class="s1">// Normally, the national prefix would be re-extracted</span><span class="s3">\r\n\t\t\t</span><span class="s1">// for an international number if such number couldn't be formatted,</span><span class="s3">\r\n\t\t\t</span><span class="s1">// but since it's already not able to be formatted,</span><span class="s3">\r\n\t\t\t</span><span class="s1">// there won't be yet another retry, so also extract national prefix here.</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.extractNationalSignificantNumber(</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">state.getNationalDigits(),</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">(stateUpdate) =&gt; state.update(stateUpdate)</span><span class="s3">\r\n\t\t\t</span><span class="s1">)</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n</span><span class="s1">}</span><span class="s3">\r\n\r\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* Extracts formatted phone number from text (if there's any).</span><span class="s3">\r\n </span><span class="s1">* @param  {string} text</span><span class="s3">\r\n </span><span class="s1">* @return {string} [formattedPhoneNumber]</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\r\n</span><span class="s1">function extractFormattedPhoneNumber(text) {</span><span class="s3">\r\n\t</span><span class="s1">// Attempt to extract a possible number from the string passed in.</span><span class="s3">\r\n\t</span><span class="s1">const startsAt = text.search(VALID_FORMATTED_PHONE_NUMBER_PART)</span><span class="s3">\r\n\t</span><span class="s1">if (startsAt &lt; 0) {</span><span class="s3">\r\n\t\t</span><span class="s1">return</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">// Trim everything to the left of the phone number.</span><span class="s3">\r\n\t</span><span class="s1">text = text.slice(startsAt)</span><span class="s3">\r\n\t</span><span class="s1">// Trim the `+`.</span><span class="s3">\r\n\t</span><span class="s1">let hasPlus</span><span class="s3">\r\n\t</span><span class="s1">if (text[0] === '+') {</span><span class="s3">\r\n\t\t</span><span class="s1">hasPlus = true</span><span class="s3">\r\n\t\t</span><span class="s1">text = text.slice('+'.length)</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">// Trim everything to the right of the phone number.</span><span class="s3">\r\n\t</span><span class="s1">text = text.replace(AFTER_PHONE_NUMBER_DIGITS_END_PATTERN, '')</span><span class="s3">\r\n\t</span><span class="s1">// Re-add the previously trimmed `+`.</span><span class="s3">\r\n\t</span><span class="s1">if (hasPlus) {</span><span class="s3">\r\n\t\t</span><span class="s1">text = '+' + text</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">return text</span><span class="s3">\r\n</span><span class="s1">}</span><span class="s3">\r\n\r\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* Extracts formatted phone number digits (and a `+`) from text (if there're any).</span><span class="s3">\r\n </span><span class="s1">* @param  {string} text</span><span class="s3">\r\n </span><span class="s1">* @return {any[]}</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\r\n</span><span class="s1">function _extractFormattedDigitsAndPlus(text) {</span><span class="s3">\r\n\t</span><span class="s1">// Extract a formatted phone number part from text.</span><span class="s3">\r\n\t</span><span class="s1">const extractedNumber = extractFormattedPhoneNumber(text) || ''</span><span class="s3">\r\n\t</span><span class="s1">// Trim a `+`.</span><span class="s3">\r\n\t</span><span class="s1">if (extractedNumber[0] === '+') {</span><span class="s3">\r\n\t\t</span><span class="s1">return [extractedNumber.slice('+'.length), true]</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">return [extractedNumber]</span><span class="s3">\r\n</span><span class="s1">}</span><span class="s3">\r\n\r\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* Extracts formatted phone number digits (and a `+`) from text (if there're any).</span><span class="s3">\r\n </span><span class="s1">* @param  {string} text</span><span class="s3">\r\n </span><span class="s1">* @return {any[]}</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\r\n</span><span class="s1">export function extractFormattedDigitsAndPlus(text) {</span><span class="s3">\r\n\t</span><span class="s1">let [formattedDigits, hasPlus] = _extractFormattedDigitsAndPlus(text)</span><span class="s3">\r\n\t</span><span class="s1">// If the extracted phone number part</span><span class="s3">\r\n\t</span><span class="s1">// can possibly be a part of some valid phone number</span><span class="s3">\r\n\t</span><span class="s1">// then parse phone number characters from a formatted phone number.</span><span class="s3">\r\n\t</span><span class="s1">if (!VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN.test(formattedDigits)) {</span><span class="s3">\r\n\t\t</span><span class="s1">formattedDigits = ''</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">return [formattedDigits, hasPlus]</span><span class="s3">\r\n</span><span class="s1">}&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>