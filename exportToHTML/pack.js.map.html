<html>
<head>
<title>pack.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
pack.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;pack.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/pack.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// A readable tar stream creator</span><span class="s3">\n</span><span class="s1">// Technically, this is a transform stream that you write paths into,</span><span class="s3">\n</span><span class="s1">// and tar format comes out of.</span><span class="s3">\n</span><span class="s1">// The `add()` method is like `write()` but returns this,</span><span class="s3">\n</span><span class="s1">// and end() return `this` as well, so you can</span><span class="s3">\n</span><span class="s1">// do `new Pack(opt).add('files').add('dir').end().pipe(output)</span><span class="s3">\n</span><span class="s1">// You could also do something like:</span><span class="s3">\n</span><span class="s1">// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))</span><span class="s3">\n\n</span><span class="s1">import fs, { type Stats } from 'fs'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">WriteEntry,</span><span class="s3">\n  </span><span class="s1">WriteEntrySync,</span><span class="s3">\n  </span><span class="s1">WriteEntryTar,</span><span class="s3">\n</span><span class="s1">} from './write-entry.js'</span><span class="s3">\n\n</span><span class="s1">export class PackJob {</span><span class="s3">\n  </span><span class="s1">path: string</span><span class="s3">\n  </span><span class="s1">absolute: string</span><span class="s3">\n  </span><span class="s1">entry?: WriteEntry | WriteEntryTar</span><span class="s3">\n  </span><span class="s1">stat?: Stats</span><span class="s3">\n  </span><span class="s1">readdir?: string[]</span><span class="s3">\n  </span><span class="s1">pending: boolean = false</span><span class="s3">\n  </span><span class="s1">ignore: boolean = false</span><span class="s3">\n  </span><span class="s1">piped: boolean = false</span><span class="s3">\n  </span><span class="s1">constructor(path: string, absolute: string) {</span><span class="s3">\n    </span><span class="s1">this.path = path || './'</span><span class="s3">\n    </span><span class="s1">this.absolute = absolute</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">import { Minipass } from 'minipass'</span><span class="s3">\n</span><span class="s1">import * as zlib from 'minizlib'</span><span class="s3">\n</span><span class="s1">import { Yallist } from 'yallist'</span><span class="s3">\n</span><span class="s1">import { ReadEntry } from './read-entry.js'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">WarnEvent,</span><span class="s3">\n  </span><span class="s1">warnMethod,</span><span class="s3">\n  </span><span class="s1">type WarnData,</span><span class="s3">\n  </span><span class="s1">type Warner,</span><span class="s3">\n</span><span class="s1">} from './warn-method.js'</span><span class="s3">\n\n</span><span class="s1">const EOF = Buffer.alloc(1024)</span><span class="s3">\n</span><span class="s1">const ONSTAT = Symbol('onStat')</span><span class="s3">\n</span><span class="s1">const ENDED = Symbol('ended')</span><span class="s3">\n</span><span class="s1">const QUEUE = Symbol('queue')</span><span class="s3">\n</span><span class="s1">const CURRENT = Symbol('current')</span><span class="s3">\n</span><span class="s1">const PROCESS = Symbol('process')</span><span class="s3">\n</span><span class="s1">const PROCESSING = Symbol('processing')</span><span class="s3">\n</span><span class="s1">const PROCESSJOB = Symbol('processJob')</span><span class="s3">\n</span><span class="s1">const JOBS = Symbol('jobs')</span><span class="s3">\n</span><span class="s1">const JOBDONE = Symbol('jobDone')</span><span class="s3">\n</span><span class="s1">const ADDFSENTRY = Symbol('addFSEntry')</span><span class="s3">\n</span><span class="s1">const ADDTARENTRY = Symbol('addTarEntry')</span><span class="s3">\n</span><span class="s1">const STAT = Symbol('stat')</span><span class="s3">\n</span><span class="s1">const READDIR = Symbol('readdir')</span><span class="s3">\n</span><span class="s1">const ONREADDIR = Symbol('onreaddir')</span><span class="s3">\n</span><span class="s1">const PIPE = Symbol('pipe')</span><span class="s3">\n</span><span class="s1">const ENTRY = Symbol('entry')</span><span class="s3">\n</span><span class="s1">const ENTRYOPT = Symbol('entryOpt')</span><span class="s3">\n</span><span class="s1">const WRITEENTRYCLASS = Symbol('writeEntryClass')</span><span class="s3">\n</span><span class="s1">const WRITE = Symbol('write')</span><span class="s3">\n</span><span class="s1">const ONDRAIN = Symbol('ondrain')</span><span class="s3">\n\n</span><span class="s1">import path from 'path'</span><span class="s3">\n</span><span class="s1">import { normalizeWindowsPath } from './normalize-windows-path.js'</span><span class="s3">\n</span><span class="s1">import { TarOptions } from './options.js'</span><span class="s3">\n\n</span><span class="s1">export class Pack</span><span class="s3">\n  </span><span class="s1">extends Minipass&lt;Buffer, ReadEntry | string, WarnEvent&lt;Buffer&gt;&gt;</span><span class="s3">\n  </span><span class="s1">implements Warner</span><span class="s3">\n</span><span class="s1">{</span><span class="s3">\n  </span><span class="s1">opt: TarOptions</span><span class="s3">\n  </span><span class="s1">cwd: string</span><span class="s3">\n  </span><span class="s1">maxReadSize?: number</span><span class="s3">\n  </span><span class="s1">preservePaths: boolean</span><span class="s3">\n  </span><span class="s1">strict: boolean</span><span class="s3">\n  </span><span class="s1">noPax: boolean</span><span class="s3">\n  </span><span class="s1">prefix: string</span><span class="s3">\n  </span><span class="s1">linkCache: Exclude&lt;TarOptions['linkCache'], undefined&gt;</span><span class="s3">\n  </span><span class="s1">statCache: Exclude&lt;TarOptions['statCache'], undefined&gt;</span><span class="s3">\n  </span><span class="s1">file: string</span><span class="s3">\n  </span><span class="s1">portable: boolean</span><span class="s3">\n  </span><span class="s1">zip?: zlib.BrotliCompress | zlib.Gzip | zlib.ZstdCompress</span><span class="s3">\n  </span><span class="s1">readdirCache: Exclude&lt;TarOptions['readdirCache'], undefined&gt;</span><span class="s3">\n  </span><span class="s1">noDirRecurse: boolean</span><span class="s3">\n  </span><span class="s1">follow: boolean</span><span class="s3">\n  </span><span class="s1">noMtime: boolean</span><span class="s3">\n  </span><span class="s1">mtime?: Date</span><span class="s3">\n  </span><span class="s1">filter: Exclude&lt;TarOptions['filter'], undefined&gt;</span><span class="s3">\n  </span><span class="s1">jobs: number;</span><span class="s3">\n\n  </span><span class="s1">[WRITEENTRYCLASS]: typeof WriteEntry | typeof WriteEntrySync</span><span class="s3">\n  </span><span class="s1">onWriteEntry?: (entry: WriteEntry) =&gt; void;</span><span class="s3">\n  </span><span class="s1">// Note: we actually DO need a linked list here, because we</span><span class="s3">\n  </span><span class="s1">// shift() to update the head of the list where we start, but still</span><span class="s3">\n  </span><span class="s1">// while that happens, need to know what the next item in the queue</span><span class="s3">\n  </span><span class="s1">// will be. Since we do multiple jobs in parallel, it's not as simple</span><span class="s3">\n  </span><span class="s1">// as just an Array.shift(), since that would lose the information about</span><span class="s3">\n  </span><span class="s1">// the next job in the list. We could add a .next field on the PackJob</span><span class="s3">\n  </span><span class="s1">// class, but then we'd have to be tracking the tail of the queue the</span><span class="s3">\n  </span><span class="s1">// whole time, and Yallist just does that for us anyway.</span><span class="s3">\n  </span><span class="s1">[QUEUE]: Yallist&lt;PackJob&gt;;</span><span class="s3">\n  </span><span class="s1">[JOBS]: number = 0;</span><span class="s3">\n  </span><span class="s1">[PROCESSING]: boolean = false;</span><span class="s3">\n  </span><span class="s1">[ENDED]: boolean = false</span><span class="s3">\n\n  </span><span class="s1">constructor(opt: TarOptions = {}) {</span><span class="s3">\n    </span><span class="s1">//@ts-ignore</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n    </span><span class="s1">this.opt = opt</span><span class="s3">\n    </span><span class="s1">this.file = opt.file || ''</span><span class="s3">\n    </span><span class="s1">this.cwd = opt.cwd || process.cwd()</span><span class="s3">\n    </span><span class="s1">this.maxReadSize = opt.maxReadSize</span><span class="s3">\n    </span><span class="s1">this.preservePaths = !!opt.preservePaths</span><span class="s3">\n    </span><span class="s1">this.strict = !!opt.strict</span><span class="s3">\n    </span><span class="s1">this.noPax = !!opt.noPax</span><span class="s3">\n    </span><span class="s1">this.prefix = normalizeWindowsPath(opt.prefix || '')</span><span class="s3">\n    </span><span class="s1">this.linkCache = opt.linkCache || new Map()</span><span class="s3">\n    </span><span class="s1">this.statCache = opt.statCache || new Map()</span><span class="s3">\n    </span><span class="s1">this.readdirCache = opt.readdirCache || new Map()</span><span class="s3">\n    </span><span class="s1">this.onWriteEntry = opt.onWriteEntry</span><span class="s3">\n\n    </span><span class="s1">this[WRITEENTRYCLASS] = WriteEntry</span><span class="s3">\n    </span><span class="s1">if (typeof opt.onwarn === 'function') {</span><span class="s3">\n      </span><span class="s1">this.on('warn', opt.onwarn)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.portable = !!opt.portable</span><span class="s3">\n\n    </span><span class="s1">if (opt.gzip || opt.brotli || opt.zstd) {</span><span class="s3">\n      </span><span class="s1">if ((opt.gzip ? 1 : 0) + (opt.brotli ? 1 : 0) + (opt.zstd ? 1 : 0) &gt; 1) {</span><span class="s3">\n        </span><span class="s1">throw new TypeError('gzip, brotli, zstd are mutually exclusive')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (opt.gzip) {</span><span class="s3">\n        </span><span class="s1">if (typeof opt.gzip !== 'object') {</span><span class="s3">\n          </span><span class="s1">opt.gzip = {}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.portable) {</span><span class="s3">\n          </span><span class="s1">opt.gzip.portable = true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.zip = new zlib.Gzip(opt.gzip)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (opt.brotli) {</span><span class="s3">\n        </span><span class="s1">if (typeof opt.brotli !== 'object') {</span><span class="s3">\n          </span><span class="s1">opt.brotli = {}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.zip = new zlib.BrotliCompress(opt.brotli)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (opt.zstd) {</span><span class="s3">\n        </span><span class="s1">if (typeof opt.zstd !== 'object') {</span><span class="s3">\n          </span><span class="s1">opt.zstd = {}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.zip = new zlib.ZstdCompress(opt.zstd)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">/* c8 ignore next */</span><span class="s3">\n      </span><span class="s1">if (!this.zip) throw new Error('impossible')</span><span class="s3">\n      </span><span class="s1">const zip = this.zip</span><span class="s3">\n      </span><span class="s1">zip.on('data', chunk =&gt; super.write(chunk as unknown as string))</span><span class="s3">\n      </span><span class="s1">zip.on('end', () =&gt; super.end())</span><span class="s3">\n      </span><span class="s1">zip.on('drain', () =&gt; this[ONDRAIN]())</span><span class="s3">\n      </span><span class="s1">this.on('resume', () =&gt; zip.resume())</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.on('drain', this[ONDRAIN])</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.noDirRecurse = !!opt.noDirRecurse</span><span class="s3">\n    </span><span class="s1">this.follow = !!opt.follow</span><span class="s3">\n    </span><span class="s1">this.noMtime = !!opt.noMtime</span><span class="s3">\n    </span><span class="s1">if (opt.mtime) this.mtime = opt.mtime</span><span class="s3">\n\n    </span><span class="s1">this.filter =</span><span class="s3">\n      </span><span class="s1">typeof opt.filter === 'function' ? opt.filter : () =&gt; true</span><span class="s3">\n\n    </span><span class="s1">this[QUEUE] = new Yallist&lt;PackJob&gt;()</span><span class="s3">\n    </span><span class="s1">this[JOBS] = 0</span><span class="s3">\n    </span><span class="s1">this.jobs = Number(opt.jobs) || 4</span><span class="s3">\n    </span><span class="s1">this[PROCESSING] = false</span><span class="s3">\n    </span><span class="s1">this[ENDED] = false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[WRITE](chunk: Buffer) {</span><span class="s3">\n    </span><span class="s1">return super.write(chunk as unknown as string)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">add(path: string | ReadEntry) {</span><span class="s3">\n    </span><span class="s1">this.write(path)</span><span class="s3">\n    </span><span class="s1">return this</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">end(cb?: () =&gt; void): this</span><span class="s3">\n  </span><span class="s1">end(path: string | ReadEntry, cb?: () =&gt; void): this</span><span class="s3">\n  </span><span class="s1">end(</span><span class="s3">\n    </span><span class="s1">path: string | ReadEntry,</span><span class="s3">\n    </span><span class="s1">encoding?: Minipass.Encoding,</span><span class="s3">\n    </span><span class="s1">cb?: () =&gt; void,</span><span class="s3">\n  </span><span class="s1">): this</span><span class="s3">\n  </span><span class="s1">end(</span><span class="s3">\n    </span><span class="s1">path?: string | ReadEntry | (() =&gt; void),</span><span class="s3">\n    </span><span class="s1">encoding?: Minipass.Encoding | (() =&gt; void),</span><span class="s3">\n    </span><span class="s1">cb?: () =&gt; void,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (typeof path === 'function') {</span><span class="s3">\n      </span><span class="s1">cb = path</span><span class="s3">\n      </span><span class="s1">path = undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (typeof encoding === 'function') {</span><span class="s3">\n      </span><span class="s1">cb = encoding</span><span class="s3">\n      </span><span class="s1">encoding = undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n    </span><span class="s1">if (path) {</span><span class="s3">\n      </span><span class="s1">this.add(path)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this[ENDED] = true</span><span class="s3">\n    </span><span class="s1">this[PROCESS]()</span><span class="s3">\n    </span><span class="s1">/* c8 ignore next */</span><span class="s3">\n    </span><span class="s1">if (cb) cb()</span><span class="s3">\n    </span><span class="s1">return this</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">write(path: string | ReadEntry) {</span><span class="s3">\n    </span><span class="s1">if (this[ENDED]) {</span><span class="s3">\n      </span><span class="s1">throw new Error('write after end')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (path instanceof ReadEntry) {</span><span class="s3">\n      </span><span class="s1">this[ADDTARENTRY](path)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this[ADDFSENTRY](path)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.flowing</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[ADDTARENTRY](p: ReadEntry) {</span><span class="s3">\n    </span><span class="s1">const absolute = normalizeWindowsPath(</span><span class="s3">\n      </span><span class="s1">path.resolve(this.cwd, p.path),</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">// in this case, we don't have to wait for the stat</span><span class="s3">\n    </span><span class="s1">if (!this.filter(p.path, p)) {</span><span class="s3">\n      </span><span class="s1">p.resume()</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const job = new PackJob(p.path, absolute)</span><span class="s3">\n      </span><span class="s1">job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))</span><span class="s3">\n      </span><span class="s1">job.entry.on('end', () =&gt; this[JOBDONE](job))</span><span class="s3">\n      </span><span class="s1">this[JOBS] += 1</span><span class="s3">\n      </span><span class="s1">this[QUEUE].push(job)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this[PROCESS]()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[ADDFSENTRY](p: string) {</span><span class="s3">\n    </span><span class="s1">const absolute = normalizeWindowsPath(path.resolve(this.cwd, p))</span><span class="s3">\n    </span><span class="s1">this[QUEUE].push(new PackJob(p, absolute))</span><span class="s3">\n    </span><span class="s1">this[PROCESS]()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[STAT](job: PackJob) {</span><span class="s3">\n    </span><span class="s1">job.pending = true</span><span class="s3">\n    </span><span class="s1">this[JOBS] += 1</span><span class="s3">\n    </span><span class="s1">const stat = this.follow ? 'stat' : 'lstat'</span><span class="s3">\n    </span><span class="s1">fs[stat](job.absolute, (er, stat) =&gt; {</span><span class="s3">\n      </span><span class="s1">job.pending = false</span><span class="s3">\n      </span><span class="s1">this[JOBS] -= 1</span><span class="s3">\n      </span><span class="s1">if (er) {</span><span class="s3">\n        </span><span class="s1">this.emit('error', er)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">this[ONSTAT](job, stat)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[ONSTAT](job: PackJob, stat: Stats) {</span><span class="s3">\n    </span><span class="s1">this.statCache.set(job.absolute, stat)</span><span class="s3">\n    </span><span class="s1">job.stat = stat</span><span class="s3">\n\n    </span><span class="s1">// now we have the stat, we can filter it.</span><span class="s3">\n    </span><span class="s1">if (!this.filter(job.path, stat)) {</span><span class="s3">\n      </span><span class="s1">job.ignore = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this[PROCESS]()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[READDIR](job: PackJob) {</span><span class="s3">\n    </span><span class="s1">job.pending = true</span><span class="s3">\n    </span><span class="s1">this[JOBS] += 1</span><span class="s3">\n    </span><span class="s1">fs.readdir(job.absolute, (er, entries) =&gt; {</span><span class="s3">\n      </span><span class="s1">job.pending = false</span><span class="s3">\n      </span><span class="s1">this[JOBS] -= 1</span><span class="s3">\n      </span><span class="s1">if (er) {</span><span class="s3">\n        </span><span class="s1">return this.emit('error', er)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this[ONREADDIR](job, entries)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[ONREADDIR](job: PackJob, entries: string[]) {</span><span class="s3">\n    </span><span class="s1">this.readdirCache.set(job.absolute, entries)</span><span class="s3">\n    </span><span class="s1">job.readdir = entries</span><span class="s3">\n    </span><span class="s1">this[PROCESS]()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[PROCESS]() {</span><span class="s3">\n    </span><span class="s1">if (this[PROCESSING]) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this[PROCESSING] = true</span><span class="s3">\n    </span><span class="s1">for (</span><span class="s3">\n      </span><span class="s1">let w = this[QUEUE].head;</span><span class="s3">\n      </span><span class="s1">!!w &amp;&amp; this[JOBS] &lt; this.jobs;</span><span class="s3">\n      </span><span class="s1">w = w.next</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this[PROCESSJOB](w.value)</span><span class="s3">\n      </span><span class="s1">if (w.value.ignore) {</span><span class="s3">\n        </span><span class="s1">const p = w.next</span><span class="s3">\n        </span><span class="s1">this[QUEUE].removeNode(w)</span><span class="s3">\n        </span><span class="s1">w.next = p</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this[PROCESSING] = false</span><span class="s3">\n\n    </span><span class="s1">if (this[ENDED] &amp;&amp; !this[QUEUE].length &amp;&amp; this[JOBS] === 0) {</span><span class="s3">\n      </span><span class="s1">if (this.zip) {</span><span class="s3">\n        </span><span class="s1">this.zip.end(EOF)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">super.write(EOF as unknown as string)</span><span class="s3">\n        </span><span class="s1">super.end()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get [CURRENT]() {</span><span class="s3">\n    </span><span class="s1">return this[QUEUE] &amp;&amp; this[QUEUE].head &amp;&amp; this[QUEUE].head.value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[JOBDONE](_job: PackJob) {</span><span class="s3">\n    </span><span class="s1">this[QUEUE].shift()</span><span class="s3">\n    </span><span class="s1">this[JOBS] -= 1</span><span class="s3">\n    </span><span class="s1">this[PROCESS]()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[PROCESSJOB](job: PackJob) {</span><span class="s3">\n    </span><span class="s1">if (job.pending) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (job.entry) {</span><span class="s3">\n      </span><span class="s1">if (job === this[CURRENT] &amp;&amp; !job.piped) {</span><span class="s3">\n        </span><span class="s1">this[PIPE](job)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!job.stat) {</span><span class="s3">\n      </span><span class="s1">const sc = this.statCache.get(job.absolute)</span><span class="s3">\n      </span><span class="s1">if (sc) {</span><span class="s3">\n        </span><span class="s1">this[ONSTAT](job, sc)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">this[STAT](job)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!job.stat) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// filtered out!</span><span class="s3">\n    </span><span class="s1">if (job.ignore) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!this.noDirRecurse &amp;&amp;</span><span class="s3">\n      </span><span class="s1">job.stat.isDirectory() &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!job.readdir</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const rc = this.readdirCache.get(job.absolute)</span><span class="s3">\n      </span><span class="s1">if (rc) {</span><span class="s3">\n        </span><span class="s1">this[ONREADDIR](job, rc)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">this[READDIR](job)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!job.readdir) {</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// we know it doesn't have an entry, because that got checked above</span><span class="s3">\n    </span><span class="s1">job.entry = this[ENTRY](job)</span><span class="s3">\n    </span><span class="s1">if (!job.entry) {</span><span class="s3">\n      </span><span class="s1">job.ignore = true</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (job === this[CURRENT] &amp;&amp; !job.piped) {</span><span class="s3">\n      </span><span class="s1">this[PIPE](job)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[ENTRYOPT](job: PackJob): TarOptions {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">onwarn: (code, msg, data) =&gt; this.warn(code, msg, data),</span><span class="s3">\n      </span><span class="s1">noPax: this.noPax,</span><span class="s3">\n      </span><span class="s1">cwd: this.cwd,</span><span class="s3">\n      </span><span class="s1">absolute: job.absolute,</span><span class="s3">\n      </span><span class="s1">preservePaths: this.preservePaths,</span><span class="s3">\n      </span><span class="s1">maxReadSize: this.maxReadSize,</span><span class="s3">\n      </span><span class="s1">strict: this.strict,</span><span class="s3">\n      </span><span class="s1">portable: this.portable,</span><span class="s3">\n      </span><span class="s1">linkCache: this.linkCache,</span><span class="s3">\n      </span><span class="s1">statCache: this.statCache,</span><span class="s3">\n      </span><span class="s1">noMtime: this.noMtime,</span><span class="s3">\n      </span><span class="s1">mtime: this.mtime,</span><span class="s3">\n      </span><span class="s1">prefix: this.prefix,</span><span class="s3">\n      </span><span class="s1">onWriteEntry: this.onWriteEntry,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[ENTRY](job: PackJob) {</span><span class="s3">\n    </span><span class="s1">this[JOBS] += 1</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">const e = new this[WRITEENTRYCLASS](</span><span class="s3">\n        </span><span class="s1">job.path,</span><span class="s3">\n        </span><span class="s1">this[ENTRYOPT](job),</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">return e</span><span class="s3">\n        </span><span class="s1">.on('end', () =&gt; this[JOBDONE](job))</span><span class="s3">\n        </span><span class="s1">.on('error', er =&gt; this.emit('error', er))</span><span class="s3">\n    </span><span class="s1">} catch (er) {</span><span class="s3">\n      </span><span class="s1">this.emit('error', er)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[ONDRAIN]() {</span><span class="s3">\n    </span><span class="s1">if (this[CURRENT] &amp;&amp; this[CURRENT].entry) {</span><span class="s3">\n      </span><span class="s1">this[CURRENT].entry.resume()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// like .pipe() but using super, because our write() is special</span><span class="s3">\n  </span><span class="s1">[PIPE](job: PackJob) {</span><span class="s3">\n    </span><span class="s1">job.piped = true</span><span class="s3">\n\n    </span><span class="s1">if (job.readdir) {</span><span class="s3">\n      </span><span class="s1">job.readdir.forEach(entry =&gt; {</span><span class="s3">\n        </span><span class="s1">const p = job.path</span><span class="s3">\n        </span><span class="s1">const base = p === './' ? '' : p.replace(/</span><span class="s3">\\</span><span class="s1">/*$/, '/')</span><span class="s3">\n        </span><span class="s1">this[ADDFSENTRY](base + entry)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const source = job.entry</span><span class="s3">\n    </span><span class="s1">const zip = this.zip</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (!source) throw new Error('cannot pipe without source')</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n    </span><span class="s1">if (zip) {</span><span class="s3">\n      </span><span class="s1">source.on('data', chunk =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!zip.write(chunk)) {</span><span class="s3">\n          </span><span class="s1">source.pause()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">source.on('data', chunk =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!super.write(chunk as unknown as string)) {</span><span class="s3">\n          </span><span class="s1">source.pause()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">pause() {</span><span class="s3">\n    </span><span class="s1">if (this.zip) {</span><span class="s3">\n      </span><span class="s1">this.zip.pause()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return super.pause()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">warn(</span><span class="s3">\n    </span><span class="s1">code: string,</span><span class="s3">\n    </span><span class="s1">message: string | Error,</span><span class="s3">\n    </span><span class="s1">data: WarnData = {},</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">warnMethod(this, code, message, data)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class PackSync extends Pack {</span><span class="s3">\n  </span><span class="s1">sync: true = true</span><span class="s3">\n  </span><span class="s1">constructor(opt: TarOptions) {</span><span class="s3">\n    </span><span class="s1">super(opt)</span><span class="s3">\n    </span><span class="s1">this[WRITEENTRYCLASS] = WriteEntrySync</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// pause/resume are no-ops in sync streams.</span><span class="s3">\n  </span><span class="s1">pause() {}</span><span class="s3">\n  </span><span class="s1">resume() {}</span><span class="s3">\n\n  </span><span class="s1">[STAT](job: PackJob) {</span><span class="s3">\n    </span><span class="s1">const stat = this.follow ? 'statSync' : 'lstatSync'</span><span class="s3">\n    </span><span class="s1">this[ONSTAT](job, fs[stat](job.absolute))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[READDIR](job: PackJob) {</span><span class="s3">\n    </span><span class="s1">this[ONREADDIR](job, fs.readdirSync(job.absolute))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// gotta get it all in this tick</span><span class="s3">\n  </span><span class="s1">[PIPE](job: PackJob) {</span><span class="s3">\n    </span><span class="s1">const source = job.entry</span><span class="s3">\n    </span><span class="s1">const zip = this.zip</span><span class="s3">\n\n    </span><span class="s1">if (job.readdir) {</span><span class="s3">\n      </span><span class="s1">job.readdir.forEach(entry =&gt; {</span><span class="s3">\n        </span><span class="s1">const p = job.path</span><span class="s3">\n        </span><span class="s1">const base = p === './' ? '' : p.replace(/</span><span class="s3">\\</span><span class="s1">/*$/, '/')</span><span class="s3">\n        </span><span class="s1">this[ADDFSENTRY](base + entry)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (!source) throw new Error('Cannot pipe without source')</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n    </span><span class="s1">if (zip) {</span><span class="s3">\n      </span><span class="s1">source.on('data', chunk =&gt; {</span><span class="s3">\n        </span><span class="s1">zip.write(chunk)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">source.on('data', chunk =&gt; {</span><span class="s3">\n        </span><span class="s1">super[WRITE](chunk)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">]}</span></pre>
</body>
</html>