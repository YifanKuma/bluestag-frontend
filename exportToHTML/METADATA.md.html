<html>
<head>
<title>METADATA.md</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #080808;}
.s3 { color: #006dcc;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
METADATA.md</font>
</center></td></tr></table>
<pre><span class="s0"># </span><span class="s2">Metadata</span>

<span class="s2">This document describes `metadata.json` that's generated from `PhoneNumberMetadata.xml` by running `npm run metadata</span><span class="s1">:</span><span class="s2">generate` command. It serves as an intermediary step for generating all other metadata </span><span class="s1">(</span><span class="s2">such as `metadata.min.json`</span><span class="s1">)</span><span class="s2">, and is therefore not included in the final distribution. See </span><span class="s1">[</span><span class="s2">`PhoneNumberMetadata.xml`</span><span class="s1">](</span><span class="s3">https://github.com/google/libphonenumber/blob/master/resources/PhoneNumberMetadata.xml</span><span class="s1">) </span><span class="s2">in Google's repo. They also have some </span><span class="s1">[</span><span class="s2">docs</span><span class="s1">](</span><span class="s3">https://github.com/google/libphonenumber/blob/master/resources/phonemetadata.proto</span><span class="s1">) </span><span class="s2">on metadata fields too.</span>

<span class="s0">## </span><span class="s2">Country calling codes</span>

<span class="s2">`country_calling_codes` — A list of countries by country calling code</span><span class="s1">: </span><span class="s2">some country calling codes are shared between several countries </span><span class="s1">(</span><span class="s2">for example, United States and Canada</span><span class="s1">)</span><span class="s2">.</span>

<span class="s0">## </span><span class="s2">Countries</span>

<span class="s2">`countries` — Contains metadata for each country.</span>

<span class="s0">### </span><span class="s2">`phone_code`</span>

<span class="s2">Country calling code, duplicated here for easy lookup of country calling code by country. Could be considered </span><span class="s1">&quot;</span><span class="s2">reverse lookup</span><span class="s1">&quot; </span><span class="s2">compared to `country_calling_codes`.</span>

<span class="s0">### </span><span class="s2">`idd_prefix`</span>

<span class="s1">[</span><span class="s2">International Direct Dialing prefix</span><span class="s1">](</span><span class="s3">https://wikitravel.org/en/International_dialling_prefix</span><span class="s1">) </span><span class="s2">when calling out of this country. </span><span class="s1">&quot;</span><span class="s2">IDD prefixes</span><span class="s1">&quot; </span><span class="s2">are defined for every country and are used to call from one country to another. </span><span class="s1">&quot;</span><span class="s2">IDD prefixes</span><span class="s1">&quot; </span><span class="s2">originated when telephony was still analogue and analogue phones didn't have a `+` input. Nowadays, mobile phone users dial international numbers using a `+` rather than an </span><span class="s1">&quot;</span><span class="s2">IDD prefix</span><span class="s1">&quot;</span><span class="s2">, but the mobile phone operating system replaces the `+` with an </span><span class="s1">&quot;</span><span class="s2">IDD prefix</span><span class="s1">&quot; </span><span class="s2">under the hood. For example, to call a Russian number `+7 800 555 35 35` from US the dialled digits would be `01178005553535` where `011` is an </span><span class="s1">&quot;</span><span class="s2">IDD prefix</span><span class="s1">&quot;</span><span class="s2">.</span>

<span class="s0">### </span><span class="s2">`default_idd_prefix`</span>

<span class="s2">When a country supports different </span><span class="s1">&quot;</span><span class="s2">IDD prefixes</span><span class="s1">&quot;</span><span class="s2">, the `idd_prefix` is a regular expression and `default_idd_prefix` is the default </span><span class="s1">&quot;</span><span class="s2">IDD prefix</span><span class="s1">&quot;</span><span class="s2">.</span>

<span class="s0">### </span><span class="s2">`ext`</span>

<span class="s2">Localized `</span><span class="s1">&quot; </span><span class="s2">ext. </span><span class="s1">&quot;</span><span class="s2">` prefix for this country. For example, in Russia it's `</span><span class="s1">&quot; </span><span class="s2">доб. </span><span class="s1">&quot;</span><span class="s2">`. Is only used for formatting phone numbers having </span><span class="s1">&quot;</span><span class="s2">extensions</span><span class="s1">&quot; (</span><span class="s2">usually these're organizational phone numbers</span><span class="s1">: </span><span class="s2">businesses, governmental institutions, educational institutions, etc</span><span class="s1">)</span><span class="s2">.</span>

<span class="s0">### </span><span class="s2">`leading_digits`</span>

<span class="s2">National </span><span class="s1">(</span><span class="s2">significant</span><span class="s1">) </span><span class="s2">number </span><span class="s1">&quot;</span><span class="s2">leading digits</span><span class="s1">&quot; </span><span class="s2">pattern. It's only defined for about 20% of the countries, and in most cases it's for resolving ambiguity in cases when there</span><span class="s1">'</span><span class="s2">re groups of countries sharing the same </span><span class="s1">&quot;</span><span class="s2">country calling code</span><span class="s1">&quot;</span><span class="s2">. Although, if there's a group of countries sharing the same </span><span class="s1">&quot;</span><span class="s2">country calling code</span><span class="s1">&quot;</span><span class="s2">, it doesn't necessarily mean that those countries have a `leading_digits` pattern defined.</span>

<span class="s2">For example, USA and Canada share the same `1` country calling code, but neither of them have a `leading_digits` pattern defined. On the other hand, Antigua and Barbuda also shares the same `1` country calling code, and its `leading_digits` pattern is `</span><span class="s1">&quot;</span><span class="s2">268</span><span class="s1">&quot;</span><span class="s2">`, so if an international phone number starts with `+1268` then it's certain that it belongs to Antigua and Barbuda, so </span><span class="s1">&quot;</span><span class="s2">leading digits</span><span class="s1">&quot; </span><span class="s2">are, in some cases, a quick way of determining which one of the countries sharing the same country calling code does a phone number belong to.</span>

<span class="s2">While in most cases a `leading_digits` pattern is a sequence of digits like `</span><span class="s1">&quot;</span><span class="s2">268</span><span class="s1">&quot;</span><span class="s2">` for Antigua and Barbuda, in other cases it's a pattern like `</span><span class="s1">&quot;</span><span class="s2">8001|8</span><span class="s1">[</span><span class="s2">024</span><span class="s1">]</span><span class="s2">9</span><span class="s1">&quot;</span><span class="s2">` for Dominican Republic.</span>

<span class="s2">Overall, `leading_digits` patterns are only used as a performance speed-up trick when determining which country a phone number belongs to</span><span class="s1">: </span><span class="s2">the check is still simpler than looking for a match against all of the precise phone number digit patterns of every country sharing a given country calling code.</span>

<span class="s2">For that reason, matching a `leading_digits` pattern is a sufficient but not a necessary condition for a phone number to belong to a country</span><span class="s1">: </span><span class="s2">if a `leading_digits` pattern exists and a phone number matches it that it's certain that the phone number belongs to the country, and no other country. But, if there's no `leading_digits` pattern, or if the phone number doesn't match the `leading_digits` pattern, then it doesn't mean that the phone number doesn</span><span class="s1">'</span><span class="s2">t belong to the country.</span>

<span class="s2">For example, </span><span class="s1">&quot;</span><span class="s2">toll free</span><span class="s1">&quot; </span><span class="s2">numbers starting with `800` are valid for all countries having `1` country calling code, so it doesn't make sense to include `800` in their `leading_digits` patterns. But one could say that those </span><span class="s1">&quot;</span><span class="s2">toll free</span><span class="s1">&quot; </span><span class="s2">numbers could be thought of as an unrelated edge case that can be ignored if the application only deals with human phone numbers.</span>

<span class="s2">Another example of phone number that're not included in `leading_digits` patters are </span><span class="s1">[&quot;</span><span class="s2">personal</span><span class="s1">&quot;](</span><span class="s3">https://en.wikipedia.org/wiki/Personal_Communications_Service</span><span class="s1">) (</span><span class="s2">satellite</span><span class="s1">) </span><span class="s2">numbers that start with </span><span class="s1">[</span><span class="s2">`5xx`</span><span class="s1">](</span><span class="s3">https://en.wikipedia.org/wiki/Personal_communications_service_(NANP)</span><span class="s1">) </span><span class="s2">for `+1` calling code.</span>

<span class="s1">&lt;!-- https://www.nationalnanpa.com/number_resource_info/5XX_codes.html --&gt;</span>

<span class="s2">The last example are mobile phone numbers which sometimes have identical patterns across the countries sharing the same </span><span class="s1">&quot;</span><span class="s2">country calling code</span><span class="s1">&quot;</span><span class="s2">. An example are Finland </span><span class="s1">(</span><span class="s2">`FI`</span><span class="s1">) </span><span class="s2">and Åland Islands </span><span class="s1">(</span><span class="s2">`AX`</span><span class="s1">) </span><span class="s2">which share the same `+358` calling code and the same pattern for mobile phone numbers. And while </span><span class="s1">[</span><span class="s2">`+358 457 XXX XXXX`</span><span class="s1">](</span><span class="s3">https://en.wikipedia.org/wiki/Telephone_numbers_in_Åland</span><span class="s1">) </span><span class="s2">mobile numbers could belong both to Finland or Åland Islands, Åland Islands' `leading_digits` pattern is just `18` which doesn't include any mobile numbers at all.</span>

<span class="s2">So `leading_digits` patterns could only be used for a quick </span><span class="s1">&quot;</span><span class="s2">positive</span><span class="s1">&quot; </span><span class="s2">check and they can't be used for ruling out any countries.</span>

<span class="s0">### </span><span class="s2">`national_number_pattern`</span>

<span class="s2">A regular expression covering all possible phone numbers for the country.</span>

<span class="s0">### </span><span class="s2">`national_prefix`</span>

<span class="s1">&quot;</span><span class="s2">National prefix</span><span class="s1">&quot;</span><span class="s2">, also known as </span><span class="s1">&quot;</span><span class="s2">National Direct Dialing prefix</span><span class="s1">&quot;</span><span class="s2">. In the early days of analogue telephony, countries were divided into </span><span class="s1">&quot;</span><span class="s2">areas</span><span class="s1">&quot; (</span><span class="s2">for example, cities</span><span class="s1">)</span><span class="s2">, and calling within an area </span><span class="s1">(</span><span class="s2">for example, a city</span><span class="s1">) </span><span class="s2">would only involve dialing a phone number without </span><span class="s1">&quot;</span><span class="s2">area code</span><span class="s1">&quot; </span><span class="s2">digits, but calling from one </span><span class="s1">&quot;</span><span class="s2">area</span><span class="s1">&quot; (</span><span class="s2">city</span><span class="s1">) </span><span class="s2">to another </span><span class="s1">(</span><span class="s2">city</span><span class="s1">) </span><span class="s2">would require dialing a </span><span class="s1">&quot;</span><span class="s2">national prefix</span><span class="s1">&quot; </span><span class="s2">first, so that the analogue telephone station would switch the user into </span><span class="s1">&quot;</span><span class="s2">nation-wide</span><span class="s1">&quot; </span><span class="s2">calling mode first.</span>

<span class="s2">For example, in New Zealand, the number that would be locally dialled as `09 345 3456` would be dialled from overseas as `+64 9 345 3456`. In this case, `0` is the national prefix.</span>

<span class="s2">Other national prefix examples</span><span class="s1">: </span><span class="s2">`1` in US, `0` in France and UK, `8` in Russia.</span>

<span class="s0">### </span><span class="s2">`national_prefix_for_parsing` / `national_prefix_transform_rule`</span>

<span class="s2">`national_prefix_for_parsing` is used to parse a </span><span class="s1">[</span><span class="s2">national </span><span class="s1">(</span><span class="s2">significant</span><span class="s1">) </span><span class="s2">number</span><span class="s1">](</span><span class="s3">https://gitlab.com/catamphetamine/libphonenumber-js#national-significant-number</span><span class="s1">) </span><span class="s2">from a phone number. Contrary to its name, `national_prefix_for_parsing` is used not just for parsing a </span><span class="s1">&quot;</span><span class="s2">national prefix</span><span class="s1">&quot; </span><span class="s2">out of a phone number </span><span class="s1">(</span><span class="s2">just `national_prefix` property would be sufficient for that</span><span class="s1">)</span><span class="s2">, but also for parsing any other possible phone number prefixes out of a phone number, if there're any, and for any other cases like fixing a missing area code. So it's actually not a </span><span class="s1">&quot;</span><span class="s2">national prefix for parsing</span><span class="s1">&quot;</span><span class="s2">, but rather a </span><span class="s1">&quot;</span><span class="s2">national </span><span class="s1">(</span><span class="s2">significant</span><span class="s1">) </span><span class="s2">number extraction mechanism</span><span class="s1">&quot;</span><span class="s2">.</span>

<span class="s2">`national_prefix_for_parsing` is a regular expression that could </span><span class="s1">(</span><span class="s2">or could not</span><span class="s1">) </span><span class="s2">have some </span><span class="s1">[&quot;</span><span class="s2">capturing groups</span><span class="s1">&quot;](</span><span class="s3">https://www.regular-expressions.info/refcapture.html</span><span class="s1">)</span><span class="s2">. If there're any </span><span class="s1">&quot;</span><span class="s2">capturing groups</span><span class="s1">&quot;</span><span class="s2">, then `national_prefix_for_parsing` is accompanied by `national_prefix_transform_rule`</span><span class="s1">: </span><span class="s2">yet another incorrect name by Google, because `national_prefix_transform_rule` is not a </span><span class="s1">&quot;</span><span class="s2">rule for transforming a national prefix</span><span class="s1">&quot;</span><span class="s2">, but rather a </span><span class="s1">&quot;</span><span class="s2">template to transform the captured groups into a national </span><span class="s1">(</span><span class="s2">significant</span><span class="s1">) </span><span class="s2">number</span><span class="s1">&quot;</span><span class="s2">.</span>

<span class="s2">There're different types of possible </span><span class="s1">&quot;</span><span class="s2">prefixes</span><span class="s1">&quot; </span><span class="s2">a phone number could have. One example are </span><span class="s1">[&quot;</span><span class="s2">carrier codes</span><span class="s1">&quot;](</span><span class="s3">https://www.bandwidth.com/glossary/carrier-identification-code-cic/</span><span class="s1">)</span><span class="s2">. If a `national_prefix_transform_rule` is defined and the `national_prefix_for_parsing` has more than one </span><span class="s1">&quot;</span><span class="s2">capturing group</span><span class="s1">&quot;</span><span class="s2">, then the second </span><span class="s1">&quot;</span><span class="s2">capturing group</span><span class="s1">&quot; </span><span class="s2">is a </span><span class="s1">&quot;</span><span class="s2">carrier code</span><span class="s1">&quot;</span><span class="s2">. If a `national_prefix_transform_rule` is not defined and the `national_prefix_for_parsing` has at least one </span><span class="s1">&quot;</span><span class="s2">capturing group</span><span class="s1">&quot;</span><span class="s2">, then the first </span><span class="s1">&quot;</span><span class="s2">capturing group</span><span class="s1">&quot; </span><span class="s2">is a </span><span class="s1">&quot;</span><span class="s2">carrier code</span><span class="s1">&quot;</span><span class="s2">.</span>

<span class="s2">For example, countries like Argentina and Brazil do use </span><span class="s1">[&quot;</span><span class="s2">carrier codes</span><span class="s1">&quot;](</span><span class="s3">https://www.bandwidth.com/glossary/carrier-identification-code-cic/</span><span class="s1">)</span><span class="s2">, and their `national_prefix_for_parsing` regular expressions include both national prefix and all possible </span><span class="s1">&quot;</span><span class="s2">carrier codes</span><span class="s1">&quot;</span><span class="s2">. So, for example, to dial the number `2222-2222` in Fortaleza, Brazil </span><span class="s1">(</span><span class="s2">national prefix `0`, area code `85`</span><span class="s1">) </span><span class="s2">using the long distance carrier Oi </span><span class="s1">(</span><span class="s2">selection code `31`</span><span class="s1">)</span><span class="s2">, one would dial `0 31 85 2222 2222`, and, for parsing such numbers, Brazil's `national_prefix_for_parsing` is `0</span><span class="s1">(</span><span class="s2">?</span><span class="s1">:(</span><span class="s2">1</span><span class="s1">[</span><span class="s2">245</span><span class="s1">]</span><span class="s2">|2</span><span class="s1">[</span><span class="s2">1-35</span><span class="s1">]</span><span class="s2">|31|4</span><span class="s1">[</span><span class="s2">13</span><span class="s1">]</span><span class="s2">|</span><span class="s1">[</span><span class="s2">56</span><span class="s1">]</span><span class="s2">5|99</span><span class="s1">)(</span><span class="s2">\d{10,11}</span><span class="s1">))</span><span class="s2">?`, which matches the whole `0318522222222` number with captured group #1 being `31` </span><span class="s1">(&quot;</span><span class="s2">carrier code</span><span class="s1">&quot;) </span><span class="s2">and captured group #2 being `8522222222` </span><span class="s1">(</span><span class="s2">which is also the actual national </span><span class="s1">(</span><span class="s2">significant</span><span class="s1">) </span><span class="s2">number, because `national_prefix_transform_rule` is `$2`</span><span class="s1">)</span><span class="s2">.</span>

<span class="s2">Another example of a </span><span class="s1">&quot;</span><span class="s2">prefix</span><span class="s1">&quot;: </span><span class="s2">some countries support </span><span class="s1">&quot;</span><span class="s2">utility</span><span class="s1">&quot; </span><span class="s2">prefixes, like Australia </span><span class="s1">(</span><span class="s2">national prefix `0`</span><span class="s1">) </span><span class="s2">that supports `1831` prefix to </span><span class="s1">[</span><span class="s2">hide your phone number</span><span class="s1">](</span><span class="s3">https://exchange.telstra.com.au/how-to-block-your-number-when-calling-someone/</span><span class="s1">) </span><span class="s2">when calling somebody </span><span class="s1">(</span><span class="s2">and `1832` to un-hide it when in </span><span class="s1">&quot;</span><span class="s2">permanent</span><span class="s1">&quot; </span><span class="s2">hiding mode</span><span class="s1">)</span><span class="s2">, and so Australia's `national_prefix_for_parsing` is `0|</span><span class="s1">(</span><span class="s2">183</span><span class="s1">[</span><span class="s2">12</span><span class="s1">])</span><span class="s2">`, which matches the `1831` prefix as group #1.</span>

<span class="s2">Another example of using a `national_prefix_for_parsing` / `national_prefix_transform_rule` pair, in this case for reasons completely unrelated to any </span><span class="s1">&quot;</span><span class="s2">prefixes</span><span class="s1">&quot;</span><span class="s2">, are U.S. Virgin Islands </span><span class="s1">(</span><span class="s2">national prefix `1`</span><span class="s1">) </span><span class="s2">whose phone numbers always start with a `340` area code because there's no other area code in this tiny </span><span class="s1">(</span><span class="s2">`346.36` square kilometers</span><span class="s1">) </span><span class="s2">island country. So it's common for its citizens to call `693-4800` instead of `</span><span class="s1">(</span><span class="s2">340</span><span class="s1">) </span><span class="s2">693-4800`, and Google's `libphonenumber` handles this case by `national_prefix_for_parsing` being `1|</span><span class="s1">([</span><span class="s2">2-9</span><span class="s1">]</span><span class="s2">\d{6}</span><span class="s1">)</span><span class="s2">$`, which matches `6934800` number as group #1, which is later used in `national_prefix_transform_rule`, which is `340$1`, meaning that it prepends `340` to the group #1 being the `6934800` number, resulting in `3406934800` national </span><span class="s1">(</span><span class="s2">significant</span><span class="s1">) </span><span class="s2">number.</span>

<span class="s2">If `national_prefix_for_parsing` matches any </span><span class="s1">&quot;</span><span class="s2">capturing groups</span><span class="s1">&quot;</span><span class="s2">, then it doesn't provide the actual national prefix being extracted, or even guarantee the fact that there is a national prefix</span><span class="s1">: </span><span class="s2">in those cases, it just converts a national number to a national </span><span class="s1">(</span><span class="s2">significant</span><span class="s1">) </span><span class="s2">number by applying a `national_prefix_for_parsing`/`national_prefix_transform_rule` transform to it.</span>

<span class="s2">For example, in `AG` country, phone numbers are same as in the `US`, with the only difference that they start with `268`. The `national_prefix_for_parsing` is `1|</span><span class="s1">([</span><span class="s2">457</span><span class="s1">]</span><span class="s2">\\d{6}</span><span class="s1">)</span><span class="s2">$`. If a number is entered with a leading `1` </span><span class="s1">(</span><span class="s2">`</span><span class="s1">&quot;</span><span class="s2">1 268 464 1234</span><span class="s1">&quot;</span><span class="s2">`</span><span class="s1">)</span><span class="s2">, then there're no </span><span class="s1">&quot;</span><span class="s2">capturing groups</span><span class="s1">&quot; </span><span class="s2">in that regular expression, so the national prefix is the entire substring matched by the regular expression</span><span class="s1">: </span><span class="s2">`</span><span class="s1">&quot;</span><span class="s2">1</span><span class="s1">&quot;</span><span class="s2">`. If a number is entered without a leading `1` </span><span class="s1">(</span><span class="s2">`</span><span class="s1">&quot;</span><span class="s2">268 464 1234</span><span class="s1">&quot;</span><span class="s2">`</span><span class="s1">)</span><span class="s2">, then the regular expression doesn't match, and the number doesn't have a national prefix </span><span class="s1">(</span><span class="s2">which is true</span><span class="s1">)</span><span class="s2">. If a number is entered without the </span><span class="s1">&quot;</span><span class="s2">area code</span><span class="s1">&quot; </span><span class="s2">`268` </span><span class="s1">(</span><span class="s2">just `</span><span class="s1">&quot;</span><span class="s2">464 1234</span><span class="s1">&quot;</span><span class="s2">`</span><span class="s1">)</span><span class="s2">, then `national_prefix_for_parsing` regular expression matches with the </span><span class="s1">&quot;</span><span class="s2">capturing group</span><span class="s1">&quot; </span><span class="s2">being `</span><span class="s1">&quot;</span><span class="s2">4641234</span><span class="s1">&quot;</span><span class="s2">`, and then `national_prefix_transform_rule` `268$1` transforms that </span><span class="s1">&quot;</span><span class="s2">capturing group</span><span class="s1">&quot; </span><span class="s2">into a `2684641234` national </span><span class="s1">(</span><span class="s2">significant</span><span class="s1">) </span><span class="s2">number; and even though `national_prefix_for_parsing` did match, the phone number didn't have any national prefix.</span>

<span class="s2">Another example is Mexico </span><span class="s1">(</span><span class="s2">`MX`</span><span class="s1">) </span><span class="s2">that has no `national_prefix_transform_rule` and has `national_prefix_for_parsing` `0</span><span class="s1">(</span><span class="s2">?</span><span class="s1">:[</span><span class="s2">12</span><span class="s1">]</span><span class="s2">|4</span><span class="s1">[</span><span class="s2">45</span><span class="s1">])</span><span class="s2">|1`</span><span class="s1">: </span><span class="s2">the `?</span><span class="s1">:</span><span class="s2">` defines a </span><span class="s1">&quot;</span><span class="s2">non-capturing group</span><span class="s1">&quot;</span><span class="s2">, so `national_prefix_for_parsing` has no </span><span class="s1">&quot;</span><span class="s2">capturing groups</span><span class="s1">&quot;</span><span class="s2">, and, therefore, matches the actual national prefix of a phone number; that national prefix isn't used anywhere though</span><span class="s1">: </span><span class="s2">it's simply discarded, because all `format`s of Mexico have `national_prefix_is_optional_when_formatting</span><span class="s1">: </span><span class="s2">true`, meaning that a national prefix isn't used when formatting a phone number using any of those `format`s.</span>

<span class="s2">If no `national_prefix_for_parsing` has been defined, but `national_prefix` has been defined, then `national_prefix_for_parsing` is equal to `national_prefix`.</span>

<span class="s2">Whatever national prefix has been extracted, it's not used anywhere</span><span class="s1">: </span><span class="s2">instead, `national_prefix_formatting_rule` of a `format` already has a national prefix </span><span class="s1">&quot;</span><span class="s2">hardcoded</span><span class="s1">&quot;</span><span class="s2">. For example, in Russia, `national_prefix` is `8`, and `national_prefix_formatting_rule` of all `format`s is `8 </span><span class="s1">(</span><span class="s2">$1</span><span class="s1">)</span><span class="s2">`. So the code doesn't store the extracted national prefix anywhere</span><span class="s1">: </span><span class="s2">only the fact that the national prefix has been extracted is used to decide whether to apply `national_prefix_formatting_rule` when formatting the parsed number.</span>

<span class="s0">### </span><span class="s2">`types`</span>

<span class="s2">Regular expressions for all possible phone number </span><span class="s1">[</span><span class="s2">types</span><span class="s1">](</span><span class="s3">https://gitlab.com/catamphetamine/libphonenumber-js#gettype-string</span><span class="s1">) </span><span class="s2">for this country</span><span class="s1">: </span><span class="s2">`fixed_line`, `mobile`, `toll_free`, `premium_rate`, etc.</span>

<span class="s0">#### </span><span class="s2">`type` `pattern`</span>

<span class="s2">A regular expression for a national </span><span class="s1">(</span><span class="s2">significant</span><span class="s1">) </span><span class="s2">number matching the type.</span>

<span class="s2">When multiple countries share the same </span><span class="s1">&quot;</span><span class="s2">country calling code</span><span class="s1">&quot;</span><span class="s2">, type patterns aren't guaranteed to be unique among them. For example, both `US` and `CA` have the </span><span class="s1">[</span><span class="s2">same</span><span class="s1">](</span><span class="s3">https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/103#note_1417147572</span><span class="s1">) </span><span class="s2">pattern for `toll_free` numbers.</span>

<span class="s0">#### </span><span class="s2">`type` `possible_lengths`</span>

<span class="s2">Possible lengths of a national </span><span class="s1">(</span><span class="s2">significant</span><span class="s1">) </span><span class="s2">number matching the type. Is always present.</span>

<span class="s0">### </span><span class="s2">`examples`</span>

<span class="s2">Phone number examples for each of the phone number `types`.</span>

<span class="s0">### </span><span class="s2">`possible_lengths`</span>

<span class="s2">Possible lengths of a national </span><span class="s1">(</span><span class="s2">significant</span><span class="s1">) </span><span class="s2">number for this numbering plan. This property is a combination of `possible_lengths` of all `types`. Is always present.</span>

<span class="s0">### </span><span class="s2">`formats`</span>

<span class="s2">Describes all possible phone number formats for this country. May be missing if phone numbers aren't formatted for this country </span><span class="s1">(</span><span class="s2">there're many such countries, usually small islands</span><span class="s1">)</span><span class="s2">.</span>

<span class="s0">#### </span><span class="s2">`format` `pattern`</span>

<span class="s2">A regular expression for a phone number supported by this format.</span>

<span class="s2">For example, in `US` there's only one possible phone number format, and it's `pattern` is `</span><span class="s1">(</span><span class="s2">\d{3}</span><span class="s1">)(</span><span class="s2">\d{3}</span><span class="s1">)(</span><span class="s2">\d{4}</span><span class="s1">)</span><span class="s2">`, meaning that the national </span><span class="s1">(</span><span class="s2">significant</span><span class="s1">) </span><span class="s2">number must be `3 + 3 + 4 = 10` digits long </span><span class="s1">(</span><span class="s2">for example, `2133734253`</span><span class="s1">)</span><span class="s2">, and is divided into three groups of digits for formatting </span><span class="s1">(</span><span class="s2">in this case, `213`, `373` and `4253`</span><span class="s1">)</span><span class="s2">.</span>

<span class="s0">#### </span><span class="s2">`format` `format`</span>

<span class="s2">Defines how the aforementioned groups of digits are combined when formatting a phone number.</span>

<span class="s2">For example, in `US` there's only one possible phone number format, and it's `format` is `</span><span class="s1">(</span><span class="s2">$1</span><span class="s1">) </span><span class="s2">$2-$3`, so `2133734253` national </span><span class="s1">(</span><span class="s2">significant</span><span class="s1">) </span><span class="s2">number is formatted as `</span><span class="s1">(</span><span class="s2">213</span><span class="s1">) </span><span class="s2">373-4253`.</span>

<span class="s0">#### </span><span class="s2">`format` `international_format`</span>

<span class="s2">Parentheses arond </span><span class="s1">&quot;</span><span class="s2">area code</span><span class="s1">&quot; </span><span class="s2">only make sense when formatting a national phone number, so international phone numbers don't use them, hence the explicit `international_format` in addition to the national `format`.</span>

<span class="s2">For example, in `US` there's only one possible phone number format, and it's `format` is `</span><span class="s1">(</span><span class="s2">$1</span><span class="s1">) </span><span class="s2">$2-$3`, while its `international_format` is `$1-$2-$3`, meaning that `2133734253` national </span><span class="s1">(</span><span class="s2">significant</span><span class="s1">) </span><span class="s2">number is formatted as `+1 213 373-4253` when formatted for international dialing.</span>

<span class="s0">#### </span><span class="s2">`format` `national_prefix_formatting_rule`</span>

<span class="s2">`national_prefix_formatting_rule` is sometimes used to define how national prefix changes how a phone number should be formatted. For example, in Russia </span><span class="s1">(</span><span class="s2">national prefix `8`</span><span class="s1">)</span><span class="s2">, all `format`s have `national_prefix_formatting_rule` `8 </span><span class="s1">(</span><span class="s2">$1</span><span class="s1">)</span><span class="s2">`, meaning that a `88005553535` phone number is first stripped of `8` national prefix into a `8005553535` national </span><span class="s1">(</span><span class="s2">significant</span><span class="s1">) </span><span class="s2">number, then the national </span><span class="s1">(</span><span class="s2">significant</span><span class="s1">) </span><span class="s2">number is first parsed using `format.pattern` `</span><span class="s1">(</span><span class="s2">\d{3}</span><span class="s1">)(</span><span class="s2">\d{3}</span><span class="s1">)(</span><span class="s2">\d{2}</span><span class="s1">)(</span><span class="s2">\d{2}</span><span class="s1">)</span><span class="s2">` and then formatted using `format.format` `$1 $2-$3-$4` while also replacing `$1` in that `format.format` with `format.national_prefix_formatting_rule` which is `8 </span><span class="s1">(</span><span class="s2">$1</span><span class="s1">)</span><span class="s2">`, so the resulting `format.format` becomes `8 </span><span class="s1">(</span><span class="s2">$1</span><span class="s1">) </span><span class="s2">$2-$3-$4`, and so the formatted number is `8 </span><span class="s1">(</span><span class="s2">800</span><span class="s1">) </span><span class="s2">555-35-35`. Have the phone number been input without the `8` national prefix, the `national_prefix_formatting_rule` wouldn't be applied, and `format.format` would stay `$1 $2-$3-$4`, and the formatted phone number would be `800 555-35-35`.</span>

<span class="s2">In some cases </span><span class="s1">(</span><span class="s2">for example, in Argentina</span><span class="s1">)</span><span class="s2">, `format.format` may exclude `$1`, so in those cases `national_prefix_formatting_rule` being `0$1` would actually mean `0$2`, because there's no `$1` </span><span class="s1">&quot;</span><span class="s2">capturing group</span><span class="s1">&quot; </span><span class="s2">in `format.format`, but there is `$2` </span><span class="s1">&quot;</span><span class="s2">capturing group</span><span class="s1">&quot; </span><span class="s2">there.</span>

<span class="s0">#### </span><span class="s2">`format` `national_prefix_is_optional_when_formatting`</span>

<span class="s2">This field specifies whether the national prefix can be omitted when formatting a number in national format. For example, a UK </span><span class="s1">(</span><span class="s2">`GB`</span><span class="s1">) </span><span class="s2">number would be formatted by `libphonenumber` as `020 XXXX XXXX`. Have they seen this number commonly being written without the leading `0` </span><span class="s1">(</span><span class="s2">like `</span><span class="s1">(</span><span class="s2">20</span><span class="s1">) </span><span class="s2">XXXX XXXX`</span><span class="s1">)</span><span class="s2">, they would have updated the metadata with `national_prefix_is_optional_when_formatting` being `true` for that `format`, so that such number, when formatted, wouldn't have `national_prefix_formatting_rule` applied to it. Otherwise, if `national_prefix_is_optional_when_formatting` is not set to `true`, `national_prefix_formatting_rule` is always applied </span><span class="s1">(</span><span class="s2">when present</span><span class="s1">)</span><span class="s2">.</span>

<span class="s0">#### </span><span class="s2">`format` `domestic_carrier_code_formatting_rule`</span>

<span class="s2">Specifies how a carrier code </span><span class="s1">(</span><span class="s2">`$CC`</span><span class="s1">) </span><span class="s2">together with the first group </span><span class="s1">(</span><span class="s2">`$FG`</span><span class="s1">) </span><span class="s2">in a national significant number should be formatted, if carrier codes are used when formatting the number for dialing. For example, if a `format`</span><span class="s1">'</span><span class="s2">s `format` is `$1 $2-$3` and `domestic_carrier_code_formatting_rule` is `$NP $CC </span><span class="s1">(</span><span class="s2">$FG</span><span class="s1">)</span><span class="s2">`, then a national number, when having a carrier code, is formatted as `national-prefix carrier-code </span><span class="s1">(</span><span class="s2">$1</span><span class="s1">) </span><span class="s2">$2-$3`.</span>

<span class="s2">For example, Google's `libphonenumber` has `formatNumberForMobileDialing</span><span class="s1">()</span><span class="s2">` function that returns a number formatted in such a way that it can be dialed from a mobile phone within a specific country, and it adds </span><span class="s1">[&quot;</span><span class="s2">carrier codes</span><span class="s1">&quot;](</span><span class="s3">https://www.bandwidth.com/glossary/carrier-identification-code-cic/</span><span class="s1">) </span><span class="s2">when dialing within certain countries </span><span class="s1">(</span><span class="s2">Brazil — when dialing from a mobile phone to any number, Colombia — when dialing from a mobile phone to a fixed line number</span><span class="s1">)</span><span class="s2">. Since `libphonenumber-js` is not a dialing library, it doesn't provide such a function and doesn</span><span class="s1">'</span><span class="s2">t use </span><span class="s1">&quot;</span><span class="s2">carrier codes</span><span class="s1">&quot; </span><span class="s2">when formatting phone numbers, so this property is ignored in this library.</span>

<span class="s0">#### </span><span class="s2">`format` `leading_digits_patterns`</span>

<span class="s1">&quot;</span><span class="s2">Leading digits</span><span class="s1">&quot; </span><span class="s2">patterns are used in `AsYouType` formatter to choose a format suitable for the phone number being input</span><span class="s1">: </span><span class="s2">if a phone number's </span><span class="s1">&quot;</span><span class="s2">leading digits</span><span class="s1">&quot; </span><span class="s2">match those of a format, then that format is used to format the phone number being input. Each subsequent leading digits pattern in `leading_digits_patterns` array requires one more leading digit.</span>

<span class="s0">## </span><span class="s2">Non-geographic</span>

<span class="s2">There're </span><span class="s1">[</span><span class="s2">calling codes</span><span class="s1">](</span><span class="s3">https://gitlab.com/catamphetamine/libphonenumber-js#non-geographic</span><span class="s1">) </span><span class="s2">that don't correspond to any country. For example, </span><span class="s1">&quot;</span><span class="s2">Global Mobile Satellite System</span><span class="s1">&quot; (</span><span class="s2">`+881`</span><span class="s1">)</span><span class="s2">. Such phone numbering systems are called </span><span class="s1">&quot;</span><span class="s2">non-geographic entities</span><span class="s1">&quot; </span><span class="s2">in Google's code. These </span><span class="s1">&quot;</span><span class="s2">non-geographic entitites</span><span class="s1">&quot; </span><span class="s2">reside in their own `nonGeographic` property, analogous to the `countries` property. `nonGeographic` is an object with keys being calling codes of the corresponding </span><span class="s1">&quot;</span><span class="s2">non-geographic entities</span><span class="s1">&quot;</span><span class="s2">, and values being same as the values of the `countries` property.</span>

<span class="s1">&quot;</span><span class="s2">Non-geographic</span><span class="s1">&quot; </span><span class="s2">numbering plans don't have </span><span class="s1">[</span><span class="s2">`possible_lengths`</span><span class="s1">](</span><span class="s2">#possible-lengths</span><span class="s1">)</span><span class="s2">.</span></pre>
</body>
</html>