<html>
<head>
<title>lib.d.mts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
lib.d.mts</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">{ S as SourceLocation, U as UserConfig, P as Plugin } from </span><span class="s2">'./types-WlZgYgM8.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ V as Variant, C as Candidate } from </span><span class="s2">'./resolve-config-QUZ9b-Gn.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s2">'./colors.mjs'</span><span class="s1">;</span>

<span class="s1">declare </span><span class="s0">const enum </span><span class="s1">ThemeOptions {</span>
    <span class="s1">NONE = </span><span class="s3">0</span><span class="s1">,</span>
    <span class="s1">INLINE = </span><span class="s3">1</span><span class="s1">,</span>
    <span class="s1">REFERENCE = </span><span class="s3">2</span><span class="s1">,</span>
    <span class="s1">DEFAULT = </span><span class="s3">4</span><span class="s1">,</span>
    <span class="s1">STATIC = </span><span class="s3">8</span><span class="s1">,</span>
    <span class="s1">USED = </span><span class="s3">16</span>
<span class="s1">}</span>
<span class="s1">declare </span><span class="s0">class </span><span class="s1">Theme {</span>
    <span class="s1">#private;</span>
    <span class="s0">private </span><span class="s1">values;</span>
    <span class="s0">private </span><span class="s1">keyframes;</span>
    <span class="s1">prefix: string | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">constructor(values?: Map&lt;string, {</span>
        <span class="s1">value: string;</span>
        <span class="s1">options: ThemeOptions;</span>
        <span class="s1">src: Declaration[</span><span class="s2">&quot;src&quot;</span><span class="s1">];</span>
    <span class="s1">}&gt;, keyframes?: Set&lt;AtRule&gt;);</span>
    <span class="s1">get size(): number;</span>
    <span class="s1">add(key: string, value: string, options?: ThemeOptions, src?: Declaration[</span><span class="s2">'src'</span><span class="s1">]): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">keysInNamespaces(themeKeys: Iterable&lt;ThemeKey&gt;): string[];</span>
    <span class="s1">get(themeKeys: ThemeKey[]): string | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">hasDefault(key: string): boolean;</span>
    <span class="s1">getOptions(key: string): ThemeOptions;</span>
    <span class="s1">entries(): IterableIterator&lt;[string, {</span>
        <span class="s1">value: string;</span>
        <span class="s1">options: ThemeOptions;</span>
        <span class="s1">src: Declaration[</span><span class="s2">&quot;src&quot;</span><span class="s1">];</span>
    <span class="s1">}]&gt; | [string, {</span>
        <span class="s1">value: string;</span>
        <span class="s1">options: ThemeOptions;</span>
        <span class="s1">src: Declaration[</span><span class="s2">&quot;src&quot;</span><span class="s1">];</span>
    <span class="s1">}][];</span>
    <span class="s1">prefixKey(key: string): string;</span>
    <span class="s1">clearNamespace(namespace: string, clearOptions: ThemeOptions): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">markUsedVariable(themeKey: string): boolean;</span>
    <span class="s1">resolve(candidateValue: string | </span><span class="s0">null</span><span class="s1">, themeKeys: ThemeKey[], options?: ThemeOptions): string | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">resolveValue(candidateValue: string | </span><span class="s0">null</span><span class="s1">, themeKeys: ThemeKey[]): string | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">resolveWith(candidateValue: string, themeKeys: ThemeKey[], nestedKeys?: </span><span class="s2">`--</span><span class="s1">${string}</span><span class="s2">`</span><span class="s1">[]): [string, Record&lt;string, string&gt;] | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">namespace(namespace: string): Map&lt;string | </span><span class="s0">null</span><span class="s1">, string&gt;;</span>
    <span class="s1">addKeyframes(value: AtRule): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">getKeyframes(): AtRule[];</span>
<span class="s1">}</span>
<span class="s1">type ThemeKey = </span><span class="s2">`--</span><span class="s1">${string}</span><span class="s2">`</span><span class="s1">;</span>

<span class="s1">type VariantFn&lt;T </span><span class="s0">extends </span><span class="s1">Variant[</span><span class="s2">'kind'</span><span class="s1">]&gt; = (rule: Rule, variant: Extract&lt;Variant, {</span>
    <span class="s1">kind: T;</span>
<span class="s1">}&gt;) =&gt; </span><span class="s0">null </span><span class="s1">| </span><span class="s0">void</span><span class="s1">;</span>
<span class="s1">type CompareFn = (a: Variant, z: Variant) =&gt; number;</span>
<span class="s1">declare </span><span class="s0">const enum </span><span class="s1">Compounds {</span>
    <span class="s1">Never = </span><span class="s3">0</span><span class="s1">,</span>
    <span class="s1">AtRules = </span><span class="s3">1</span><span class="s1">,</span>
    <span class="s1">StyleRules = </span><span class="s3">2</span>
<span class="s1">}</span>
<span class="s1">declare </span><span class="s0">class </span><span class="s1">Variants {</span>
    <span class="s1">compareFns: Map&lt;number, CompareFn&gt;;</span>
    <span class="s1">variants: Map&lt;string, {</span>
        <span class="s1">kind: Variant[</span><span class="s2">&quot;kind&quot;</span><span class="s1">];</span>
        <span class="s1">order: number;</span>
        <span class="s1">applyFn: VariantFn&lt;any&gt;;</span>
        <span class="s1">compoundsWith: Compounds;</span>
        <span class="s1">compounds: Compounds;</span>
    <span class="s1">}&gt;;</span>
    <span class="s0">private </span><span class="s1">completions;</span>
    <span class="s4">/**</span>
     <span class="s4">* Registering a group of variants should result in the same sort number for</span>
     <span class="s4">* all the variants. This is to ensure that the variants are applied in the</span>
     <span class="s4">* correct order.</span>
     <span class="s4">*/</span>
    <span class="s0">private </span><span class="s1">groupOrder;</span>
    <span class="s4">/**</span>
     <span class="s4">* Keep track of the last sort order instead of using the size of the map to</span>
     <span class="s4">* avoid unnecessarily skipping order numbers.</span>
     <span class="s4">*/</span>
    <span class="s0">private </span><span class="s1">lastOrder;</span>
    <span class="s0">static</span><span class="s1">(name: string, applyFn: VariantFn&lt;</span><span class="s2">'static'</span><span class="s1">&gt;, { compounds, order }?: {</span>
        <span class="s1">compounds?: Compounds;</span>
        <span class="s1">order?: number;</span>
    <span class="s1">}): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">fromAst(name: string, ast: AstNode[], designSystem: DesignSystem): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">functional(name: string, applyFn: VariantFn&lt;</span><span class="s2">'functional'</span><span class="s1">&gt;, { compounds, order }?: {</span>
        <span class="s1">compounds?: Compounds;</span>
        <span class="s1">order?: number;</span>
    <span class="s1">}): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">compound(name: string, compoundsWith: Compounds, applyFn: VariantFn&lt;</span><span class="s2">'compound'</span><span class="s1">&gt;, { compounds, order }?: {</span>
        <span class="s1">compounds?: Compounds;</span>
        <span class="s1">order?: number;</span>
    <span class="s1">}): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">group(fn: () =&gt; </span><span class="s0">void</span><span class="s1">, compareFn?: CompareFn): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">has(name: string): boolean;</span>
    <span class="s1">get(name: string): {</span>
        <span class="s1">kind: Variant[</span><span class="s2">&quot;kind&quot;</span><span class="s1">];</span>
        <span class="s1">order: number;</span>
        <span class="s1">applyFn: VariantFn&lt;any&gt;;</span>
        <span class="s1">compoundsWith: Compounds;</span>
        <span class="s1">compounds: Compounds;</span>
    <span class="s1">} | undefined;</span>
    <span class="s1">kind(name: string): </span><span class="s2">&quot;arbitrary&quot; </span><span class="s1">| </span><span class="s2">&quot;static&quot; </span><span class="s1">| </span><span class="s2">&quot;functional&quot; </span><span class="s1">| </span><span class="s2">&quot;compound&quot;</span><span class="s1">;</span>
    <span class="s1">compoundsWith(parent: string, child: string | Variant): boolean;</span>
    <span class="s1">suggest(name: string, suggestions: () =&gt; string[]): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">getCompletions(name: string): string[];</span>
    <span class="s1">compare(a: Variant | </span><span class="s0">null</span><span class="s1">, z: Variant | </span><span class="s0">null</span><span class="s1">): number;</span>
    <span class="s1">keys(): IterableIterator&lt;string&gt;;</span>
    <span class="s1">entries(): IterableIterator&lt;[string, {</span>
        <span class="s1">kind: Variant[</span><span class="s2">&quot;kind&quot;</span><span class="s1">];</span>
        <span class="s1">order: number;</span>
        <span class="s1">applyFn: VariantFn&lt;any&gt;;</span>
        <span class="s1">compoundsWith: Compounds;</span>
        <span class="s1">compounds: Compounds;</span>
    <span class="s1">}]&gt;;</span>
    <span class="s0">private </span><span class="s1">set;</span>
    <span class="s0">private </span><span class="s1">nextOrder;</span>
<span class="s1">}</span>

<span class="s1">declare </span><span class="s0">function </span><span class="s1">compileAstNodes(candidate: Candidate, designSystem: DesignSystem, flags: CompileAstFlags): {</span>
    <span class="s1">node: AstNode;</span>
    <span class="s1">propertySort: {</span>
        <span class="s1">order: number[];</span>
        <span class="s1">count: number;</span>
    <span class="s1">};</span>
<span class="s1">}[];</span>

<span class="s0">interface </span><span class="s1">ClassMetadata {</span>
    <span class="s1">modifiers: string[];</span>
<span class="s1">}</span>
<span class="s1">type ClassEntry = [string, ClassMetadata];</span>
<span class="s0">interface </span><span class="s1">SelectorOptions {</span>
    <span class="s1">modifier?: string;</span>
    <span class="s1">value?: string;</span>
<span class="s1">}</span>
<span class="s0">interface </span><span class="s1">VariantEntry {</span>
    <span class="s1">name: string;</span>
    <span class="s1">isArbitrary: boolean;</span>
    <span class="s1">values: string[];</span>
    <span class="s1">hasDash: boolean;</span>
    <span class="s1">selectors: (options: SelectorOptions) =&gt; string[];</span>
<span class="s1">}</span>

<span class="s1">type CompileFn&lt;T </span><span class="s0">extends </span><span class="s1">Candidate[</span><span class="s2">'kind'</span><span class="s1">]&gt; = (value: Extract&lt;Candidate, {</span>
    <span class="s1">kind: T;</span>
<span class="s1">}&gt;) =&gt; AstNode[] | undefined | </span><span class="s0">null</span><span class="s1">;</span>
<span class="s0">interface </span><span class="s1">SuggestionGroup {</span>
    <span class="s1">supportsNegative?: boolean;</span>
    <span class="s1">values: (string | </span><span class="s0">null</span><span class="s1">)[];</span>
    <span class="s1">modifiers: string[];</span>
<span class="s1">}</span>
<span class="s1">type UtilityOptions = {</span>
    <span class="s1">types: string[];</span>
<span class="s1">};</span>
<span class="s1">type Utility = {</span>
    <span class="s1">kind: </span><span class="s2">'static' </span><span class="s1">| </span><span class="s2">'functional'</span><span class="s1">;</span>
    <span class="s1">compileFn: CompileFn&lt;any&gt;;</span>
    <span class="s1">options?: UtilityOptions;</span>
<span class="s1">};</span>
<span class="s1">declare </span><span class="s0">class </span><span class="s1">Utilities {</span>
    <span class="s0">private </span><span class="s1">utilities;</span>
    <span class="s0">private </span><span class="s1">completions;</span>
    <span class="s0">static</span><span class="s1">(name: string, compileFn: CompileFn&lt;</span><span class="s2">'static'</span><span class="s1">&gt;): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">functional(name: string, compileFn: CompileFn&lt;</span><span class="s2">'functional'</span><span class="s1">&gt;, options?: UtilityOptions): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">has(name: string, kind: </span><span class="s2">'static' </span><span class="s1">| </span><span class="s2">'functional'</span><span class="s1">): boolean;</span>
    <span class="s1">get(name: string): Utility[];</span>
    <span class="s1">getCompletions(name: string): SuggestionGroup[];</span>
    <span class="s1">suggest(name: string, groups: () =&gt; SuggestionGroup[]): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">keys(kind: </span><span class="s2">'static' </span><span class="s1">| </span><span class="s2">'functional'</span><span class="s1">): string[];</span>
<span class="s1">}</span>

<span class="s1">declare </span><span class="s0">const enum </span><span class="s1">CompileAstFlags {</span>
    <span class="s1">None = </span><span class="s3">0</span><span class="s1">,</span>
    <span class="s1">RespectImportant = </span><span class="s3">1</span>
<span class="s1">}</span>
<span class="s1">type DesignSystem = {</span>
    <span class="s1">theme: Theme;</span>
    <span class="s1">utilities: Utilities;</span>
    <span class="s1">variants: Variants;</span>
    <span class="s1">invalidCandidates: Set&lt;string&gt;;</span>
    <span class="s1">important: boolean;</span>
    <span class="s1">getClassOrder(classes: string[]): [string, bigint | </span><span class="s0">null</span><span class="s1">][];</span>
    <span class="s1">getClassList(): ClassEntry[];</span>
    <span class="s1">getVariants(): VariantEntry[];</span>
    <span class="s1">parseCandidate(candidate: string): Readonly&lt;Candidate&gt;[];</span>
    <span class="s1">parseVariant(variant: string): Readonly&lt;Variant&gt; | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">compileAstNodes(candidate: Candidate, flags?: CompileAstFlags): ReturnType&lt;</span><span class="s0">typeof </span><span class="s1">compileAstNodes&gt;;</span>
    <span class="s1">printCandidate(candidate: Candidate): string;</span>
    <span class="s1">printVariant(variant: Variant): string;</span>
    <span class="s1">getVariantOrder(): Map&lt;Variant, number&gt;;</span>
    <span class="s1">resolveThemeValue(path: string, forceInline?: boolean): string | undefined;</span>
    <span class="s1">trackUsedVariables(raw: string): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">candidatesToCss(classes: string[]): (string | </span><span class="s0">null</span><span class="s1">)[];</span>
<span class="s1">};</span>

<span class="s1">type StyleRule = {</span>
    <span class="s1">kind: </span><span class="s2">'rule'</span><span class="s1">;</span>
    <span class="s1">selector: string;</span>
    <span class="s1">nodes: AstNode[];</span>
    <span class="s1">src?: SourceLocation;</span>
    <span class="s1">dst?: SourceLocation;</span>
<span class="s1">};</span>
<span class="s1">type AtRule = {</span>
    <span class="s1">kind: </span><span class="s2">'at-rule'</span><span class="s1">;</span>
    <span class="s1">name: string;</span>
    <span class="s1">params: string;</span>
    <span class="s1">nodes: AstNode[];</span>
    <span class="s1">src?: SourceLocation;</span>
    <span class="s1">dst?: SourceLocation;</span>
<span class="s1">};</span>
<span class="s1">type Declaration = {</span>
    <span class="s1">kind: </span><span class="s2">'declaration'</span><span class="s1">;</span>
    <span class="s1">property: string;</span>
    <span class="s1">value: string | undefined;</span>
    <span class="s1">important: boolean;</span>
    <span class="s1">src?: SourceLocation;</span>
    <span class="s1">dst?: SourceLocation;</span>
<span class="s1">};</span>
<span class="s1">type Comment = {</span>
    <span class="s1">kind: </span><span class="s2">'comment'</span><span class="s1">;</span>
    <span class="s1">value: string;</span>
    <span class="s1">src?: SourceLocation;</span>
    <span class="s1">dst?: SourceLocation;</span>
<span class="s1">};</span>
<span class="s1">type Context = {</span>
    <span class="s1">kind: </span><span class="s2">'context'</span><span class="s1">;</span>
    <span class="s1">context: Record&lt;string, string | boolean&gt;;</span>
    <span class="s1">nodes: AstNode[];</span>
    <span class="s1">src?: undefined;</span>
    <span class="s1">dst?: undefined;</span>
<span class="s1">};</span>
<span class="s1">type AtRoot = {</span>
    <span class="s1">kind: </span><span class="s2">'at-root'</span><span class="s1">;</span>
    <span class="s1">nodes: AstNode[];</span>
    <span class="s1">src?: undefined;</span>
    <span class="s1">dst?: undefined;</span>
<span class="s1">};</span>
<span class="s1">type Rule = StyleRule | AtRule;</span>
<span class="s1">type AstNode = StyleRule | AtRule | Declaration | Comment | Context | AtRoot;</span>

<span class="s4">/**</span>
 <span class="s4">* Line offset tables are the key to generating our source maps. They allow us</span>
 <span class="s4">* to store indexes with our AST nodes and later convert them into positions as</span>
 <span class="s4">* when given the source that the indexes refer to.</span>
 <span class="s4">*/</span>
<span class="s4">/**</span>
 <span class="s4">* A position in source code</span>
 <span class="s4">*</span>
 <span class="s4">* https://tc39.es/ecma426/#sec-position-record-type</span>
 <span class="s4">*/</span>
<span class="s0">interface </span><span class="s1">Position {</span>
    <span class="s4">/** The line number, one-based */</span>
    <span class="s1">line: number;</span>
    <span class="s4">/** The column/character number, one-based */</span>
    <span class="s1">column: number;</span>
<span class="s1">}</span>

<span class="s0">interface </span><span class="s1">OriginalPosition </span><span class="s0">extends </span><span class="s1">Position {</span>
    <span class="s1">source: DecodedSource;</span>
<span class="s1">}</span>
<span class="s4">/**</span>
 <span class="s4">* A &quot;decoded&quot; sourcemap</span>
 <span class="s4">*</span>
 <span class="s4">* </span><span class="s5">@see </span><span class="s4">https://tc39.es/ecma426/#decoded-source-map-record</span>
 <span class="s4">*/</span>
<span class="s0">interface </span><span class="s1">DecodedSourceMap {</span>
    <span class="s1">file: string | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">sources: DecodedSource[];</span>
    <span class="s1">mappings: DecodedMapping[];</span>
<span class="s1">}</span>
<span class="s4">/**</span>
 <span class="s4">* A &quot;decoded&quot; source</span>
 <span class="s4">*</span>
 <span class="s4">* </span><span class="s5">@see </span><span class="s4">https://tc39.es/ecma426/#decoded-source-record</span>
 <span class="s4">*/</span>
<span class="s0">interface </span><span class="s1">DecodedSource {</span>
    <span class="s1">url: string | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">content: string | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">ignore: boolean;</span>
<span class="s1">}</span>
<span class="s4">/**</span>
 <span class="s4">* A &quot;decoded&quot; mapping</span>
 <span class="s4">*</span>
 <span class="s4">* </span><span class="s5">@see </span><span class="s4">https://tc39.es/ecma426/#decoded-mapping-record</span>
 <span class="s4">*/</span>
<span class="s0">interface </span><span class="s1">DecodedMapping {</span>
    <span class="s1">originalPosition: OriginalPosition | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">generatedPosition: Position;</span>
    <span class="s1">name: string | </span><span class="s0">null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s1">type Config = UserConfig;</span>
<span class="s1">declare </span><span class="s0">const enum </span><span class="s1">Polyfills {</span>
    <span class="s1">None = </span><span class="s3">0</span><span class="s1">,</span>
    <span class="s1">AtProperty = </span><span class="s3">1</span><span class="s1">,</span>
    <span class="s1">ColorMix = </span><span class="s3">2</span><span class="s1">,</span>
    <span class="s1">All = </span><span class="s3">3</span>
<span class="s1">}</span>
<span class="s1">type CompileOptions = {</span>
    <span class="s1">base?: string;</span>
    <span class="s1">from?: string;</span>
    <span class="s1">polyfills?: Polyfills;</span>
    <span class="s1">loadModule?: (id: string, base: string, resourceHint: </span><span class="s2">'plugin' </span><span class="s1">| </span><span class="s2">'config'</span><span class="s1">) =&gt; Promise&lt;{</span>
        <span class="s1">path: string;</span>
        <span class="s1">base: string;</span>
        <span class="s1">module: Plugin | Config;</span>
    <span class="s1">}&gt;;</span>
    <span class="s1">loadStylesheet?: (id: string, base: string) =&gt; Promise&lt;{</span>
        <span class="s1">path: string;</span>
        <span class="s1">base: string;</span>
        <span class="s1">content: string;</span>
    <span class="s1">}&gt;;</span>
<span class="s1">};</span>
<span class="s1">type Root = </span><span class="s0">null </span><span class="s1">| </span><span class="s2">'none' </span><span class="s1">| {</span>
    <span class="s1">base: string;</span>
    <span class="s1">pattern: string;</span>
<span class="s1">};</span>
<span class="s1">declare </span><span class="s0">const enum </span><span class="s1">Features {</span>
    <span class="s1">None = </span><span class="s3">0</span><span class="s1">,</span>
    <span class="s1">AtApply = </span><span class="s3">1</span><span class="s1">,</span>
    <span class="s1">AtImport = </span><span class="s3">2</span><span class="s1">,</span>
    <span class="s1">JsPluginCompat = </span><span class="s3">4</span><span class="s1">,</span>
    <span class="s1">ThemeFunction = </span><span class="s3">8</span><span class="s1">,</span>
    <span class="s1">Utilities = </span><span class="s3">16</span><span class="s1">,</span>
    <span class="s1">Variants = </span><span class="s3">32</span><span class="s1">,</span>
    <span class="s1">AtTheme = </span><span class="s3">64</span>
<span class="s1">}</span>
<span class="s1">declare </span><span class="s0">function </span><span class="s1">compileAst(input: AstNode[], opts?: CompileOptions): Promise&lt;{</span>
    <span class="s1">sources: {</span>
        <span class="s1">base: string;</span>
        <span class="s1">pattern: string;</span>
        <span class="s1">negated: boolean;</span>
    <span class="s1">}[];</span>
    <span class="s1">root: Root;</span>
    <span class="s1">features: Features;</span>
    <span class="s1">build(candidates: string[]): AstNode[];</span>
<span class="s1">}&gt;;</span>

<span class="s1">declare </span><span class="s0">function </span><span class="s1">compile(css: string, opts?: CompileOptions): Promise&lt;{</span>
    <span class="s1">sources: {</span>
        <span class="s1">base: string;</span>
        <span class="s1">pattern: string;</span>
        <span class="s1">negated: boolean;</span>
    <span class="s1">}[];</span>
    <span class="s1">root: Root;</span>
    <span class="s1">features: Features;</span>
    <span class="s1">build(candidates: string[]): string;</span>
    <span class="s1">buildSourceMap(): DecodedSourceMap;</span>
<span class="s1">}&gt;;</span>
<span class="s1">declare </span><span class="s0">function </span><span class="s1">__unstable__loadDesignSystem(css: string, opts?: CompileOptions): Promise&lt;DesignSystem&gt;;</span>
<span class="s1">declare </span><span class="s0">function </span><span class="s1">postcssPluginWarning(): </span><span class="s0">void</span><span class="s1">;</span>

<span class="s0">export </span><span class="s1">{ type Config, type DecodedSourceMap, Features, Polyfills, __unstable__loadDesignSystem, compile, compileAst, postcssPluginWarning as </span><span class="s0">default </span><span class="s1">};</span>
</pre>
</body>
</html>