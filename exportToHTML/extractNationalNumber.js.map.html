<html>
<head>
<title>extractNationalNumber.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
extractNationalNumber.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;extractNationalNumber.js&quot;</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_extractNationalNumberFromPossiblyIncompleteNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;_interopRequireDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_matchesEntirely&quot;</span><span class="s0">,</span><span class="s1">&quot;_checkNumberLength&quot;</span><span class="s0">,</span><span class="s1">&quot;_getCountryByCallingCode&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;__esModule&quot;</span><span class="s0">,</span><span class="s1">&quot;extractNationalNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;number&quot;</span><span class="s0">,</span><span class="s1">&quot;country&quot;</span><span class="s0">,</span><span class="s1">&quot;metadata&quot;</span><span class="s0">,</span><span class="s1">&quot;_extractNationalNumbe&quot;</span><span class="s0">,</span><span class="s1">&quot;extractNationalNumberFromPossiblyIncompleteNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;carrierCode&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldHaveExtractedNationalPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;numberingPlan&quot;</span><span class="s0">,</span><span class="s1">&quot;possibleLengths&quot;</span><span class="s0">,</span><span class="s1">&quot;getCountryByCallingCode&quot;</span><span class="s0">,</span><span class="s1">&quot;callingCode&quot;</span><span class="s0">,</span><span class="s1">&quot;isPossibleIncompleteNationalNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalNumberBefore&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalNumberAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;matchesEntirely&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalNumberPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;checkNumberLength&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../source/helpers/extractNationalNumber.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import extractNationalNumberFromPossiblyIncompleteNumber from './extractNationalNumberFromPossiblyIncompleteNumber.js'</span><span class="s3">\r\n</span><span class="s1">import matchesEntirely from './matchesEntirely.js'</span><span class="s3">\r\n</span><span class="s1">import checkNumberLength from './checkNumberLength.js'</span><span class="s3">\r\n</span><span class="s1">import getCountryByCallingCode from './getCountryByCallingCode.js'</span><span class="s3">\r\n\r\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* Strips national prefix and carrier code from a complete phone number.</span><span class="s3">\r\n </span><span class="s1">* The difference from the non-</span><span class="s3">\&quot;</span><span class="s1">FromCompleteNumber</span><span class="s3">\&quot; </span><span class="s1">function is that</span><span class="s3">\r\n </span><span class="s1">* it won't extract national prefix if the resultant number is too short</span><span class="s3">\r\n </span><span class="s1">* to be a complete number for the selected phone numbering plan.</span><span class="s3">\r\n </span><span class="s1">* @param  {string} number — Complete phone number digits.</span><span class="s3">\r\n </span><span class="s1">* @param  {string?} country — Country, if known.</span><span class="s3">\r\n </span><span class="s1">* @param  {Metadata} metadata — Metadata with a phone numbering plan selected.</span><span class="s3">\r\n </span><span class="s1">* @return {object} `{ nationalNumber: string, carrierCode: string? }`.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\r\n</span><span class="s1">export default function extractNationalNumber(number, country, metadata) {</span><span class="s3">\r\n\t</span><span class="s1">// Parsing national prefixes and carrier codes</span><span class="s3">\r\n\t</span><span class="s1">// is only required for local phone numbers</span><span class="s3">\r\n\t</span><span class="s1">// but some people don't understand that</span><span class="s3">\r\n\t</span><span class="s1">// and sometimes write international phone numbers</span><span class="s3">\r\n\t</span><span class="s1">// with national prefixes (or maybe even carrier codes).</span><span class="s3">\r\n\t</span><span class="s1">// http://ucken.blogspot.ru/2016/03/trunk-prefixes-in-skype4b.html</span><span class="s3">\r\n\t</span><span class="s1">// Google's original library forgives such mistakes</span><span class="s3">\r\n\t</span><span class="s1">// and so does this library, because it has been requested:</span><span class="s3">\r\n\t</span><span class="s1">// https://github.com/catamphetamine/libphonenumber-js/issues/127</span><span class="s3">\r\n\t</span><span class="s1">const {</span><span class="s3">\r\n\t\t</span><span class="s1">carrierCode,</span><span class="s3">\r\n\t\t</span><span class="s1">nationalNumber</span><span class="s3">\r\n\t</span><span class="s1">} = extractNationalNumberFromPossiblyIncompleteNumber(</span><span class="s3">\r\n\t\t</span><span class="s1">number,</span><span class="s3">\r\n\t\t</span><span class="s1">metadata</span><span class="s3">\r\n\t</span><span class="s1">)</span><span class="s3">\r\n\r\n\t</span><span class="s1">if (nationalNumber !== number) {</span><span class="s3">\r\n\t\t</span><span class="s1">if (!shouldHaveExtractedNationalPrefix(number, nationalNumber, metadata)) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">// Don't strip the national prefix.</span><span class="s3">\r\n\t\t\t</span><span class="s1">return { nationalNumber: number }</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">// Check the national (significant) number length after extracting national prefix and carrier code.</span><span class="s3">\r\n\t\t</span><span class="s1">// Legacy generated metadata (before `1.0.18`) didn't support the </span><span class="s3">\&quot;</span><span class="s1">possible lengths</span><span class="s3">\&quot; </span><span class="s1">feature.</span><span class="s3">\r\n\t\t</span><span class="s1">if (metadata.numberingPlan.possibleLengths()) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">// If an exact `country` is not specified, attempt to detect it from the assumed national number.</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (!country) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">country = getCountryByCallingCode(metadata.numberingPlan.callingCode(), {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">nationalNumber,</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">metadata</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">})</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t\t</span><span class="s1">// The number remaining after stripping the national prefix and carrier code</span><span class="s3">\r\n\t\t\t</span><span class="s1">// should be long enough to have a possible length for the country.</span><span class="s3">\r\n\t\t\t</span><span class="s1">// Otherwise, don't strip the national prefix and carrier code,</span><span class="s3">\r\n\t\t\t</span><span class="s1">// since the original number could be a valid number.</span><span class="s3">\r\n\t\t\t</span><span class="s1">// This check has been copy-pasted </span><span class="s3">\&quot;</span><span class="s1">as is</span><span class="s3">\&quot; </span><span class="s1">from Google's original library:</span><span class="s3">\r\n\t\t\t</span><span class="s1">// https://github.com/google/libphonenumber/blob/876268eb1ad6cdc1b7b5bef17fc5e43052702d57/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L3236-L3250</span><span class="s3">\r\n\t\t\t</span><span class="s1">// It doesn't check for the </span><span class="s3">\&quot;</span><span class="s1">possibility</span><span class="s3">\&quot; </span><span class="s1">of the original `number`.</span><span class="s3">\r\n\t\t\t</span><span class="s1">// I guess it's fine not checking that one. It works as is anyway.</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (!isPossibleIncompleteNationalNumber(nationalNumber, country, metadata)) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// Don't strip the national prefix.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">return { nationalNumber: number }</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">return { nationalNumber, carrierCode }</span><span class="s3">\r\n</span><span class="s1">}</span><span class="s3">\r\n\r\n</span><span class="s1">// In some countries, the same digit could be a national prefix</span><span class="s3">\r\n</span><span class="s1">// or a leading digit of a valid phone number.</span><span class="s3">\r\n</span><span class="s1">// For example, in Russia, national prefix is `8`,</span><span class="s3">\r\n</span><span class="s1">// and also `800 555 35 35` is a valid number</span><span class="s3">\r\n</span><span class="s1">// in which `8` is not a national prefix, but the first digit</span><span class="s3">\r\n</span><span class="s1">// of a national (significant) number.</span><span class="s3">\r\n</span><span class="s1">// Same's with Belarus:</span><span class="s3">\r\n</span><span class="s1">// `82004910060` is a valid national (significant) number,</span><span class="s3">\r\n</span><span class="s1">// but `2004910060` is not.</span><span class="s3">\r\n</span><span class="s1">// To support such cases (to prevent the code from always stripping</span><span class="s3">\r\n</span><span class="s1">// national prefix), a condition is imposed: a national prefix</span><span class="s3">\r\n</span><span class="s1">// is not extracted when the original number is </span><span class="s3">\&quot;</span><span class="s1">viable</span><span class="s3">\&quot; </span><span class="s1">and the</span><span class="s3">\r\n</span><span class="s1">// resultant number is not, a </span><span class="s3">\&quot;</span><span class="s1">viable</span><span class="s3">\&quot; </span><span class="s1">national number being the one</span><span class="s3">\r\n</span><span class="s1">// that matches `national_number_pattern`.</span><span class="s3">\r\n</span><span class="s1">function shouldHaveExtractedNationalPrefix(nationalNumberBefore, nationalNumberAfter, metadata) {</span><span class="s3">\r\n\t</span><span class="s1">// The equivalent in Google's code is:</span><span class="s3">\r\n\t</span><span class="s1">// https://github.com/google/libphonenumber/blob/e326fa1fc4283bb05eb35cb3c15c18f98a31af33/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L2969-L3004</span><span class="s3">\r\n\t</span><span class="s1">if (matchesEntirely(nationalNumberBefore, metadata.nationalNumberPattern()) &amp;&amp;</span><span class="s3">\r\n\t\t</span><span class="s1">!matchesEntirely(nationalNumberAfter, metadata.nationalNumberPattern())) {</span><span class="s3">\r\n\t\t</span><span class="s1">return false</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">// This </span><span class="s3">\&quot;</span><span class="s1">is possible</span><span class="s3">\&quot; </span><span class="s1">national number (length) check has been commented out</span><span class="s3">\r\n\t</span><span class="s1">// because it's superceded by the (effectively) same check done in the</span><span class="s3">\r\n\t</span><span class="s1">// `extractNationalNumber()` function after it calls `shouldHaveExtractedNationalPrefix()`.</span><span class="s3">\r\n\t</span><span class="s1">// In other words, why run the same check twice if it could only be run once.</span><span class="s3">\r\n\t</span><span class="s1">// // Check the national (significant) number length after extracting national prefix and carrier code.</span><span class="s3">\r\n\t</span><span class="s1">// // Fixes a minor </span><span class="s3">\&quot;</span><span class="s1">weird behavior</span><span class="s3">\&quot; </span><span class="s1">bug: https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/57</span><span class="s3">\r\n\t</span><span class="s1">// // (Legacy generated metadata (before `1.0.18`) didn't support the </span><span class="s3">\&quot;</span><span class="s1">possible lengths</span><span class="s3">\&quot; </span><span class="s1">feature).</span><span class="s3">\r\n\t</span><span class="s1">// if (metadata.possibleLengths()) {</span><span class="s3">\r\n\t</span><span class="s1">// </span><span class="s3">\t</span><span class="s1">if (isPossibleIncompleteNationalNumber(nationalNumberBefore, metadata) &amp;&amp;</span><span class="s3">\r\n\t</span><span class="s1">// </span><span class="s3">\t\t</span><span class="s1">!isPossibleIncompleteNationalNumber(nationalNumberAfter, metadata)) {</span><span class="s3">\r\n\t</span><span class="s1">// </span><span class="s3">\t\t</span><span class="s1">return false</span><span class="s3">\r\n\t</span><span class="s1">// </span><span class="s3">\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">// }</span><span class="s3">\r\n\t</span><span class="s1">return true</span><span class="s3">\r\n</span><span class="s1">}</span><span class="s3">\r\n\r\n</span><span class="s1">function isPossibleIncompleteNationalNumber(nationalNumber, country, metadata) {</span><span class="s3">\r\n\t</span><span class="s1">switch (checkNumberLength(nationalNumber, country, metadata)) {</span><span class="s3">\r\n\t\t</span><span class="s1">case 'TOO_SHORT':</span><span class="s3">\r\n\t\t</span><span class="s1">case 'INVALID_LENGTH':</span><span class="s3">\r\n\t\t</span><span class="s1">// This library ignores </span><span class="s3">\&quot;</span><span class="s1">local-only</span><span class="s3">\&quot; </span><span class="s1">phone numbers (for simplicity).</span><span class="s3">\r\n\t\t</span><span class="s1">// See the readme for more info on what are </span><span class="s3">\&quot;</span><span class="s1">local-only</span><span class="s3">\&quot; </span><span class="s1">phone numbers.</span><span class="s3">\r\n\t\t</span><span class="s1">// case 'IS_POSSIBLE_LOCAL_ONLY':</span><span class="s3">\r\n\t\t\t</span><span class="s1">return false</span><span class="s3">\r\n\t\t</span><span class="s1">default:</span><span class="s3">\r\n\t\t\t</span><span class="s1">return true</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n</span><span class="s1">}&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAAA,IAAAA,kDAAA,GAAAC,sBAAA,CAAAC,OAAA;AACA,IAAAC,gBAAA,GAAAF,sBAAA,CAAAC,OAAA;AACA,IAAAE,kBAAA,GAAAH,sBAAA,CAAAC,OAAA;AACA,IAAAG,wBAAA,GAAAJ,sBAAA,CAAAC,OAAA;AAAkE,SAAAD,uBAAAK,CAAA,WAAAA,CAAA,IAAAA,CAAA,CAAAC,UAAA,GAAAD,CAAA,gBAAAA,CAAA;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,SAASE,qBAAqBA,CAACC,MAAM,EAAEC,OAAO,EAAEC,QAAQ,EAAE;EACxE;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAAC,qBAAA,GAGI,IAAAC,6DAAiD,EACpDJ,MAAM,EACNE,QACD,CAAC;IALAG,WAAW,GAAAF,qBAAA,CAAXE,WAAW;IACXC,cAAc,GAAAH,qBAAA,CAAdG,cAAc;EAMf,IAAIA,cAAc,KAAKN,MAAM,EAAE;IAC9B,IAAI,CAACO,iCAAiC,CAACP,MAAM,EAAEM,cAAc,EAAEJ,QAAQ,CAAC,EAAE;MACzE;MACA,OAAO;QAAEI,cAAc,EAAEN;MAAO,CAAC;IAClC;IACA;IACA;IACA,IAAIE,QAAQ,CAACM,aAAa,CAACC,eAAe,CAAC,CAAC,EAAE;MAC7C;MACA,IAAI,CAACR,OAAO,EAAE;QACbA,OAAO,GAAG,IAAAS,mCAAuB,EAACR,QAAQ,CAACM,aAAa,CAACG,WAAW,CAAC,CAAC,EAAE;UACvEL,cAAc,EAAdA,cAAc;UACdJ,QAAQ,EAARA;QACD,CAAC,CAAC;MACH;;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAI,CAACU,kCAAkC,CAACN,cAAc,EAAEL,OAAO,EAAEC,QAAQ,CAAC,EAAE;QAC3E;QACA,OAAO;UAAEI,cAAc,EAAEN;QAAO,CAAC;MAClC;IACD;EACD;EAEA,OAAO;IAAEM,cAAc,EAAdA,cAAc;IAAED,WAAW,EAAXA;EAAY,CAAC;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,iCAAiCA,CAACM,oBAAoB,EAAEC,mBAAmB,EAAEZ,QAAQ,EAAE;EAC/F;EACA;EACA,IAAI,IAAAa,2BAAe,EAACF,oBAAoB,EAAEX,QAAQ,CAACc,qBAAqB,CAAC,CAAC,CAAC,IAC1E,CAAC,IAAAD,2BAAe,EAACD,mBAAmB,EAAEZ,QAAQ,CAACc,qBAAqB,CAAC,CAAC,CAAC,EAAE;IACzE,OAAO,KAAK;EACb;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,OAAO,IAAI;AACZ;AAEA,SAASJ,kCAAkCA,CAACN,cAAc,EAAEL,OAAO,EAAEC,QAAQ,EAAE;EAC9E,QAAQ,IAAAe,6BAAiB,EAACX,cAAc,EAAEL,OAAO,EAAEC,QAAQ,CAAC;IAC3D,KAAK,WAAW;IAChB,KAAK,gBAAgB;MACrB;MACA;MACA;MACC,OAAO,KAAK;IACb;MACC,OAAO,IAAI;EACb;AACD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>